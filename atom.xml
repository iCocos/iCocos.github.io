<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iCocos</title>
  
  <subtitle>www.icocos.cn</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://icocos.github.io/"/>
  <updated>2018-08-06T18:33:42.291Z</updated>
  <id>https://icocos.github.io/</id>
  
  <author>
    <name>曹理鹏@iCocos</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初识游戏——cocos2dx初探</title>
    <link href="https://icocos.github.io/2018/06/15/%E5%88%9D%E8%AF%86%E6%B8%B8%E6%88%8F%E2%80%94%E2%80%94cocos2dx%E5%88%9D%E6%8E%A2/"/>
    <id>https://icocos.github.io/2018/06/15/初识游戏——cocos2dx初探/</id>
    <published>2018-06-15T15:49:12.000Z</published>
    <updated>2018-08-06T18:33:42.291Z</updated>
    
    <content type="html"><![CDATA[<p>前端时间一直在忙项目，也提到了关于是一个AVG游戏项目，近期由于最新需求，需要开发iOS 游戏，之前做了这么久一直没有感觉到真正游戏或者游戏开发的存在，这一次，好像真的要步入游戏开发了。</p><p>所以整理了一下。</p><a id="more"></a><blockquote><p>具体概念和基本使用就不做介绍了，因为那些都太枯燥了，这里先说说整个环境搭建（以Mac为例），然后根据实际开发整理一些有意义的东西</p></blockquote><h5 id="先来看看官方"><a href="#先来看看官方" class="headerlink" title="先来看看官方"></a>先来看看官方</h5><p><a href="http://docs.cocos.com/cocos2d-x/manual/zh/" target="_blank" rel="noopener">http://docs.cocos.com/cocos2d-x/manual/zh/</a></p><h2 id="搭建开发环境-iOS"><a href="#搭建开发环境-iOS" class="headerlink" title="搭建开发环境 - iOS"></a>搭建开发环境 - iOS</h2><h4 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h4><pre><code>Cocos2d-x v3.17，下载后解压，下载参见：Cocos官网页面:http://www.cocos.com/downloadXcode 9 下载后安装，下载参见：Apple官网页面;https://developer.apple.com/download/more/或者前往App Store下载</code></pre><h4 id="配置步骤："><a href="#配置步骤：" class="headerlink" title="配置步骤："></a>配置步骤：</h4><ul><li><p>打开 cocos2d-x-3.17/build/cocos2d_tests.xcodeproj</p></li><li><p>在 Xcode 顶部工具栏选择 cpp-tests iOS，iPhone 7 Plus，点击运行，项目将自动编译运行，效果如图：</p></li></ul><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/000001.png" alt="曹理鹏(iCocos)-梦工厂"></p><h4 id="如何调试-Debug"><a href="#如何调试-Debug" class="headerlink" title="如何调试(Debug)"></a>如何调试(Debug)</h4><ul><li>点击代码行左侧的空白，设置断点</li><li>运行 cpp-tests</li></ul><p>操作 App 触发断点，IDE 将卡在断点处，视图会自动变化，左侧导航栏可以查看运行堆栈，底部窗口可以查看变量的值：</p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/000002.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>这里严格来说，其实不算是环境搭建，而是下载引擎，运行官方demo而已，那么下面我们开始简单的搭建一个实际项目，并后续从零开始做一个真正的游戏</p><h2 id="实际开发配置"><a href="#实际开发配置" class="headerlink" title="实际开发配置"></a>实际开发配置</h2><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><pre><code>登录Cocos2d-x 的官网 http://www.cocos2d-x.org点击download 下载最新的版本</code></pre><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/000003.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>点击超链接，将会下载得到一个Cocos2d-x-3.17.zip 压缩包</p><pre><code>将下载的压缩包进行解压，打开得到的文件夹，其结构目录如下</code></pre><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/000004.png" alt="曹理鹏(iCocos)-梦工厂"></p><ul><li>build :多平台下的架构文件存放的目录</li><li>cocos 框架核心目录 里面存放了Cocos2d-x的核心代码。</li><li>docs：文档目录 可以使用该目录下的doxygen.config 文件创建离线文档</li><li>extensions:扩展目录 存放了一些官方的扩展 包括更多图形用户界面的控制功能 网络访问 CocosBuilder 等</li><li>external：存放扩展需要用到的物理引擎 包括box2d和chipmunk</li><li>licenses: cocos2d依赖很多开源项目，所有的授权许可文件都在这个目录</li><li>plugin:plugin-x 项目目录，plugin -x  是一个可以快速接入第三方idk的框架</li><li>templates：该目录包括在不同集成环境及不同平台中创建Cocos2d-x 新项目的模板</li><li>test：测试项目 这是我们最开始用到的文件 在 cpp-tests 项目中包含所有类的用法 lua 和js 样本也在这个目录</li><li>tools： 需要用到的工具 Cocos2d-console 目录中包含了创建Cocos2d-x项目的脚本 可以针对不同的平台进行开发环境的搭建 同时 还包括将c++绑定至lua 及JavaScript 的脚本文件</li></ul><h4 id="Cocos2d-x的安装和配置"><a href="#Cocos2d-x的安装和配置" class="headerlink" title="Cocos2d-x的安装和配置"></a>Cocos2d-x的安装和配置</h4><p>Cocos2d-x 从2.1.4 版 之后已经不再支持使用模板来生成项目 而是使用官方提供的python 直接创建项目 也就是说Cocos2d-x 不能安装到Xcode上面，不能使用Xcode的Cocos2d-x模板一步一步的生成项目，只能使用Xcode来打开已经创建好的项目</p><h4 id="创建项目的步骤如下："><a href="#创建项目的步骤如下：" class="headerlink" title="创建项目的步骤如下："></a>创建项目的步骤如下：</h4><ul><li>打开终端 进入Cocos2d-x3.14 目录执行./setup.py  运行该文件用来 配置系统的一些环境变量</li></ul><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/000005.png" alt="曹理鹏(iCocos)-梦工厂"></p><ul><li>打开终端 执行Cocos new HelloCpp -p org.cocos2dx -l cpp -d codes</li></ul><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/000006.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>如果一切正常 则项目创建成功 关闭终端 再次进入Cocos2d-3.14目录这时候 会发现新建的codes目录</p><p>进入该目录发现新建的HelloCpp项目 进入proj.ios_mac 双击HelloCPP.xcodeproj 文件 使用快捷键（command+run）运行程序 就可以在iOS模拟器上看到经典的hello world 画面</p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/000007.png" alt="曹理鹏(iCocos)-梦工厂"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端时间一直在忙项目，也提到了关于是一个AVG游戏项目，近期由于最新需求，需要开发iOS 游戏，之前做了这么久一直没有感觉到真正游戏或者游戏开发的存在，这一次，好像真的要步入游戏开发了。&lt;/p&gt;
&lt;p&gt;所以整理了一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://icocos.github.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="https://icocos.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
      <category term="cocos2dx初探" scheme="https://icocos.github.io/tags/cocos2dx%E5%88%9D%E6%8E%A2/"/>
    
  </entry>
  
  <entry>
    <title>Golang——groutine和channel底层机制</title>
    <link href="https://icocos.github.io/2018/06/12/Golang%E2%80%94%E2%80%94groutine%E5%92%8Cchannel%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6/"/>
    <id>https://icocos.github.io/2018/06/12/Golang——groutine和channel底层机制/</id>
    <published>2018-06-12T15:49:12.000Z</published>
    <updated>2018-08-06T17:26:22.420Z</updated>
    
    <content type="html"><![CDATA[<p>goroutine, channel其实可以认为是golang中runtime的一部分，当然golang的runtime还包含Garbage collection，内存分配，垃圾回收，interfaces, maps,slices等一些高级功能</p><a id="more"></a><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><blockquote><p>我们知道Golang系统默认支持原始并发(加入协程与管道)，不想其他语言一样，需要写一堆的代码，还没有几个能写好的。</p></blockquote><p>Golang使用Groutine和channels实现了CSP(Communicating Sequential Processes)模型，channles负责goroutine通信。</p><h3 id="goroutinue"><a href="#goroutinue" class="headerlink" title="goroutinue"></a>goroutinue</h3><p>goroutine是Golang实现的用户空间的轻量级的线程，有runtime调度器调度，与操作系统的thread有多对一的关系</p><ul><li>goroutinue，本质上就是协程。但有两点不同：<ul><li>1.goroutinue可以实现并行，多个协程可以在多个处理器同时跑。而协程同一时刻只能在一个处理器上跑（把宿主语言想象成单线程的就好了）。</li><li>2.goroutine之间的通信是通过channel，而协程的通信是通过yield和resume()操作。</li></ul></li></ul><h4 id="goroutine-scheduler"><a href="#goroutine-scheduler" class="headerlink" title="goroutine scheduler"></a>goroutine scheduler</h4><p>goroutine scheduler 是Go runtime的一个重要的组成部分。他负责追踪，调度每个goroutine运行，实际上是从应用程序的process所属的thread pool中分配一个thread来执行这个goroutine。因此，和java虚拟机中的Java thread和OS thread映射概念类似，每个goroutine只有分配到一个OS thread才能运行。</p><h3 id="Chanel"><a href="#Chanel" class="headerlink" title="Chanel"></a>Chanel</h3><p>Channel是Go中的一个核心类型，你可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication)</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul><li>ch := make(chan Task, 3) // hchan（src/runtime/chan.go）</li></ul><p>创建channel时在该进程的heap申请一块内存，创建一个hchan结构体，返回执行该内存的指针(ch变量本身是一个指针，在函数间传递的时候是同一个channel)</p><p>channel使用一个唤醒队列保存groutine之间传递的数据，使用两个list保存goroutine(向该chan发生数据，从该chan接受数据),还有一个mutex保证操作安全</p><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><p>M是操作系统的线程，G是用户启动的goroutine，P是与调度相关的context，每个M都拥有一个P，P维护了一个能够运行的goutine队列，用于该线程执行。</p><h4 id="发生接受数据"><a href="#发生接受数据" class="headerlink" title="发生接受数据"></a>发生接受数据</h4><p>向channel发送和从channel接收数据主要涉及hchan里的四个成员变量</p><pre><code>buf(指向dataqsiz元素的数组)，sendx，recvx，lock(锁定保护HCHA中的所有字段)</code></pre><ul><li>初始化的时候hchan中buf为空，sendx，recvx为0：</li><li>向chan发生数据的时候，会对buf加锁，然后将要发生的数据copy到buf中，并sendx+1，最后释放buf的锁。</li><li>从chan接受数据的时候，会对buf加锁，然后将buf里面的数据copy到变量对应的内存，并recvx+1，最后释放buf的锁。</li></ul><p>底层通过hchan中的buf，使用copy内存的方式通讯，达到共享内存目的</p><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><ul><li>当想已满的chan发生数据，runtime检测到对应的hchan已经满了，会通知调度器，调度器将发送至置为waiting，移除与线程M的关系，<br>然后从P的runqueue中选择一个goroutine在线程M中执行，此时发送者处于阻塞状态，但是操作系统线程非阻塞，所以只消耗少量资源。</li><li>发送者阻塞后会创建一个自己的结构体sudog，然后放到sendq(发送阻塞列表：保存channel相关变量的指针，如发送或者接收数据的变量的地址&amp;copy)</li><li>从chan接收数据时，会通知调度器，将发送者状态设置为runnable，并且将其加入P的runqueue，等待线程执行</li></ul><blockquote><p>注意：如果接受者先运行，那么他会从一个空的chanl中取数据，这个时候会直接阻塞，通发送者阻塞一样，也会创建一个自己的结构体sudog，保存接收数据的变量的地址，<br>但是该sudog不是放在recvq(接收阻塞列表)，当再想chan发送数据的时候，runtime辟谷没有对hchan中buf加锁，而是直接将发送的数据copy到接收者的结构体sudog对应的elem指向的内存地址</p></blockquote><h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><p>goroutine, channel其实可以认为是golang中runtime的一部分，当然golang的runtime还包含Garbage collection，内存分配，垃圾回收，interfaces, maps,slices等一些高级功能</p><blockquote><p>1.4之前，runtime还是由C语言所编写的，官方计划，1.5版本将去除C的代码，runtime将完全由Go语言来完成，不论何种方式，runtime和用户编译后的代码被linker静态链接起来，形成一个可执行文件。这个文件从操作系统角度来说是一个user space的独立的可执行文件。</p></blockquote><p>从运行的角度来说，这个文件由2部分组成，一部分是用户的代码，另一部分就是runtime。runtime通过接口函数调用来管理goroutine, channel及其他一些高级的功能。从用户代码发起的调用操作系统API的调用都会被runtime拦截并处理。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><blockquote><p>goroutine的调度器是在线程之上的多路复用。channel的实现是仅仅的关联在调度器之上，compiler也是紧密的和goroutine调度器关联在一起，不仅仅创建goroutine，而且也管理着stack，防止stack溢出。goroutine是一个执行的stack+一个控制的struct。调度器分配goroutine在线程上执行，当一个线程阻塞了或者调用一个非Go的函数(CGO调用)，那么调度器就会开始一个新的线程来运行其他的goroutine.</p></blockquote><ul><li>推荐文章<ul><li><a href="https://blog.csdn.net/whatday/article/details/74453089" target="_blank" rel="noopener">https://blog.csdn.net/whatday/article/details/74453089</a></li><li><a href="https://blog.csdn.net/kongdefei5000/article/details/75209005" target="_blank" rel="noopener">https://blog.csdn.net/kongdefei5000/article/details/75209005</a></li><li><a href="https://www.zhihu.com/question/20862617" target="_blank" rel="noopener">https://www.zhihu.com/question/20862617</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;goroutine, channel其实可以认为是golang中runtime的一部分，当然golang的runtime还包含Garbage collection，内存分配，垃圾回收，interfaces, maps,slices等一些高级功能&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://icocos.github.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="https://icocos.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
      <category term="groutine和channel底层机制" scheme="https://icocos.github.io/tags/groutine%E5%92%8Cchannel%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Golang——Http服务初探</title>
    <link href="https://icocos.github.io/2018/06/07/Golang%E2%80%94%E2%80%94Http%E6%9C%8D%E5%8A%A1%E5%88%9D%E6%8E%A2/"/>
    <id>https://icocos.github.io/2018/06/07/Golang——Http服务初探/</id>
    <published>2018-06-07T15:49:12.000Z</published>
    <updated>2018-08-06T18:33:42.537Z</updated>
    
    <content type="html"><![CDATA[<p>这里开始之前，先来说说golang中http服务的内部机制(所有其他库都是在此基础延伸)</p><a id="more"></a><p>这里开始之前，先来说说golang中http服务中三个重要的方法(所有其他库都是在此基础延伸)</p><ul><li>func Handle<ul><li>func Handle(pattern string, handler Handler)<blockquote><p>Handle registers the handler for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched.</p></blockquote></li></ul></li><li>func HandleFunc<ul><li>func HandleFunc(pattern string, handler func(ResponseWriter, *Request))<blockquote><p>HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched.</p></blockquote></li></ul></li><li>func ListenAndServe<ul><li>func ListenAndServe(addr string, handler Handler) error<blockquote><p>ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Handler is typically nil, in which case the DefaultServeMux is used.</p></blockquote></li></ul></li></ul><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>ListenAndServe是用于在指定的TCP 网络地址addr 进行监听，然后调用服务端处理程序来处理传入的连<br>接请求。该方法有两个参数：第一个参数addr 即监听地址；第二个参数表示服务端处理程序，<br>通常为空，这意味着服务端调用 http.DefaultServeMux 进行处理，而服务端编写的业务逻<br>辑处理程序 http.Handle() 或 http.HandleFunc() 默认注入 http.DefaultServeMux 中</p></blockquote><p>下面以三种不同的方式实现最Golang中基本的Http Server</p><h2 id="默认方式"><a href="#默认方式" class="headerlink" title="默认方式"></a>默认方式</h2><p> 默认handler，处理路由注册</p><pre><code>//===================================Http 1===================================//func Http_Server1() {    http.HandleFunc(&quot;/&quot;, sayServer1)    err := http.ListenAndServe(&quot;:8080&quot;, nil)    if err != nil {        panic(err)    }}func sayServer1(w http.ResponseWriter, r *http.Request) {    io.WriteString(w,&quot;sayServer1 Http Service&quot;)}</code></pre><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/1.png" alt="曹理鹏(iCocos)-梦工厂"></p><h2 id="自定义方式"><a href="#自定义方式" class="headerlink" title="自定义方式"></a>自定义方式</h2><p>自己实现hander，注册到max中，在注册路由</p><pre><code>//===================================Http 2===================================//func Http_Server2() {    mux := http.NewServeMux()    mux.Handle(&quot;/&quot;, &amp;myHanlder{})    mux.HandleFunc(&quot;/hello&quot;, sayServer2)    err := http.ListenAndServe(&quot;:8080&quot;, mux)    if err != nil {        panic(err)    }}type myHanlder struct{}func (*myHanlder) ServeHTTP(w http.ResponseWriter, r *http.Request) {    io.WriteString(w,&quot;Http Service: &quot;+ r.URL.String())}func sayServer2(w http.ResponseWriter, r *http.Request) {    io.WriteString(w,&quot;sayServer2 Http Service&quot;)}</code></pre><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/20.png" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/21.png" alt="曹理鹏(iCocos)-梦工厂"></p><h2 id="底层拓展方式"><a href="#底层拓展方式" class="headerlink" title="底层拓展方式"></a>底层拓展方式</h2><p>底层实现路由注册，多用户封装</p><pre><code>//===================================Http 3===================================//var mux map[string]func(http.ResponseWriter, *http.Request) // 路由指定func Http_Server3() {    server := http.Server{        Addr:&quot;:8080&quot;,        Handler:&amp;mHandler{},        ReadTimeout:5*time.Second,    }     注册    mux = make(map[string]func(http.ResponseWriter, *http.Request))    mux[&quot;/hello&quot;] = sayServer3    mux[&quot;/golang&quot;] = golang    err := server.ListenAndServe()    if err != nil {        panic(err)    }}type mHandler struct {}func (*mHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {    if h,ok := mux[r.URL.String()]; ok {        h(w,r)        return    }    io.WriteString(w,&quot;Http Service Custome: &quot;+ r.URL.String())}func sayServer3(w http.ResponseWriter, r *http.Request) {    io.WriteString(w,&quot;sayServer3 Http Service&quot;)}func golang(w http.ResponseWriter, r *http.Request) {    io.WriteString(w,&quot;golang Http Service&quot;)}</code></pre><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/30.png" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/31.png" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/32.png" alt="曹理鹏(iCocos)-梦工厂"></p><h2 id="Beego你好世界"><a href="#Beego你好世界" class="headerlink" title="Beego你好世界"></a>Beego你好世界</h2><p>其实上面只是作为个简单的入门了解，一般实际开发中，那么做的还是不多，我们大部分都会选择使用第三方，比如PHP中的ThinkPHP，Yii，在Golang中也有几个不错的第三个可以使用，而且目前已经很成熟了，至少可以满足目前几乎大部分公司的业务需求<br>比如beego(国人开发)，gin，dotweb，echo这些都是笔者通过技术群或者网络热门程度了解到在Golang中还不错的的库，而且使用中和非常多。</p><p>这里我简单以beego作为案例尝试下，没有什么技术含量，勿喷</p><h4 id="下载安装-前提：配置GOPATH"><a href="#下载安装-前提：配置GOPATH" class="headerlink" title="下载安装(前提：配置GOPATH)"></a>下载安装(前提：配置GOPATH)</h4><pre><code>go get github.com/astaxie/beego</code></pre><h4 id="创建文件-hello-go"><a href="#创建文件-hello-go" class="headerlink" title="创建文件 hello.go"></a>创建文件 hello.go</h4><pre><code>//================================Hello World!!===============================//package mainimport &quot;github.com/astaxie/beego&quot;type HomeController struct {    beego.Controller}func (this *HomeController) Get() {    this.Ctx.WriteString(&quot;Hello World!!&quot;)}func Http_Hello() {    beego.Router(&quot;/&quot;, &amp;HomeController{})    beego.Run()}</code></pre><h4 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h4><pre><code>go build -o hello hello.go./hello</code></pre><h4 id="浏览效果"><a href="#浏览效果" class="headerlink" title="浏览效果"></a>浏览效果</h4><p>打开浏览器并访问 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/beego.png" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/0.png" alt="曹理鹏(iCocos)-梦工厂"></p><h2 id="关闭http服务"><a href="#关闭http服务" class="headerlink" title="关闭http服务"></a>关闭http服务</h2><p>在go1.8中新增了一个新特性，利用Shutdown(ctx context.Context) 优雅地关闭http服务。</p><p>Shutdown 将无中断的关闭正在活跃的连接，然后平滑的停止服务。处理流程如下：</p><pre><code>首先关闭所有的监听;然后关闭所有的空闲连接;然后无限期等待连接处理完毕转为空闲，并关闭;如果提供了 带有超时的Context，将在服务关闭前返回 Context的超时错误;</code></pre><p>利用这个特性改造一下v3版本的程序，实现一个关闭http的提示</p><pre><code>// 主动关闭服务器var server *http.Serverfunc main() {    // 一个通知退出的chan    quit := make(chan os.Signal)    signal.Notify(quit, os.Interrupt)    mux := http.NewServeMux()    mux.Handle(&quot;/&quot;, &amp;myHandler{})    mux.HandleFunc(&quot;/bye&quot;, sayBye)    server = &amp;http.Server{        Addr:         &quot;:1210&quot;,        WriteTimeout: time.Second * 4,        Handler:      mux,    }    go func() {        // 接收退出信号        &lt;-quit        if err := server.Close(); err != nil {            log.Fatal(&quot;Close server:&quot;, err)        }    }()    log.Println(&quot;Starting v3 httpserver&quot;)    err := server.ListenAndServe()    if err != nil {        // 正常退出        if err == http.ErrServerClosed {            log.Fatal(&quot;Server closed under request&quot;)        } else {            log.Fatal(&quot;Server closed unexpected&quot;, err)        }    }    log.Fatal(&quot;Server exited&quot;)}type myHandler struct{}func (*myHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {    w.Write([]byte(&quot;this is version 3&quot;))}// 关闭httpfunc sayBye(w http.ResponseWriter, r *http.Request) {    w.Write([]byte(&quot;bye bye ,shutdown the server&quot;))     // 没有输出    err := server.Shutdown(nil)    if err != nil {        log.([]byte(&quot;shutdown the server err&quot;))    }}</code></pre><p>尝试访问<a href="http://localhost:1210/bye" target="_blank" rel="noopener">http://localhost:1210/bye</a> 在控制台会得到以下提示结果，平滑关闭http服务成功:</p><p><a href="https://www.jianshu.com/p/be3d9cdc680b" target="_blank" rel="noopener">https://www.jianshu.com/p/be3d9cdc680b</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里开始之前，先来说说golang中http服务的内部机制(所有其他库都是在此基础延伸)&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://icocos.github.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="https://icocos.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Http服务初探" scheme="https://icocos.github.io/tags/Http%E6%9C%8D%E5%8A%A1%E5%88%9D%E6%8E%A2/"/>
    
  </entry>
  
  <entry>
    <title>Golang——文件IO处理</title>
    <link href="https://icocos.github.io/2018/06/03/Golang%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6IO%E5%A4%84%E7%90%86/"/>
    <id>https://icocos.github.io/2018/06/03/Golang——文件IO处理/</id>
    <published>2018-06-03T15:49:12.000Z</published>
    <updated>2018-08-06T18:33:42.532Z</updated>
    
    <content type="html"><![CDATA[<p>读写文件应该是在开发过程中经常遇到的，今天要跟大家一起分享的就是在golang的世界中，如何读写文件</p><a id="more"></a><p>读写文件应该是在开发过程中经常遇到的，今天简单看看golang的世界中，如何读写文件。</p><h3 id="读取文件方法速度比较"><a href="#读取文件方法速度比较" class="headerlink" title="读取文件方法速度比较"></a>读取文件方法速度比较</h3><pre><code>package mainimport (    &quot;bufio&quot;    &quot;fmt&quot;    &quot;io&quot;    &quot;io/ioutil&quot;    &quot;os&quot;    &quot;time&quot;)func read0(path string) string {    f, err := ioutil.ReadFile(path)    if err != nil {        fmt.Printf(&quot;%s\n&quot;, err)        panic(err)    }    return string(f)}func read1(path string) string {    fi, err := os.Open(path)    if err != nil {        panic(err)    }    defer fi.Close()    chunks := make([]byte, 1024, 1024)    buf := make([]byte, 1024)    for {        n, err := fi.Read(buf)        if err != nil &amp;&amp; err != io.EOF {        panic(err)    }    if 0 == n {        break    }        chunks = append(chunks, buf[:n]...)    }    return string(chunks)}func read2(path string) string {    fi, err := os.Open(path)    if err != nil {        panic(err)    }    defer fi.Close()    r := bufio.NewReader(fi)    chunks := make([]byte, 1024, 1024)    buf := make([]byte, 1024)    for {        n, err := r.Read(buf)        if err != nil &amp;&amp; err != io.EOF {            panic(err)        }        if 0 == n {            break        }        chunks = append(chunks, buf[:n]...)    }    return string(chunks)}func read3(path string) string {    fi, err := os.Open(path)    if err != nil {        panic(err)    }    defer fi.Close()    fd, err := ioutil.ReadAll(fi)    return string(fd)}func main() {    file := &quot;test.log&quot;    start := time.Now()    read0(file)    t0 := time.Now()    fmt.Printf(&quot;Cost time %v\n&quot;, t0.Sub(start))    read1(file)    t1 := time.Now()    fmt.Printf(&quot;Cost time %v\n&quot;, t1.Sub(t0))    read2(file)    t2 := time.Now()    fmt.Printf(&quot;Cost time %v\n&quot;, t2.Sub(t1))    read3(file)    t3 := time.Now()    fmt.Printf(&quot;Cost time %v\n&quot;, t3.Sub(t2))}</code></pre><p>运行结果对比：</p><pre><code>Cost time 4.0105msCost time 11.5043msCost time 7.0042msCost time 2.4983msCost time 4.4925msCost time 11.0053msCost time 5.0082msCost time 2.9992msCost time 3.9866msCost time 15.0085msCost time 7.5054msCost time 2.5035msCost time 4.9989msCost time 14.0112msCost time 7.5045msCost time 3.508msCost time 3.0043msCost time 15.0265msCost time 8.9884msCost time 2.0036ms</code></pre><h3 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h3><pre><code>//=================================== Files ===================================//func File_Server() {    mux := http.NewServeMux()    mux.Handle(&quot;/&quot;, &amp;fileHanlder{})    mux.HandleFunc(&quot;/hello&quot;, sayServer2)    wd, err := os.Getwd()    if err != nil {        panic(err)    }    mux.Handle(&quot;/static/&quot;, http.StripPrefix(&quot;/static/&quot;, http.FileServer(http.Dir(wd))))    err = http.ListenAndServe(&quot;:8080&quot;, mux)    if err != nil {        panic(err)    }}type fileHanlder struct{}func (*fileHanlder) ServeHTTP(w http.ResponseWriter, r *http.Request) {    io.WriteString(w,&quot;Http Service: &quot;+ r.URL.String())}func sayServer2(w http.ResponseWriter, r *http.Request) {    io.WriteString(w,&quot;sayServer2 Http Service&quot;)}</code></pre><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/file.png" alt="曹理鹏(iCocos)-梦工厂"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读写文件应该是在开发过程中经常遇到的，今天要跟大家一起分享的就是在golang的世界中，如何读写文件&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://icocos.github.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="https://icocos.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
      <category term="文件操作" scheme="https://icocos.github.io/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Go——Golang Response Snippets</title>
    <link href="https://icocos.github.io/2018/06/01/Go%E2%80%94%E2%80%94Golang-Response-Snippets/"/>
    <id>https://icocos.github.io/2018/06/01/Go——Golang-Response-Snippets/</id>
    <published>2018-06-01T15:49:12.000Z</published>
    <updated>2018-08-06T18:33:42.372Z</updated>
    
    <content type="html"><![CDATA[<p>做过后端开发的应该都知道，我们遇到最多的就是返回数据给客户端，就和客户端要搭界面一样，重复操作着，但是却有必不可少，今天我们来简单说说Golang Response Snippets</p><a id="more"></a><h5 id="Golang-Response-Snippets-JSON-XML-and-more"><a href="#Golang-Response-Snippets-JSON-XML-and-more" class="headerlink" title="Golang Response Snippets: JSON, XML and more"></a>Golang Response Snippets: JSON, XML and more</h5><blockquote><p>Taking inspiration from the Rails layouts and rendering guide, I thought it’d be a nice idea to build a snippet collection illustrating some common HTTP responses for Go web applications.</p></blockquote><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/response.png" alt="曹理鹏(iCocos)-梦工厂"></p><p><a href="https://www.alexedwards.net/blog/golang-response-snippets" target="_blank" rel="noopener">Golang Response Snippets</a></p><h2 id="只返回header"><a href="#只返回header" class="headerlink" title="只返回header"></a>只返回header</h2><p>对于一些请求而言，不需要返回任何的数据，只是返回一个header即可，大大提高了返回服务器响应速度。</p><p>先了解一下net/http包中的几个方法：</p><pre><code>//给一个key设定为响应的value.func (h Header) Set(key, value string)// WriteHeader该方法发送HTTP回复的头域和状态码。如果没有被显式调用，第一次调用Write时会触发隐式调用WriteHeader(http.StatusOK)。因此，显示调用WriterHeader主要用于发送错误状态码。WriteHeader(int) </code></pre><p>在使用的时候，我们可以这么做</p><pre><code>package mainimport (    &quot;net/http&quot;)func main() {    http.HandleFunc(&quot;/&quot;, foo)    http.ListenAndServe(&quot;:8080&quot;, nil)}func foo(w http.ResponseWriter, r *http.Request) {    w.Header().Set(&quot;Server&quot;, &quot;A Go Web Server&quot;)    w.WriteHeader(200)} </code></pre><h5 id="通过curl进行请求：curl-i-localhost-8080"><a href="#通过curl进行请求：curl-i-localhost-8080" class="headerlink" title="通过curl进行请求：curl -i localhost:8080"></a>通过curl进行请求：curl -i localhost:8080</h5><pre><code>curl -i localhost:8080HTTP/1.1 200 OKServer: A Go Web ServerDate: Mon, 29 Jan 2018 02:52:41 GMTContent-Length: 0Content-Type: text/plain; charset=utf-8 </code></pre><h2 id="返回文本"><a href="#返回文本" class="headerlink" title="返回文本"></a>返回文本</h2><p>这个不常用，但是也介绍一下而已。</p><p>用到的方法：</p><pre><code>// Write向连接中写入数据，该数据作为HTTP response的一部分。如果被调用时还没有调用WriteHeader，本方法会先调用WriteHeader(http.StatusOK)。//如果Header中没有&quot;Content-Type&quot;键，本方法会使用包函数DetectContentType检查数据的前512字节，将返回值作为该键的值Write([]byte) (int, error) </code></pre><h5 id="返回文本实际使用方法"><a href="#返回文本实际使用方法" class="headerlink" title="返回文本实际使用方法"></a>返回文本实际使用方法</h5><pre><code>package mainimport (    &quot;net/http&quot;)func main() {    http.HandleFunc(&quot;/&quot;, foo)    http.ListenAndServe(&quot;:8080&quot;, nil)}func foo(w http.ResponseWriter, r *http.Request) {    w.Write([]byte(&quot;I am Gopher&quot;))} </code></pre><h5 id="通过curl进行请求：curl-i-localhost-8080-1"><a href="#通过curl进行请求：curl-i-localhost-8080-1" class="headerlink" title="通过curl进行请求：curl -i localhost:8080"></a>通过curl进行请求：curl -i localhost:8080</h5><pre><code>curl -i localhost:8080HTTP/1.1 200 OKDate: Mon, 29 Jan 2018 03:02:00 GMTContent-Length: 11Content-Type: text/plain; charset=utf-8I am Gopher </code></pre><h2 id="返回JSON"><a href="#返回JSON" class="headerlink" title="返回JSON"></a>返回JSON</h2><p>Go语言里的标准库”encoding/json”</p><p>转换对应表：</p><pre><code>bool类型 转换成JSON中的boolean整型，浮点型转换成JSON中的Number字符串转换成JSON中的字符串（&quot;&quot;而不是&apos;&apos;）结构体转换成JSON中的Object[]byte 会先base64然后转换成JSON中的字符串（&quot;&quot;而不是&apos;&apos;）map 转换成JSON中的Objectinterface{} 会按内部的类型进行实际转换nil 会转换成JSON中的Null</code></pre><p>encodeing/json几乎常用的就两个方法：</p><pre><code>func Marshal(v interface{}) ([]byte, error)func Unmarshal(data []byte, v interface{}) error</code></pre><p>顾名思义“Marshal”将Go对象进行转换成JSON，而”Unmarshal”则是将JSON转换成Go对象。</p><pre><code>package mainimport (    &quot;encoding/json&quot;    &quot;net/http&quot;) // 为了对应关系可以一一对应上，我们需要手动的为结构体打上Tag，才能转换到正确的JSON // structTag还有一些其他有用的属性，比如： //     omitempty 如果JSON字段为空则忽略 //     - 直接忽略 type Profile struct {    Name    string   `json:&quot;name&quot;`    Hobbies []string `json:&quot;hobbies&quot;`}func main() {    http.HandleFunc(&quot;/&quot;, foo)    http.ListenAndServe(&quot;:8080&quot;, nil)}func foo(w http.ResponseWriter, r *http.Request) {    profile := Profile{&quot;SuperWang&quot;, []string{&quot;football&quot;, &quot;programming&quot;}}    js, err := json.Marshal(profile)    if err != nil {        http.Error(w, err.Error(), http.StatusInternalServerError)        return    }    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)    w.Write(js)} </code></pre><p>有时候你想更灵活的使用JSON，这个时候就要用到json.RawMessage，多数情况下，我们不会使用到它。在JSON中，有一个字段的格式是未知的，比如可能是string，也可能是int，那么这个时候就要用到*json.RawMessage了。</p><p>不过在转换的过程中，如果我们定义的是结构体，跟Map会有一些不同，以下几点是要注意的：</p><pre><code>结构体的成员必须是大写开头使用Marshal时会按结构体成员的变量名做为KeyUnmarshal时会自动匹配结构体成员，大小写不敏感，如果JSON中有多余字段，会直接抛弃，如果缺少某个字段，则会忽略对结构体成员赋值</code></pre><h5 id="通过curl进行请求：curl-i-localhost-8080-2"><a href="#通过curl进行请求：curl-i-localhost-8080-2" class="headerlink" title="通过curl进行请求：curl -i localhost:8080"></a>通过curl进行请求：curl -i localhost:8080</h5><pre><code>curl -i localhost:8080HTTP/1.1 200 OKContent-Type: application/jsonDate: Mon, 29 Jan 2018 03:10:52 GMTContent-Length: 57{&quot;name&quot;:&quot;SuperWang&quot;,&quot;hobbies&quot;:[&quot;football&quot;,&quot;programming&quot;]}</code></pre><h2 id="返回XML"><a href="#返回XML" class="headerlink" title="返回XML"></a>返回XML</h2><p>很久之前，很多人讨论xml和json孰是孰非，渐渐地xml越来越被人们遗忘。<br>但是一些接口还是需要使用xml的，比如xmpp协议。</p><pre><code>package mainimport (    &quot;encoding/xml&quot;    &quot;net/http&quot;)type Profile struct {    Name    string    Hobbies []string `xml:&quot;Hobbies&gt;Hobby&quot;`}func main() {    http.HandleFunc(&quot;/&quot;, foo)    http.ListenAndServe(&quot;:8080&quot;, nil)}func foo(w http.ResponseWriter, r *http.Request) {    profile := Profile{&quot;SuperWang&quot;, []string{&quot;football&quot;, &quot;programming&quot;}}    x, err := xml.MarshalIndent(profile, &quot;&quot;, &quot;  &quot;)    if err != nil {        http.Error(w, err.Error(), http.StatusInternalServerError)        return    }    w.Header().Set(&quot;Content-Type&quot;, &quot;application/xml&quot;)    w.Write(x)} </code></pre><p>通过curl进行请求：curl -i localhost:8080</p><pre><code>curl -i localhost:8080HTTP/1.1 200 OKContent-Type: application/xmlDate: Mon, 29 Jan 2018 03:16:00 GMTContent-Length: 129&lt;Profile&gt;  &lt;Name&gt;SuperWang&lt;/Name&gt;  &lt;Hobbies&gt;    &lt;Hobby&gt;football&lt;/Hobby&gt;    &lt;Hobby&gt;programming&lt;/Hobby&gt;  &lt;/Hobbies&gt;&lt;/Profile&gt; </code></pre><h2 id="返回文件"><a href="#返回文件" class="headerlink" title="返回文件"></a>返回文件</h2><p>通过接口，返回一张图片，一个文本文件等等，都是很常见的。</p><pre><code>package mainimport (    &quot;net/http&quot;    &quot;path&quot;)func main() {    http.HandleFunc(&quot;/&quot;, foo)    http.ListenAndServe(&quot;:8080&quot;, nil)}func foo(w http.ResponseWriter, r *http.Request) {    fp := path.Join(&quot;images&quot;, &quot;foo.png&quot;)    http.ServeFile(w, r, fp)} </code></pre><p>建一个images文件夹，放入foo.png文件，运行，</p><h5 id="运行，浏览器输入："><a href="#运行，浏览器输入：" class="headerlink" title="运行，浏览器输入："></a>运行，浏览器输入：</h5><ul><li><a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></li></ul><h2 id="返回HTML"><a href="#返回HTML" class="headerlink" title="返回HTML"></a>返回HTML</h2><p>下面是返回一个HTML的网页。</p><pre><code>package mainimport (    &quot;html/template&quot;    &quot;net/http&quot;    &quot;path&quot;)type Profile struct {    Name    string    Hobbies []string}func main() {    http.HandleFunc(&quot;/&quot;, foo)    http.ListenAndServe(&quot;:8080&quot;, nil)}func foo(w http.ResponseWriter, r *http.Request) {    profile := Profile{&quot;SpuerWang&quot;, []string{&quot;snowboarding&quot;, &quot;programming&quot;}}    fp := path.Join(&quot;templates&quot;, &quot;index.html&quot;)    tmpl, err := template.ParseFiles(fp)    if err != nil {        http.Error(w, err.Error(), http.StatusInternalServerError)        return    }    if err := tmpl.Execute(w, profile); err != nil {        http.Error(w, err.Error(), http.StatusInternalServerError)    }} </code></pre><p>新建文件夹templates，在里面新建文件inde.html:</p><pre><code>&lt;h1&gt;Title {{ .Name }}&lt;/h1&gt;&lt;p&gt;.....&lt;/p&gt;</code></pre><h5 id="运行，浏览器输入：-1"><a href="#运行，浏览器输入：-1" class="headerlink" title="运行，浏览器输入："></a>运行，浏览器输入：</h5><ul><li><a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做过后端开发的应该都知道，我们遇到最多的就是返回数据给客户端，就和客户端要搭界面一样，重复操作着，但是却有必不可少，今天我们来简单说说Golang Response Snippets&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://icocos.github.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="https://icocos.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Response" scheme="https://icocos.github.io/tags/Response/"/>
    
  </entry>
  
  <entry>
    <title>Go——简单说说goroutine和channel</title>
    <link href="https://icocos.github.io/2018/05/29/Go%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4goroutine%E5%92%8Cchannel/"/>
    <id>https://icocos.github.io/2018/05/29/Go——简单说说goroutine和channel/</id>
    <published>2018-05-29T15:41:55.000Z</published>
    <updated>2018-08-06T17:26:22.452Z</updated>
    
    <content type="html"><![CDATA[<p>Go 语言中的 channel 是实现  goroutine 间无锁通信的关键机制，他使得写多线程并发程序变得简单、灵活、触手可得，今天我们来简单说说goroutine和channel</p><a id="more"></a><h4 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h4><ul><li>Go 语言中的 channel 是实现  goroutine 间无锁通信的关键机制，他使得写多线程并发程序变得简单、灵活、触手可得</li></ul><p>channel是消息传递的机制，用于多线程环境下lock free synchronization.</p><ul><li>它同时具备2个特性：<ol><li>消息传递</li><li>同步</li></ol></li></ul><ul><li>参考文章：<ul><li><a href="https://blog.csdn.net/kongdefei5000/article/details/75209005" target="_blank" rel="noopener">https://blog.csdn.net/kongdefei5000/article/details/75209005</a></li><li><a href="https://blog.csdn.net/nobugtodebug/article/details/45396507" target="_blank" rel="noopener">https://blog.csdn.net/nobugtodebug/article/details/45396507</a></li></ul></li></ul><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><blockquote><p>channel 分类： 不带缓存 channel， 带缓存 channel</p></blockquote><p>无缓冲的与有缓冲channel有着重大差别，那就是一个是同步的 一个是非同步的。</p><pre><code>c1:=make(chan int)         无缓冲c2:=make(chan int,1)      有缓冲c1&lt;-1</code></pre><ul><li>无缓冲： 不仅仅是向 c1 通道放 1，而是一直要等有别的携程 &lt;-c1 接手了这个参数，那么c1&lt;-1才会继续下去，要不然就一直阻塞着。</li><li>有缓冲： c2&lt;-1 则不会阻塞，因为缓冲大小是1(其实是缓冲大小为0)，只有当放第二个值的时候，第一个还没被人拿走，这时候才会阻塞。</li></ul><h5 id="不带缓存-channel"><a href="#不带缓存-channel" class="headerlink" title="不带缓存 channel"></a>不带缓存 channel</h5><pre><code>（a）创建channel    make(chan type)    e.g.   ch := make(chan int)（b）通信方式(由于chan操作类似于Queue，为便于理解这里用EnQueue,DeQueue来描述通信操作)    EnQueue:    ch &lt;- typevar        DeQueue:   var :=  &lt;- ch    e.g.    ch &lt;- 1    v := &lt;-ch</code></pre><ul><li>关键：<ul><li>调用channel EnQueue 操作之后被阻塞住（不管channel是否为空），直到写的数据被读取掉。</li><li>调用channel DeQueue 操作时，如果channel中有数据则被读出，如果为空则阻塞住，直到有人往里面EnQueue数据。</li></ul></li></ul><h5 id="带缓存-channel"><a href="#带缓存-channel" class="headerlink" title="带缓存 channel"></a>带缓存 channel</h5><pre><code>（a）创建channel    make(chan type, size)    e.g.  ch := make(chan int, 9)（b）通信方式    同不带缓存channel</code></pre><ul><li>关键：<ul><li>当channel中元素小于等于channel size时，调用channel EnQueue 操作后数据被放入到缓存中（非阻塞）；</li><li>当channel满以后，如果再调用EnQueue操作就会被阻塞住直到有元素被DeQueue出来。</li><li>调用channel DeQueue 操作时，如果channel 为空则阻塞住直到有人往里面EnQueue数据，否则直接DeQueue出元素。</li></ul></li></ul><blockquote><p>注意: </p></blockquote><blockquote><p>需要特别注意的是两者对于range操作的区别：</p></blockquote><blockquote><p>无缓存channel是EnQueue一个数据被range读一个；</p></blockquote><blockquote><p>而带缓存channel是EnQueue满之后被range整个一起拿出来用(这个机制对于用户是透明的，用户看到的还是一个一个拿出来)，或者timeout时间到之后即使channel没有满也会被range拿出来。</p></blockquote><blockquote><p>另外，channel 关闭之后，循环读channel操作(e.g. for v:=range channel) 读完channel中剩余数据会自动跳出循环。</p></blockquote><ul><li>参考网络介绍：</li></ul><blockquote><p>顾名思义，就是通道。通道的目的是用来传递数据。在一个通道上我们可以执行数据的发送(Send)和接受(Receive)操作。对于非缓冲的 channel 而言，Receive 方法执行时，会判断该通道上是否有值，如果没有就会等待(阻塞)，直到有一个值为止。同样，在 channel 上有值，而尚未被一个 Receiver 接受的时候，Send 方法也会阻塞，直到 Channel 变空。这样，通过一个简单的机制就可以保证 Send 和 Receive 总是在不同的时间执行的，而且只有 Send 之后才能 Receive. 这样就避免了常规的多线程编程中数据共享的问题。正如 Go 语言的文档一句话所说：</p></blockquote><blockquote><p>Do not communicate by sharing memory; instead, share memory by communicating.</p></blockquote><blockquote><p>不要通过共享内存来沟通;而是通过沟通来共享内存。</p></blockquote><blockquote><p>在常规的多线程编程里，我们总是定义好一些类变量，如果这些变量有可能被多个线程同时访问，那么就需要加锁。这样带来了一定的编程复杂性，如果代码写的稍有bug，则会导致读/写到错误的值。</p></blockquote><blockquote><p>而通过 channel 来沟通，我们得到了一个更为清晰的沟通方式。两个线程(或者 goroutine)要读写相同的数据，则创建一个通道，双方通过对这个通道执行 Send / Receive 的操作来设值或取值即可，相对而言，比较不容易出错。</p></blockquote><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><ul><li>goroutine的并发模型定义为以下几个要点：<ul><li>基于Thread的轻量级协程</li><li>通过channel来进行协程间的消息传递</li><li>只暴露协程，屏蔽线程操作的接口</li></ul></li></ul><h4 id="goroutine原理"><a href="#goroutine原理" class="headerlink" title="goroutine原理"></a>goroutine原理</h4><blockquote><p>Golang的runtime实现了goroutine和OS thread的M:N模型，因此实际的goroutine是基于线程的更加轻量级的实现，我们便可以在Golang中大量创建goroutine而不用担心昂贵的context swtich所带来的开销。goroutine之间，我们可以通过channel来进行交互。由于go已将将所有system call都wrap到了标准库中，在针对这些systemcall进行调用时会主动标记goroutine为阻塞状态并保存现场，交由scheduler执行。所以在golang中，在大部分情况下我们可以非常安心地在goroutine中使用阻塞操作而不用担心并发性受到影响。</p></blockquote><p>在操作系统的OS Thread和编程语言的User Thread之间，实际上存在3中线程对应模型，也就是：1:1，1:N，M:N。</p><ul><li>N:1是说，多个（N）用户线程始终在一个内核线程上跑，context上下文切换确实很快，但是无法真正的利用多核。</li><li>1:1是说，一个用户线程就只在一个内核线程上跑，这时可以利用多核，但是上下文switch很慢，频繁切换效率很低。</li><li>M:N是说， 多个goroutine在多个内核线程上跑，这个看似可以集齐上面两者的优势，但是无疑增加了调度的难度。</li></ul><p>goroutine google runtime默认的实现为M:N的模型，于是这样可以根据具体的操作类型（操作系统阻塞或非阻塞操作）调整goroutine和OS Thread的映射情况，显得更加的灵活。</p><h5 id="在goroutine实现中，有三个最重要的数据结构，分别为G-M-P："><a href="#在goroutine实现中，有三个最重要的数据结构，分别为G-M-P：" class="headerlink" title="在goroutine实现中，有三个最重要的数据结构，分别为G M P："></a>在goroutine实现中，有三个最重要的数据结构，分别为G M P：</h5><pre><code>G：代表一个goroutineM：代表 一个OS ThreadP：一个P和一个M进行绑定，代表在这个OS Thread上的调度器</code></pre><blockquote><p>goroutine - 可以大致理解为一种轻量级的线程(或微线程)，它是一种“分配在同一个地址空间内的，能够并行执行的函数”。同时，它是轻量级的，不需要像分配线程那样分配独立的栈空间。所以理论上讲，我们可以很容易的分配很多个 goroutine, 让它们并发执行，而其开销则比多线程程序要小得多，从而可以让程序支持比较大的并发性。</p></blockquote><h5 id="goroutinue，本质上就是协程。但有两点不同："><a href="#goroutinue，本质上就是协程。但有两点不同：" class="headerlink" title="goroutinue，本质上就是协程。但有两点不同："></a>goroutinue，本质上就是协程。但有两点不同：</h5><ol><li>goroutinue可以实现并行，也就是说，多个协程可以在多个处理器同时跑。而协程同一时刻只能在一个处理器上跑（把宿主语言想象成单线程的就好了）。</li><li>goroutine之间的通信是通过channel，而协程的通信是通过yield和resume()操作。</li></ol><h5 id="那么如果有两个A-B两个协程-在放入和取出数据时都只能用int类型的数据进行通信"><a href="#那么如果有两个A-B两个协程-在放入和取出数据时都只能用int类型的数据进行通信" class="headerlink" title="那么如果有两个A,B两个协程 在放入和取出数据时都只能用int类型的数据进行通信"></a>那么如果有两个A,B两个协程 在放入和取出数据时都只能用int类型的数据进行通信</h5><ul><li>如 取数据 &lt;- channel 放数据 channel &lt;- 1</li></ul><blockquote><p>协程之间可以通过在通道中放入-取出数据的方式进行通信</p></blockquote><h2 id="3种优雅的Go-channel用法"><a href="#3种优雅的Go-channel用法" class="headerlink" title="3种优雅的Go channel用法"></a>3种优雅的Go channel用法</h2><p>写Go的人应该都听过Rob Pike的这句话</p><pre><code>Do not communicate by sharing memory; instead, share memory by communicating.</code></pre><p>相信很多朋友和我一样，在实际应用中总感觉不到好处，为了用channel而用。但以我的切身体会来说，这是写代码时碰到的场景不复杂、对channel不熟悉导致的，所以希望这篇文章能给大家带来点新思路，对Golang优雅的channel有更深的认识 ：）</p><h3 id="Fan-In-Out"><a href="#Fan-In-Out" class="headerlink" title="Fan In/Out"></a>Fan In/Out</h3><p>数据的输出有时候需要做扇出／入（FanIn／Out），但是在函数中调用常常得修改接口，而且上下游对于数据的依赖程度非常高，所以一般使用通过channel进行Fan In／Out，这样就可以轻易实现类似于shell里的管道。</p><pre><code>func fanIn(input1, input2 &lt;-chan string) &lt;-chan string {    c := make(chan string)    go func() {        for {            select {                case s := &lt;-input1:  c &lt;- s                case s := &lt;-input2:  c &lt;- s            }        }    }()    return c}</code></pre><h3 id="同步Goroutine"><a href="#同步Goroutine" class="headerlink" title="同步Goroutine"></a>同步Goroutine</h3><p>两个goroutine之间同步状态，例如A goroutine需要让B goroutine退出，一般做法如下：</p><pre><code>func main() {    g = make(chan int)    quit = make(chan bool)    go B()    for i := 0; i &lt; 3; i++ {        g &lt;- i    }    quit &lt;- true // 没办法等待B的退出只能Sleep    fmt.Println(&quot;Main quit&quot;)}func B() {    for {        select {            case i := &lt;-g:            fmt.Println(i + 1)            case &lt;-quit:            fmt.Println(&quot;B quit&quot;)            return        }    }}</code></pre><h5 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h5><pre><code>/*Output:123Main quit*/</code></pre><p>可是了main函数没办法等待B合适地退出，所以B quit 没办法打印，程序直接退出了。然而，chan是Go里的第一对象，所以可以把chan传入chan中，所以上面的代码可以把quit 定义为chan chan bool，以此控制两个goroutine的同步</p><pre><code>func main() {    g = make(chan int)    quit = make(chan chan bool)    go B()    for i := 0; i &lt; 5; i++ {        g &lt;- i    }    wait := make(chan bool)    quit &lt;- wait    &lt;-wait //这样就可以等待B的退出了    fmt.Println(&quot;Main Quit&quot;)}func B() {    for {        select {            case i := &lt;-g:            fmt.Println(i + 1)            case c := &lt;-quit:            c &lt;- true            fmt.Println(&quot;B Quit&quot;)            return        }    }}</code></pre><h5 id="Log-1"><a href="#Log-1" class="headerlink" title="Log"></a>Log</h5><pre><code>/* Output123B QuitMain Quit*/</code></pre><h3 id="分布式递归调用"><a href="#分布式递归调用" class="headerlink" title="分布式递归调用"></a>分布式递归调用</h3><p>在现实生活中，如果你要找美国总统聊天，你会怎么做？第一步打电话给在美国的朋友，然后他们也会发动自己的关系网，再找可能认识美国总统的人，以此类推，直到找到为止。这在Kadmelia分布式系统中也是一样的，如果需要获取目标ID信息，那么就不停地查询，被查询节点就算没有相关信息，也会返回它觉得最近节点，直到找到ID或者等待超时。 好了，这个要用Go来实现怎么做呢？</p><pre><code>func recursiveCall(ctx context.Context, id []byte, initialNodes []*node){    seen := map[string]*node{} //已见过的节点记录    request := make(chan *node, 3) //设置请求节点channel    // 输入初始节点    go func() {        for _, n := range initialNodes {            request &lt;- n        }    }()    OUT:    for {        //循环直到找到数据        if data != nil {            return        }        // 在新的请求，超时和上层取消请求中select        select {            case n := &lt;-request:            go func() {                // 发送新的请求                response := s.sendQuery(ctx, n, MethodFindValue, id)                select {                    case &lt;-ctx.Done():                    case msg :=&lt;-response:                    seen[responseToNode(response)] = n //更新已见过的节点信息                    // 加载新的节点                    for _, rn := range LoadNodeInfoFromByte(msg[PayLoadStart:]) {                        mu.Lock()                        _, ok := seen[rn.HexID()]                        mu.Unlock()                        // 见过了，跳过这个节点                        if ok {                            continue                        }                        AddNode(rn)                        // 将新的节点送入channel                        request &lt;- rn                        }                    }                }            }()            case &lt;-time.After(500 * time.Millisecond):            break OUT // break至外层，否则仅仅是跳至loop外            case &lt;-ctx.Done():            break OUT        }    }    return}</code></pre><p>这时的buffered channel类似于一个局部queue，对需要的节点进行处理，但这段代码的精妙之处在于，这里的block操作是select的，随时可以取消，而不是要等待或者对queue的长度有认识。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go 语言中的 channel 是实现  goroutine 间无锁通信的关键机制，他使得写多线程并发程序变得简单、灵活、触手可得，今天我们来简单说说goroutine和channel&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://icocos.github.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="https://icocos.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
      <category term="goroutine和channel" scheme="https://icocos.github.io/tags/goroutine%E5%92%8Cchannel/"/>
    
  </entry>
  
  <entry>
    <title>Go——函数与方法的奇妙之处</title>
    <link href="https://icocos.github.io/2018/05/25/Go%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95%E7%9A%84%E5%A5%87%E5%A6%99%E4%B9%8B%E5%A4%84/"/>
    <id>https://icocos.github.io/2018/05/25/Go——函数与方法的奇妙之处/</id>
    <published>2018-05-25T14:44:39.000Z</published>
    <updated>2018-08-06T17:26:22.335Z</updated>
    
    <content type="html"><![CDATA[<p>有过（面向对象）编程经验的应该都知道方法或者函数，比如在C，PHP，swift，OC，Java，kotlin等都有函数或者方法的存在，或者有二者的存在，只是有些人没有太过留意，比如PHP中就有这样的现象，而iOS中除了存在方法和行数，方法还分类方法和对象方法。</p><a id="more"></a><p>有过（面向对象）编程经验的应该都知道方法或者函数，比如在C，PHP，swift，OC，Java，kotlin等都有函数或者方法的存在，或者有二者的存在，只是有些人没有太过留意，比如PHP中就有这样的现象，而iOS中除了存在方法和行数，方法还分类方法和对象方法。</p><blockquote><p>那么Golang中方法和行数的本质意义其实差不多，只是定义和使用的语法不同而已。</p></blockquote><p>这里我们就来说说Golang中函数与方法，</p><h2 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h2><h5 id="行数定义"><a href="#行数定义" class="headerlink" title="行数定义"></a>行数定义</h5><pre><code>func function_name( [parameter list] ) [return_types]{   body of the function}</code></pre><h5 id="不允许函数内嵌定义"><a href="#不允许函数内嵌定义" class="headerlink" title="不允许函数内嵌定义"></a>不允许函数内嵌定义</h5><pre><code>func main() {    func swap(x, y string) (string, string) {    return y, x    }}</code></pre><h5 id="支持多返回值、支持命名返回值"><a href="#支持多返回值、支持命名返回值" class="headerlink" title="支持多返回值、支持命名返回值"></a>支持多返回值、支持命名返回值</h5><pre><code>func split(sum int) (x, y int) {    return}</code></pre><h5 id="函数只能判断是否为nil"><a href="#函数只能判断是否为nil" class="headerlink" title="函数只能判断是否为nil"></a>函数只能判断是否为nil</h5><pre><code>fmt.Println(add == nil)//fmt.Println(add == 1)  //错误 mismatched types func(int, int) int and int)</code></pre><h5 id="参数视为局部变量，因此不能声明同名变量"><a href="#参数视为局部变量，因此不能声明同名变量" class="headerlink" title="参数视为局部变量，因此不能声明同名变量"></a>参数视为局部变量，因此不能声明同名变量</h5><pre><code>func add(a, b int) int {    a := 2}</code></pre><h5 id="不支持默认参数、已”-”命名的参赛也不能忽略"><a href="#不支持默认参数、已”-”命名的参赛也不能忽略" class="headerlink" title="不支持默认参数、已”_”命名的参赛也不能忽略"></a>不支持默认参数、已”_”命名的参赛也不能忽略</h5><pre><code>func add(a, b int, _ bool) int {    return a + b}func main() {    fmt.Println(add(1,2, true))    //fmt.Println(add(1,2) // 错误：not enough arguments in call to add}</code></pre><h5 id="支持可变参数"><a href="#支持可变参数" class="headerlink" title="支持可变参数"></a>支持可变参数</h5><pre><code>func test(str string, a ...int) {    fmt.Println(&quot;%T, %v\n&quot;, str, a)}func main() {    test(&quot;a&quot;, 1, 2, 3)}</code></pre><h5 id="可以在函数内定义匿名函数"><a href="#可以在函数内定义匿名函数" class="headerlink" title="可以在函数内定义匿名函数"></a>可以在函数内定义匿名函数</h5><pre><code>func main() {    func (s string) {        fmt.Println(s)    } (&quot;hello, go!&quot;)}</code></pre><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><pre><code>// This function `intSeq` returns another function, which// we define anonymously in the body of `intSeq`. The// returned function _closes over_ the variable `i` to// form a closure.func intSeq() func() int {    i := 0    return func() int {        i += 1        return i    }}func main() {    // We call `intSeq`, assigning the result (a function)    // to `nextInt`. This function value captures its    // own `i` value, which will be updated each time    // we call `nextInt`.    nextInt := intSeq()    // See the effect of the closure by calling `nextInt`    // a few times.    fmt.Println(nextInt())    fmt.Println(nextInt())    fmt.Println(nextInt())    // To confirm that the state is unique to that    // particular function, create and test a new one.    newInts := intSeq()    fmt.Println(newInts())}</code></pre><ul><li>注意<ul><li>函数的左花括号也不能另起一行</li><li>不支持函数重载</li></ul></li></ul><h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h2><h5 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h5><pre><code>func (r Recevier) function_name(){   body of the method}</code></pre><h5 id="定义和使用："><a href="#定义和使用：" class="headerlink" title="定义和使用："></a>定义和使用：</h5><pre><code>type Vertex struct {    X, Y float64}func (v Vertex) Abs() float64 {    return math.Sqrt(v.X*v.X + v.Y*v.Y)}func main() {    v := Vertex{3, 4}    fmt.Println(v.Abs())}</code></pre><h5 id="下面来仔细看看官方对方法给出的一个例子"><a href="#下面来仔细看看官方对方法给出的一个例子" class="headerlink" title="下面来仔细看看官方对方法给出的一个例子"></a>下面来仔细看看官方对方法给出的一个例子</h5><pre><code>package mainimport &quot;fmt&quot;type rect struct {    width, height int}// This `area` method has a _receiver type_ of `*rect`.func (r *rect) area() int {    return r.width * r.height}// Methods can be defined for either pointer or value// receiver types. Here&apos;s an example of a value receiver.func (r rect) perim() int {    return 2*r.width + 2*r.height}func main() {    r := rect{width: 10, height: 5}    // Here we call the 2 methods defined for our struct.    fmt.Println(&quot;area: &quot;, r.area())    fmt.Println(&quot;perim:&quot;, r.perim())    // Go automatically handles conversion between values    // and pointers for method calls. You may want to use    // a pointer receiver type to avoid copying on method    // calls or to allow the method to mutate the    // receiving struct.    rp := &amp;r    fmt.Println(&quot;area: &quot;, rp.area())    fmt.Println(&quot;perim:&quot;, rp.perim())}</code></pre><blockquote><p>其实是利用方法求长方形的周长和面积，其中也给出了receiver作为指针和值的区别</p></blockquote><ul><li>这里也简单说下：什么时候receiver用指针<ul><li>1 改变receiver的值</li><li>2 struct本身非常的大，这样拷贝的代价是很昂贵的</li><li>3 如果struct的一个method中receiver为指针，那么其他的method的receiver最好也要用指针。</li></ul></li></ul><h2 id="方法与函数的区别"><a href="#方法与函数的区别" class="headerlink" title="方法与函数的区别"></a>方法与函数的区别</h2><p>在golang的世界中，一定要区分 方法和函数。</p><p>Go中没有类的概念，但是我们可以在一些类型上定义一些方法，也就是所谓的方法，跟函数不同。</p><ul><li>方法和函数定义语法区别在于：<ul><li>方法是针对对象的（有些是针对类）</li><li>函数是针对全局的（Golang中指包），</li><li>方法前置实例接受参数，这个receiver可以是基础类型也可以是指针。</li></ul></li></ul><blockquote><p>虽然Go语言没有类的概念，但它支持的数据类型可以定义对应的method(s)。本质上说，所谓的method(s)其实就是函数，只不过与普通函数相比，这类函数是作用在某个数据类型上的，所以在函数签名中，会有个receiver(接收器)来表明当前定义的函数会作用在该receiver上。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有过（面向对象）编程经验的应该都知道方法或者函数，比如在C，PHP，swift，OC，Java，kotlin等都有函数或者方法的存在，或者有二者的存在，只是有些人没有太过留意，比如PHP中就有这样的现象，而iOS中除了存在方法和行数，方法还分类方法和对象方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://icocos.github.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="https://icocos.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
      <category term="函数与方法" scheme="https://icocos.github.io/tags/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Go语言中的Array、Slice、Map和Set</title>
    <link href="https://icocos.github.io/2018/05/22/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84Array%E3%80%81Slice%E3%80%81Map%E5%92%8CSet/"/>
    <id>https://icocos.github.io/2018/05/22/Go语言中的Array、Slice、Map和Set/</id>
    <published>2018-05-22T15:01:33.000Z</published>
    <updated>2018-08-09T09:08:36.310Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言中和其他语言一样，存在数组，Map(iOS中的字典)，但是还有一个比较特殊的Slice，他其实底层还是数组，今天我们来简单说说Go语言中的Array、Slice、Map和Set</p><a id="more"></a><h2 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array(数组)"></a>Array(数组)</h2><h5 id="内部机制"><a href="#内部机制" class="headerlink" title="内部机制"></a>内部机制</h5><blockquote><p>在 Go 语言中数组是固定长度的数据类型，它包含相同类型的连续的元素，这些元素可以是内建类型，像数字和字符串，也可以是结构类型，元素可以通过唯一的索引值访问，从 0 开始。</p></blockquote><p>数组是很有价值的数据结构，因为它的内存分配是连续的，内存连续意味着可是让它在 CPU 缓存中待更久，所以迭代数组和移动元素都会非常迅速。</p><h5 id="数组声明和初始化"><a href="#数组声明和初始化" class="headerlink" title="数组声明和初始化"></a>数组声明和初始化</h5><p>通过指定数据类型和元素个数(数组长度)来声明数组。</p><pre><code>// 声明一个长度为5的整数数组var array [5]int</code></pre><p>一旦数组被声明了，那么它的数据类型跟长度都不能再被改变。如果你需要更多的元素，那么只能创建一个你想要长度的新的数组，然后把原有数组的元素拷贝过去。</p><blockquote><p>Go 语言中任何变量被声明时，都会被默认初始化为各自类型对应的 0 值，数组当然也不例外。当一个数组被声明时，它里面包含的每个元素都会被初始化为 0 值。</p></blockquote><p>一种快速创建和初始化数组的方法是使用数组字面值。数组字面值允许我们声明我们需要的元素个数并指定数据类型：</p><pre><code>// 声明一个长度为5的整数数组// 初始化每个元素array := [5]int{7, 77, 777, 7777, 77777}</code></pre><p>如果你把长度写成 …，Go 编译器将会根据你的元素来推导出长度：</p><pre><code>// 通过初始化值的个数来推导出数组容量array := [...]int{7, 77, 777, 7777, 77777}</code></pre><p>如果我们知道想要数组的长度，但是希望对指定位置元素初始化，可以这样：</p><pre><code>// 声明一个长度为5的整数数组// 为索引为1和2的位置指定元素初始化// 剩余元素为0值array := [5]int{1: 77, 2: 777}</code></pre><h5 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h5><p>使用 [] 操作符来访问数组元素：</p><pre><code>array := [5]int{7, 77, 777, 7777, 77777}// 改变索引为2的元素的值array[2] = 1</code></pre><p>我们可以定义一个指针数组：</p><pre><code>array := [5]*int{0: new(int), 1: new(int)}// 为索引为0和1的元素赋值*array[0] = 7*array[1] = 77</code></pre><p>在 Go 语言中数组是一个值，所以可以用它来进行赋值操作。一个数组可以被赋值给任意相同类型的数组：</p><pre><code>var array1 [5]stringarray2 := [5]string{&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;, &quot;Yellow&quot;, &quot;Pink&quot;}array1 = array2</code></pre><p>注意数组的类型同时包括数组的长度和可以被存储的元素类型，数组类型完全相同才可以互相赋值，比如下面这样就不可以：</p><pre><code>var array1 [4]stringarray2 := [5]string{&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;, &quot;Yellow&quot;, &quot;Pink&quot;}array1 = array2// 编译器会报错Compiler Error:cannot use array2 (type [5]string) as type [4]string in assignment</code></pre><p>拷贝一个指针数组实际上是拷贝指针值，而不是指针指向的值：</p><pre><code>var array1 [3]*stringarray2 := [3]*string{new(string), new(string), new(string)}*array2[0] = &quot;Red&quot;*array2[1] = &quot;Blue&quot;*array2[2] = &quot;Green&quot;array1 = array2// 赋值完成后，两组指针数组指向同一字符串</code></pre><h5 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h5><p>数组总是一维的，但是可以组合成多维的。多维数组通常用于有父子关系的数据或者是坐标系数据：</p><pre><code>// 声明一个二维数组var array [4][2]int// 使用数组字面值声明并初始化array := [4][2]int{{10, 11}, {20, 21}, {30, 31}, {40, 41}}// 指定外部数组索引位置初始化array := [4][2]int{1: {20, 21}, 3: {40, 41}}// 同时指定内外部数组索引位置初始化array := [4][2]int{1: {0: 20}, 3: {1: 41}}</code></pre><p>同样通过 [] 操作符来访问数组元素：</p><pre><code>var array [2][2]intarray[0][0] = 0array[0][1] = 1array[1][0] = 2array[1][1] = 3</code></pre><p>也同样的相同类型的多维数组可以相互赋值：</p><pre><code>var array1 = [2][2]intvar array2 = [2][2]intarray[0][0] = 0array[0][1] = 1array[1][0] = 2array[1][1] = 3array1 = array2</code></pre><p>因为数组是值，我们可以拷贝单独的维：</p><pre><code>var array3 [2]int = array1[1]var value int = array1[1][0]</code></pre><h5 id="在函数中传递数组"><a href="#在函数中传递数组" class="headerlink" title="在函数中传递数组"></a>在函数中传递数组</h5><p>在函数中传递数组是非常昂贵的行为，因为在函数之间传递变量永远是传递值，所以如果变量是数组，那么意味着传递整个数组，即使它很大很大很大。。。</p><p>举个栗子，创建一个有百万元素的整形数组，在64位的机器上它需要8兆的内存空间，来看看我们声明它和传递它时发生了什么：</p><pre><code>var array [1e6]intfoo(array)func foo(array [1e6]int) {  ...}</code></pre><p>每一次 foo 被调用，8兆内存将会被分配在栈上。一旦函数返回，会弹栈并释放内存，每次都需要8兆空间。</p><p>Go 语言当然不会这么傻，有更好的方法来在函数中传递数组，那就是传递指向数组的指针，这样每次只需要分配8字节内存：</p><pre><code>var array [1e6]intfoo(&amp;array)func foo(array *[1e6]int){  ...}</code></pre><p>但是注意如果你在函数中改变指针指向的值，那么原始数组的值也会被改变。幸运的是 slice(切片)可以帮我们处理好这些问题，来一起看看。</p><h2 id="Slice-切片"><a href="#Slice-切片" class="headerlink" title="Slice(切片)"></a>Slice(切片)</h2><h5 id="内部机制和基础"><a href="#内部机制和基础" class="headerlink" title="内部机制和基础"></a>内部机制和基础</h5><p>slice 是一种可以动态数组，可以按我们的希望增长和收缩。它的增长操作很容易使用，因为有内建的 append 方法。我们也可以通过 relice 操作化简 slice。因为 slice 的底层内存是连续分配的，所以 slice 的索引，迭代和垃圾回收性能都很好。</p><p>slice 是对底层数组的抽象和控制。它包含 Go 需要对底层数组管理的三种元数据，分别是：</p><ol><li>指向底层数组的指针</li><li>slice 中元素的长度</li><li>slice 的容量(可供增长的最大值)</li></ol><h5 id="创建和初始化"><a href="#创建和初始化" class="headerlink" title="创建和初始化"></a>创建和初始化</h5><p>Go 中创建 slice 有很多种方法，我们一个一个来看。</p><p>第一个方法是使用内建的函数 make。当我们使用 make 创建时，一个选项是可以指定 slice 的长度：</p><pre><code>slice := make([]string, 5)</code></pre><p>如果只指定了长度，那么容量默认等于长度。我们可以分别指定长度和容量：</p><pre><code>slice := make([]int, 3, 5)</code></pre><p>当我们分别指定了长度和容量，我们创建的 slice 就可以拥有一开始并没有访问的底层数组的容量。上面代码的 slice 中，可以访问3个元素，但是底层数组有5个元素。两个与长度不相干的元素可以被 slice 来用。新创建的 slice 同样可以共享底层数组和已存在的容量。</p><p>不允许创建长度大于容量的 slice：</p><pre><code>slice := make([]int, 5, 3)Compiler Error:len larger than cap in make([]int)</code></pre><p>惯用的创建 slice 的方法是使用 slice 字面量。跟创建数组很类似，不过不用指定 []里的值。初始的长度和容量依赖于元素的个数：</p><pre><code>// 创建一个字符串 slice// 长度和容量都是 5slice := []string{&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;, &quot;Yellow&quot;, &quot;Pink&quot;}</code></pre><p>在使用 slice 字面量创建 slice 时有一种方法可以初始化长度和容量，那就是初始化索引。下面是个例子：</p><pre><code>// 创建一个字符串 slice// 初始化一个有100个元素的空的字符串 sliceslice := []string{99: &quot;&quot;}nil 和 empty slice</code></pre><p>有的时候我们需要创建一个 nil slice，创建一个 nil slice 的方法是声明它但不初始化它：</p><pre><code>var slice []int</code></pre><p>创建一个 nil slice 是创建 slice 最基本的方法，很多标准库和内建函数都可以使用它。当我们想要表示一个并不存在的 slice 时它变得非常有用，比如一个返回 slice 的函数中发生异常的时候。</p><p>创建 empty slice 的方法就是声明并初始化一下：</p><pre><code>// 使用 make 创建silce := make([]int, 0)// 使用 slice 字面值创建slice := []int{}</code></pre><p>empty slice 包含0个元素并且底层数组没有分配存储空间。当我们想要表示一个空集合时它很有用处，比如一个数据库查询返回0个结果。</p><blockquote><p>不管我们用 nil slice 还是 empty slice，内建函数 append，len和cap的工作方式完全相同。</p></blockquote><h5 id="使用-slice"><a href="#使用-slice" class="headerlink" title="使用 slice"></a>使用 slice</h5><p>为一个指定索引值的 slice 赋值跟之前数组赋值的做法完全相同。改变单个元素的值使用 [] 操作符：</p><pre><code>slice := []int{10, 20, 30, 40, 50}slice[1] = 25</code></pre><p>我们可以在底层数组上对一部分数据进行 slice 操作，来创建一个新的 slice：</p><pre><code>// 长度为5，容量为5slice := []int{10, 20, 30, 40, 50}// 长度为2，容量为4newSlice := slice[1:3]</code></pre><p>在 slice 操作之后我们得到了两个 slice，它们共享底层数组。但是它们能访问底层数组的范围却不同，newSlice 不能访问它头指针前面的值。</p><p>计算任意 new slice 的长度和容量可以使用下面的公式：</p><pre><code>对于 slice[i:j] 和底层容量为 k 的数组长度：j - i容量：k - i</code></pre><p>必须再次明确一下现在是两个 slice 共享底层数组，因此只要有一个 slice 改变了底层数组的值，那么另一个也会随之改变：</p><pre><code>slice := []int{10, 20, 30, 40, 50}newSlice := slice[1:3]newSlice[1] = 35</code></pre><p>改变 newSlice 的第二个元素的值，也会同样改变 slice 的第三个元素的值。</p><p>一个 slice 只能访问它长度范围内的索引，试图访问超出长度范围的索引会产生一个运行时错误。容量只可以用来增长，它只有被合并到长度才可以被访问：</p><pre><code>slice := []int{10, 20, 30, 40, 50}newSlice := slice[1:3]newSlice[3] = 45Runtime Exception:panic: runtime error: index out of range</code></pre><p>容量可以被合并到长度里，通过内建的 append 函数。</p><h5 id="slice-增长"><a href="#slice-增长" class="headerlink" title="slice 增长"></a>slice 增长</h5><p>slice 比 数组的优势就在于它可以按照我们的需要增长，我们只需要使用 append 方法，然后 Go 会为我们做好一切。</p><p>使用 append 方法时我们需要一个源 slice 和需要附加到它里面的值。当 append 方法返回时，它返回一个新的 slice，append 方法总是增长 slice 的长度，另一方面，如果源 slice 的容量足够，那么底层数组不会发生改变，否则会重新分配内存空间。</p><pre><code>// 创建一个长度和容量都为5的 sliceslice := []int{10, 20, 30, 40, 50}// 创建一个新的 slicenewSlice := slice[1:3]// 为新的 slice append 一个值newSlice = append(newSlice, 60)</code></pre><p>因为 newSlice 有可用的容量，所以在 append 操作之后 slice 索引为 3 的值也变成了 60，之前说过这是因为 slice 和 newSlice 共享同样的底层数组。</p><p>如果没有足够可用的容量，append 函数会创建一个新的底层数组，拷贝已存在的值和将要被附加的新值：</p><pre><code>// 创建长度和容量都为4的 sliceslice := []int{10, 20, 30, 40}// 附加一个新值到 slice，因为超出了容量，所以会创建新的底层数组newSlice := append(slice, 50)</code></pre><p>append 函数重新创建底层数组时，容量会是现有元素的两倍(前提是元素个数小于1000)，如果元素个数超过1000，那么容量会以 1.25 倍来增长。</p><h5 id="slice-的第三个索引参数"><a href="#slice-的第三个索引参数" class="headerlink" title="slice 的第三个索引参数"></a>slice 的第三个索引参数</h5><p>slice 还可以有第三个索引参数来限定容量，它的目的不是为了增加容量，而是提供了对底层数组的一个保护机制，以方便我们更好的控制 append 操作，举个栗子：</p><pre><code>source := []string{&quot;apple&quot;, &quot;orange&quot;, &quot;plum&quot;, &quot;banana&quot;, &quot;grape&quot;}// 接着我们在源 slice 之上创建一个新的 sliceslice := source[2:3:4]</code></pre><p>新创建的 slice 长度为 1，容量为 2，可以看出长度和容量的计算公式也很简单：</p><pre><code>对于 slice[i:j:k]  或者 [2:3:4]长度： j - i       或者   3 - 2容量： k - i       或者   4 - 2</code></pre><p>如果我们试图设置比可用容量更大的容量，会得到一个运行时错误：</p><pre><code>slice := source[2:3:6]Runtime Error:panic: runtime error: slice bounds out of range</code></pre><p>限定容量最大的用处是我们在创建新的 slice 时候限定容量与长度相同，这样以后再给新的 slice 增加元素时就会分配新的底层数组，而不会影响原有 slice 的值：</p><pre><code>source := []string{&quot;apple&quot;, &quot;orange&quot;, &quot;plum&quot;, &quot;banana&quot;, &quot;grape&quot;}// 接着我们在源 slice 之上创建一个新的 slice// 并且设置长度和容量相同slice := source[2:3:3]// 添加一个新元素slice = append(slice, &quot;kiwi&quot;)</code></pre><p>如果没有第三个索引参数限定，添加 kiwi 这个元素时就会覆盖掉 banana。</p><p>内建函数 append 是一个变参函数，意思就是你可以一次添加多个元素，比如：</p><pre><code>s1 := []int{1, 2}s2 := []int{3, 4}fmt.Printf(&quot;%v\n&quot;, append(s1, s2...))Output:[1 2 3 4]</code></pre><h5 id="迭代-slice"><a href="#迭代-slice" class="headerlink" title="迭代 slice"></a>迭代 slice</h5><p>slice 也是一种集合，所以可以被迭代，用 for 配合 range 来迭代：</p><pre><code>slice := []int{10, 20, 30, 40, 50}for index, value := range slice {  fmt.Printf(&quot;Index: %d  Value: %d\n&quot;, index, value)}Output:Index: 0  Value: 10Index: 1  Value: 20Index: 2  Value: 30Index: 3  Value: 40Index: 4  Value: 50</code></pre><p>当迭代时 range 关键字会返回两个值，第一个是索引值，第二个是索引位置值的拷贝。注意：返回的是值的拷贝而不是引用，如果我们把值的地址作为指针使用，会得到一个错误，来看看为啥：</p><pre><code>slice := []int{10, 20, 30 ,40}for index, value := range slice {  fmt.Printf(&quot;Value: %d  Value-Addr: %X  ElemAddr: %X\n&quot;, value, &amp;value, &amp;slice[index])}Output:Value: 10  Value-Addr: 10500168  ElemAddr: 1052E100Value: 20  Value-Addr: 10500168  ElemAddr: 1052E104Value: 30  Value-Addr: 10500168  ElemAddr: 1052E108Value: 40  Value-Addr: 10500168  ElemAddr: 1052E10C</code></pre><p>value 变量的地址总是相同的因为它只是包含一个拷贝。如果想得到每个元素的真是地址可以使用 &amp;slice[index]。</p><p>如果不需要索引值，可以使用 _ 操作符来忽略它：</p><pre><code>slice := []int{10, 20, 30, 40}for _, value := range slice {  fmt.Printf(&quot;Value: %d\n&quot;, value)}Output:Value: 10Value: 20Value: 30Value: 40</code></pre><p>range 总是从开始一次遍历，如果你想控制遍历的step，就用传统的 for 循环：</p><pre><code>slice := []int{10, 20, 30, 40}for index := 2; index &lt; len(slice); index++ {  fmt.Printf(&quot;Index: %d  Value: %d\n&quot;, index, slice[index])}Output:Index: 2  Value: 30Index: 3  Value: 40</code></pre><p>同数组一样，另外两个内建函数 len 和 cap 分别返回 slice 的长度和容量。</p><h5 id="多维-slice"><a href="#多维-slice" class="headerlink" title="多维 slice"></a>多维 slice</h5><p>也是同数组一样，slice 可以组合为多维的 slice：</p><pre><code>slice := [][]int{{10}, {20, 30}}</code></pre><p>需要注意的是使用 append 方法时的行为，比如我们现在对 slice[0] 增加一个元素：</p><pre><code>slice := [][]int{{10}, {20, 30}}slice[0] = append(slice[0], 20)</code></pre><p>那么只有 slice[0] 会重新创建底层数组，slice[1] 则不会。</p><h5 id="在函数间传递-slice"><a href="#在函数间传递-slice" class="headerlink" title="在函数间传递 slice"></a>在函数间传递 slice</h5><p>在函数间传递 slice 是很廉价的，因为 slice 相当于是指向底层数组的指针，让我们创建一个很大的 slice 然后传递给函数调用它：</p><pre><code>slice := make([]int, 1e6)slice = foo(slice)func foo(slice []int) []int {    ...    return slice}</code></pre><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h5 id="内部机制-1"><a href="#内部机制-1" class="headerlink" title="内部机制"></a>内部机制</h5><ul><li><p>map 是一种无序的键值对的集合。map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。</p></li><li><p>map 是一种集合，所以我们可以像迭代数组和 slice 那样迭代它。不过，map 是无序的，我们无法决定它的返回顺序，这是因为 map 是使用 hash 表来实现的。</p></li></ul><p>map 的 hash 表包含了一个桶集合(collection of buckets)。当我们存储，移除或者查找键值对(key/value pair)时，都会从选择一个桶开始。在映射(map)操作过程中，我们会把指定的键值(key)传递给 hash 函数(又称散列函数)。hash 函数的作用是生成索引，索引均匀的分布在所有可用的桶上。hash 表算法详见：July的博客—从头到尾彻底解析 hash 表算法</p><h5 id="创建和初始化-1"><a href="#创建和初始化-1" class="headerlink" title="创建和初始化"></a>创建和初始化</h5><p>Go 语言中有多种方法创建和初始化 map。我们可以使用内建函数 make 也可以使用 map 字面值：</p><pre><code>// 通过 make 来创建dict := make(map[string]int)// 通过字面值创建dict := map[string]string{&quot;Red&quot;: &quot;#da1337&quot;, &quot;Orange&quot;: &quot;#e95a22&quot;}</code></pre><p>使用字面值是创建 map 惯用的方法(为什么不使用make)。初始化 map 的长度依赖于键值对的数量。</p><p>map 的键可以是任意内建类型或者是 struct 类型，map 的值可以是使用 ==操作符的表达式。slice，function 和 包含 slice 的 struct 类型不可以作为 map 的键，否则会编译错误：</p><pre><code>dict := map[[]string]int{}Compiler Exception:invalid map key type []string</code></pre><h5 id="使用-map"><a href="#使用-map" class="headerlink" title="使用 map"></a>使用 map</h5><p>给 map 赋值就是指定合法类型的键，然后把值赋给键：</p><pre><code>colors := map[string]string{}colors[&quot;Red&quot;] = &quot;#da1337&quot;</code></pre><p>如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对，否则会报运行时错误：</p><pre><code>var colors map[string]stringcolors[&quot;Red&quot;] = &quot;#da1337&quot;Runtime Error:panic: runtime error: assignment to entry in nil map</code></pre><p>测试 map 的键是否存在是 map 操作的重要部分，因为它可以让我们判断是否可以执行一个操作，或者是往 map 里缓存一个值。它也可以被用来比较两个 map 的键值对是否匹配或者缺失。</p><p>从 map 里检索一个值有两种选择，我们可以同时检索值并且判断键是否存在：</p><pre><code>value, exists := colors[&quot;Blue&quot;]if exists {  fmt.Println(value)}</code></pre><p>另一种选择是只返回值，然后判断是否是零值来确定键是否存在。但是只有你确定零值是非法值的时候这招才管用：</p><pre><code>value := colors[&quot;Blue&quot;]if value != &quot;&quot; {  fmt.Println(value)}</code></pre><p>当索引一个 map 取值时它总是会返回一个值，即使键不存在。上面的例子就返回了对应类型的零值。</p><p>迭代一个 map 和迭代数组和 slice 是一样的，使用 range 关键字，不过在迭代 map 时我们不使用 index/value 而使用 key/value 结构：</p><pre><code>colors := map[string]string{    &quot;AliceBlue&quot;:   &quot;#f0f8ff&quot;,    &quot;Coral&quot;:       &quot;#ff7F50&quot;,    &quot;DarkGray&quot;:    &quot;#a9a9a9&quot;,    &quot;ForestGreen&quot;: &quot;#228b22&quot;,}for key, value := range colors {  fmt.Printf(&quot;Key: %s  Value: %s\n&quot;, key, value)}</code></pre><p>如果我们想要从 map 中移除一个键值对，使用内建函数 delete(要是也能返回移除是否成功就好了，哎。。。)：</p><pre><code>delete(colors, &quot;Coral&quot;)for key, value := range colors {  fmt.Println(&quot;Key: %s  Value: %s\n&quot;, key, value)}</code></pre><h5 id="在函数间传递-map"><a href="#在函数间传递-map" class="headerlink" title="在函数间传递 map"></a>在函数间传递 map</h5><p>在函数间传递 map 不是传递 map 的拷贝。所以如果我们在函数中改变了 map，那么所有引用 map 的地方都会改变：</p><pre><code>func main() {  colors := map[string]string{     &quot;AliceBlue&quot;:   &quot;#f0f8ff&quot;,     &quot;Coral&quot;:       &quot;#ff7F50&quot;,     &quot;DarkGray&quot;:    &quot;#a9a9a9&quot;,     &quot;ForestGreen&quot;: &quot;#228b22&quot;,  }  for key, value := range colors {      fmt.Printf(&quot;Key: %s  Value: %s\n&quot;, key, value)  }  removeColor(colors, &quot;Coral&quot;)  for key, value := range colors {      fmt.Printf(&quot;Key: %s  Value: %s\n&quot;, key, value)  }}func removeColor(colors map[string]string, key string) {    delete(colors, key)}</code></pre><p>执行会得到以下结果：</p><pre><code>Key: AliceBlue Value: #F0F8FFKey: Coral Value: #FF7F50Key: DarkGray Value: #A9A9A9Key: ForestGreen Value: #228B22Key: AliceBlue Value: #F0F8FFKey: DarkGray Value: #A9A9A9Key: ForestGreen Value: #228B22</code></pre><p>可以看出来传递 map 也是十分廉价的，类似 slice。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Go 语言本身是不提供 set 的，但是我们可以自己实现它，下面就来试试：</p><pre><code>package mainimport(  &quot;fmt&quot;  &quot;sync&quot;)type Set struct {  m map[int]bool  sync.RWMutex}func New() *Set {  return &amp;Set{    m: map[int]bool{},  }}func (s *Set) Add(item int) {  s.Lock()  defer s.Unlock()  s.m[item] = true}func (s *Set) Remove(item int) {  s.Lock()  s.Unlock()  delete(s.m, item)}func (s *Set) Has(item int) bool {  s.RLock()  defer s.RUnlock()  _, ok := s.m[item]  return ok}func (s *Set) Len() int {  return len(s.List())}func (s *Set) Clear() {  s.Lock  defer s.Unlock()  s.m = map[int]bool{}}func (s *Set) IsEmpty() bool {  if s.Len() == 0 {    return true  }  return false}func (s *Set) List() []int {  s.RLock()  defer s.RUnlock()  list := []int{}  for item := range s.m {    list = append(list, item)  }  return list}func main() {  // 初始化  s := New()  s.Add(1)  s.Add(1)  s.Add(2)  s.Clear()  if s.IsEmpty() {    fmt.Println(&quot;0 item&quot;)  }  s.Add(1)  s.Add(2)  s.Add(3)  if s.Has(2) {    fmt.Println(&quot;2 does exist&quot;)  }  s.Remove(2)  s.Remove(3)  fmt.Println(&quot;list of all items&quot;, S.List())}</code></pre><ul><li>注意我们只是使用了 int 作为键，你可以自己实现用 interface{} 作为键，做成更通用的 Set，另外，这个实现是线程安全的。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>数组是 slice 和 map 的底层结构。</li><li>slice 是 Go 里面惯用的集合数据的方法，map 则是用来存储键值对。</li><li>内建函数 make 用来创建 slice 和 map，并且为它们指定长度和容量等等。slice 和 map 字面值也可以做同样的事。</li><li>slice 有容量的约束，不过可以通过内建函数 append 来增加元素。</li><li>map 没有容量一说，所以也没有任何增长限制。</li><li>内建函数 len 可以用来获得 slice 和 map 的长度。</li><li>内建函数 cap 只能作用在 slice 上。</li><li>可以通过组合方式来创建多维数组和 slice。map 的值可以是 slice 或者另一个 map。slice 不能作为 map 的键。</li><li>在函数之间传递 slice 和 map 是相当廉价的，因为他们不会传递底层数组的拷贝。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go语言中和其他语言一样，存在数组，Map(iOS中的字典)，但是还有一个比较特殊的Slice，他其实底层还是数组，今天我们来简单说说Go语言中的Array、Slice、Map和Set&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://icocos.github.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="https://icocos.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Array、Slice、Map、Set" scheme="https://icocos.github.io/tags/Array%E3%80%81Slice%E3%80%81Map%E3%80%81Set/"/>
    
  </entry>
  
  <entry>
    <title>Golang知识图谱</title>
    <link href="https://icocos.github.io/2018/05/10/Golang%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    <id>https://icocos.github.io/2018/05/10/Golang知识图谱/</id>
    <published>2018-05-10T02:49:12.000Z</published>
    <updated>2018-08-06T18:33:42.390Z</updated>
    
    <content type="html"><![CDATA[<p>一张图介绍Golang知识图谱，查漏补缺，还能装逼</p><a id="more"></a><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/golangallstudydata.png" alt="曹理鹏(iCocos)-梦工厂"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一张图介绍Golang知识图谱，查漏补缺，还能装逼&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://icocos.github.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="https://icocos.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Golang知识图谱" scheme="https://icocos.github.io/tags/Golang%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
  </entry>
  
  <entry>
    <title>Go——基础学习笔记</title>
    <link href="https://icocos.github.io/2018/05/09/Go%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://icocos.github.io/2018/05/09/Go——基础学习笔记/</id>
    <published>2018-05-09T02:07:21.000Z</published>
    <updated>2018-08-06T17:26:22.436Z</updated>
    
    <content type="html"><![CDATA[<p>iOS开发中有一个方向叫，你想工程开发，曾经也试着话时间去研究过相关的技术，熟悉使用那些相关的工具，但是毕竟没有专门实战过项目，也就只能简单的入门一下。而随着iOS开发年限的增长，和所了解到的东西，发现有不少公司或者朋友都在关注安全这一块，虽然Apple已经把安全做得很到位了，但是还是有这一块的问题存在，所以我根据个人的能力并结合网上的相关资料，简单的整理了一下，不管是作为了解，还是项目实战，或者为了面试，我都希望能有所帮助……</p><a id="more"></a><blockquote><p>07年由RRK三人主持开发，09年11月开源，12年1.0稳定版</p></blockquote><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>语言简单</li><li>实用，有效，高效</li><li>静态类型</li><li>编译型</li><li>开源</li><li>脚本化语法</li><li>函数式</li><li>面向对象</li><li>原始并发</li><li>协程（并发编程的管道）</li><li>垃圾回收</li><li>类型安全</li><li>内存安全</li><li>UTF8编码</li><li>移除或异常无用包</li><li>内置高性能http server</li><li>完善简便的各种库(package)</li><li>调用C很简便</li><li>跨平台</li><li>作者之一是c的作者</li></ul><h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><ul><li>脚本化</li><li>静态+编译-&gt;速度(相比：动态+解释)</li><li>并发(运行时系统调度和算法)</li></ul><h5 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h5><ul><li>语法糖少</li><li>速度不及C</li><li>第三方库较少</li></ul><h5 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h5><ul><li>GOROOT：Go语言的当前安装目录</li><li>GOPATH：Go语言工作区的结合（工作目录）</li><li>GOBIN：可执行文件目录</li><li>PATH：Go语言本身目录和Go程序生成可执行文件命令</li></ul><blockquote><p>(~/.bash_profile(单一用户),/etc/profile(全局用户)</p></blockquote><ul><li>相关目录$GOOS_$GOARCH： GOOS-操作系统，GOARCH-计算架构</li></ul><h5 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h5><ul><li>src：源码文件（代码包）</li><li>pkg：存放归档文件（代码包，库）</li><li>bin：Go程序可执行文件</li></ul><h5 id="源码文件"><a href="#源码文件" class="headerlink" title="源码文件"></a>源码文件</h5><ul><li>命令源码文件（功能）：Go语言入口，声明自己属于main代码包，包含无参数声明和结果声明的main函数</li><li>库源码文件（功能）：不具备命令源码文件的两个特征</li><li>测试源码文件（辅助）：同上，但是名称为：_test.go后缀</li></ul><blockquote><p>测试函数（至少一个）：Test(功能)或Benchmark(基准或性能)前缀，参数<em>testing.T或</em>testing.B</p></blockquote><h5 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h5><ul><li>go run： 编译-临时-运行-可执行，归档文件<ul><li>a：强制编译，不管是不是最新</li><li>n：打印编译需要的命令，不执行</li><li>p n：并行编译，n为并行数</li><li>a：列出被编译代码包名称（-a -v：所有涉及）</li><li>work：临时工作目录路径，且不删除</li><li>x：打印编译需要的命令，执行</li></ul></li><li>go build：编译代码包（库：不产生结果文件，只检查有效性。命令：生成可执行文件，结果文件）<ul><li>a：加入-编译所有涉及，不加入-只编译最新的</li></ul></li><li>go install：编译并安装代码包或源码文件</li><li>go get：从远程代码仓库下载并安装代码包（git，Mercurial，svn，Bazaar）<ul><li>d：只下载不安装</li><li>fix：下载后，先执行修正动作，在安装</li><li>u：更新代码包</li></ul></li></ul><blockquote><p>ds(显示指定目录的目录结构)/pds命令(显示指定代码包的以来关系)</p></blockquote><h5 id="DOC"><a href="#DOC" class="headerlink" title="DOC"></a>DOC</h5><ul><li>godoc -http=:8800</li></ul><h5 id="基础总结"><a href="#基础总结" class="headerlink" title="基础总结"></a>基础总结</h5><ul><li>只有package为main的包可以包含main函数</li><li>一个可执行文件有且仅有一个main函数</li><li>import导入非main包</li><li>函数外包使用var申明和赋值全局变量</li><li>type进行结构体和接口的声明</li></ul><h4 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h4><pre><code>// 当前程序的包名（package：非注释的第一行）package main// 导入其他包import &quot;fmt&quot; // 格式import . &quot;os&quot; // 省略import io &quot;io&quot; // 别名import _ &quot;time&quot; // 忽略import (    &quot;strings&quot; )// 常量定义const PI = 3.14// 全局变量声明与赋值var name = &quot;iCocos&quot;// 一般类型的声明type newtype int// 结构体的声明type gostruct = struct{}// 接口的声明type gointerface interface{} // 以上三种都可以使用组 type (    byte int8    rune int 32    文本 string )// 由main函数作为程序入口和启动func main() {    Printf(&quot;Hello World!&quot;)}</code></pre><h5 id="可见性规则"><a href="#可见性规则" class="headerlink" title="可见性规则"></a>可见性规则</h5><p>常量，变量，类型，接口，结构体，函数</p><ul><li>大小写区分：<ul><li>小写为private</li><li>大写为public</li></ul></li></ul><hr><ul><li>陆续更新<ul><li>01基础学习笔记</li><li>02Go语法初识</li><li>03类型与变量</li><li>04常量与运算符</li><li>05控制语句</li><li>06数组array</li><li>07切片slice</li><li>08map</li><li>09函数function</li><li>10结构struct</li><li>11方法method</li><li>12接口interface</li><li>13反射reflection</li><li>14并发concurrency</li><li>15项目与坑</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS开发中有一个方向叫，你想工程开发，曾经也试着话时间去研究过相关的技术，熟悉使用那些相关的工具，但是毕竟没有专门实战过项目，也就只能简单的入门一下。而随着iOS开发年限的增长，和所了解到的东西，发现有不少公司或者朋友都在关注安全这一块，虽然Apple已经把安全做得很到位了，但是还是有这一块的问题存在，所以我根据个人的能力并结合网上的相关资料，简单的整理了一下，不管是作为了解，还是项目实战，或者为了面试，我都希望能有所帮助……&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://icocos.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://icocos.github.io/tags/Go/"/>
    
      <category term="基础学习笔记" scheme="https://icocos.github.io/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>服务器配置——实战验证与补充</title>
    <link href="https://icocos.github.io/2018/05/05/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81%E4%B8%8E%E8%A1%A5%E5%85%85/"/>
    <id>https://icocos.github.io/2018/05/05/服务器配置——实战验证与补充/</id>
    <published>2018-05-05T10:07:54.000Z</published>
    <updated>2018-08-06T17:26:24.394Z</updated>
    
    <content type="html"><![CDATA[<p> 下面关于之前一些流程（Ngnix，Php，Go，Mysql）安装配置与使用的一些总结，和遇到的一个坑，其中也有关于服务器配置与部署，代码上传与发布相关内容，主要是为了熟悉整个流程……</p><a id="more"></a><blockquote><p>这里补充一下前面没有提到，但是实际操作会用到或者能提升效率的东西</p></blockquote><h2 id="安装ftp"><a href="#安装ftp" class="headerlink" title="安装ftp"></a>安装ftp</h2><p>大家看到了，所有的文件操作在ssh中可以通过vim方法来实现，但是，你知道在windows中用惯了，还是喜欢看图形界面，所以在这里我安装了ftp可以远程来上传修改文件</p><pre><code>软件：winscp（百度下载就好了）</code></pre><h3 id="安装vsftpd"><a href="#安装vsftpd" class="headerlink" title="安装vsftpd"></a>安装vsftpd</h3><pre><code>yum install vsftpd</code></pre><h3 id="启动-重启-关闭vsftpd服务器"><a href="#启动-重启-关闭vsftpd服务器" class="headerlink" title="启动/重启/关闭vsftpd服务器"></a>启动/重启/关闭vsftpd服务器</h3><pre><code>[root@localhost ftp]# /sbin/service vsftpd restartShutting down vsftpd: [ OK ]Starting vsftpd for vsftpd: [ OK ] </code></pre><p>OK表示重启成功了.</p><p>这里现在就可以直接使用root及你的密码来查看了，当然这样的是超级用户，留给自己用的，要配置指定要文件夹的用户，我就在不在这里写了，大家继续百度下吧</p><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><pre><code>sudo apt-get updatesudo apt-get install git</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 下面关于之前一些流程（Ngnix，Php，Go，Mysql）安装配置与使用的一些总结，和遇到的一个坑，其中也有关于服务器配置与部署，代码上传与发布相关内容，主要是为了熟悉整个流程……&lt;/p&gt;
    
    </summary>
    
      <category term="Server" scheme="https://icocos.github.io/categories/Server/"/>
    
    
      <category term="Server" scheme="https://icocos.github.io/tags/Server/"/>
    
      <category term="实战验证与补充" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81%E4%B8%8E%E8%A1%A5%E5%85%85/"/>
    
  </entry>
  
  <entry>
    <title>服务器配置——Go安装与配置</title>
    <link href="https://icocos.github.io/2018/05/04/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94Go%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>https://icocos.github.io/2018/05/04/服务器配置——Go安装与配置/</id>
    <published>2018-05-04T10:06:17.000Z</published>
    <updated>2018-08-06T18:33:42.386Z</updated>
    
    <content type="html"><![CDATA[<p> 这里应该说是我此次的最初目的，当然后面接触了不少服务器配置与部署后，我发现重点不是学习Go，而且这整个过程中学到的一切，好了，其实我突然重新开始整服务器和博客，是因为想要开始好好，认认真真的学习一下Go，并将其应用到实战中……</p><a id="more"></a><h2 id="go下载安装后上传到服务器"><a href="#go下载安装后上传到服务器" class="headerlink" title="go下载安装后上传到服务器"></a>go下载安装后上传到服务器</h2><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/servers/go000.jpeg" alt="HYMBA"></p><p>这里之前是可以直接使用wget安装的，但是大部分的wget地址所下载的gz包都无法解压</p><pre><code>#解压tar -zxvf go1.8.4.linux-amd64.tar.gz</code></pre><p>所以一般都是选择官网的</p><h2 id="HOME-下面创建了一个-export-文件"><a href="#HOME-下面创建了一个-export-文件" class="headerlink" title="$HOME 下面创建了一个 .export 文件"></a>$HOME 下面创建了一个 .export 文件</h2><p>写的 这些环境变量</p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/servers/go001.jpeg" alt="HYMBA"></p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/servers/go002.jpeg" alt="HYMBA"></p><p>要想立即生效的话 要么退出从新连接 要么执行下 source ~/.bashrc</p><h4 id="执行-go-env"><a href="#执行-go-env" class="headerlink" title="执行 go env"></a>执行 go env</h4><blockquote><p>看看 GOPATH GOROOT GOBIN 是不是自己设置的</p></blockquote><h2 id="在-HOME-GoWorkSpec-创建了这文件目录-下面有"><a href="#在-HOME-GoWorkSpec-创建了这文件目录-下面有" class="headerlink" title="在 $HOME/GoWorkSpec 创建了这文件目录 下面有"></a>在 $HOME/GoWorkSpec 创建了这文件目录 下面有</h2><ul><li>bin </li><li>pkg </li><li>src </li></ul><p>三个子目录  src 放源码</p><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/servers/go003.jpeg" alt="HYMBA"></p><h2 id="go-http-server"><a href="#go-http-server" class="headerlink" title="go http server"></a>go http server</h2><p>如果你配置好了所有需要的服务与配置，并且对Go语言已经足够熟悉了，那么你一定会想用Go语言来干点撒。</p><p>没错，就是我们一开始的目的，实现服务器开发，和Php一样接收前端或者移动端的请求，进行数据的处理与返回</p><blockquote><p>但是由于时间原因，而且关于go http server目前还有点早，后面会用专门的文章来说明具体的配置与实战。</p></blockquote><p>感兴趣的可以看看下面的文章：</p><ul><li><a href="https://blog.csdn.net/chenxun_2010/article/details/73862810" target="_blank" rel="noopener">https://blog.csdn.net/chenxun_2010/article/details/73862810</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 这里应该说是我此次的最初目的，当然后面接触了不少服务器配置与部署后，我发现重点不是学习Go，而且这整个过程中学到的一切，好了，其实我突然重新开始整服务器和博客，是因为想要开始好好，认认真真的学习一下Go，并将其应用到实战中……&lt;/p&gt;
    
    </summary>
    
      <category term="Server" scheme="https://icocos.github.io/categories/Server/"/>
    
    
      <category term="Server" scheme="https://icocos.github.io/tags/Server/"/>
    
      <category term="Go安装与配置" scheme="https://icocos.github.io/tags/Go%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>服务器配置——MySql安装与配置</title>
    <link href="https://icocos.github.io/2018/05/04/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94MySql%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>https://icocos.github.io/2018/05/04/服务器配置——MySql安装与配置/</id>
    <published>2018-05-04T10:05:26.000Z</published>
    <updated>2018-08-06T17:26:22.858Z</updated>
    
    <content type="html"><![CDATA[<p>服务器好了之后，首先我们应该从数据库入手，因为一切没有数据交互与存储的服务器和客户端都只是娱乐，这里我们选择大部分人都熟知而且与PHP成为天和之作的Mysql，当然他和Go也一样兼容……</p><a id="more"></a><h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><p>mysql 可以管理网站用到的数据库，WordPress 和 Drupal 也都支持 mysql 数据库。所以我们的 Web 运行环境里，需要安装一个 mysql 。之前我们已经添加了资源库，所以可以直接使用 yum 命令去安装  mysql ：</p><pre><code>yum install mysql-server</code></pre><p>安装完成后，使用 service 命令启动 mysql 服务：</p><pre><code>service mysqld start</code></pre><p>然后我们需要简单配置一下 mysql ，默认安装以后 mysql 的 root 用户是没有密码的，对于生产环境来说，这肯定是不行的.</p><p>另外还有一些安全相关的设置，可以使用下面这行命令去配置一下，它是一个向导，问你一些问题，你要给出答案，比如是否要设置 root 用户的密码， 密码是什么等等。</p><pre><code>mysql_secure_installation</code></pre><p>然后根据实际情况进行配置，也可以看看下面比较常用的配置方案</p><pre><code>Enter current password for root (enter for none):解释：输入当前 root 用户密码，默认为空，直接回车。Set root password? [Y/n]  y解释：要设置 root 密码吗？输入 y 表示愿意。Remove anonymous users? [Y/n]  y解释：要移除掉匿名用户吗？输入 y 表示愿意。Disallow root login remotely? [Y/n]  n解释：不想让 root 远程登陆吗？输入 y 表示愿意。Remove test database and access to it? [Y/n]  y解释：要去掉 test 数据库吗？输入 y 表示愿意。Reload privilege tables now? [Y/n]  y解释：想要重新加载权限吗？输入 y 表示愿意。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;服务器好了之后，首先我们应该从数据库入手，因为一切没有数据交互与存储的服务器和客户端都只是娱乐，这里我们选择大部分人都熟知而且与PHP成为天和之作的Mysql，当然他和Go也一样兼容……&lt;/p&gt;
    
    </summary>
    
      <category term="Server" scheme="https://icocos.github.io/categories/Server/"/>
    
    
      <category term="Server" scheme="https://icocos.github.io/tags/Server/"/>
    
      <category term="MySql安装与配置" scheme="https://icocos.github.io/tags/MySql%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>服务器配置——Php安装与配置</title>
    <link href="https://icocos.github.io/2018/05/03/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94Php%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>https://icocos.github.io/2018/05/03/服务器配置——Php安装与配置/</id>
    <published>2018-05-03T10:06:09.000Z</published>
    <updated>2018-08-06T17:26:22.357Z</updated>
    
    <content type="html"><![CDATA[<p> 由于之前学过一段时间的Php，偶尔看到一个不错的东西也会尝试一下，虽然可能最终结果和意义并不大，但是此次我还是觉决定让服务器支持Php，同时也会适当的更新一些Php的内容（能力有限，都是比较基础的内容）……</p> <a id="more"></a><blockquote><p>说了服务器第一步Ngnix安装与配置之后，就要开始说说关于PHP和Go的安装与配置</p></blockquote><h2 id="配置php-fpm部分"><a href="#配置php-fpm部分" class="headerlink" title="配置php-fpm部分"></a>配置php-fpm部分</h2><p>要让 nginx 能够执行 php 文件，需要去安装一下 php-fpm，它直接包含在了 CentOS 资源库里，所以直接使用 yum 命令可以安装它：</p><pre><code>yum install php-fpm</code></pre><p>完成以后，可以检查一下 php-fpm 的运行状态，使用 service 命令：</p><pre><code>service php-fpm status</code></pre><p>返回：</p><pre><code>php-fpm is stopped（php-fpm 已停止）</code></pre><p>启动 php-fpm 同样可以使用 service 命令：</p><pre><code>service php-fpm start</code></pre><h2 id="让-nginx-可以执行-php"><a href="#让-nginx-可以执行-php" class="headerlink" title="让 nginx 可以执行 php"></a>让 nginx 可以执行 php</h2><p>现在我们应该就可以让 nginx 去执行 php 了。不过你需要修改一下 nginx 的配置文件，之前我们在配置虚拟主机的时候，创建了一个 nginx.ninghao.net.conf 的配置文件，需要去修改下 nginx 的这个配置文件，才能去执行 php 。使用 vim 命令去编辑它：</p><pre><code>vim /etc/nginx/conf.d/nginx.ninghao.net.conf</code></pre><p>注意你的配置文件不一定叫 nginx.ninghao.net.conf，应该是你自己命名的配置文件。打开以后，找到下面这段字样的代码：</p><pre><code># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000##location ~ \.php$ {#    root           html;#    fastcgi_pass   127.0.0.1:9000;#    fastcgi_index  index.php;#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;#    include        fastcgi_params;#}</code></pre><p>这是 nginx 默认给我们的用来执行 php 的配置，从 location 开始取消注释，会让这个配置生效，然后我们还得简单去修改一下：</p><pre><code># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000#location ~ \.php$ {#   root           html;    fastcgi_pass   127.0.0.1:9000;    fastcgi_index  index.php;    fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;    include        fastcgi_params;}</code></pre><p>注意 root 那里仍然是被注释掉的，还有 SCRIPT_FILENAME 后面修改了一下，把 /scripts 换成了 $document_root 。保存并退出。然后重新启动 nginx：</p><pre><code>service nginx restart</code></pre><h2 id="测试是否可以执行-php"><a href="#测试是否可以执行-php" class="headerlink" title="测试是否可以执行 php"></a>测试是否可以执行 php</h2><p>现在，我们已经安装了 php-fpm，并修改了 nginx 的配置文件让它可以去执行 php，下面，我们得去测试一下，可以使用 php 的 phpinfo(); 函数，方法是在你的虚拟主机根目录下面，创建一个 php 文件，命名为 phpinfo.php，然后在这个文件里输入：</p><pre><code>&lt;?php phpinfo(); ?&gt;</code></pre><p>保存文件并退出。在浏览器里打开刚才创建的这个 php 文件。我这里应该是 <code>http://nginx.ninghao.net/phpinfo.php</code>。打开以后，你应该能看到像下面这样的界面，如果能，说明 nginx 已经可以执行 php 了。</p><h2 id="配置扩展"><a href="#配置扩展" class="headerlink" title="配置扩展"></a>配置扩展</h2><blockquote><p>现在，我们有了可以提供 web 服务的 nginx ，并且安装了 php-fpm ，配置了 nginx 可以让它去执行 php ，也安装了数据库管理系统。</p></blockquote><p>不过在运行真正的网站的时候，我们还需要为 php 安装一些额外的扩展，比如 处理 mysql 数据库的 mysql 扩展，缓存功能的 apc 扩展，处理图像的 gd 扩展等等。安装它们同样可以使用 yum 命令。</p><pre><code>yum install php-pecl-apc php-mysql php-gd php-mcrypt php-pear php-mbstring php-xmlrpc php-dom</code></pre><p>上面安装了一些 php 的扩展，如果你发现在安装网站的时候提示需要安装其它的扩展，同样可以使用 yum 命令去安装。安装完成以后，需要重启一下 php-fpm ：</p><pre><code>service php-fpm restart</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 由于之前学过一段时间的Php，偶尔看到一个不错的东西也会尝试一下，虽然可能最终结果和意义并不大，但是此次我还是觉决定让服务器支持Php，同时也会适当的更新一些Php的内容（能力有限，都是比较基础的内容）……&lt;/p&gt;
    
    </summary>
    
      <category term="Server" scheme="https://icocos.github.io/categories/Server/"/>
    
    
      <category term="Server" scheme="https://icocos.github.io/tags/Server/"/>
    
      <category term="Php安装与配置" scheme="https://icocos.github.io/tags/Php%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>服务器配置——Nginx安装与配置</title>
    <link href="https://icocos.github.io/2018/05/03/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94Nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>https://icocos.github.io/2018/05/03/服务器配置——Nginx安装与配置/</id>
    <published>2018-05-03T10:04:52.000Z</published>
    <updated>2018-08-06T18:33:42.317Z</updated>
    
    <content type="html"><![CDATA[<p> 配置完阿里控制台之后，首先我们开始配置服务器，我的服务器各种配置都需要自己重新配，这里我现在Ngnix，不要问我为什么选择他，可能是之前用过Apache，对他印象不好吧……</p> <a id="more"></a><p>前面说了关于阿里云主机操作，这里打算开始一步一步搭建和配置服务器，并且开始Go语言和后台学习，并且徐后续更新，直到后面的后台实战开发</p><blockquote><p>关于域名解析，实例，和安全组相关请自行参考阿里官方教程</p></blockquote><h2 id="如何连接服务器执行环境配置"><a href="#如何连接服务器执行环境配置" class="headerlink" title="如何连接服务器执行环境配置"></a>如何连接服务器执行环境配置</h2><blockquote><p>我使用的是centos6.8 64位版本，如果您不是第一次接触linux那一定知道，linux不是一个可视化界面的系统，所以要摒弃windows的操作习惯，我使用的xshell这个软件链接的服务器，连接语句是 ssh root@ip地址</p></blockquote><p>地址处就是写入你的ip地址，然后回车鞋面就会自动连接，弹框提示输入密码</p><ul><li>输入服务器的密码，点击确定即链接上了</li></ul><p>ok，下面就可以开始配置环境了，第一步我们先配置nginx</p><h2 id="nginx安装部分"><a href="#nginx安装部分" class="headerlink" title="nginx安装部分"></a>nginx安装部分</h2><p>想在 CentOS 系统上安装 Nginx ，你得先去添加一个资源库，像这样：</p><pre><code>vim /etc/yum.repos.d/nginx.repo</code></pre><p>使用 vim 命令去打开 <code>/etc/yum.repos.d/nginx.repo</code> ，如果 nginx.repo 不存在，就会去创建一个这样的文件，打开以后按一下小 i 键，进入编辑模式，然后复制粘贴下面这几行代码，完成以后按 esc 键退出，再输入 :wq （保存并退出）</p><pre><code>[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=0enabled=1</code></pre><p>完成以后，我们就可以使用 yum 命令去安装 nginx 了，像这样：</p><pre><code>yum install nginx</code></pre><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/servers/ngnix0001.png" alt="HYMBA"></p><p>安装好以后测试一下 nginx 服务：</p><pre><code>service nginx status</code></pre><p>应该会返回：</p><pre><code>nginx is stopped （nginx 已停止）</code></pre><p>再测试一下 nginx 的配置文件：</p><pre><code>nginx -t</code></pre><p>应该会返回：</p><pre><code>nginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful</code></pre><p>… syntax is ok，… test is successful，说明配置文件没问题，同时这个结果里你可以找到 nginx 的配置文件 nginx.conf 所在的位置。</p><h2 id="操纵-nginx-服务"><a href="#操纵-nginx-服务" class="headerlink" title="操纵 nginx 服务"></a>操纵 nginx 服务</h2><p>操纵服务，可以使用使用 service 命令，它可以启动（start），重启（restart），或停止服务（stop），比如要启动 nginx 服务：</p><pre><code>service nginx start</code></pre><p>服务启动以后，你就可以在浏览器上使用服务器的 IP 地址，或者指向这个地址的域名访问服务器指定的目录了。你会看到类似下面的这些文字。</p><pre><code>Welcome to nginx! If you see this page, the nginx web server is successfully installed and working. Further configuration is required. For online documentation and support please refer to nginx.org. Commercial support is available at nginx.com. Thank you for using nginx.</code></pre><h2 id="nginx配置部分"><a href="#nginx配置部分" class="headerlink" title="nginx配置部分"></a>nginx配置部分</h2><p>下面来看一下为 nginx 配置虚拟主机。先进入到 nginx 配置文件目录：</p><pre><code>cd /etc/nginx/conf.d</code></pre><p>复制这个目录里的 default.conf ，复制以后的名字可以使用你的虚拟主机名字。比如创建一个 nginx.ninghao.net 的虚拟主机。复制文件可以使用 cp 命令，像这样：</p><pre><code>cp default.conf nginx.ninghao.net.conf</code></pre><p>再去编辑一下这个复制以后的配置文件，可以使用 vim 命令：</p><pre><code>vim nginx.ninghao.net.conf</code></pre><p>你会看到像这样的代码：</p><pre><code>server { listen 80; server_name localhost; #charset koi8-r; #access_log   /var/log/nginx/log/host.access.log main; location / { root /usr/share/nginx/html; index index.html index.htm;}...}</code></pre><blockquote><p>server_name 就是主机名，也就是跟这个虚拟主机绑定在一块儿的域名，我事先把 nginx.ninghao.net 指向了服务器，这个虚拟主机就是为它准备的，所以，server_name 后面的东西就是 nginx.ninghao.net 。</p><p>紧接着 server_name 下面可以是一个root，就是这个虚拟主机的根目录，也就是网站所在的目录。比如我们要把 nginx.ninghao.net 这个网站的文件放在/home/www/nginx.ninghao.net 下面，那么这个 root 就是这个路径。</p></blockquote><p>然后去掉 location / 里面的 root 这行代码。再在 index 后面加上一种索引文件名，也就是默认打开的文件，这里要加上一个 index.php ，这样访问 nginx.ninghao.net 就可以直接打开 root 目录下面的 index.php 了。稍后我们再去安装 php 。修改之后，看起来像这样：</p><pre><code>server { listen 80; server_name nginx.ninghao.net; root /home/www/nginx.ninghao.net; #charset koi8-r; #access_log /var/log/nginx/log/host.access.log main; location / { index index.php index.html index.htm; }...}</code></pre><p>这个配置文件先修改到这，稍后，我们再回来继续修改一下它。保存一下，按 esc ，输入 :wp（保存并退出）。现在虚拟主机应该就可以使用了。主机的域名是 nginx.ninghao.net，访问它的时候，打开的是 /home/www/nginx.ninghao.net 这个目录里面的东西，你可以在这个目录下放点东西。</p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/servers/ngnix0003.png" alt="HYMBA"></p><p>重启 nginx 或者重新加载 nginx 可以让配置文件生效。</p><pre><code>service nginx reload</code></pre><p>现在，打开浏览器，输入你为虚拟主机设置的域名，看看是否能打开你指定的目录里的东西。</p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/servers/ngnix0002.png" alt="HYMBA"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 配置完阿里控制台之后，首先我们开始配置服务器，我的服务器各种配置都需要自己重新配，这里我现在Ngnix，不要问我为什么选择他，可能是之前用过Apache，对他印象不好吧……&lt;/p&gt;
    
    </summary>
    
      <category term="Server" scheme="https://icocos.github.io/categories/Server/"/>
    
    
      <category term="Server" scheme="https://icocos.github.io/tags/Server/"/>
    
      <category term="Nginx安装与配置" scheme="https://icocos.github.io/tags/Nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>服务器配置——阿里云主机配置与操作</title>
    <link href="https://icocos.github.io/2018/05/01/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%BB%E6%9C%BA/"/>
    <id>https://icocos.github.io/2018/05/01/服务器配置——阿里云主机/</id>
    <published>2018-05-01T10:00:54.000Z</published>
    <updated>2018-08-06T17:26:24.290Z</updated>
    
    <content type="html"><![CDATA[<p> 去年中旬在阿里买了一个属于自己的个性域名(笔者英文)：<a href="http://www.icocos.cn，虽然是CN，但是这都不是重点，重点是为了更全面的接触后台，更好的学习与实战后台开发与PHP，前天又在阿里买了个主机，打算开发玩弄一番，毕竟第一次，期间可能会遇到不少坑和不对的地方，望谅解与指出一起交流，谢谢....." target="_blank" rel="noopener">www.icocos.cn，虽然是CN，但是这都不是重点，重点是为了更全面的接触后台，更好的学习与实战后台开发与PHP，前天又在阿里买了个主机，打算开发玩弄一番，毕竟第一次，期间可能会遇到不少坑和不对的地方，望谅解与指出一起交流，谢谢.....</a>.</p><a id="more"></a><h2 id="阿里云（先声明我不是来给阿里大广告的，😂😂😂😂😂😂）"><a href="#阿里云（先声明我不是来给阿里大广告的，😂😂😂😂😂😂）" class="headerlink" title="阿里云（先声明我不是来给阿里大广告的，😂😂😂😂😂😂）"></a>阿里云（先声明我不是来给阿里大广告的，😂😂😂😂😂😂）</h2><ol><li>阿里云主机</li><li>域名：<a href="http://www.icocos.cn" target="_blank" rel="noopener">www.icocos.cn</a></li></ol><p>这里关于阿里云主机和域名的购买很简单，准备钱，一路点下去就可以了,具体操作强查看阿里文档……</p><h2 id="备案"><a href="#备案" class="headerlink" title="备案"></a>备案</h2><p>关于备案确实是不少人蛋疼的事情，说麻烦也没有多麻烦，说不麻烦但是搞起来又不是点几下就可以的，所以也有不少人选择了不需要备案的或者国外的主机，我当时也有这种想法，但是后来放弃了，投资嘛，自己都不舍得投资还怎么学东西，怎么提升呢！</p><pre><code>本案分个人备案和企业备案，具体详情阿里也有教程，或者网上也有相关教程</code></pre><h2 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h2><p>在链接之前可能需要做一些配置，但是有些事必须的有些可以后面备案成功之后再做，我就是第一次弄所以一直不懂，以为需要备案以后才能操作的。</p><h3 id="添加安全组织，允许22端口访问"><a href="#添加安全组织，允许22端口访问" class="headerlink" title="添加安全组织，允许22端口访问"></a>添加安全组织，允许22端口访问</h3><p>这里其实就是进入阿里控制台的云服务ECS，找到安全组，添加安全组，配置规则就可以.</p><p>这里只要注意</p><pre><code>端口:22/22授权对象：0.0.0.0/0</code></pre><p>初步的这样就可以了，我是为了方便链接访问</p><blockquote><p>然后就可以链接了</p></blockquote><h2 id="连接，并操作"><a href="#连接，并操作" class="headerlink" title="连接，并操作"></a>连接，并操作</h2><p>连接的话当然首选ssh，不要问我为什么，我也不知道，大家都用它，哈哈！</p><h3 id="关于SSH"><a href="#关于SSH" class="headerlink" title="关于SSH"></a>关于SSH</h3><p>SSH是每一台Linux电脑的标准配置。</p><pre><code>简单说，SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。</code></pre><h3 id="最基本的用法"><a href="#最基本的用法" class="headerlink" title="最基本的用法"></a>最基本的用法</h3><p>SSH主要用于远程登录。假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。</p><p>　　$ ssh user@host</p><p>如果本地用户名与远程用户名一致，登录时可以省略用户名。</p><p>　　$ ssh host</p><p>SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。</p><p>　　$ ssh -p 2222 user@host</p><p>上面这条命令表示，ssh直接连接远程主机的2222端口。</p><h3 id="这里我使用的是SSH-shell这个工具，Windows用什么不知道，网上应该一大堆"><a href="#这里我使用的是SSH-shell这个工具，Windows用什么不知道，网上应该一大堆" class="headerlink" title="这里我使用的是SSH shell这个工具，Windows用什么不知道，网上应该一大堆"></a>这里我使用的是SSH shell这个工具，Windows用什么不知道，网上应该一大堆</h3><p>命令行步骤</p><pre><code>输入 ssh root@ip地址输入yes输入密码</code></pre><p>就可以看到显示</p><pre><code>[root@iZwz92qgus0ln1nx5dftjd2rZ ~]#</code></pre><p>SSH工具使用也很简单，进后点击Add Server输入ip，端口是默认22，输入root用户名，输入后台配置的密码，对了这里的密码是需要在控制台配置的</p><p>一切顺利的话可以看到一个和terminal一样的终端界面，并且已经连接成功的显示</p><pre><code>[root@iZwz92qgus0ln1nx5dftjd2rZ ~]#</code></pre><p>然后就可以使用命令操作主机文件了。</p><h2 id="密码登录：Mac-客户端"><a href="#密码登录：Mac-客户端" class="headerlink" title="密码登录：Mac 客户端"></a>密码登录：Mac 客户端</h2><h3 id="进入-ssh-文件夹，如果没有就创建一个-ssh文件夹"><a href="#进入-ssh-文件夹，如果没有就创建一个-ssh文件夹" class="headerlink" title="进入.ssh 文件夹，如果没有就创建一个.ssh文件夹"></a>进入.ssh 文件夹，如果没有就创建一个.ssh文件夹</h3><pre><code>mkdir ~/.sshcd ~/.ssh/</code></pre><h3 id="生成rsa秘钥：这个相信大部分人都弄过，github就需要"><a href="#生成rsa秘钥：这个相信大部分人都弄过，github就需要" class="headerlink" title="生成rsa秘钥：这个相信大部分人都弄过，github就需要"></a>生成rsa秘钥：这个相信大部分人都弄过，github就需要</h3><pre><code>ssh-keygen -t rsa</code></pre><h3 id="在该文件夹下就会产生三个文件夹：id-rsa-id-rsa-pub-know-hosts。"><a href="#在该文件夹下就会产生三个文件夹：id-rsa-id-rsa-pub-know-hosts。" class="headerlink" title="在该文件夹下就会产生三个文件夹：id_rsa,id_rsa.pub,know_hosts。"></a>在该文件夹下就会产生三个文件夹：id_rsa,id_rsa.pub,know_hosts。</h3><pre><code>id_rsa：存储私钥，记得只能自己看哦。别人那到这个文件就完蛋蛋咯。id_rsa.pub:存储公钥，用来通信加密使用，有了这个人家才能确定这是你。</code></pre><h3 id="公钥拷贝到云主机"><a href="#公钥拷贝到云主机" class="headerlink" title="公钥拷贝到云主机"></a>公钥拷贝到云主机</h3><pre><code>scp id_rsa.pub  root@78.129.23.45:/root/.ssh/id_rsa.pub</code></pre><h3 id="Note-云主机上没有-ssh-文件时，你要自己建立一个。"><a href="#Note-云主机上没有-ssh-文件时，你要自己建立一个。" class="headerlink" title="Note:云主机上没有.ssh/文件时，你要自己建立一个。"></a>Note:云主机上没有.ssh/文件时，你要自己建立一个。</h3><p>终端连接后输入ls只能看到default.pass文件，ls -a发现也是没有.ssh文件夹的，所以需要输入下面命令创建.ssh文件夹</p><pre><code>mkdir .ssh #回车没有提示就成功再次ls -a就可以看到一个蓝色的隐藏文件夹</code></pre><h2 id="登录到云主机"><a href="#登录到云主机" class="headerlink" title="登录到云主机"></a>登录到云主机</h2><h3 id="进入-ssh-文件夹"><a href="#进入-ssh-文件夹" class="headerlink" title="进入.ssh/文件夹"></a>进入.ssh/文件夹</h3><pre><code>cd  /root/.ssh/</code></pre><h3 id="将客户端公钥放入云主机识别keys文件夹中"><a href="#将客户端公钥放入云主机识别keys文件夹中" class="headerlink" title="将客户端公钥放入云主机识别keys文件夹中"></a>将客户端公钥放入云主机识别keys文件夹中</h3><pre><code>cat id_rsa.pub &gt;&gt; authorized_keys</code></pre><h3 id="销毁公钥"><a href="#销毁公钥" class="headerlink" title="销毁公钥"></a>销毁公钥</h3><pre><code>rm id_rsa.pub</code></pre><p>再次输入ssh root@ip地址就可以直接连接了，当然如果你使用工具的话就不用这么麻烦。</p><blockquote><p>到这里就基本上初步，而且是很简单的实现的主机的查看与操作，具体更多操作和命令请查看相关资料，后期也会有一些配置，操作与实战，请期待</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 去年中旬在阿里买了一个属于自己的个性域名(笔者英文)：&lt;a href=&quot;http://www.icocos.cn，虽然是CN，但是这都不是重点，重点是为了更全面的接触后台，更好的学习与实战后台开发与PHP，前天又在阿里买了个主机，打算开发玩弄一番，毕竟第一次，期间可能会遇到不少坑和不对的地方，望谅解与指出一起交流，谢谢.....&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.icocos.cn，虽然是CN，但是这都不是重点，重点是为了更全面的接触后台，更好的学习与实战后台开发与PHP，前天又在阿里买了个主机，打算开发玩弄一番，毕竟第一次，期间可能会遇到不少坑和不对的地方，望谅解与指出一起交流，谢谢.....&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="Server" scheme="https://icocos.github.io/categories/Server/"/>
    
    
      <category term="Server" scheme="https://icocos.github.io/tags/Server/"/>
    
      <category term="阿里云主机配置与操作" scheme="https://icocos.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>iOS——开发者中心更新手机号码</title>
    <link href="https://icocos.github.io/2018/04/26/iOS%E2%80%94%E2%80%94%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%AD%E5%BF%83%E6%9B%B4%E6%96%B0%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81/"/>
    <id>https://icocos.github.io/2018/04/26/iOS——开发者中心更新手机号码/</id>
    <published>2018-04-26T08:26:41.000Z</published>
    <updated>2018-08-06T18:33:42.269Z</updated>
    
    <content type="html"><![CDATA[<p>The Apple Developer 开发者中心更新手机号码 Program License Agreement has been updated…….</p><a id="more"></a><blockquote><p>The Apple Developer 开发者中心更新手机号码 Program License Agreement has been updated.</p></blockquote><h5 id="从而导致："><a href="#从而导致：" class="headerlink" title="从而导致："></a>从而导致：</h5><pre><code>1. 无法提交新APP2. 无法编辑证书</code></pre><p>从而造成无法继续做任何App更新，与证书相关的操作。</p><blockquote><p>于是开始联系苹果技术客服（400 670 1855），但是在天朝开发者的数量你懂的，于是，不管三七二十几，拨通了放一边不管，因为我打过不下5次客服，排队时间从来没有少于半个小时了。</p></blockquote><p>……</p><blockquote><p>等了近两个小时候，既然通了，叙事描述了一番，让我根据他们的说明提交对应的信息和问题的描述，然后让我们等2-3个工作日，当时我就闹过了，但是也没有办法，谁让人家是爸爸呢！</p></blockquote><p>于是在等待苹果消息的时候，不定时的进入后台刷新查看状态，同事在寻求各种大神和好友的帮助。</p><h6 id="最后在一个群里看到了一个比较直接的解决方案，当然也比较变态，这一切都都应该是苹果的锅。"><a href="#最后在一个群里看到了一个比较直接的解决方案，当然也比较变态，这一切都都应该是苹果的锅。" class="headerlink" title="最后在一个群里看到了一个比较直接的解决方案，当然也比较变态，这一切都都应该是苹果的锅。"></a>最后在一个群里看到了一个比较直接的解决方案，当然也比较变态，这一切都都应该是苹果的锅。</h6><h4 id="具体方案是这样的："><a href="#具体方案是这样的：" class="headerlink" title="具体方案是这样的："></a>具体方案是这样的：</h4><pre><code>1、在修改手机号的页面，将COUNTRY / REGION一栏的国家从中国改成香港（Hong Kong）2、修改地区会提示你修改付款信息（随便瞎填一下就行了，修改后记得点保存）3、和原来的步骤一样，在REACHABLE AT（改手机号旁）处，点击Add More..添加手机号（如果之前添加了，建议删除重新添加）</code></pre><p>这个时候，就可以去登录开发者中心了，如果前面几步操作无误，就不会再提示让修改手机号了，然后点击同意协议就行了！</p><p>最后别忘了把地区改回中国！</p><blockquote><p>网上有小伙伴给出了具体原因：</p></blockquote><p>因为中国的iCloud数据转到中国,更新后数据在中国保存,开发中心获取不到导致的。</p><p>当然，还有一些小伙伴也有其他的方案，由于我们已经搞定了，所以就没有尝试，如果感兴趣可以试试！</p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/180424/apple/apple.jpeg" alt="曹理鹏(iCocos)-梦工厂"></p><p>期间如果具体遇到了问题，我相信作为一个合格的开发的，难不到你，哈哈！</p><blockquote><p>好了，今天，我们就到这里</p></blockquote><blockquote><p>拜了个拜……</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The Apple Developer 开发者中心更新手机号码 Program License Agreement has been updated…….&lt;/p&gt;
    
    </summary>
    
      <category term="Apple" scheme="https://icocos.github.io/categories/Apple/"/>
    
    
      <category term="Apple" scheme="https://icocos.github.io/tags/Apple/"/>
    
      <category term="开发者中心更新手机号码" scheme="https://icocos.github.io/tags/%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%AD%E5%BF%83%E6%9B%B4%E6%96%B0%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>iOS——Xcode默认路径(Fastlane打包)</title>
    <link href="https://icocos.github.io/2018/04/24/iOS%E2%80%94%E2%80%94Xcode%E9%BB%98%E8%AE%A4%E8%B7%AF%E5%BE%84-Fastlane%E6%89%93%E5%8C%85/"/>
    <id>https://icocos.github.io/2018/04/24/iOS——Xcode默认路径-Fastlane打包/</id>
    <published>2018-04-24T09:44:45.000Z</published>
    <updated>2018-08-06T17:26:23.642Z</updated>
    
    <content type="html"><![CDATA[<p>最近在使用fastlane的时候，发现踩了不少坑，但是大部分由于时间的原因没能即使记录下来…..</p><a id="more"></a><p>最近在使用fastlane的时候，发现踩了不少坑，但是大部分由于时间的原因没能即使记录下来</p><h5 id="这次简单的记录了一下前两天遇到的一个坑"><a href="#这次简单的记录了一下前两天遇到的一个坑" class="headerlink" title="这次简单的记录了一下前两天遇到的一个坑"></a>这次简单的记录了一下前两天遇到的一个坑</h5><blockquote><p>事情是这样的，由于公司的一个测试机不知道被谁脑残似的点点了升级，于是系统直接到11.3，从而导致我的Xcode版本不支持对应真机的调试，</p></blockquote><h6 id="于是想着网上找对应的真机包，发现并没有找到，可能是我搜索能力不行，如果你有最新的，多多分享哦。"><a href="#于是想着网上找对应的真机包，发现并没有找到，可能是我搜索能力不行，如果你有最新的，多多分享哦。" class="headerlink" title="于是想着网上找对应的真机包，发现并没有找到，可能是我搜索能力不行，如果你有最新的，多多分享哦。"></a>于是想着网上找对应的真机包，发现并没有找到，可能是我搜索能力不行，如果你有最新的，多多分享哦。</h6><blockquote><p>然后我就开始升级Xcode，但是发现升级Xcode又要升级系统，麻蛋。</p><ul><li>于是就有了下面的一路<br>升级系统<br>升级Xcode 9.3<br>编译一下，发现报错，报错的位置是WCDB，<br>于是在官方群里问了一下，发现是WCDB的一个大坑，于是github有人提出了两种方式</li></ul></blockquote><p>在 Xcode 9.3 来 Swift 4.0.3 的方法，该方法可以临时解决 WCDB 的问题。</p><pre><code>1. 下载并安装 Swift 4.0.3 的 toolchain: https://swift.org/builds/swift-4.0.3-release/xcode/swift-4.0.3-RELEASE/swift-4.0.3-RELEASE-osx.pkg2. 在 Xcode 中选择 Preferences -&gt; Components -&gt; Toolchains，选择 Swift 4.0.3 Release3. Clean 并重编你的 Xcode 工程</code></pre><p>综合考虑之后，我暂时选择放弃的那台11.3的真机调试功能，只能通过扫描安装</p><ul><li>于是又有了下面的一路<blockquote><p>下载并安装Xcode 9.2<br>编译项目<br>…..</p></blockquote></li></ul><p>就在下班的时候，准备打包，没过几分钟就发现，变态的fastlane报错了（这是要闹哪一出，我都打算打完包直接闪人的）</p><h5 id="具体错误如下："><a href="#具体错误如下：" class="headerlink" title="具体错误如下："></a>具体错误如下：</h5><pre><code>+-----------------------+---------+--------+|               Used plugins               |+-----------------------+---------+--------+| Plugin                | Version | Action |+-----------------------+---------+--------+| fastlane-plugin-pgyer | 0.2.1   | pgyer  |+-----------------------+---------+--------+[14:34:34]: ----------------------------------------[14:34:34]: --- Step: Verifying fastlane version ---[14:34:34]: ----------------------------------------[14:34:34]: Your fastlane version 2.89.0 matches the minimum requirement of 2.89.0  ✅[14:34:34]: ------------------------------[14:34:34]: --- Step: default_platform ---[14:34:34]: ------------------------------[14:34:34]: Driving the lane &apos;ios development_build&apos; 🚀[14:34:34]: 开始打development ipa[14:34:34]: ------------------------------[14:34:34]: --- Step: get_build_number ---[14:34:34]: ------------------------------。。。。。。[14:34:34]: fastlane finished with errorsLooking for related GitHub issues on fastlane/fastlane.../Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane_core/lib/fastlane_core/ui/interface.rb:145:in `shell_error!&apos;: [!] Exit status of command &apos;cd /Users/icocos/Desktop/\积\木\塔\科\技/\源\码/Fiction_iOS &amp;&amp; agvtool what-version -terse&apos; was 1 instead of 0. (FastlaneCore::Interface::FastlaneShellError)xcode-select: error: tool &apos;agvtool&apos; requires Xcode, but active developer directory &apos;/Library/Developer/CommandLineTools&apos; is a command line tools instancefrom /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane_core/lib/fastlane_core/ui/ui.rb:17:in `method_missing&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/helper/sh_helper.rb:80:in `sh_control_output&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/helper/sh_helper.rb:12:in `sh&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/actions/get_build_number.rb:28:in `run&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/runner.rb:257:in `block (2 levels) in execute_action&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/actions/actions_helper.rb:50:in `execute_action&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/runner.rb:236:in `block in execute_action&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/runner.rb:231:in `chdir&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/runner.rb:231:in `execute_action&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/runner.rb:157:in `trigger_action_by_name&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/fast_file.rb:148:in `method_missing&apos;from Fastfile:10:in `updateProjectBuildNumber&apos;from Fastfile:45:in `block (2 levels) in parsing_binding&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/lane.rb:33:in `call&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/runner.rb:49:in `block in execute&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/runner.rb:45:in `chdir&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/runner.rb:45:in `execute&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/lane_manager.rb:57:in `cruise_lane&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/command_line_handler.rb:36:in `handle&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/commands_generator.rb:108:in `block (2 levels) in run&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1@global/gems/commander-fastlane-4.4.6/lib/commander/command.rb:178:in `call&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1@global/gems/commander-fastlane-4.4.6/lib/commander/command.rb:153:in `run&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1@global/gems/commander-fastlane-4.4.6/lib/commander/runner.rb:476:in `run_active_command&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane_core/lib/fastlane_core/ui/fastlane_runner.rb:75:in `run!&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1@global/gems/commander-fastlane-4.4.6/lib/commander/delegates.rb:15:in `run!&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/commands_generator.rb:333:in `run&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/commands_generator.rb:42:in `start&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/cli_tools_distributor.rb:107:in `take_off&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/bin/fastlane:20:in `&lt;top (required)&gt;&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1/bin/fastlane:23:in `load&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1/bin/fastlane:23:in `&lt;main&gt;&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1/bin/ruby_executable_hooks:15:in `eval&apos;from /Users/icocos/.rvm/gems/ruby-2.4.1/bin/ruby_executable_hooks:15:in `&lt;main&gt;&apos;xcode-select: error: tool &apos;agvtool&apos; requires Xcode, but active developer directory &apos;/Library/Developer/CommandLineTools&apos; is a command line tools instancexcode-select: error: tool &apos;xcodebuild&apos; requires Xcode, but active developer directory &apos;/Library/Deve</code></pre><p>我尝试着杀进程，重启电脑，升级fastlane，然而并没有什么卵用</p><h5 id="于是网上到处寻找答案："><a href="#于是网上到处寻找答案：" class="headerlink" title="于是网上到处寻找答案："></a>于是网上到处寻找答案：</h5><p>按照stack中的方案一，卸载fastlane重新安装，捣鼓了一会打算重新打包的时候，还是这个错，我就很奇怪了，</p><h5 id="然后，我整理了一下思路"><a href="#然后，我整理了一下思路" class="headerlink" title="然后，我整理了一下思路"></a>然后，我整理了一下思路</h5><ul><li>Xcode9.2直接升级到9.3，升级和运行fasrlane，再次安装9.2，于是有了两个Xcode，当时我就蒙圈了</li></ul><p>就根据具体问题网上找到了一个重置默认Xcode的方式：</p><pre><code>sudo xcode-select --switch /Applications/Xcode\ 9.2.app/Contents/Developer</code></pre><p>以上错误是因为安装了 xcode , 但并不是系统默认的位置, 所以可以使用以下命令把 xcode 的路径修改为你安装的位置即可</p><p>switch后面部分就是安装的 xcode 的自定义路径.</p><blockquote><p>再次运行fastlane，发现成功了，当时我真想扇自己两耳光.</p></blockquote><p>这问题貌似并没有撒难度，只是当时急着上线，有点脑残了，耗费了我将近4个小时，然后悄悄的回家了，</p><h5 id="到家已是2点多……"><a href="#到家已是2点多……" class="headerlink" title="到家已是2点多……"></a>到家已是2点多……</h5>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在使用fastlane的时候，发现踩了不少坑，但是大部分由于时间的原因没能即使记录下来…..&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://icocos.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://icocos.github.io/tags/iOS/"/>
    
      <category term="Xcode默认路径（Fastlane打包的尴尬）" scheme="https://icocos.github.io/tags/Xcode%E9%BB%98%E8%AE%A4%E8%B7%AF%E5%BE%84%EF%BC%88Fastlane%E6%89%93%E5%8C%85%E7%9A%84%E5%B0%B4%E5%B0%AC%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>iOS——3-rf一把无形的双刃剑</title>
    <link href="https://icocos.github.io/2018/04/20/iOS%E2%80%94%E2%80%943-rf%E4%B8%80%E6%8A%8A%E6%97%A0%E5%BD%A2%E7%9A%84%E5%8F%8C%E5%88%83%E5%89%91/"/>
    <id>https://icocos.github.io/2018/04/20/iOS——3-rf一把无形的双刃剑/</id>
    <published>2018-04-20T09:45:36.000Z</published>
    <updated>2018-08-06T18:33:42.506Z</updated>
    
    <content type="html"><![CDATA[<p>今天我就遇到一个奇葩的问题，上一次编译并打包成功和这一次报错之间就一个上厕所的时间…..</p><a id="more"></a><h5 id="大部分情况下，在项目报错的时候"><a href="#大部分情况下，在项目报错的时候" class="headerlink" title="大部分情况下，在项目报错的时候"></a>大部分情况下，在项目报错的时候</h5><ul><li>很多人会选择clean再次编译</li><li>退出xcode重新编译</li><li>清楚drivedata重新编译</li><li>重启电脑重新编译</li></ul><p>今天我就遇到一个奇葩的问题，上一次编译并打包成功和这一次报错之间就一个上厕所的时间。</p><h4 id="具体错误"><a href="#具体错误" class="headerlink" title="具体错误"></a>具体错误</h4><pre><code>ld: file too small (length=0) file     &apos;/Users/icocos/Library/Developer/Xcode/DerivedData/Fiction_iOS-ccljhnehuyrphfbjlldfaqmstvub/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/RxSwift.build/Objects-normal/arm64/Just.o&apos;     for architecture arm64clang: error: linker command failed with exit code 1 (use -v to see invocation)</code></pre><blockquote><p>以上错误来自RXSwift。</p></blockquote><p>查看git仓库，但是一句代码也没改，连一个空格都没有动</p><h6 id="于是我就按照上面的走了一遍，发现并没有什么卵用-于是我在想"><a href="#于是我就按照上面的走了一遍，发现并没有什么卵用-于是我在想" class="headerlink" title="于是我就按照上面的走了一遍，发现并没有什么卵用,于是我在想:"></a>于是我就按照上面的走了一遍，发现并没有什么卵用,于是我在想:</h6><p>最后在一个群里有位大佬给了一个方案：</p><pre><code>rm -rf $HOME/Library/Developer/Xcode/DerivedData/*rm -rf $HOME/Library/Caches/com.apple.dt.Xcode/*rm -rf &quot;$(getconf DARWIN_USER_CACHE_DIR)/org.llvm.clang/ModuleCache&quot;</code></pre><p>既然真的成功了。我们暂且把它叫做3rf。</p><p>关于rf这里有一个圈内的笑话：</p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/2018/05/rf0001.png" alt="曹理鹏(iCocos)-梦工厂"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我就遇到一个奇葩的问题，上一次编译并打包成功和这一次报错之间就一个上厕所的时间…..&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://icocos.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://icocos.github.io/tags/iOS/"/>
    
      <category term="3-rf一把无形的双刃剑" scheme="https://icocos.github.io/tags/3-rf%E4%B8%80%E6%8A%8A%E6%97%A0%E5%BD%A2%E7%9A%84%E5%8F%8C%E5%88%83%E5%89%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS——奇葩需求QQ号与QQ群添加与跳转</title>
    <link href="https://icocos.github.io/2018/04/18/iOS%E2%80%94%E2%80%94%E5%A5%87%E8%91%A9%E9%9C%80%E6%B1%82QQ%E5%8F%B7%E4%B8%8EQQ%E7%BE%A4%E6%B7%BB%E5%8A%A0%E4%B8%8E%E8%B7%B3%E8%BD%AC/"/>
    <id>https://icocos.github.io/2018/04/18/iOS——奇葩需求QQ号与QQ群添加与跳转/</id>
    <published>2018-04-18T15:06:24.000Z</published>
    <updated>2018-08-06T18:33:42.553Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做一个新的二次元游戏App，说真的第一次做游戏一开始有点压力，但是后面了解到用到的技术其实跟游戏没有太多关系，就巴拉巴拉的开始写了，但是由于只有一个人，项目赶着上线，再加上之前需求的不明确和中途的调整，导致期间也浪费了不少时间，最近在实现最后一个功能的时候遇到了点问题，一开始是我想的太复杂了，后面群里一问，网上一了解，发现：MMP，这么简单，说多了都是尿，于是记录了这一切……..</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>本文的起因：</p></blockquote><blockquote><p>新项目，一个人纯swift开发，有个小功能第一次遇到，就是在用户中心有一行显示（群号+点击加群）文案，点击这一行拉起QQ App，如果QQ APP所登录的QQ已经加入了QQ号就直接到群聊页面，如果没有就跳到加群页面，可以点击申请加群。</p></blockquote><h5 id="注意：-这里其实是打开QQ后，使用QQ来去打开了一个网页。"><a href="#注意：-这里其实是打开QQ后，使用QQ来去打开了一个网页。" class="headerlink" title="注意： 这里其实是打开QQ后，使用QQ来去打开了一个网页。"></a>注意： 这里其实是打开QQ后，使用QQ来去打开了一个网页。</h5><p>下面上代码：</p><h3 id="一下是朋友提供的OC代码"><a href="#一下是朋友提供的OC代码" class="headerlink" title="一下是朋友提供的OC代码"></a>一下是朋友提供的OC代码</h3><pre><code>- (NSURL*)getQQQunUrl {    NSString *qq_number = @&quot;??&quot;    NSString* urlStr = [NSString stringWithFormat:@&quot;mqqapi://card/show_pslcard?src_type=internal&amp;version=1&amp;uin=%@&amp;key=%@&amp;card_type=group&amp;source=external&quot;, qq_number, @&quot;44a6e01f2dab126f87ecd2ec7b7e66ae259b30535fd0c2c25776271e8c0ac08f&quot;];    return [NSURL URLWithString:urlStr];}</code></pre><h4 id="调用方式："><a href="#调用方式：" class="headerlink" title="调用方式："></a>调用方式：</h4><pre><code>NSURL* url = [self getQQqunUrl];if ([[UIApplication sharedApplication] canOpenURL:url]) {    [[UIApplication sharedApplication] openURL:url];}</code></pre><h3 id="这是我最终Swift的实现方式"><a href="#这是我最终Swift的实现方式" class="headerlink" title="这是我最终Swift的实现方式"></a>这是我最终Swift的实现方式</h3><pre><code>func getQQQunUrl() -&gt; String {    let qq_number = &quot;??&quot;    let url_str = &quot;mqqapi://card/show_pslcard?src_type=internal&amp;version=1&amp;uin=\(qq_number)&amp;key=44a6e01f2dab126f87ecd2ec7b7e66ae259b30535fd0c2c25776271e8c0ac08f&amp;card_type=group&amp;source=external&quot;    return url_str}</code></pre><h4 id="调用方式：-1"><a href="#调用方式：-1" class="headerlink" title="调用方式："></a>调用方式：</h4><pre><code>let urlString = self.getQQQunUrl()if let url = URL(string: urlString) {    //根据iOS系统版本，分别处理    if #available(iOS 10, *) {        UIApplication.shared.open(url, options: [:], completionHandler: { (success) in })    } else {        UIApplication.shared.openURL(url)    }}</code></pre><blockquote><p>只要替换以上QQ好就可以，看着代码是不是很简单，算了不说了，我都想静一静……</p></blockquote><p>来看看效果图：</p><h5 id="加群之前的效果"><a href="#加群之前的效果" class="headerlink" title="加群之前的效果"></a>加群之前的效果</h5><p><img src="http://pd1l3bbt7.bkt.clouddn.com/201801Images/JMT/0316/0002.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/201801Images/JMT/0316/0003.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h5 id="加群之后的效果"><a href="#加群之后的效果" class="headerlink" title="加群之后的效果"></a>加群之后的效果</h5><p><img src="http://pd1l3bbt7.bkt.clouddn.com/201801Images/JMT/0316/0004.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/201801Images/JMT/0316/0005.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h2 id="QQ号调整"><a href="#QQ号调整" class="headerlink" title="QQ号调整"></a>QQ号调整</h2><p>最近又有一个新的需求，由于需求比较相似，于是我直接在这里追加了。</p><p>需要处理QQ号的跳转，点击直接打开QQ调用网页版加号或者聊天页面</p><blockquote><p>其实功能并没有任何难度在，其实寻找对应的链接，替换内部信息就可以。</p></blockquote><p>一下只提供OC和Swift的关键代码：</p><h3 id="OC的实现方式"><a href="#OC的实现方式" class="headerlink" title="OC的实现方式"></a>OC的实现方式</h3><pre><code>//qqNumber就是你要打开的QQ号码， 也就是你的客服号码。NSString  *qqNumber=@&quot;QQ号&quot;;if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;mqq://&quot;]]) {    UIWebView *webView = [[UIWebView alloc] initWithFrame:CGRectZero];    NSURL * url=[NSURL URLWithString:[NSString stringWithFormat:@&quot;mqq://im/chat?chat_type=wpa&amp;uin=%@&amp;version=1&amp;src_type=web&quot;,qqNumber]];    NSURLRequest *request = [NSURLRequest requestWithURL:url];    webView.delegate = self;    [webView loadRequest:request];    [self.view addSubview:webView];}</code></pre><h3 id="Swift的实现方式"><a href="#Swift的实现方式" class="headerlink" title="Swift的实现方式"></a>Swift的实现方式</h3><pre><code>// 打开Urlclass func openOuterUrl(_ url: String) {    if let url = URL(string: url) {        //根据iOS系统版本，分别处理        if UIApplication.shared.canOpenURL(url)  {            //根据iOS系统版本，分别处理            if #available(iOS 10, *) {                UIApplication.shared.open(url, options: [:],                completionHandler: { (success) in })            } else {                UIApplication.shared.openURL(url)            }        }    }}class func getQQUrl() -&gt; String {    let url_str = &quot;mqq://im/chat?chat_type=wpa&amp;uin=\(self.getQQ())&amp;version=1&amp;src_type=web&quot;    return url_str}</code></pre><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://www.jianshu.com/p/ac4981b634c2" target="_blank" rel="noopener">iOS调用QQ客户端,发起临时会话</a><br><a href="https://www.jianshu.com/p/d306a443bcc8" target="_blank" rel="noopener">IOS APP中打开指定qq聊天界面</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做一个新的二次元游戏App，说真的第一次做游戏一开始有点压力，但是后面了解到用到的技术其实跟游戏没有太多关系，就巴拉巴拉的开始写了，但是由于只有一个人，项目赶着上线，再加上之前需求的不明确和中途的调整，导致期间也浪费了不少时间，最近在实现最后一个功能的时候遇到了点问题，一开始是我想的太复杂了，后面群里一问，网上一了解，发现：MMP，这么简单，说多了都是尿，于是记录了这一切……..&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://icocos.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://icocos.github.io/tags/iOS/"/>
    
      <category term="QQ号与QQ群添加与调整功能" scheme="https://icocos.github.io/tags/QQ%E5%8F%B7%E4%B8%8EQQ%E7%BE%A4%E6%B7%BB%E5%8A%A0%E4%B8%8E%E8%B0%83%E6%95%B4%E5%8A%9F%E8%83%BD/"/>
    
  </entry>
  
</feed>
