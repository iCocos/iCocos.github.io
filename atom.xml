<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iCocos</title>
  
  <subtitle>www.icocos.cn</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://icocos.github.io/"/>
  <updated>2019-05-22T09:04:02.635Z</updated>
  <id>https://icocos.github.io/</id>
  
  <author>
    <name>曹理鹏@iCocos</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP面试题总结三</title>
    <link href="https://icocos.github.io/2019/06/18/PHP%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%E4%B8%89/"/>
    <id>https://icocos.github.io/2019/06/18/PHP面试题总结三/</id>
    <published>2019-06-18T14:22:18.000Z</published>
    <updated>2019-05-22T09:04:02.635Z</updated>
    
    <content type="html"><![CDATA[<h3 id="isset、empty、is-null的区别"><a href="#isset、empty、is-null的区别" class="headerlink" title="isset、empty、is_null的区别"></a>isset、empty、is_null的区别</h3><p>isset 判断变量是否定义或者是否为空</p><pre><code>变量存在返回ture，否则返回false变量定义不赋值返回falseunset一个变量，返回false变量赋值为null，返回false</code></pre><a id="more"></a><p>empty：判断变量的值是否为空，能转换为false的都是空，为空返回true，反之返回false。</p><pre><code>&quot;&quot;,0,&quot;0&quot;,NULL，FALSE都认为为空，返回true没有任何属性的对象都认为是空</code></pre><p>is_null：检测传入的值(值、变量、表达式)是否为null</p><pre><code>定义了，但是赋值为Null定义了，但是没有赋值unset一个变量</code></pre><h3 id="前端调试的工具"><a href="#前端调试的工具" class="headerlink" title="前端调试的工具"></a>前端调试的工具</h3><pre><code>Firefox的firebugChrome的开发工具EmmetJSON格式校验工具</code></pre><h3 id="简单描述mysql中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）（新浪网技术部）"><a href="#简单描述mysql中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）（新浪网技术部）" class="headerlink" title="简单描述mysql中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）（新浪网技术部）"></a>简单描述mysql中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）（新浪网技术部）</h3><pre><code>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。普通索引(由关键字KEY或INDEX定义的索引)的唯一任务是加快对数据的访问速度。普通索引允许被索引的数据列包含重复的值。如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。也就是说，唯一索引可以保证数据记录的唯一性。主键，是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引，这就是联合索引。索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件。</code></pre><h3 id="数据库中的事务是什么"><a href="#数据库中的事务是什么" class="headerlink" title="数据库中的事务是什么?"></a>数据库中的事务是什么?</h3><pre><code>事务（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。ACID 四大特性,原子性、隔离性、一致性、持久性。</code></pre><h3 id="了解XSS攻击吗？如何防止？"><a href="#了解XSS攻击吗？如何防止？" class="headerlink" title="了解XSS攻击吗？如何防止？"></a>了解XSS攻击吗？如何防止？</h3><pre><code>XSS是跨站脚本攻击，首先是利用跨站脚本漏洞以一个特权模式去执行攻击者构造的脚本，然后利用不安全的Activex控件执行恶意的行为。使用htmlspecialchars()函数对提交的内容进行过滤，使字符串里面的特殊符号实体化。</code></pre><h3 id="SQL注入漏洞产生的原因？如何防止？"><a href="#SQL注入漏洞产生的原因？如何防止？" class="headerlink" title="SQL注入漏洞产生的原因？如何防止？"></a>SQL注入漏洞产生的原因？如何防止？</h3><pre><code>SQL注入产生的原因：程序开发过程中不注意规范书写sql语句和对特殊字符进行过滤，导致客户端可以通过全局变量POST和GET提交一些sql语句正常执行。</code></pre><p>防止SQL注入的方式：</p><pre><code>开启配置文件中的magic_quotes_gpc 和 magic_quotes_runtime设置执行sql语句时使用addslashes进行sql语句转换Sql语句书写尽量不要省略双引号和单引号。过滤掉sql语句中的一些关键词：update、insert、delete、select、 * 。提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不易被猜到的。Php配置文件中设置register_globals为off,关闭全局变量注册控制错误信息，不要在浏览器上输出错误信息，将错误信息写到日志文件中。</code></pre><h3 id="PHP网站的主要攻击方式有哪些？"><a href="#PHP网站的主要攻击方式有哪些？" class="headerlink" title="PHP网站的主要攻击方式有哪些？"></a>PHP网站的主要攻击方式有哪些？</h3><pre><code>命令注入(Command Injection)eval 注入(Eval Injection)客户端脚本攻击(Script Insertion)跨网站脚本攻击(Cross Site Scripting, XSS)SQL 注入攻击(SQL injection)跨网站请求伪造攻击(Cross Site RequestForgeries, CSRF)Session 会话劫持(Session Hijacking)Session 固定攻击(Session Fixation)HTTP 响应拆分攻击(HTTP Response Splitting)文件上传漏洞(File Upload Attack)目录穿越漏洞(Directory Traversal)远程文件包含攻击(Remote Inclusion)动态函数注入攻击(Dynamic VariableEvaluation)URL 攻击(URL attack)表单提交欺骗攻击(Spoofed FormSubmissions)HTTP 请求欺骗攻击(Spoofed HTTP Requests)</code></pre><h3 id="框架中什么是单一入口和多入口-，-单一入口的优缺点？"><a href="#框架中什么是单一入口和多入口-，-单一入口的优缺点？" class="headerlink" title="框架中什么是单一入口和多入口 ， 单一入口的优缺点？"></a>框架中什么是单一入口和多入口 ， 单一入口的优缺点？</h3><pre><code>多口就是通过访问不同的文件来完成用户请求。单一入口只 web 程序所有的请求都指向一个脚本文件的。单一入口更容易控制权限，方便对 http 请求可以进行安全性检查。缺点：URL 看起来不那么美观，特别是对搜索引擎来说不友好。</code></pre><h2 id="对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题："><a href="#对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题：" class="headerlink" title="对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题："></a>对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题：</h2><h3 id="索引的目的是什么？"><a href="#索引的目的是什么？" class="headerlink" title="索引的目的是什么？"></a>索引的目的是什么？</h3><pre><code>快速访问数据表中的特定信息，提高检索速度创建唯一性索引，保证数据库表中每一行数据的唯一性。加速表和表之间的连接使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间</code></pre><h3 id="索引对数据库系统的负面影响是什么？"><a href="#索引对数据库系统的负面影响是什么？" class="headerlink" title="索引对数据库系统的负面影响是什么？"></a>索引对数据库系统的负面影响是什么？</h3><p>负面影响：<br>    创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。</p><h3 id="为数据表建立索引的原则有哪些？"><a href="#为数据表建立索引的原则有哪些？" class="headerlink" title="为数据表建立索引的原则有哪些？"></a>为数据表建立索引的原则有哪些？</h3><pre><code>在最频繁使用的、用以缩小查询范围的字段上建立索引。在频繁使用的、需要排序的字段上建立索引</code></pre><h3 id="什么情况下不宜建立索引？"><a href="#什么情况下不宜建立索引？" class="headerlink" title="什么情况下不宜建立索引？"></a>什么情况下不宜建立索引？</h3><pre><code>对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等。</code></pre><h2 id="简述在MySQL数据库中MyISAM和InnoDB的区别"><a href="#简述在MySQL数据库中MyISAM和InnoDB的区别" class="headerlink" title="简述在MySQL数据库中MyISAM和InnoDB的区别"></a>简述在MySQL数据库中MyISAM和InnoDB的区别</h2><pre><code>区别于其他数据库的最重要的特点就是其插件式的表存储引擎。切记：存储引擎是基于表的，而不是数据库。</code></pre><h3 id="InnoDB与MyISAM的区别："><a href="#InnoDB与MyISAM的区别：" class="headerlink" title="InnoDB与MyISAM的区别："></a>InnoDB与MyISAM的区别：</h3><pre><code>InnoDB存储引擎: 主要面向OLTP(Online Transaction Processing，在线事务处理)方面的应用，是第一个完整支持ACID事务的存储引擎(BDB第一个支持事务的存储引擎，已经停止开发)。</code></pre><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>行锁设计、支持外键；</p><pre><code>支持类似于Oracle风格的一致性非锁定读(即：默认情况下读取操作不会产生锁)；InnoDB将数据放在一个逻辑的表空间中，由InnoDB自身进行管理。从MySQL4.1版本开始，可以将每个InnoDB存储引擎的表单独存放到一个独立的ibd文件中；InnoDB通过使用MVCC(多版本并发控制：读不会阻塞写，写也不会阻塞读)来获得高并发性，并且实现了SQL标准的4种隔离级别(默认为REPEATABLE级别)；InnoDB还提供了插入缓冲(insert buffer)、二次写(double write)、自适应哈希索引(adaptive hash index)、预读(read ahead)等高性能和高可用的功能；InnoDB采用了聚集(clustered)的方式来存储表中的数据，每张标的存储都按主键的顺序存放(如果没有显式的在建表时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键)；InnoDB表会有三个隐藏字段：除了上面提到了6字节的DB_ROW_ID外，还有6字节的DB_TX_ID(事务ID)和7字节的DB_ROLL_PTR(指向对应回滚段的地址)。这个可以通过innodb monitor看到；MyISAM存储引擎: 是MySQL官方提供的存储引擎，主要面向OLAP(Online Analytical Processing,在线分析处理)方面的应用。特点：</code></pre><p>不支持事务，支持表所和全文索引。操作速度快；<br>MyISAM存储引擎表由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。MySQL数据库只缓存其索引文件，数据文件的缓存交给操作系统本身来完成；<br>MySQL5.0版本开始，MyISAM默认支持256T的单表数据；</p><h3 id="解释MySQL外连接、内连接与自连接的区别"><a href="#解释MySQL外连接、内连接与自连接的区别" class="headerlink" title="解释MySQL外连接、内连接与自连接的区别"></a>解释MySQL外连接、内连接与自连接的区别</h3><pre><code>先说什么是交叉连接: 交叉连接又叫笛卡尔积，它是指不使用任何条件，直接将一个表的所有记录和另一个表中的所有记录一一匹配。内连接 则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合条件的记录不会出现在结果集中，即内连接只连接匹配的行。外连接 其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或两个表中的所有数据行，这三种情况依次称之为左外连接，右外连接，和全外连接。左外连接，也称左连接，左表为主表，左表中的所有记录都会出现在结果集中，对于那些在右表中并没有匹配的记录，仍然要显示，右边对应的那些字段值以NULL来填充。右外连接，也称右连接，右表为主表，右表中的所有记录都会出现在结果集中。左连接和右连接可以互换，MySQL目前还不支持全外连接。</code></pre><h3 id="写出三种以上MySQL数据库存储引擎的名称（提示：不区分大小写）"><a href="#写出三种以上MySQL数据库存储引擎的名称（提示：不区分大小写）" class="headerlink" title="写出三种以上MySQL数据库存储引擎的名称（提示：不区分大小写）"></a>写出三种以上MySQL数据库存储引擎的名称（提示：不区分大小写）</h3><pre><code>MyISAM、InnoDB、BDB（BerkeleyDB）、Merge、Memory（Heap）、Example、Federated、Archive、CSV、Blackhole、MaxDB 等等十几个引擎</code></pre><h3 id="什么是面向对象？主要特征是什么？几大原则是什么？"><a href="#什么是面向对象？主要特征是什么？几大原则是什么？" class="headerlink" title="什么是面向对象？主要特征是什么？几大原则是什么？"></a>什么是面向对象？主要特征是什么？几大原则是什么？</h3><pre><code>面向对象是程序的一种设计模式，它利于提高程序的重用性，使程序机构更加清晰。 主要特征是：封装、继承、多态。五大基本原则： 单一职责原则；开放封闭原则；替换原则； 依赖原则； 接口分离原则。</code></pre><h3 id="什么是静态路由，其特点是什么-什么是动态路由，其特点是什么"><a href="#什么是静态路由，其特点是什么-什么是动态路由，其特点是什么" class="headerlink" title="什么是静态路由，其特点是什么?什么是动态路由，其特点是什么?"></a>什么是静态路由，其特点是什么?什么是动态路由，其特点是什么?</h3><p>参考答案：<br>    　　静态路由是由系统管理员设计与构建的路由表规定的路由。适用于网关数量有限的场 合，且网络拓朴结构不经常变化的网络。其缺点是不能动态地适用网络状况的变化，当 网络状况变化后必须由网络管理员修改路由表。<br>        动态路由是由路由选择协议而动态构建的，路由协议之间通过交换各自所拥有的路由信 息实时更新路由表的内容。动态路由可以自动学习网络的拓朴结构，并更新路由表。其 缺点是路由广播更新信息将占据大量的网络带宽。</p><h3 id="使用过-Memcache-缓存吗，如果使用过，能够简单的描述一下它的工作原理吗？"><a href="#使用过-Memcache-缓存吗，如果使用过，能够简单的描述一下它的工作原理吗？" class="headerlink" title="使用过 Memcache 缓存吗，如果使用过，能够简单的描述一下它的工作原理吗？"></a>使用过 Memcache 缓存吗，如果使用过，能够简单的描述一下它的工作原理吗？</h3><pre><code>Memcahce 是把所有的数据保存在内存当中，采用 hash 表的方式，每条数据由 key 和 value 组成，每个 key 是独一无二的，当要访问某个值的时候先按照找到值，然后返回结果。Memcahce 采用 LRU 算法来逐渐把过期数据清除掉。</code></pre><h3 id="列举流行的-Ajax-框架？说明-Ajax-实现原理是什么及-json-在-Ajax-中起什么作用？"><a href="#列举流行的-Ajax-框架？说明-Ajax-实现原理是什么及-json-在-Ajax-中起什么作用？" class="headerlink" title="列举流行的 Ajax 框架？说明 Ajax 实现原理是什么及 json 在 Ajax 中起什么作用？"></a>列举流行的 Ajax 框架？说明 Ajax 实现原理是什么及 json 在 Ajax 中起什么作用？</h3><p>流行的 Ajax 框架有 jQuery，Prototype，Dojo，MooTools。</p><pre><code>Ajax 的工作原理是一个页面的指定位置可以加载另一个页面所有的输出内容，这样就实现了一个静态页面也能获取到数据库中的返回数据信息了。所以 Ajax 技术实现了一个静态网页在不刷新整个页面的情况下与服务器通信，减少了用户等待时间，同时也从而降低了网络流量，增强了客户体验的友好程度。在使用 Ajax 时，涉及到数据传输，即将数据从服务器返回到客户端，服务器端和客户端分别使用不同的脚步语言来处理数据，这就需要一种通用的数据格式，XML 和 json 就是最常用的两种，而 json 比 XML 更简单。</code></pre><h3 id="Myql中的事务回滚机制概述"><a href="#Myql中的事务回滚机制概述" class="headerlink" title="Myql中的事务回滚机制概述"></a>Myql中的事务回滚机制概述</h3><p>事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位，事务回滚是指将该事务已经完成的对数据库的更新操作撤销。</p><p>　　要同时修改数据库中两个不同表时，如果它们不是一个事务的话，当第一个表修改完，可能第二个表修改过程中出现了异常而没能修改，此时就只有第二个表依旧是未修改之前的状态，而第一个表已经被修改完毕。而当你把它们设定为一个事务的时候，当第一个表修改完，第二表修改出现异常而没能修改，第一个表和第二个表都要回到未修改的状态，这就是所谓的事务回滚。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;isset、empty、is-null的区别&quot;&gt;&lt;a href=&quot;#isset、empty、is-null的区别&quot; class=&quot;headerlink&quot; title=&quot;isset、empty、is_null的区别&quot;&gt;&lt;/a&gt;isset、empty、is_null的区别&lt;/h3&gt;&lt;p&gt;isset 判断变量是否定义或者是否为空&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;变量存在返回ture，否则返回false
变量定义不赋值返回false
unset一个变量，返回false
变量赋值为null，返回false
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="PHP面试题" scheme="https://icocos.github.io/tags/PHP%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>PHP面试题总结二</title>
    <link href="https://icocos.github.io/2019/06/15/PHP%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%E4%BA%8C/"/>
    <id>https://icocos.github.io/2019/06/15/PHP面试题总结二/</id>
    <published>2019-06-15T04:14:14.000Z</published>
    <updated>2019-05-22T09:04:08.781Z</updated>
    
    <content type="html"><![CDATA[<h3 id="双引号和单引号的区别"><a href="#双引号和单引号的区别" class="headerlink" title="双引号和单引号的区别"></a>双引号和单引号的区别</h3><pre><code>双引号解释变量，单引号不解释变量双引号里插入单引号，其中单引号里如果有变量的话，变量解释双引号的变量名后面必须要有一个非数字、字母、下划线的特殊字符，或者用{}讲变量括起来，否则会将变量名后面的部分当做一个整体，引起语法错误双引号解释转义字符，单引号不解释转义字符，但是解释&apos;\和\\能使单引号字符尽量使用单引号，单引号的效率比双引号要高（因为双引号要先遍历一遍，判断里面有没有变量，然后再进行操作，而单引号则不需要判断）</code></pre><a id="more"></a><h3 id="常用的超全局变量-8个"><a href="#常用的超全局变量-8个" class="headerlink" title="常用的超全局变量(8个)"></a>常用的超全局变量(8个)</h3><pre><code>$_GET -----&gt;get传送方式$POST -----&gt;post传送方式$REQUEST -----&gt;可以接收到get和post两种方式的值***$GLOBALS -----&gt;所有的变量都放在里面$FILE -----&gt;上传文件使用$SERVER -----&gt;系统环境变量* **$SESSION -----&gt;会话控制的时候会用到$COOKIE -----&gt;会话控制的时候会用到</code></pre><h3 id="HTTP中POST、GET、PUT、DELETE方式的区别"><a href="#HTTP中POST、GET、PUT、DELETE方式的区别" class="headerlink" title="HTTP中POST、GET、PUT、DELETE方式的区别"></a>HTTP中POST、GET、PUT、DELETE方式的区别</h3><pre><code>HTTP定义了与服务器交互的不同的方法，最基本的是POST、GET、PUT、DELETE，与其比不可少的URL的全称是资源描述符，我们可以这样理解：url描述了一个网络上资源，而post、get、put、delegate就是对这个资源进行增、删、改、查的操作！</code></pre><h3 id="表单中get和post提交方式的区别"><a href="#表单中get和post提交方式的区别" class="headerlink" title="表单中get和post提交方式的区别"></a>表单中get和post提交方式的区别</h3><pre><code>get是把参数数据队列加到提交表单的action属性所指的url中，值和表单内各个字段一一对应，从url中可以看到；post是通过HTTPPOST机制，将表单内各个字段与其内容防止在HTML的head中一起传送到action属性所指的url地址，用户看不到这个过程对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据get传送的数据量较小，post传送的数据量较大，一般被默认不受限制，但在理论上，IIS4中最大量为80kb，IIS5中为1000k，get安全性非常低，post安全性较高</code></pre><p>========= </p><pre><code>GET请求会向数据库发索取数据的请求，从而来获取信息，该请求就像数据库的select操作一样，只是用来查询一下数据，不会修改、增加数据，不会影响资源的内容，即该请求不会产生副作用。无论进行多少次操作，结果都是一样的。与GET不同的是，PUT请求是向服务器端发送数据的，从而改变信息，该请求就像数据库的update操作一样，用来修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。POST请求同PUT请求类似，都是向服务器端发送数据的，但是该请求会改变数据的种类等资源，就像数据库的insert操作一样，会创建新的内容。几乎目前所有的提交操作都是用POST请求的。DELETE请求顾名思义，就是用来删除某一个资源的，该请求就像数据库的delete操作。</code></pre><h2 id="PHP介绍"><a href="#PHP介绍" class="headerlink" title="PHP介绍"></a>PHP介绍</h2><p>Hypertext Preprocessor—-超文本预处理器<br>Personal Home Page 原始名称</p><pre><code>目标用途: 允许web开发人员快速编写动态生成的web页面，与其他页面相比，PHP是将程序嵌入到HTML文档中去执行，效率比完全生成HTML编辑的CGI高很多HTML: Hypertext Markup Language创始人: 拉姆斯勒·勒多夫Rasmus Lerdorf，1968年生，加拿大滑铁卢大学</code></pre><p>勒多夫最开始是为了维护个人网页，用prel语言写了维护程序，之后又用c进行了重写，最终衍生出php/fi</p><h3 id="时间轴"><a href="#时间轴" class="headerlink" title="时间轴:"></a>时间轴:</h3><pre><code>1995.06.08将PHP/FI公开释出1995 php2.0，加入了对MySQL的支持1997 php3.02000 php4.02008 php5.0</code></pre><p>由于php6.0没有完全解决Unicode编码，所以基本没有生产线上的应用，基本只是一款概念产品，很多功能已经在php5.3.3和php5.3.4上实现</p><h3 id="常见的IDE-Intergrated-Development-Environment-集成开发环境"><a href="#常见的IDE-Intergrated-Development-Environment-集成开发环境" class="headerlink" title="常见的IDE(Intergrated Development Environment): 集成开发环境"></a>常见的IDE(Intergrated Development Environment): 集成开发环境</h3><pre><code>Coda（mac）PHPStromAdobe DreamweaverNetBeans</code></pre><h3 id="常见文本编辑器，具备代码高亮："><a href="#常见文本编辑器，具备代码高亮：" class="headerlink" title="常见文本编辑器，具备代码高亮："></a>常见文本编辑器，具备代码高亮：</h3><pre><code>NodePad++SublimeText</code></pre><h2 id="PHP优势"><a href="#PHP优势" class="headerlink" title="PHP优势"></a>PHP优势</h2><h3 id="PHP特性"><a href="#PHP特性" class="headerlink" title="PHP特性:"></a>PHP特性:</h3><pre><code>php独特混合了C,Java,Prel以及PHP自创的语法可以比CGI或者Prel更快速去执行动态网页，与其他变成语言相比，PHP是讲程序嵌入到HTML文档中去执行，执行效率比完全生成HTML编辑的CGI要高很多，所有的CGI都能实现支持几乎所有流行的数据库以及操作系统PHP可以使用C,C++进行程序的扩展</code></pre><h3 id="PHP优势-1"><a href="#PHP优势-1" class="headerlink" title="PHP优势:"></a>PHP优势:</h3><pre><code>开放源代码免费性快捷性跨平台强效率高图形处理面向对象专业专注</code></pre><h3 id="PHP技术应用"><a href="#PHP技术应用" class="headerlink" title="PHP技术应用:"></a>PHP技术应用:</h3><pre><code>静态页面生成数据库缓存过程缓存div+css w3c标准大负荷分布式flex支持MVCSmarty模块引擎</code></pre><h3 id="PHP认证级别"><a href="#PHP认证级别" class="headerlink" title="PHP认证级别"></a>PHP认证级别</h3><pre><code>初级 IFE:Index Front Engineer 前端工程师中级 IPE:Index PHP Engineer PHP工程师高级 IAE:Index Architecture Engineer 架构工程师</code></pre><h3 id="echo、print-r、print、var-dump之间的区别"><a href="#echo、print-r、print、var-dump之间的区别" class="headerlink" title="echo、print_r、print、var_dump之间的区别"></a>echo、print_r、print、var_dump之间的区别</h3><pre><code>* echo、print是php语句，var_dump和print_r是函数* echo 输出一个或多个字符串，中间以逗号隔开，没有返回值是语言结构而不是真正的函数，因此不能作为表达式的一部分使用* print也是php的一个关键字，有返回值 只能打印出简单类型变量的值(如int，string)，如果字符串显示成功则返回true，否则返回false* print_r 可以打印出复杂类型变量的值(如数组、对象）以列表的形式显示，并以array、object开头，但print_r输出布尔值和NULL的结果没有意义，因为都是打印&quot;\n&quot;，因此var_dump()函数更适合调试* var_dump() 判断一个变量的类型和长度，并输出变量的数值</code></pre><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p>点击这儿查看HTTP状态码详解</p><h3 id="常见的HTTP状态码："><a href="#常见的HTTP状态码：" class="headerlink" title="常见的HTTP状态码："></a>常见的HTTP状态码：</h3><pre><code>200 - 请求成功301 - 资源(网页等)被永久转义到其他URL404 - 请求的资源(网页等)不存在505 - 内部服务器错误</code></pre><h3 id="HTTP状态码分类"><a href="#HTTP状态码分类" class="headerlink" title="HTTP状态码分类:"></a>HTTP状态码分类:</h3><pre><code>1** - 信息，服务器收到的请求，需要请求者继续执行操作2** - 成功，操作被成功接收并处理3** - 重定向，需要进一步的操作以完成请求4** - 客户端错误，请求包含语法错误或者无法完成请求5** 服务器错误，服务器在处理请求的过程中发生了错误</code></pre><h3 id="什么是魔术引号"><a href="#什么是魔术引号" class="headerlink" title="什么是魔术引号"></a>什么是魔术引号</h3><pre><code>魔术引号是一个将自动将进入PHP脚本的数据进行转义的过程，最好在编码时不要转义而在运行时根据需要而转义</code></pre><h3 id="如何获取客户端的ip-要求取得一个int-和服务器ip的代码"><a href="#如何获取客户端的ip-要求取得一个int-和服务器ip的代码" class="headerlink" title="如何获取客户端的ip(要求取得一个int)和服务器ip的代码"></a>如何获取客户端的ip(要求取得一个int)和服务器ip的代码</h3><pre><code>客户端：$_SERVER[&quot;REMOTE_ADDR&quot;];或者getenv(&apos;REMOTE_ADDR&apos;)ip2long进行转换服务器端：gethostbyname(&apos;www.baidu.com&apos;)</code></pre><h3 id="使用那些工具进行版本控制"><a href="#使用那些工具进行版本控制" class="headerlink" title="使用那些工具进行版本控制"></a>使用那些工具进行版本控制</h3><pre><code>cvs、svn、vss、git</code></pre><h3 id="优化数据库的方法"><a href="#优化数据库的方法" class="headerlink" title="优化数据库的方法"></a>优化数据库的方法</h3><p>MySQL数据库优化的八大方式（经典必看）点击获取</p><pre><code>选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置NOTNULL，例如&apos;省份&apos;、&apos;性别&apos;最好适用ENUM使用连接(JOIN)来代替子查询适用联合(UNION)来代替手动创建的临时表事务处理锁定表、优化事务处理适用外键，优化锁定表建立索引优化查询语句</code></pre><h3 id="是否使用过模板引擎？使用的模板引擎的名字是？"><a href="#是否使用过模板引擎？使用的模板引擎的名字是？" class="headerlink" title="是否使用过模板引擎？使用的模板引擎的名字是？"></a>是否使用过模板引擎？使用的模板引擎的名字是？</h3><pre><code>Smarty:Smarty算是一种很老的PHP模板引擎了，它曾是我使用这门语言模板的最初选择。虽然它的更新已经不算频繁了，并且缺少新一代模板引擎所具有的部分特性，但是它仍然值得一看。</code></pre><h3 id="对于大流量网站，采用什么方法来解决访问量的问题"><a href="#对于大流量网站，采用什么方法来解决访问量的问题" class="headerlink" title="对于大流量网站，采用什么方法来解决访问量的问题"></a>对于大流量网站，采用什么方法来解决访问量的问题</h3><pre><code>确认服务器硬件是否能够支持当前的流量数据库读写分离，优化数据表程序功能规则，禁止外部的盗链控制大文件的下载使用不同主机分流主要流量</code></pre><h3 id="语句include和require的区别是什么？为避免多次包含同一文件，可以用-语句代替他们"><a href="#语句include和require的区别是什么？为避免多次包含同一文件，可以用-语句代替他们" class="headerlink" title="语句include和require的区别是什么？为避免多次包含同一文件，可以用(?)语句代替他们"></a>语句include和require的区别是什么？为避免多次包含同一文件，可以用(?)语句代替他们</h3><pre><code>require是无条件包含，也就是如果一个流程里加入require，无论条件成立与否都会先执行require，当文件不存在或者无法打开的时候，会提示错误，并且会终止程序执行include有返回值，而require没有(可能因为如此require的速度比include快)，如果被包含的文件不存在的化，那么会提示一个错误，但是程序会继续执行下去注意:包含文件不存在或者语法错误的时候require是致命的，而include不是require_once表示了只包含一次，避免了重复包含</code></pre><h3 id="谈谈mvc的认识"><a href="#谈谈mvc的认识" class="headerlink" title="谈谈mvc的认识"></a>谈谈mvc的认识</h3><pre><code>由模型、视图、控制器完成的应用程序，由模型发出要实现的功能到控制器，控制器接收组织功能传递给视图</code></pre><h3 id="说明php中传值与传引用的区别，并说明传值什么时候传引用？"><a href="#说明php中传值与传引用的区别，并说明传值什么时候传引用？" class="headerlink" title="说明php中传值与传引用的区别，并说明传值什么时候传引用？"></a>说明php中传值与传引用的区别，并说明传值什么时候传引用？</h3><pre><code>变量默认总是传值赋值，那也就是说，当将一个表达式的值赋予一个变量时，整个表达式的值被赋值到目标变量，这意味着：当一个变量的赋予另外一个变量时，改变其中一个变量的值，将不会影响到另外一个变量</code></pre><p>php也提供了另外一种方式给变量赋值：引用赋值。这意味着新的变量简单的<strong>引用</strong>(换言之，成为了其别名或者指向)了原始变量。改动的新的变量将影响到原始变量，反之亦然。使用引用赋值，简单地将一个&amp;符号加到将要赋值的变量前(源变量)</p><pre><code>对象默认是传引用对于较大是的数据，传引用比较好，这样可以节省内存的开销</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;双引号和单引号的区别&quot;&gt;&lt;a href=&quot;#双引号和单引号的区别&quot; class=&quot;headerlink&quot; title=&quot;双引号和单引号的区别&quot;&gt;&lt;/a&gt;双引号和单引号的区别&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;双引号解释变量，单引号不解释变量
双引号里插入单引号，其中单引号里如果有变量的话，变量解释
双引号的变量名后面必须要有一个非数字、字母、下划线的特殊字符，或者用{}讲变量括起来，否则会将变量名后面的部分当做一个整体，引起语法错误
双引号解释转义字符，单引号不解释转义字符，但是解释&amp;apos;\和\\
能使单引号字符尽量使用单引号，单引号的效率比双引号要高（因为双引号要先遍历一遍，判断里面有没有变量，然后再进行操作，而单引号则不需要判断）
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="PHP面试题" scheme="https://icocos.github.io/tags/PHP%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>PHP面试题总结一</title>
    <link href="https://icocos.github.io/2019/06/13/PHP%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%E4%B8%80/"/>
    <id>https://icocos.github.io/2019/06/13/PHP面试题总结一/</id>
    <published>2019-06-13T10:01:24.000Z</published>
    <updated>2019-05-22T09:04:13.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这个文档只是一个提纲，以及一些可能的考点或者demo代码。列出了大概的技术栈，每一个点都需要花更多的时间去深入钻研，万不能只看一点点皮毛就去面试。而应该在广泛学习的基础上，通过文档里的每一个点引出无数个思维方向，从而在大脑里形成一个自己的知识树，明白自己的欠缺，不断学习，丰富自己的技术栈。</p><a id="more"></a><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>redis包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hashs（哈希类型）。这些数据类型都 支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</p><h4 id="php中reids的操作"><a href="#php中reids的操作" class="headerlink" title="php中reids的操作"></a>php中reids的操作</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from 菜鸟runoob</span></span><br><span class="line"><span class="comment">// 从代码中以点带面，在什么样的场景中会运用到</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置连接的IP、端口、以及相应的数据库</span></span><br><span class="line">$server = <span class="keyword">array</span>(</span><br><span class="line">‘host’     =&gt; ’<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>′,</span><br><span class="line">‘port’     =&gt; <span class="number">6379</span>,</span><br><span class="line">‘database’ =&gt; <span class="number">15</span></span><br><span class="line">);</span><br><span class="line">$redis = <span class="keyword">new</span> Client($server);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通set/get操作</span></span><br><span class="line">$redis-&gt;set(‘library’, ‘predis’);</span><br><span class="line">$retval = $redis-&gt;get(‘library’);</span><br><span class="line"><span class="keyword">echo</span> $retval; <span class="comment">//显示 ‘predis’</span></span><br><span class="line"></span><br><span class="line">$redis-&gt;exists(‘foo’);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// del 删除</span></span><br><span class="line">$redis-&gt;del(‘foo’);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hset/hget 存取hash表的数据</span></span><br><span class="line">$redis-&gt;hset(‘hash1′,’key1′,’v1′); <span class="comment">//将key为’key1′ value为’v1′的元素存入hash1表</span></span><br><span class="line">$redis-&gt;hset(‘hash1′,’key2′,’v2′);</span><br><span class="line">$redis-&gt;hget(‘hash1′,’key1′);  <span class="comment">//取出表’hash1′中的key ‘key1′的值,返回’v1′</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步保存服务器数据到磁盘</span></span><br><span class="line">$redis-&gt;save();</span><br></pre></td></tr></table></figure><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><h4 id="mysql优化怎么做的？"><a href="#mysql优化怎么做的？" class="headerlink" title="mysql优化怎么做的？"></a>mysql优化怎么做的？</h4><ol><li><p>设计角度：存储引擎的选择，字段类型选择，范式</p></li><li><p>功能角度：可以利用mysql自身的特性，如索引，查询缓存，碎片整理，分区、分表等</p></li><li><p>sql语句的优化方面:尽量简化查询语句，能查询字段少就尽量少查询字段，优化分页语句、分组语句等。</p></li><li><p>部署大负载架构体系：数据库服务器单独出来，负载大时可以采用主从复制，读写分离机制进行设计</p></li><li><p>从硬件上升级数据库服务器。</p></li></ol><h4 id="sql注入是什么及如何预防sql注入？"><a href="#sql注入是什么及如何预防sql注入？" class="headerlink" title="sql注入是什么及如何预防sql注入？"></a>sql注入是什么及如何预防sql注入？</h4><p>SQL注入攻击指的是用户或者黑客通过构建特殊的输入作为参数传入我们的Web应用程序端，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序员没有细致地过滤用户输入的数据，致使非法数据侵入系统而造成的。因此我们在做开发过程中一定要预防sql注入，主要从两方面着手：</p><p>1、占位符的方式，就是对sql语句进行预处理，然后执行sql语句</p><p>2、通过addslashes或者mysql_real_escape_string这两个函数对用户输入的值进行转义处理，把一些特殊的字符转义掉。</p><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>预处理语句用于执行多个相同的 SQL 语句，并且执行效率更高。</p><p><strong>预处理语句的工作原理如下</strong>：</p><ol><li><p>预处理：创建 SQL 语句模板并发送到数据库。预留的值使用参数 “?” 标记 。例如：<br><code>INSERT INTO MyGuests (firstname, lastname, email) VALUES(?, ?, ?)</code><br>数据库解析，编译，对SQL语句模板执行查询优化，并存储结果不输出。</p></li><li><p>执行：最后，将应用绑定的值传递给参数（”?” 标记），数据库执行语句。应用可以多次执行语句，如果参数的值不一样。</p></li></ol><p>相比于直接执行SQL语句，预处理语句有两个主要优点：</p><ol><li><p>预处理语句大大减少了分析时间，只做了一次查询（虽然语句多次执行）。</p></li><li><p>绑定参数减少了服务器带宽，你只需要发送查询的参数，而不是整个语句。</p></li></ol><p>预处理语句针对<strong>SQL注入</strong>是非常有用的，因为参数值发送后使用不同的协议，保证了数据的合法性。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$stmt = $conn-&gt;prepare(<span class="string">"INSERT INTO MyGuests (firstname, lastname, email) VALUES (?, ?, ?)"</span>);</span><br><span class="line">$stmt-&gt;bind_param(<span class="string">"sss"</span>, $firstname, $lastname, $email);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置参数并执行</span></span><br><span class="line">$firstname = <span class="string">"John"</span>;</span><br><span class="line">$lastname = <span class="string">"Doe"</span>;</span><br><span class="line">$email = <span class="string">"john@example.com"</span>;</span><br><span class="line">$stmt-&gt;execute();</span><br><span class="line"></span><br><span class="line">$stmt-&gt;close();</span><br></pre></td></tr></table></figure><h4 id="mysql索引"><a href="#mysql索引" class="headerlink" title="mysql索引"></a>mysql索引</h4><ul><li><strong>非常重要！</strong></li></ul><p>了解InnoDB和Myisam，B+tree,聚簇索引等等<br><a href="https://www.cnblogs.com/shijingxiang/articles/4743324.html" target="_blank" rel="noopener">InnoDB索引原理详解</a></p><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p><table><thead><tr><th>SQL术语/概念</th><th>MongoDB术语/概念</th><th>解释/说明</th></tr></thead><tbody><tr><td>database</td><td>database</td><td>数据库</td></tr><tr><td>table</td><td>collection</td><td>数据库表/集合</td></tr><tr><td>row</td><td>document</td><td>数据记录行/文档</td></tr><tr><td>column</td><td>field</td><td>数据字段/域</td></tr><tr><td>index</td><td>index</td><td>索引</td></tr><tr><td>table joins</td><td></td><td>表连接,MongoDB不支持</td></tr><tr><td>primary key</td><td>primary key</td><td>主键,MongoDB自动将_id字段设置为主键</td></tr></tbody></table><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// from runoob</span></span><br><span class="line">$m = <span class="keyword">new</span> MongoClient(); <span class="comment">// 连接默认主机和端口为：mongodb://localhost:27017</span></span><br><span class="line">$db = $m-&gt;test; <span class="comment">// 获取名称为 "test" 的数据库</span></span><br><span class="line"></span><br><span class="line">$collection = $db-&gt;createCollection(<span class="string">"runoob"</span>); <span class="comment">// 创建集合</span></span><br><span class="line"></span><br><span class="line">$collection = $db-&gt;runoob; <span class="comment">// 选择集合</span></span><br><span class="line">$document = <span class="keyword">array</span>( </span><br><span class="line">    <span class="string">"title"</span> =&gt; <span class="string">"MongoDB"</span>, </span><br><span class="line">    <span class="string">"description"</span> =&gt; <span class="string">"database"</span>, </span><br><span class="line">    <span class="string">"likes"</span> =&gt; <span class="number">100</span>,</span><br><span class="line">    <span class="string">"url"</span> =&gt; <span class="string">"http://www.runoob.com/mongodb/"</span>,</span><br><span class="line">    <span class="string">"by"</span>, <span class="string">"菜鸟教程"</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入文档</span></span><br><span class="line">$collection-&gt;insert($document);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找文档</span></span><br><span class="line">$cursor = $collection-&gt;find();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新文档</span></span><br><span class="line">$collection-&gt;update(<span class="keyword">array</span>(<span class="string">"title"</span>=&gt;<span class="string">"MongoDB"</span>), <span class="keyword">array</span>(<span class="string">'$set'</span>=&gt;<span class="keyword">array</span>(<span class="string">"title"</span>=&gt;<span class="string">"MongoDB 教程"</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除文档</span></span><br><span class="line">$collection-&gt;remove(<span class="keyword">array</span>(<span class="string">"title"</span>=&gt;<span class="string">"MongoDB 教程"</span>), <span class="keyword">array</span>(<span class="string">"justOne"</span> =&gt; <span class="keyword">true</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="composer"><a href="#composer" class="headerlink" title="composer"></a>composer</h2><p>Composer 是 PHP5.3以上 的一个依赖管理工具。它允许你声明项目所依赖的代码库，它会在你的项目中为你安装他们。</p><h4 id="创建一个-composer-json-文件"><a href="#创建一个-composer-json-文件" class="headerlink" title="创建一个 composer.json 文件"></a>创建一个 composer.json 文件</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"require"</span>: &#123;</span><br><span class="line">        <span class="attr">"monolog/monolog"</span>: <span class="string">"1.2.*"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="php-web相关"><a href="#php-web相关" class="headerlink" title="php web相关"></a>php web相关</h2><h4 id="cookie与session的区别"><a href="#cookie与session的区别" class="headerlink" title="cookie与session的区别"></a>cookie与session的区别</h4><ol><li><p>cookie数据存放在客户的浏览器上，session数据放在服务器上。</p></li><li><p>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。</p></li><li><p>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。</p></li><li><p>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p></li></ol><h4 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h4><ol><li>get是从服务器上获取数据，post是向服务器传送数据。</li><li>get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。</li><li>get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。4.. get安全性非常低，post安全性较高。但是执行效率却比Post方法好。</li></ol><h4 id="php在储存session以什么形式存在"><a href="#php在储存session以什么形式存在" class="headerlink" title="php在储存session以什么形式存在"></a>php在储存session以什么形式存在</h4><p>PHP为session的存储提供了三种方式: 文件/ 内存/ 自定义存储,默认是使用文件存储.在访问量大的网站上采用这种方式就不大合 适,因为这样会导致大量的输入输出的冗余.我们可以在php.ini更改配置文件或者php脚本中通过相应的函数来设置session文件的存储类型来改变session文件的存储形式</p><h4 id="xss攻击怎么防止"><a href="#xss攻击怎么防止" class="headerlink" title="xss攻击怎么防止"></a>xss攻击怎么防止</h4><p>XSS又称CSS，全称Cross SiteScript(跨站脚本攻击)， XSS攻击类似于SQL注入攻击，是Web程序中常见的漏洞，XSS属于被动式且用于客户端的攻击方式，所以容易被忽略其危害性。其原理是攻击者向有XSS漏洞的网站中输入(传入)恶意的HTML代码，当用户浏览该网站时，这段HTML代码会自动执行，从而达到攻击的目的。如，盗取用户Cookie信息、破坏页面结</p><p>常见的恶意字符XSS输入：</p><ol><li><p>XSS 输入通常包含 JavaScript 脚本，如弹出恶意警告框：<br><code>&lt;script&gt;alert(&quot;XSS&quot;);&lt;/script&gt;</code></p></li><li><p>XSS 输入也可能是 HTML 代码段，譬如：</p><p> (1) 网页不停地刷新 <code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;&quot;&gt;</code></p><p> (2) 嵌入其它网站的链接，重定向到其它网站等。</p></li></ol><p>方法：利用php htmlentities()函数</p><p>php防止XSS跨站脚本攻击的方法：是针对非法的HTML代码包括单双引号等，使用htmlspecialchars()函数。</p><h4 id="静态化如何实现的"><a href="#静态化如何实现的" class="headerlink" title="静态化如何实现的"></a><a href="https://blog.csdn.net/qq_39618306/article/details/79014438" target="_blank" rel="noopener">静态化如何实现的</a></h4><p>这里要说的静态化指的是页面静态化，也即生成实实在在的静态文件，也即不需要查询数据库就可以直接从文件中获取数据，指的是真静态。它的实现方式主要有两种：</p><ul><li><p>一种是我们在添加信息入库的时候就生成的静态文件，也称为模板替换技术，这种主要用在后台，用于一些基本上很少变化的信息上，在添加信息的时候使用添加的信息来替换制定好的模板中的内容，达到生成静态文件的目的，这样在前台访问该信息时，可以直接从生成好的静态文件中获取信息，如一些CMS系统。</p></li><li><p>另外一种是用户在访问我们的页面时先判断是否有对应的缓存文件存在，如果存在就读缓存，不存在就读数据库，同时生成缓存文件。这种实现的主要原理是基于PHP中的ob缓冲技术来实现的，当没有静态文件时，从数据库中读取，读取的数据使用OB缓存，使用相关的函数从OB缓冲中读取数据，写入到文件中，形成静态文件。当然这个过程中要考虑静态文件的缓存周期问题，我们可以根据文件的最后修改时间和当前时间及设定的缓存时间来定时更新缓存文件。</p></li></ul><h4 id="如何处理负载、高并发"><a href="#如何处理负载、高并发" class="headerlink" title="如何处理负载、高并发"></a>如何处理负载、高并发</h4><p>从低成本、高性能和高扩张性的角度来说有如下处理方案：</p><ol><li><p>HTML静态化<br>其实大家都知道，效率最高、消耗最小的就是纯静态化的html页面，所以我们尽可能使我们的 网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。</p></li><li><p>图片服务器分离<br>把图片单独存储，尽量减少图片等大流量的开销，可以放在一些相关的平台上，如骑牛等</p></li><li><p>数据库集群和库表散列及缓存<br>数据库的并发连接为100，一台数据库远远不够，可以从读写分离、主从复制，数据库集群方面来着手。另外尽量减少数据库的访问，可以使用缓存数据库如memcache、redis。</p></li><li><p>镜像：<br>尽量减少下载，可以把不同的请求分发到多个镜像端。</p></li><li><p>负载均衡：<br>Apache的最大并发连接为1500，只能增加服务器，可以从硬件上着手，如F5服务器。当然硬件的成本比较高，我们往往从软件方面着手。<br><strong>负载均衡</strong>建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力，同时能够提高网络的灵活性和可用性。目前使用最为广泛的负载均衡软件是Nginx、LVS、HAProxy。</p></li></ol><ul><li>知识点： <a href="https://www.cnblogs.com/Anker/p/6056540.html" target="_blank" rel="noopener">反向代理</a></li></ul><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>心中有概念，然后足够的实际操作。</p><h4 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h4><p><a href="https://baike.baidu.com/item/apache/6265" target="_blank" rel="noopener">百度百科介绍</a></p><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p><a href="https://baike.baidu.com/item/nginx/3817705" target="_blank" rel="noopener">百度百科介绍</a></p><h2 id="php特性"><a href="#php特性" class="headerlink" title="php特性"></a>php特性</h2><h4 id="PHP-的垃圾收集机制是怎样的"><a href="#PHP-的垃圾收集机制是怎样的" class="headerlink" title="PHP 的垃圾收集机制是怎样的"></a>PHP 的垃圾收集机制是怎样的</h4><p>php作为脚本语言是页面结束即释放变量所占内存的。 当一个 PHP线程结束时，当前占用的所有内存空间都会被销毁，当前程序中所有对象同时被销毁。GC进程一般都跟着每起一个SESSION而开始运行的.gc目的是为了在session文件过期以后自动销毁删除这些文件.在PHP中，没有任何变量指向这个对象时，这个对象就成为垃圾。PHP会将其在内存中销毁；这是PHP的GC垃圾处理机制，防止内存溢出。 执行这些函数也可以起到回收作用__destruct /unset/mysql_close /fclose php对session有明确的gc处理时间设定session.gc_maxlifetime 如果说有垃圾，那就是整体的程序在框架使用中，会多次调用同一文件等等造成的非单件模式等。所以在出来的时候，必要的用_once引用，在声明类的时候使用单件模式。还有简化逻辑等等。</p><h4 id="zval"><a href="#zval" class="headerlink" title="zval"></a>zval</h4><p><a href="https://www.jianshu.com/p/63a381a7f70c" target="_blank" rel="noopener">内存管理</a></p><p><a href="http://php.net/manual/zh/features.gc.php" target="_blank" rel="noopener">垃圾回收机制</a></p><h4 id="cgi、fastcgi、php-fpm"><a href="#cgi、fastcgi、php-fpm" class="headerlink" title="cgi、fastcgi、php-fpm"></a>cgi、fastcgi、php-fpm</h4><ul><li><p><strong>cgi</strong><br>早期的web server只可以处理简单的静态web文件，但是随着技术的发展出现动态语言如PHP，Python。PHP语言交给PHP解析器进行处理，但是处理之后如何和web server进行通信呢？<br>为了解决不同的语言处理器与web server之间的通讯，出现了CGI协议。只要按照CGI协议编写程序，就可以实现与语言解析器与web server之间的通讯。<br>CGI协议虽然解决了语言解析器和seb server之间通讯的问题，但是它的效率很低。因为web server每收到一个请求都会创建一个CGI进程，PHP解析器都会解析php.ini文件，初始化环境，请求结束的时候再关闭进程。对于每一个创建的CGI进程都会执行这些操作。所以效率很低。</p></li><li><p><strong>FastCGI</strong><br>FastCGI是用来提高CGI性能的，FastCGI每次处理完请求之后不会关闭掉进程。而是保留这个进程，使这个进程可以处理多个请求。这样的话每个请求都不用再重新创建一个进程了。大大提升了处理效率。</p></li><li><p><strong>PHP-FPM</strong><br>PHP-FPM(FastCGI Process Manager：FastCGI进程管理器)是一个实现了Fastcgi的程序，并且提供进程管理的功能。进程包括master进程和worker进程。master进程只有一个，负责监听端口，接受来自web server的请求。worker进程一般会有多个，每个进程中会嵌入一个PHP解析器，进程PHP代码的处理。</p></li></ul><h4 id="php-ini中的safe-mode-影响"><a href="#php-ini中的safe-mode-影响" class="headerlink" title="php.ini中的safe_mode 影响"></a>php.ini中的safe_mode 影响</h4><p><strong>Warning<br>本特性已自 PHP 5.3.0 起废弃并将自 PHP 5.4.0 起移除。</strong></p><p>1)用户输入输出函数（fopen()file()require(),只能用于调用这些函数有相同脚本的拥有者）</p><p>2)创建新文件（限制用户只在该用户拥有目录下创建文件）</p><p>3)用户调用popen()systen()exec()等脚本，只有脚本处在safe_mode_exec_dir配置指令指定的目录中才可能</p><p>4)加强HTTP认证，认证脚本拥有者的UID的划入认证领域范围内，此外启用安全模式下，不会设置PHP_AUTH</p><p>5)mysql服务器所用的用户名必须与调用mysql_connect()的文件的拥有者用户名相同6)</p><p>受影响的函数变量以及配置命令达到40个</p><h4 id="php的设计模式"><a href="#php的设计模式" class="headerlink" title="php的设计模式"></a>php的设计模式</h4><ol><li><p><strong>单例模式</strong><br>一个类在整个应用中，只有一个对象实例的设计模式<br>类必须自行创建这个实例<br>必须自行向整个系统提供这个实例<br><strong>三私</strong>：私有静态成员变量、构造函数、克隆函数<br><strong>一公</strong>：公共的静态方法</p></li><li><p><strong>工厂模式</strong><br>可以根据输入的参数或者应用程序配置的不同,创建一种专门用来实例化并返回其它类的实例的类</p></li><li><p>观察者模式<br>观察者模式提供了组件之间紧密耦合的另一种方法。<br>该模式：一个对象通过添加一个方法（该方法允许另一个对象，即观察者注册自己）全本身变得可观察。当可观察的对象更改时，它会将消息发送到已注册的观察者。这些观察者使用该信息执行的操作与可观察的对象无关。</p></li><li><p>命令链模式：<br>以松散耦合主题为基础，发送消息、命令和请求，或通过一组处理程序发送任意内容。每个处理程序都会自行判断自己能否处理请求，如果可以，该请求被处理，进程停止。</p></li><li><p>策略模式：<br>此算法是从复杂类提取的，因而可以方便地替换。</p></li></ol><h2 id="php语法"><a href="#php语法" class="headerlink" title="php语法"></a>php语法</h2><h4 id="Include和require的区别"><a href="#Include和require的区别" class="headerlink" title="Include和require的区别"></a>Include和require的区别</h4><p>require函数通常放在PHP程序的最前面，在PHP程序执行之前，就会先读取require指定引入的文件，使它变成PHP程序网页的一部分。</p><p>include函数一般是放在流程控制的处理部分中。PHP程序在读到include的文件时，才将它读进来，这种方式可以把程序执行时的流程简单化。</p><p>他们两个的用途是一样的，不一定非要哪个放在最前面哪个放在中间，他们最根本的区别在于错误处理的方式不一样。</p><p>require一个文件存在错误的话，那么程序就会中断执行，并显示致命错误</p><p>而include一个文件存在错误的话，那么程序不会中断，会继续执行，并显示一个警告的错误</p><p>其它区别：include有返回值，而require没有。</p><h4 id="PHP的变量类型"><a href="#PHP的变量类型" class="headerlink" title="PHP的变量类型"></a>PHP的变量类型</h4><p><strong>四种标量类型</strong></p><ol><li><p>boolean （布尔型）：这是最简单的类型，只有两种取值，可以为 TRUE/true 或 FALSE/false ，不区分大小写。详细请查看：PHP布尔类型（boolean）</p></li><li><p>integer （整型）：在32 位操作系统中它的有效范围是：-2 147 483 648~+2 147 483 647。整型值可以使用十进制，十六进制或八进制表示，前面可以加上可选的符号（- 或者 +）。八进制表示数字前必须加上 0（零），十六进制表示数字前必须加上 0x。</p></li><li><p>float （浮点型, 也称作 double)</p></li><li><p>string （字符串）：字符型变量不同于其他编程语言有字符与字符串之分，在PHP 中，统一使用字符型变量来定义字符或者字符串。</p></li></ol><p><strong>两种复合类型</strong></p><ol><li><p>array （数组）：数组型变量是一种比较特殊的变量类型，将在后续章节中详细说明。</p></li><li><p>object （对象）：对象也是一种特殊的数据类型。要创建object变量，请使用 new 关键字。详细请查看：PHP对象类型（object）</p></li></ol><p><strong>两种特殊类型</strong>：</p><ol><li><p>resource（资源）：源是一种特殊变量，保存了到外部资源的一个引用。资源是通过专门的函数来建立和使用的。详情请查看：PHP资源类型（resource）</p></li><li><p>NULL（NULL）：表示一个变量没有值。NULL 类型唯一可能的值就是 NULL。</p></li></ol><h4 id="单引号与双引号的区别"><a href="#单引号与双引号的区别" class="headerlink" title="单引号与双引号的区别"></a>单引号与双引号的区别</h4><ol><li><p>单引号内部的变量不会执行， 双引号会执行</p></li><li><p>单引号解析速度比双引号快。</p></li><li><p>单引号只能解析部分特殊字符，双引号可以解析所有特殊字符。</p></li></ol><h2 id="php扩展"><a href="#php扩展" class="headerlink" title="php扩展"></a>php扩展</h2><h4 id="GD库"><a href="#GD库" class="headerlink" title="GD库"></a>GD库</h4><p>图像处理扩展<br><a href="http://php.net/manual/zh/ref.image.php" target="_blank" rel="noopener">GD 和图像处理 函数</a></p><h4 id="yaf"><a href="#yaf" class="headerlink" title="yaf"></a>yaf</h4><p><a href="http://php.net/manual/zh/book.yaf.php" target="_blank" rel="noopener">Yet Another Framework</a></p><h4 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h4><p><a href="http://php.net/manual/zh/book.curl.php" target="_blank" rel="noopener">Client URL</a></p><h4 id="mysqli"><a href="#mysqli" class="headerlink" title="mysqli"></a>mysqli</h4><p><a href="http://php.net/manual/zh/book.mysqli.php" target="_blank" rel="noopener">mysql增强版</a></p><h2 id="php7"><a href="#php7" class="headerlink" title="php7"></a>php7</h2><p><a href="http://www.runoob.com/w3cnote/php7-new-features.html" target="_blank" rel="noopener">php7新特性</a></p><ul><li>??运算符(NULL 合并运算符)</li></ul><p>由于日常使用中存在大量同时使用三元表达式和 isset()的情况，NULL 合并运算符使得变量存在且值不为NULL， 它就会返回自身的值，否则返回它的第二个操作数。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 如果 $_GET['user'] 不存在返回 'nobody'，否则返回 $_GET['user'] 的值</span></span><br><span class="line">$username = $_GET[<span class="string">'user'</span>] ?? <span class="string">'nobody'</span>;</span><br><span class="line"><span class="comment">// 类似的三元运算符</span></span><br><span class="line">$username = <span class="keyword">isset</span>($_GET[<span class="string">'user'</span>]) ? $_GET[<span class="string">'user'</span>] : <span class="string">'nobody'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ul><li>&lt;=&gt; 太空船操作符（组合比较符）</li></ul><p>太空船操作符用于比较两个表达式。当a大于、等于或小于b时它分别返回-1、0或1。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 整型</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">1</span> &lt;=&gt; <span class="number">1</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">1</span> &lt;=&gt; <span class="number">2</span>; <span class="comment">// -1</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">2</span> &lt;=&gt; <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浮点型</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">1.5</span> &lt;=&gt; <span class="number">1.5</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">1.5</span> &lt;=&gt; <span class="number">2.5</span>; <span class="comment">// -1</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">2.5</span> &lt;=&gt; <span class="number">1.5</span>; <span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"a"</span> &lt;=&gt; <span class="string">"a"</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"a"</span> &lt;=&gt; <span class="string">"b"</span>; <span class="comment">// -1</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"b"</span> &lt;=&gt; <span class="string">"a"</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ul><li>通过 define() 定义常量数组</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">define(<span class="string">'ANIMALS'</span>, [</span><br><span class="line">    <span class="string">'dog'</span>,</span><br><span class="line">    <span class="string">'cat'</span>,</span><br><span class="line">    <span class="string">'bird'</span></span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> ANIMALS[<span class="number">1</span>]; <span class="comment">// 输出 "cat"</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ul><li>整除</li></ul><p>新增了整除函数 intdiv()</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">var_dump(intdiv(<span class="number">10</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">// 输出结果： int(3)</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="php优化"><a href="#php优化" class="headerlink" title="php优化"></a>php优化</h2><p><a href="https://www.awaimai.com/1050.html" target="_blank" rel="noopener">48条高效率的PHP优化写法</a></p><h2 id="操作系统相关"><a href="#操作系统相关" class="headerlink" title="操作系统相关"></a>操作系统相关</h2><p>操作系统是本科计算机中可以说是非常重要的课程，一定要认真复习。</p><h4 id="linux常用命令及工具"><a href="#linux常用命令及工具" class="headerlink" title="linux常用命令及工具"></a>linux常用命令及工具</h4><p><code>ps aux</code> 查看进程pid等常用<br><code>grep</code> 过滤，-E支持表达式<br><code>curl</code> 发起一次请求<br><code>kill -9 pid</code> 杀死进程<br><code>top</code> linux版任务管理器，查看当前进程占用内存CPU<br><code>wc -l</code> 计算行数<br><code>tail -f file</code> 实时查看文件变化<br><code>contab</code> 定时任务工具<br>⋯⋯</p><h4 id="进程各个状态"><a href="#进程各个状态" class="headerlink" title="进程各个状态"></a>进程各个状态</h4><p><a href="https://blog.csdn.net/qwe6112071/article/details/70473905" target="_blank" rel="noopener">进程的状态和转换详解</a></p><h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><p><a href="https://baike.baidu.com/item/TCP/IP%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">TCP/IP - 百度百科</a></p><p><a href="http://www.cnblogs.com/ranyonsue/p/5984001.html" target="_blank" rel="noopener">HTTP协议详解</a></p><h4 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h4><p><strong>12345法则</strong></p><ul><li>1** 消息<br>100  客户端应当继续发送请求。</li><li>2** 成功<br>200 成功</li><li>3** 重定向<br>301 永久重定向，例如http定向到https<br>302 临时重定向，例如js跳转</li><li>4** 请求错误<br>403 forbidden 拒绝请求。<br>404 not found 找不到请求的网页。</li><li>5** 服务器错误<br>500 Internal Server Error 服务器内部错误，例如php代码错误</li></ul><h4 id="http版本"><a href="#http版本" class="headerlink" title="http版本"></a>http版本</h4><h5 id="1-0"><a href="#1-0" class="headerlink" title="1.0"></a>1.0</h5><ul><li><p>无状态、无连接。<br>HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。</p></li><li><p>队头阻塞<br>HTTP1.0规定下一个请求必须在前一个请求响应到达之前才能发送。假设前一个请求响应一直不到达，那么下一个请求就不发送，同样的后面的请求也给阻塞了。</p></li></ul><h5 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h5><ul><li><p>长连接<br>HTTP1.1增加了一个Connection字段，通过设置Keep-Alive可以保持HTTP连接不断开，避免了每次客户端与服务器请求都要重复建立释放建立TCP连接，提高了网络的利用率。如果客户端想关闭HTTP连接，可以在请求头中携带Connection: false来告知服务器关闭请求。</p></li><li><p>管道化<br>基于HTTP1.1的长连接，使得请求管线化成为可能。管线化使得请求能够“并行”传输。</p></li><li><p>新的字段<br>如cache-control，支持断点传输，以及增加了Host字段（使得一个服务器能够用来创建多个Web站点）。</p></li></ul><h5 id="2-0"><a href="#2-0" class="headerlink" title="2.0"></a>2.0</h5><ul><li><p>二进制分帧<br>HTTP2.0通过在应用层和传输层之间增加一个二进制分帧层，突破了HTTP1.1的性能限制、改进传输性能。</p></li><li><p>多路复用（连接共享）<br>HTTP2.0实现了真正的并行传输，它能够在一个TCP上进行任意数量HTTP请求。而这个强大的功能则是基于“二进制分帧”的特性。</p></li><li><p>头部压缩<br>HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。高效的压缩算法可以很大的压缩header，减少发送包的数量从而降低延迟。</p></li><li><p>服务器推送<br>服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求。</p></li></ul><h4 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h4><table><thead><tr><th></th><th></th><th>http</th><th>https</th></tr></thead><tbody><tr><td>端口</td><td>80</td><td>443</td></tr><tr><td>内容</td><td>明文传输</td><td>加密传输</td></tr><tr><td>安全</td><td>无状态</td><td>需要安全证书</td></tr></tbody></table><p>HTTPS 约等于 HTTP+SSL</p><ul><li>优点<br>相对安全/SEO排名更高</li><li>缺点<br>证书需要申请，服务器资源占用更高，连接建立需要传送证书，速度更慢.</li></ul><h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><p><a href="https://blog.csdn.net/guoguo527/article/details/52078962" target="_blank" rel="noopener">四层模型及OSI七层参考模型</a></p><p><a href="https://www.cnblogs.com/Jessy/p/3535612.html" target="_blank" rel="noopener">三次握手四次挥手</a></p><p>简略快速回忆版：</p><ul><li><p>三次握手<br>客户端：我要和你通信(syn-sent)<br>服务端：你的请求已收到，发送确认(syn-rcvd)<br>客户端：你的确认已收到，连接建立(est)</p></li><li><p>四次挥手<br>客户端：我没有东西了，准备关闭(fin-wait)<br>服务端：你的关闭我收到了，但我还有点东西没传完(close-wait)<br>⋯⋯一段时间后⋯⋯<br>服务端：我的东西传完了，可以关闭了(last-ack)<br>客户端：收到关闭通知，你也可以关闭了(time-wait)</p></li></ul><h2 id="算法相关"><a href="#算法相关" class="headerlink" title="算法相关"></a>算法相关</h2><p>各种数据结构，栈图树；各种算法，动态规划balabala</p><p>中等难度算法题在解答基础上提高速度，高级算法题能够有思路，不求ac，至少通过一部分。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;这个文档只是一个提纲，以及一些可能的考点或者demo代码。列出了大概的技术栈，每一个点都需要花更多的时间去深入钻研，万不能只看一点点皮毛就去面试。而应该在广泛学习的基础上，通过文档里的每一个点引出无数个思维方向，从而在大脑里形成一个自己的知识树，明白自己的欠缺，不断学习，丰富自己的技术栈。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="PHP面试题" scheme="https://icocos.github.io/tags/PHP%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>架构篇——MySQL高可用集群(PXC)详解</title>
    <link href="https://icocos.github.io/2019/06/11/%E6%9E%B6%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4-PXC-%E8%AF%A6%E8%A7%A3/"/>
    <id>https://icocos.github.io/2019/06/11/架构篇——MySQL高可用集群-PXC-详解/</id>
    <published>2019-06-11T09:56:41.000Z</published>
    <updated>2019-05-22T09:04:41.409Z</updated>
    
    <content type="html"><![CDATA[<h5 id="在介绍PXC之前，先来看一个相关的技术：MyCat"><a href="#在介绍PXC之前，先来看一个相关的技术：MyCat" class="headerlink" title="在介绍PXC之前，先来看一个相关的技术：MyCat"></a>在介绍PXC之前，先来看一个相关的技术：MyCat</h5><h3 id="MyCat简介"><a href="#MyCat简介" class="headerlink" title="MyCat简介"></a>MyCat简介</h3><p>MyCat是阿里开源的分布式数据库分库分表中间件</p><blockquote><p>MyCat是一个开源的分布式数据库系统，是一个实现了MySQL协议的服务器，前端用户可以把它看作是一个数据库代理，用MySQL客户端工具和命令行访问，而其后端可以用MySQL原生协议与多个MySQL服务器通信，也可以用JDBC协议与大多数主流数据库服务器通信</p></blockquote><h4 id="MyCat功能"><a href="#MyCat功能" class="headerlink" title="MyCat功能:"></a>MyCat功能:</h4><ul><li>数据库读写分离(写操作在主,读操作在从数据库)</li><li>读的负载均衡(一主多从)</li><li>垂直拆分(将表分开为多个数据库)</li><li>水平拆分(对表取模拆分)</li></ul><a id="more"></a><blockquote><p>MyCAT是mysql中间件，前身是阿里大名鼎鼎的Cobar，Cobar在开源了一段时间后，不了了之。于是MyCAT扛起了这面大旗，在大数据时代，其重要性愈发彰显。这篇文章主要是MyCAT的入门部署。</p></blockquote><ul><li>更多相关可以参考这里：<a href="https://www.jianshu.com/p/c6e29d724fca" target="_blank" rel="noopener">https://www.jianshu.com/p/c6e29d724fca</a></li></ul><p>下面是MyCat结合PXC的架构图</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2019/phps/pxc.png"></p><h3 id="PXC简介"><a href="#PXC简介" class="headerlink" title="PXC简介"></a>PXC简介</h3><p>PXC是percona公司的percona  xtraDB  cluster，简称PXC。它是基于Galera协议的高可用集群方案。可以实现多个节点间的数据同步复制以及读写，并且可保障数据库的服务高可用及数据强一致性。</p><blockquote><p>PXC就属于一套近乎完美的MySQL高可用集群架构方案；</p></blockquote><h5 id="主要特点是：-读写强一致性-牺牲性能"><a href="#主要特点是：-读写强一致性-牺牲性能" class="headerlink" title="主要特点是： 读写强一致性(牺牲性能)"></a>主要特点是： 读写强一致性(牺牲性能)</h5><h5 id="PXC特性"><a href="#PXC特性" class="headerlink" title="PXC特性"></a>PXC特性</h5><ul><li>1）同步复制，事务要么在所有节点提交或不提交。</li><li>2）多主复制，可以在任意节点进行写操作。</li><li>3）在从服务器上并行应用事件，真正意义上的并行复制。</li><li>4）节点自动配置，数据一致性，不再是异步复制。</li></ul><p>PXC最大的优势：强一致性、无同步延迟</p><ul><li><p>优点总结：</p><ul><li>服务高可用</li><li>可以达到时时同步(并发复制)，无延迟现象发生</li><li>完全兼容MySQL</li><li>对于集群中新节点的加入(自动部署)，维护起来很简单</li><li>数据的强一致性</li><li>多个可同时读写节点，可实现写扩展，不过最好事先进行分库分表，让各个节点分别写不同的表或者库，避免让galera解决数据冲突；</li></ul></li><li><p>不足之处总结：</p><ul><li>只支持Innodb存储引擎</li><li>存在多节点update更新问题，也就是写放大问题</li><li>在线DDL语句，锁表问题</li><li>sst针对新节点加入的传输代价过高的问题</li><li>所有表都要有主键；</li><li>不支持LOCK TABLE等显式锁操作；</li><li>锁冲突、死锁问题相对更多；</li><li>不支持XA；</li></ul></li></ul><p>事实上，采用PXC的主要目的是解决数据的一致性问题，高可用是顺带实现的。因为PXC存在写扩大以及短板效应，并发效率会有较大损失，类似semi sync replication机制。</p><pre><code>网络说明基于Galere协议的高可用方案：pxc+ Galera是Codership提供的多主数据同步复制机制，可以实现多个节点间的数据同步复制以及读写，并且+ 可保障数据库的服务高可用及数据一致性。+ 基于Galera的高可用方案主要有MariaDB Galera Cluster和Percona XtraDB Cluster（简称PXC），目前PXC用的会比较多一些。+ mariadb的集群原理跟PXC一样,maridb-cluster其实就是PXC，两者原理是一样的。</code></pre><h3 id="PXC原理"><a href="#PXC原理" class="headerlink" title="PXC原理"></a>PXC原理</h3><p>Percona XtraDB Cluster（简称PXC集群）提供了MySQL高可用的一种实现方法。</p><ul><li>1）集群是有节点组成的，推荐配置至少3个节点，但是也可以运行在2个节点上。</li><li>2）每个节点都是普通的mysql/percona服务器，可以将现有的数据库服务器组成集群，反之，也可以将集群拆分成单独的服务器。</li><li>3）每个节点都包含完整的数据副本。</li></ul><p>PXC集群主要由两部分组成：Percona Server with XtraDB和Write Set Replication patches（使用了Galera library，一个通用的用于事务型应用的同步、多主复制插件）。</p><p>PXC会使用大概是4个端口号</p><ul><li>3306 数据库对外服务的端口号</li><li>4444 请求SST SST: 指数据一个镜象传输 xtrabackup , rsync ,mysqldump </li><li>4567 : 组成员之间进行沟通的一个端口号</li><li>4568 : 传输IST用的。相对于SST来说的一个增量。</li></ul><blockquote><p>注：安装PXC过程中， iptables 禁掉 ，selinux 也禁掉</p></blockquote><h3 id="PXC的操作流程："><a href="#PXC的操作流程：" class="headerlink" title="PXC的操作流程："></a>PXC的操作流程：</h3><ul><li>首先客户端先发起一个事务，该事务先在本地执行，执行完成之后就要发起对事务的提交操作了。</li><li>在提交之前需要将产生的复制写集广播出去，然后获取到一个全局的事务ID号，一并传送到另一个节点上面。</li><li>通过合并数据之后，发现没有冲突数据，执行apply_cd和commit_cb动作，否则就需要取消此次事务的操作。</li><li>当前server节点通过验证之后，执行提交操作，并返回OK，如果验证没通过，则执行回滚。</li><li>在生产中至少要有3个节点的集群环境，如果其中一个节点没有验证通过，出现了数据冲突，那么此时采取的方式就是讲出现不一致的节点踢出集群环境，而且它自己会执行shutdown命令，自动关机。</li></ul><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>部署环境： CentOS7.X</p><h5 id="1、执行-命令-vi-etc-selinux-config"><a href="#1、执行-命令-vi-etc-selinux-config" class="headerlink" title="1、执行 命令   vi /etc/selinux/config"></a>1、执行 命令   vi /etc/selinux/config</h5><pre><code>SELINUX=disabled   #修改该项为disabled</code></pre><h5 id="2、执行命令-setenforce-0"><a href="#2、执行命令-setenforce-0" class="headerlink" title="2、执行命令   setenforce 0"></a>2、执行命令   setenforce 0</h5><h5 id="3、查看防火墙是否开启-systemctl-status-firewalld"><a href="#3、查看防火墙是否开启-systemctl-status-firewalld" class="headerlink" title="3、查看防火墙是否开启     systemctl status firewalld"></a>3、查看防火墙是否开启     systemctl status firewalld</h5><p>如果防火墙是开启状态，则开放端口 3306 、4444、4567、4568</p><pre><code>firewall-cmd --add-port=3306/tcp --permanent     #开放了3306端口</code></pre><p>开放完4个端口后，重新加载防火墙规则</p><pre><code>firewall-cmd --reload</code></pre><h5 id="4、安装Persona仓库"><a href="#4、安装Persona仓库" class="headerlink" title="4、安装Persona仓库"></a>4、安装Persona仓库</h5><pre><code>yum install http://www.percona.com/downloads/percona-release/redhat/0.1-4/percona-release-0.1-4.noarch.rpm</code></pre><h5 id="5、安装PXC（保证服务器没有装MySQL）卸载MySQL-参考链接：https-blog-csdn-net-tjcyjd-article-details-52189182"><a href="#5、安装PXC（保证服务器没有装MySQL）卸载MySQL-参考链接：https-blog-csdn-net-tjcyjd-article-details-52189182" class="headerlink" title="5、安装PXC（保证服务器没有装MySQL）卸载MySQL 参考链接：https://blog.csdn.net/tjcyjd/article/details/52189182"></a>5、安装PXC（保证服务器没有装MySQL）卸载MySQL 参考链接：<a href="https://blog.csdn.net/tjcyjd/article/details/52189182" target="_blank" rel="noopener">https://blog.csdn.net/tjcyjd/article/details/52189182</a></h5><pre><code>yum install Percona-XtraDB-Cluster-57</code></pre><h5 id="6、开启PXC服务"><a href="#6、开启PXC服务" class="headerlink" title="6、开启PXC服务"></a>6、开启PXC服务</h5><pre><code>service mysql start</code></pre><h5 id="7、查看安装数据库的临时密码并记住"><a href="#7、查看安装数据库的临时密码并记住" class="headerlink" title="7、查看安装数据库的临时密码并记住"></a>7、查看安装数据库的临时密码并记住</h5><pre><code>grep &apos;temporary password&apos; /var/log/mysqld.log</code></pre><h5 id="8、登录MySQL数据库"><a href="#8、登录MySQL数据库" class="headerlink" title="8、登录MySQL数据库"></a>8、登录MySQL数据库</h5><pre><code>mysql -u root -p</code></pre><p>输入临时密码, 登录成功后修改密码</p><pre><code>ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;你的密码&apos;;</code></pre><h5 id="9、停止MySQL服务"><a href="#9、停止MySQL服务" class="headerlink" title="9、停止MySQL服务"></a>9、停止MySQL服务</h5><pre><code>service mysql stop   （某些版本使用mysqld）</code></pre><h5 id="10、配置节点"><a href="#10、配置节点" class="headerlink" title="10、配置节点"></a>10、配置节点</h5><pre><code>vi  /etc/percona-xtradb-cluster.conf.d/wsrep.cnf</code></pre><p>修改配置文件</p><pre><code># Cluster connection URL contains IPs of nodes#If no IP is found, this implies that a new cluster needs to be created,#in order to do that you need to bootstrap this node#集群中节点的IP地址（本机填最后）wsrep_cluster_address=gcomm://ip地址,IP地址,IP地址（用,号隔开）# In order for Galera to work correctly binlog format should be ROWbinlog_format=ROW# MyISAM storage engine has only experimental supportdefault_storage_engine=InnoDB# Slave thread to usewsrep_slave_threads= 8wsrep_log_conflicts# This changes how InnoDB autoincrement locks are managed and is a requirement for Galerainnodb_autoinc_lock_mode=2# Node IP address#当前节点IPwsrep_node_address=IP地址# Cluster name#集群名称wsrep_cluster_name=pxc-cluster#If wsrep_node_name is not specified,  then system hostname will be used#当前节点名称wsrep_node_name=pxc-cluster-node-1#pxc_strict_mode allowed values: DISABLED,PERMISSIVE,ENFORCING,MASTER#不使用实验功能pxc_strict_mode=ENFORCING# SST method#状态快照传输（sst）方法，官方建议wsrep_sst_method=xtrabackup-v2#Authentication for SST method#用户凭证（mysql的用户名和密码）wsrep_sst_auth=&quot;用户名:密码&quot;</code></pre><p>剩下的节点修改当前节点名、当前节点IP、集群中的节点IP，其他相同</p><blockquote><p>注：1—10步骤  每个节点都要配置一次</p></blockquote><h5 id="11、初始化集群节点"><a href="#11、初始化集群节点" class="headerlink" title="11、初始化集群节点"></a>11、初始化集群节点</h5><p>其中一个节点使用 systemctl start <a href="mailto:mysql@bootstrap.service" target="_blank" rel="noopener">mysql@bootstrap.service</a> 启动</p><h6 id="登录mysql"><a href="#登录mysql" class="headerlink" title="登录mysql"></a>登录mysql</h6><pre><code>mysql -u root -p</code></pre><p>开启 wsrep_causal_reads</p><pre><code>set wsrep_causal_reads =1;</code></pre><h5 id="12、创建配置文件中对应的用户"><a href="#12、创建配置文件中对应的用户" class="headerlink" title="12、创建配置文件中对应的用户"></a>12、创建配置文件中对应的用户</h5><blockquote><p>所有节点的IP都要创建</p></blockquote><p>创建用户：    </p><pre><code>CREATE USER &apos;用户名&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;密码&apos;;  </code></pre><p>刷新权限：   </p><pre><code>GRANT all privileges ON *.* TO &apos;用户名&apos;@&apos;localhost&apos; ;FLUSH PRIVILEGES;</code></pre><p>创建用户：</p><pre><code>CREATE USER &apos;用户名&apos;@&apos;当前需要访问数据库的IP地址&apos; IDENTIFIED BY &apos;密码&apos;;  </code></pre><p>刷新权限：</p><pre><code>GRANT all privileges ON *.* TO &apos;用户名&apos;@&apos;当前节点IP地址&apos; ;FLUSH PRIVILEGES;</code></pre><h5 id="13、其他节点使用-service-mysql-start-启动-，登录mysql，配置wsrep-causal-reds，set-wsrep-causal-reads-1"><a href="#13、其他节点使用-service-mysql-start-启动-，登录mysql，配置wsrep-causal-reds，set-wsrep-causal-reads-1" class="headerlink" title="13、其他节点使用   service mysql start  启动 ，登录mysql，配置wsrep_causal_reds，set wsrep_causal_reads =1;"></a>13、其他节点使用   service mysql start  启动 ，登录mysql，配置wsrep_causal_reds，set wsrep_causal_reads =1;</h5><h5 id="14、其他节点启动成功后在引导节点（使用-systemctl-start-mysql-bootstrap-service-命令启动的节点）"><a href="#14、其他节点启动成功后在引导节点（使用-systemctl-start-mysql-bootstrap-service-命令启动的节点）" class="headerlink" title="14、其他节点启动成功后在引导节点（使用 systemctl start mysql@bootstrap.service 命令启动的节点）"></a>14、其他节点启动成功后在引导节点（使用 systemctl start <a href="mailto:mysql@bootstrap.service" target="_blank" rel="noopener">mysql@bootstrap.service</a> 命令启动的节点）</h5><p>验证集群：</p><pre><code>show status like &apos;wsrep%&apos;;  </code></pre><h5 id="15、节点数据同步验证"><a href="#15、节点数据同步验证" class="headerlink" title="15、节点数据同步验证"></a>15、节点数据同步验证</h5><p>在当前节点创建一个数据库 </p><pre><code>CREATE DATABASE percona;</code></pre><p>启动其他节点的数据库服务，进去后会发现新建的数据库，同理 其他节点创建的数据  当前节点也能看到</p><p>注意：服务的启动和停止要对应</p><pre><code>service mysql stop   ------&gt;  启动时用service mysql start</code></pre><p>或者 </p><pre><code>systemctl stop mysql@bootstrap.service   -----&gt;  启用是用 systemctl start mysql@bootstrap.service </code></pre><ul><li>更多相关实战配置可以参考这里：<a href="https://www.jianshu.com/p/0b7c050dfab6" target="_blank" rel="noopener">https://www.jianshu.com/p/0b7c050dfab6</a></li></ul><h5 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h5><ul><li>带你玩转Mysql高可用方案–PXC<ul><li><a href="https://blog.csdn.net/zisefeizhu/article/details/81873466" target="_blank" rel="noopener">https://blog.csdn.net/zisefeizhu/article/details/81873466</a></li></ul></li><li><p>Docker搭建PXC集群</p><ul><li><a href="https://blog.csdn.net/weixin_41141219/article/details/82767832" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41141219/article/details/82767832</a></li></ul></li><li><p>MySQL高可用方案－PXC环境部署记录: 详细教程</p><ul><li><a href="http://www.cnblogs.com/kevingrace/p/5685371.html" target="_blank" rel="noopener">http://www.cnblogs.com/kevingrace/p/5685371.html</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;在介绍PXC之前，先来看一个相关的技术：MyCat&quot;&gt;&lt;a href=&quot;#在介绍PXC之前，先来看一个相关的技术：MyCat&quot; class=&quot;headerlink&quot; title=&quot;在介绍PXC之前，先来看一个相关的技术：MyCat&quot;&gt;&lt;/a&gt;在介绍PXC之前，先来看一个相关的技术：MyCat&lt;/h5&gt;&lt;h3 id=&quot;MyCat简介&quot;&gt;&lt;a href=&quot;#MyCat简介&quot; class=&quot;headerlink&quot; title=&quot;MyCat简介&quot;&gt;&lt;/a&gt;MyCat简介&lt;/h3&gt;&lt;p&gt;MyCat是阿里开源的分布式数据库分库分表中间件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MyCat是一个开源的分布式数据库系统，是一个实现了MySQL协议的服务器，前端用户可以把它看作是一个数据库代理，用MySQL客户端工具和命令行访问，而其后端可以用MySQL原生协议与多个MySQL服务器通信，也可以用JDBC协议与大多数主流数据库服务器通信&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;MyCat功能&quot;&gt;&lt;a href=&quot;#MyCat功能&quot; class=&quot;headerlink&quot; title=&quot;MyCat功能:&quot;&gt;&lt;/a&gt;MyCat功能:&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;数据库读写分离(写操作在主,读操作在从数据库)&lt;/li&gt;
&lt;li&gt;读的负载均衡(一主多从)&lt;/li&gt;
&lt;li&gt;垂直拆分(将表分开为多个数据库)&lt;/li&gt;
&lt;li&gt;水平拆分(对表取模拆分)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="MySQL" scheme="https://icocos.github.io/tags/MySQL/"/>
    
      <category term="PXC集群" scheme="https://icocos.github.io/tags/PXC%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>架构篇——MySQL主从复制(Master-Slave)详解</title>
    <link href="https://icocos.github.io/2019/06/09/%E6%9E%B6%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-Master-Slave-%E8%AF%A6%E8%A7%A3/"/>
    <id>https://icocos.github.io/2019/06/09/架构篇——MySQL主从复制-Master-Slave-详解/</id>
    <published>2019-06-09T09:55:42.000Z</published>
    <updated>2019-05-22T09:04:36.347Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h3><p>Mysql主从又叫Replication、AB复制(不同于PXC)。简单讲就是A与B两台机器做主从后，在A上写数据，另外一台B也会跟着写数据，实现数据实时同步</p><blockquote><p>mysql主从是基于binlog，主上需开启binlog才能进行主从</p></blockquote><h5 id="主从过程大概有3个步骤"><a href="#主从过程大概有3个步骤" class="headerlink" title="主从过程大概有3个步骤"></a>主从过程大概有3个步骤</h5><ul><li>主将更改操作记录到binlog里</li><li>从将主的binlog事件（sql语句） 同步本机上并记录在relaylog里</li><li>从根据relaylog里面的sql语句按顺序执行</li></ul><a id="more"></a><h4 id="主从作用"><a href="#主从作用" class="headerlink" title="主从作用"></a>主从作用</h4><pre><code>实时灾备，用于故障切换读写分离，提供查询服务备份，避免影响业务</code></pre><h4 id="主从形式"><a href="#主从形式" class="headerlink" title="主从形式"></a>主从形式</h4><ul><li>一主一从</li><li>主主复制</li><li>一主多从—扩展系统读取的性能，因为读是在从库读取的</li><li>多主一从—5.7版本开始支持</li><li>联级复制</li></ul><p>MySQL数据库自身提供的主从复制功能可以方便的实现数据的多处自动备份，实现数据库的拓展。多个数据备份不仅可以加强数据的安全性，通过实现读写分离还能进一步提升数据库的负载性能。</p><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><blockquote><p>MySQL之间数据复制的基础是二进制日志文件（binary log file）。一台MySQL数据库一旦启用二进制日志后，其作为master，它的数据库中所有操作都会以“事件”的方式记录在二进制日志中，其他数据库作为slave通过一个I/O线程与主服务器保持通信，并监控master的二进制日志文件的变化，如果发现master二进制日志文件发生变化，则会把变化复制到自己的中继日志中，然后slave的一个SQL线程会把相关的“事件”执行到自己的数据库中，以此实现从数据库和主数据库的一致性，也就实现了主从复制。</p></blockquote><ul><li>主库将所有的写操作记录在binlog日志中，并生成log dump线程，将binlog日志传给从库的I/O线程</li><li>从库生成两个线程，一个是I/O线程，另一个是SQL线程</li><li>I/O线程去请求主库的binlog日志，并将binlog日志中的文件写入relay log（中继日志）中</li><li>SQL线程会读取relay loy中的内容，并解析成具体的操作，来实现主从的操作一致，达到最终数据一致的目的</li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>实现MySQL主从复制需要进行的配置：</p><ul><li><p>主服务器：</p><ul><li>开启二进制日志</li><li>配置唯一的server-id</li><li>获得master二进制日志文件名及位置</li><li>创建一个用于slave和master通信的用户账号</li></ul></li><li><p>从服务器：</p><ul><li>配置唯一的server-id</li><li>使用master分配的用户账号读取master二进制日志</li><li>启用slave服务</li></ul></li></ul><h4 id="具体实现过程如下："><a href="#具体实现过程如下：" class="headerlink" title="具体实现过程如下："></a>具体实现过程如下：</h4><p>主从复制配置步骤：</p><ul><li>确保从数据库与主数据库里的数据一致</li><li>在主数据库里创建一个同步账户授权给从数据库使用</li><li>配合主数据库（修改配置文件）</li><li>配置从数据库（修改配置文件）</li></ul><h5 id="一、准备工作："><a href="#一、准备工作：" class="headerlink" title="一、准备工作："></a>一、准备工作：</h5><ol><li>主从数据库版本最好一致</li><li>主从数据库内数据保持一致</li></ol><p>搭建两台MYSQL服务器，一台作为主服务器，一台作为从服务器，主服务器进行写操作，从服务器进行读操作</p><pre><code>+ 主数据库：192.168.0.1 /Linux-MySQL+ 从数据库：192.168.0.2 /Linux-MySQL</code></pre><h5 id="二、主数据库master修改："><a href="#二、主数据库master修改：" class="headerlink" title="二、主数据库master修改："></a>二、主数据库master修改：</h5><p>1.修改mysql配置</p><p>找到主数据库的配置文件my.cnf(或者my.ini)，我的在/etc/mysql/my.cnf,在[mysqld]部分插入如下两行：</p><pre><code>[mysqld]log-bin=mysql-bin #开启二进制日志server-id=1 #设置server-id</code></pre><p>2.重启mysql，创建用于同步的用户账号</p><p>打开mysql会话shell</p><pre><code>mysql -hlocalhost -uname -ppassword</code></pre><p>创建用户：用户：rel1密码：slavepass</p><p>3.授权</p><p>主服务器授权从服务器特定账号登录</p><pre><code>mysql&gt; CREATE USER &apos;repl&apos;@&apos;192.168.0.2&apos; IDENTIFIED BY &apos;slavepass&apos;;#创建用户mysql&gt; GRANT REPLICATION SLAVE ON *.* TO &apos;repl&apos;@&apos;192.168.0.2&apos;;#分配权限mysql&gt;flush privileges;   #刷新权限</code></pre><p>4.查看master状态，记录二进制文件名(mysql-bin.000003)和位置(73)：</p><pre><code>mysql &gt; SHOW MASTER STATUS;+------------------+----------+--------------+------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |+------------------+----------+--------------+------------------+| mysql-bin.000003 | 73       | test         | manual,mysql     |+------------------+----------+--------------+------------------+</code></pre><h5 id="三、从服务器slave修改："><a href="#三、从服务器slave修改：" class="headerlink" title="三、从服务器slave修改："></a>三、从服务器slave修改：</h5><p>1.修改mysql配置</p><p>同样找到my.cnf配置文件，添加server-id</p><pre><code>[mysqld]server-id=2 #设置server-id，必须唯一</code></pre><p>2.重启mysql，打开mysql会话，执行同步SQL语句(需要主服务器主机名，登陆凭据，二进制文件的名称和位置)：<br>复制代码</p><pre><code>mysql&gt; CHANGE MASTER TO    -&gt;     MASTER_HOST=&apos;192.168.0.1&apos;,    -&gt;     MASTER_USER=&apos;rep1&apos;,    -&gt;     MASTER_PASSWORD=&apos;slavepass&apos;,    -&gt;     MASTER_LOG_FILE=&apos;mysql-bin.000003&apos;,    -&gt;     MASTER_LOG_POS=73;</code></pre><p>3.启动slave同步进程：</p><pre><code>mysql&gt;start slave;</code></pre><p>4.查看slave状态：</p><pre><code>mysql&gt; show slave status\G;*************************** 1. row ***************************               Slave_IO_State: Waiting for master to send event                  Master_Host: 192.168.0.1                  Master_User: rep1                  Master_Port: 3306                Connect_Retry: 60              Master_Log_File: mysql-bin.000013          Read_Master_Log_Pos: 11662               Relay_Log_File: mysqld-relay-bin.000022                Relay_Log_Pos: 11765        Relay_Master_Log_File: mysql-bin.000013             Slave_IO_Running: Yes            Slave_SQL_Running: Yes              Replicate_Do_DB:           Replicate_Ignore_DB:         ...</code></pre><p>当Slave_IO_Running和Slave_SQL_Running都为YES的时候就表示主从同步设置成功了。</p><p>接下来就可以进行一些验证了，比如在主master数据库的test数据库的一张表中插入一条数据，在slave的test库的相同数据表中查看是否有新增的数据即可验证主从复制功能是否有效，还可以关闭slave（mysql&gt;stop slave;）,然后再修改master，看slave是否也相应修改（停止slave后，master的修改不会同步到slave），就可以完成主从复制功能的验证了。</p><p>还可以用到的其他相关参数：</p><blockquote><p>master开启二进制日志后默认记录所有库所有表的操作，可以通过配置来指定只记录指定的数据库甚至指定的表的操作，具体在mysql配置文件的[mysqld]可添加修改如下选项：</p></blockquote><pre><code># 不同步哪些数据库  binlog-ignore-db = mysql  binlog-ignore-db = test  binlog-ignore-db = information_schema  # 只同步哪些数据库，除此之外，其他不同步  binlog-do-db = game  </code></pre><blockquote><p>如之前查看master状态时就可以看到只记录了test库，忽略了manual和mysql库。</p></blockquote><h3 id="操作流程汇总"><a href="#操作流程汇总" class="headerlink" title="操作流程汇总"></a>操作流程汇总</h3><h5 id="关闭防火墙以SELINUX"><a href="#关闭防火墙以SELINUX" class="headerlink" title="关闭防火墙以SELINUX"></a>关闭防火墙以SELINUX</h5><pre><code>[root@icocos ~]# systemctl stop firewalld[root@icocos ~]# systemctl disable firewalld[root@icocos ~]#  sed -ri &apos;s/(SELINUX=).*/\1disabled/g&apos; /etc/selinux/config[root@icocos ~]# setenforce 0</code></pre><h5 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h5><pre><code>安装依赖包[root@icocos ~]# yum -y install ncurses-devel openssl-devel openssl cmake mariadb-devel</code></pre><h5 id="创建用户和组"><a href="#创建用户和组" class="headerlink" title="创建用户和组"></a>创建用户和组</h5><pre><code>[root@icocos ~]# groupadd -r -g 306 mysql[root@icocos ~]# useradd -M -s /sbin/nologin -g 306 -u 306 mysql</code></pre><h5 id="下载二进制格式的mysql软件包"><a href="#下载二进制格式的mysql软件包" class="headerlink" title="下载二进制格式的mysql软件包"></a>下载二进制格式的mysql软件包</h5><pre><code>[root@icocos ~]# cd /usr/src/[root@icocos src]#wget https://downloads.mysql.com/archives/get/file/mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz</code></pre><h5 id="解压软件至-usr-local"><a href="#解压软件至-usr-local" class="headerlink" title="解压软件至/usr/local/"></a>解压软件至/usr/local/</h5><pre><code>[root@icocos src]# lsdebug  kernels  mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz[root@icocos src]# tar xf mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz -C /usr/local/[root@icocos src]#  ls  /usr/local/bin  etc  games  include  lib  lib64  libexec  mysql-5.7.22-linux-glibc2.12-x86_64  sbin  share  src[root@icocos src]#  cd  /usr/local/[root@icocos local]# ln -sv mysql-5.7.22-linux-glibc2.12-x86_64/ mysql&quot;mysql&quot; -&gt; &quot;mysql-5.7.22-linux-glibc2.12-x86_64/&quot;[root@icocos local]# ll总用量 0drwxr-xr-x. 2 root root   6 11月  5 2016 bindrwxr-xr-x. 2 root root   6 11月  5 2016 etcdrwxr-xr-x. 2 root root   6 11月  5 2016 gamesdrwxr-xr-x. 2 root root   6 11月  5 2016 includedrwxr-xr-x. 2 root root   6 11月  5 2016 libdrwxr-xr-x. 2 root root   6 11月  5 2016 lib64drwxr-xr-x. 2 root root   6 11月  5 2016 libexeclrwxrwxrwx. 1 root root  36 9月   7 22:20 mysql -&gt; mysql-5.7.22-linux-glibc2.12-x86_64/drwxr-xr-x. 9 root root 129 9月   7 22:19 mysql-5.7.22-linux-glibc2.12-x86_64drwxr-xr-x. 2 root root   6 11月  5 2016 sbindrwxr-xr-x. 5 root root  49 9月   3 23:02 sharedrwxr-xr-x. 2 root root   6 11月  5 2016 src</code></pre><h5 id="修改目录-usr-locaal-mysql的属主属组"><a href="#修改目录-usr-locaal-mysql的属主属组" class="headerlink" title="修改目录/usr/locaal/mysql的属主属组"></a>修改目录/usr/locaal/mysql的属主属组</h5><pre><code>[root@icocos local]# chown -R mysql.mysql /usr/local/mysql[root@icocos local]#  ll /usr/local/mysql -dlrwxrwxrwx. 1 mysql mysql 36 9月   7 22:20 /usr/local/mysql -&gt; mysql-5.7.22-linux-glibc2.12-x86_64/</code></pre><h5 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h5><pre><code>[root@icocos local]# ls /usr/local/mysqlbin  COPYING  docs  include  lib  man  README  share  support-files[root@icocos local]# cd[root@icocos ~]# echo &apos;export PATH=/usr/local/mysql/bin:$PATH&apos; &gt; /etc/profile.d/mysql.sh[root@icocos ~]# . /etc/profile.d/mysql.sh[root@icocos ~]# echo $PATH/usr/local/mysql/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</code></pre><h5 id="建立数据存放目录"><a href="#建立数据存放目录" class="headerlink" title="建立数据存放目录"></a>建立数据存放目录</h5><pre><code>[root@icocos ~]# cd /usr/local/mysql[root@icocos mysql]# mkdir /opt/data[root@icocos mysql]#  chown -R mysql.mysql /opt/data/[root@icocos mysql]#  ll /opt/总用量 0drwxr-xr-x. 2 mysql mysql 6 9月   7 22:25 data</code></pre><h5 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h5><pre><code>[root@icocos mysql]# /usr/local/mysql/bin/mysqld --initialize --user=mysql --datadir=/opt/data///这个命令的最后会生成一个临时密码，此处密码是1EbNA-k*BtKo</code></pre><h5 id="配置mysql"><a href="#配置mysql" class="headerlink" title="配置mysql"></a>配置mysql</h5><pre><code>[root@icocos ~]# ln -sv /usr/local/mysql/include/ /usr/local/include/mysql&quot;/usr/local/include/mysql&quot; -&gt; &quot;/usr/local/mysql/include/&quot;[root@icocos ~]# echo &apos;/usr/local/mysql/lib&apos; &gt; /etc/ld.so.conf.d/mysql.conf[root@icocos ~]#  ldconfig -v</code></pre><h5 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h5><pre><code>[root@icocos ~]# cat &gt; /etc/my.cnf &lt;&lt;EOF&gt; [mysqld]&gt; basedir = /usr/local/mysql&gt; datadir = /opt/data&gt; socket = /tmp/mysql.sock&gt; port = 3306&gt; pid-file = /opt/data/mysql.pid&gt; user = mysql&gt; skip-name-resolve&gt; EOF</code></pre><h5 id="配置服务启动脚本"><a href="#配置服务启动脚本" class="headerlink" title="配置服务启动脚本"></a>配置服务启动脚本</h5><pre><code>[root@icocos ~]# cp -a /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld[root@icocos ~]#  sed -ri &apos;s#^(basedir=).*#\1/usr/local/mysql#g&apos; /etc/init.d/mysqld[root@icocos ~]# sed -ri &apos;s#^(datadir=).*#\1/opt/data#g&apos; /etc/init.d/mysqld</code></pre><h5 id="启动mysql"><a href="#启动mysql" class="headerlink" title="启动mysql"></a>启动mysql</h5><pre><code>[root@icocos ~]#  service mysqld startStarting MySQL.Logging to &apos;/opt/data/icocos.err&apos;... SUCCESS![root@icocos ~]#  ps -ef|grep mysqlroot       4897      1  0 22:38 pts/2    00:00:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/opt/data --pid-file=/opt/data/mysql.pidmysql      5075   4897  6 22:38 pts/2    00:00:01 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/opt/data --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=icocos.err --pid-file=/opt/data/mysql.pid --socket=/tmp/mysql.sock --port=3306root       5109   4668  0 22:38 pts/2    00:00:00 grep --color=auto mysql[root@icocos ~]# ss -antlState       Recv-Q Send-Q                     Local Address:Port                                    Peer Address:Port              LISTEN      0      128                                    *:22                                                 *:*                  LISTEN      0      100                            127.0.0.1:25                                                 *:*                  LISTEN      0      128                                   :::22                                                :::*                  LISTEN      0      100                                  ::1:25                                                :::*                  LISTEN      0      80                                    :::3306                                              :::*                  </code></pre><h5 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h5><p>使用临时密码修改</p><pre><code>[root@icocos ~]# mysql -uroot -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.7.22Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; set password = password(&apos;123456&apos;);Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; quitBye</code></pre><h5 id="mysql主从配置"><a href="#mysql主从配置" class="headerlink" title="mysql主从配置"></a>mysql主从配置</h5><p>确保从数据库与主数据库的数据一样先在主数据库创建所需要同步的库和表</p><pre><code>[root@icocos ~]# mysql -uroot -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 4Server version: 5.7.22 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. AlOracle is a registered trademark of Oracle Corporation andaffiliates. Other names may be trademarks of their respectowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the currmysql&gt; create database yan;Query OK, 1 row affected (0.00 sec)mysql&gt; create database lisi;Query OK, 1 row affected (0.00 sec)mysql&gt; create database wangwu;Query OK, 1 row affected (0.00 sec)mysql&gt; use yan;Database changedmysql&gt; create table tom (id int not null,name varchar(100)not null ,age tinyint);Query OK, 0 rows affected (11.83 sec)mysql&gt; insert tom (id,name,age) values(1,&apos;zhangshan&apos;,20),(2,&apos;wangwu&apos;,7),(3,&apos;lisi&apos;,23);Query OK, 3 rows affected (0.07 sec)Records: 3  Duplicates: 0  Warnings: 0mysql&gt; select * from tom;+----+-----------+------+| id | name      | age  |+----+-----------+------+|  1 | zhangshan |   20 ||  2 | wangwu    |    7 ||  3 | lisi      |   23 |+----+-----------+------+3 rows in set (0.00 sec)</code></pre><h5 id="备份主库"><a href="#备份主库" class="headerlink" title="备份主库"></a>备份主库</h5><p>备份主库时需要另开一个终端，给数据库上读锁，避免在备份期间有其他人在写入导致数据同步的不一致</p><pre><code>[root@icocos ~]# mysql -uroot -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 5Server version: 5.7.22 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; flush tables with read lock;Query OK, 0 rows affected (0.76 sec)</code></pre><p>此锁表的终端必须在备份完成以后才能退出（退出锁表失效）</p><h5 id="备份主库并将备份文件传送到从库"><a href="#备份主库并将备份文件传送到从库" class="headerlink" title="备份主库并将备份文件传送到从库"></a>备份主库并将备份文件传送到从库</h5><pre><code>[root@icocos ~]# mysqldump -uroot -p123456 --all-databases &gt; /opt/all-20180907.sqlmysqldump: [Warning] Using a password on the command line interface can be insecure.[root@icocos ~]# ls /opt/all-20180907.sql  data[root@icocos ~]# scp /opt/all-20180907.sql root@192.168.0.2:/opt/The authenticity of host &apos;192.168.0.2 (192.168.0.2)&apos; can&apos;t be established.ECDSA key fingerprint is SHA256:7mLj77SFk7sPkhjpMPfdK3nZ98hOuyP4OKzjXeijSJ0.ECDSA key fingerprint is MD5:a0:1b:eb:7f:f0:b6:7b:73:97:91:4c:f3:b1:89:d8:ea.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;192.168.0.2&apos; (ECDSA) to the list of known hosts.root@192.168.0.2&apos;s password:all-20180907.sql       100%  784KB 783.3KB/s   00:01    </code></pre><h5 id="解除主库的锁表状态，直接退出交互式界面即可"><a href="#解除主库的锁表状态，直接退出交互式界面即可" class="headerlink" title="解除主库的锁表状态，直接退出交互式界面即可"></a>解除主库的锁表状态，直接退出交互式界面即可</h5><pre><code>mysql&gt; quitBye</code></pre><h5 id="在从库上恢复主库的备份并查看是否与主库的数据保持一致"><a href="#在从库上恢复主库的备份并查看是否与主库的数据保持一致" class="headerlink" title="在从库上恢复主库的备份并查看是否与主库的数据保持一致"></a>在从库上恢复主库的备份并查看是否与主库的数据保持一致</h5><pre><code>[root@icocos ~]# mysql -uroot -p123456 &lt; /opt/all-20180907.sqlmysql: [Warning] Using a password on the command line interface can be insecure.[root@icocos ~]# mysql -uroot -p123456mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 4Server version: 5.7.22 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || lisi               || mysql              || performance_schema || sys                || wangwu             || yan                |+--------------------+7 rows in set (0.18 sec)mysql&gt; use yan;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; select * from tom;+----+-----------+------+| id | name      | age  |+----+-----------+------+|  1 | zhangshan |   20 ||  2 | wangwu    |    7 ||  3 | lisi      |   23 |+----+-----------+------+3 rows in set (0.06 sec)</code></pre><h5 id="在主数据库创建一个同步账户授权给从数据使用"><a href="#在主数据库创建一个同步账户授权给从数据使用" class="headerlink" title="在主数据库创建一个同步账户授权给从数据使用"></a>在主数据库创建一个同步账户授权给从数据使用</h5><pre><code>[root@icocos ~]# mysql -uroot -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 7Server version: 5.7.22 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; create user &apos;repl&apos;@&apos;192.168.0.2&apos; identified by &apos;123456&apos;;Query OK, 0 rows affected (5.50 sec)mysql&gt; grant replication slave on *.* to &apos;repl&apos;@&apos;192.168.0.2&apos;;Query OK, 0 rows affected (0.04 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.09 sec)</code></pre><h5 id="配置主数据库编辑配置文件"><a href="#配置主数据库编辑配置文件" class="headerlink" title="配置主数据库编辑配置文件"></a>配置主数据库编辑配置文件</h5><pre><code>[root@icocos ~]# vim /etc/my.cnf[root@icocos ~]# cat /etc/my.cnf[mysqld]basedir = /usr/local/mysqldatadir = /opt/datasocket = /tmp/mysql.sockport = 3306pid-file = /opt/data/mysql.piduser = mysqlskip-name-resolve//添加以下内容log-bin=mysql-bin //启用binlog日志server-id=1 //主数据库服务器唯一标识符 主的必须必从大log-error=/opt/data/mysql.log</code></pre><h5 id="重启mysql服务"><a href="#重启mysql服务" class="headerlink" title="重启mysql服务"></a>重启mysql服务</h5><pre><code>[root@icocos ~]# service mysqld restartShutting down MySQL..... SUCCESS!Starting MySQL.Logging to &apos;/opt/data/mysql.log&apos;................................ SUCCESS![root@icocos ~]# ss -antlState       Recv-Q Send-Q Local Address:Port               Peer Address:Port              LISTEN      0      128     *:22                  *:*                  LISTEN      0      100    127.0.0.1:25                  *:*                  LISTEN      0      128    :::22                 :::*                  LISTEN      0      100       ::1:25                 :::*                  LISTEN      0      80     :::3306               :::*</code></pre><h5 id="查看主库的状态"><a href="#查看主库的状态" class="headerlink" title="查看主库的状态"></a>查看主库的状态</h5><pre><code>mysql&gt; show master status;+------------------+----------+--------------+------------------+-------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+------------------+----------+--------------+------------------+-------------------+| mysql-bin.000001 |      154 |              |                  |                   |+------------------+----------+--------------+------------------+-------------------+1 row in set (0.00 sec)</code></pre><h5 id="配置从数据库"><a href="#配置从数据库" class="headerlink" title="配置从数据库"></a>配置从数据库</h5><p>编辑配置文件</p><pre><code>[root@icocos ~]# cat /etc/my.cnf[mysqld]basedir = /usr/local/mysqldatadir = /opt/datasocket = /tmp/mysql.sockport = 3306pid-file = /opt/data/mysql.piduser = mysqlskip-name-resolve//添加以下内容：server-id=2 //设置从库的唯一标识符 从的必须比主小relay-log=mysql-relay-bin //启用中继日志relay logerror-log=/opt/data/mysql.log</code></pre><h5 id="重启从库的mysql服务"><a href="#重启从库的mysql服务" class="headerlink" title="重启从库的mysql服务"></a>重启从库的mysql服务</h5><pre><code>[root@icocos ~]# service mysqld restartShutting down MySQL.. SUCCESS!Starting MySQL.. SUCCESS![root@icocos ~]# ss -antlState       Recv-Q Send-Q Local Address:Port               Peer Address:Port              LISTEN      0      128     *:22                  *:*                  LISTEN      0      100    127.0.0.1:25                  *:*                  LISTEN      0      128    :::22                 :::*                  LISTEN      0      100       ::1:25                 :::*                  LISTEN      0      80     :::3306               :::*                  </code></pre><h5 id="配置并启动主从复制"><a href="#配置并启动主从复制" class="headerlink" title="配置并启动主从复制"></a>配置并启动主从复制</h5><pre><code>mysql&gt; change master to    -&gt; master_host=&apos;192.168.0.1&apos;,    -&gt; master_user=&apos;repl&apos;,    -&gt; master_password=&apos;123456&apos;,    -&gt; master_log_file=&apos;mysql-bin.000001&apos;,    -&gt; master_log_pos=154;Query OK, 0 rows affected, 2 warnings (0.28 sec)</code></pre><h5 id="查看从服务器状态"><a href="#查看从服务器状态" class="headerlink" title="查看从服务器状态"></a>查看从服务器状态</h5><pre><code>mysql&gt; show slave status\G;*************************** 1. row ***************************               Slave_IO_State: Waiting for master to send event                  Master_Host: 192.168.0.1                  Master_User: repl                  Master_Port: 3306                Connect_Retry: 60              Master_Log_File: mysql-bin.000001          Read_Master_Log_Pos: 154               Relay_Log_File: mysql-relay-bin.000003                Relay_Log_Pos: 320        Relay_Master_Log_File: mysql-bin.000001             Slave_IO_Running: Yes                                     //此处必须是yes            Slave_SQL_Running: Yes                                    //此处必须是yes                     Replicate_Do_DB:          Replicate_Ignore_DB:           Replicate_Do_Table:       Replicate_Ignore_Table:      Replicate_Wild_Do_Table:  Replicate_Wild_Ignore_Table:                   Last_Errno: 0                   Last_Error:                 Skip_Counter: 0          Exec_Master_Log_Pos: 154              Relay_Log_Space: 527              Until_Condition: None               Until_Log_File:                Until_Log_Pos: 0           Master_SSL_Allowed: No           Master_SSL_CA_File:           Master_SSL_CA_Path:              Master_SSL_Cert:            Master_SSL_Cipher:               Master_SSL_Key:        Seconds_Behind_Master: 0Master_SSL_Verify_Server_Cert: No                Last_IO_Errno: 0                Last_IO_Error:               Last_SQL_Errno: 0               Last_SQL_Error:  Replicate_Ignore_Server_Ids:             Master_Server_Id: 1                  Master_UUID: 5abf1791-b2af-11e8-b6ad-000c2980fbb4             Master_Info_File: /opt/data/master.info                    SQL_Delay: 0          SQL_Remaining_Delay: NULL      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates           Master_Retry_Count: 86400                  Master_Bind:      Last_IO_Error_Timestamp:     Last_SQL_Error_Timestamp:               Master_SSL_Crl:           Master_SSL_Crlpath:           Retrieved_Gtid_Set:            Executed_Gtid_Set:                Auto_Position: 0         Replicate_Rewrite_DB:                 Channel_Name:           Master_TLS_Version:1 row in set (0.00 sec)ERROR:No query specified</code></pre><h5 id="测试验证在主服务器的yan库的tom表插入数据"><a href="#测试验证在主服务器的yan库的tom表插入数据" class="headerlink" title="测试验证在主服务器的yan库的tom表插入数据:"></a>测试验证在主服务器的yan库的tom表插入数据:</h5><pre><code>mysql&gt; use yan;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; select * from tom;+----+-----------+------+| id | name      | age  |+----+-----------+------+|  1 | zhangshan |   20 ||  2 | wangwu    |    7 ||  3 | lisi      |   23 |+----+-----------+------+3 rows in set (0.09 sec)mysql&gt; insert tom(id,name,age) value (4,&quot;yyl&quot;,18);Query OK, 1 row affected (0.14 sec)mysql&gt; select * from tom;+----+-----------+------+| id | name      | age  |+----+-----------+------+|  1 | zhangshan |   20 ||  2 | wangwu    |    7 ||  3 | lisi      |   23 ||  4 | yyl       |   18 |+----+-----------+------+4 rows in set (0.00 sec)</code></pre><h5 id="在从数据库查看是否数据同步"><a href="#在从数据库查看是否数据同步" class="headerlink" title="在从数据库查看是否数据同步"></a>在从数据库查看是否数据同步</h5><pre><code>mysql&gt; use yan;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; select * from tom;+----+-----------+------+| id | name      | age  |+----+-----------+------+|  1 | zhangshan |   20 ||  2 | wangwu    |    7 ||  3 | lisi      |   23 ||  4 | yyl       |   18 |+----+-----------+------+4 rows in set (0.00 sec)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;主从&quot;&gt;&lt;a href=&quot;#主从&quot; class=&quot;headerlink&quot; title=&quot;主从&quot;&gt;&lt;/a&gt;主从&lt;/h3&gt;&lt;p&gt;Mysql主从又叫Replication、AB复制(不同于PXC)。简单讲就是A与B两台机器做主从后，在A上写数据，另外一台B也会跟着写数据，实现数据实时同步&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mysql主从是基于binlog，主上需开启binlog才能进行主从&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;主从过程大概有3个步骤&quot;&gt;&lt;a href=&quot;#主从过程大概有3个步骤&quot; class=&quot;headerlink&quot; title=&quot;主从过程大概有3个步骤&quot;&gt;&lt;/a&gt;主从过程大概有3个步骤&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;主将更改操作记录到binlog里&lt;/li&gt;
&lt;li&gt;从将主的binlog事件（sql语句） 同步本机上并记录在relaylog里&lt;/li&gt;
&lt;li&gt;从根据relaylog里面的sql语句按顺序执行&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="MySQL" scheme="https://icocos.github.io/tags/MySQL/"/>
    
      <category term="主从复制" scheme="https://icocos.github.io/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>MySQL锁机制和PHP锁机制</title>
    <link href="https://icocos.github.io/2019/06/06/MySQL%E9%94%81%E6%9C%BA%E5%88%B6%E5%92%8CPHP%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>https://icocos.github.io/2019/06/06/MySQL锁机制和PHP锁机制/</id>
    <published>2019-06-06T10:47:41.000Z</published>
    <updated>2019-05-27T02:39:08.392Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PHP中的文件锁-（锁的是文件，不是表）"><a href="#PHP中的文件锁-（锁的是文件，不是表）" class="headerlink" title="PHP中的文件锁 （锁的是文件，不是表）"></a>PHP中的文件锁 （锁的是文件，不是表）</h3><p>文件锁的文件与表有什么关系？：一点关系也没有，与令牌相似，谁拿到谁操作。所以表根本没锁。<br>测试时，有个文件就行，叫什么名无所谓</p><p>bool flock ( int handle, int operation [, int &amp;wouldblock] );<br>flock() 操作的 handle 必须是一个已经打开的文件指针。operation 可以是以下值之一：</p><ul><li>要取得共享锁定（读取程序），将 operation 设为 LOCK_SH（PHP 4.0.1 以前的版本设置为 1）</li><li>要取得独占锁定（写入程序），将 operation 设为 LOCK_EX（PHP 4.0.1 以前的版本中设置为 2）</li><li>要释放锁定（无论共享或独占），将 operation 设为 LOCK_UN（PHP 4.0.1 以前的版本中设置为 3）</li><li>如果你不希望 flock() 在锁定时堵塞，则给 operation 加上 LOCK_NB（PHP 4.0.1 以前的版本中设置为4）</li></ul><a id="more"></a><h4 id="建两个文件"><a href="#建两个文件" class="headerlink" title="建两个文件"></a>建两个文件</h4><!--more--><h5 id="1-a-php"><a href="#1-a-php" class="headerlink" title="(1) a.php"></a>(1) a.php</h5><pre><code>$file = &quot;temp.txt&quot;;   $fp = fopen($file , &apos;w&apos;);   if(flock($fp , LOCK_EX)){        fwrite($fp , &quot;abc\n&quot;);        sleep(10);        fwrite($fp , &quot;123\n&quot;);       flock($fp , LOCK_UN);   }   fclose($fp);  </code></pre><h5 id="2-b-php"><a href="#2-b-php" class="headerlink" title="(2) b.php"></a>(2) b.php</h5><pre><code>$file = &quot;temp.txt&quot;;   $fp = fopen($file , &apos;r&apos;);   echo fread($fp , 100);   fclose($fp);  </code></pre><p>运行 a.php 后，马上运行 b.php ，可以看到输出：</p><pre><code>abc</code></pre><p>等 a.php 运行完后运行 b.php ，可以看到输出：</p><pre><code>abc123</code></pre><p>显然，当 a.php 写文件时数据太大，导致时间比较长时，这时 b.php 读取数据不完整</p><p>修改 b.php 为：</p><pre><code>$file = &quot;temp.txt&quot;;   $fp = fopen($file , &apos;r&apos;);   if(flock($fp , LOCK_EX)){       echo fread($fp , 100);       flock($fp , LOCK_UN);   } else{       echo &quot;Lock file failed...\n&quot;;   }   fclose($fp);  </code></pre><p>运行 a.php 后，马上运行 b.php ，可以发现 b.php 会等到 a.php 运行完成后(即 10 秒后)才显示：</p><pre><code>abc123</code></pre><p>读取数据完整，但时间过长，他要等待写锁释放。</p><p>修改 b.php 为：</p><pre><code>$file = &quot;temp.txt&quot;;   $fp = fopen($file , &apos;r&apos;);   if(flock($fp , LOCK_SH | LOCK_NB)){       echo fread($fp , 100);       flock($fp , LOCK_UN);   } else{       echo &quot;Lock file failed...\n&quot;;   }   fclose($fp);  </code></pre><p>运行 a.php 后，马上运行 b.php ，可以看到输出：<br>    Lock file failed…</p><p>证明可以返回锁文件失败状态，而不是向上面一样要等很久。</p><h5 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h5><blockquote><p>建议作文件缓存时，选好相关的锁，不然可能导致读取数据不完整，或重复写入数据。<br>file_get_contents 好像选择不了锁，不知道他默认用的什么锁，反正和不锁得到的输出一样，是不完整的数据。</p></blockquote><p>我是要做文件缓存，所以只需要知道是否有写锁存在即可，有的话就查数据库就可以了。<br>测试环境：Linux(Ubuntu 6) , PHP 5.1.2 , Apache 2</p><h5 id="再转："><a href="#再转：" class="headerlink" title="再转："></a>再转：</h5><p>文件锁有两种：共享锁和排他锁，也就是读锁(LOCK_SH)和写锁(LOCK_EX)<br>文件的锁一般这么使用：</p><pre><code>$fp = fopen(&quot;filename&quot;, &quot;a&quot;);   flock($fp, LOCK_SH) or die(&quot;lock error&quot;)   $str = fread($fp, 1024);   flock($fp, LOCK_UN);   fclose($fp);  </code></pre><blockquote><p>注意fwrite之后，文件立即就被更新了，而不是等fwrite然后fclose之后文件才会更新，这个可以通过在fwrite之后fclose之前读取这个文件进行检查 </p></blockquote><p>但是什么时候使用lock_ex什么时候使用lock_sh呢？ </p><h5 id="读的时候："><a href="#读的时候：" class="headerlink" title="读的时候："></a>读的时候：</h5><p>如果不想出现dirty数据，那么最好使用lock_sh共享锁。可以考虑以下三种情况： </p><ol><li>如果读的时候没有加共享锁，那么其他程序要写的话（不管这个写是加锁还是不加锁）都会立即写成功。如果正好读了一半，然后被其他程序给写了，那么读的后一半就有可能跟前一半对不上（前一半是修改前的，后一半是修改后的） </li><li>如果读的时候加上了共享锁（因为只是读，没有必要使用排他锁），这个时候，其他程序开始写，这个写程序没有使用锁，那么写程序会直接修改这个文件，也会导致前面一样的问题 </li><li>最理想的情况是，读的时候加锁(lock_sh),写的时候也进行加锁(lock_ex),这样写程序会等着读程序完成之后才进行操作，而不会出现贸然操作的情况 </li></ol><h5 id="写的时候："><a href="#写的时候：" class="headerlink" title="写的时候："></a>写的时候：</h5><p>如果多个写程序不加锁同时对文件进行操作，那么最后的数据有可能一部分是a程序写的，一部分是b程序写的<br>如果写的时候加锁了，这个时候有其他的程序来读，那么他会读到什么东西呢？ </p><ol><li>如果读程序没有申请共享锁，那么他会读到dirty的数据。比如写程序要写a,b,c三部分，写完a,这时候读读到的是a，继续写b，这时候读读到的是ab，然后写c，这时候读到的是abc. </li><li>如果读程序在之前申请了共享锁，那么读程序会等写程序将abc写完并释放锁之后才进行读。</li></ol><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>项目中应该只使用PHP中的文件锁，尽量避免锁表，因为如果表被锁定了，那么整个网站中所有和这个表相关的功能都被拖慢了（例如：前台很多用户一直下订单，商品表mysql锁表，其他与商品表相关的操作一直处于阻塞状态【读不出来商品表】，因为一个功能把整个网站速度拖慢）。</p><blockquote><p> 比如在一个O2O外卖项目中，中午12-2点，晚上6点都是订单高并发时，这种情况下，MySQL锁显然是不考虑的，用户体验太差。其实根据实际的需求，外卖可以不用设计库存量的，当然除了秒杀活动模块还是需要php文件锁的。</p></blockquote><p>应用场景：</p><ol><li>高并发下单时，减库存量时要加锁</li><li>高并发抢单、抢票时要使用</li></ol><p>MySQL锁示例代码：</p><pre><code>&lt;?php /**模拟秒杀活动-- 商品100件CREATE TABLE a(    id int comment &apos;模拟100件活动商品的数量&apos;);INSERT INTO a VALUES(100);模仿：以10的并发量访问这个脚本！    使用apache自带的ab.exe软件 */ error_reporting(0); mysql_connect(&apos;localhost&apos;,&apos;root&apos;,&apos;admin123&apos;); mysql_select_db(&apos;test&apos;); # mysql 锁 mysql_query(&apos;LOCK TABLE a WRITE&apos;);// 只有一个客户端可以锁定表，其他客户端阻塞在这 $rs = mysql_query(&apos;SELECT id FROM a&apos;); $id = mysql_result($rs, 0, 0); if($id &gt; 0) {     --$id;     mysql_query(&apos;UPDATE a SET id=&apos;.$id); } # mysql 解锁 mysql_query(&apos;UNLOCK TABLES&apos;);</code></pre><p>PHP文件锁示例代码：</p><pre><code>&lt;?php /**模拟秒杀活动-- 商品100件CREATE TABLE a(    id int comment &apos;模拟100件活动商品的数量&apos;);INSERT INTO a VALUES(100);模仿：以10的并发量访问这个脚本！    使用apache自带的ab.exe软件 */ error_reporting(0); mysql_connect(&apos;localhost&apos;,&apos;root&apos;,&apos;admin123&apos;); mysql_select_db(&apos;test&apos;); # php中的文件锁 $fp = fopen(&apos;./a.lock&apos;, &apos;r&apos;); // php的文件锁和表没关系，随便一个文件即可 flock($fp, LOCK_EX);// 排他锁 $rs = mysql_query(&apos;SELECT id FROM a&apos;); $id = mysql_result($rs, 0, 0); if($id &gt; 0) {     --$id;     mysql_query(&apos;UPDATE a SET id=&apos;.$id); } # php的文件锁，释放锁 flock($fp, LOCK_UN); fclose($fp);</code></pre><h3 id="MYSQL中的锁："><a href="#MYSQL中的锁：" class="headerlink" title="MYSQL中的锁："></a>MYSQL中的锁：</h3><p>语法 ：<br>LOCK TABLE 表名1 READ|WRITE, 表名2 READ|WRITE ……………… 【锁表】<br>UNLOCK TABLES  【释放表】</p><ul><li>Read:读锁|共享锁 ： 所有的客户端只能读这个表不能写这个表</li><li>Write:写锁|排它锁： 所有当前锁定客户端可以操作这个表，其他客户端只能阻塞</li></ul><blockquote><p>注意：在锁表的过程中只能操作被锁定的表，如果要操作其他表，必须把所有要操作的表都锁定起来！</p></blockquote><h5 id="1-表级锁定（table-level）"><a href="#1-表级锁定（table-level）" class="headerlink" title="1.表级锁定（table-level）"></a>1.表级锁定（table-level）</h5><p>表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并大度大打折扣。使用表级锁定的主要是MyISAM等一些非事务性存储引擎。</p><h5 id="2-行级锁定（row-level）"><a href="#2-行级锁定（row-level）" class="headerlink" title="2.行级锁定（row-level）"></a>2.行级锁定（row-level）</h5><p>行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。<br>虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。使用行级锁定的主要是InnoDB存储引擎。</p><h5 id="3-页级锁定（page-level）"><a href="#3-页级锁定（page-level）" class="headerlink" title="3.页级锁定（page-level）"></a>3.页级锁定（page-level）</h5><p>页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。<br>在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。</p><h5 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h5><ul><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；  </li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；    </li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。  </li></ul><p>适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</p><h3 id="二、表级锁定"><a href="#二、表级锁定" class="headerlink" title="二、表级锁定"></a>二、表级锁定</h3><p>在mysql中，MyISAM引擎使用的锁定机制完全是mysql的表级锁定，下面将以MYISAM引擎作为示例</p><h5 id="1-MySQL表级锁的模式"><a href="#1-MySQL表级锁的模式" class="headerlink" title="1.MySQL表级锁的模式"></a>1.MySQL表级锁的模式</h5><blockquote><p>MySQL的表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。  </p></blockquote><ul><li>兼容性：  <ul><li>对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；  </li><li>对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；  </li><li>MyISAM表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。</li></ul></li></ul><h5 id="2-加锁"><a href="#2-加锁" class="headerlink" title="2.加锁"></a>2.加锁</h5><blockquote><p>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。</p></blockquote><h5 id="3-MyISAM锁的优化"><a href="#3-MyISAM锁的优化" class="headerlink" title="3.MyISAM锁的优化"></a>3.MyISAM锁的优化</h5><blockquote><p>对于MyISAM存储引擎，虽然使用表级锁定在锁定实现的过程中比实现行级锁定或者页级锁所带来的附加成本都要小，锁定本身所消耗的资源也是最少。但是由于锁定的颗粒度比较到，所以造成锁定资源的争用情况也会比其他的锁定级别都要多，从而在较大程度上会降低并发处理能力。所以，在优化MyISAM存储引擎锁定问题的时候，最关键的就是如何让其提高并发度。由于锁定级别是不可能改变的了，所以我们首先需要尽可能让锁定的时间变短，然后就是让可能并发进行的操作尽可能的并发。</p></blockquote><ul><li>（1）查询表锁争用情况</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like &apos;table%&apos;;</span><br><span class="line">+----------------------------+---------+</span><br><span class="line">| Variable_name              | Value   |</span><br><span class="line">+----------------------------+---------+</span><br><span class="line">| Table_locks_immediate      | 100     |</span><br><span class="line">| Table_locks_waited         | 11      |</span><br><span class="line">+----------------------------+---------+</span><br></pre></td></tr></table></figure><p>这里有两个状态变量记录MySQL内部表级锁定的情况，两个变量说明如下：</p><ul><li>Table_locks_immediate：产生表级锁定的次数;  </li><li>Table_locks_waited：出现表级锁定争用而发生等待的次数；</li></ul><p>两个状态值都是从系统启动后开始记录，出现一次对应的事件则数量加1。如果这里的Table_locks_waited状态值比较高，那么说明系统中表级锁定争用现象比较严重，就需要进一步分析为什么会有较多的锁定资源争用了</p><ul><li>（2）缩短锁定时间</li></ul><p>如何让锁定时间尽可能的短呢？唯一的办法就是让我们的Query执行时间尽可能的短。</p><pre><code>+ a)尽两减少大的复杂Query，将复杂Query分拆成几个小的Query分布进行；  + b)尽可能的建立足够高效的索引，让数据检索更迅速；  + c)尽量让MyISAM存储引擎的表只存放必要的信息，控制字段类型；  + d)利用合适的机会优化MyISAM表数据文件</code></pre><ul><li>(3)分离并行的操作</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;PHP中的文件锁-（锁的是文件，不是表）&quot;&gt;&lt;a href=&quot;#PHP中的文件锁-（锁的是文件，不是表）&quot; class=&quot;headerlink&quot; title=&quot;PHP中的文件锁 （锁的是文件，不是表）&quot;&gt;&lt;/a&gt;PHP中的文件锁 （锁的是文件，不是表）&lt;/h3&gt;&lt;p&gt;文件锁的文件与表有什么关系？：一点关系也没有，与令牌相似，谁拿到谁操作。所以表根本没锁。&lt;br&gt;测试时，有个文件就行，叫什么名无所谓&lt;/p&gt;
&lt;p&gt;bool flock ( int handle, int operation [, int &amp;amp;wouldblock] );&lt;br&gt;flock() 操作的 handle 必须是一个已经打开的文件指针。operation 可以是以下值之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要取得共享锁定（读取程序），将 operation 设为 LOCK_SH（PHP 4.0.1 以前的版本设置为 1）&lt;/li&gt;
&lt;li&gt;要取得独占锁定（写入程序），将 operation 设为 LOCK_EX（PHP 4.0.1 以前的版本中设置为 2）&lt;/li&gt;
&lt;li&gt;要释放锁定（无论共享或独占），将 operation 设为 LOCK_UN（PHP 4.0.1 以前的版本中设置为 3）&lt;/li&gt;
&lt;li&gt;如果你不希望 flock() 在锁定时堵塞，则给 operation 加上 LOCK_NB（PHP 4.0.1 以前的版本中设置为4）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>PHP-高并发和大流量的解决方案</title>
    <link href="https://icocos.github.io/2019/06/03/PHP-%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%A7%E6%B5%81%E9%87%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://icocos.github.io/2019/06/03/PHP-高并发和大流量的解决方案/</id>
    <published>2019-06-03T10:47:41.000Z</published>
    <updated>2019-05-22T09:17:16.637Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-高并发的概念"><a href="#一-高并发的概念" class="headerlink" title="一  高并发的概念"></a>一  高并发的概念</h3><p>在互联网时代，并发，高并发通常是指并发访问。也就是在某个时间点，有多少个访问同时到来。</p><h3 id="二-高并发架构相关概念"><a href="#二-高并发架构相关概念" class="headerlink" title="二  高并发架构相关概念"></a>二  高并发架构相关概念</h3><ul><li>1、QPS (每秒查询率) : 每秒钟请求或者查询的数量，在互联网领域，指每秒响应请求数(指HTTP请求)</li><li>2、PV（Page View）：综合浏览量，即页面浏览量或者点击量，一个访客在24小时内访问的页面数量</li></ul><blockquote><p>–注：同一个人浏览你的网站的同一页面，只记做一次pv</p></blockquote><ul><li>3、吞吐量（fetches/sec） ：单位时间内处理的请求数量 （通常由QPS和并发数决定）</li><li>4、响应时间：从请求发出到收到响应花费的时间</li><li>5、独立访客（UV）：一定时间范围内，相同访客多次访问网站，只计算为1个独立访客</li><li>6、带宽：计算带宽需关注两个指标，峰值流量和页面的平均大小</li><li>7、日网站带宽： PV/统计时间（换算到秒） <em> 平均页面大小（kb）</em> 8</li></ul><a id="more"></a><h3 id="三-需要注意点："><a href="#三-需要注意点：" class="headerlink" title="三 需要注意点："></a>三 需要注意点：</h3><ul><li>1、QPS不等于并发连接数（QPS是每秒HTTP请求数量，并发连接数是系统同时处理的请求数量）</li><li>2、峰值每秒请求数（QPS）= （总PV数<em>80%）/ （六小时秒数</em>20%）【代表80%的访问量都集中在20%的时间内】</li><li>3、压力测试： 测试能承受的最大并发数 以及测试最大承受的QPS值</li><li>4、常用的性能测试工具【ab，wrk，httpload，Web Bench，Siege，Apache JMeter】</li></ul><h3 id="四-优化"><a href="#四-优化" class="headerlink" title="四 优化"></a>四 优化</h3><h5 id="1、当QPS小于50时"><a href="#1、当QPS小于50时" class="headerlink" title="1、当QPS小于50时"></a>1、当QPS小于50时</h5><p>​    优化方案:为一般小型网站,不用考虑优化</p><h5 id="2、当QPS达到100时-遇到数据查询瓶颈"><a href="#2、当QPS达到100时-遇到数据查询瓶颈" class="headerlink" title="2、当QPS达到100时,遇到数据查询瓶颈"></a>2、当QPS达到100时,遇到数据查询瓶颈</h5><p>​    优化方案: 数据库缓存层,数据库的负载均衡</p><h5 id="3、当QPS达到800时-遇到带宽瓶颈"><a href="#3、当QPS达到800时-遇到带宽瓶颈" class="headerlink" title="3、当QPS达到800时, 遇到带宽瓶颈"></a>3、当QPS达到800时, 遇到带宽瓶颈</h5><p>​    优化方案:CDN加速,负载均衡</p><h5 id="4、当QPS达到1000时"><a href="#4、当QPS达到1000时" class="headerlink" title="4、当QPS达到1000时"></a>4、当QPS达到1000时</h5><p>​    优化方案: 做html静态缓存</p><h5 id="5、当QPS达到2000时"><a href="#5、当QPS达到2000时" class="headerlink" title="5、当QPS达到2000时"></a>5、当QPS达到2000时</h5><p>​    优化方案: 做业务分离,分布式存储</p><h3 id="五、高并发解决方案案例"><a href="#五、高并发解决方案案例" class="headerlink" title="五、高并发解决方案案例:"></a>五、高并发解决方案案例:</h3><h5 id="1、流量优化"><a href="#1、流量优化" class="headerlink" title="1、流量优化"></a>1、流量优化</h5><p>​    防盗链处理(去除恶意请求)</p><h5 id="2、前端优化"><a href="#2、前端优化" class="headerlink" title="2、前端优化"></a>2、前端优化</h5><ul><li>(1) 减少HTTP请求[将css,js等合并]</li><li>(2) 添加异步请求(先不将所有数据都展示给用户,用户触发某个事件,才会异步请求数据)</li><li>(3) 启用浏览器缓存和文件压缩</li><li>(4) CDN加速</li><li>(5) 建立独立的图片服务器(减少I/O)</li></ul><h5 id="3、服务端优化"><a href="#3、服务端优化" class="headerlink" title="3、服务端优化"></a>3、服务端优化</h5><ul><li>(1) 页面静态化</li><li>(2) 并发处理</li><li>(3) 队列处理</li></ul><h5 id="4、数据库优化"><a href="#4、数据库优化" class="headerlink" title="4、数据库优化"></a>4、数据库优化</h5><ul><li>(1) 数据库缓存</li><li>(2) 分库分表,分区</li><li>(3) 读写分离</li><li>(4) 负载均衡</li></ul><h5 id="5、web服务器优化"><a href="#5、web服务器优化" class="headerlink" title="5、web服务器优化"></a>5、web服务器优化</h5><ul><li><p>(1) nginx反向代理实现负载均衡</p></li><li><p>(2) lvs实现负载均衡</p></li></ul><h5 id="关于海亮数据"><a href="#关于海亮数据" class="headerlink" title="关于海亮数据"></a>关于海亮数据</h5><p>业务场景, 每天产生百万左右的日志,总量过亿, 准即时分析</p><ol><li>不需要使用复杂的技术栈, PHP本身即可处理, 时间也可接受</li><li>可简单使用多开CLI进程的方式,每个CLI对应一个日志源, 不需要引入多线程之类的技术, 适合日志源较固定的业务场景.</li><li>提前过滤不需要保留的日志,如:爬虫, 业务中无用的日志, 我的业务场景 中可过滤掉90%的无效 日志</li><li>事先确认分析需求, 只根据需求对日志进行分析.  此处详解</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.我使用第三方UA解析库对 UA进行分析,结果详细,但占用CPU过高,处理时间不理想</span><br><span class="line"></span><br><span class="line">b.根据业务需求,只分析是否爬虫以及操作系统(android,iOS,其它), 这样分析速度提升一个数量级</span><br></pre></td></tr></table></figure><ol start="5"><li>多种PHP技术并用: 本地文件缓存, 精细设计断点续操作, 批量插入数据库, 人性化的界面输出.</li><li>对异常进行分析, 有些异常使用简单的延时重试即可处理.</li><li>最重要的, 是要相信PHP, 如果有PHP不能实现的功能 , 那只是因为你的水平不够, 而不是PHP的问题. </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-高并发的概念&quot;&gt;&lt;a href=&quot;#一-高并发的概念&quot; class=&quot;headerlink&quot; title=&quot;一  高并发的概念&quot;&gt;&lt;/a&gt;一  高并发的概念&lt;/h3&gt;&lt;p&gt;在互联网时代，并发，高并发通常是指并发访问。也就是在某个时间点，有多少个访问同时到来。&lt;/p&gt;
&lt;h3 id=&quot;二-高并发架构相关概念&quot;&gt;&lt;a href=&quot;#二-高并发架构相关概念&quot; class=&quot;headerlink&quot; title=&quot;二  高并发架构相关概念&quot;&gt;&lt;/a&gt;二  高并发架构相关概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;1、QPS (每秒查询率) : 每秒钟请求或者查询的数量，在互联网领域，指每秒响应请求数(指HTTP请求)&lt;/li&gt;
&lt;li&gt;2、PV（Page View）：综合浏览量，即页面浏览量或者点击量，一个访客在24小时内访问的页面数量&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;–注：同一个人浏览你的网站的同一页面，只记做一次pv&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;3、吞吐量（fetches/sec） ：单位时间内处理的请求数量 （通常由QPS和并发数决定）&lt;/li&gt;
&lt;li&gt;4、响应时间：从请求发出到收到响应花费的时间&lt;/li&gt;
&lt;li&gt;5、独立访客（UV）：一定时间范围内，相同访客多次访问网站，只计算为1个独立访客&lt;/li&gt;
&lt;li&gt;6、带宽：计算带宽需关注两个指标，峰值流量和页面的平均大小&lt;/li&gt;
&lt;li&gt;7、日网站带宽： PV/统计时间（换算到秒） &lt;em&gt; 平均页面大小（kb）&lt;/em&gt; 8&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>PHP书籍汇总与推荐</title>
    <link href="https://icocos.github.io/2019/06/01/PHP%E4%B9%A6%E7%B1%8D%E6%B1%87%E6%80%BB%E4%B8%8E%E6%8E%A8%E8%8D%90/"/>
    <id>https://icocos.github.io/2019/06/01/PHP书籍汇总与推荐/</id>
    <published>2019-06-01T14:22:18.000Z</published>
    <updated>2019-05-30T03:02:52.484Z</updated>
    
    <content type="html"><![CDATA[<h5 id="先来推荐一波我最近在看，和准备看的书籍或者文档"><a href="#先来推荐一波我最近在看，和准备看的书籍或者文档" class="headerlink" title="先来推荐一波我最近在看，和准备看的书籍或者文档"></a>先来推荐一波我最近在看，和准备看的书籍或者文档</h5><p>首先作为一个PHP开发人员，官方手册是必看的，没看过或者说不看都不算一个合格的PHP程序员</p><a id="more"></a><ul><li><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2019/books/docs.png"></li></ul><h3 id="关于MySQL"><a href="#关于MySQL" class="headerlink" title="关于MySQL"></a>关于MySQL</h3><ul><li><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2019/books/mysql01.png"></p></li><li><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2019/books/mysql02.png"></p></li><li><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2019/books/mysql03.png"></p></li><li><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2019/books/mysql04.png"></p></li></ul><h3 id="关于PHP"><a href="#关于PHP" class="headerlink" title="关于PHP"></a>关于PHP</h3><ul><li><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2019/books/php01.png"></li></ul><h3 id="关于实战优化"><a href="#关于实战优化" class="headerlink" title="关于实战优化"></a>关于实战优化</h3><ul><li><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2019/books/php02.png"></p></li><li><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2019/books/php03.png"></p></li></ul><h3 id="PHP底层原理"><a href="#PHP底层原理" class="headerlink" title="PHP底层原理"></a>PHP底层原理</h3><ul><li><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2019/books/tipi.png"></li></ul><h5 id="【初阶】（基础知识及入门）"><a href="#【初阶】（基础知识及入门）" class="headerlink" title="【初阶】（基础知识及入门）"></a>【初阶】（基础知识及入门）</h5><ol><li>《PHP与MySQL程序设计（第4版）》  <a href="http://item.jd.com/10701892.html" target="_blank" rel="noopener">http://item.jd.com/10701892.html</a></li><li>《深入浅出MySQL 数据库开发 优化与管理维护 第2版》 <a href="http://item.jd.com/11381295.html" target="_blank" rel="noopener">http://item.jd.com/11381295.html</a> </li><li>《实战Nginx：取代Apache的高性能Web服务器》 <a href="http://dwz.cn/2K1ryn" target="_blank" rel="noopener">http://dwz.cn/2K1ryn</a> </li><li>《Redis 实战》 <a href="http://item.jd.com/11791607.html" target="_blank" rel="noopener">http://item.jd.com/11791607.html</a> </li><li>《MongoDB权威指南 第2版》 <a href="http://item.jd.com/11384782.html" target="_blank" rel="noopener">http://item.jd.com/11384782.html</a></li><li>《Linux系统命令及Shell脚本实践指南》 <a href="http://item.jd.com/11354663.html" target="_blank" rel="noopener">http://item.jd.com/11354663.html</a></li></ol><!--more--><h5 id="【中阶】（基本系统知识相关，可阅读类似书籍）"><a href="#【中阶】（基本系统知识相关，可阅读类似书籍）" class="headerlink" title="【中阶】（基本系统知识相关，可阅读类似书籍）"></a>【中阶】（基本系统知识相关，可阅读类似书籍）</h5><ol><li>《图解HTTP》 <a href="http://item.jd.com/11449491.html" target="_blank" rel="noopener">http://item.jd.com/11449491.html</a></li><li>《图解TCP/IP 第5版》 <a href="http://item.jd.com/11253710.html" target="_blank" rel="noopener">http://item.jd.com/11253710.html</a></li><li>《大话设计模式》 <a href="http://item.jd.com/10079261.html" target="_blank" rel="noopener">http://item.jd.com/10079261.html</a></li><li>《大话数据结构》 <a href="http://item.jd.com/10663703.html" target="_blank" rel="noopener">http://item.jd.com/10663703.html</a></li><li>《编译原理（第2版）》 <a href="http://item.jd.com/10058776.html" target="_blank" rel="noopener">http://item.jd.com/10058776.html</a></li><li>《Linux C 编程一站式学习》 <a href="http://dwz.cn/2K1C3n" target="_blank" rel="noopener">http://dwz.cn/2K1C3n</a> </li><li>《PHP应用程序安全编程》 <a href="http://dwz.cn/2K317p" target="_blank" rel="noopener">http://dwz.cn/2K317p</a></li><li>《高性能PHP应用开发》  <a href="http://dwz.cn/2K1kcy" target="_blank" rel="noopener">http://dwz.cn/2K1kcy</a> </li><li>《PHP核心技术与最佳实践》 <a href="http://item.jd.com/11123177.html" target="_blank" rel="noopener">http://item.jd.com/11123177.html</a></li><li>《高性能MySQL（第3版）》 <a href="http://item.jd.com/11220393.html" target="_blank" rel="noopener">http://item.jd.com/11220393.html</a></li><li>《深入理解MariaDB与MySQL》  <a href="http://item.jd.com/11835700.html" target="_blank" rel="noopener">http://item.jd.com/11835700.html</a></li><li>《构建高可用Linux服务器（第3版）》 <a href="http://item.jd.com/11557939.html" target="_blank" rel="noopener">http://item.jd.com/11557939.html</a></li></ol><h5 id="【中高阶】（深入理解系统）"><a href="#【中高阶】（深入理解系统）" class="headerlink" title="【中高阶】（深入理解系统）"></a>【中高阶】（深入理解系统）</h5><ol><li>《深入理解计算机系统（原书第2版）》 <a href="http://item.jd.com/10360906.html" target="_blank" rel="noopener">http://item.jd.com/10360906.html</a></li><li>《现代操作系统（原书第3版）》  <a href="http://item.jd.com/10058893.html" target="_blank" rel="noopener">http://item.jd.com/10058893.html</a></li><li>《数据库系统概念（原书第6版）》 <a href="http://item.jd.com/10954261.html" target="_blank" rel="noopener">http://item.jd.com/10954261.html</a></li><li>《数据库系统实现（第2版）》 <a href="http://item.jd.com/10060181.html" target="_blank" rel="noopener">http://item.jd.com/10060181.html</a></li><li>《UNIX环境高级编程（第3版）》 <a href="http://item.jd.com/11469694.html" target="_blank" rel="noopener">http://item.jd.com/11469694.html</a></li><li>《UNIX网络编程 卷1 套接字联网API（第3版）》 <a href="http://item.jd.com/11728741.html" target="_blank" rel="noopener">http://item.jd.com/11728741.html</a></li><li>《Linux高性能服务器编程》 <a href="http://item.jd.com/11252777.html" target="_blank" rel="noopener">http://item.jd.com/11252777.html</a></li></ol><h5 id="【高阶】（深入理解服务原理）"><a href="#【高阶】（深入理解服务原理）" class="headerlink" title="【高阶】（深入理解服务原理）"></a>【高阶】（深入理解服务原理）</h5><ol><li>《深入理解PHP内核》 <a href="http://www.php-internals.com/book/" target="_blank" rel="noopener">http://www.php-internals.com/book/</a></li><li>《深入理解MySQL》 <a href="http://item.jd.com/10063042.html" target="_blank" rel="noopener">http://item.jd.com/10063042.html</a></li><li>《MySQL技术内幕：InnoDB存储引擎（第2版）》 <a href="http://item.jd.com/11252326.html" target="_blank" rel="noopener">http://item.jd.com/11252326.html</a> </li><li>《深入剖析Nginx》 <a href="http://item.jd.com/11226514.html" target="_blank" rel="noopener">http://item.jd.com/11226514.html</a></li><li>《深入理解Nginx：模块开发与架构解析》 <a href="http://item.jd.com/11217076.html" target="_blank" rel="noopener">http://item.jd.com/11217076.html</a> </li><li>《Redis设计与实现》 <a href="http://item.jd.com/11486101.html" target="_blank" rel="noopener">http://item.jd.com/11486101.html</a></li></ol><h5 id="【架构及升级】（Web架构、分布式、云计算、机器学习等方向）"><a href="#【架构及升级】（Web架构、分布式、云计算、机器学习等方向）" class="headerlink" title="【架构及升级】（Web架构、分布式、云计算、机器学习等方向）"></a>【架构及升级】（Web架构、分布式、云计算、机器学习等方向）</h5><ol><li>《大规模Web服务开发技术》 <a href="http://dwz.cn/2K2o1d" target="_blank" rel="noopener">http://dwz.cn/2K2o1d</a></li><li>《大型分布式网站架构设计与实践》 <a href="http://item.jd.com/11529266.html" target="_blank" rel="noopener">http://item.jd.com/11529266.html</a> </li><li>《大型网站技术架构 核心原理与案例分析》 <a href="http://item.jd.com/11322972.html" target="_blank" rel="noopener">http://item.jd.com/11322972.html</a></li><li>《大规模分布式系统架构与设计实战》 <a href="http://item.jd.com/11417660.html" target="_blank" rel="noopener">http://item.jd.com/11417660.html</a></li><li>《大规模分布式存储系统：原理解析与架构实战》 <a href="http://item.jd.com/11310547.html" target="_blank" rel="noopener">http://item.jd.com/11310547.html</a></li><li>《分布式系统：概念与设计（原书第5版）》 <a href="http://item.jd.com/11194499.html" target="_blank" rel="noopener">http://item.jd.com/11194499.html</a></li><li>《Hadoop权威指南（第3版 修订版）》 <a href="http://item.jd.com/11566298.html" target="_blank" rel="noopener">http://item.jd.com/11566298.html</a> </li><li><p>《Cassandra权威指南》 <a href="http://item.jd.com/10794341.html" target="_blank" rel="noopener">http://item.jd.com/10794341.html</a></p></li><li><p>《云计算架构技术与实践》 <a href="http://item.jd.com/11537731.html" target="_blank" rel="noopener">http://item.jd.com/11537731.html</a></p></li><li><p>《OpenStack开源云王者归来》 <a href="http://item.jd.com/11521443.html" target="_blank" rel="noopener">http://item.jd.com/11521443.html</a></p></li><li><p>《数据挖掘 概念与技术（原书第3版）》 <a href="http://item.jd.com/11056660.html" target="_blank" rel="noopener">http://item.jd.com/11056660.html</a> </p></li><li>《机器学习》 <a href="http://item.jd.com/10131321.html" target="_blank" rel="noopener">http://item.jd.com/10131321.html</a></li><li>《图解机器学习》 <a href="http://item.jd.com/11676112.html" target="_blank" rel="noopener">http://item.jd.com/11676112.html</a></li><li>《机器学习实战》 <a href="http://item.jd.com/11242112.html" target="_blank" rel="noopener">http://item.jd.com/11242112.html</a></li></ol><h5 id="【番外篇】（可以参考延展学习）"><a href="#【番外篇】（可以参考延展学习）" class="headerlink" title="【番外篇】（可以参考延展学习）"></a>【番外篇】（可以参考延展学习）</h5><ol><li>《深入PHP：面向对象、模式与实践（第3版）》 <a href="http://item.jd.com/10794350.html" target="_blank" rel="noopener">http://item.jd.com/10794350.html</a></li><li>《Linux网络编程（第2版）》 <a href="http://item.jd.com/11397772.html" target="_blank" rel="noopener">http://item.jd.com/11397772.html</a></li><li>《Linux多线程服务端编程 使用muduo C++网络库》 <a href="http://item.jd.com/11163782.html" target="_blank" rel="noopener">http://item.jd.com/11163782.html</a></li><li>《Linux运维之道》 <a href="http://item.jd.com/11375254.html" target="_blank" rel="noopener">http://item.jd.com/11375254.html</a></li><li>《Linux性能优化大师》 <a href="http://item.jd.com/11734651.html" target="_blank" rel="noopener">http://item.jd.com/11734651.html</a></li><li>《PostgreSQL修炼之道：从小工到专家》 <a href="http://item.jd.com/11684063.html" target="_blank" rel="noopener">http://item.jd.com/11684063.html</a> </li><li><p>《图解网络硬件》 <a href="http://item.jd.com/11506709.html" target="_blank" rel="noopener">http://item.jd.com/11506709.html</a> </p></li><li><p>《网络安全基础：网络攻防、协议与安全》 <a href="http://item.jd.com/10550797.html" target="_blank" rel="noopener">http://item.jd.com/10550797.html</a></p></li><li>《密码学原理与实践（第3版）》 <a href="http://item.jd.com/10067358.html" target="_blank" rel="noopener">http://item.jd.com/10067358.html</a></li><li>《黑客大曝光：网络安全机密与解决方案（第7版）》 <a href="http://item.jd.com/11307435.html" target="_blank" rel="noopener">http://item.jd.com/11307435.html</a></li><li><p>《黑客攻防技术宝典 Web实战篇 第2版》 <a href="http://item.jd.com/11020022.html" target="_blank" rel="noopener">http://item.jd.com/11020022.html</a></p></li><li><p>《精通正则表达式（第3版）》 <a href="http://item.jd.com/11070361.html" target="_blank" rel="noopener">http://item.jd.com/11070361.html</a></p></li><li>《Go语言编程》 <a href="http://item.jd.com/11067810.html" target="_blank" rel="noopener">http://item.jd.com/11067810.html</a></li><li>《Python基础教程（第2版 修订版）》 <a href="http://item.jd.com/11461683.html" target="_blank" rel="noopener">http://item.jd.com/11461683.html</a></li><li>《快学Scala》 <a href="http://item.jd.com/11113845.html" target="_blank" rel="noopener">http://item.jd.com/11113845.html</a></li><li>《Erlang/OTP并发编程实战》 <a href="http://item.jd.com/11037265.html" target="_blank" rel="noopener">http://item.jd.com/11037265.html</a></li><li>《函数式编程思维》 <a href="http://item.jd.com/11763847.html" target="_blank" rel="noopener">http://item.jd.com/11763847.html</a></li><li>《Android从入门到精通》 <a href="http://item.jd.com/11078112.html" target="_blank" rel="noopener">http://item.jd.com/11078112.html</a></li><li><p>《iOS开发指南》 <a href="http://item.jd.com/11681585.html" target="_blank" rel="noopener">http://item.jd.com/11681585.html</a></p></li><li><p>《搜索引擎：信息检索实践》 <a href="http://item.jd.com/10059723.html" target="_blank" rel="noopener">http://item.jd.com/10059723.html</a></p></li><li>《统计自然语言处理（第2版）》 <a href="http://item.jd.com/11314362.html" target="_blank" rel="noopener">http://item.jd.com/11314362.html</a></li><li>《这就是搜索引擎：核心技术详解》 <a href="http://item.jd.com/10893803.html" target="_blank" rel="noopener">http://item.jd.com/10893803.html</a></li><li>《Elasticsearch服务器开发（第2版）》 <a href="http://item.jd.com/11615450.html" target="_blank" rel="noopener">http://item.jd.com/11615450.html</a></li><li><p>《实战Elasticsearch、Logstash、Kibana》 <a href="http://item.jd.com/11706768.html" target="_blank" rel="noopener">http://item.jd.com/11706768.html</a></p></li><li><p>《推荐系统实践》 <a href="http://item.jd.com/11007625.html" target="_blank" rel="noopener">http://item.jd.com/11007625.html</a></p></li><li>《机器学习实践指南：案例应用解析》 <a href="http://item.jd.com/11447036.html" target="_blank" rel="noopener">http://item.jd.com/11447036.html</a> </li><li>《Hadoop实战（第2版）》 <a href="http://item.jd.com/11116710.html" target="_blank" rel="noopener">http://item.jd.com/11116710.html</a></li><li>《Hadoop大数据分析与挖掘实战》 <a href="http://item.jd.com/11837003.html" target="_blank" rel="noopener">http://item.jd.com/11837003.html</a></li><li>《Spark大数据处理：技术、应用与性能优化》 <a href="http://item.jd.com/11577088.html" target="_blank" rel="noopener">http://item.jd.com/11577088.html</a></li><li>《Spark机器学习》 <a href="http://item.jd.com/11763016.html" target="_blank" rel="noopener">http://item.jd.com/11763016.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;先来推荐一波我最近在看，和准备看的书籍或者文档&quot;&gt;&lt;a href=&quot;#先来推荐一波我最近在看，和准备看的书籍或者文档&quot; class=&quot;headerlink&quot; title=&quot;先来推荐一波我最近在看，和准备看的书籍或者文档&quot;&gt;&lt;/a&gt;先来推荐一波我最近在看，和准备看的书籍或者文档&lt;/h5&gt;&lt;p&gt;首先作为一个PHP开发人员，官方手册是必看的，没看过或者说不看都不算一个合格的PHP程序员&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="PHP面试题" scheme="https://icocos.github.io/tags/PHP%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>PHP闭包（Closure）初探</title>
    <link href="https://icocos.github.io/2019/05/24/PHP%E9%97%AD%E5%8C%85%EF%BC%88Closure%EF%BC%89%E5%88%9D%E6%8E%A2/"/>
    <id>https://icocos.github.io/2019/05/24/PHP闭包（Closure）初探/</id>
    <published>2019-05-24T10:47:41.000Z</published>
    <updated>2019-05-22T09:17:17.657Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉发现PHP已经出到了5.5版本，而自己一直在用PHP5.2，让我看起来像深山出来的小伙子一样，又土又落后。在我习惯在javascript中使用闭包之后，忽然间对PHP的闭包打起了兴趣。</p><blockquote><p>于是乎在网上下了个WAMP集成开发环境，是PHP5.3版本的（PHP5.3开始引入了闭包的特性），不得不说WAMP安装使用真的很方便。简单配置了一下，开始动手。</p></blockquote><a id="more"></a><h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><p>提到闭包就不得不想起匿名函数，也叫闭包函数（closures），貌似PHP闭包实现主要就是靠它。声明一个匿名函数是这样：</p><pre><code>$func = function() {}; //带结束符</code></pre><p>可以看到，匿名函数因为没有名字，如果要使用它，需要将其返回给一个变量。匿名函数也像普通函数一样可以声明参数，调用方法也相同：</p><p>​<br>    $func = function( $param ) {<br>        echo $param;<br>    };</p><pre><code>$func( &apos;some string&apos; );//输出：//some string</code></pre><p>顺便提一下，PHP在引入闭包之前，也有一个可以创建匿名函数的函数：create function，但是代码逻辑只能写成字符串，这样看起来很晦涩并且不好维护，所以很少有人用。</p><h5 id="实现闭包"><a href="#实现闭包" class="headerlink" title="实现闭包"></a>实现闭包</h5><p>将匿名函数在普通函数中当做参数传入，也可以被返回。这就实现了一个简单的闭包。</p><p>下边有三个例子</p><h6 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h6><pre><code>//在函数里定义一个匿名函数，并且调用它function printStr() {    $func = function( $str ) {        echo $str;    };    $func( &apos;some string&apos; );}printStr();</code></pre><h6 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h6><pre><code>//在函数中把匿名函数返回，并且调用它function getPrintStrFunc() {    $func = function( $str ) {        echo $str;    };    return $func;}$printStrFunc = getPrintStrFunc();$printStrFunc( &apos;some string&apos; );</code></pre><h6 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h6><pre><code>//把匿名函数当做参数传递，并且调用它function callFunc( $func ) {    $func( &apos;some string&apos; );}$printStrFunc = function( $str ) {    echo $str;};callFunc( $printStrFunc );//也可以直接将匿名函数进行传递。如果你了解js，这种写法可能会很熟悉callFunc( function( $str ) {    echo $str;} );</code></pre><blockquote><p>连接闭包和外界变量的关键字：USE</p></blockquote><p>闭包可以保存所在代码块上下文的一些变量和值。PHP在默认情况下，匿名函数不能调用所在代码块的上下文变量，而需要通过使用use关键字。</p><pre><code>function getMoney() {    $rmb = 1;    $dollar = 6;    $func = function() use ( $rmb ) {        echo $rmb;        echo $dollar;    };    $func();}getMoney();//输出：//1//报错，找不到dorllar变量</code></pre><p>可以看到，dollar没有在use关键字中声明，在这个匿名函数里也就不能获取到它，所以开发中要注意这个问题。</p><p>有人可能会想到，是否可以在匿名函数中改变上下文的变量，但我发现是不可以的：</p><pre><code>function getMoney() {    $rmb = 1;    $func = function() use ( $rmb ) {        echo $rmb;        //把$rmb的值加1        $rmb++;    };    $func();    echo $rmb;}getMoney();//输出：//1//1</code></pre><p>啊，原来use所引用的也只不过是变量的一个副本而已。但是我想要完全引用变量，而不是复制。</p><p>要达到这种效果，其实在变量前加一个 &amp; 符号就可以了：</p><pre><code>function getMoney() {    $rmb = 1;    $func = function() use ( &amp;$rmb ) {        echo $rmb;        //把$rmb的值加1        $rmb++;    };    $func();    echo $rmb;}getMoney();//输出：//1//2</code></pre><p>好，这样匿名函数就可以引用上下文的变量了。如果将匿名函数返回给外界，匿名函数会保存use所引用的变量，而外界则不能得到这些变量，这样形成‘闭包’这个概念可能会更清晰一些。</p><pre><code>function getMoneyFunc() {    $rmb = 1;    $func = function() use ( &amp;$rmb ) {        echo $rmb;        //把$rmb的值加1        $rmb++;    };    return $func;}$getMoney = getMoneyFunc();$getMoney();$getMoney();$getMoney();//输出：//1//2//3</code></pre><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote><p>PHP闭包的特性并没有太大惊喜，其实用CLASS就可以实现类似甚至强大得多的功能，更不能和js的闭包相提并论，只能期待PHP以后对闭包支持的改进。不过匿名函数还是挺有用的，比如在使用preg_replace_callback等之类的函数可以不用在外部声明回调函数了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知不觉发现PHP已经出到了5.5版本，而自己一直在用PHP5.2，让我看起来像深山出来的小伙子一样，又土又落后。在我习惯在javascript中使用闭包之后，忽然间对PHP的闭包打起了兴趣。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;于是乎在网上下了个WAMP集成开发环境，是PHP5.3版本的（PHP5.3开始引入了闭包的特性），不得不说WAMP安装使用真的很方便。简单配置了一下，开始动手。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>MySQL两种存储引擎- MyISAM和InnoDB 简单总结</title>
    <link href="https://icocos.github.io/2019/05/03/MySQL%E4%B8%A4%E7%A7%8D%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%20MyISAM%E5%92%8CInnoDB%20%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <id>https://icocos.github.io/2019/05/03/MySQL两种存储引擎- MyISAM和InnoDB 简单总结/</id>
    <published>2019-05-03T10:47:41.000Z</published>
    <updated>2019-05-22T09:17:26.545Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>MyISAM是MySQL的默认数据库引擎（5.5版之前），由早期的ISAM（Indexed Sequential Access Method：有索引的顺序访问方法）所改良。虽然性能极佳，但却有一个缺点：不支持事务处理（transaction）。不过，在这几年的发展下，MySQL也导入了InnoDB（另一种数据库引擎），以强化参考完整性与并发违规处理机制，后来就逐渐取代MyISAM。</p></li><li><p>InnoDB，是MySQL的数据库引擎之一，为MySQL AB发布binary的标准之一。InnoDB由Innobase Oy公司所开发，2006年五月时由甲骨文公司并购。与传统的ISAM与MyISAM相比，InnoDB的最大特色就是支持了ACID兼容的事务（Transaction）功能，类似于PostgreSQL。目前InnoDB采用双轨制授权，一是GPL授权，另一是专有软件授权。</p></li></ul><a id="more"></a><p>MyISAM和InnoDB两者之间有着明显区别，简单梳理如下:</p><h5 id="1-事务支持"><a href="#1-事务支持" class="headerlink" title="1) 事务支持"></a>1) 事务支持</h5><p>MyISAM不支持事务，而InnoDB支持。InnoDB的AUTOCOMMIT默认是打开的，即每条SQL语句会默认被封装成一个事务，自动提交，这样会影响速度，所以最好是把多条SQL语句显示放在begin和commit之间，组成一个事务去提交。</p><p>MyISAM是非事务安全型的，而InnoDB是事务安全型的，默认开启自动提交，宜合并事务，一同提交，减小数据库多次提交导致的开销，大大提高性能。</p><h5 id="2-存储结构"><a href="#2-存储结构" class="headerlink" title="2) 存储结构"></a>2) 存储结构</h5><p>MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。</p><p>InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</p><h5 id="3-存储空间"><a href="#3-存储空间" class="headerlink" title="3) 存储空间"></a>3) 存储空间</h5><p>MyISAM：可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。</p><p>InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。</p><h5 id="4-可移植性、备份及恢复"><a href="#4-可移植性、备份及恢复" class="headerlink" title="4) 可移植性、备份及恢复"></a>4) 可移植性、备份及恢复</h5><p>MyISAM：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。</p><p>InnoDB：免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。</p><h5 id="5-事务支持"><a href="#5-事务支持" class="headerlink" title="5) 事务支持"></a>5) 事务支持</h5><p>MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。</p><p>InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</p><h5 id="6-AUTO-INCREMENT"><a href="#6-AUTO-INCREMENT" class="headerlink" title="6) AUTO_INCREMENT"></a>6) AUTO_INCREMENT</h5><p>MyISAM：可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。</p><p>InnoDB：InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。</p><h5 id="7-表锁差异"><a href="#7-表锁差异" class="headerlink" title="7) 表锁差异"></a>7) 表锁差异</h5><p>MyISAM：只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。</p><p>InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</p><p>MyISAM锁的粒度是表级，而InnoDB支持行级锁定。简单来说就是, InnoDB支持数据行锁定，而MyISAM不支持行锁定，只支持锁定整个表。即MyISAM同一个表上的读锁和写锁是互斥的，MyISAM并发读写时如果等待队列中既有读请求又有写请求，默认写请求的优先级高，即使读请求先到，所以MyISAM不适合于有大量查询和修改并存的情况，那样查询进程会长时间阻塞。因为MyISAM是锁表，所以某项读操作比较耗时会使其他写进程饿死。</p><h5 id="8-全文索引"><a href="#8-全文索引" class="headerlink" title="8) 全文索引"></a>8) 全文索引</h5><p>MyISAM：支持(FULLTEXT类型的)全文索引</p><p>InnoDB：不支持(FULLTEXT类型的)全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。</p><p>全文索引是指对char、varchar和text中的每个词（停用词除外）建立倒排序索引。MyISAM的全文索引其实没啥用，因为它不支持中文分词，必须由使用者分词后加入空格再写到数据表里，而且少于4个汉字的词会和停用词一样被忽略掉。</p><blockquote><p>另外，MyIsam索引和数据分离，InnoDB在一起，MyIsam天生非聚簇索引，最多有一个unique的性质，InnoDB的数据文件本身就是主键索引文件，这样的索引被称为“聚簇索引”</p></blockquote><h5 id="9-表主键"><a href="#9-表主键" class="headerlink" title="9) 表主键"></a>9) 表主键</h5><p>MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。</p><p>InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。InnoDB的主键范围更大，最大是MyISAM的2倍。</p><h5 id="10-表的具体行数"><a href="#10-表的具体行数" class="headerlink" title="10) 表的具体行数"></a>10) 表的具体行数</h5><p>MyISAM：保存有表的总行数，如果select count(*) from table;会直接取出出该值。</p><p>InnoDB：没有保存表的总行数(只能遍历)，如果使用select count(*) from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。</p><h5 id="11-CURD操作"><a href="#11-CURD操作" class="headerlink" title="11) CURD操作"></a>11) CURD操作</h5><p>MyISAM：如果执行大量的SELECT，MyISAM是更好的选择。</p><p>InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。</p><h5 id="12-外键"><a href="#12-外键" class="headerlink" title="12) 外键"></a>12) 外键</h5><p>MyISAM：不支持</p><p>InnoDB：支持</p><h5 id="13-查询效率"><a href="#13-查询效率" class="headerlink" title="13) 查询效率"></a>13) 查询效率</h5><p>没有where的count(<em>)使用MyISAM要比InnoDB快得多。因为MyISAM内置了一个计数器，count(</em>)时它直接从计数器中读，而InnoDB必须扫描全表。所以在InnoDB上执行count(<em>)时一般要伴随where，且where中要包含主键以外的索引列。为什么这里特别强调“主键以外”？因为InnoDB中primary index是和raw data存放在一起的，而secondary index则是单独存放，然后有个指针指向primary key。所以只是count(</em>)的话使用secondary index扫描更快，而primary key则主要在扫描索引同时要返回raw data时的作用较大。MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM。</p><p>通过上述的分析，基本上可以考虑使用InnoDB来替代MyISAM引擎了，原因是InnoDB自身很多良好的特点，比如事务支持、存储 过程、视图、行级锁定等等，在并发很多的情况下，相信InnoDB的表现肯定要比MyISAM强很多。另外，任何一种表都不是万能的，只用恰当的针对业务类型来选择合适的表类型，才能最大的发挥MySQL的性能优势。如果不是很复杂的Web应用，非关键应用，还是可以继续考虑MyISAM的，这个具体情况可以自己斟酌。</p><h3 id="MyISAM和InnoDB两者的应用场景："><a href="#MyISAM和InnoDB两者的应用场景：" class="headerlink" title="MyISAM和InnoDB两者的应用场景："></a>MyISAM和InnoDB两者的应用场景：</h3><ul><li><p>1) MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。</p></li><li><p>2) InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。</p></li></ul><p>但是实际场景中，针对具体问题需要具体分析，一般而言可以遵循以下几个问题：</p><ul><li>数据库是否有外键？</li><li>是否需要事务支持？</li><li>是否需要全文索引？</li><li>数据库经常使用什么样的查询模式？在写多读少的应用中还是Innodb插入性能更稳定，在并发情况下也能基本，如果是对读取速度要求比较快的应用还是选MyISAM。</li><li>数据库的数据有多大？ 大尺寸倾向于innodb，因为事务日志，故障恢复。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;MyISAM是MySQL的默认数据库引擎（5.5版之前），由早期的ISAM（Indexed Sequential Access Method：有索引的顺序访问方法）所改良。虽然性能极佳，但却有一个缺点：不支持事务处理（transaction）。不过，在这几年的发展下，MySQL也导入了InnoDB（另一种数据库引擎），以强化参考完整性与并发违规处理机制，后来就逐渐取代MyISAM。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;InnoDB，是MySQL的数据库引擎之一，为MySQL AB发布binary的标准之一。InnoDB由Innobase Oy公司所开发，2006年五月时由甲骨文公司并购。与传统的ISAM与MyISAM相比，InnoDB的最大特色就是支持了ACID兼容的事务（Transaction）功能，类似于PostgreSQL。目前InnoDB采用双轨制授权，一是GPL授权，另一是专有软件授权。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引优化策略与笔记</title>
    <link href="https://icocos.github.io/2019/04/29/MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5%E4%B8%8E%E7%AC%94%E8%AE%B0/"/>
    <id>https://icocos.github.io/2019/04/29/MySQL索引优化策略与笔记/</id>
    <published>2019-04-29T10:47:41.000Z</published>
    <updated>2019-05-27T02:33:41.460Z</updated>
    
    <content type="html"><![CDATA[<p>面试知识，数据库索引优化</p><h4 id="什么问题？"><a href="#什么问题？" class="headerlink" title="什么问题？"></a>什么问题？</h4><pre><code>索引有什么代价？哪些场景下你需要建索引？或者有时候反过来问，哪些场景下不推荐建索引。建好索引之后，怎么才能最高效地利用索引？或者反过来问，请说出一个无法有效利用已建索引的案例。</code></pre><h4 id="索引的好处？"><a href="#索引的好处？" class="headerlink" title="索引的好处？"></a>索引的好处？</h4><blockquote><p>快速查询数据。</p></blockquote><a id="more"></a><h4 id="代价是什么？"><a href="#代价是什么？" class="headerlink" title="代价是什么？"></a>代价是什么？</h4><pre><code>索引需要占硬盘空间，这是空间方面的代价。一旦插入新的数据，就需要重新建索引，这是时间上的代价。</code></pre><h4 id="不同场景，不同对待。"><a href="#不同场景，不同对待。" class="headerlink" title="不同场景，不同对待。"></a>不同场景，不同对待。</h4><h5 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h5><blockquote><p>数据表规模不大，就几千行，即使不建索引，查询语句的返回时间也不长，这时建索引的意义就不大。当然，若就几千行，索引所占的空间也不多，所以这种情况下，顶多属于“性价比”不高。</p></blockquote><h4 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h4><blockquote><p> 某个商品表里有几百万条商品信息，同时每天会在一个时间点，往其中更新大概十万条左右的商品信息，现在用where语句查询特定商品时（比如where name = ‘XXX’）速度很慢。为了提升查询效率可以建索引，但当每天更新数据时，又会重建索引，这是要耗费时间的。这时就需要综合考虑，甚至可以在更新前删除索引，更新后再重建。</p></blockquote><h4 id="场景三"><a href="#场景三" class="headerlink" title="场景三"></a>场景三</h4><blockquote><p>因为在数据表里ID值都不相同，所以索引能发挥出比较大的作用。相反，如果某个字段重复率很高，如性别字段，或者某个字段大多数值是空（null），那么不建议对该字段建索引。</p></blockquote><h3 id="建立索引原则"><a href="#建立索引原则" class="headerlink" title="建立索引原则"></a>建立索引原则</h3><p>一定是有业务需求了才会建索引。比如在一个商品表里，我们经常要根据name做查询，如果没有索引，查询速度会很慢，这时就需要建索引。但在项目开发中，如果不经常根据商品编号查询，那么就没必要对编号建索引。</p><p>最后再强调一次，建索引是要付出代价的，没事别乱建着玩，同时在一个表上也不能建太多的索引。<br>具体的例子来看索引的正确用法</p><pre><code>语句一：select name from 商品表。不会用到索引，因为没有where语句。语句二：select * from 商品表 where name = ‘Java书’，会用到索引，如果项目里经常用到name来查询，且商品表的数据量很大，而name值的重复率又不高，那么建议建索引。语句三：select * from 商品表 where name like ‘Java%’ 这是个模糊查询，会用到索引，请大家记住，用like进行模糊查询时，如果第一个就是模糊的匹配符，比如where name like ‘%java’，那么在查询时不会走索引。在其他情况下，不论用了多少个%，也不论%的位置，只要不出现在第一个位置，那么都能用到索引。</code></pre><p>学生成绩表里有两个字段：姓名和成绩。现在对成绩这个整数类型的字段建索引。</p><pre><code>第一种情况，当数字型字段遇到非等值操作符时，无法用到索引。比如：</code></pre><p>​ select name from 学生成绩表 where 成绩&gt;95 , 一旦出现大于符号，就不能用到索引，为了用到索引，我们应该改一下SQL语句里的where从句：where 成绩 in (96,97,98,99,100)</p><pre><code>第二种情况，如果对索引字段进行了某种左值操作，那么无法用到索引。</code></pre><p>​ 能用到索引的写法：select name from 学生成绩表 where 成绩 = 60</p><p>​ 不能用到索引的写法：select name from 学生成绩表 where 成绩+40 = 100</p><pre><code>第三种情况，如果对索引字段进行了函数操作，那么无法用到索引。</code></pre><p>​ 比如SQL语句：select * from 商品表 where substr(name) = ‘J’，我们希望查询商品名首字母是J的记录，可一旦针对name使用函数，即使name字段上有索引，也无法用到。<br>​ </p><blockquote><p>非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据。</p></blockquote><p>不管以任何方式查询表， 最终都会利用主键通过聚集索引来定位到数据， 聚集索引（主键）是通往真实数据所在的唯一路径。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试知识，数据库索引优化&lt;/p&gt;
&lt;h4 id=&quot;什么问题？&quot;&gt;&lt;a href=&quot;#什么问题？&quot; class=&quot;headerlink&quot; title=&quot;什么问题？&quot;&gt;&lt;/a&gt;什么问题？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;索引有什么代价？哪些场景下你需要建索引？或者有时候反过来问，哪些场景下不推荐建索引。
建好索引之后，怎么才能最高效地利用索引？或者反过来问，请说出一个无法有效利用已建索引的案例。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;索引的好处？&quot;&gt;&lt;a href=&quot;#索引的好处？&quot; class=&quot;headerlink&quot; title=&quot;索引的好处？&quot;&gt;&lt;/a&gt;索引的好处？&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;快速查询数据。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>如何处理负载、高并发问题</title>
    <link href="https://icocos.github.io/2019/04/27/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%B4%9F%E8%BD%BD%E3%80%81%E9%AB%98%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/"/>
    <id>https://icocos.github.io/2019/04/27/如何处理负载、高并发问题/</id>
    <published>2019-04-27T10:47:41.000Z</published>
    <updated>2019-05-22T09:07:52.595Z</updated>
    
    <content type="html"><![CDATA[<p>从低成本、高性能和高扩张性的角度来说有如下处理方案：</p><h5 id="1、HTML静态化"><a href="#1、HTML静态化" class="headerlink" title="1、HTML静态化"></a>1、HTML静态化</h5><p>其实大家都知道，效率最高、消耗最小的就是纯静态化的html页面，所以我们尽可能使我们的  网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。</p><h5 id="2、图片服务器分离"><a href="#2、图片服务器分离" class="headerlink" title="2、图片服务器分离"></a>2、图片服务器分离</h5><p>​    把图片单独存储，尽量减少图片等大流量的开销，可以放在一些相关的平台上，如骑牛等</p><a id="more"></a><h5 id="3、数据库集群和库表散列及缓存"><a href="#3、数据库集群和库表散列及缓存" class="headerlink" title="3、数据库集群和库表散列及缓存"></a>3、数据库集群和库表散列及缓存</h5><p>数据库的并发连接为100，一台数据库远远不够，可以从读写分离、主从复制，数据库集群方面来着手。另外尽量减少数据库的访问，可以使用缓存数据库如memcache、redis。</p><h5 id="4、镜像："><a href="#4、镜像：" class="headerlink" title="4、镜像："></a>4、镜像：</h5><p>   尽量减少下载，可以把不同的请求分发到多个镜像端。</p><h5 id="5、负载均衡："><a href="#5、负载均衡：" class="headerlink" title="5、负载均衡："></a>5、负载均衡：</h5><p>   Apache的最大并发连接为1500，只能增加服务器，可以从硬件上着手，如F5服务器。当然硬件的成本比较高，我们往往从软件方面着手。</p><p>   负载均衡 （Load Balancing） 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力，同时能够提高网络的灵活性和可用性。目前使用最为广泛的负载均衡软件是Nginx、LVS、HAProxy。我分别来说下三种的优缺点:</p><h5 id="Nginx的优点是："><a href="#Nginx的优点是：" class="headerlink" title="Nginx的优点是："></a>Nginx的优点是：</h5><ol><li><p>工作在网络的7层之上，可以针对http应用做一些分流的策略，比如针对域名、目录结构，它的正则规则比HAProxy更为强大和灵活，这也是它目前广泛流行的主要原因之一，Nginx单凭这点可利用的场合就远多于LVS了。 </p></li><li><p>Nginx对网络稳定性的依赖非常小，理论上能ping通就就能进行负载功能，这个也是它的优势之一；相反LVS对网络稳定性依赖比较大，这点本人深有体会； </p></li><li><p>Nginx安装和配置比较简单，测试起来比较方便，它基本能把错误用日志打印出来。LVS的配置、测试就要花比较长的时间了，LVS对网络依赖比较大。 </p></li><li><p>可以承担高负载压力且稳定，在硬件不差的情况下一般能支撑几万次的并发量，负载度比LVS相对小些。 </p></li><li><p>Nginx可以通过端口检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点，不过其中缺点就是不支持url来检测。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而不满。 </p></li><li><p>Nginx不仅仅是一款优秀的负载均衡器/反向代理软件，它同时也是功能强大的Web应用服务器。LNMP也是近几年非常流行的web架构，在高流量的环境中稳定性也很好。 </p></li><li><p>Nginx现在作为Web反向加速缓存越来越成熟了，速度比传统的Squid服务器更快，可以考虑用其作为反向代理加速器。 </p></li><li><p>Nginx可作为中层反向代理使用，这一层面Nginx基本上无对手，唯一可以对比Nginx的就只有 lighttpd了，不过 lighttpd目前还没有做到Nginx完全的功能，配置也不那么清晰易读，社区资料也远远没Nginx活跃。 </p></li><li><p>Nginx也可作为静态网页和图片服务器，这方面的性能也无对手。还有Nginx社区非常活跃，第三方模块也很多。</p></li></ol><h5 id="Nginx的缺点是："><a href="#Nginx的缺点是：" class="headerlink" title="Nginx的缺点是："></a>Nginx的缺点是：</h5><ol><li>Nginx仅能支持http、https和Email协议，这样就在适用范围上面小些，这个是它的缺点。</li><li>对后端服务器的健康检查，只支持通过端口来检测，不支持通过url来检测。不支持Session的直接保持，但能通过ip_hash来解决。</li></ol><h4 id="LVS：使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability-、可靠性（Reliability-和可管理性（Manageability-。"><a href="#LVS：使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability-、可靠性（Reliability-和可管理性（Manageability-。" class="headerlink" title="LVS：使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability)、可靠性（Reliability)和可管理性（Manageability)。"></a>LVS：使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability)、可靠性（Reliability)和可管理性（Manageability)。</h4><h5 id="LVS的优点是："><a href="#LVS的优点是：" class="headerlink" title="LVS的优点是："></a>LVS的优点是：</h5><ol><li>抗负载能力强、是工作在网络4层之上仅作分发之用，没有流量的产生，这个特点也决定了它在负载均衡软件里的性能最强的，对内存和cpu资源消耗比较低。</li><li>配置性比较低，这是一个缺点也是一个优点，因为没有可太多配置的东西，所以并不需要太多接触，大大减少了人为出错的几率。</li><li>工作稳定，因为其本身抗负载能力很强，自身有完整的双机热备方案，如LVS+Keepalived，不过我们在项目实施中用得最多的还是LVS/DR+Keepalived。</li><li>无流量，LVS只分发请求，而流量并不从它本身出去，这点保证了均衡器IO的性能不会受到大流量的影响。</li><li>应用范围比较广，因为LVS工作在4层，所以它几乎可以对所有应用做负载均衡，包括http、数据库、在线聊天室等等。</li></ol><h5 id="LVS的缺点是："><a href="#LVS的缺点是：" class="headerlink" title="LVS的缺点是："></a>LVS的缺点是：</h5><ol><li>软件本身不支持正则表达式处理，不能做动静分离；而现在许多网站在这方面都有较强的需求，这个是Nginx/HAProxy+Keepalived的优势所在。</li><li>如果是网站应用比较庞大的话，LVS/DR+Keepalived实施起来就比较复杂了，特别后面有 Windows Server的机器的话，如果实施及配置还有维护过程就比较复杂了，相对而言，Nginx/HAProxy+Keepalived就简单多了。</li></ol><h5 id="HAProxy的特点是："><a href="#HAProxy的特点是：" class="headerlink" title="HAProxy的特点是："></a>HAProxy的特点是：</h5><ol><li>HAProxy也是支持虚拟主机的。</li><li>HAProxy的优点能够补充Nginx的一些缺点，比如支持Session的保持，Cookie的引导；同时支持通过获取指定的url来检测后端服务器的状态。</li><li>HAProxy跟LVS类似，本身就只是一款负载均衡软件；单纯从效率上来讲HAProxy会比Nginx有更出色的负载均衡速度，在并发处理上也是优于Nginx的。</li><li>HAProxy支持TCP协议的负载均衡转发，可以对MySQL读进行负载均衡，对后端的MySQL节点进行检测和负载均衡，大家可以用LVS+Keepalived对MySQL主从做负载均衡。</li><li>HAProxy负载均衡策略非常多，HAProxy的负载均衡算法现在具体有如下8种：</li></ol><p>① roundrobin，表示简单的轮询，这个不多说，这个是负载均衡基本都具备的；<br>② static-rr，表示根据权重，建议关注；<br>③ leastconn，表示最少连接者先处理，建议关注；<br>④ source，表示根据请求源IP，这个跟Nginx的IP_hash机制类似，我们用其作为解决session问题的一种方法，建议关注；<br>⑤ ri，表示根据请求的URI；<br>⑥ rl_param，表示根据请求的URl参数’balance url_param’ requires an URL parametername；<br>⑦ hdr(name)，表示根据HTTP请求头来锁定每一次HTTP请求；<br>⑧ rdp-cookie(name)，表示根据据cookie(name)来锁定并哈希每一次TCP请求。</p><h5 id="Nginx和LVS对比的总结："><a href="#Nginx和LVS对比的总结：" class="headerlink" title="Nginx和LVS对比的总结："></a>Nginx和LVS对比的总结：</h5><ol><li><p>Nginx工作在网络的7层，所以它可以针对http应用本身来做分流策略，比如针对域名、目录结构等，相比之下LVS并不具备这样的功能，所以Nginx单凭这点可利用的场合就远多于LVS了；但Nginx有用的这些功能使其可调整度要高于LVS，所以经常要去触碰触碰，触碰多了，人为出问题的几率也就会大。   </p></li><li><p>Nginx对网络稳定性的依赖较小，理论上只要ping得通，网页访问正常，Nginx就能连得通，这是Nginx的一大优势！Nginx同时还能区分内外网，如果是同时拥有内外网的节点，就相当于单机拥有了备份线路；LVS就比较依赖于网络环境，目前来看服务器在同一网段内并且LVS使用direct方式分流，效果较能得到保证。另外注意，LVS需要向托管商至少申请多一个ip来做Visual IP，貌似是不能用本身的IP来做VIP的。要做好LVS管理员，确实得跟进学习很多有关网络通信方面的知识，就不再是一个HTTP那么简单了。</p></li><li><p>Nginx安装和配置比较简单，测试起来也很方便，因为它基本能把错误用日志打印出来。LVS的安装和配置、测试就要花比较长的时间了；LVS对网络依赖比较大，很多时候不能配置成功都是因为网络问题而不是配置问题，出了问题要解决也相应的会麻烦得多。 </p></li><li><p>Nginx也同样能承受很高负载且稳定，但负载度和稳定度差LVS还有几个等级：Nginx处理所有流量所以受限于机器IO和配置；本身的bug也还是难以避免的。 </p></li><li><p>Nginx可以检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点。目前LVS中 ldirectd也能支持针对服务器内部的情况来监控，但LVS的原理使其不能重发请求。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而恼火。 </p></li><li><p>Nginx对请求的异步处理可以帮助节点服务器减轻负载，假如使用 apache直接对外服务，那么出现很多的窄带链接时apache服务器将会占用大量内存而不能释放，使用多一个Nginx做apache代理的话，这些窄带链接会被Nginx挡住，apache上就不会堆积过多的请求，这样就减少了相当多的资源占用。这点使用squid也有相同的作用，即使squid本身配置为不缓存，对apache还是有很大帮助的。 </p></li><li><p>Nginx能支持http、https和email（email的功能比较少用），LVS所支持的应用在这点上会比Nginx更多。在使用上，一般最前端所采取的策略应是LVS，也就是DNS的指向应为LVS均衡器，LVS的优点令它非常适合做这个任务。重要的ip地址，最好交由LVS托管，比如数据库的 ip、webservice服务器的ip等等，这些ip地址随着时间推移，使用面会越来越大，如果更换ip则故障会接踵而至。所以将这些重要ip交给 LVS托管是最为稳妥的，这样做的唯一缺点是需要的VIP数量会比较多。Nginx可作为LVS节点机器使用，一是可以利用Nginx的功能，二是可以利用Nginx的性能。当然这一层面也可以直接使用squid，squid的功能方面就比Nginx弱不少了，性能上也有所逊色于Nginx。Nginx也可作为中层代理使用，这一层面Nginx基本上无对手，唯一可以撼动Nginx的就只有lighttpd了，不过lighttpd目前还没有能做到 Nginx完全的功能，配置也不那么清晰易读。另外，中层代理的IP也是重要的，所以中层代理也拥有一个VIP和LVS是最完美的方案了。具体的应用还得具体分析，如果是比较小的网站（日PV小于1000万），用Nginx就完全可以了，如果机器也不少，可以用DNS轮询，LVS所耗费的机器还是比较多的；大型网站或者重要的服务，机器不发愁的时候，要多多考虑利用LVS。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从低成本、高性能和高扩张性的角度来说有如下处理方案：&lt;/p&gt;
&lt;h5 id=&quot;1、HTML静态化&quot;&gt;&lt;a href=&quot;#1、HTML静态化&quot; class=&quot;headerlink&quot; title=&quot;1、HTML静态化&quot;&gt;&lt;/a&gt;1、HTML静态化&lt;/h5&gt;&lt;p&gt;其实大家都知道，效率最高、消耗最小的就是纯静态化的html页面，所以我们尽可能使我们的  网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。&lt;/p&gt;
&lt;h5 id=&quot;2、图片服务器分离&quot;&gt;&lt;a href=&quot;#2、图片服务器分离&quot; class=&quot;headerlink&quot; title=&quot;2、图片服务器分离&quot;&gt;&lt;/a&gt;2、图片服务器分离&lt;/h5&gt;&lt;p&gt;​    把图片单独存储，尽量减少图片等大流量的开销，可以放在一些相关的平台上，如骑牛等&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="高负载" scheme="https://icocos.github.io/tags/%E9%AB%98%E8%B4%9F%E8%BD%BD/"/>
    
      <category term="高并发" scheme="https://icocos.github.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL 事务处理常见有两种方法</title>
    <link href="https://icocos.github.io/2019/04/26/MYSQL%20%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%B8%B8%E8%A7%81%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>https://icocos.github.io/2019/04/26/MYSQL 事务处理常见有两种方法/</id>
    <published>2019-04-26T10:47:41.000Z</published>
    <updated>2019-05-22T09:17:25.529Z</updated>
    
    <content type="html"><![CDATA[<p> MYSQL在操作大量的数据或者比较重要的数据的时候，事务处理很重要，比如银行的转账，支付，等等，作为开发人员事务是必须的一步。</p><h5 id="1、用-BEGIN-ROLLBACK-COMMIT来实现"><a href="#1、用-BEGIN-ROLLBACK-COMMIT来实现" class="headerlink" title="1、用 BEGIN, ROLLBACK, COMMIT来实现"></a>1、用 BEGIN, ROLLBACK, COMMIT来实现</h5><ul><li>BEGIN 开始一个事务</li><li>ROLLBACK 事务回滚</li><li>COMMIT 事务确认</li></ul><a id="more"></a><h5 id="2、直接用-SET-来改变-MySQL-的自动提交模式"><a href="#2、直接用-SET-来改变-MySQL-的自动提交模式" class="headerlink" title="2、直接用 SET 来改变 MySQL 的自动提交模式:"></a>2、直接用 SET 来改变 MySQL 的自动提交模式:</h5><ul><li>SET AUTOCOMMIT=0 禁止自动提交</li><li>SET AUTOCOMMIT=1 开启自动提交</li></ul><blockquote><p>注意的是，在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</p></blockquote><p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p><h3 id="一、php事务处理概述："><a href="#一、php事务处理概述：" class="headerlink" title="一、php事务处理概述："></a>一、php事务处理概述：</h3><ul><li><p>事务:是若干事件的集合</p></li><li><p>事务处理:当所有事件执行成功,事务才执行;若有任何一个事件不能成功执行,事务的其它事件也不被执行。</p></li></ul><p>只要你的MySQL版本支持BDB或InnoDB表类型，那么你的MySQL就具有事务处理的能力。这里面，又以InnoDB表类型用的最多，虽然后来发生了诸如Oracle收购InnoDB等令MySQL不爽的事情，但是这类商业事件与技术无关，下面就以InnoDB表类型为例简单说一下MySQL中的事务处理。</p><h3 id="二、php事务处理代码："><a href="#二、php事务处理代码：" class="headerlink" title="二、php事务处理代码："></a>二、php事务处理代码：</h3><pre><code>&lt;?phptry{$pdo=new PDO(&quot;mysql:host=localhost;dbname=psp&quot;,&quot;root&quot;,&quot;&quot;);$pdo-&gt;exec(&quot;set names utf8&quot;);$pdo-&gt;setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_EXCEPTION);//设置异常处理模式$pdo-&gt;setAttribute(PDO::ATTR_AUTOCOMMIT,0);//关闭自动提交}catch(PDOException $e){echo &quot;数据库连接失败&quot;;exit;}try{$age=10;$pdo-&gt;beginTransaction();//开始事务$affected_rows1=$pdo-&gt;exec(&quot;update kfry set k_age=k_age+{$age} where k_name=&apos;user1&apos;&quot;);$affected_rows2=$pdo-&gt;exec(&quot;update kfry set k_age=k_age-{$age} where k_name=&apos;user2&apos;&quot;);//随意更改使之执行成功或失败/* if($affected_rows1&amp;&amp;$affected_rows2){$pdo-&gt;commit();echo &quot;操作成功&quot;;}else{$pdo-&gt;rollback();} */if(!$affected_rows1)throw new PDOException(&quot;加入错误&quot;);if(!$affected_rows2)throw new PDOException(&quot;减少错误&quot;);echo &quot;操作成功&quot;;$pdo-&gt;commit();//如果执行到此处前面两个更新sql语句执行成功，整个事务执行成功}catch(PDOException $e){echo &quot;操作失败：&quot;.$e-&gt;getMessage();$pdo-&gt;rollback();//执行事务中的语句出了问题，整个事务全部撤销}$pdo-&gt;setAttribute(PDO::ATTR_AUTOCOMMIT,1);//测试是否成功echo &quot;\n操作结果为:\n&quot;;$sql=&quot;select * from kfry&quot;;$result=$pdo-&gt;query($sql);foreach($result as $v){echo $v[&apos;k_name&apos;].&quot; &quot;.$v[&apos;k_age&apos;].&quot;\n&quot;;}?&gt;</code></pre><p>以上就是php 事务处理详解的详细内容，更多请关注php中文网其它相关文章！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; MYSQL在操作大量的数据或者比较重要的数据的时候，事务处理很重要，比如银行的转账，支付，等等，作为开发人员事务是必须的一步。&lt;/p&gt;
&lt;h5 id=&quot;1、用-BEGIN-ROLLBACK-COMMIT来实现&quot;&gt;&lt;a href=&quot;#1、用-BEGIN-ROLLBACK-COMMIT来实现&quot; class=&quot;headerlink&quot; title=&quot;1、用 BEGIN, ROLLBACK, COMMIT来实现&quot;&gt;&lt;/a&gt;1、用 BEGIN, ROLLBACK, COMMIT来实现&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;BEGIN 开始一个事务&lt;/li&gt;
&lt;li&gt;ROLLBACK 事务回滚&lt;/li&gt;
&lt;li&gt;COMMIT 事务确认&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Web安全的一次探讨</title>
    <link href="https://icocos.github.io/2019/03/13/Web%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%80%E6%AC%A1%E6%8E%A2%E8%AE%A8/"/>
    <id>https://icocos.github.io/2019/03/13/Web安全的一次探讨/</id>
    <published>2019-03-13T04:14:14.000Z</published>
    <updated>2019-05-22T09:17:14.833Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、SQL注入攻击-SQL-Injection"><a href="#一、SQL注入攻击-SQL-Injection" class="headerlink" title="一、SQL注入攻击(SQL Injection)"></a>一、SQL注入攻击(SQL Injection)</h3><p>攻击者把sql命令插入到web表单的输入域或页面请求的字符串，欺骗服务器执行恶意的sql命令。常见的sql注入攻击类似：</p><h5 id="登录页面中输入内容直接用来构造动态的sql语句，例如："><a href="#登录页面中输入内容直接用来构造动态的sql语句，例如：" class="headerlink" title="登录页面中输入内容直接用来构造动态的sql语句，例如："></a>登录页面中输入内容直接用来构造动态的sql语句，例如：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$query = &apos;select * from users where login = &apos;. $username. &apos;and password = &apos;. $password;</span><br></pre></td></tr></table></figure><a id="more"></a><p>攻击者如果在用户名或者密码框输入<code>or &#39;1&#39; =1</code>，这样我们执行的sql语句就变成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where login = &apos;&apos; or &apos;1&apos; = 1 and ...</span><br></pre></td></tr></table></figure><p>这样就绕过了我们的登录验证。类似的还有很多，用户通过输入恶意的sql命令来绕过我们的验证，欺骗我们的系统。</p><h5 id="防范的方法："><a href="#防范的方法：" class="headerlink" title="防范的方法："></a>防范的方法：</h5><ol><li>检查变量数据类型和格式</li><li>过滤特殊的符号</li><li>绑定变量，使用预处理语句（当我们绑定变量的时候，就算有特殊字符sql也会认为是个变量而不是sql命令）</li></ol><h3 id="二、跨站脚本攻击-Cross-Site-Scripting-XSS；因为CSS被用了所以叫XSS"><a href="#二、跨站脚本攻击-Cross-Site-Scripting-XSS；因为CSS被用了所以叫XSS" class="headerlink" title="二、跨站脚本攻击(Cross Site Scripting, XSS；因为CSS被用了所以叫XSS)"></a>二、跨站脚本攻击(Cross Site Scripting, XSS；因为CSS被用了所以叫XSS)</h3><p>攻击者将恶意代码注入到网页上，其他用户在加载网页时就会执行代码，攻击者可能会得到各种私密的信息，如cookie等。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    echo &apos;你好！&apos;.$_GET[&apos;name&apos;];</span><br></pre></td></tr></table></figure><p>如果用户传入一段脚本<code>&lt;script&gt;[code]&lt;/script&gt;</code>，那么脚本也会执行，如果code的内容是获取到cookie并发送到某个指定的位置，获取了敏感的信息。亦或是利用用户的身份去执行一些不正当的操作。</p><h5 id="防范的方法：-1"><a href="#防范的方法：-1" class="headerlink" title="防范的方法："></a>防范的方法：</h5><ol><li>输出的时候过滤特殊的字符，转换成html编码，过滤输出的变量（PHP可以使用htmlspecialchars）</li></ol><h3 id="三、跨站请求伪造攻击-Cross-Site-Request-Forgeries-CSRF"><a href="#三、跨站请求伪造攻击-Cross-Site-Request-Forgeries-CSRF" class="headerlink" title="三、跨站请求伪造攻击(Cross Site Request Forgeries, CSRF)"></a>三、跨站请求伪造攻击(Cross Site Request Forgeries, CSRF)</h3><p>攻击者伪造目标用户的HTTP请求，然后此请求发送到有CSRF漏洞的网站，网站执行此请求后，引发跨站请求伪造攻击。攻击者利用隐蔽的HTTP连接，让目标用户在不注意的情况下单击这个链接，由于是用户自己点击的，而他又是合法用户拥有合法权限，所以目标用户能够在网站内执行特定的HTTP链接，从而达到攻击者的目的。  </p><blockquote><p>  用户刚刚登陆了银行A网站，建立了会话，A网站可以进行转账操作<code>http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000</code>在没有退出的情况下去访问危险网站B网站，B网站有一个图片是这样的<code>&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;</code>，不小心点了B网站，用户发现账上少了1000块。  </p></blockquote><p>可能有人会说，修改操作并不会用get请求。那么假设银行A网站的表单如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;Transfer.php&quot; method=&quot;POST&quot;&gt;</span><br><span class="line">    &lt;p&gt;ToBankId: &lt;input type=&quot;text&quot; name=&quot;toBankId&quot; /&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;Money: &lt;input type=&quot;text&quot; name=&quot;money&quot; /&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Transfer&quot; /&gt;&lt;/p&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>后台处理页面如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">session_start();</span><br><span class="line">if (isset($_REQUEST[&apos;toBankId&apos;] &amp;&amp; isset($_POST[&apos;money&apos;]))</span><br><span class="line">&#123;</span><br><span class="line">    buy_stocks($_REQUEST[&apos;toBankId&apos;],$_REQUEST[&apos;money&apos;]);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>B网站这时候也相应的改了代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">　　　　&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">　　　　　　function steal()</span><br><span class="line">　　　　　　&#123;</span><br><span class="line">          　　　　 iframe = document.frames[&quot;steal&quot;];</span><br><span class="line">　　     　　      iframe.document.Submit(&quot;transfer&quot;);</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&lt;/script&gt;</span><br><span class="line">　　&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">　　&lt;body onload=&quot;steal()&quot;&gt;</span><br><span class="line">　　　　&lt;iframe name=&quot;steal&quot; display=&quot;none&quot;&gt;</span><br><span class="line">　　　　　　&lt;form method=&quot;POST&quot; name=&quot;transfer&quot;　action=&quot;http://www.myBank.com/Transfer.php&quot;&gt;</span><br><span class="line">　　　　　　　　&lt;input type=&quot;hidden&quot; name=&quot;toBankId&quot; value=&quot;11&quot;&gt;</span><br><span class="line">　　　　　　　　&lt;input type=&quot;hidden&quot; name=&quot;money&quot; value=&quot;1000&quot;&gt;</span><br><span class="line">　　　　　　&lt;/form&gt;</span><br><span class="line">　　　　&lt;/iframe&gt;</span><br><span class="line">　　&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>用户一点到B网站，发现又少了1000块…….</p><h5 id="防范方法："><a href="#防范方法：" class="headerlink" title="防范方法："></a>防范方法：</h5><ul><li>对表单进行cookie hash校验，将一个随机值的hash写入cookie，每次提交表单，都在服务端对这个hash进行校验（建立在用户的cookie没有被盗取）</li></ul><h3 id="四、Session固定攻击-Session-Fixation"><a href="#四、Session固定攻击-Session-Fixation" class="headerlink" title="四、Session固定攻击(Session Fixation)"></a>四、Session固定攻击(Session Fixation)</h3><p>攻击者预先设定session id，让合法用户使用这个session id来访问被攻击的应用程序，一旦用户的会话ID被成功固定，攻击者就可以通过此session id来冒充用户访问应用程序。例如：  </p><ol><li>攻击者先访问目标网站，获得了自己的session_id，如SID=123</li><li>攻击者给目标用户发送链接，并带上了自己的session_id，如<code>http:///www.bank.com/?SID=123</code>，</li><li>目标用户点击了<code>http:///www.bank.com/?SID=123</code>，输入用户名密码登录，由于session_id不会变更，那么攻击者就可以通过访问<code>http:///www.bank.com/?SID=123</code>来获取目标用户的身份。</li></ol><h5 id="防范方法：-1"><a href="#防范方法：-1" class="headerlink" title="防范方法："></a>防范方法：</h5><ol><li>定期更改session_id</li><li>更改session_id的名字</li></ol><h3 id="五、Session劫持-Session-Hijacking"><a href="#五、Session劫持-Session-Hijacking" class="headerlink" title="五、Session劫持(Session Hijacking)"></a>五、Session劫持(Session Hijacking)</h3><p>攻击者利用各种手段来获取目标用户的session id。一旦获取到session id，那么攻击者可以利用目标用户的身份来登录网站，获取目标用户的操作权限。</p><h5 id="攻击者获取目标用户session-id的方法"><a href="#攻击者获取目标用户session-id的方法" class="headerlink" title="攻击者获取目标用户session id的方法:"></a>攻击者获取目标用户session id的方法:</h5><ol><li>暴力破解:尝试各种session id，直到破解为止;</li><li>计算:如果session id使用非随机的方式产生，那么就有可能计算出来;</li><li>窃取:使用网络截获，xss攻击等方法获得<br>防范方法：</li><li>定期更改session id</li><li>更改session的名称</li><li>关闭透明化session id</li><li>设置HttpOnly。通过设置Cookie的HttpOnly为true，可以防止客户端脚本访问这个Cookie，从而有效的防止XSS攻击。</li></ol><h3 id="六、文件上传漏洞-File-Upload-Attack"><a href="#六、文件上传漏洞-File-Upload-Attack" class="headerlink" title="六、文件上传漏洞(File Upload Attack)"></a>六、文件上传漏洞(File Upload Attack)</h3><p>攻击者利用程序缺陷绕过系统对文件的验证与处理策略将恶意代码上传到服务器并获得执行服务器端命令的能力。  </p><h5 id="常用的攻击手段有："><a href="#常用的攻击手段有：" class="headerlink" title="常用的攻击手段有："></a>常用的攻击手段有：</h5><ol><li>上传Web脚本代码，Web容器解释执行上传的恶意脚本；</li><li>上传Flash跨域策略文件crossdomain.xml，修改访问权限(其他策略文件利用方式类似)；</li><li>上传病毒、木马文件，诱骗用户和管理员下载执行；</li><li>上传包含脚本的图片，某些浏览器的低级版本会执行该脚本，用于钓鱼和欺诈。<br>总的来说，利用的上传文件要么具备可执行能力(恶意代码)，要么具备影响服务器行为的能力(配置文件)。<br>防范方法：  </li><li>文件上传的目录设置为不可执行；</li><li>判断文件类型，设置白名单。对于图片的处理，可以使用压缩函数或者resize函数，在处理图片的同时破坏图片中可能包含的HTML代码；</li><li>使用随机数改写文件名和文件路径：一个是上传后无法访问；再来就是像shell、.php 、.rar和crossdomain.xml这种文件，都将因为重命名而无法攻击；</li><li>单独设置文件服务器的域名：由于浏览器同源策略的关系，一系列客户端攻击将失效，比如上传crossdomain.xml、上传包含Javascript的XSS利用等问题将得到解决。</li></ol><h3 id="MYSQL安全"><a href="#MYSQL安全" class="headerlink" title="MYSQL安全"></a>MYSQL安全</h3><ol><li>使用预处理语句防止sql注入</li><li>写入数据库的数据要进行特殊字符转义</li><li>查询的错误信息不要返回给用户，将错误记录到日志   </li><li>定期做数据库备份</li><li>不给查询用户root权限，合理分配权限</li><li>关闭远程访问数据库的权限</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、SQL注入攻击-SQL-Injection&quot;&gt;&lt;a href=&quot;#一、SQL注入攻击-SQL-Injection&quot; class=&quot;headerlink&quot; title=&quot;一、SQL注入攻击(SQL Injection)&quot;&gt;&lt;/a&gt;一、SQL注入攻击(SQL Injection)&lt;/h3&gt;&lt;p&gt;攻击者把sql命令插入到web表单的输入域或页面请求的字符串，欺骗服务器执行恶意的sql命令。常见的sql注入攻击类似：&lt;/p&gt;
&lt;h5 id=&quot;登录页面中输入内容直接用来构造动态的sql语句，例如：&quot;&gt;&lt;a href=&quot;#登录页面中输入内容直接用来构造动态的sql语句，例如：&quot; class=&quot;headerlink&quot; title=&quot;登录页面中输入内容直接用来构造动态的sql语句，例如：&quot;&gt;&lt;/a&gt;登录页面中输入内容直接用来构造动态的sql语句，例如：&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$query = &amp;apos;select * from users where login = &amp;apos;. $username. &amp;apos;and password = &amp;apos;. $password;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>数据库查询速度优化之解决技巧</title>
    <link href="https://icocos.github.io/2019/03/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%E4%B9%8B%E8%A7%A3%E5%86%B3%E6%8A%80%E5%B7%A7/"/>
    <id>https://icocos.github.io/2019/03/11/数据库查询速度优化之解决技巧/</id>
    <published>2019-03-11T10:47:41.000Z</published>
    <updated>2019-05-22T09:17:29.029Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、对查询进行优化-应尽可能避免全表扫描"><a href="#1、对查询进行优化-应尽可能避免全表扫描" class="headerlink" title="1、对查询进行优化,应尽可能避免全表扫描"></a>1、对查询进行优化,应尽可能避免全表扫描</h3><p>首先应考虑在 where 及 order by 涉及的列上建立索引。<br>下面我们来以一个表中177条数据比较一下,全表扫描与建立索引之后性能的一个比较.</p><blockquote><p>从这两种方式查询数据库结果看,建立索引之后查询速度提高了些,现在数据量还不明显,如果表中有10万条速度,差异就会很明显了.</p></blockquote><a id="more"></a><h3 id="2、写数据语句时尽可能减少表的全局扫描"><a href="#2、写数据语句时尽可能减少表的全局扫描" class="headerlink" title="2、写数据语句时尽可能减少表的全局扫描"></a>2、写数据语句时尽可能减少表的全局扫描</h3><h5 id="2-1-减少where-字段值null判断"><a href="#2-1-减少where-字段值null判断" class="headerlink" title="2.1 减少where 字段值null判断"></a>2.1 减少where 字段值null判断</h5><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where pay_status = null</code></pre><p>如何这样做,就会导致引擎放弃使用索引而进行全表扫描<br>应该这样去设置(也就是在没有值时,我们在存数据库时自动默认给个o值,而不是什么都不写):</p><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where pay_status = 0</code></pre><h5 id="2-2-应尽量避免在-where-子句中使用-或-lt-gt-操作符"><a href="#2-2-应尽量避免在-where-子句中使用-或-lt-gt-操作符" class="headerlink" title="2.2 应尽量避免在 where 子句中使用!=或&lt;&gt;操作符"></a>2.2 应尽量避免在 where 子句中使用!=或&lt;&gt;操作符</h5><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where pay_status != null ;//或者SELECT * FROM &quot;tb_real_time_car&quot; where pay_status &lt;&gt; null ;</code></pre><p>这样写将导致引擎放弃使用索引而进行全表扫描。</p><h5 id="2-3-应尽量避免在-where-子句中使用-or-来连接条件"><a href="#2-3-应尽量避免在-where-子句中使用-or-来连接条件" class="headerlink" title="2.3 应尽量避免在 where 子句中使用 or 来连接条件"></a>2.3 应尽量避免在 where 子句中使用 or 来连接条件</h5><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where pay_status != null or enter_time = null; </code></pre><p>这样将导致引擎放弃使用索引而进行全表扫描</p><p>可以这样操作:</p><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where pay_status != null union all SELECT * FROM &quot;tb_real_time_car&quot; where enter_time = null; </code></pre><h5 id="2-4-in-和-not-in-也要慎用"><a href="#2-4-in-和-not-in-也要慎用" class="headerlink" title="2.4 in 和 not in 也要慎用"></a>2.4 in 和 not in 也要慎用</h5><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where rowed in [1,2,3,4]; //或者SELECT * FROM &quot;tb_real_time_car&quot; where rowed not in [1,2,3,4]; </code></pre><p>这样操作,也会导致全表扫描</p><p>可以这样来写:</p><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where rowed between 1 and 5; </code></pre><h5 id="2-5-少使用模糊匹配-like"><a href="#2-5-少使用模糊匹配-like" class="headerlink" title="2.5 少使用模糊匹配 like"></a>2.5 少使用模糊匹配 like</h5><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where enter_time like &apos;%2016-09-01%&apos;</code></pre><h5 id="2-6-应尽量避免在-where-子句中对字段进行表达式操作"><a href="#2-6-应尽量避免在-where-子句中对字段进行表达式操作" class="headerlink" title="2.6 应尽量避免在 where 子句中对字段进行表达式操作"></a>2.6 应尽量避免在 where 子句中对字段进行表达式操作</h5><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where rowid/4 =100;</code></pre><p>这样写,将导致引擎放弃使用索引而进行全表扫描</p><p>应该写成:</p><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where rowid =4*100;</code></pre><h5 id="2-7-任何地方都不要使用-通配符去查询所有"><a href="#2-7-任何地方都不要使用-通配符去查询所有" class="headerlink" title="2.7 任何地方都不要使用*通配符去查询所有"></a>2.7 任何地方都不要使用*通配符去查询所有</h5><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where rowid/4 =100;</code></pre><p>以通配符*去查询所有数据,这样做也是非常耗时的,我们应该需要什么字段就查询什么字段.</p><p>应该这样做:</p><pre><code>SELECT leave_time FROM &quot;tb_real_time_car&quot; where rowid/4 =100;</code></pre><h3 id="3、不要在条件判断时进行-算数运算"><a href="#3、不要在条件判断时进行-算数运算" class="headerlink" title="3、不要在条件判断时进行 算数运算"></a>3、不要在条件判断时进行 算数运算</h3><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where rowid/4 =100;</code></pre><p>所以不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算,这样系统将可能无法正确使用索引</p><p>应该这样做:</p><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where rowed =400;</code></pre><h3 id="4、很多时候用-exists-代替-in-是一个好的选择"><a href="#4、很多时候用-exists-代替-in-是一个好的选择" class="headerlink" title="4、很多时候用 exists 代替 in 是一个好的选择"></a>4、很多时候用 exists 代替 in 是一个好的选择</h3><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where rowed (select rowed from &quot;tb_real&quot;);</code></pre><p>应该这样来写:</p><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where exists (select rowed from &quot;tb_real&quot; where rowed = tb_real.rowid);</code></pre><h3 id="5-论索引技巧"><a href="#5-论索引技巧" class="headerlink" title="5 论索引技巧"></a>5 论索引技巧</h3><h5 id="5-1-并不是所有索引对查询都有效"><a href="#5-1-并不是所有索引对查询都有效" class="headerlink" title="5.1 并不是所有索引对查询都有效"></a>5.1 并不是所有索引对查询都有效</h5><p>SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用</p><h5 id="5-2-索引并不是越多越好"><a href="#5-2-索引并不是越多越好" class="headerlink" title="5.2 索引并不是越多越好"></a>5.2 索引并不是越多越好</h5><p>索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p><h5 id="5-3-应尽可能的避免更新-clustered-索引数据列"><a href="#5-3-应尽可能的避免更新-clustered-索引数据列" class="headerlink" title="5.3 应尽可能的避免更新 clustered 索引数据列"></a>5.3 应尽可能的避免更新 clustered 索引数据列</h5><p>因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p><h5 id="5-4-尽量使用数字型字段"><a href="#5-4-尽量使用数字型字段" class="headerlink" title="5.4 尽量使用数字型字段"></a>5.4 尽量使用数字型字段</h5><p>若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p><h3 id="6-创建数据库时应该注意地方"><a href="#6-创建数据库时应该注意地方" class="headerlink" title="6 创建数据库时应该注意地方"></a>6 创建数据库时应该注意地方</h3><h5 id="6-1-尽可能的使用-varchar-nvarchar-代替-char-nchar"><a href="#6-1-尽可能的使用-varchar-nvarchar-代替-char-nchar" class="headerlink" title="6.1. 尽可能的使用 varchar/nvarchar 代替 char/nchar"></a>6.1. 尽可能的使用 varchar/nvarchar 代替 char/nchar</h5><p>因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p><h5 id="6-2-用表变量来代替临时表。"><a href="#6-2-用表变量来代替临时表。" class="headerlink" title="6.2 用表变量来代替临时表。"></a>6.2 用表变量来代替临时表。</h5><ol><li><p>如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p></li><li><p>在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p></li><li><p>如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p></li></ol><h5 id="6-3-避免频繁创建和删除临时表，以减少系统表资源的消耗。"><a href="#6-3-避免频繁创建和删除临时表，以减少系统表资源的消耗。" class="headerlink" title="6.3 避免频繁创建和删除临时表，以减少系统表资源的消耗。"></a>6.3 避免频繁创建和删除临时表，以减少系统表资源的消耗。</h5><h5 id="6-4-尽量避免使用游标"><a href="#6-4-尽量避免使用游标" class="headerlink" title="6.4 尽量避免使用游标"></a>6.4 尽量避免使用游标</h5><ol><li><p>因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p></li><li><p>使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p></li><li><p>与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p></li></ol><h3 id="7-数据放回时注意什么"><a href="#7-数据放回时注意什么" class="headerlink" title="7 数据放回时注意什么"></a>7 数据放回时注意什么</h3><h5 id="7-1-尽量避免大事务操作，提高系统并发能力。"><a href="#7-1-尽量避免大事务操作，提高系统并发能力。" class="headerlink" title="7.1 尽量避免大事务操作，提高系统并发能力。"></a>7.1 尽量避免大事务操作，提高系统并发能力。</h5><pre><code>这样可以有效提高系统的并发能力</code></pre><h5 id="7-2-尽量避免向客户端返回大数据量"><a href="#7-2-尽量避免向客户端返回大数据量" class="headerlink" title="7.2 尽量避免向客户端返回大数据量"></a>7.2 尽量避免向客户端返回大数据量</h5><pre><code>若数据量过大，应该考虑相应需求是否合理。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、对查询进行优化-应尽可能避免全表扫描&quot;&gt;&lt;a href=&quot;#1、对查询进行优化-应尽可能避免全表扫描&quot; class=&quot;headerlink&quot; title=&quot;1、对查询进行优化,应尽可能避免全表扫描&quot;&gt;&lt;/a&gt;1、对查询进行优化,应尽可能避免全表扫描&lt;/h3&gt;&lt;p&gt;首先应考虑在 where 及 order by 涉及的列上建立索引。&lt;br&gt;下面我们来以一个表中177条数据比较一下,全表扫描与建立索引之后性能的一个比较.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从这两种方式查询数据库结果看,建立索引之后查询速度提高了些,现在数据量还不明显,如果表中有10万条速度,差异就会很明显了.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>关于mysql最左前缀原则</title>
    <link href="https://icocos.github.io/2019/03/01/%E5%85%B3%E4%BA%8Emysql%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99/"/>
    <id>https://icocos.github.io/2019/03/01/关于mysql最左前缀原则/</id>
    <published>2019-03-01T10:47:41.000Z</published>
    <updated>2019-05-22T09:06:40.679Z</updated>
    
    <content type="html"><![CDATA[<h4 id="背景知识："><a href="#背景知识：" class="headerlink" title="背景知识："></a>背景知识：</h4><ol><li>mysql中可以使用explain关键字来查看sql语句的执行计划。</li><li>最左前缀原则主要使用在联合索引中</li><li>数据库版本Mysql5.5.53</li></ol><a id="more"></a><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>mysql建立多列索引（联合索引）有最左前缀的原则，即最左优先，如：</p><ul><li>如果有一个2列的索引(col1,col2),则已经对(col1)、(col1,col2)上建立了索引；</li><li>如果有一个3列索引(col1,col2,col3)，则已经对(col1)、(col1,col2)、(col1,col2,col3)上建立了索引；</li></ul><p>1、b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+树是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道第一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。</p><p>2、比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。（这种情况无法用到联合索引）</p><p>关于最左前缀的使用，有下面两条说明：</p><ul><li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a  = 1 and b = 2 and c &gt; 3 and d = 4  如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li><li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li></ul><p>联合索引有一个最左前缀原则，所以建立联合索引的时候，这个联合索引的字段顺序非常重要</p><p>下面写了例子说明这个：</p><pre><code>CREATE TABLE `test_myisam` (`id` int(11) NOT NULL AUTO_INCREMENT,`conference_id` varchar(200) NOT NULL,`account` varchar(100) DEFAULT NULL,`status` int(2) DEFAULT NULL COMMENT &apos;0:invite,  1:cancel_invite,  2:decline,  3:connect&apos;,`duration` bigint(20) unsigned DEFAULT NULL,`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,PRIMARY KEY (`id`)) ENGINE=myisam AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</code></pre><p>以上表结构，我想通过三列进行查询 account ,status,create_time进行查询统计。</p><h5 id="如何建立索引？"><a href="#如何建立索引？" class="headerlink" title="如何建立索引？"></a>如何建立索引？</h5><p>因为我们有可能按照acccount单独统计，或者按照account status，或者是account，status，create_time进行统计，如何建立索引？？？</p><p>下面是建立索引前后的对比600万数据</p><p>如何生成：执行如下脚本，account和日期不同还有status不同，分别生成一百万。</p><pre><code>CREATE  PROCEDURE `add_data_myisam_cp_27`()begindeclare v_rows int(10) default 1000000;declare v_count int(10) default 0;id_loop:LOOPinsert into test_myisam values(null,round(rand()*1000000000),&apos;cloudp&apos;,round(rand()*3),round(rand()*100000),&apos;2016-07-27 00:00:22&apos;);set v_count= v_count + 1;if v_count&gt;v_rows thenleave id_loop;end if;end loop id_loop;end;</code></pre><p>测试结果利用建立的索引性能提高了三倍：</p><pre><code>MariaDB [prf]&gt; select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and date(create_time)=&apos;2016-07-27&apos;;+----------+| count(1) |+----------+|   167400 |+----------+1 row in set (1.28 sec)MariaDB [prf]&gt; create index as_index on test_myisam(account,status,create_time);Query OK, 6000006 rows affected (31.60 sec)Records: 6000006  Duplicates: 0  Warnings: 0MariaDB [prf]&gt; select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and date(create_time)=&apos;2016-07-27&apos;;+----------+| count(1) |+----------+|   167400 |+----------+1 row in set (0.42 sec)MariaDB [prf]&gt; explain select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and date(create_time)=&apos;2016-07-27&apos;;+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+| id   | select_type | table       | type | possible_keys | key      | key_len | ref         | rows   | Extra                    |+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+|    1 | SIMPLE      | test_myisam | ref  | as_index      | as_index | 308     | const,const | 520216 | Using where; Using index |+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+1 row in set (0.00 sec)</code></pre><p>从1.28秒下降到0.42秒<br>但是这个date(create_time)会对每一列都会转换后对比，这里会比较消耗性能；</p><h5 id="如何利用上索引？？"><a href="#如何利用上索引？？" class="headerlink" title="如何利用上索引？？"></a>如何利用上索引？？</h5><p>修改为：</p><pre><code>MariaDB [prf]&gt; explain select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and date(create_time)=&apos;2016-07-27&apos;;+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+| id   | select_type | table       | type | possible_keys | key      | key_len | ref         | rows   | Extra                    |+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+|    1 | SIMPLE      | test_myisam | ref  | as_index      | as_index | 308     | const,const | 520216 | Using where; Using index |+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+1 row in set (0.00 sec)MariaDB [prf]&gt; select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and create_time  between &apos;2016-07-27&apos; and &apos;2016-07-28&apos;;+----------+| count(1) |+----------+|   167400 |+----------+1 row in set (0.15 sec)MariaDB [prf]&gt; explain select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and create_time  between &apos;2016-07-27&apos; and &apos;2016-07-28&apos;;+------+-------------+-------------+-------+---------------+----------+---------+------+--------+--------------------------+| id   | select_type | table       | type  | possible_keys | key      | key_len | ref  | rows   | Extra                    |+------+-------------+-------------+-------+---------------+----------+---------+------+--------+--------------------------+|    1 | SIMPLE      | test_myisam | range | as_index      | as_index | 312     | NULL | 174152 | Using where; Using index |+------+-------------+-------------+-------+---------------+----------+---------+------+--------+--------------------------+1 row in set (0.00 sec)</code></pre><p>如上效率又提高了三倍，是因为扫描的数据行数减少了，最后一个create_time如果不用索引需要扫描52016行，如果使用了索引扫描174152行，命中的行数为：167400行，命中率非常高了。</p><h5 id="这里有个疑问："><a href="#这里有个疑问：" class="headerlink" title="这里有个疑问："></a>这里有个疑问：</h5><blockquote><p> 如果按照天进行统计，create_time作为联合索引的第一列，如何使用上这个索引呢？？？？</p></blockquote><p>至今没有想清楚，如果这一列是date类型可以直接用上索引，如果在oracle中可以date(create_time)建立函数式索引。但是mysql貌似不支持函数式索引。</p><h5 id="一个解决方式是："><a href="#一个解决方式是：" class="headerlink" title="一个解决方式是："></a>一个解决方式是：</h5><blockquote><p>create_time定义为 date类型，在每一列存入的时候，通过触发器自动把这一行修改为date类型。</p></blockquote><p>如果有好的注意欢迎留言探讨，目前没有好的方式加上create_time，可以从业务上解决，就是每天的统计计算完成以后，直接把数据推到历史表中，统计结果单独存放。</p><h5 id="最后说一下关于索引失效的问题："><a href="#最后说一下关于索引失效的问题：" class="headerlink" title="最后说一下关于索引失效的问题："></a>最后说一下关于索引失效的问题：</h5><ol><li>如果条件中有or，即使其中有条件带索引也不会使用(<strong>这也是为什么尽量少用or的原因</strong>)。<strong>注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引</strong></li><li>对于多列索引，不是使用的第一部分，则不会使用索引（即不符合最左前缀原则）</li><li>like查询是以%开头</li><li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引</li><li>如果mysql估计使用全表扫描要比使用索引快,则不使用索引</li></ol><h6 id="此外，查看索引的使用情况"><a href="#此外，查看索引的使用情况" class="headerlink" title="此外，查看索引的使用情况"></a>此外，查看索引的使用情况</h6><ul><li><p>show status like ‘Handler_read%’;</p></li><li><p>handler_read_key:这个值越高越好，越高表示使用索引查询到的次数</p></li><li>handler_read_rnd_next:这个值越高，说明查询低效</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;背景知识：&quot;&gt;&lt;a href=&quot;#背景知识：&quot; class=&quot;headerlink&quot; title=&quot;背景知识：&quot;&gt;&lt;/a&gt;背景知识：&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;mysql中可以使用explain关键字来查看sql语句的执行计划。&lt;/li&gt;
&lt;li&gt;最左前缀原则主要使用在联合索引中&lt;/li&gt;
&lt;li&gt;数据库版本Mysql5.5.53&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="MySQL" scheme="https://icocos.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://icocos.github.io/tags/MySQL/"/>
    
      <category term="最佳左前缀" scheme="https://icocos.github.io/tags/%E6%9C%80%E4%BD%B3%E5%B7%A6%E5%89%8D%E7%BC%80/"/>
    
  </entry>
  
  <entry>
    <title>PHP之PHP-FPM入门</title>
    <link href="https://icocos.github.io/2019/02/24/PHP%E4%B9%8BPHP-FPM%E5%85%A5%E9%97%A8/"/>
    <id>https://icocos.github.io/2019/02/24/PHP之PHP-FPM入门/</id>
    <published>2019-02-24T10:18:51.000Z</published>
    <updated>2019-05-22T09:17:24.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHP-FPM"><a href="#PHP-FPM" class="headerlink" title="PHP-FPM"></a>PHP-FPM</h1><p>Nginx 和 PHP 通信的主要流程为：通过浏览器访问Url后，请求到web服务器，服务器根据配置文件，确定为PHP脚本文件，转发到PHP解析器，PHP解析器会解析php.ini文件初始化执行环境，然后处理请求，再以标准的数据格式返回处理结果，最后退出进程。</p><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><p>nginx和php-fpm通信有tcp socket和unix socket两种方式：</p><ul><li>unix socket方式：nginx和php-fpm的进程之间通信，速度快，消耗资源少。而tcp需要经过本地回环驱动，还要申请临时端口和tcp相关资源。</li></ul><a id="more"></a><blockquote><p>unix socket相比不是那么稳定，当并发连接数爆发时，会产生大量的长时缓存，在没有面向连接协议支撑的情况下，大数据包很有可能就直接出错并不会返回异常。</p></blockquote><p>虽然socket有更少的数据拷贝和上下文切换，更少的资源占用，但是如果数据都是错的，那还有什么用呢。另外使用unix socket的话，必须nginx和fpm在同一台机器上</p><ul><li>tcp socket方式：tcp协议能保证数据的正确性，可以跨服务器，当nginx和php-fpm不在同一台机器上时，只能使用这种方式，但性能不如unix socket。</li></ul><h2 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h2><p>CGI（Common Gateway Interface）是服务器与后台语言交互的协议，有了这个协议，开发者可以使用任何语言处理服务器转发过来的请求，动态地生成内容，保证了传递过来的数据是标准格式的,规定了以什么样的格式传哪些数据（URL、查询字符串、POST数据、HTTP header等等），方便了开发者。</p><h2 id="PHP-CGI"><a href="#PHP-CGI" class="headerlink" title="PHP-CGI"></a>PHP-CGI</h2><p>PHP语言对应与服务器交互的CGI程序就是PHP-CGI，标准的CGI程序对每个请求都会执行：PHP解析器解析php.ini文件，初始化执行环境。</p><p>CGI程序本身只能解析请求、返回结果，不会进程管理，所以有一个致命的缺点，那就是每处理一个请求都需要fork一个全新的进程，随着Web的兴起，高并发越来越成为常态，这样低效的方式明显不能满足需求，每一次web请求都会有启动和退出进程，也就是最为人诟病的fork-and-execute模式。</p><h2 id="FastCGI"><a href="#FastCGI" class="headerlink" title="FastCGI"></a>FastCGI</h2><p>FastCGI，允许在一个进程内处理多个请求，而不是一个请求处理完毕就直接结束进程，性能上有了很大的提高。</p><p>FastCGI会先启一个master进程，解析配置文件，初始化执行环境，然后再启动多个worker进程。当请求过来时，master会传递给一个worker，然后立即可以接受下一个请求，避免了重复创建进程。当worker不够用时，master可以根据配置预先启动几个worker等着。当然空闲worker太多时，也会停掉一些，这样就提高了性能，也节约了资源。</p><h2 id="PHP-FPM-1"><a href="#PHP-FPM-1" class="headerlink" title="PHP-FPM"></a>PHP-FPM</h2><p>PHP-FPM（FastCGI Process Manager）是FastCGI协议的一个实现，任何实现了FastCGI协议的服务器都能够与之通信。</p><p>FPM是一个PHP进程管理器，包含master和worker两种进程。</p><p>master进程只有一个，负责监听端口，接收来自服务器的请求，而worker进程则一般有多个（具体数量根据实际需要配置），每个进程内部都嵌入了一个PHP解释器，是PHP代码真正执行的地方。</p><p>从FPM接收到请求，到处理完毕，其具体的流程如下：</p><ul><li>FPM的master进程接收到请求。</li><li>master进程根据配置指派特定的worker进程进行请求处理</li><li>如果没有可用进程，返回错误，这也是我们配合Nginx遇到502错误比较多的原因。</li><li>worker进程处理请求，如果超时，返回504错误。</li><li>请求处理结束，返回结果。</li></ul><h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><p>Nginx不仅仅是一个Web服务器，也是一个功能强大的Proxy服务器，除了进行http请求的代理，也可以进行许多其他协议请求的代理，包括与FPM相关的FastCGI协议。</p><p>为了能够使Nginx理解FastCGI协议，Nginx提供了FastCGI模块来将http请求映射为对应的FastCGI请求。</p><blockquote><p>Nginx的FastCGI模块提供了fastcgi_param指令来主要处理这些映射关系，/usr/local/nginx/conf/fastcgi.conf 是Nginx的一个配置文件实例，其主要完成的工作是将Nginx中的变量翻译成PHP中能够理解的变量。</p></blockquote><p>除此之外，非常重要的就是fastcgi_pass指令了，这个指令用于指定FPM进程监听的地址，Nginx会把所有的PHP请求翻译成FastCGI请求之后再发送到这个地址。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;PHP-FPM&quot;&gt;&lt;a href=&quot;#PHP-FPM&quot; class=&quot;headerlink&quot; title=&quot;PHP-FPM&quot;&gt;&lt;/a&gt;PHP-FPM&lt;/h1&gt;&lt;p&gt;Nginx 和 PHP 通信的主要流程为：通过浏览器访问Url后，请求到web服务器，服务器根据配置文件，确定为PHP脚本文件，转发到PHP解析器，PHP解析器会解析php.ini文件初始化执行环境，然后处理请求，再以标准的数据格式返回处理结果，最后退出进程。&lt;/p&gt;
&lt;h2 id=&quot;通信方式&quot;&gt;&lt;a href=&quot;#通信方式&quot; class=&quot;headerlink&quot; title=&quot;通信方式&quot;&gt;&lt;/a&gt;通信方式&lt;/h2&gt;&lt;p&gt;nginx和php-fpm通信有tcp socket和unix socket两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;unix socket方式：nginx和php-fpm的进程之间通信，速度快，消耗资源少。而tcp需要经过本地回环驱动，还要申请临时端口和tcp相关资源。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>高并发大流解决量方案</title>
    <link href="https://icocos.github.io/2019/02/17/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%A4%A7%E6%B5%81%E8%A7%A3%E5%86%B3%E9%87%8F%E6%96%B9%E6%A1%88/"/>
    <id>https://icocos.github.io/2019/02/17/高并发大流解决量方案/</id>
    <published>2019-02-17T04:14:14.000Z</published>
    <updated>2019-05-22T09:17:27.845Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><ul><li>QPS:每秒钟请求或者查询的数量，通常是指每秒相应请求数（http）<ul><li>QPS不等于并发连接数，QPS是每秒的HTTP请求数量，并发连接数是指系统同时处理的请求数量  </li><li>峰值的每秒请求数（QPS）= (总PV数 <em> 80%)/(6小时秒数 </em> 20%)  </li><li>峰值QPS的计算规律主要是80%的访问量集中在20%的访问时间</li></ul></li><li>吞吐量：单位时间内处理请求的数量</li><li>响应时间：从请求发出到收到响应花费的时间</li><li>PV(page view)综合浏览量，即页面点击数。通常日PV在千万级就是高并发的网站</li><li>UV(unique visitor)独立访客，一定时间内相同访客访问网站，只计算为1个独立访客</li></ul><a id="more"></a><ul><li><p>带宽：计算带宽大小，我们需要关注两个指标，峰值流量和平均大小</p><blockquote><p>日网站的带宽 = PV/统计时间（秒） <em> 平均页面大小（KB） </em> 8  </p></blockquote></li><li><p>压力测试</p><ul><li>1.测试能承受的最大并发  </li><li>2.测试最大承受QPS值  </li></ul></li></ul><h5 id="ab-apache-benchmark-工具使用"><a href="#ab-apache-benchmark-工具使用" class="headerlink" title="ab(apache benchmark)工具使用:"></a>ab(apache benchmark)工具使用:</h5><p>ab会创建多个并发访问线程，模拟多个访问者同时对一个URL地址进行访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ab的基本使用</span><br><span class="line">ab -c 100 -n 5000 url</span><br><span class="line">并发请求100次，总共5000次</span><br><span class="line"></span><br><span class="line">测试时注意被测试机器的CPU、内存、网络都不超过最高限度的75%</span><br></pre></td></tr></table></figure><p>此处介绍一些QPS的数值：</p><ol><li>50：小型网站，一般服务器即可应付</li><li>100：假设数据库每次请求都在0.01秒内完成，单个页面只有一个sql，100QPS意味着1秒钟要完成100次请求，但是我们数据库不一定能完成100次查询。此时优化方案为：数据库缓存、数据库负载均衡</li><li>800：假设网站有百兆带宽，意味着实际出口的带宽为8M左右，如果每个页面只有10K，在这个QPS下，带宽已经吃完。此时的方案：CDN加速，负载均衡</li><li>1000： 假设使用nosql来缓存数据库查询（memcache或redis），每个页面对nosql的请求远大于直接对DB的请求</li><li>2000： 业务分离，做分布式存储</li></ol><h3 id="二、优化方案"><a href="#二、优化方案" class="headerlink" title="二、优化方案"></a>二、优化方案</h3><ul><li>流量优化：  </li></ul><ol><li>防盗链处理 </li><li>减少前端http请求（合并css、js等静态资源）</li><li>添加异步请求，减少http请求的并发量</li><li>启用浏览器的缓存和使用文件压缩</li><li>CDN加速，减轻服务器压力和带宽压力<ul><li>服务端优化  </li></ul><ol><li>页面静态化</li><li>并发处理</li></ol><ul><li>数据库优化  </li></ul><ol><li>数据库缓存</li><li>分库分表，分区操作</li><li>读写分离</li><li>负载均衡</li></ol><ul><li>web服务器优化  </li></ul><ol><li>负载均衡</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、概念&quot;&gt;&lt;a href=&quot;#一、概念&quot; class=&quot;headerlink&quot; title=&quot;一、概念&quot;&gt;&lt;/a&gt;一、概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;QPS:每秒钟请求或者查询的数量，通常是指每秒相应请求数（http）&lt;ul&gt;
&lt;li&gt;QPS不等于并发连接数，QPS是每秒的HTTP请求数量，并发连接数是指系统同时处理的请求数量  &lt;/li&gt;
&lt;li&gt;峰值的每秒请求数（QPS）= (总PV数 &lt;em&gt; 80%)/(6小时秒数 &lt;/em&gt; 20%)  &lt;/li&gt;
&lt;li&gt;峰值QPS的计算规律主要是80%的访问量集中在20%的访问时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;吞吐量：单位时间内处理请求的数量&lt;/li&gt;
&lt;li&gt;响应时间：从请求发出到收到响应花费的时间&lt;/li&gt;
&lt;li&gt;PV(page view)综合浏览量，即页面点击数。通常日PV在千万级就是高并发的网站&lt;/li&gt;
&lt;li&gt;UV(unique visitor)独立访客，一定时间内相同访客访问网站，只计算为1个独立访客&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>深入理解PHP之：Nginx 与 FPM 的工作机制</title>
    <link href="https://icocos.github.io/2019/02/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E4%B9%8B%EF%BC%9ANginx-%E4%B8%8E-FPM-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/"/>
    <id>https://icocos.github.io/2019/02/15/深入理解PHP之：Nginx-与-FPM-的工作机制/</id>
    <published>2019-02-15T09:54:22.000Z</published>
    <updated>2019-05-21T08:52:03.574Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>网络上有很多关于如何配置 Nginx + FPM 的文章，但它们更多从操作的角度出发，告诉我们怎么做，但却没有告诉我们为什么要这么做，本文从 Nginx 与 FPM 的工作机制出发，探讨配置背后的原理，让我们真正理解 Nginx 与 PHP 是如何协同工作的。</p><h4 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h4><p>要说 Nginx 与 PHP 是如何协同工作的，首先得说 CGI (Common Gateway Interface) 和 FastCGI 这两个协议。</p><a id="more"></a><blockquote><p>CGI 是 Web Server 与后台语言交互的协议，有了这个协议，开发者可以使用任何语言处理 Web Server 发来的请求，动态的生成内容。但 CGI 有一个致命的缺点，那就是每处理一个请求都需要 fork 一个全新的进程，随着 Web 的兴起，高并发越来越成为常态，这样低效的方式明显不能满足需求。就这样，FastCGI 诞生了，CGI 很快就退出了历史的舞台。FastCGI，顾名思义为更快的 CGI，它允许在一个进程内处理多个请求，而不是一个请求处理完毕就直接结束进程，性能上有了很大的提高。</p></blockquote><p>FPM (FastCGI Process Manager)，它是 FastCGI 的实现，任何实现了 FastCGI 协议的 Web Server 都能够与之通信。FPM 之于标准的 FastCGI，也提供了一些增强功能，具体可以参考官方文档：PHP: FPM Installation。</p><pre><code>FPM 是一个 PHP 进程管理器，包含 master 进程和 worker 进程两种进程：master 进程只有一个，负责监听端口，接收来自 Web Server 的请求，而 worker 进程则一般有多个 (具体数量根据实际需要配置)，每个进程内部都嵌入了一个 PHP 解释器，是 PHP 代码真正执行的地方，下图是我本机上 fpm 的进程情况，1一个 master 进程，3个 worker 进程：</code></pre><p><img src="http://img0.ph.126.net/WMv1Zu5I-rlmKMoUTc68-Q==/6631597730303787300.png" alt="fpm进程"></p><p>从 FPM 接收到请求，到处理完毕，其具体的流程如下：</p><pre><code>1. FPM 的 master 进程接收到请求2. master 进程根据配置指派特定的 worker进程进行请求处理，如果没有可用进程，返回错误，这也是我们配合 Nginx 遇到502错误比较多的原因。3. worker 进程处理请求，如果超时，返回504错误4. 请求处理结束，返回结果</code></pre><p>FPM 从接收到处理请求的流程就是这样了，那么 Nginx 又是如何发送请求给 fpm 的呢？这就需要从 Nginx 层面来说明了。</p><p>Nginx 不仅仅是一个 Web 服务器，也是一个功能强大的 Proxy 服务器，除了进行 http 请求的代理，也可以进行许多其他协议请求的代理，包括本文与 fpm 相关的 fastcgi 协议。为了能够使 Nginx 理解 fastcgi 协议，Nginx 提供了 fastcgi 模块来将 http 请求映射为对应的 fastcgi 请求。</p><blockquote><p>Nginx 的 fastcgi 模块提供了 fastcgi_param 指令来主要处理这些映射关系，下面 Ubuntu 下 Nginx 的一个配置文件，其主要完成的工作是将 Nginx 中的变量翻译成 PHP 中能够理解的变量。</p></blockquote><p><img src="http://img2.ph.126.net/QWqq90MIXEcQnTA7ft1WVg==/6631819831652599451.jpg" alt="fastcgi_param"></p><p>除此之外，非常重要的就是 fastcgi_pass 指令了，这个指令用于指定 fpm 进程监听的地址，Nginx 会把所有的 php 请求翻译成 fastcgi 请求之后再发送到这个地址。下面一个简单的可以工作的 Nginx 配置文件：</p><p><img src="http://img0.ph.126.net/tLal8xnxIanLB_mfp2dHUQ==/6631751661931678563.jpg" alt="nginx配置"></p><p>在这个配置文件中，我们新建了一个虚拟主机，监听在 80 端口，Web 根目录为 /home/rf/projects/wordpress。然后我们通过 location 指令，将所有的以 .php 结尾的请求都交给 fastcgi 模块处理，从而把所有的 php 请求都交给了 fpm 处理，从而完成 Nginx 到 fpm 的闭环。</p><p>如此以来，Nginx 与 FPM 通信的整个流程应该比较清晰了吧。</p><ol><li>nginx是web服务器，提供http服务。</li><li>php代码需要php解析器解析。所以这里要有个nginx和php解析器通信的问题。就出现了一个fastcgi的协议来解决通信问题。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;网络上有很多关于如何配置 Nginx + FPM 的文章，但它们更多从操作的角度出发，告诉我们怎么做，但却没有告诉我们为什么要这么做，本文从 Nginx 与 FPM 的工作机制出发，探讨配置背后的原理，让我们真正理解 Nginx 与 PHP 是如何协同工作的。&lt;/p&gt;
&lt;h4 id=&quot;内容：&quot;&gt;&lt;a href=&quot;#内容：&quot; class=&quot;headerlink&quot; title=&quot;内容：&quot;&gt;&lt;/a&gt;内容：&lt;/h4&gt;&lt;p&gt;要说 Nginx 与 PHP 是如何协同工作的，首先得说 CGI (Common Gateway Interface) 和 FastCGI 这两个协议。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="Nginx" scheme="https://icocos.github.io/tags/Nginx/"/>
    
      <category term="FPM" scheme="https://icocos.github.io/tags/FPM/"/>
    
  </entry>
  
  <entry>
    <title>LVS负载均衡（LVS简介、三种工作模式、十种调度算法）</title>
    <link href="https://icocos.github.io/2019/01/25/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%88LVS%E7%AE%80%E4%BB%8B%E3%80%81%E4%B8%89%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E3%80%81%E5%8D%81%E7%A7%8D%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%89/"/>
    <id>https://icocos.github.io/2019/01/25/LVS负载均衡（LVS简介、三种工作模式、十种调度算法）/</id>
    <published>2019-01-25T10:47:41.000Z</published>
    <updated>2019-05-22T09:17:26.696Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、LVS简介"><a href="#一、LVS简介" class="headerlink" title="一、LVS简介"></a>一、LVS简介</h3><p>LVS（Linux Virtual Server）即Linux虚拟服务器，是由章文嵩博士主导的开源负载均衡项目，目前LVS已经被集成到Linux内核模块中。</p><p>该项目在Linux内核中实现了基于IP的数据请求负载均衡调度方案，终端互联网用户从外部访问公司的外部负载均衡服务器，终端用户的Web请求会发送给LVS调度器，调度器根据自己预设的算法决定将该请求发送给后端的某台Web服务器，比如，轮询算法可以将外部的请求平均分发给后端的所有服务器，终端用户访问LVS调度器虽然会被转发到后端真实的服务器，但如果真实服务器连接的是相同的存储，提供的服务也是相同的服务，最终用户不管是访问哪台真实服务器，得到的服务内容都是一样的，整个集群对用户而言都是透明的。</p><a id="more"></a><blockquote><p> 最后根据LVS工作模式的不同，真实服务器会选择不同的方式将用户需要的数据发送到终端用户，LVS工作模式分为NAT模式、TUN模式、以及DR模式。</p></blockquote><h3 id="二、三种工作模式的解析。"><a href="#二、三种工作模式的解析。" class="headerlink" title="二、三种工作模式的解析。"></a>二、三种工作模式的解析。</h3><h5 id="1、基于NAT的LVS模式负载均衡"><a href="#1、基于NAT的LVS模式负载均衡" class="headerlink" title="1、基于NAT的LVS模式负载均衡"></a>1、基于NAT的LVS模式负载均衡</h5><p> NAT（Network Address Translation）即网络地址转换，其作用是通过数据报头的修改，使得位于企业内部的私有IP地址可以访问外网，以及外部用用户可以访问位于公司内部的私有IP主机。VS/NAT工作模式拓扑结构如图2所示，LVS负载调度器可以使用两块网卡配置不同的IP地址，eth0设置为私钥IP与内部网络通过交换设备相互连接，eth1设备为外网IP与外部网络联通。</p><ul><li>第一步，用户通过互联网DNS服务器解析到公司负载均衡设备上面的外网地址，相对于真实服务器而言，LVS外网IP又称VIP（Virtual IP Address），用户通过访问VIP，即可连接后端的真实服务器（Real Server），而这一切对用户而言都是透明的，用户以为自己访问的就是真实服务器，但他并不知道自己访问的VIP仅仅是一个调度器，也不清楚后端的真实服务器到底在哪里、有多少真实服务器。</li><li>第二步，用户将请求发送至124.126.147.168，此时LVS将根据预设的算法选择后端的一台真实服务器（192.168.0.1~192.168.0.3），将数据请求包转发给真实服务器，并且在转发之前LVS会修改数据包中的目标地址以及目标端口，目标地址与目标端口将被修改为选出的真实服务器IP地址以及相应的端口。</li><li>第三步，真实的服务器将响应数据包返回给LVS调度器，调度器在得到响应的数据包后会将源地址和源端口修改为VIP及调度器相应的端口，修改完成后，由调度器将响应数据包发送回终端用户，另外，由于LVS调度器有一个连接Hash表，该表中会记录连接请求及转发信息，当同一个连接的下一个数据包发送给调度器时，从该Hash表中可以直接找到之前的连接记录，并根据记录信息选出相同的真实服务器及端口信息。</li></ul><h5 id="2、基于TUN的LVS负载均衡"><a href="#2、基于TUN的LVS负载均衡" class="headerlink" title="2、基于TUN的LVS负载均衡"></a>2、基于TUN的LVS负载均衡</h5><p>在LVS（NAT）模式的集群环境中，由于所有的数据请求及响应的数据包都需要经过LVS调度器转发，如果后端服务器的数量大于10台，则调度器就会成为整个集群环境的瓶颈。我们知道，数据请求包往往远小于响应数据包的大小。因为响应数据包中包含有客户需要的具体数据，所以LVS（TUN）的思路就是将请求与响应数据分离，让调度器仅处理数据请求，而让真实服务器响应数据包直接返回给客户端。</p><p>VS/TUN工作模式拓扑结构如图3所示。其中，IP隧道（IP tunning）是一种数据包封装技术，它可以将原始数据包封装并添加新的包头（内容包括新的源地址及端口、目标地址及端口），从而实现将一个目标为调度器的VIP地址的数据包封装，通过隧道转发给后端的真实服务器（Real Server），通过将客户端发往调度器的原始数据包封装，并在其基础上添加新的数据包头（修改目标地址为调度器选择出来的真实服务器的IP地址及对应端口），LVS（TUN）模式要求真实服务器可以直接与外部网络连接，真实服务器在收到请求数据包后直接给客户端主机响应数据。</p><h5 id="3、基于DR的LVS负载均衡"><a href="#3、基于DR的LVS负载均衡" class="headerlink" title="3、基于DR的LVS负载均衡"></a>3、基于DR的LVS负载均衡</h5><p>在LVS（TUN）模式下，由于需要在LVS调度器与真实服务器之间创建隧道连接，这同样会增加服务器的负担。与LVS（TUN）类似，DR模式也叫直接路由模式，其体系结构如图4所示，该模式中LVS依然仅承担数据的入站请求以及根据算法选出合理的真实服务器，最终由后端真实服务器负责将响应数据包发送返回给客户端。与隧道模式不同的是，直接路由模式（DR模式）要求调度器与后端服务器必须在同一个局域网内，VIP地址需要在调度器与后端所有的服务器间共享，因为最终的真实服务器给客户端回应数据包时需要设置源IP为VIP地址，目标IP为客户端IP，这样客户端访问的是调度器的VIP地址，回应的源地址也依然是该VIP地址（真实服务器上的VIP），客户端是感觉不到后端服务器存在的。由于多台计算机都设置了同样一个VIP地址，所以在直接路由模式中要求调度器的VIP地址是对外可见的，客户端需要将请求数据包发送到调度器主机，而所有的真实服务器的VIP地址必须配置在Non-ARP的网络设备上，也就是该网络设备并不会向外广播自己的MAC及对应的IP地址，真实服务器的VIP对外界是不可见的，但真实服务器却可以接受目标地址VIP的网络请求，并在回应数据包时将源地址设置为该VIP地址。调度器根据算法在选出真实服务器后，在不修改数据报文的情况下，将数据帧的MAC地址修改为选出的真实服务器的MAC地址，通过交换机将该数据帧发给真实服务器。整个过程中，真实服务器的VIP不需要对外界可见。</p><h3 id="三、LVS负载均衡调度算法"><a href="#三、LVS负载均衡调度算法" class="headerlink" title="三、LVS负载均衡调度算法"></a>三、LVS负载均衡调度算法</h3><p>根据前面的介绍，我们了解了LVS的三种工作模式，但不管实际环境中采用的是哪种模式，调度算法进行调度的策略与算法都是LVS的核心技术，LVS在内核中主要实现了一下十种调度算法。</p><h5 id="1-轮询调度"><a href="#1-轮询调度" class="headerlink" title="1.轮询调度"></a>1.轮询调度</h5><p>轮询调度（Round Robin 简称’RR’）算法就是按依次循环的方式将请求调度到不同的服务器上，该算法最大的特点就是实现简单。轮询算法假设所有的服务器处理请求的能力都一样的，调度器会将所有的请求平均分配给每个真实服务器。</p><h5 id="2-加权轮询调度"><a href="#2-加权轮询调度" class="headerlink" title="2.加权轮询调度"></a>2.加权轮询调度</h5><p>加权轮询（Weight Round Robin 简称’WRR’）算法主要是对轮询算法的一种优化与补充，LVS会考虑每台服务器的性能，并给每台服务器添加一个权值，如果服务器A的权值为1，服务器B的权值为2，则调度器调度到服务器B的请求会是服务器A的两倍。权值越高的服务器，处理的请求越多。</p><h5 id="3-最小连接调度"><a href="#3-最小连接调度" class="headerlink" title="3.最小连接调度"></a>3.最小连接调度</h5><p>最小连接调度（Least Connections 简称’LC’）算法是把新的连接请求分配到当前连接数最小的服务器。最小连接调度是一种动态的调度算法，它通过服务器当前活跃的连接数来估计服务器的情况。调度器需要记录各个服务器已建立连接的数目，当一个请求被调度到某台服务器，其连接数加1；当连接中断或者超时，其连接数减1。</p><p>（集群系统的真实服务器具有相近的系统性能，采用最小连接调度算法可以比较好地均衡负载。)</p><h5 id="4-加权最小连接调度"><a href="#4-加权最小连接调度" class="headerlink" title="4.加权最小连接调度"></a>4.加权最小连接调度</h5><p>加权最少连接（Weight Least Connections 简称’WLC’）算法是最小连接调度的超集，各个服务器相应的权值表示其处理性能。服务器的缺省权值为1，系统管理员可以动态地设置服务器的权值。加权最小连接调度在调度新连接时尽可能使服务器的已建立连接数和其权值成比例。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。</p><h5 id="5-基于局部的最少连接"><a href="#5-基于局部的最少连接" class="headerlink" title="5.基于局部的最少连接"></a>5.基于局部的最少连接</h5><p>基于局部的最少连接调度（Locality-Based Least Connections 简称’LBLC’）算法是针对请求报文的目标IP地址的 负载均衡调度，目前主要用于Cache集群系统，因为在Cache集群客户请求报文的目标IP地址是变化的。这里假设任何后端服务器都可以处理任一请求，算法的设计目标是在服务器的负载基本平衡情况下，将相同目标IP地址的请求调度到同一台服务器，来提高各台服务器的访问局部性和Cache命中率，从而提升整个集群系统的处理能力。LBLC调度算法先根据请求的目标IP地址找出该目标IP地址最近使用的服务器，若该服务器是可用的且没有超载，将请求发送到该服务器；若服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则使用’最少连接’的原则选出一个可用的服务器，将请求发送到服务器。</p><h5 id="6-带复制的基于局部性的最少连接"><a href="#6-带复制的基于局部性的最少连接" class="headerlink" title="6.带复制的基于局部性的最少连接"></a>6.带复制的基于局部性的最少连接</h5><p>带复制的基于局部性的最少连接（Locality-Based Least Connections with Replication  简称’LBLCR’）算法也是针对目标IP地址的负载均衡，目前主要用于Cache集群系统，它与LBLC算法不同之处是它要维护从一个目标IP地址到一组服务器的映射，而LBLC算法维护从一个目标IP地址到一台服务器的映射。按’最小连接’原则从该服务器组中选出一一台服务器，若服务器没有超载，将请求发送到该服务器；若服务器超载，则按’最小连接’原则从整个集群中选出一台服务器，将该服务器加入到这个服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。</p><h5 id="7-目标地址散列调度"><a href="#7-目标地址散列调度" class="headerlink" title="7.目标地址散列调度"></a>7.目标地址散列调度</h5><p>目标地址散列调度（Destination Hashing 简称’DH’）算法先根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且并未超载，将请求发送到该服务器，否则返回空。</p><h5 id="8-源地址散列调度U"><a href="#8-源地址散列调度U" class="headerlink" title="8.源地址散列调度U"></a>8.源地址散列调度U</h5><p>源地址散列调度（Source Hashing  简称’SH’）算法先根据请求的源IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且并未超载，将请求发送到该服务器，否则返回空。它采用的散列函数与目标地址散列调度算法的相同，它的算法流程与目标地址散列调度算法的基本相似。</p><h5 id="9-最短的期望的延迟"><a href="#9-最短的期望的延迟" class="headerlink" title="9.最短的期望的延迟"></a>9.最短的期望的延迟</h5><p>最短的期望的延迟调度（Shortest Expected Delay 简称’SED’）算法基于WLC算法。举个例子吧，ABC三台服务器的权重分别为1、2、3 。那么如果使用WLC算法的话一个新请求进入时它可能会分给ABC中的任意一个。使用SED算法后会进行一个运算</p><p>A：（1+1）/1=2   B：（1+2）/2=3/2   C：（1+3）/3=4/3   就把请求交给得出运算结果最小的服务器。</p><h5 id="10-最少队列调度"><a href="#10-最少队列调度" class="headerlink" title="10.最少队列调度"></a>10.最少队列调度</h5><p>最少队列调度（Never Queue 简称’NQ’）算法，无需队列。如果有realserver的连接数等于0就直接分配过去，不需要在进行SED运算。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、LVS简介&quot;&gt;&lt;a href=&quot;#一、LVS简介&quot; class=&quot;headerlink&quot; title=&quot;一、LVS简介&quot;&gt;&lt;/a&gt;一、LVS简介&lt;/h3&gt;&lt;p&gt;LVS（Linux Virtual Server）即Linux虚拟服务器，是由章文嵩博士主导的开源负载均衡项目，目前LVS已经被集成到Linux内核模块中。&lt;/p&gt;
&lt;p&gt;该项目在Linux内核中实现了基于IP的数据请求负载均衡调度方案，终端互联网用户从外部访问公司的外部负载均衡服务器，终端用户的Web请求会发送给LVS调度器，调度器根据自己预设的算法决定将该请求发送给后端的某台Web服务器，比如，轮询算法可以将外部的请求平均分发给后端的所有服务器，终端用户访问LVS调度器虽然会被转发到后端真实的服务器，但如果真实服务器连接的是相同的存储，提供的服务也是相同的服务，最终用户不管是访问哪台真实服务器，得到的服务内容都是一样的，整个集群对用户而言都是透明的。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
</feed>
