<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iCocos</title>
  
  <subtitle>www.icocos.cn</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://icocos.github.io/"/>
  <updated>2019-05-22T09:04:41.409Z</updated>
  <id>https://icocos.github.io/</id>
  
  <author>
    <name>曹理鹏@iCocos</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>架构篇——MySQL高可用集群(PXC)详解</title>
    <link href="https://icocos.github.io/2019/06/11/%E6%9E%B6%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4-PXC-%E8%AF%A6%E8%A7%A3/"/>
    <id>https://icocos.github.io/2019/06/11/架构篇——MySQL高可用集群-PXC-详解/</id>
    <published>2019-06-11T09:56:41.000Z</published>
    <updated>2019-05-22T09:04:41.409Z</updated>
    
    <content type="html"><![CDATA[<h5 id="在介绍PXC之前，先来看一个相关的技术：MyCat"><a href="#在介绍PXC之前，先来看一个相关的技术：MyCat" class="headerlink" title="在介绍PXC之前，先来看一个相关的技术：MyCat"></a>在介绍PXC之前，先来看一个相关的技术：MyCat</h5><h3 id="MyCat简介"><a href="#MyCat简介" class="headerlink" title="MyCat简介"></a>MyCat简介</h3><p>MyCat是阿里开源的分布式数据库分库分表中间件</p><blockquote><p>MyCat是一个开源的分布式数据库系统，是一个实现了MySQL协议的服务器，前端用户可以把它看作是一个数据库代理，用MySQL客户端工具和命令行访问，而其后端可以用MySQL原生协议与多个MySQL服务器通信，也可以用JDBC协议与大多数主流数据库服务器通信</p></blockquote><h4 id="MyCat功能"><a href="#MyCat功能" class="headerlink" title="MyCat功能:"></a>MyCat功能:</h4><ul><li>数据库读写分离(写操作在主,读操作在从数据库)</li><li>读的负载均衡(一主多从)</li><li>垂直拆分(将表分开为多个数据库)</li><li>水平拆分(对表取模拆分)</li></ul><a id="more"></a><blockquote><p>MyCAT是mysql中间件，前身是阿里大名鼎鼎的Cobar，Cobar在开源了一段时间后，不了了之。于是MyCAT扛起了这面大旗，在大数据时代，其重要性愈发彰显。这篇文章主要是MyCAT的入门部署。</p></blockquote><ul><li>更多相关可以参考这里：<a href="https://www.jianshu.com/p/c6e29d724fca" target="_blank" rel="noopener">https://www.jianshu.com/p/c6e29d724fca</a></li></ul><p>下面是MyCat结合PXC的架构图</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2019/phps/pxc.png"></p><h3 id="PXC简介"><a href="#PXC简介" class="headerlink" title="PXC简介"></a>PXC简介</h3><p>PXC是percona公司的percona  xtraDB  cluster，简称PXC。它是基于Galera协议的高可用集群方案。可以实现多个节点间的数据同步复制以及读写，并且可保障数据库的服务高可用及数据强一致性。</p><blockquote><p>PXC就属于一套近乎完美的MySQL高可用集群架构方案；</p></blockquote><h5 id="主要特点是：-读写强一致性-牺牲性能"><a href="#主要特点是：-读写强一致性-牺牲性能" class="headerlink" title="主要特点是： 读写强一致性(牺牲性能)"></a>主要特点是： 读写强一致性(牺牲性能)</h5><h5 id="PXC特性"><a href="#PXC特性" class="headerlink" title="PXC特性"></a>PXC特性</h5><ul><li>1）同步复制，事务要么在所有节点提交或不提交。</li><li>2）多主复制，可以在任意节点进行写操作。</li><li>3）在从服务器上并行应用事件，真正意义上的并行复制。</li><li>4）节点自动配置，数据一致性，不再是异步复制。</li></ul><p>PXC最大的优势：强一致性、无同步延迟</p><ul><li><p>优点总结：</p><ul><li>服务高可用</li><li>可以达到时时同步(并发复制)，无延迟现象发生</li><li>完全兼容MySQL</li><li>对于集群中新节点的加入(自动部署)，维护起来很简单</li><li>数据的强一致性</li><li>多个可同时读写节点，可实现写扩展，不过最好事先进行分库分表，让各个节点分别写不同的表或者库，避免让galera解决数据冲突；</li></ul></li><li><p>不足之处总结：</p><ul><li>只支持Innodb存储引擎</li><li>存在多节点update更新问题，也就是写放大问题</li><li>在线DDL语句，锁表问题</li><li>sst针对新节点加入的传输代价过高的问题</li><li>所有表都要有主键；</li><li>不支持LOCK TABLE等显式锁操作；</li><li>锁冲突、死锁问题相对更多；</li><li>不支持XA；</li></ul></li></ul><p>事实上，采用PXC的主要目的是解决数据的一致性问题，高可用是顺带实现的。因为PXC存在写扩大以及短板效应，并发效率会有较大损失，类似semi sync replication机制。</p><pre><code>网络说明基于Galere协议的高可用方案：pxc+ Galera是Codership提供的多主数据同步复制机制，可以实现多个节点间的数据同步复制以及读写，并且+ 可保障数据库的服务高可用及数据一致性。+ 基于Galera的高可用方案主要有MariaDB Galera Cluster和Percona XtraDB Cluster（简称PXC），目前PXC用的会比较多一些。+ mariadb的集群原理跟PXC一样,maridb-cluster其实就是PXC，两者原理是一样的。</code></pre><h3 id="PXC原理"><a href="#PXC原理" class="headerlink" title="PXC原理"></a>PXC原理</h3><p>Percona XtraDB Cluster（简称PXC集群）提供了MySQL高可用的一种实现方法。</p><ul><li>1）集群是有节点组成的，推荐配置至少3个节点，但是也可以运行在2个节点上。</li><li>2）每个节点都是普通的mysql/percona服务器，可以将现有的数据库服务器组成集群，反之，也可以将集群拆分成单独的服务器。</li><li>3）每个节点都包含完整的数据副本。</li></ul><p>PXC集群主要由两部分组成：Percona Server with XtraDB和Write Set Replication patches（使用了Galera library，一个通用的用于事务型应用的同步、多主复制插件）。</p><p>PXC会使用大概是4个端口号</p><ul><li>3306 数据库对外服务的端口号</li><li>4444 请求SST SST: 指数据一个镜象传输 xtrabackup , rsync ,mysqldump </li><li>4567 : 组成员之间进行沟通的一个端口号</li><li>4568 : 传输IST用的。相对于SST来说的一个增量。</li></ul><blockquote><p>注：安装PXC过程中， iptables 禁掉 ，selinux 也禁掉</p></blockquote><h3 id="PXC的操作流程："><a href="#PXC的操作流程：" class="headerlink" title="PXC的操作流程："></a>PXC的操作流程：</h3><ul><li>首先客户端先发起一个事务，该事务先在本地执行，执行完成之后就要发起对事务的提交操作了。</li><li>在提交之前需要将产生的复制写集广播出去，然后获取到一个全局的事务ID号，一并传送到另一个节点上面。</li><li>通过合并数据之后，发现没有冲突数据，执行apply_cd和commit_cb动作，否则就需要取消此次事务的操作。</li><li>当前server节点通过验证之后，执行提交操作，并返回OK，如果验证没通过，则执行回滚。</li><li>在生产中至少要有3个节点的集群环境，如果其中一个节点没有验证通过，出现了数据冲突，那么此时采取的方式就是讲出现不一致的节点踢出集群环境，而且它自己会执行shutdown命令，自动关机。</li></ul><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>部署环境： CentOS7.X</p><h5 id="1、执行-命令-vi-etc-selinux-config"><a href="#1、执行-命令-vi-etc-selinux-config" class="headerlink" title="1、执行 命令   vi /etc/selinux/config"></a>1、执行 命令   vi /etc/selinux/config</h5><pre><code>SELINUX=disabled   #修改该项为disabled</code></pre><h5 id="2、执行命令-setenforce-0"><a href="#2、执行命令-setenforce-0" class="headerlink" title="2、执行命令   setenforce 0"></a>2、执行命令   setenforce 0</h5><h5 id="3、查看防火墙是否开启-systemctl-status-firewalld"><a href="#3、查看防火墙是否开启-systemctl-status-firewalld" class="headerlink" title="3、查看防火墙是否开启     systemctl status firewalld"></a>3、查看防火墙是否开启     systemctl status firewalld</h5><p>如果防火墙是开启状态，则开放端口 3306 、4444、4567、4568</p><pre><code>firewall-cmd --add-port=3306/tcp --permanent     #开放了3306端口</code></pre><p>开放完4个端口后，重新加载防火墙规则</p><pre><code>firewall-cmd --reload</code></pre><h5 id="4、安装Persona仓库"><a href="#4、安装Persona仓库" class="headerlink" title="4、安装Persona仓库"></a>4、安装Persona仓库</h5><pre><code>yum install http://www.percona.com/downloads/percona-release/redhat/0.1-4/percona-release-0.1-4.noarch.rpm</code></pre><h5 id="5、安装PXC（保证服务器没有装MySQL）卸载MySQL-参考链接：https-blog-csdn-net-tjcyjd-article-details-52189182"><a href="#5、安装PXC（保证服务器没有装MySQL）卸载MySQL-参考链接：https-blog-csdn-net-tjcyjd-article-details-52189182" class="headerlink" title="5、安装PXC（保证服务器没有装MySQL）卸载MySQL 参考链接：https://blog.csdn.net/tjcyjd/article/details/52189182"></a>5、安装PXC（保证服务器没有装MySQL）卸载MySQL 参考链接：<a href="https://blog.csdn.net/tjcyjd/article/details/52189182" target="_blank" rel="noopener">https://blog.csdn.net/tjcyjd/article/details/52189182</a></h5><pre><code>yum install Percona-XtraDB-Cluster-57</code></pre><h5 id="6、开启PXC服务"><a href="#6、开启PXC服务" class="headerlink" title="6、开启PXC服务"></a>6、开启PXC服务</h5><pre><code>service mysql start</code></pre><h5 id="7、查看安装数据库的临时密码并记住"><a href="#7、查看安装数据库的临时密码并记住" class="headerlink" title="7、查看安装数据库的临时密码并记住"></a>7、查看安装数据库的临时密码并记住</h5><pre><code>grep &apos;temporary password&apos; /var/log/mysqld.log</code></pre><h5 id="8、登录MySQL数据库"><a href="#8、登录MySQL数据库" class="headerlink" title="8、登录MySQL数据库"></a>8、登录MySQL数据库</h5><pre><code>mysql -u root -p</code></pre><p>输入临时密码, 登录成功后修改密码</p><pre><code>ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;你的密码&apos;;</code></pre><h5 id="9、停止MySQL服务"><a href="#9、停止MySQL服务" class="headerlink" title="9、停止MySQL服务"></a>9、停止MySQL服务</h5><pre><code>service mysql stop   （某些版本使用mysqld）</code></pre><h5 id="10、配置节点"><a href="#10、配置节点" class="headerlink" title="10、配置节点"></a>10、配置节点</h5><pre><code>vi  /etc/percona-xtradb-cluster.conf.d/wsrep.cnf</code></pre><p>修改配置文件</p><pre><code># Cluster connection URL contains IPs of nodes#If no IP is found, this implies that a new cluster needs to be created,#in order to do that you need to bootstrap this node#集群中节点的IP地址（本机填最后）wsrep_cluster_address=gcomm://ip地址,IP地址,IP地址（用,号隔开）# In order for Galera to work correctly binlog format should be ROWbinlog_format=ROW# MyISAM storage engine has only experimental supportdefault_storage_engine=InnoDB# Slave thread to usewsrep_slave_threads= 8wsrep_log_conflicts# This changes how InnoDB autoincrement locks are managed and is a requirement for Galerainnodb_autoinc_lock_mode=2# Node IP address#当前节点IPwsrep_node_address=IP地址# Cluster name#集群名称wsrep_cluster_name=pxc-cluster#If wsrep_node_name is not specified,  then system hostname will be used#当前节点名称wsrep_node_name=pxc-cluster-node-1#pxc_strict_mode allowed values: DISABLED,PERMISSIVE,ENFORCING,MASTER#不使用实验功能pxc_strict_mode=ENFORCING# SST method#状态快照传输（sst）方法，官方建议wsrep_sst_method=xtrabackup-v2#Authentication for SST method#用户凭证（mysql的用户名和密码）wsrep_sst_auth=&quot;用户名:密码&quot;</code></pre><p>剩下的节点修改当前节点名、当前节点IP、集群中的节点IP，其他相同</p><blockquote><p>注：1—10步骤  每个节点都要配置一次</p></blockquote><h5 id="11、初始化集群节点"><a href="#11、初始化集群节点" class="headerlink" title="11、初始化集群节点"></a>11、初始化集群节点</h5><p>其中一个节点使用 systemctl start <a href="mailto:mysql@bootstrap.service" target="_blank" rel="noopener">mysql@bootstrap.service</a> 启动</p><h6 id="登录mysql"><a href="#登录mysql" class="headerlink" title="登录mysql"></a>登录mysql</h6><pre><code>mysql -u root -p</code></pre><p>开启 wsrep_causal_reads</p><pre><code>set wsrep_causal_reads =1;</code></pre><h5 id="12、创建配置文件中对应的用户"><a href="#12、创建配置文件中对应的用户" class="headerlink" title="12、创建配置文件中对应的用户"></a>12、创建配置文件中对应的用户</h5><blockquote><p>所有节点的IP都要创建</p></blockquote><p>创建用户：    </p><pre><code>CREATE USER &apos;用户名&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;密码&apos;;  </code></pre><p>刷新权限：   </p><pre><code>GRANT all privileges ON *.* TO &apos;用户名&apos;@&apos;localhost&apos; ;FLUSH PRIVILEGES;</code></pre><p>创建用户：</p><pre><code>CREATE USER &apos;用户名&apos;@&apos;当前需要访问数据库的IP地址&apos; IDENTIFIED BY &apos;密码&apos;;  </code></pre><p>刷新权限：</p><pre><code>GRANT all privileges ON *.* TO &apos;用户名&apos;@&apos;当前节点IP地址&apos; ;FLUSH PRIVILEGES;</code></pre><h5 id="13、其他节点使用-service-mysql-start-启动-，登录mysql，配置wsrep-causal-reds，set-wsrep-causal-reads-1"><a href="#13、其他节点使用-service-mysql-start-启动-，登录mysql，配置wsrep-causal-reds，set-wsrep-causal-reads-1" class="headerlink" title="13、其他节点使用   service mysql start  启动 ，登录mysql，配置wsrep_causal_reds，set wsrep_causal_reads =1;"></a>13、其他节点使用   service mysql start  启动 ，登录mysql，配置wsrep_causal_reds，set wsrep_causal_reads =1;</h5><h5 id="14、其他节点启动成功后在引导节点（使用-systemctl-start-mysql-bootstrap-service-命令启动的节点）"><a href="#14、其他节点启动成功后在引导节点（使用-systemctl-start-mysql-bootstrap-service-命令启动的节点）" class="headerlink" title="14、其他节点启动成功后在引导节点（使用 systemctl start mysql@bootstrap.service 命令启动的节点）"></a>14、其他节点启动成功后在引导节点（使用 systemctl start <a href="mailto:mysql@bootstrap.service" target="_blank" rel="noopener">mysql@bootstrap.service</a> 命令启动的节点）</h5><p>验证集群：</p><pre><code>show status like &apos;wsrep%&apos;;  </code></pre><h5 id="15、节点数据同步验证"><a href="#15、节点数据同步验证" class="headerlink" title="15、节点数据同步验证"></a>15、节点数据同步验证</h5><p>在当前节点创建一个数据库 </p><pre><code>CREATE DATABASE percona;</code></pre><p>启动其他节点的数据库服务，进去后会发现新建的数据库，同理 其他节点创建的数据  当前节点也能看到</p><p>注意：服务的启动和停止要对应</p><pre><code>service mysql stop   ------&gt;  启动时用service mysql start</code></pre><p>或者 </p><pre><code>systemctl stop mysql@bootstrap.service   -----&gt;  启用是用 systemctl start mysql@bootstrap.service </code></pre><ul><li>更多相关实战配置可以参考这里：<a href="https://www.jianshu.com/p/0b7c050dfab6" target="_blank" rel="noopener">https://www.jianshu.com/p/0b7c050dfab6</a></li></ul><h5 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h5><ul><li>带你玩转Mysql高可用方案–PXC<ul><li><a href="https://blog.csdn.net/zisefeizhu/article/details/81873466" target="_blank" rel="noopener">https://blog.csdn.net/zisefeizhu/article/details/81873466</a></li></ul></li><li><p>Docker搭建PXC集群</p><ul><li><a href="https://blog.csdn.net/weixin_41141219/article/details/82767832" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41141219/article/details/82767832</a></li></ul></li><li><p>MySQL高可用方案－PXC环境部署记录: 详细教程</p><ul><li><a href="http://www.cnblogs.com/kevingrace/p/5685371.html" target="_blank" rel="noopener">http://www.cnblogs.com/kevingrace/p/5685371.html</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;在介绍PXC之前，先来看一个相关的技术：MyCat&quot;&gt;&lt;a href=&quot;#在介绍PXC之前，先来看一个相关的技术：MyCat&quot; class=&quot;headerlink&quot; title=&quot;在介绍PXC之前，先来看一个相关的技术：MyCat&quot;&gt;&lt;/a&gt;在介绍PXC之前，先来看一个相关的技术：MyCat&lt;/h5&gt;&lt;h3 id=&quot;MyCat简介&quot;&gt;&lt;a href=&quot;#MyCat简介&quot; class=&quot;headerlink&quot; title=&quot;MyCat简介&quot;&gt;&lt;/a&gt;MyCat简介&lt;/h3&gt;&lt;p&gt;MyCat是阿里开源的分布式数据库分库分表中间件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MyCat是一个开源的分布式数据库系统，是一个实现了MySQL协议的服务器，前端用户可以把它看作是一个数据库代理，用MySQL客户端工具和命令行访问，而其后端可以用MySQL原生协议与多个MySQL服务器通信，也可以用JDBC协议与大多数主流数据库服务器通信&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;MyCat功能&quot;&gt;&lt;a href=&quot;#MyCat功能&quot; class=&quot;headerlink&quot; title=&quot;MyCat功能:&quot;&gt;&lt;/a&gt;MyCat功能:&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;数据库读写分离(写操作在主,读操作在从数据库)&lt;/li&gt;
&lt;li&gt;读的负载均衡(一主多从)&lt;/li&gt;
&lt;li&gt;垂直拆分(将表分开为多个数据库)&lt;/li&gt;
&lt;li&gt;水平拆分(对表取模拆分)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="MySQL" scheme="https://icocos.github.io/tags/MySQL/"/>
    
      <category term="PXC集群" scheme="https://icocos.github.io/tags/PXC%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>架构篇——MySQL主从复制(Master-Slave)详解</title>
    <link href="https://icocos.github.io/2019/06/09/%E6%9E%B6%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-Master-Slave-%E8%AF%A6%E8%A7%A3/"/>
    <id>https://icocos.github.io/2019/06/09/架构篇——MySQL主从复制-Master-Slave-详解/</id>
    <published>2019-06-09T09:55:42.000Z</published>
    <updated>2019-05-22T09:04:36.347Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h3><p>Mysql主从又叫Replication、AB复制(不同于PXC)。简单讲就是A与B两台机器做主从后，在A上写数据，另外一台B也会跟着写数据，实现数据实时同步</p><blockquote><p>mysql主从是基于binlog，主上需开启binlog才能进行主从</p></blockquote><h5 id="主从过程大概有3个步骤"><a href="#主从过程大概有3个步骤" class="headerlink" title="主从过程大概有3个步骤"></a>主从过程大概有3个步骤</h5><ul><li>主将更改操作记录到binlog里</li><li>从将主的binlog事件（sql语句） 同步本机上并记录在relaylog里</li><li>从根据relaylog里面的sql语句按顺序执行</li></ul><a id="more"></a><h4 id="主从作用"><a href="#主从作用" class="headerlink" title="主从作用"></a>主从作用</h4><pre><code>实时灾备，用于故障切换读写分离，提供查询服务备份，避免影响业务</code></pre><h4 id="主从形式"><a href="#主从形式" class="headerlink" title="主从形式"></a>主从形式</h4><ul><li>一主一从</li><li>主主复制</li><li>一主多从—扩展系统读取的性能，因为读是在从库读取的</li><li>多主一从—5.7版本开始支持</li><li>联级复制</li></ul><p>MySQL数据库自身提供的主从复制功能可以方便的实现数据的多处自动备份，实现数据库的拓展。多个数据备份不仅可以加强数据的安全性，通过实现读写分离还能进一步提升数据库的负载性能。</p><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><blockquote><p>MySQL之间数据复制的基础是二进制日志文件（binary log file）。一台MySQL数据库一旦启用二进制日志后，其作为master，它的数据库中所有操作都会以“事件”的方式记录在二进制日志中，其他数据库作为slave通过一个I/O线程与主服务器保持通信，并监控master的二进制日志文件的变化，如果发现master二进制日志文件发生变化，则会把变化复制到自己的中继日志中，然后slave的一个SQL线程会把相关的“事件”执行到自己的数据库中，以此实现从数据库和主数据库的一致性，也就实现了主从复制。</p></blockquote><ul><li>主库将所有的写操作记录在binlog日志中，并生成log dump线程，将binlog日志传给从库的I/O线程</li><li>从库生成两个线程，一个是I/O线程，另一个是SQL线程</li><li>I/O线程去请求主库的binlog日志，并将binlog日志中的文件写入relay log（中继日志）中</li><li>SQL线程会读取relay loy中的内容，并解析成具体的操作，来实现主从的操作一致，达到最终数据一致的目的</li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>实现MySQL主从复制需要进行的配置：</p><ul><li><p>主服务器：</p><ul><li>开启二进制日志</li><li>配置唯一的server-id</li><li>获得master二进制日志文件名及位置</li><li>创建一个用于slave和master通信的用户账号</li></ul></li><li><p>从服务器：</p><ul><li>配置唯一的server-id</li><li>使用master分配的用户账号读取master二进制日志</li><li>启用slave服务</li></ul></li></ul><h4 id="具体实现过程如下："><a href="#具体实现过程如下：" class="headerlink" title="具体实现过程如下："></a>具体实现过程如下：</h4><p>主从复制配置步骤：</p><ul><li>确保从数据库与主数据库里的数据一致</li><li>在主数据库里创建一个同步账户授权给从数据库使用</li><li>配合主数据库（修改配置文件）</li><li>配置从数据库（修改配置文件）</li></ul><h5 id="一、准备工作："><a href="#一、准备工作：" class="headerlink" title="一、准备工作："></a>一、准备工作：</h5><ol><li>主从数据库版本最好一致</li><li>主从数据库内数据保持一致</li></ol><p>搭建两台MYSQL服务器，一台作为主服务器，一台作为从服务器，主服务器进行写操作，从服务器进行读操作</p><pre><code>+ 主数据库：192.168.0.1 /Linux-MySQL+ 从数据库：192.168.0.2 /Linux-MySQL</code></pre><h5 id="二、主数据库master修改："><a href="#二、主数据库master修改：" class="headerlink" title="二、主数据库master修改："></a>二、主数据库master修改：</h5><p>1.修改mysql配置</p><p>找到主数据库的配置文件my.cnf(或者my.ini)，我的在/etc/mysql/my.cnf,在[mysqld]部分插入如下两行：</p><pre><code>[mysqld]log-bin=mysql-bin #开启二进制日志server-id=1 #设置server-id</code></pre><p>2.重启mysql，创建用于同步的用户账号</p><p>打开mysql会话shell</p><pre><code>mysql -hlocalhost -uname -ppassword</code></pre><p>创建用户：用户：rel1密码：slavepass</p><p>3.授权</p><p>主服务器授权从服务器特定账号登录</p><pre><code>mysql&gt; CREATE USER &apos;repl&apos;@&apos;192.168.0.2&apos; IDENTIFIED BY &apos;slavepass&apos;;#创建用户mysql&gt; GRANT REPLICATION SLAVE ON *.* TO &apos;repl&apos;@&apos;192.168.0.2&apos;;#分配权限mysql&gt;flush privileges;   #刷新权限</code></pre><p>4.查看master状态，记录二进制文件名(mysql-bin.000003)和位置(73)：</p><pre><code>mysql &gt; SHOW MASTER STATUS;+------------------+----------+--------------+------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |+------------------+----------+--------------+------------------+| mysql-bin.000003 | 73       | test         | manual,mysql     |+------------------+----------+--------------+------------------+</code></pre><h5 id="三、从服务器slave修改："><a href="#三、从服务器slave修改：" class="headerlink" title="三、从服务器slave修改："></a>三、从服务器slave修改：</h5><p>1.修改mysql配置</p><p>同样找到my.cnf配置文件，添加server-id</p><pre><code>[mysqld]server-id=2 #设置server-id，必须唯一</code></pre><p>2.重启mysql，打开mysql会话，执行同步SQL语句(需要主服务器主机名，登陆凭据，二进制文件的名称和位置)：<br>复制代码</p><pre><code>mysql&gt; CHANGE MASTER TO    -&gt;     MASTER_HOST=&apos;192.168.0.1&apos;,    -&gt;     MASTER_USER=&apos;rep1&apos;,    -&gt;     MASTER_PASSWORD=&apos;slavepass&apos;,    -&gt;     MASTER_LOG_FILE=&apos;mysql-bin.000003&apos;,    -&gt;     MASTER_LOG_POS=73;</code></pre><p>3.启动slave同步进程：</p><pre><code>mysql&gt;start slave;</code></pre><p>4.查看slave状态：</p><pre><code>mysql&gt; show slave status\G;*************************** 1. row ***************************               Slave_IO_State: Waiting for master to send event                  Master_Host: 192.168.0.1                  Master_User: rep1                  Master_Port: 3306                Connect_Retry: 60              Master_Log_File: mysql-bin.000013          Read_Master_Log_Pos: 11662               Relay_Log_File: mysqld-relay-bin.000022                Relay_Log_Pos: 11765        Relay_Master_Log_File: mysql-bin.000013             Slave_IO_Running: Yes            Slave_SQL_Running: Yes              Replicate_Do_DB:           Replicate_Ignore_DB:         ...</code></pre><p>当Slave_IO_Running和Slave_SQL_Running都为YES的时候就表示主从同步设置成功了。</p><p>接下来就可以进行一些验证了，比如在主master数据库的test数据库的一张表中插入一条数据，在slave的test库的相同数据表中查看是否有新增的数据即可验证主从复制功能是否有效，还可以关闭slave（mysql&gt;stop slave;）,然后再修改master，看slave是否也相应修改（停止slave后，master的修改不会同步到slave），就可以完成主从复制功能的验证了。</p><p>还可以用到的其他相关参数：</p><blockquote><p>master开启二进制日志后默认记录所有库所有表的操作，可以通过配置来指定只记录指定的数据库甚至指定的表的操作，具体在mysql配置文件的[mysqld]可添加修改如下选项：</p></blockquote><pre><code># 不同步哪些数据库  binlog-ignore-db = mysql  binlog-ignore-db = test  binlog-ignore-db = information_schema  # 只同步哪些数据库，除此之外，其他不同步  binlog-do-db = game  </code></pre><blockquote><p>如之前查看master状态时就可以看到只记录了test库，忽略了manual和mysql库。</p></blockquote><h3 id="操作流程汇总"><a href="#操作流程汇总" class="headerlink" title="操作流程汇总"></a>操作流程汇总</h3><h5 id="关闭防火墙以SELINUX"><a href="#关闭防火墙以SELINUX" class="headerlink" title="关闭防火墙以SELINUX"></a>关闭防火墙以SELINUX</h5><pre><code>[root@icocos ~]# systemctl stop firewalld[root@icocos ~]# systemctl disable firewalld[root@icocos ~]#  sed -ri &apos;s/(SELINUX=).*/\1disabled/g&apos; /etc/selinux/config[root@icocos ~]# setenforce 0</code></pre><h5 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h5><pre><code>安装依赖包[root@icocos ~]# yum -y install ncurses-devel openssl-devel openssl cmake mariadb-devel</code></pre><h5 id="创建用户和组"><a href="#创建用户和组" class="headerlink" title="创建用户和组"></a>创建用户和组</h5><pre><code>[root@icocos ~]# groupadd -r -g 306 mysql[root@icocos ~]# useradd -M -s /sbin/nologin -g 306 -u 306 mysql</code></pre><h5 id="下载二进制格式的mysql软件包"><a href="#下载二进制格式的mysql软件包" class="headerlink" title="下载二进制格式的mysql软件包"></a>下载二进制格式的mysql软件包</h5><pre><code>[root@icocos ~]# cd /usr/src/[root@icocos src]#wget https://downloads.mysql.com/archives/get/file/mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz</code></pre><h5 id="解压软件至-usr-local"><a href="#解压软件至-usr-local" class="headerlink" title="解压软件至/usr/local/"></a>解压软件至/usr/local/</h5><pre><code>[root@icocos src]# lsdebug  kernels  mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz[root@icocos src]# tar xf mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz -C /usr/local/[root@icocos src]#  ls  /usr/local/bin  etc  games  include  lib  lib64  libexec  mysql-5.7.22-linux-glibc2.12-x86_64  sbin  share  src[root@icocos src]#  cd  /usr/local/[root@icocos local]# ln -sv mysql-5.7.22-linux-glibc2.12-x86_64/ mysql&quot;mysql&quot; -&gt; &quot;mysql-5.7.22-linux-glibc2.12-x86_64/&quot;[root@icocos local]# ll总用量 0drwxr-xr-x. 2 root root   6 11月  5 2016 bindrwxr-xr-x. 2 root root   6 11月  5 2016 etcdrwxr-xr-x. 2 root root   6 11月  5 2016 gamesdrwxr-xr-x. 2 root root   6 11月  5 2016 includedrwxr-xr-x. 2 root root   6 11月  5 2016 libdrwxr-xr-x. 2 root root   6 11月  5 2016 lib64drwxr-xr-x. 2 root root   6 11月  5 2016 libexeclrwxrwxrwx. 1 root root  36 9月   7 22:20 mysql -&gt; mysql-5.7.22-linux-glibc2.12-x86_64/drwxr-xr-x. 9 root root 129 9月   7 22:19 mysql-5.7.22-linux-glibc2.12-x86_64drwxr-xr-x. 2 root root   6 11月  5 2016 sbindrwxr-xr-x. 5 root root  49 9月   3 23:02 sharedrwxr-xr-x. 2 root root   6 11月  5 2016 src</code></pre><h5 id="修改目录-usr-locaal-mysql的属主属组"><a href="#修改目录-usr-locaal-mysql的属主属组" class="headerlink" title="修改目录/usr/locaal/mysql的属主属组"></a>修改目录/usr/locaal/mysql的属主属组</h5><pre><code>[root@icocos local]# chown -R mysql.mysql /usr/local/mysql[root@icocos local]#  ll /usr/local/mysql -dlrwxrwxrwx. 1 mysql mysql 36 9月   7 22:20 /usr/local/mysql -&gt; mysql-5.7.22-linux-glibc2.12-x86_64/</code></pre><h5 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h5><pre><code>[root@icocos local]# ls /usr/local/mysqlbin  COPYING  docs  include  lib  man  README  share  support-files[root@icocos local]# cd[root@icocos ~]# echo &apos;export PATH=/usr/local/mysql/bin:$PATH&apos; &gt; /etc/profile.d/mysql.sh[root@icocos ~]# . /etc/profile.d/mysql.sh[root@icocos ~]# echo $PATH/usr/local/mysql/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</code></pre><h5 id="建立数据存放目录"><a href="#建立数据存放目录" class="headerlink" title="建立数据存放目录"></a>建立数据存放目录</h5><pre><code>[root@icocos ~]# cd /usr/local/mysql[root@icocos mysql]# mkdir /opt/data[root@icocos mysql]#  chown -R mysql.mysql /opt/data/[root@icocos mysql]#  ll /opt/总用量 0drwxr-xr-x. 2 mysql mysql 6 9月   7 22:25 data</code></pre><h5 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h5><pre><code>[root@icocos mysql]# /usr/local/mysql/bin/mysqld --initialize --user=mysql --datadir=/opt/data///这个命令的最后会生成一个临时密码，此处密码是1EbNA-k*BtKo</code></pre><h5 id="配置mysql"><a href="#配置mysql" class="headerlink" title="配置mysql"></a>配置mysql</h5><pre><code>[root@icocos ~]# ln -sv /usr/local/mysql/include/ /usr/local/include/mysql&quot;/usr/local/include/mysql&quot; -&gt; &quot;/usr/local/mysql/include/&quot;[root@icocos ~]# echo &apos;/usr/local/mysql/lib&apos; &gt; /etc/ld.so.conf.d/mysql.conf[root@icocos ~]#  ldconfig -v</code></pre><h5 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h5><pre><code>[root@icocos ~]# cat &gt; /etc/my.cnf &lt;&lt;EOF&gt; [mysqld]&gt; basedir = /usr/local/mysql&gt; datadir = /opt/data&gt; socket = /tmp/mysql.sock&gt; port = 3306&gt; pid-file = /opt/data/mysql.pid&gt; user = mysql&gt; skip-name-resolve&gt; EOF</code></pre><h5 id="配置服务启动脚本"><a href="#配置服务启动脚本" class="headerlink" title="配置服务启动脚本"></a>配置服务启动脚本</h5><pre><code>[root@icocos ~]# cp -a /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld[root@icocos ~]#  sed -ri &apos;s#^(basedir=).*#\1/usr/local/mysql#g&apos; /etc/init.d/mysqld[root@icocos ~]# sed -ri &apos;s#^(datadir=).*#\1/opt/data#g&apos; /etc/init.d/mysqld</code></pre><h5 id="启动mysql"><a href="#启动mysql" class="headerlink" title="启动mysql"></a>启动mysql</h5><pre><code>[root@icocos ~]#  service mysqld startStarting MySQL.Logging to &apos;/opt/data/icocos.err&apos;... SUCCESS![root@icocos ~]#  ps -ef|grep mysqlroot       4897      1  0 22:38 pts/2    00:00:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/opt/data --pid-file=/opt/data/mysql.pidmysql      5075   4897  6 22:38 pts/2    00:00:01 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/opt/data --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=icocos.err --pid-file=/opt/data/mysql.pid --socket=/tmp/mysql.sock --port=3306root       5109   4668  0 22:38 pts/2    00:00:00 grep --color=auto mysql[root@icocos ~]# ss -antlState       Recv-Q Send-Q                     Local Address:Port                                    Peer Address:Port              LISTEN      0      128                                    *:22                                                 *:*                  LISTEN      0      100                            127.0.0.1:25                                                 *:*                  LISTEN      0      128                                   :::22                                                :::*                  LISTEN      0      100                                  ::1:25                                                :::*                  LISTEN      0      80                                    :::3306                                              :::*                  </code></pre><h5 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h5><p>使用临时密码修改</p><pre><code>[root@icocos ~]# mysql -uroot -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.7.22Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; set password = password(&apos;123456&apos;);Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; quitBye</code></pre><h5 id="mysql主从配置"><a href="#mysql主从配置" class="headerlink" title="mysql主从配置"></a>mysql主从配置</h5><p>确保从数据库与主数据库的数据一样先在主数据库创建所需要同步的库和表</p><pre><code>[root@icocos ~]# mysql -uroot -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 4Server version: 5.7.22 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. AlOracle is a registered trademark of Oracle Corporation andaffiliates. Other names may be trademarks of their respectowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the currmysql&gt; create database yan;Query OK, 1 row affected (0.00 sec)mysql&gt; create database lisi;Query OK, 1 row affected (0.00 sec)mysql&gt; create database wangwu;Query OK, 1 row affected (0.00 sec)mysql&gt; use yan;Database changedmysql&gt; create table tom (id int not null,name varchar(100)not null ,age tinyint);Query OK, 0 rows affected (11.83 sec)mysql&gt; insert tom (id,name,age) values(1,&apos;zhangshan&apos;,20),(2,&apos;wangwu&apos;,7),(3,&apos;lisi&apos;,23);Query OK, 3 rows affected (0.07 sec)Records: 3  Duplicates: 0  Warnings: 0mysql&gt; select * from tom;+----+-----------+------+| id | name      | age  |+----+-----------+------+|  1 | zhangshan |   20 ||  2 | wangwu    |    7 ||  3 | lisi      |   23 |+----+-----------+------+3 rows in set (0.00 sec)</code></pre><h5 id="备份主库"><a href="#备份主库" class="headerlink" title="备份主库"></a>备份主库</h5><p>备份主库时需要另开一个终端，给数据库上读锁，避免在备份期间有其他人在写入导致数据同步的不一致</p><pre><code>[root@icocos ~]# mysql -uroot -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 5Server version: 5.7.22 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; flush tables with read lock;Query OK, 0 rows affected (0.76 sec)</code></pre><p>此锁表的终端必须在备份完成以后才能退出（退出锁表失效）</p><h5 id="备份主库并将备份文件传送到从库"><a href="#备份主库并将备份文件传送到从库" class="headerlink" title="备份主库并将备份文件传送到从库"></a>备份主库并将备份文件传送到从库</h5><pre><code>[root@icocos ~]# mysqldump -uroot -p123456 --all-databases &gt; /opt/all-20180907.sqlmysqldump: [Warning] Using a password on the command line interface can be insecure.[root@icocos ~]# ls /opt/all-20180907.sql  data[root@icocos ~]# scp /opt/all-20180907.sql root@192.168.0.2:/opt/The authenticity of host &apos;192.168.0.2 (192.168.0.2)&apos; can&apos;t be established.ECDSA key fingerprint is SHA256:7mLj77SFk7sPkhjpMPfdK3nZ98hOuyP4OKzjXeijSJ0.ECDSA key fingerprint is MD5:a0:1b:eb:7f:f0:b6:7b:73:97:91:4c:f3:b1:89:d8:ea.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;192.168.0.2&apos; (ECDSA) to the list of known hosts.root@192.168.0.2&apos;s password:all-20180907.sql       100%  784KB 783.3KB/s   00:01    </code></pre><h5 id="解除主库的锁表状态，直接退出交互式界面即可"><a href="#解除主库的锁表状态，直接退出交互式界面即可" class="headerlink" title="解除主库的锁表状态，直接退出交互式界面即可"></a>解除主库的锁表状态，直接退出交互式界面即可</h5><pre><code>mysql&gt; quitBye</code></pre><h5 id="在从库上恢复主库的备份并查看是否与主库的数据保持一致"><a href="#在从库上恢复主库的备份并查看是否与主库的数据保持一致" class="headerlink" title="在从库上恢复主库的备份并查看是否与主库的数据保持一致"></a>在从库上恢复主库的备份并查看是否与主库的数据保持一致</h5><pre><code>[root@icocos ~]# mysql -uroot -p123456 &lt; /opt/all-20180907.sqlmysql: [Warning] Using a password on the command line interface can be insecure.[root@icocos ~]# mysql -uroot -p123456mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 4Server version: 5.7.22 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || lisi               || mysql              || performance_schema || sys                || wangwu             || yan                |+--------------------+7 rows in set (0.18 sec)mysql&gt; use yan;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; select * from tom;+----+-----------+------+| id | name      | age  |+----+-----------+------+|  1 | zhangshan |   20 ||  2 | wangwu    |    7 ||  3 | lisi      |   23 |+----+-----------+------+3 rows in set (0.06 sec)</code></pre><h5 id="在主数据库创建一个同步账户授权给从数据使用"><a href="#在主数据库创建一个同步账户授权给从数据使用" class="headerlink" title="在主数据库创建一个同步账户授权给从数据使用"></a>在主数据库创建一个同步账户授权给从数据使用</h5><pre><code>[root@icocos ~]# mysql -uroot -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 7Server version: 5.7.22 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; create user &apos;repl&apos;@&apos;192.168.0.2&apos; identified by &apos;123456&apos;;Query OK, 0 rows affected (5.50 sec)mysql&gt; grant replication slave on *.* to &apos;repl&apos;@&apos;192.168.0.2&apos;;Query OK, 0 rows affected (0.04 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.09 sec)</code></pre><h5 id="配置主数据库编辑配置文件"><a href="#配置主数据库编辑配置文件" class="headerlink" title="配置主数据库编辑配置文件"></a>配置主数据库编辑配置文件</h5><pre><code>[root@icocos ~]# vim /etc/my.cnf[root@icocos ~]# cat /etc/my.cnf[mysqld]basedir = /usr/local/mysqldatadir = /opt/datasocket = /tmp/mysql.sockport = 3306pid-file = /opt/data/mysql.piduser = mysqlskip-name-resolve//添加以下内容log-bin=mysql-bin //启用binlog日志server-id=1 //主数据库服务器唯一标识符 主的必须必从大log-error=/opt/data/mysql.log</code></pre><h5 id="重启mysql服务"><a href="#重启mysql服务" class="headerlink" title="重启mysql服务"></a>重启mysql服务</h5><pre><code>[root@icocos ~]# service mysqld restartShutting down MySQL..... SUCCESS!Starting MySQL.Logging to &apos;/opt/data/mysql.log&apos;................................ SUCCESS![root@icocos ~]# ss -antlState       Recv-Q Send-Q Local Address:Port               Peer Address:Port              LISTEN      0      128     *:22                  *:*                  LISTEN      0      100    127.0.0.1:25                  *:*                  LISTEN      0      128    :::22                 :::*                  LISTEN      0      100       ::1:25                 :::*                  LISTEN      0      80     :::3306               :::*</code></pre><h5 id="查看主库的状态"><a href="#查看主库的状态" class="headerlink" title="查看主库的状态"></a>查看主库的状态</h5><pre><code>mysql&gt; show master status;+------------------+----------+--------------+------------------+-------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+------------------+----------+--------------+------------------+-------------------+| mysql-bin.000001 |      154 |              |                  |                   |+------------------+----------+--------------+------------------+-------------------+1 row in set (0.00 sec)</code></pre><h5 id="配置从数据库"><a href="#配置从数据库" class="headerlink" title="配置从数据库"></a>配置从数据库</h5><p>编辑配置文件</p><pre><code>[root@icocos ~]# cat /etc/my.cnf[mysqld]basedir = /usr/local/mysqldatadir = /opt/datasocket = /tmp/mysql.sockport = 3306pid-file = /opt/data/mysql.piduser = mysqlskip-name-resolve//添加以下内容：server-id=2 //设置从库的唯一标识符 从的必须比主小relay-log=mysql-relay-bin //启用中继日志relay logerror-log=/opt/data/mysql.log</code></pre><h5 id="重启从库的mysql服务"><a href="#重启从库的mysql服务" class="headerlink" title="重启从库的mysql服务"></a>重启从库的mysql服务</h5><pre><code>[root@icocos ~]# service mysqld restartShutting down MySQL.. SUCCESS!Starting MySQL.. SUCCESS![root@icocos ~]# ss -antlState       Recv-Q Send-Q Local Address:Port               Peer Address:Port              LISTEN      0      128     *:22                  *:*                  LISTEN      0      100    127.0.0.1:25                  *:*                  LISTEN      0      128    :::22                 :::*                  LISTEN      0      100       ::1:25                 :::*                  LISTEN      0      80     :::3306               :::*                  </code></pre><h5 id="配置并启动主从复制"><a href="#配置并启动主从复制" class="headerlink" title="配置并启动主从复制"></a>配置并启动主从复制</h5><pre><code>mysql&gt; change master to    -&gt; master_host=&apos;192.168.0.1&apos;,    -&gt; master_user=&apos;repl&apos;,    -&gt; master_password=&apos;123456&apos;,    -&gt; master_log_file=&apos;mysql-bin.000001&apos;,    -&gt; master_log_pos=154;Query OK, 0 rows affected, 2 warnings (0.28 sec)</code></pre><h5 id="查看从服务器状态"><a href="#查看从服务器状态" class="headerlink" title="查看从服务器状态"></a>查看从服务器状态</h5><pre><code>mysql&gt; show slave status\G;*************************** 1. row ***************************               Slave_IO_State: Waiting for master to send event                  Master_Host: 192.168.0.1                  Master_User: repl                  Master_Port: 3306                Connect_Retry: 60              Master_Log_File: mysql-bin.000001          Read_Master_Log_Pos: 154               Relay_Log_File: mysql-relay-bin.000003                Relay_Log_Pos: 320        Relay_Master_Log_File: mysql-bin.000001             Slave_IO_Running: Yes                                     //此处必须是yes            Slave_SQL_Running: Yes                                    //此处必须是yes                     Replicate_Do_DB:          Replicate_Ignore_DB:           Replicate_Do_Table:       Replicate_Ignore_Table:      Replicate_Wild_Do_Table:  Replicate_Wild_Ignore_Table:                   Last_Errno: 0                   Last_Error:                 Skip_Counter: 0          Exec_Master_Log_Pos: 154              Relay_Log_Space: 527              Until_Condition: None               Until_Log_File:                Until_Log_Pos: 0           Master_SSL_Allowed: No           Master_SSL_CA_File:           Master_SSL_CA_Path:              Master_SSL_Cert:            Master_SSL_Cipher:               Master_SSL_Key:        Seconds_Behind_Master: 0Master_SSL_Verify_Server_Cert: No                Last_IO_Errno: 0                Last_IO_Error:               Last_SQL_Errno: 0               Last_SQL_Error:  Replicate_Ignore_Server_Ids:             Master_Server_Id: 1                  Master_UUID: 5abf1791-b2af-11e8-b6ad-000c2980fbb4             Master_Info_File: /opt/data/master.info                    SQL_Delay: 0          SQL_Remaining_Delay: NULL      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates           Master_Retry_Count: 86400                  Master_Bind:      Last_IO_Error_Timestamp:     Last_SQL_Error_Timestamp:               Master_SSL_Crl:           Master_SSL_Crlpath:           Retrieved_Gtid_Set:            Executed_Gtid_Set:                Auto_Position: 0         Replicate_Rewrite_DB:                 Channel_Name:           Master_TLS_Version:1 row in set (0.00 sec)ERROR:No query specified</code></pre><h5 id="测试验证在主服务器的yan库的tom表插入数据"><a href="#测试验证在主服务器的yan库的tom表插入数据" class="headerlink" title="测试验证在主服务器的yan库的tom表插入数据:"></a>测试验证在主服务器的yan库的tom表插入数据:</h5><pre><code>mysql&gt; use yan;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; select * from tom;+----+-----------+------+| id | name      | age  |+----+-----------+------+|  1 | zhangshan |   20 ||  2 | wangwu    |    7 ||  3 | lisi      |   23 |+----+-----------+------+3 rows in set (0.09 sec)mysql&gt; insert tom(id,name,age) value (4,&quot;yyl&quot;,18);Query OK, 1 row affected (0.14 sec)mysql&gt; select * from tom;+----+-----------+------+| id | name      | age  |+----+-----------+------+|  1 | zhangshan |   20 ||  2 | wangwu    |    7 ||  3 | lisi      |   23 ||  4 | yyl       |   18 |+----+-----------+------+4 rows in set (0.00 sec)</code></pre><h5 id="在从数据库查看是否数据同步"><a href="#在从数据库查看是否数据同步" class="headerlink" title="在从数据库查看是否数据同步"></a>在从数据库查看是否数据同步</h5><pre><code>mysql&gt; use yan;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; select * from tom;+----+-----------+------+| id | name      | age  |+----+-----------+------+|  1 | zhangshan |   20 ||  2 | wangwu    |    7 ||  3 | lisi      |   23 ||  4 | yyl       |   18 |+----+-----------+------+4 rows in set (0.00 sec)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;主从&quot;&gt;&lt;a href=&quot;#主从&quot; class=&quot;headerlink&quot; title=&quot;主从&quot;&gt;&lt;/a&gt;主从&lt;/h3&gt;&lt;p&gt;Mysql主从又叫Replication、AB复制(不同于PXC)。简单讲就是A与B两台机器做主从后，在A上写数据，另外一台B也会跟着写数据，实现数据实时同步&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mysql主从是基于binlog，主上需开启binlog才能进行主从&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;主从过程大概有3个步骤&quot;&gt;&lt;a href=&quot;#主从过程大概有3个步骤&quot; class=&quot;headerlink&quot; title=&quot;主从过程大概有3个步骤&quot;&gt;&lt;/a&gt;主从过程大概有3个步骤&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;主将更改操作记录到binlog里&lt;/li&gt;
&lt;li&gt;从将主的binlog事件（sql语句） 同步本机上并记录在relaylog里&lt;/li&gt;
&lt;li&gt;从根据relaylog里面的sql语句按顺序执行&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="MySQL" scheme="https://icocos.github.io/tags/MySQL/"/>
    
      <category term="主从复制" scheme="https://icocos.github.io/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>MySQL锁机制和PHP锁机制</title>
    <link href="https://icocos.github.io/2019/06/06/MySQL%E9%94%81%E6%9C%BA%E5%88%B6%E5%92%8CPHP%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>https://icocos.github.io/2019/06/06/MySQL锁机制和PHP锁机制/</id>
    <published>2019-06-06T10:47:41.000Z</published>
    <updated>2019-05-27T02:39:08.392Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PHP中的文件锁-（锁的是文件，不是表）"><a href="#PHP中的文件锁-（锁的是文件，不是表）" class="headerlink" title="PHP中的文件锁 （锁的是文件，不是表）"></a>PHP中的文件锁 （锁的是文件，不是表）</h3><p>文件锁的文件与表有什么关系？：一点关系也没有，与令牌相似，谁拿到谁操作。所以表根本没锁。<br>测试时，有个文件就行，叫什么名无所谓</p><p>bool flock ( int handle, int operation [, int &amp;wouldblock] );<br>flock() 操作的 handle 必须是一个已经打开的文件指针。operation 可以是以下值之一：</p><ul><li>要取得共享锁定（读取程序），将 operation 设为 LOCK_SH（PHP 4.0.1 以前的版本设置为 1）</li><li>要取得独占锁定（写入程序），将 operation 设为 LOCK_EX（PHP 4.0.1 以前的版本中设置为 2）</li><li>要释放锁定（无论共享或独占），将 operation 设为 LOCK_UN（PHP 4.0.1 以前的版本中设置为 3）</li><li>如果你不希望 flock() 在锁定时堵塞，则给 operation 加上 LOCK_NB（PHP 4.0.1 以前的版本中设置为4）</li></ul><a id="more"></a><h4 id="建两个文件"><a href="#建两个文件" class="headerlink" title="建两个文件"></a>建两个文件</h4><!--more--><h5 id="1-a-php"><a href="#1-a-php" class="headerlink" title="(1) a.php"></a>(1) a.php</h5><pre><code>$file = &quot;temp.txt&quot;;   $fp = fopen($file , &apos;w&apos;);   if(flock($fp , LOCK_EX)){        fwrite($fp , &quot;abc\n&quot;);        sleep(10);        fwrite($fp , &quot;123\n&quot;);       flock($fp , LOCK_UN);   }   fclose($fp);  </code></pre><h5 id="2-b-php"><a href="#2-b-php" class="headerlink" title="(2) b.php"></a>(2) b.php</h5><pre><code>$file = &quot;temp.txt&quot;;   $fp = fopen($file , &apos;r&apos;);   echo fread($fp , 100);   fclose($fp);  </code></pre><p>运行 a.php 后，马上运行 b.php ，可以看到输出：</p><pre><code>abc</code></pre><p>等 a.php 运行完后运行 b.php ，可以看到输出：</p><pre><code>abc123</code></pre><p>显然，当 a.php 写文件时数据太大，导致时间比较长时，这时 b.php 读取数据不完整</p><p>修改 b.php 为：</p><pre><code>$file = &quot;temp.txt&quot;;   $fp = fopen($file , &apos;r&apos;);   if(flock($fp , LOCK_EX)){       echo fread($fp , 100);       flock($fp , LOCK_UN);   } else{       echo &quot;Lock file failed...\n&quot;;   }   fclose($fp);  </code></pre><p>运行 a.php 后，马上运行 b.php ，可以发现 b.php 会等到 a.php 运行完成后(即 10 秒后)才显示：</p><pre><code>abc123</code></pre><p>读取数据完整，但时间过长，他要等待写锁释放。</p><p>修改 b.php 为：</p><pre><code>$file = &quot;temp.txt&quot;;   $fp = fopen($file , &apos;r&apos;);   if(flock($fp , LOCK_SH | LOCK_NB)){       echo fread($fp , 100);       flock($fp , LOCK_UN);   } else{       echo &quot;Lock file failed...\n&quot;;   }   fclose($fp);  </code></pre><p>运行 a.php 后，马上运行 b.php ，可以看到输出：<br>    Lock file failed…</p><p>证明可以返回锁文件失败状态，而不是向上面一样要等很久。</p><h5 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h5><blockquote><p>建议作文件缓存时，选好相关的锁，不然可能导致读取数据不完整，或重复写入数据。<br>file_get_contents 好像选择不了锁，不知道他默认用的什么锁，反正和不锁得到的输出一样，是不完整的数据。</p></blockquote><p>我是要做文件缓存，所以只需要知道是否有写锁存在即可，有的话就查数据库就可以了。<br>测试环境：Linux(Ubuntu 6) , PHP 5.1.2 , Apache 2</p><h5 id="再转："><a href="#再转：" class="headerlink" title="再转："></a>再转：</h5><p>文件锁有两种：共享锁和排他锁，也就是读锁(LOCK_SH)和写锁(LOCK_EX)<br>文件的锁一般这么使用：</p><pre><code>$fp = fopen(&quot;filename&quot;, &quot;a&quot;);   flock($fp, LOCK_SH) or die(&quot;lock error&quot;)   $str = fread($fp, 1024);   flock($fp, LOCK_UN);   fclose($fp);  </code></pre><blockquote><p>注意fwrite之后，文件立即就被更新了，而不是等fwrite然后fclose之后文件才会更新，这个可以通过在fwrite之后fclose之前读取这个文件进行检查 </p></blockquote><p>但是什么时候使用lock_ex什么时候使用lock_sh呢？ </p><h5 id="读的时候："><a href="#读的时候：" class="headerlink" title="读的时候："></a>读的时候：</h5><p>如果不想出现dirty数据，那么最好使用lock_sh共享锁。可以考虑以下三种情况： </p><ol><li>如果读的时候没有加共享锁，那么其他程序要写的话（不管这个写是加锁还是不加锁）都会立即写成功。如果正好读了一半，然后被其他程序给写了，那么读的后一半就有可能跟前一半对不上（前一半是修改前的，后一半是修改后的） </li><li>如果读的时候加上了共享锁（因为只是读，没有必要使用排他锁），这个时候，其他程序开始写，这个写程序没有使用锁，那么写程序会直接修改这个文件，也会导致前面一样的问题 </li><li>最理想的情况是，读的时候加锁(lock_sh),写的时候也进行加锁(lock_ex),这样写程序会等着读程序完成之后才进行操作，而不会出现贸然操作的情况 </li></ol><h5 id="写的时候："><a href="#写的时候：" class="headerlink" title="写的时候："></a>写的时候：</h5><p>如果多个写程序不加锁同时对文件进行操作，那么最后的数据有可能一部分是a程序写的，一部分是b程序写的<br>如果写的时候加锁了，这个时候有其他的程序来读，那么他会读到什么东西呢？ </p><ol><li>如果读程序没有申请共享锁，那么他会读到dirty的数据。比如写程序要写a,b,c三部分，写完a,这时候读读到的是a，继续写b，这时候读读到的是ab，然后写c，这时候读到的是abc. </li><li>如果读程序在之前申请了共享锁，那么读程序会等写程序将abc写完并释放锁之后才进行读。</li></ol><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>项目中应该只使用PHP中的文件锁，尽量避免锁表，因为如果表被锁定了，那么整个网站中所有和这个表相关的功能都被拖慢了（例如：前台很多用户一直下订单，商品表mysql锁表，其他与商品表相关的操作一直处于阻塞状态【读不出来商品表】，因为一个功能把整个网站速度拖慢）。</p><blockquote><p> 比如在一个O2O外卖项目中，中午12-2点，晚上6点都是订单高并发时，这种情况下，MySQL锁显然是不考虑的，用户体验太差。其实根据实际的需求，外卖可以不用设计库存量的，当然除了秒杀活动模块还是需要php文件锁的。</p></blockquote><p>应用场景：</p><ol><li>高并发下单时，减库存量时要加锁</li><li>高并发抢单、抢票时要使用</li></ol><p>MySQL锁示例代码：</p><pre><code>&lt;?php /**模拟秒杀活动-- 商品100件CREATE TABLE a(    id int comment &apos;模拟100件活动商品的数量&apos;);INSERT INTO a VALUES(100);模仿：以10的并发量访问这个脚本！    使用apache自带的ab.exe软件 */ error_reporting(0); mysql_connect(&apos;localhost&apos;,&apos;root&apos;,&apos;admin123&apos;); mysql_select_db(&apos;test&apos;); # mysql 锁 mysql_query(&apos;LOCK TABLE a WRITE&apos;);// 只有一个客户端可以锁定表，其他客户端阻塞在这 $rs = mysql_query(&apos;SELECT id FROM a&apos;); $id = mysql_result($rs, 0, 0); if($id &gt; 0) {     --$id;     mysql_query(&apos;UPDATE a SET id=&apos;.$id); } # mysql 解锁 mysql_query(&apos;UNLOCK TABLES&apos;);</code></pre><p>PHP文件锁示例代码：</p><pre><code>&lt;?php /**模拟秒杀活动-- 商品100件CREATE TABLE a(    id int comment &apos;模拟100件活动商品的数量&apos;);INSERT INTO a VALUES(100);模仿：以10的并发量访问这个脚本！    使用apache自带的ab.exe软件 */ error_reporting(0); mysql_connect(&apos;localhost&apos;,&apos;root&apos;,&apos;admin123&apos;); mysql_select_db(&apos;test&apos;); # php中的文件锁 $fp = fopen(&apos;./a.lock&apos;, &apos;r&apos;); // php的文件锁和表没关系，随便一个文件即可 flock($fp, LOCK_EX);// 排他锁 $rs = mysql_query(&apos;SELECT id FROM a&apos;); $id = mysql_result($rs, 0, 0); if($id &gt; 0) {     --$id;     mysql_query(&apos;UPDATE a SET id=&apos;.$id); } # php的文件锁，释放锁 flock($fp, LOCK_UN); fclose($fp);</code></pre><h3 id="MYSQL中的锁："><a href="#MYSQL中的锁：" class="headerlink" title="MYSQL中的锁："></a>MYSQL中的锁：</h3><p>语法 ：<br>LOCK TABLE 表名1 READ|WRITE, 表名2 READ|WRITE ……………… 【锁表】<br>UNLOCK TABLES  【释放表】</p><ul><li>Read:读锁|共享锁 ： 所有的客户端只能读这个表不能写这个表</li><li>Write:写锁|排它锁： 所有当前锁定客户端可以操作这个表，其他客户端只能阻塞</li></ul><blockquote><p>注意：在锁表的过程中只能操作被锁定的表，如果要操作其他表，必须把所有要操作的表都锁定起来！</p></blockquote><h5 id="1-表级锁定（table-level）"><a href="#1-表级锁定（table-level）" class="headerlink" title="1.表级锁定（table-level）"></a>1.表级锁定（table-level）</h5><p>表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并大度大打折扣。使用表级锁定的主要是MyISAM等一些非事务性存储引擎。</p><h5 id="2-行级锁定（row-level）"><a href="#2-行级锁定（row-level）" class="headerlink" title="2.行级锁定（row-level）"></a>2.行级锁定（row-level）</h5><p>行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。<br>虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。使用行级锁定的主要是InnoDB存储引擎。</p><h5 id="3-页级锁定（page-level）"><a href="#3-页级锁定（page-level）" class="headerlink" title="3.页级锁定（page-level）"></a>3.页级锁定（page-level）</h5><p>页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。<br>在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。</p><h5 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h5><ul><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；  </li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；    </li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。  </li></ul><p>适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</p><h3 id="二、表级锁定"><a href="#二、表级锁定" class="headerlink" title="二、表级锁定"></a>二、表级锁定</h3><p>在mysql中，MyISAM引擎使用的锁定机制完全是mysql的表级锁定，下面将以MYISAM引擎作为示例</p><h5 id="1-MySQL表级锁的模式"><a href="#1-MySQL表级锁的模式" class="headerlink" title="1.MySQL表级锁的模式"></a>1.MySQL表级锁的模式</h5><blockquote><p>MySQL的表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。  </p></blockquote><ul><li>兼容性：  <ul><li>对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；  </li><li>对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；  </li><li>MyISAM表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。</li></ul></li></ul><h5 id="2-加锁"><a href="#2-加锁" class="headerlink" title="2.加锁"></a>2.加锁</h5><blockquote><p>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。</p></blockquote><h5 id="3-MyISAM锁的优化"><a href="#3-MyISAM锁的优化" class="headerlink" title="3.MyISAM锁的优化"></a>3.MyISAM锁的优化</h5><blockquote><p>对于MyISAM存储引擎，虽然使用表级锁定在锁定实现的过程中比实现行级锁定或者页级锁所带来的附加成本都要小，锁定本身所消耗的资源也是最少。但是由于锁定的颗粒度比较到，所以造成锁定资源的争用情况也会比其他的锁定级别都要多，从而在较大程度上会降低并发处理能力。所以，在优化MyISAM存储引擎锁定问题的时候，最关键的就是如何让其提高并发度。由于锁定级别是不可能改变的了，所以我们首先需要尽可能让锁定的时间变短，然后就是让可能并发进行的操作尽可能的并发。</p></blockquote><ul><li>（1）查询表锁争用情况</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like &apos;table%&apos;;</span><br><span class="line">+----------------------------+---------+</span><br><span class="line">| Variable_name              | Value   |</span><br><span class="line">+----------------------------+---------+</span><br><span class="line">| Table_locks_immediate      | 100     |</span><br><span class="line">| Table_locks_waited         | 11      |</span><br><span class="line">+----------------------------+---------+</span><br></pre></td></tr></table></figure><p>这里有两个状态变量记录MySQL内部表级锁定的情况，两个变量说明如下：</p><ul><li>Table_locks_immediate：产生表级锁定的次数;  </li><li>Table_locks_waited：出现表级锁定争用而发生等待的次数；</li></ul><p>两个状态值都是从系统启动后开始记录，出现一次对应的事件则数量加1。如果这里的Table_locks_waited状态值比较高，那么说明系统中表级锁定争用现象比较严重，就需要进一步分析为什么会有较多的锁定资源争用了</p><ul><li>（2）缩短锁定时间</li></ul><p>如何让锁定时间尽可能的短呢？唯一的办法就是让我们的Query执行时间尽可能的短。</p><pre><code>+ a)尽两减少大的复杂Query，将复杂Query分拆成几个小的Query分布进行；  + b)尽可能的建立足够高效的索引，让数据检索更迅速；  + c)尽量让MyISAM存储引擎的表只存放必要的信息，控制字段类型；  + d)利用合适的机会优化MyISAM表数据文件</code></pre><ul><li>(3)分离并行的操作</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;PHP中的文件锁-（锁的是文件，不是表）&quot;&gt;&lt;a href=&quot;#PHP中的文件锁-（锁的是文件，不是表）&quot; class=&quot;headerlink&quot; title=&quot;PHP中的文件锁 （锁的是文件，不是表）&quot;&gt;&lt;/a&gt;PHP中的文件锁 （锁的是文件，不是表）&lt;/h3&gt;&lt;p&gt;文件锁的文件与表有什么关系？：一点关系也没有，与令牌相似，谁拿到谁操作。所以表根本没锁。&lt;br&gt;测试时，有个文件就行，叫什么名无所谓&lt;/p&gt;
&lt;p&gt;bool flock ( int handle, int operation [, int &amp;amp;wouldblock] );&lt;br&gt;flock() 操作的 handle 必须是一个已经打开的文件指针。operation 可以是以下值之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要取得共享锁定（读取程序），将 operation 设为 LOCK_SH（PHP 4.0.1 以前的版本设置为 1）&lt;/li&gt;
&lt;li&gt;要取得独占锁定（写入程序），将 operation 设为 LOCK_EX（PHP 4.0.1 以前的版本中设置为 2）&lt;/li&gt;
&lt;li&gt;要释放锁定（无论共享或独占），将 operation 设为 LOCK_UN（PHP 4.0.1 以前的版本中设置为 3）&lt;/li&gt;
&lt;li&gt;如果你不希望 flock() 在锁定时堵塞，则给 operation 加上 LOCK_NB（PHP 4.0.1 以前的版本中设置为4）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>MySQL两种存储引擎- MyISAM和InnoDB 简单总结</title>
    <link href="https://icocos.github.io/2019/05/03/MySQL%E4%B8%A4%E7%A7%8D%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%20MyISAM%E5%92%8CInnoDB%20%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <id>https://icocos.github.io/2019/05/03/MySQL两种存储引擎- MyISAM和InnoDB 简单总结/</id>
    <published>2019-05-03T10:47:41.000Z</published>
    <updated>2019-05-22T09:17:26.545Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>MyISAM是MySQL的默认数据库引擎（5.5版之前），由早期的ISAM（Indexed Sequential Access Method：有索引的顺序访问方法）所改良。虽然性能极佳，但却有一个缺点：不支持事务处理（transaction）。不过，在这几年的发展下，MySQL也导入了InnoDB（另一种数据库引擎），以强化参考完整性与并发违规处理机制，后来就逐渐取代MyISAM。</p></li><li><p>InnoDB，是MySQL的数据库引擎之一，为MySQL AB发布binary的标准之一。InnoDB由Innobase Oy公司所开发，2006年五月时由甲骨文公司并购。与传统的ISAM与MyISAM相比，InnoDB的最大特色就是支持了ACID兼容的事务（Transaction）功能，类似于PostgreSQL。目前InnoDB采用双轨制授权，一是GPL授权，另一是专有软件授权。</p></li></ul><a id="more"></a><p>MyISAM和InnoDB两者之间有着明显区别，简单梳理如下:</p><h5 id="1-事务支持"><a href="#1-事务支持" class="headerlink" title="1) 事务支持"></a>1) 事务支持</h5><p>MyISAM不支持事务，而InnoDB支持。InnoDB的AUTOCOMMIT默认是打开的，即每条SQL语句会默认被封装成一个事务，自动提交，这样会影响速度，所以最好是把多条SQL语句显示放在begin和commit之间，组成一个事务去提交。</p><p>MyISAM是非事务安全型的，而InnoDB是事务安全型的，默认开启自动提交，宜合并事务，一同提交，减小数据库多次提交导致的开销，大大提高性能。</p><h5 id="2-存储结构"><a href="#2-存储结构" class="headerlink" title="2) 存储结构"></a>2) 存储结构</h5><p>MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。</p><p>InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</p><h5 id="3-存储空间"><a href="#3-存储空间" class="headerlink" title="3) 存储空间"></a>3) 存储空间</h5><p>MyISAM：可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。</p><p>InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。</p><h5 id="4-可移植性、备份及恢复"><a href="#4-可移植性、备份及恢复" class="headerlink" title="4) 可移植性、备份及恢复"></a>4) 可移植性、备份及恢复</h5><p>MyISAM：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。</p><p>InnoDB：免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。</p><h5 id="5-事务支持"><a href="#5-事务支持" class="headerlink" title="5) 事务支持"></a>5) 事务支持</h5><p>MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。</p><p>InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</p><h5 id="6-AUTO-INCREMENT"><a href="#6-AUTO-INCREMENT" class="headerlink" title="6) AUTO_INCREMENT"></a>6) AUTO_INCREMENT</h5><p>MyISAM：可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。</p><p>InnoDB：InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。</p><h5 id="7-表锁差异"><a href="#7-表锁差异" class="headerlink" title="7) 表锁差异"></a>7) 表锁差异</h5><p>MyISAM：只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。</p><p>InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</p><p>MyISAM锁的粒度是表级，而InnoDB支持行级锁定。简单来说就是, InnoDB支持数据行锁定，而MyISAM不支持行锁定，只支持锁定整个表。即MyISAM同一个表上的读锁和写锁是互斥的，MyISAM并发读写时如果等待队列中既有读请求又有写请求，默认写请求的优先级高，即使读请求先到，所以MyISAM不适合于有大量查询和修改并存的情况，那样查询进程会长时间阻塞。因为MyISAM是锁表，所以某项读操作比较耗时会使其他写进程饿死。</p><h5 id="8-全文索引"><a href="#8-全文索引" class="headerlink" title="8) 全文索引"></a>8) 全文索引</h5><p>MyISAM：支持(FULLTEXT类型的)全文索引</p><p>InnoDB：不支持(FULLTEXT类型的)全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。</p><p>全文索引是指对char、varchar和text中的每个词（停用词除外）建立倒排序索引。MyISAM的全文索引其实没啥用，因为它不支持中文分词，必须由使用者分词后加入空格再写到数据表里，而且少于4个汉字的词会和停用词一样被忽略掉。</p><blockquote><p>另外，MyIsam索引和数据分离，InnoDB在一起，MyIsam天生非聚簇索引，最多有一个unique的性质，InnoDB的数据文件本身就是主键索引文件，这样的索引被称为“聚簇索引”</p></blockquote><h5 id="9-表主键"><a href="#9-表主键" class="headerlink" title="9) 表主键"></a>9) 表主键</h5><p>MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。</p><p>InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。InnoDB的主键范围更大，最大是MyISAM的2倍。</p><h5 id="10-表的具体行数"><a href="#10-表的具体行数" class="headerlink" title="10) 表的具体行数"></a>10) 表的具体行数</h5><p>MyISAM：保存有表的总行数，如果select count(*) from table;会直接取出出该值。</p><p>InnoDB：没有保存表的总行数(只能遍历)，如果使用select count(*) from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。</p><h5 id="11-CURD操作"><a href="#11-CURD操作" class="headerlink" title="11) CURD操作"></a>11) CURD操作</h5><p>MyISAM：如果执行大量的SELECT，MyISAM是更好的选择。</p><p>InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。</p><h5 id="12-外键"><a href="#12-外键" class="headerlink" title="12) 外键"></a>12) 外键</h5><p>MyISAM：不支持</p><p>InnoDB：支持</p><h5 id="13-查询效率"><a href="#13-查询效率" class="headerlink" title="13) 查询效率"></a>13) 查询效率</h5><p>没有where的count(<em>)使用MyISAM要比InnoDB快得多。因为MyISAM内置了一个计数器，count(</em>)时它直接从计数器中读，而InnoDB必须扫描全表。所以在InnoDB上执行count(<em>)时一般要伴随where，且where中要包含主键以外的索引列。为什么这里特别强调“主键以外”？因为InnoDB中primary index是和raw data存放在一起的，而secondary index则是单独存放，然后有个指针指向primary key。所以只是count(</em>)的话使用secondary index扫描更快，而primary key则主要在扫描索引同时要返回raw data时的作用较大。MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM。</p><p>通过上述的分析，基本上可以考虑使用InnoDB来替代MyISAM引擎了，原因是InnoDB自身很多良好的特点，比如事务支持、存储 过程、视图、行级锁定等等，在并发很多的情况下，相信InnoDB的表现肯定要比MyISAM强很多。另外，任何一种表都不是万能的，只用恰当的针对业务类型来选择合适的表类型，才能最大的发挥MySQL的性能优势。如果不是很复杂的Web应用，非关键应用，还是可以继续考虑MyISAM的，这个具体情况可以自己斟酌。</p><h3 id="MyISAM和InnoDB两者的应用场景："><a href="#MyISAM和InnoDB两者的应用场景：" class="headerlink" title="MyISAM和InnoDB两者的应用场景："></a>MyISAM和InnoDB两者的应用场景：</h3><ul><li><p>1) MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。</p></li><li><p>2) InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。</p></li></ul><p>但是实际场景中，针对具体问题需要具体分析，一般而言可以遵循以下几个问题：</p><ul><li>数据库是否有外键？</li><li>是否需要事务支持？</li><li>是否需要全文索引？</li><li>数据库经常使用什么样的查询模式？在写多读少的应用中还是Innodb插入性能更稳定，在并发情况下也能基本，如果是对读取速度要求比较快的应用还是选MyISAM。</li><li>数据库的数据有多大？ 大尺寸倾向于innodb，因为事务日志，故障恢复。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;MyISAM是MySQL的默认数据库引擎（5.5版之前），由早期的ISAM（Indexed Sequential Access Method：有索引的顺序访问方法）所改良。虽然性能极佳，但却有一个缺点：不支持事务处理（transaction）。不过，在这几年的发展下，MySQL也导入了InnoDB（另一种数据库引擎），以强化参考完整性与并发违规处理机制，后来就逐渐取代MyISAM。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;InnoDB，是MySQL的数据库引擎之一，为MySQL AB发布binary的标准之一。InnoDB由Innobase Oy公司所开发，2006年五月时由甲骨文公司并购。与传统的ISAM与MyISAM相比，InnoDB的最大特色就是支持了ACID兼容的事务（Transaction）功能，类似于PostgreSQL。目前InnoDB采用双轨制授权，一是GPL授权，另一是专有软件授权。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引优化策略与笔记</title>
    <link href="https://icocos.github.io/2019/04/29/MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5%E4%B8%8E%E7%AC%94%E8%AE%B0/"/>
    <id>https://icocos.github.io/2019/04/29/MySQL索引优化策略与笔记/</id>
    <published>2019-04-29T10:47:41.000Z</published>
    <updated>2019-05-27T02:33:41.460Z</updated>
    
    <content type="html"><![CDATA[<p>面试知识，数据库索引优化</p><h4 id="什么问题？"><a href="#什么问题？" class="headerlink" title="什么问题？"></a>什么问题？</h4><pre><code>索引有什么代价？哪些场景下你需要建索引？或者有时候反过来问，哪些场景下不推荐建索引。建好索引之后，怎么才能最高效地利用索引？或者反过来问，请说出一个无法有效利用已建索引的案例。</code></pre><h4 id="索引的好处？"><a href="#索引的好处？" class="headerlink" title="索引的好处？"></a>索引的好处？</h4><blockquote><p>快速查询数据。</p></blockquote><a id="more"></a><h4 id="代价是什么？"><a href="#代价是什么？" class="headerlink" title="代价是什么？"></a>代价是什么？</h4><pre><code>索引需要占硬盘空间，这是空间方面的代价。一旦插入新的数据，就需要重新建索引，这是时间上的代价。</code></pre><h4 id="不同场景，不同对待。"><a href="#不同场景，不同对待。" class="headerlink" title="不同场景，不同对待。"></a>不同场景，不同对待。</h4><h5 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h5><blockquote><p>数据表规模不大，就几千行，即使不建索引，查询语句的返回时间也不长，这时建索引的意义就不大。当然，若就几千行，索引所占的空间也不多，所以这种情况下，顶多属于“性价比”不高。</p></blockquote><h4 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h4><blockquote><p> 某个商品表里有几百万条商品信息，同时每天会在一个时间点，往其中更新大概十万条左右的商品信息，现在用where语句查询特定商品时（比如where name = ‘XXX’）速度很慢。为了提升查询效率可以建索引，但当每天更新数据时，又会重建索引，这是要耗费时间的。这时就需要综合考虑，甚至可以在更新前删除索引，更新后再重建。</p></blockquote><h4 id="场景三"><a href="#场景三" class="headerlink" title="场景三"></a>场景三</h4><blockquote><p>因为在数据表里ID值都不相同，所以索引能发挥出比较大的作用。相反，如果某个字段重复率很高，如性别字段，或者某个字段大多数值是空（null），那么不建议对该字段建索引。</p></blockquote><h3 id="建立索引原则"><a href="#建立索引原则" class="headerlink" title="建立索引原则"></a>建立索引原则</h3><p>一定是有业务需求了才会建索引。比如在一个商品表里，我们经常要根据name做查询，如果没有索引，查询速度会很慢，这时就需要建索引。但在项目开发中，如果不经常根据商品编号查询，那么就没必要对编号建索引。</p><p>最后再强调一次，建索引是要付出代价的，没事别乱建着玩，同时在一个表上也不能建太多的索引。<br>具体的例子来看索引的正确用法</p><pre><code>语句一：select name from 商品表。不会用到索引，因为没有where语句。语句二：select * from 商品表 where name = ‘Java书’，会用到索引，如果项目里经常用到name来查询，且商品表的数据量很大，而name值的重复率又不高，那么建议建索引。语句三：select * from 商品表 where name like ‘Java%’ 这是个模糊查询，会用到索引，请大家记住，用like进行模糊查询时，如果第一个就是模糊的匹配符，比如where name like ‘%java’，那么在查询时不会走索引。在其他情况下，不论用了多少个%，也不论%的位置，只要不出现在第一个位置，那么都能用到索引。</code></pre><p>学生成绩表里有两个字段：姓名和成绩。现在对成绩这个整数类型的字段建索引。</p><pre><code>第一种情况，当数字型字段遇到非等值操作符时，无法用到索引。比如：</code></pre><p>​ select name from 学生成绩表 where 成绩&gt;95 , 一旦出现大于符号，就不能用到索引，为了用到索引，我们应该改一下SQL语句里的where从句：where 成绩 in (96,97,98,99,100)</p><pre><code>第二种情况，如果对索引字段进行了某种左值操作，那么无法用到索引。</code></pre><p>​ 能用到索引的写法：select name from 学生成绩表 where 成绩 = 60</p><p>​ 不能用到索引的写法：select name from 学生成绩表 where 成绩+40 = 100</p><pre><code>第三种情况，如果对索引字段进行了函数操作，那么无法用到索引。</code></pre><p>​ 比如SQL语句：select * from 商品表 where substr(name) = ‘J’，我们希望查询商品名首字母是J的记录，可一旦针对name使用函数，即使name字段上有索引，也无法用到。<br>​ </p><blockquote><p>非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据。</p></blockquote><p>不管以任何方式查询表， 最终都会利用主键通过聚集索引来定位到数据， 聚集索引（主键）是通往真实数据所在的唯一路径。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试知识，数据库索引优化&lt;/p&gt;
&lt;h4 id=&quot;什么问题？&quot;&gt;&lt;a href=&quot;#什么问题？&quot; class=&quot;headerlink&quot; title=&quot;什么问题？&quot;&gt;&lt;/a&gt;什么问题？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;索引有什么代价？哪些场景下你需要建索引？或者有时候反过来问，哪些场景下不推荐建索引。
建好索引之后，怎么才能最高效地利用索引？或者反过来问，请说出一个无法有效利用已建索引的案例。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;索引的好处？&quot;&gt;&lt;a href=&quot;#索引的好处？&quot; class=&quot;headerlink&quot; title=&quot;索引的好处？&quot;&gt;&lt;/a&gt;索引的好处？&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;快速查询数据。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>如何处理负载、高并发问题</title>
    <link href="https://icocos.github.io/2019/04/27/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%B4%9F%E8%BD%BD%E3%80%81%E9%AB%98%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/"/>
    <id>https://icocos.github.io/2019/04/27/如何处理负载、高并发问题/</id>
    <published>2019-04-27T10:47:41.000Z</published>
    <updated>2019-05-22T09:07:52.595Z</updated>
    
    <content type="html"><![CDATA[<p>从低成本、高性能和高扩张性的角度来说有如下处理方案：</p><h5 id="1、HTML静态化"><a href="#1、HTML静态化" class="headerlink" title="1、HTML静态化"></a>1、HTML静态化</h5><p>其实大家都知道，效率最高、消耗最小的就是纯静态化的html页面，所以我们尽可能使我们的  网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。</p><h5 id="2、图片服务器分离"><a href="#2、图片服务器分离" class="headerlink" title="2、图片服务器分离"></a>2、图片服务器分离</h5><p>​    把图片单独存储，尽量减少图片等大流量的开销，可以放在一些相关的平台上，如骑牛等</p><a id="more"></a><h5 id="3、数据库集群和库表散列及缓存"><a href="#3、数据库集群和库表散列及缓存" class="headerlink" title="3、数据库集群和库表散列及缓存"></a>3、数据库集群和库表散列及缓存</h5><p>数据库的并发连接为100，一台数据库远远不够，可以从读写分离、主从复制，数据库集群方面来着手。另外尽量减少数据库的访问，可以使用缓存数据库如memcache、redis。</p><h5 id="4、镜像："><a href="#4、镜像：" class="headerlink" title="4、镜像："></a>4、镜像：</h5><p>   尽量减少下载，可以把不同的请求分发到多个镜像端。</p><h5 id="5、负载均衡："><a href="#5、负载均衡：" class="headerlink" title="5、负载均衡："></a>5、负载均衡：</h5><p>   Apache的最大并发连接为1500，只能增加服务器，可以从硬件上着手，如F5服务器。当然硬件的成本比较高，我们往往从软件方面着手。</p><p>   负载均衡 （Load Balancing） 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力，同时能够提高网络的灵活性和可用性。目前使用最为广泛的负载均衡软件是Nginx、LVS、HAProxy。我分别来说下三种的优缺点:</p><h5 id="Nginx的优点是："><a href="#Nginx的优点是：" class="headerlink" title="Nginx的优点是："></a>Nginx的优点是：</h5><ol><li><p>工作在网络的7层之上，可以针对http应用做一些分流的策略，比如针对域名、目录结构，它的正则规则比HAProxy更为强大和灵活，这也是它目前广泛流行的主要原因之一，Nginx单凭这点可利用的场合就远多于LVS了。 </p></li><li><p>Nginx对网络稳定性的依赖非常小，理论上能ping通就就能进行负载功能，这个也是它的优势之一；相反LVS对网络稳定性依赖比较大，这点本人深有体会； </p></li><li><p>Nginx安装和配置比较简单，测试起来比较方便，它基本能把错误用日志打印出来。LVS的配置、测试就要花比较长的时间了，LVS对网络依赖比较大。 </p></li><li><p>可以承担高负载压力且稳定，在硬件不差的情况下一般能支撑几万次的并发量，负载度比LVS相对小些。 </p></li><li><p>Nginx可以通过端口检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点，不过其中缺点就是不支持url来检测。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而不满。 </p></li><li><p>Nginx不仅仅是一款优秀的负载均衡器/反向代理软件，它同时也是功能强大的Web应用服务器。LNMP也是近几年非常流行的web架构，在高流量的环境中稳定性也很好。 </p></li><li><p>Nginx现在作为Web反向加速缓存越来越成熟了，速度比传统的Squid服务器更快，可以考虑用其作为反向代理加速器。 </p></li><li><p>Nginx可作为中层反向代理使用，这一层面Nginx基本上无对手，唯一可以对比Nginx的就只有 lighttpd了，不过 lighttpd目前还没有做到Nginx完全的功能，配置也不那么清晰易读，社区资料也远远没Nginx活跃。 </p></li><li><p>Nginx也可作为静态网页和图片服务器，这方面的性能也无对手。还有Nginx社区非常活跃，第三方模块也很多。</p></li></ol><h5 id="Nginx的缺点是："><a href="#Nginx的缺点是：" class="headerlink" title="Nginx的缺点是："></a>Nginx的缺点是：</h5><ol><li>Nginx仅能支持http、https和Email协议，这样就在适用范围上面小些，这个是它的缺点。</li><li>对后端服务器的健康检查，只支持通过端口来检测，不支持通过url来检测。不支持Session的直接保持，但能通过ip_hash来解决。</li></ol><h4 id="LVS：使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability-、可靠性（Reliability-和可管理性（Manageability-。"><a href="#LVS：使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability-、可靠性（Reliability-和可管理性（Manageability-。" class="headerlink" title="LVS：使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability)、可靠性（Reliability)和可管理性（Manageability)。"></a>LVS：使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability)、可靠性（Reliability)和可管理性（Manageability)。</h4><h5 id="LVS的优点是："><a href="#LVS的优点是：" class="headerlink" title="LVS的优点是："></a>LVS的优点是：</h5><ol><li>抗负载能力强、是工作在网络4层之上仅作分发之用，没有流量的产生，这个特点也决定了它在负载均衡软件里的性能最强的，对内存和cpu资源消耗比较低。</li><li>配置性比较低，这是一个缺点也是一个优点，因为没有可太多配置的东西，所以并不需要太多接触，大大减少了人为出错的几率。</li><li>工作稳定，因为其本身抗负载能力很强，自身有完整的双机热备方案，如LVS+Keepalived，不过我们在项目实施中用得最多的还是LVS/DR+Keepalived。</li><li>无流量，LVS只分发请求，而流量并不从它本身出去，这点保证了均衡器IO的性能不会受到大流量的影响。</li><li>应用范围比较广，因为LVS工作在4层，所以它几乎可以对所有应用做负载均衡，包括http、数据库、在线聊天室等等。</li></ol><h5 id="LVS的缺点是："><a href="#LVS的缺点是：" class="headerlink" title="LVS的缺点是："></a>LVS的缺点是：</h5><ol><li>软件本身不支持正则表达式处理，不能做动静分离；而现在许多网站在这方面都有较强的需求，这个是Nginx/HAProxy+Keepalived的优势所在。</li><li>如果是网站应用比较庞大的话，LVS/DR+Keepalived实施起来就比较复杂了，特别后面有 Windows Server的机器的话，如果实施及配置还有维护过程就比较复杂了，相对而言，Nginx/HAProxy+Keepalived就简单多了。</li></ol><h5 id="HAProxy的特点是："><a href="#HAProxy的特点是：" class="headerlink" title="HAProxy的特点是："></a>HAProxy的特点是：</h5><ol><li>HAProxy也是支持虚拟主机的。</li><li>HAProxy的优点能够补充Nginx的一些缺点，比如支持Session的保持，Cookie的引导；同时支持通过获取指定的url来检测后端服务器的状态。</li><li>HAProxy跟LVS类似，本身就只是一款负载均衡软件；单纯从效率上来讲HAProxy会比Nginx有更出色的负载均衡速度，在并发处理上也是优于Nginx的。</li><li>HAProxy支持TCP协议的负载均衡转发，可以对MySQL读进行负载均衡，对后端的MySQL节点进行检测和负载均衡，大家可以用LVS+Keepalived对MySQL主从做负载均衡。</li><li>HAProxy负载均衡策略非常多，HAProxy的负载均衡算法现在具体有如下8种：</li></ol><p>① roundrobin，表示简单的轮询，这个不多说，这个是负载均衡基本都具备的；<br>② static-rr，表示根据权重，建议关注；<br>③ leastconn，表示最少连接者先处理，建议关注；<br>④ source，表示根据请求源IP，这个跟Nginx的IP_hash机制类似，我们用其作为解决session问题的一种方法，建议关注；<br>⑤ ri，表示根据请求的URI；<br>⑥ rl_param，表示根据请求的URl参数’balance url_param’ requires an URL parametername；<br>⑦ hdr(name)，表示根据HTTP请求头来锁定每一次HTTP请求；<br>⑧ rdp-cookie(name)，表示根据据cookie(name)来锁定并哈希每一次TCP请求。</p><h5 id="Nginx和LVS对比的总结："><a href="#Nginx和LVS对比的总结：" class="headerlink" title="Nginx和LVS对比的总结："></a>Nginx和LVS对比的总结：</h5><ol><li><p>Nginx工作在网络的7层，所以它可以针对http应用本身来做分流策略，比如针对域名、目录结构等，相比之下LVS并不具备这样的功能，所以Nginx单凭这点可利用的场合就远多于LVS了；但Nginx有用的这些功能使其可调整度要高于LVS，所以经常要去触碰触碰，触碰多了，人为出问题的几率也就会大。   </p></li><li><p>Nginx对网络稳定性的依赖较小，理论上只要ping得通，网页访问正常，Nginx就能连得通，这是Nginx的一大优势！Nginx同时还能区分内外网，如果是同时拥有内外网的节点，就相当于单机拥有了备份线路；LVS就比较依赖于网络环境，目前来看服务器在同一网段内并且LVS使用direct方式分流，效果较能得到保证。另外注意，LVS需要向托管商至少申请多一个ip来做Visual IP，貌似是不能用本身的IP来做VIP的。要做好LVS管理员，确实得跟进学习很多有关网络通信方面的知识，就不再是一个HTTP那么简单了。</p></li><li><p>Nginx安装和配置比较简单，测试起来也很方便，因为它基本能把错误用日志打印出来。LVS的安装和配置、测试就要花比较长的时间了；LVS对网络依赖比较大，很多时候不能配置成功都是因为网络问题而不是配置问题，出了问题要解决也相应的会麻烦得多。 </p></li><li><p>Nginx也同样能承受很高负载且稳定，但负载度和稳定度差LVS还有几个等级：Nginx处理所有流量所以受限于机器IO和配置；本身的bug也还是难以避免的。 </p></li><li><p>Nginx可以检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点。目前LVS中 ldirectd也能支持针对服务器内部的情况来监控，但LVS的原理使其不能重发请求。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而恼火。 </p></li><li><p>Nginx对请求的异步处理可以帮助节点服务器减轻负载，假如使用 apache直接对外服务，那么出现很多的窄带链接时apache服务器将会占用大量内存而不能释放，使用多一个Nginx做apache代理的话，这些窄带链接会被Nginx挡住，apache上就不会堆积过多的请求，这样就减少了相当多的资源占用。这点使用squid也有相同的作用，即使squid本身配置为不缓存，对apache还是有很大帮助的。 </p></li><li><p>Nginx能支持http、https和email（email的功能比较少用），LVS所支持的应用在这点上会比Nginx更多。在使用上，一般最前端所采取的策略应是LVS，也就是DNS的指向应为LVS均衡器，LVS的优点令它非常适合做这个任务。重要的ip地址，最好交由LVS托管，比如数据库的 ip、webservice服务器的ip等等，这些ip地址随着时间推移，使用面会越来越大，如果更换ip则故障会接踵而至。所以将这些重要ip交给 LVS托管是最为稳妥的，这样做的唯一缺点是需要的VIP数量会比较多。Nginx可作为LVS节点机器使用，一是可以利用Nginx的功能，二是可以利用Nginx的性能。当然这一层面也可以直接使用squid，squid的功能方面就比Nginx弱不少了，性能上也有所逊色于Nginx。Nginx也可作为中层代理使用，这一层面Nginx基本上无对手，唯一可以撼动Nginx的就只有lighttpd了，不过lighttpd目前还没有能做到 Nginx完全的功能，配置也不那么清晰易读。另外，中层代理的IP也是重要的，所以中层代理也拥有一个VIP和LVS是最完美的方案了。具体的应用还得具体分析，如果是比较小的网站（日PV小于1000万），用Nginx就完全可以了，如果机器也不少，可以用DNS轮询，LVS所耗费的机器还是比较多的；大型网站或者重要的服务，机器不发愁的时候，要多多考虑利用LVS。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从低成本、高性能和高扩张性的角度来说有如下处理方案：&lt;/p&gt;
&lt;h5 id=&quot;1、HTML静态化&quot;&gt;&lt;a href=&quot;#1、HTML静态化&quot; class=&quot;headerlink&quot; title=&quot;1、HTML静态化&quot;&gt;&lt;/a&gt;1、HTML静态化&lt;/h5&gt;&lt;p&gt;其实大家都知道，效率最高、消耗最小的就是纯静态化的html页面，所以我们尽可能使我们的  网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。&lt;/p&gt;
&lt;h5 id=&quot;2、图片服务器分离&quot;&gt;&lt;a href=&quot;#2、图片服务器分离&quot; class=&quot;headerlink&quot; title=&quot;2、图片服务器分离&quot;&gt;&lt;/a&gt;2、图片服务器分离&lt;/h5&gt;&lt;p&gt;​    把图片单独存储，尽量减少图片等大流量的开销，可以放在一些相关的平台上，如骑牛等&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="高负载" scheme="https://icocos.github.io/tags/%E9%AB%98%E8%B4%9F%E8%BD%BD/"/>
    
      <category term="高并发" scheme="https://icocos.github.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL 事务处理常见有两种方法</title>
    <link href="https://icocos.github.io/2019/04/26/MYSQL%20%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%B8%B8%E8%A7%81%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>https://icocos.github.io/2019/04/26/MYSQL 事务处理常见有两种方法/</id>
    <published>2019-04-26T10:47:41.000Z</published>
    <updated>2019-05-22T09:17:25.529Z</updated>
    
    <content type="html"><![CDATA[<p> MYSQL在操作大量的数据或者比较重要的数据的时候，事务处理很重要，比如银行的转账，支付，等等，作为开发人员事务是必须的一步。</p><h5 id="1、用-BEGIN-ROLLBACK-COMMIT来实现"><a href="#1、用-BEGIN-ROLLBACK-COMMIT来实现" class="headerlink" title="1、用 BEGIN, ROLLBACK, COMMIT来实现"></a>1、用 BEGIN, ROLLBACK, COMMIT来实现</h5><ul><li>BEGIN 开始一个事务</li><li>ROLLBACK 事务回滚</li><li>COMMIT 事务确认</li></ul><a id="more"></a><h5 id="2、直接用-SET-来改变-MySQL-的自动提交模式"><a href="#2、直接用-SET-来改变-MySQL-的自动提交模式" class="headerlink" title="2、直接用 SET 来改变 MySQL 的自动提交模式:"></a>2、直接用 SET 来改变 MySQL 的自动提交模式:</h5><ul><li>SET AUTOCOMMIT=0 禁止自动提交</li><li>SET AUTOCOMMIT=1 开启自动提交</li></ul><blockquote><p>注意的是，在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</p></blockquote><p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p><h3 id="一、php事务处理概述："><a href="#一、php事务处理概述：" class="headerlink" title="一、php事务处理概述："></a>一、php事务处理概述：</h3><ul><li><p>事务:是若干事件的集合</p></li><li><p>事务处理:当所有事件执行成功,事务才执行;若有任何一个事件不能成功执行,事务的其它事件也不被执行。</p></li></ul><p>只要你的MySQL版本支持BDB或InnoDB表类型，那么你的MySQL就具有事务处理的能力。这里面，又以InnoDB表类型用的最多，虽然后来发生了诸如Oracle收购InnoDB等令MySQL不爽的事情，但是这类商业事件与技术无关，下面就以InnoDB表类型为例简单说一下MySQL中的事务处理。</p><h3 id="二、php事务处理代码："><a href="#二、php事务处理代码：" class="headerlink" title="二、php事务处理代码："></a>二、php事务处理代码：</h3><pre><code>&lt;?phptry{$pdo=new PDO(&quot;mysql:host=localhost;dbname=psp&quot;,&quot;root&quot;,&quot;&quot;);$pdo-&gt;exec(&quot;set names utf8&quot;);$pdo-&gt;setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_EXCEPTION);//设置异常处理模式$pdo-&gt;setAttribute(PDO::ATTR_AUTOCOMMIT,0);//关闭自动提交}catch(PDOException $e){echo &quot;数据库连接失败&quot;;exit;}try{$age=10;$pdo-&gt;beginTransaction();//开始事务$affected_rows1=$pdo-&gt;exec(&quot;update kfry set k_age=k_age+{$age} where k_name=&apos;user1&apos;&quot;);$affected_rows2=$pdo-&gt;exec(&quot;update kfry set k_age=k_age-{$age} where k_name=&apos;user2&apos;&quot;);//随意更改使之执行成功或失败/* if($affected_rows1&amp;&amp;$affected_rows2){$pdo-&gt;commit();echo &quot;操作成功&quot;;}else{$pdo-&gt;rollback();} */if(!$affected_rows1)throw new PDOException(&quot;加入错误&quot;);if(!$affected_rows2)throw new PDOException(&quot;减少错误&quot;);echo &quot;操作成功&quot;;$pdo-&gt;commit();//如果执行到此处前面两个更新sql语句执行成功，整个事务执行成功}catch(PDOException $e){echo &quot;操作失败：&quot;.$e-&gt;getMessage();$pdo-&gt;rollback();//执行事务中的语句出了问题，整个事务全部撤销}$pdo-&gt;setAttribute(PDO::ATTR_AUTOCOMMIT,1);//测试是否成功echo &quot;\n操作结果为:\n&quot;;$sql=&quot;select * from kfry&quot;;$result=$pdo-&gt;query($sql);foreach($result as $v){echo $v[&apos;k_name&apos;].&quot; &quot;.$v[&apos;k_age&apos;].&quot;\n&quot;;}?&gt;</code></pre><p>以上就是php 事务处理详解的详细内容，更多请关注php中文网其它相关文章！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; MYSQL在操作大量的数据或者比较重要的数据的时候，事务处理很重要，比如银行的转账，支付，等等，作为开发人员事务是必须的一步。&lt;/p&gt;
&lt;h5 id=&quot;1、用-BEGIN-ROLLBACK-COMMIT来实现&quot;&gt;&lt;a href=&quot;#1、用-BEGIN-ROLLBACK-COMMIT来实现&quot; class=&quot;headerlink&quot; title=&quot;1、用 BEGIN, ROLLBACK, COMMIT来实现&quot;&gt;&lt;/a&gt;1、用 BEGIN, ROLLBACK, COMMIT来实现&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;BEGIN 开始一个事务&lt;/li&gt;
&lt;li&gt;ROLLBACK 事务回滚&lt;/li&gt;
&lt;li&gt;COMMIT 事务确认&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Web安全的一次探讨</title>
    <link href="https://icocos.github.io/2019/03/13/Web%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%80%E6%AC%A1%E6%8E%A2%E8%AE%A8/"/>
    <id>https://icocos.github.io/2019/03/13/Web安全的一次探讨/</id>
    <published>2019-03-13T04:14:14.000Z</published>
    <updated>2019-05-22T09:17:14.833Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、SQL注入攻击-SQL-Injection"><a href="#一、SQL注入攻击-SQL-Injection" class="headerlink" title="一、SQL注入攻击(SQL Injection)"></a>一、SQL注入攻击(SQL Injection)</h3><p>攻击者把sql命令插入到web表单的输入域或页面请求的字符串，欺骗服务器执行恶意的sql命令。常见的sql注入攻击类似：</p><h5 id="登录页面中输入内容直接用来构造动态的sql语句，例如："><a href="#登录页面中输入内容直接用来构造动态的sql语句，例如：" class="headerlink" title="登录页面中输入内容直接用来构造动态的sql语句，例如："></a>登录页面中输入内容直接用来构造动态的sql语句，例如：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$query = &apos;select * from users where login = &apos;. $username. &apos;and password = &apos;. $password;</span><br></pre></td></tr></table></figure><a id="more"></a><p>攻击者如果在用户名或者密码框输入<code>or &#39;1&#39; =1</code>，这样我们执行的sql语句就变成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where login = &apos;&apos; or &apos;1&apos; = 1 and ...</span><br></pre></td></tr></table></figure><p>这样就绕过了我们的登录验证。类似的还有很多，用户通过输入恶意的sql命令来绕过我们的验证，欺骗我们的系统。</p><h5 id="防范的方法："><a href="#防范的方法：" class="headerlink" title="防范的方法："></a>防范的方法：</h5><ol><li>检查变量数据类型和格式</li><li>过滤特殊的符号</li><li>绑定变量，使用预处理语句（当我们绑定变量的时候，就算有特殊字符sql也会认为是个变量而不是sql命令）</li></ol><h3 id="二、跨站脚本攻击-Cross-Site-Scripting-XSS；因为CSS被用了所以叫XSS"><a href="#二、跨站脚本攻击-Cross-Site-Scripting-XSS；因为CSS被用了所以叫XSS" class="headerlink" title="二、跨站脚本攻击(Cross Site Scripting, XSS；因为CSS被用了所以叫XSS)"></a>二、跨站脚本攻击(Cross Site Scripting, XSS；因为CSS被用了所以叫XSS)</h3><p>攻击者将恶意代码注入到网页上，其他用户在加载网页时就会执行代码，攻击者可能会得到各种私密的信息，如cookie等。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    echo &apos;你好！&apos;.$_GET[&apos;name&apos;];</span><br></pre></td></tr></table></figure><p>如果用户传入一段脚本<code>&lt;script&gt;[code]&lt;/script&gt;</code>，那么脚本也会执行，如果code的内容是获取到cookie并发送到某个指定的位置，获取了敏感的信息。亦或是利用用户的身份去执行一些不正当的操作。</p><h5 id="防范的方法：-1"><a href="#防范的方法：-1" class="headerlink" title="防范的方法："></a>防范的方法：</h5><ol><li>输出的时候过滤特殊的字符，转换成html编码，过滤输出的变量（PHP可以使用htmlspecialchars）</li></ol><h3 id="三、跨站请求伪造攻击-Cross-Site-Request-Forgeries-CSRF"><a href="#三、跨站请求伪造攻击-Cross-Site-Request-Forgeries-CSRF" class="headerlink" title="三、跨站请求伪造攻击(Cross Site Request Forgeries, CSRF)"></a>三、跨站请求伪造攻击(Cross Site Request Forgeries, CSRF)</h3><p>攻击者伪造目标用户的HTTP请求，然后此请求发送到有CSRF漏洞的网站，网站执行此请求后，引发跨站请求伪造攻击。攻击者利用隐蔽的HTTP连接，让目标用户在不注意的情况下单击这个链接，由于是用户自己点击的，而他又是合法用户拥有合法权限，所以目标用户能够在网站内执行特定的HTTP链接，从而达到攻击者的目的。  </p><blockquote><p>  用户刚刚登陆了银行A网站，建立了会话，A网站可以进行转账操作<code>http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000</code>在没有退出的情况下去访问危险网站B网站，B网站有一个图片是这样的<code>&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;</code>，不小心点了B网站，用户发现账上少了1000块。  </p></blockquote><p>可能有人会说，修改操作并不会用get请求。那么假设银行A网站的表单如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;Transfer.php&quot; method=&quot;POST&quot;&gt;</span><br><span class="line">    &lt;p&gt;ToBankId: &lt;input type=&quot;text&quot; name=&quot;toBankId&quot; /&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;Money: &lt;input type=&quot;text&quot; name=&quot;money&quot; /&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Transfer&quot; /&gt;&lt;/p&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>后台处理页面如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">session_start();</span><br><span class="line">if (isset($_REQUEST[&apos;toBankId&apos;] &amp;&amp; isset($_POST[&apos;money&apos;]))</span><br><span class="line">&#123;</span><br><span class="line">    buy_stocks($_REQUEST[&apos;toBankId&apos;],$_REQUEST[&apos;money&apos;]);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>B网站这时候也相应的改了代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">　　　　&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">　　　　　　function steal()</span><br><span class="line">　　　　　　&#123;</span><br><span class="line">          　　　　 iframe = document.frames[&quot;steal&quot;];</span><br><span class="line">　　     　　      iframe.document.Submit(&quot;transfer&quot;);</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&lt;/script&gt;</span><br><span class="line">　　&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">　　&lt;body onload=&quot;steal()&quot;&gt;</span><br><span class="line">　　　　&lt;iframe name=&quot;steal&quot; display=&quot;none&quot;&gt;</span><br><span class="line">　　　　　　&lt;form method=&quot;POST&quot; name=&quot;transfer&quot;　action=&quot;http://www.myBank.com/Transfer.php&quot;&gt;</span><br><span class="line">　　　　　　　　&lt;input type=&quot;hidden&quot; name=&quot;toBankId&quot; value=&quot;11&quot;&gt;</span><br><span class="line">　　　　　　　　&lt;input type=&quot;hidden&quot; name=&quot;money&quot; value=&quot;1000&quot;&gt;</span><br><span class="line">　　　　　　&lt;/form&gt;</span><br><span class="line">　　　　&lt;/iframe&gt;</span><br><span class="line">　　&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>用户一点到B网站，发现又少了1000块…….</p><h5 id="防范方法："><a href="#防范方法：" class="headerlink" title="防范方法："></a>防范方法：</h5><ul><li>对表单进行cookie hash校验，将一个随机值的hash写入cookie，每次提交表单，都在服务端对这个hash进行校验（建立在用户的cookie没有被盗取）</li></ul><h3 id="四、Session固定攻击-Session-Fixation"><a href="#四、Session固定攻击-Session-Fixation" class="headerlink" title="四、Session固定攻击(Session Fixation)"></a>四、Session固定攻击(Session Fixation)</h3><p>攻击者预先设定session id，让合法用户使用这个session id来访问被攻击的应用程序，一旦用户的会话ID被成功固定，攻击者就可以通过此session id来冒充用户访问应用程序。例如：  </p><ol><li>攻击者先访问目标网站，获得了自己的session_id，如SID=123</li><li>攻击者给目标用户发送链接，并带上了自己的session_id，如<code>http:///www.bank.com/?SID=123</code>，</li><li>目标用户点击了<code>http:///www.bank.com/?SID=123</code>，输入用户名密码登录，由于session_id不会变更，那么攻击者就可以通过访问<code>http:///www.bank.com/?SID=123</code>来获取目标用户的身份。</li></ol><h5 id="防范方法：-1"><a href="#防范方法：-1" class="headerlink" title="防范方法："></a>防范方法：</h5><ol><li>定期更改session_id</li><li>更改session_id的名字</li></ol><h3 id="五、Session劫持-Session-Hijacking"><a href="#五、Session劫持-Session-Hijacking" class="headerlink" title="五、Session劫持(Session Hijacking)"></a>五、Session劫持(Session Hijacking)</h3><p>攻击者利用各种手段来获取目标用户的session id。一旦获取到session id，那么攻击者可以利用目标用户的身份来登录网站，获取目标用户的操作权限。</p><h5 id="攻击者获取目标用户session-id的方法"><a href="#攻击者获取目标用户session-id的方法" class="headerlink" title="攻击者获取目标用户session id的方法:"></a>攻击者获取目标用户session id的方法:</h5><ol><li>暴力破解:尝试各种session id，直到破解为止;</li><li>计算:如果session id使用非随机的方式产生，那么就有可能计算出来;</li><li>窃取:使用网络截获，xss攻击等方法获得<br>防范方法：</li><li>定期更改session id</li><li>更改session的名称</li><li>关闭透明化session id</li><li>设置HttpOnly。通过设置Cookie的HttpOnly为true，可以防止客户端脚本访问这个Cookie，从而有效的防止XSS攻击。</li></ol><h3 id="六、文件上传漏洞-File-Upload-Attack"><a href="#六、文件上传漏洞-File-Upload-Attack" class="headerlink" title="六、文件上传漏洞(File Upload Attack)"></a>六、文件上传漏洞(File Upload Attack)</h3><p>攻击者利用程序缺陷绕过系统对文件的验证与处理策略将恶意代码上传到服务器并获得执行服务器端命令的能力。  </p><h5 id="常用的攻击手段有："><a href="#常用的攻击手段有：" class="headerlink" title="常用的攻击手段有："></a>常用的攻击手段有：</h5><ol><li>上传Web脚本代码，Web容器解释执行上传的恶意脚本；</li><li>上传Flash跨域策略文件crossdomain.xml，修改访问权限(其他策略文件利用方式类似)；</li><li>上传病毒、木马文件，诱骗用户和管理员下载执行；</li><li>上传包含脚本的图片，某些浏览器的低级版本会执行该脚本，用于钓鱼和欺诈。<br>总的来说，利用的上传文件要么具备可执行能力(恶意代码)，要么具备影响服务器行为的能力(配置文件)。<br>防范方法：  </li><li>文件上传的目录设置为不可执行；</li><li>判断文件类型，设置白名单。对于图片的处理，可以使用压缩函数或者resize函数，在处理图片的同时破坏图片中可能包含的HTML代码；</li><li>使用随机数改写文件名和文件路径：一个是上传后无法访问；再来就是像shell、.php 、.rar和crossdomain.xml这种文件，都将因为重命名而无法攻击；</li><li>单独设置文件服务器的域名：由于浏览器同源策略的关系，一系列客户端攻击将失效，比如上传crossdomain.xml、上传包含Javascript的XSS利用等问题将得到解决。</li></ol><h3 id="MYSQL安全"><a href="#MYSQL安全" class="headerlink" title="MYSQL安全"></a>MYSQL安全</h3><ol><li>使用预处理语句防止sql注入</li><li>写入数据库的数据要进行特殊字符转义</li><li>查询的错误信息不要返回给用户，将错误记录到日志   </li><li>定期做数据库备份</li><li>不给查询用户root权限，合理分配权限</li><li>关闭远程访问数据库的权限</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、SQL注入攻击-SQL-Injection&quot;&gt;&lt;a href=&quot;#一、SQL注入攻击-SQL-Injection&quot; class=&quot;headerlink&quot; title=&quot;一、SQL注入攻击(SQL Injection)&quot;&gt;&lt;/a&gt;一、SQL注入攻击(SQL Injection)&lt;/h3&gt;&lt;p&gt;攻击者把sql命令插入到web表单的输入域或页面请求的字符串，欺骗服务器执行恶意的sql命令。常见的sql注入攻击类似：&lt;/p&gt;
&lt;h5 id=&quot;登录页面中输入内容直接用来构造动态的sql语句，例如：&quot;&gt;&lt;a href=&quot;#登录页面中输入内容直接用来构造动态的sql语句，例如：&quot; class=&quot;headerlink&quot; title=&quot;登录页面中输入内容直接用来构造动态的sql语句，例如：&quot;&gt;&lt;/a&gt;登录页面中输入内容直接用来构造动态的sql语句，例如：&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$query = &amp;apos;select * from users where login = &amp;apos;. $username. &amp;apos;and password = &amp;apos;. $password;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>关于mysql最左前缀原则</title>
    <link href="https://icocos.github.io/2019/03/01/%E5%85%B3%E4%BA%8Emysql%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99/"/>
    <id>https://icocos.github.io/2019/03/01/关于mysql最左前缀原则/</id>
    <published>2019-03-01T10:47:41.000Z</published>
    <updated>2019-05-22T09:06:40.679Z</updated>
    
    <content type="html"><![CDATA[<h4 id="背景知识："><a href="#背景知识：" class="headerlink" title="背景知识："></a>背景知识：</h4><ol><li>mysql中可以使用explain关键字来查看sql语句的执行计划。</li><li>最左前缀原则主要使用在联合索引中</li><li>数据库版本Mysql5.5.53</li></ol><a id="more"></a><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>mysql建立多列索引（联合索引）有最左前缀的原则，即最左优先，如：</p><ul><li>如果有一个2列的索引(col1,col2),则已经对(col1)、(col1,col2)上建立了索引；</li><li>如果有一个3列索引(col1,col2,col3)，则已经对(col1)、(col1,col2)、(col1,col2,col3)上建立了索引；</li></ul><p>1、b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+树是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道第一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。</p><p>2、比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。（这种情况无法用到联合索引）</p><p>关于最左前缀的使用，有下面两条说明：</p><ul><li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a  = 1 and b = 2 and c &gt; 3 and d = 4  如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li><li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li></ul><p>联合索引有一个最左前缀原则，所以建立联合索引的时候，这个联合索引的字段顺序非常重要</p><p>下面写了例子说明这个：</p><pre><code>CREATE TABLE `test_myisam` (`id` int(11) NOT NULL AUTO_INCREMENT,`conference_id` varchar(200) NOT NULL,`account` varchar(100) DEFAULT NULL,`status` int(2) DEFAULT NULL COMMENT &apos;0:invite,  1:cancel_invite,  2:decline,  3:connect&apos;,`duration` bigint(20) unsigned DEFAULT NULL,`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,PRIMARY KEY (`id`)) ENGINE=myisam AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</code></pre><p>以上表结构，我想通过三列进行查询 account ,status,create_time进行查询统计。</p><h5 id="如何建立索引？"><a href="#如何建立索引？" class="headerlink" title="如何建立索引？"></a>如何建立索引？</h5><p>因为我们有可能按照acccount单独统计，或者按照account status，或者是account，status，create_time进行统计，如何建立索引？？？</p><p>下面是建立索引前后的对比600万数据</p><p>如何生成：执行如下脚本，account和日期不同还有status不同，分别生成一百万。</p><pre><code>CREATE  PROCEDURE `add_data_myisam_cp_27`()begindeclare v_rows int(10) default 1000000;declare v_count int(10) default 0;id_loop:LOOPinsert into test_myisam values(null,round(rand()*1000000000),&apos;cloudp&apos;,round(rand()*3),round(rand()*100000),&apos;2016-07-27 00:00:22&apos;);set v_count= v_count + 1;if v_count&gt;v_rows thenleave id_loop;end if;end loop id_loop;end;</code></pre><p>测试结果利用建立的索引性能提高了三倍：</p><pre><code>MariaDB [prf]&gt; select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and date(create_time)=&apos;2016-07-27&apos;;+----------+| count(1) |+----------+|   167400 |+----------+1 row in set (1.28 sec)MariaDB [prf]&gt; create index as_index on test_myisam(account,status,create_time);Query OK, 6000006 rows affected (31.60 sec)Records: 6000006  Duplicates: 0  Warnings: 0MariaDB [prf]&gt; select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and date(create_time)=&apos;2016-07-27&apos;;+----------+| count(1) |+----------+|   167400 |+----------+1 row in set (0.42 sec)MariaDB [prf]&gt; explain select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and date(create_time)=&apos;2016-07-27&apos;;+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+| id   | select_type | table       | type | possible_keys | key      | key_len | ref         | rows   | Extra                    |+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+|    1 | SIMPLE      | test_myisam | ref  | as_index      | as_index | 308     | const,const | 520216 | Using where; Using index |+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+1 row in set (0.00 sec)</code></pre><p>从1.28秒下降到0.42秒<br>但是这个date(create_time)会对每一列都会转换后对比，这里会比较消耗性能；</p><h5 id="如何利用上索引？？"><a href="#如何利用上索引？？" class="headerlink" title="如何利用上索引？？"></a>如何利用上索引？？</h5><p>修改为：</p><pre><code>MariaDB [prf]&gt; explain select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and date(create_time)=&apos;2016-07-27&apos;;+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+| id   | select_type | table       | type | possible_keys | key      | key_len | ref         | rows   | Extra                    |+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+|    1 | SIMPLE      | test_myisam | ref  | as_index      | as_index | 308     | const,const | 520216 | Using where; Using index |+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+1 row in set (0.00 sec)MariaDB [prf]&gt; select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and create_time  between &apos;2016-07-27&apos; and &apos;2016-07-28&apos;;+----------+| count(1) |+----------+|   167400 |+----------+1 row in set (0.15 sec)MariaDB [prf]&gt; explain select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and create_time  between &apos;2016-07-27&apos; and &apos;2016-07-28&apos;;+------+-------------+-------------+-------+---------------+----------+---------+------+--------+--------------------------+| id   | select_type | table       | type  | possible_keys | key      | key_len | ref  | rows   | Extra                    |+------+-------------+-------------+-------+---------------+----------+---------+------+--------+--------------------------+|    1 | SIMPLE      | test_myisam | range | as_index      | as_index | 312     | NULL | 174152 | Using where; Using index |+------+-------------+-------------+-------+---------------+----------+---------+------+--------+--------------------------+1 row in set (0.00 sec)</code></pre><p>如上效率又提高了三倍，是因为扫描的数据行数减少了，最后一个create_time如果不用索引需要扫描52016行，如果使用了索引扫描174152行，命中的行数为：167400行，命中率非常高了。</p><h5 id="这里有个疑问："><a href="#这里有个疑问：" class="headerlink" title="这里有个疑问："></a>这里有个疑问：</h5><blockquote><p> 如果按照天进行统计，create_time作为联合索引的第一列，如何使用上这个索引呢？？？？</p></blockquote><p>至今没有想清楚，如果这一列是date类型可以直接用上索引，如果在oracle中可以date(create_time)建立函数式索引。但是mysql貌似不支持函数式索引。</p><h5 id="一个解决方式是："><a href="#一个解决方式是：" class="headerlink" title="一个解决方式是："></a>一个解决方式是：</h5><blockquote><p>create_time定义为 date类型，在每一列存入的时候，通过触发器自动把这一行修改为date类型。</p></blockquote><p>如果有好的注意欢迎留言探讨，目前没有好的方式加上create_time，可以从业务上解决，就是每天的统计计算完成以后，直接把数据推到历史表中，统计结果单独存放。</p><h5 id="最后说一下关于索引失效的问题："><a href="#最后说一下关于索引失效的问题：" class="headerlink" title="最后说一下关于索引失效的问题："></a>最后说一下关于索引失效的问题：</h5><ol><li>如果条件中有or，即使其中有条件带索引也不会使用(<strong>这也是为什么尽量少用or的原因</strong>)。<strong>注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引</strong></li><li>对于多列索引，不是使用的第一部分，则不会使用索引（即不符合最左前缀原则）</li><li>like查询是以%开头</li><li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引</li><li>如果mysql估计使用全表扫描要比使用索引快,则不使用索引</li></ol><h6 id="此外，查看索引的使用情况"><a href="#此外，查看索引的使用情况" class="headerlink" title="此外，查看索引的使用情况"></a>此外，查看索引的使用情况</h6><ul><li><p>show status like ‘Handler_read%’;</p></li><li><p>handler_read_key:这个值越高越好，越高表示使用索引查询到的次数</p></li><li>handler_read_rnd_next:这个值越高，说明查询低效</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;背景知识：&quot;&gt;&lt;a href=&quot;#背景知识：&quot; class=&quot;headerlink&quot; title=&quot;背景知识：&quot;&gt;&lt;/a&gt;背景知识：&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;mysql中可以使用explain关键字来查看sql语句的执行计划。&lt;/li&gt;
&lt;li&gt;最左前缀原则主要使用在联合索引中&lt;/li&gt;
&lt;li&gt;数据库版本Mysql5.5.53&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="MySQL" scheme="https://icocos.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://icocos.github.io/tags/MySQL/"/>
    
      <category term="最佳左前缀" scheme="https://icocos.github.io/tags/%E6%9C%80%E4%BD%B3%E5%B7%A6%E5%89%8D%E7%BC%80/"/>
    
  </entry>
  
  <entry>
    <title>高并发大流解决量方案</title>
    <link href="https://icocos.github.io/2019/02/17/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%A4%A7%E6%B5%81%E8%A7%A3%E5%86%B3%E9%87%8F%E6%96%B9%E6%A1%88/"/>
    <id>https://icocos.github.io/2019/02/17/高并发大流解决量方案/</id>
    <published>2019-02-17T04:14:14.000Z</published>
    <updated>2019-05-22T09:17:27.845Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><ul><li>QPS:每秒钟请求或者查询的数量，通常是指每秒相应请求数（http）<ul><li>QPS不等于并发连接数，QPS是每秒的HTTP请求数量，并发连接数是指系统同时处理的请求数量  </li><li>峰值的每秒请求数（QPS）= (总PV数 <em> 80%)/(6小时秒数 </em> 20%)  </li><li>峰值QPS的计算规律主要是80%的访问量集中在20%的访问时间</li></ul></li><li>吞吐量：单位时间内处理请求的数量</li><li>响应时间：从请求发出到收到响应花费的时间</li><li>PV(page view)综合浏览量，即页面点击数。通常日PV在千万级就是高并发的网站</li><li>UV(unique visitor)独立访客，一定时间内相同访客访问网站，只计算为1个独立访客</li></ul><a id="more"></a><ul><li><p>带宽：计算带宽大小，我们需要关注两个指标，峰值流量和平均大小</p><blockquote><p>日网站的带宽 = PV/统计时间（秒） <em> 平均页面大小（KB） </em> 8  </p></blockquote></li><li><p>压力测试</p><ul><li>1.测试能承受的最大并发  </li><li>2.测试最大承受QPS值  </li></ul></li></ul><h5 id="ab-apache-benchmark-工具使用"><a href="#ab-apache-benchmark-工具使用" class="headerlink" title="ab(apache benchmark)工具使用:"></a>ab(apache benchmark)工具使用:</h5><p>ab会创建多个并发访问线程，模拟多个访问者同时对一个URL地址进行访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ab的基本使用</span><br><span class="line">ab -c 100 -n 5000 url</span><br><span class="line">并发请求100次，总共5000次</span><br><span class="line"></span><br><span class="line">测试时注意被测试机器的CPU、内存、网络都不超过最高限度的75%</span><br></pre></td></tr></table></figure><p>此处介绍一些QPS的数值：</p><ol><li>50：小型网站，一般服务器即可应付</li><li>100：假设数据库每次请求都在0.01秒内完成，单个页面只有一个sql，100QPS意味着1秒钟要完成100次请求，但是我们数据库不一定能完成100次查询。此时优化方案为：数据库缓存、数据库负载均衡</li><li>800：假设网站有百兆带宽，意味着实际出口的带宽为8M左右，如果每个页面只有10K，在这个QPS下，带宽已经吃完。此时的方案：CDN加速，负载均衡</li><li>1000： 假设使用nosql来缓存数据库查询（memcache或redis），每个页面对nosql的请求远大于直接对DB的请求</li><li>2000： 业务分离，做分布式存储</li></ol><h3 id="二、优化方案"><a href="#二、优化方案" class="headerlink" title="二、优化方案"></a>二、优化方案</h3><ul><li>流量优化：  </li></ul><ol><li>防盗链处理 </li><li>减少前端http请求（合并css、js等静态资源）</li><li>添加异步请求，减少http请求的并发量</li><li>启用浏览器的缓存和使用文件压缩</li><li>CDN加速，减轻服务器压力和带宽压力<ul><li>服务端优化  </li></ul><ol><li>页面静态化</li><li>并发处理</li></ol><ul><li>数据库优化  </li></ul><ol><li>数据库缓存</li><li>分库分表，分区操作</li><li>读写分离</li><li>负载均衡</li></ol><ul><li>web服务器优化  </li></ul><ol><li>负载均衡</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、概念&quot;&gt;&lt;a href=&quot;#一、概念&quot; class=&quot;headerlink&quot; title=&quot;一、概念&quot;&gt;&lt;/a&gt;一、概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;QPS:每秒钟请求或者查询的数量，通常是指每秒相应请求数（http）&lt;ul&gt;
&lt;li&gt;QPS不等于并发连接数，QPS是每秒的HTTP请求数量，并发连接数是指系统同时处理的请求数量  &lt;/li&gt;
&lt;li&gt;峰值的每秒请求数（QPS）= (总PV数 &lt;em&gt; 80%)/(6小时秒数 &lt;/em&gt; 20%)  &lt;/li&gt;
&lt;li&gt;峰值QPS的计算规律主要是80%的访问量集中在20%的访问时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;吞吐量：单位时间内处理请求的数量&lt;/li&gt;
&lt;li&gt;响应时间：从请求发出到收到响应花费的时间&lt;/li&gt;
&lt;li&gt;PV(page view)综合浏览量，即页面点击数。通常日PV在千万级就是高并发的网站&lt;/li&gt;
&lt;li&gt;UV(unique visitor)独立访客，一定时间内相同访客访问网站，只计算为1个独立访客&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>深入理解PHP之：Nginx 与 FPM 的工作机制</title>
    <link href="https://icocos.github.io/2019/02/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E4%B9%8B%EF%BC%9ANginx-%E4%B8%8E-FPM-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/"/>
    <id>https://icocos.github.io/2019/02/15/深入理解PHP之：Nginx-与-FPM-的工作机制/</id>
    <published>2019-02-15T09:54:22.000Z</published>
    <updated>2019-05-21T08:52:03.574Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>网络上有很多关于如何配置 Nginx + FPM 的文章，但它们更多从操作的角度出发，告诉我们怎么做，但却没有告诉我们为什么要这么做，本文从 Nginx 与 FPM 的工作机制出发，探讨配置背后的原理，让我们真正理解 Nginx 与 PHP 是如何协同工作的。</p><h4 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h4><p>要说 Nginx 与 PHP 是如何协同工作的，首先得说 CGI (Common Gateway Interface) 和 FastCGI 这两个协议。</p><a id="more"></a><blockquote><p>CGI 是 Web Server 与后台语言交互的协议，有了这个协议，开发者可以使用任何语言处理 Web Server 发来的请求，动态的生成内容。但 CGI 有一个致命的缺点，那就是每处理一个请求都需要 fork 一个全新的进程，随着 Web 的兴起，高并发越来越成为常态，这样低效的方式明显不能满足需求。就这样，FastCGI 诞生了，CGI 很快就退出了历史的舞台。FastCGI，顾名思义为更快的 CGI，它允许在一个进程内处理多个请求，而不是一个请求处理完毕就直接结束进程，性能上有了很大的提高。</p></blockquote><p>FPM (FastCGI Process Manager)，它是 FastCGI 的实现，任何实现了 FastCGI 协议的 Web Server 都能够与之通信。FPM 之于标准的 FastCGI，也提供了一些增强功能，具体可以参考官方文档：PHP: FPM Installation。</p><pre><code>FPM 是一个 PHP 进程管理器，包含 master 进程和 worker 进程两种进程：master 进程只有一个，负责监听端口，接收来自 Web Server 的请求，而 worker 进程则一般有多个 (具体数量根据实际需要配置)，每个进程内部都嵌入了一个 PHP 解释器，是 PHP 代码真正执行的地方，下图是我本机上 fpm 的进程情况，1一个 master 进程，3个 worker 进程：</code></pre><p><img src="http://img0.ph.126.net/WMv1Zu5I-rlmKMoUTc68-Q==/6631597730303787300.png" alt="fpm进程"></p><p>从 FPM 接收到请求，到处理完毕，其具体的流程如下：</p><pre><code>1. FPM 的 master 进程接收到请求2. master 进程根据配置指派特定的 worker进程进行请求处理，如果没有可用进程，返回错误，这也是我们配合 Nginx 遇到502错误比较多的原因。3. worker 进程处理请求，如果超时，返回504错误4. 请求处理结束，返回结果</code></pre><p>FPM 从接收到处理请求的流程就是这样了，那么 Nginx 又是如何发送请求给 fpm 的呢？这就需要从 Nginx 层面来说明了。</p><p>Nginx 不仅仅是一个 Web 服务器，也是一个功能强大的 Proxy 服务器，除了进行 http 请求的代理，也可以进行许多其他协议请求的代理，包括本文与 fpm 相关的 fastcgi 协议。为了能够使 Nginx 理解 fastcgi 协议，Nginx 提供了 fastcgi 模块来将 http 请求映射为对应的 fastcgi 请求。</p><blockquote><p>Nginx 的 fastcgi 模块提供了 fastcgi_param 指令来主要处理这些映射关系，下面 Ubuntu 下 Nginx 的一个配置文件，其主要完成的工作是将 Nginx 中的变量翻译成 PHP 中能够理解的变量。</p></blockquote><p><img src="http://img2.ph.126.net/QWqq90MIXEcQnTA7ft1WVg==/6631819831652599451.jpg" alt="fastcgi_param"></p><p>除此之外，非常重要的就是 fastcgi_pass 指令了，这个指令用于指定 fpm 进程监听的地址，Nginx 会把所有的 php 请求翻译成 fastcgi 请求之后再发送到这个地址。下面一个简单的可以工作的 Nginx 配置文件：</p><p><img src="http://img0.ph.126.net/tLal8xnxIanLB_mfp2dHUQ==/6631751661931678563.jpg" alt="nginx配置"></p><p>在这个配置文件中，我们新建了一个虚拟主机，监听在 80 端口，Web 根目录为 /home/rf/projects/wordpress。然后我们通过 location 指令，将所有的以 .php 结尾的请求都交给 fastcgi 模块处理，从而把所有的 php 请求都交给了 fpm 处理，从而完成 Nginx 到 fpm 的闭环。</p><p>如此以来，Nginx 与 FPM 通信的整个流程应该比较清晰了吧。</p><ol><li>nginx是web服务器，提供http服务。</li><li>php代码需要php解析器解析。所以这里要有个nginx和php解析器通信的问题。就出现了一个fastcgi的协议来解决通信问题。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;网络上有很多关于如何配置 Nginx + FPM 的文章，但它们更多从操作的角度出发，告诉我们怎么做，但却没有告诉我们为什么要这么做，本文从 Nginx 与 FPM 的工作机制出发，探讨配置背后的原理，让我们真正理解 Nginx 与 PHP 是如何协同工作的。&lt;/p&gt;
&lt;h4 id=&quot;内容：&quot;&gt;&lt;a href=&quot;#内容：&quot; class=&quot;headerlink&quot; title=&quot;内容：&quot;&gt;&lt;/a&gt;内容：&lt;/h4&gt;&lt;p&gt;要说 Nginx 与 PHP 是如何协同工作的，首先得说 CGI (Common Gateway Interface) 和 FastCGI 这两个协议。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="Nginx" scheme="https://icocos.github.io/tags/Nginx/"/>
    
      <category term="FPM" scheme="https://icocos.github.io/tags/FPM/"/>
    
  </entry>
  
  <entry>
    <title>LVS负载均衡（LVS简介、三种工作模式、十种调度算法）</title>
    <link href="https://icocos.github.io/2019/01/25/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%88LVS%E7%AE%80%E4%BB%8B%E3%80%81%E4%B8%89%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E3%80%81%E5%8D%81%E7%A7%8D%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%89/"/>
    <id>https://icocos.github.io/2019/01/25/LVS负载均衡（LVS简介、三种工作模式、十种调度算法）/</id>
    <published>2019-01-25T10:47:41.000Z</published>
    <updated>2019-05-22T09:17:26.696Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、LVS简介"><a href="#一、LVS简介" class="headerlink" title="一、LVS简介"></a>一、LVS简介</h3><p>LVS（Linux Virtual Server）即Linux虚拟服务器，是由章文嵩博士主导的开源负载均衡项目，目前LVS已经被集成到Linux内核模块中。</p><p>该项目在Linux内核中实现了基于IP的数据请求负载均衡调度方案，终端互联网用户从外部访问公司的外部负载均衡服务器，终端用户的Web请求会发送给LVS调度器，调度器根据自己预设的算法决定将该请求发送给后端的某台Web服务器，比如，轮询算法可以将外部的请求平均分发给后端的所有服务器，终端用户访问LVS调度器虽然会被转发到后端真实的服务器，但如果真实服务器连接的是相同的存储，提供的服务也是相同的服务，最终用户不管是访问哪台真实服务器，得到的服务内容都是一样的，整个集群对用户而言都是透明的。</p><a id="more"></a><blockquote><p> 最后根据LVS工作模式的不同，真实服务器会选择不同的方式将用户需要的数据发送到终端用户，LVS工作模式分为NAT模式、TUN模式、以及DR模式。</p></blockquote><h3 id="二、三种工作模式的解析。"><a href="#二、三种工作模式的解析。" class="headerlink" title="二、三种工作模式的解析。"></a>二、三种工作模式的解析。</h3><h5 id="1、基于NAT的LVS模式负载均衡"><a href="#1、基于NAT的LVS模式负载均衡" class="headerlink" title="1、基于NAT的LVS模式负载均衡"></a>1、基于NAT的LVS模式负载均衡</h5><p> NAT（Network Address Translation）即网络地址转换，其作用是通过数据报头的修改，使得位于企业内部的私有IP地址可以访问外网，以及外部用用户可以访问位于公司内部的私有IP主机。VS/NAT工作模式拓扑结构如图2所示，LVS负载调度器可以使用两块网卡配置不同的IP地址，eth0设置为私钥IP与内部网络通过交换设备相互连接，eth1设备为外网IP与外部网络联通。</p><ul><li>第一步，用户通过互联网DNS服务器解析到公司负载均衡设备上面的外网地址，相对于真实服务器而言，LVS外网IP又称VIP（Virtual IP Address），用户通过访问VIP，即可连接后端的真实服务器（Real Server），而这一切对用户而言都是透明的，用户以为自己访问的就是真实服务器，但他并不知道自己访问的VIP仅仅是一个调度器，也不清楚后端的真实服务器到底在哪里、有多少真实服务器。</li><li>第二步，用户将请求发送至124.126.147.168，此时LVS将根据预设的算法选择后端的一台真实服务器（192.168.0.1~192.168.0.3），将数据请求包转发给真实服务器，并且在转发之前LVS会修改数据包中的目标地址以及目标端口，目标地址与目标端口将被修改为选出的真实服务器IP地址以及相应的端口。</li><li>第三步，真实的服务器将响应数据包返回给LVS调度器，调度器在得到响应的数据包后会将源地址和源端口修改为VIP及调度器相应的端口，修改完成后，由调度器将响应数据包发送回终端用户，另外，由于LVS调度器有一个连接Hash表，该表中会记录连接请求及转发信息，当同一个连接的下一个数据包发送给调度器时，从该Hash表中可以直接找到之前的连接记录，并根据记录信息选出相同的真实服务器及端口信息。</li></ul><h5 id="2、基于TUN的LVS负载均衡"><a href="#2、基于TUN的LVS负载均衡" class="headerlink" title="2、基于TUN的LVS负载均衡"></a>2、基于TUN的LVS负载均衡</h5><p>在LVS（NAT）模式的集群环境中，由于所有的数据请求及响应的数据包都需要经过LVS调度器转发，如果后端服务器的数量大于10台，则调度器就会成为整个集群环境的瓶颈。我们知道，数据请求包往往远小于响应数据包的大小。因为响应数据包中包含有客户需要的具体数据，所以LVS（TUN）的思路就是将请求与响应数据分离，让调度器仅处理数据请求，而让真实服务器响应数据包直接返回给客户端。</p><p>VS/TUN工作模式拓扑结构如图3所示。其中，IP隧道（IP tunning）是一种数据包封装技术，它可以将原始数据包封装并添加新的包头（内容包括新的源地址及端口、目标地址及端口），从而实现将一个目标为调度器的VIP地址的数据包封装，通过隧道转发给后端的真实服务器（Real Server），通过将客户端发往调度器的原始数据包封装，并在其基础上添加新的数据包头（修改目标地址为调度器选择出来的真实服务器的IP地址及对应端口），LVS（TUN）模式要求真实服务器可以直接与外部网络连接，真实服务器在收到请求数据包后直接给客户端主机响应数据。</p><h5 id="3、基于DR的LVS负载均衡"><a href="#3、基于DR的LVS负载均衡" class="headerlink" title="3、基于DR的LVS负载均衡"></a>3、基于DR的LVS负载均衡</h5><p>在LVS（TUN）模式下，由于需要在LVS调度器与真实服务器之间创建隧道连接，这同样会增加服务器的负担。与LVS（TUN）类似，DR模式也叫直接路由模式，其体系结构如图4所示，该模式中LVS依然仅承担数据的入站请求以及根据算法选出合理的真实服务器，最终由后端真实服务器负责将响应数据包发送返回给客户端。与隧道模式不同的是，直接路由模式（DR模式）要求调度器与后端服务器必须在同一个局域网内，VIP地址需要在调度器与后端所有的服务器间共享，因为最终的真实服务器给客户端回应数据包时需要设置源IP为VIP地址，目标IP为客户端IP，这样客户端访问的是调度器的VIP地址，回应的源地址也依然是该VIP地址（真实服务器上的VIP），客户端是感觉不到后端服务器存在的。由于多台计算机都设置了同样一个VIP地址，所以在直接路由模式中要求调度器的VIP地址是对外可见的，客户端需要将请求数据包发送到调度器主机，而所有的真实服务器的VIP地址必须配置在Non-ARP的网络设备上，也就是该网络设备并不会向外广播自己的MAC及对应的IP地址，真实服务器的VIP对外界是不可见的，但真实服务器却可以接受目标地址VIP的网络请求，并在回应数据包时将源地址设置为该VIP地址。调度器根据算法在选出真实服务器后，在不修改数据报文的情况下，将数据帧的MAC地址修改为选出的真实服务器的MAC地址，通过交换机将该数据帧发给真实服务器。整个过程中，真实服务器的VIP不需要对外界可见。</p><h3 id="三、LVS负载均衡调度算法"><a href="#三、LVS负载均衡调度算法" class="headerlink" title="三、LVS负载均衡调度算法"></a>三、LVS负载均衡调度算法</h3><p>根据前面的介绍，我们了解了LVS的三种工作模式，但不管实际环境中采用的是哪种模式，调度算法进行调度的策略与算法都是LVS的核心技术，LVS在内核中主要实现了一下十种调度算法。</p><h5 id="1-轮询调度"><a href="#1-轮询调度" class="headerlink" title="1.轮询调度"></a>1.轮询调度</h5><p>轮询调度（Round Robin 简称’RR’）算法就是按依次循环的方式将请求调度到不同的服务器上，该算法最大的特点就是实现简单。轮询算法假设所有的服务器处理请求的能力都一样的，调度器会将所有的请求平均分配给每个真实服务器。</p><h5 id="2-加权轮询调度"><a href="#2-加权轮询调度" class="headerlink" title="2.加权轮询调度"></a>2.加权轮询调度</h5><p>加权轮询（Weight Round Robin 简称’WRR’）算法主要是对轮询算法的一种优化与补充，LVS会考虑每台服务器的性能，并给每台服务器添加一个权值，如果服务器A的权值为1，服务器B的权值为2，则调度器调度到服务器B的请求会是服务器A的两倍。权值越高的服务器，处理的请求越多。</p><h5 id="3-最小连接调度"><a href="#3-最小连接调度" class="headerlink" title="3.最小连接调度"></a>3.最小连接调度</h5><p>最小连接调度（Least Connections 简称’LC’）算法是把新的连接请求分配到当前连接数最小的服务器。最小连接调度是一种动态的调度算法，它通过服务器当前活跃的连接数来估计服务器的情况。调度器需要记录各个服务器已建立连接的数目，当一个请求被调度到某台服务器，其连接数加1；当连接中断或者超时，其连接数减1。</p><p>（集群系统的真实服务器具有相近的系统性能，采用最小连接调度算法可以比较好地均衡负载。)</p><h5 id="4-加权最小连接调度"><a href="#4-加权最小连接调度" class="headerlink" title="4.加权最小连接调度"></a>4.加权最小连接调度</h5><p>加权最少连接（Weight Least Connections 简称’WLC’）算法是最小连接调度的超集，各个服务器相应的权值表示其处理性能。服务器的缺省权值为1，系统管理员可以动态地设置服务器的权值。加权最小连接调度在调度新连接时尽可能使服务器的已建立连接数和其权值成比例。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。</p><h5 id="5-基于局部的最少连接"><a href="#5-基于局部的最少连接" class="headerlink" title="5.基于局部的最少连接"></a>5.基于局部的最少连接</h5><p>基于局部的最少连接调度（Locality-Based Least Connections 简称’LBLC’）算法是针对请求报文的目标IP地址的 负载均衡调度，目前主要用于Cache集群系统，因为在Cache集群客户请求报文的目标IP地址是变化的。这里假设任何后端服务器都可以处理任一请求，算法的设计目标是在服务器的负载基本平衡情况下，将相同目标IP地址的请求调度到同一台服务器，来提高各台服务器的访问局部性和Cache命中率，从而提升整个集群系统的处理能力。LBLC调度算法先根据请求的目标IP地址找出该目标IP地址最近使用的服务器，若该服务器是可用的且没有超载，将请求发送到该服务器；若服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则使用’最少连接’的原则选出一个可用的服务器，将请求发送到服务器。</p><h5 id="6-带复制的基于局部性的最少连接"><a href="#6-带复制的基于局部性的最少连接" class="headerlink" title="6.带复制的基于局部性的最少连接"></a>6.带复制的基于局部性的最少连接</h5><p>带复制的基于局部性的最少连接（Locality-Based Least Connections with Replication  简称’LBLCR’）算法也是针对目标IP地址的负载均衡，目前主要用于Cache集群系统，它与LBLC算法不同之处是它要维护从一个目标IP地址到一组服务器的映射，而LBLC算法维护从一个目标IP地址到一台服务器的映射。按’最小连接’原则从该服务器组中选出一一台服务器，若服务器没有超载，将请求发送到该服务器；若服务器超载，则按’最小连接’原则从整个集群中选出一台服务器，将该服务器加入到这个服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。</p><h5 id="7-目标地址散列调度"><a href="#7-目标地址散列调度" class="headerlink" title="7.目标地址散列调度"></a>7.目标地址散列调度</h5><p>目标地址散列调度（Destination Hashing 简称’DH’）算法先根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且并未超载，将请求发送到该服务器，否则返回空。</p><h5 id="8-源地址散列调度U"><a href="#8-源地址散列调度U" class="headerlink" title="8.源地址散列调度U"></a>8.源地址散列调度U</h5><p>源地址散列调度（Source Hashing  简称’SH’）算法先根据请求的源IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且并未超载，将请求发送到该服务器，否则返回空。它采用的散列函数与目标地址散列调度算法的相同，它的算法流程与目标地址散列调度算法的基本相似。</p><h5 id="9-最短的期望的延迟"><a href="#9-最短的期望的延迟" class="headerlink" title="9.最短的期望的延迟"></a>9.最短的期望的延迟</h5><p>最短的期望的延迟调度（Shortest Expected Delay 简称’SED’）算法基于WLC算法。举个例子吧，ABC三台服务器的权重分别为1、2、3 。那么如果使用WLC算法的话一个新请求进入时它可能会分给ABC中的任意一个。使用SED算法后会进行一个运算</p><p>A：（1+1）/1=2   B：（1+2）/2=3/2   C：（1+3）/3=4/3   就把请求交给得出运算结果最小的服务器。</p><h5 id="10-最少队列调度"><a href="#10-最少队列调度" class="headerlink" title="10.最少队列调度"></a>10.最少队列调度</h5><p>最少队列调度（Never Queue 简称’NQ’）算法，无需队列。如果有realserver的连接数等于0就直接分配过去，不需要在进行SED运算。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、LVS简介&quot;&gt;&lt;a href=&quot;#一、LVS简介&quot; class=&quot;headerlink&quot; title=&quot;一、LVS简介&quot;&gt;&lt;/a&gt;一、LVS简介&lt;/h3&gt;&lt;p&gt;LVS（Linux Virtual Server）即Linux虚拟服务器，是由章文嵩博士主导的开源负载均衡项目，目前LVS已经被集成到Linux内核模块中。&lt;/p&gt;
&lt;p&gt;该项目在Linux内核中实现了基于IP的数据请求负载均衡调度方案，终端互联网用户从外部访问公司的外部负载均衡服务器，终端用户的Web请求会发送给LVS调度器，调度器根据自己预设的算法决定将该请求发送给后端的某台Web服务器，比如，轮询算法可以将外部的请求平均分发给后端的所有服务器，终端用户访问LVS调度器虽然会被转发到后端真实的服务器，但如果真实服务器连接的是相同的存储，提供的服务也是相同的服务，最终用户不管是访问哪台真实服务器，得到的服务内容都是一样的，整个集群对用户而言都是透明的。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>关于流量优化方案</title>
    <link href="https://icocos.github.io/2019/01/11/%E5%85%B3%E4%BA%8E%E6%B5%81%E9%87%8F%E4%BC%98%E5%8C%96/"/>
    <id>https://icocos.github.io/2019/01/11/关于流量优化/</id>
    <published>2019-01-11T04:14:14.000Z</published>
    <updated>2019-05-22T09:06:19.887Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、防盗链"><a href="#一、防盗链" class="headerlink" title="一、防盗链"></a>一、防盗链</h3><h5 id="盗链"><a href="#盗链" class="headerlink" title="盗链"></a>盗链</h5><blockquote><p>在自己的页面上展示一些并不在自己服务器上的内容。<br>获取他人服务器上的资源地址，绕过别人的资源展示页面，直接在自己的页面上向用户输出<br>防盗链则是防止别人通过技术手段盗取本站的资源，让不是本站展示的资源链接失效</p></blockquote><a id="more"></a><h5 id="防盗链原理："><a href="#防盗链原理：" class="headerlink" title="防盗链原理："></a>防盗链原理：</h5><p>通过referer或者签名（在资源地址后面带上一串签名，每次收到请求验证签名），网站可以检测目标访问的来源网页，如果是资源文件，则可以跟踪到他显示的网页地址。一旦检测到来源不是本站则进行组织或者返回指定页面。</p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><blockquote><p>Referer</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Nginx模块 ngx_http_referer_module 用来阻挡来源非法的域名请求</span><br><span class="line">Nginx指令 valid_referers 全局变量$invalid_referer</span><br><span class="line"></span><br><span class="line">valid_referers none|blocked|server_names|string....;</span><br><span class="line">none: referer 来源头部为空</span><br><span class="line">blocked: referer不为空，但是里面的值被代理或者防火墙删除了，这些值并不以http：//或者https://开头</span><br><span class="line">server_names: referer来源头部包含当前的server_names</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">location ~ .*\.(gif|jpeg|png|flv|swf|rar|zip)$</span><br><span class="line">&#123;</span><br><span class="line">    valid_referer none blocked haobin.com *.haobin.com;</span><br><span class="line">    if($invalid_referer)</span><br><span class="line">    &#123;</span><br><span class="line">        #return 403;</span><br><span class="line">        rewrite ^/http://www.haobin.com/403.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="如果有人伪造referer，可以通过签名的方法解决"><a href="#如果有人伪造referer，可以通过签名的方法解决" class="headerlink" title="如果有人伪造referer，可以通过签名的方法解决"></a>如果有人伪造referer，可以通过签名的方法解决</h5><blockquote><p>加密签名</p></blockquote><p>通过第三方模块HttpAccessKeyModule实现Nginx防盗链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">首先安装这个模块</span><br><span class="line">accesskey on|off    模块开关</span><br><span class="line">accesskey_hashmethod md5 | sha-1    指定签名加密方式</span><br><span class="line">accesskey_arg    GET参数的名称</span><br><span class="line">accesskey_signature     加密规则</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">location ~ .*\.(gif|jpeg|png|flv|swf|zip|rar)$</span><br><span class="line">&#123;</span><br><span class="line">    accesskey on;</span><br><span class="line">    accesskey_hashmethod md5;</span><br><span class="line">    accesskey_arg &quot;key&quot;;</span><br><span class="line">    accesskey_signature &quot;sign$remote_addr&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、减少HTTP请求"><a href="#二、减少HTTP请求" class="headerlink" title="二、减少HTTP请求"></a>二、减少HTTP请求</h3><h5 id="性能黄金法则："><a href="#性能黄金法则：" class="headerlink" title="性能黄金法则："></a>性能黄金法则：</h5><p>只有10%-20%的最终用户响应时间花在接受请求的HTML文档上，剩下的80%-90%时间花在HTML文档所引用的组件（图片、css、script等）进行的http请求上</p><h5 id="1-图片地图：允许在一个图片上关联多个url，目标的url选择取决于用户单击了图片上的哪个位置。"><a href="#1-图片地图：允许在一个图片上关联多个url，目标的url选择取决于用户单击了图片上的哪个位置。" class="headerlink" title="1.图片地图：允许在一个图片上关联多个url，目标的url选择取决于用户单击了图片上的哪个位置。"></a>1.图片地图：允许在一个图片上关联多个url，目标的url选择取决于用户单击了图片上的哪个位置。</h5><p>例如有五张图片，每张图片对应一个超链接。此时就产生了五个http请求，我们将五张图片合成为一张图片，然后以图片的位置定位超链接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">实现</span><br><span class="line">&lt;map&gt;</span><br><span class="line">    &lt;area&gt;&lt;/area&gt;</span><br><span class="line">    &lt;area&gt;&lt;/area&gt;</span><br><span class="line">    &lt;area&gt;&lt;/area&gt;</span><br><span class="line">    ........</span><br><span class="line">&lt;/map&gt;</span><br></pre></td></tr></table></figure><h5 id="2-CSS-Sprites（CSS-精灵）"><a href="#2-CSS-Sprites（CSS-精灵）" class="headerlink" title="2.CSS Sprites（CSS 精灵）"></a>2.CSS Sprites（CSS 精灵）</h5><p>通过使用合并图片，指定css的background-image和background-position来显示元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background-position属性</span><br><span class="line">background-position:x,y; x和y可以写正值也可以写负值，我们可以想象图片左上方(0,0)，以(0,0)坐标向右的是负数的x轴，以(0,0)坐标向下的是负数的y轴</span><br></pre></td></tr></table></figure><h5 id="3-合并脚本和样式表"><a href="#3-合并脚本和样式表" class="headerlink" title="3.合并脚本和样式表"></a>3.合并脚本和样式表</h5><h5 id="4-图片使用base64编码减少页面请求数"><a href="#4-图片使用base64编码减少页面请求数" class="headerlink" title="4.图片使用base64编码减少页面请求数"></a>4.图片使用base64编码减少页面请求数</h5><blockquote><p>采用Base64编码直接将图片嵌入网页当中</p></blockquote><h3 id="三、浏览器缓存和压缩技术"><a href="#三、浏览器缓存和压缩技术" class="headerlink" title="三、浏览器缓存和压缩技术"></a>三、浏览器缓存和压缩技术</h3><h5 id="1-HTTP缓存分类"><a href="#1-HTTP缓存分类" class="headerlink" title="1.HTTP缓存分类"></a>1.HTTP缓存分类</h5><blockquote><p>http缓存类型中，请求成功会有三种情况：</p></blockquote><pre><code>200 from cache：直接从本地缓存中获取相应，最快速，最省流量（network的size字段）  304 not modify： 协商缓存，浏览器在没有命中的情况下请求头中发送一定的校验数据到服务端，如果服务端没有改变，浏览器从本地缓存相应，返回304。 该方式，只返回一些基本的头信息，不发送实际的相应体200 ok： 以上两种缓存失败，服务器返回完整的相应。 该方式没有用到缓存，是最慢的。</code></pre><h5 id="2-本地缓存"><a href="#2-本地缓存" class="headerlink" title="2.本地缓存"></a>2.本地缓存</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Pragma： HTTP1.0的属性，该字段设置为no-cache，会告知浏览器禁用本地缓存</span><br><span class="line"></span><br><span class="line">Expires: HTTP1.0的属性，用来启用本地缓存。expires的值对应为一个类似</span><br><span class="line">Thu, 31 Dec 2017 20:11:20 GMT的格林威治时间，告诉浏览器如果还没有到该时间，则缓存有效，无须发送请求。这个时间是服务器返回的，是以服务器的时间为基准，如果服务器和客户端的时间不一致就可能产生差错。</span><br><span class="line"></span><br><span class="line">Cache-Control: 告知浏览器缓存过期的时间间隔。</span><br><span class="line">no-store: 禁止浏览器缓存</span><br><span class="line">no-cache: 不允许直接使用本地缓存，先发起请求和服务器协商</span><br><span class="line">max-age=delta-seconds: 告知浏览器响应本地缓存的最长期限，以秒为单位</span><br><span class="line"></span><br><span class="line">优先级：Pragrma &gt; Cache-Control &gt; Expires</span><br></pre></td></tr></table></figure><h5 id="3-协商缓存"><a href="#3-协商缓存" class="headerlink" title="3.协商缓存"></a>3.协商缓存</h5><blockquote><p>浏览器没有命中本地缓存，如果本地缓存过期或者响应不允许直接使用本地缓存，那么浏览器会发起服务端请求，服务端会验证数据是否被修改，如果没有被修改就通知浏览器使用本地缓存</p></blockquote><p>相关的Header：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: 通知浏览器资源的最后修改时间（一个格林威治时间）</span><br><span class="line">If-Modified-Since: 得到资源最后修改时间后，会将这个If-Modified-Since（Last-Modified的值）提交到服务器做检查，如果没有修改，就返回304</span><br><span class="line"></span><br><span class="line">ETag: HTTP1.1属性，指纹标识符，如果文件发生更改，指纹会改变</span><br><span class="line">If-None_Match: 本地缓存失效，会携带此值（ETage 的值）去请求服务端，服务端判断资源是否改变，如果没有改变，直接使用本地缓存，返回304</span><br></pre></td></tr></table></figure><h5 id="4-缓存对象的选择"><a href="#4-缓存对象的选择" class="headerlink" title="4.缓存对象的选择"></a>4.缓存对象的选择</h5><ul><li>不变的内容适合本地缓存：图像，js，css，可下载的媒体文件等</li><li>适合协商缓存的文件：HTML文件，经常替换的图片，经常修改的js、css等文件</li></ul><h5 id="5-Nginx配置缓存策略"><a href="#5-Nginx配置缓存策略" class="headerlink" title="5.Nginx配置缓存策略"></a>5.Nginx配置缓存策略</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*****通过PHP模拟Last-Modified-&gt;If-Modified-Since模式******</span><br><span class="line">// 读取上一次修改时间</span><br><span class="line">$since = $_SERVER[&apos;HTTP_IF_MODIFIED-SINCE&apos;];</span><br><span class="line">$lifetime = 3600; // 模拟缓存一分钟</span><br><span class="line">// 如果没过期就返回304</span><br><span class="line">if(strtotime($since) + $lifetiem &gt; time())&#123;</span><br><span class="line">    header(&apos;HTTP/1.1 304 NOT MODIFIED&apos;);</span><br><span class="line">    exit;</span><br><span class="line">&#125;</span><br><span class="line">// 返回Last-Modified相应头</span><br><span class="line">header(&apos;Last-Modified: &apos;.gmdate(&apos;D, d M Y H:i:s&apos;, time())). &apos;GMT&apos;);</span><br></pre></td></tr></table></figure><h5 id="Nginx缓存配置："><a href="#Nginx缓存配置：" class="headerlink" title="Nginx缓存配置："></a>Nginx缓存配置：</h5><blockquote><p>本地缓存配置指令：  </p></blockquote><pre><code>add_header： 添加状态码为2XX和3XX的响应头  add_header name value \[always]; 语法格式  可以通过该指令来设置Pragma/Expires/Cache-Control</code></pre><blockquote><p>expires指令： 通知浏览器过期时长  </p></blockquote><pre><code>expires time;  语法格式  为负值表示Cache-Control: no-cache   为正直表示Cache-Control:max-age=指定时间 </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Nginx缓存配置：</span><br><span class="line"># 遇到图片等资源就缓存30天</span><br><span class="line">location ~ .*\.(gif|jpeg|png|flv|swf|zip|rar)$</span><br><span class="line">&#123;</span><br><span class="line">    expires     30d;</span><br><span class="line">&#125;</span><br><span class="line">$ 遇到js/css等资源就缓存12小时</span><br><span class="line">location ~ .*\.(js|css)?$</span><br><span class="line">&#123;</span><br><span class="line">    expires     12h;</span><br><span class="line">&#125;</span><br><span class="line"># expires   max; 代表设置十年的缓存</span><br></pre></td></tr></table></figure><blockquote><p>Nginx协商缓存配置：  </p></blockquote><ul><li>ETage指令： 指定签名 </li><li>etage: on|off; 开关，默认是on</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.(gif|jpeg|png|flv|swf|zip|rar)$</span><br><span class="line">&#123;</span><br><span class="line">    # 默认是开启的</span><br><span class="line">    etag     off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-前端代码和资源的压缩"><a href="#6-前端代码和资源的压缩" class="headerlink" title="6.前端代码和资源的压缩"></a>6.前端代码和资源的压缩</h5><ul><li>JavaScript压缩：去掉多余的空格和回车，替换长变量名，简写代码等</li><li>CSS压缩： 同样是去掉空白符、注释并且优化CSS语义规则</li><li>图片压缩： 借助压缩工具压缩（tinypng、jpegMini、imageoption等）</li><li>Gzip压缩</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Nginx配置:</span><br><span class="line">gizp on|off;    #是否开启gzip</span><br><span class="line">gzip_buffers 32 4K|16 8k #缓冲（在内存中有几块 每块多大）</span><br><span class="line">gzip_comp_level [1-9] #压缩级别（推荐使用6） 级别越高，压缩越小，越占用CPU资源</span><br><span class="line">gzip_disable #正则表达式匹配UA 什么样的uri不进行gzip </span><br><span class="line">gzip_min_length 200 #开始压缩的最小长度</span><br><span class="line">gzip_http_version 1.0|1.1 #开始压缩的http版本协议</span><br><span class="line">gzip_types text/plain application/xml #对那些类型进行压缩，如text、css、html等</span><br></pre></td></tr></table></figure><p>现在前端有很多工具可以对资源进行压缩，打包等。如grunt、webpack等已经很流行了。比较流行的前端框架也有相应的脚手架来帮助打包：vue-cli、angular-cli等</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、防盗链&quot;&gt;&lt;a href=&quot;#一、防盗链&quot; class=&quot;headerlink&quot; title=&quot;一、防盗链&quot;&gt;&lt;/a&gt;一、防盗链&lt;/h3&gt;&lt;h5 id=&quot;盗链&quot;&gt;&lt;a href=&quot;#盗链&quot; class=&quot;headerlink&quot; title=&quot;盗链&quot;&gt;&lt;/a&gt;盗链&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;在自己的页面上展示一些并不在自己服务器上的内容。&lt;br&gt;获取他人服务器上的资源地址，绕过别人的资源展示页面，直接在自己的页面上向用户输出&lt;br&gt;防盗链则是防止别人通过技术手段盗取本站的资源，让不是本站展示的资源链接失效&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="服务器" scheme="https://icocos.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="流量" scheme="https://icocos.github.io/tags/%E6%B5%81%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>分区、分表、分库、分片入门</title>
    <link href="https://icocos.github.io/2018/12/23/%E5%88%86%E5%8C%BA%E3%80%81%E5%88%86%E8%A1%A8%E3%80%81%E5%88%86%E5%BA%93%E3%80%81%E5%88%86%E7%89%87%E5%85%A5%E9%97%A8/"/>
    <id>https://icocos.github.io/2018/12/23/分区、分表、分库、分片入门/</id>
    <published>2018-12-23T10:47:41.000Z</published>
    <updated>2019-05-22T09:06:54.678Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、分区的概念"><a href="#一、分区的概念" class="headerlink" title="一、分区的概念"></a>一、分区的概念</h3><p>数据分区是一种物理数据库的设计技术，它的目的是为了在特定的SQL操作中减少数据读写的总量以缩减响应时间。</p><p>分区并不是生成新的数据表，而是将表的数据均衡分摊到不同的硬盘，系统或是不同服务器存储介子中，实际上还是一张表。另外，分区可以做到将表的数据均衡到不同的地方，提高数据检索的效率，降低数据库的频繁IO压力值，分区的优点如下：</p><a id="more"></a><ul><li>1、相对于单个文件系统或是硬盘，分区可以存储更多的数据；</li><li>2、数据管理比较方便，比如要清理或废弃某年的数据，就可以直接删除该日期的分区数据即可；</li><li>3、精准定位分区查询数据，不需要全表扫描查询，大大提高数据检索效率；</li><li>4、可跨多个分区磁盘查询，来提高查询的吞吐量；</li><li>5、在涉及聚合函数查询时，可以很容易进行数据的合并；</li></ul><h3 id="二、分类-（row-行-，column-列）"><a href="#二、分类-（row-行-，column-列）" class="headerlink" title="二、分类 （row 行 ，column 列）"></a>二、分类 （row 行 ，column 列）</h3><ul><li>1、水平分区</li></ul><p>这种形式分区是对表的行进行分区，通过这样的方式不同分组里面的物理列分割的数据集得以组合，从而进行个体分割（单分区）或集体分割（1个或多个分区）。所有在表中定义的列在每个数据集中都能找到，所以表的特性依然得以保持。</p><blockquote><p>举个简单例子：一个包含十年发票记录的表可以被分区为十个不同的分区，每个分区包含的是其中一年的记录。（朋奕注：这里具体使用的分区方式我们后面再说，可以先说一点，一定要通过某个属性列来分割，譬如这里使用的列就是年份）</p></blockquote><ul><li>2、垂直分区</li></ul><p>这种分区方式一般来说是通过对表的垂直划分来减少目标表的宽度，使某些特定的列被划分到特定的分区，每个分区都包含了其中的列所对应的行。</p><blockquote><p>举个简单例子：一个包含了大text和BLOB列的表，这些text和BLOB列又不经常被访问，这时候就要把这些不经常使用的text和BLOB了划分到另一个分区，在保证它们数据相关性的同时还能提高访问速度。</p></blockquote><p>在数据库供应商开始在他们的数据库引擎中建立分区（主要是水平分区）时，DBA和建模者必须设计好表的物理分区结构，不要保存冗余的数据（不同表中同时都包含父表中的数据）或相互联结成一个逻辑父对象（通常是视图）。这种做法会使水平分区的大部分功能失效，有时候也会对垂直分区产生影响。</p><h3 id="三、分片、分区、分表、分库的详细理解"><a href="#三、分片、分区、分表、分库的详细理解" class="headerlink" title="三、分片、分区、分表、分库的详细理解"></a>三、分片、分区、分表、分库的详细理解</h3><h5 id="一、什么是分片、分区、分表、分库"><a href="#一、什么是分片、分区、分表、分库" class="headerlink" title="一、什么是分片、分区、分表、分库"></a>一、什么是分片、分区、分表、分库</h5><ul><li>分片</li></ul><p>当数据库数据达到上亿级别时，数据库压力会很大，存不下，可以考虑使用数据库分片。</p><ul><li>分区</li></ul><p>就是把一张表的数据分成N个区块，在逻辑上看最终只是一张表，但底层是由N个物理区块组成的</p><ul><li>分表</li></ul><p>就是把一张表按一定的规则分解成N个具有独立存储空间的实体表。系统读写时需要根据定义好的规则得到对应的字表明，然后操作它。</p><ul><li>分库</li></ul><p>一旦分表，一个库中的表会越来越多</p><blockquote><p>将整个数据库比作图书馆，一张表就是一本书。当要在一本书中查找某项内容时，如果不分章节，查找的效率将会下降。而同理，在数据库中就是分区。</p></blockquote><h5 id="常用的单机数据库的瓶颈"><a href="#常用的单机数据库的瓶颈" class="headerlink" title="常用的单机数据库的瓶颈"></a>常用的单机数据库的瓶颈</h5><ul><li>问题描述<ul><li>单个表数据量越大，读写锁，插入操作重新建立索引效率越低。</li><li>单个库数据量太大（一个数据库数据量到1T-2T就是极限）</li><li>单个数据库服务器压力过大</li><li>读写速度遇到瓶颈（并发量几百）</li></ul></li></ul><h3 id="二、分片"><a href="#二、分片" class="headerlink" title="二、分片"></a>二、分片</h3><p>不同的表放到不同的 数据库中—垂直切割。</p><pre><code>数据量小，查询性能会提高。 不同数据库位于不同服务器上时，会减小服务器压力。</code></pre><p>单张表数据量也很大，如用户量大产生操作量也会很大。单独查询时，压力也会很大。此时垂直分割也无济于事。可以考虑–水平分割。</p><pre><code>一张表放到不同数据库中。用户表，放到不同数据库，每个数据库存储部分数据，单表数据量不大。</code></pre><h3 id="三、分区"><a href="#三、分区" class="headerlink" title="三、分区"></a>三、分区</h3><h5 id="什么时候考虑使用分区？"><a href="#什么时候考虑使用分区？" class="headerlink" title="什么时候考虑使用分区？"></a>什么时候考虑使用分区？</h5><ul><li>一张表的查询速度已经慢到影响使用的时候。</li><li>sql经过优化</li><li>数据量大</li><li>表中的数据是分段的</li><li>对数据的操作往往只涉及一部分数据，而不是所有的数据</li></ul><h5 id="分区解决的问题"><a href="#分区解决的问题" class="headerlink" title="分区解决的问题"></a>分区解决的问题</h5><p>​    </p><p>​    主要可以提升查询效率</p><h5 id="分区的实现方式（简单）"><a href="#分区的实现方式（简单）" class="headerlink" title="分区的实现方式（简单）"></a>分区的实现方式（简单）</h5><p>mysql5 开始支持分区功能</p><pre><code>CREATE TABLE sales (id INT AUTO_INCREMENT,amount DOUBLE NOT NULL,order_day DATETIME NOT NULL,PRIMARY KEY(id, order_day)) ENGINE=Innodb PARTITION BY RANGE(YEAR(order_day)) (PARTITION p_2010 VALUES LESS THAN (2010),PARTITION p_2011 VALUES LESS THAN (2011),PARTITION p_2012 VALUES LESS THAN (2012),PARTITION p_catchall VALUES LESS THAN MAXVALUE);</code></pre><blockquote><p> MySQL5.1提供的分区(Partition)功能确实可以实现表的分区，但是这种分区是局限在单个数据库范围里的，它不能跨越服务器的限制。</p></blockquote><p>如果能够保证数据量很难超过现有数据库服务器的物理承载量，那么只需利用MySQL5.1提供的分区(Partition)功能来改善数据库性能即可；否则，还是考虑应用Sharding理念吧，spider  storage engine就是一个不错的选择。</p><h5 id="Sharding与数据库分区-Partition-的区别"><a href="#Sharding与数据库分区-Partition-的区别" class="headerlink" title="Sharding与数据库分区(Partition)的区别　　"></a>Sharding与数据库分区(Partition)的区别　　</h5><blockquote><p> 有的时候，Sharding 也被近似等同于水平分区(Horizontal Partitioning)，网上很多地方也用水平分区来指代  Sharding，但我个人认为二者之间实际上还是有区别的。的确，Sharding  的思想是从分区的思想而来，但数据库分区基本上是数据对象级别的处理，比如表和索引的分区，每个子数据集上能够有不同的物理存储属性，还是单个数据库范围内的操作，而 Sharding 是能够跨数据库，甚至跨越物理机器的。</p></blockquote><h3 id="四、分表"><a href="#四、分表" class="headerlink" title="四、分表"></a>四、分表</h3><h5 id="什么时候考虑分表？"><a href="#什么时候考虑分表？" class="headerlink" title="什么时候考虑分表？"></a>什么时候考虑分表？</h5><ul><li>一张表的查询速度已经慢到影响使用的时候。</li><li>sql经过优化</li><li>数据量大</li><li>当频繁插入或者联合查询时，速度变慢</li></ul><h5 id="分表解决的问题"><a href="#分表解决的问题" class="headerlink" title="分表解决的问题"></a>分表解决的问题</h5><p>分表后，单表的并发能力提高了，磁盘I/O性能也提高了，写操作效率提高了</p><ul><li>查询一次的时间短了</li><li>数据分布在不同的文件，磁盘I/O性能提高</li><li>读写锁影响的数据量变小</li><li>插入数据库需要重新建立索引的数据减少</li></ul><h5 id="分表的实现方式（复杂）"><a href="#分表的实现方式（复杂）" class="headerlink" title="分表的实现方式（复杂）"></a>分表的实现方式（复杂）</h5><p>​    需要业务系统配合迁移升级，工作量较大</p><p>#####分区和分表的区别与联系</p><ul><li>分区和分表的目的都是减少数据库的负担，提高表的增删改查效率。</li><li>分区只是一张表中的数据的存储位置发生改变，分表是将一张表分成多张表。</li><li>当访问量大，且表数据比较大时，两种方式可以互相配合使用。</li><li>当访问量不大，但表数据比较多时，可以只进行分区。</li></ul><h5 id="常见分区分表的规则策略（类似）"><a href="#常见分区分表的规则策略（类似）" class="headerlink" title="常见分区分表的规则策略（类似）"></a>常见分区分表的规则策略（类似）</h5><ul><li>Range（范围）</li><li>Hash（哈希）</li><li>List（链表）</li><li>按照时间拆分</li><li>Hash之后按照分表个数取模</li><li>在认证库中保存数据库配置，就是建立一个DB，这个DB单独保存user_id到DB的映射关系</li></ul><h3 id="五、分库"><a href="#五、分库" class="headerlink" title="五、分库"></a>五、分库</h3><h5 id="什么时候考虑使用分库？"><a href="#什么时候考虑使用分库？" class="headerlink" title="什么时候考虑使用分库？"></a>什么时候考虑使用分库？</h5><ul><li>单台DB的存储空间不够</li><li>随着查询量的增加单台数据库服务器已经没办法支撑</li></ul><h5 id="分库解决的问题"><a href="#分库解决的问题" class="headerlink" title="分库解决的问题"></a>分库解决的问题</h5><p>​    其主要目的是为突破单节点数据库服务器的 I/O 能力限制，解决数据库扩展性问题。 </p><h5 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h5><p>将系统中不存在关联关系或者需要join的表可以放在不同的数据库不同的服务器中。</p><blockquote><p>按照业务垂直划分。比如：可以按照业务分为资金、会员、订单三个数据库。</p></blockquote><p>需要解决的问题：跨数据库的事务、jion查询等问题。</p><h5 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h5><p>例如，大部分的站点。数据都是和用户有关，那么可以根据用户，将数据按照用户水平拆分。</p><blockquote><p>按照规则划分，一般水平分库是在垂直分库之后的。比如每天处理的订单数量是海量的，可以按照一定的规则水平划分。需要解决的问题：数据路由、组装。</p></blockquote><h5 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h5><p>对于时效性不高的数据，可以通过读写分离缓解数据库压力。需要解决的问题：在业务上区分哪些业务上是允许一定时间延迟的，以及数据同步问题。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><blockquote><p>垂直分库–&gt;水平分库–&gt;读写分离</p></blockquote><h3 id="六、拆分之后面临新的问题"><a href="#六、拆分之后面临新的问题" class="headerlink" title="六、拆分之后面临新的问题"></a>六、拆分之后面临新的问题</h3><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ul><li>事务的支持，分库分表，就变成了分布式事务</li><li>join时跨库，跨表的问题</li><li>分库分表，读写分离使用了分布式，分布式为了保证强一致性，必然带来延迟，导致性能降低，系统的复杂度变高。</li></ul><h5 id="常用的解决方案："><a href="#常用的解决方案：" class="headerlink" title="常用的解决方案："></a>常用的解决方案：</h5><p>对于不同的方式之间没有严格的界限，特点不同，侧重点不同。需要根据实际情况，结合每种方式的特点来进行处理。</p><p>选用第三方的数据库中间件（Atlas，Mycat，TDDL，DRDS），同时业务系统需要配合数据存储的升级。</p><h3 id="七、数据存储的演进"><a href="#七、数据存储的演进" class="headerlink" title="七、数据存储的演进"></a>七、数据存储的演进</h3><h5 id="单库单表"><a href="#单库单表" class="headerlink" title="单库单表"></a>单库单表</h5><p>单库单表是最常见的数据库设计，例如，有一张用户(user)表放在数据库db中，所有的用户都可以在db库中的user表中查到。</p><h5 id="单库多表"><a href="#单库多表" class="headerlink" title="单库多表"></a>单库多表</h5><p>随着用户数量的增加，user表的数据量会越来越大，当数据量达到一定程度的时候对user表的查询会渐渐的变慢，从而影响整个DB的性能。如果使用mysql, 还有一个更严重的问题是，当需要添加一列的时候，mysql会锁表，期间所有的读写操作只能等待。</p><blockquote><p> 可以通过某种方式将user进行水平的切分，产生两个表结构完全一样的user_0000,user_0001等表，user_0000 + user_0001 + …的数据刚好是一份完整的数据。</p></blockquote><h5 id="多库多表"><a href="#多库多表" class="headerlink" title="多库多表"></a>多库多表</h5><p>随着数据量增加也许单台DB的存储空间不够，随着查询量的增加单台数据库服务器已经没办法支撑。这个时候可以再对数据库进行水平拆分。</p><h3 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h3><p>总的来说，优先考虑分区。当分区不能满足需求时，开始考虑分表，合理的分表对效率的提升会优于分区。</p><h5 id="基础数据存储"><a href="#基础数据存储" class="headerlink" title="基础数据存储"></a>基础数据存储</h5><p>Mysql：只存储非文本的基础信息。包括：评论状态，用户，时间等基础数据。以及图片，标签，点赞等附加信息。数据组织形式（不同的数据又可选择不同的库表拆分方案）：</p><ul><li>评论基础数据按用户ID进行拆库并拆表</li><li>图片及标签处于同一数据库下，根据商品编号分别进行拆表</li><li>其它的扩展信息数据，因数据量不大、访问量不高，处理于同一库下且不做分表即可</li></ul><h5 id="文本存储"><a href="#文本存储" class="headerlink" title="文本存储"></a>文本存储</h5><p>文本存储（评论的内容）使用了mongodb、hbase</p><ul><li>选择nosql而非mysql</li><li>减轻了mysql存储压力，释放msyql，庞大的存储也有了可靠的保障</li><li>nosql的高性能读写大大提升了系统的吞吐量并降低了延迟</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、分区的概念&quot;&gt;&lt;a href=&quot;#一、分区的概念&quot; class=&quot;headerlink&quot; title=&quot;一、分区的概念&quot;&gt;&lt;/a&gt;一、分区的概念&lt;/h3&gt;&lt;p&gt;数据分区是一种物理数据库的设计技术，它的目的是为了在特定的SQL操作中减少数据读写的总量以缩减响应时间。&lt;/p&gt;
&lt;p&gt;分区并不是生成新的数据表，而是将表的数据均衡分摊到不同的硬盘，系统或是不同服务器存储介子中，实际上还是一张表。另外，分区可以做到将表的数据均衡到不同的地方，提高数据检索的效率，降低数据库的频繁IO压力值，分区的优点如下：&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="https://icocos.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://icocos.github.io/tags/MySQL/"/>
    
      <category term="拓展" scheme="https://icocos.github.io/tags/%E6%8B%93%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>JWT（JSON Web Token]）入门简介</title>
    <link href="https://icocos.github.io/2018/12/16/JWT%EF%BC%88JSON-Web-Token-%EF%BC%89%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B/"/>
    <id>https://icocos.github.io/2018/12/16/JWT（JSON-Web-Token-）入门简介/</id>
    <published>2018-12-16T10:17:21.000Z</published>
    <updated>2019-05-20T11:45:07.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Jwt"><a href="#Jwt" class="headerlink" title="Jwt"></a>Jwt</h1><p><code>JWT</code>是（JSON Web Token]）的缩写，主要用来做用户身份验证的。</p><p>随着当前分布式应用、前后端分离的技术广泛使用，早年通过session管理用户状态的成本越来越高，session共享问题以及之后出现的token认证基本都是通过如Redis之类的中间件实现的。</p><blockquote><p>JWT通过将数据保存在客户端，每次请求时将token发送至服务端校验，服务端无需存储token，实现完全无状态化。</p></blockquote><a id="more"></a><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul><li>客户端登录请求认证</li><li>服务端认证通过后，生成包含数据的<code>JSON</code>对象，并将此对象进行签名生成<code>token</code></li><li>服务端将<code>token</code>返回客户端，客户端存储在本地，如cookie或localStorage</li><li>客户端下次请求时携带<code>token</code>到服务端，常用的是放在 HTTP 请求的头的Authorization字段中，<code>Authorization: Bearer &lt;token&gt;</code></li><li>服务端验证<code>token</code>有效性</li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><code>Token</code>是一个使用<code>.</code>分割的三部分组成的长字符串，<code>Header.Payload.Signature</code></p><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header是一个Base64URL之后的json对象，<code>{&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;}</code>，<code>alg</code>表示签名的算法（algorithm），默认是 <code>HMAC SHA256</code>（HS256），<code>typ</code>表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。</p><h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><p>Payload 也是一个Base64URL之后的JSON对象，用来存放传递的数据。JWT 规定了7个官方字段可用：</p><ul><li>iss (issuer)：签发人</li><li>iat (Issued At)：签发时间</li><li>exp (expiration time)：过期时间</li><li>nbf (Not Before)：生效时间</li><li>jti (JWT ID)：编号</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li></ul><p>除了官方字段，还可以在这个部分定义私有字段，比如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sub"</span>: <span class="string">"101"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"ruesin"</span>,</span><br><span class="line">  <span class="attr">"LoginToken"</span>:<span class="string">"abcd123"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为默认是Base64URL编码不加密的，所以客户端是可以解码读取这些数据，不要把秘密信息放在这个部分。</p><h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><blockquote><p>Signature 是对前两部分的签名，校验tonken的有效性，防止数据篡改。</p></blockquote><p>签名是通过服务端指定的密钥（secret）及Header中指定的签名算法产生的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Jwt&quot;&gt;&lt;a href=&quot;#Jwt&quot; class=&quot;headerlink&quot; title=&quot;Jwt&quot;&gt;&lt;/a&gt;Jwt&lt;/h1&gt;&lt;p&gt;&lt;code&gt;JWT&lt;/code&gt;是（JSON Web Token]）的缩写，主要用来做用户身份验证的。&lt;/p&gt;
&lt;p&gt;随着当前分布式应用、前后端分离的技术广泛使用，早年通过session管理用户状态的成本越来越高，session共享问题以及之后出现的token认证基本都是通过如Redis之类的中间件实现的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JWT通过将数据保存在客户端，每次请求时将token发送至服务端校验，服务端无需存储token，实现完全无状态化。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="JWT" scheme="https://icocos.github.io/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>Nginx配置文件(nginx.conf)详解</title>
    <link href="https://icocos.github.io/2018/11/16/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-nginx-conf-%E8%AF%A6%E8%A7%A3/"/>
    <id>https://icocos.github.io/2018/11/16/Nginx配置文件-nginx-conf-详解/</id>
    <published>2018-11-16T10:36:59.000Z</published>
    <updated>2019-05-21T10:20:03.158Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx 总的 配置文件 位置 /usr/local/nginx/conf/nginx.conf<br>nginx 正则匹配</p><h3 id="一．正则表达式匹配，其中："><a href="#一．正则表达式匹配，其中：" class="headerlink" title="一．正则表达式匹配，其中："></a>一．正则表达式匹配，其中：</h3><ol><li>~ 为区分大小写匹配</li><li>~* 为不区分大小写匹配</li><li>!~和!~*分别为区分大小写不匹配及不区分大小写不匹配</li></ol><a id="more"></a><h3 id="二．文件及目录匹配，其中："><a href="#二．文件及目录匹配，其中：" class="headerlink" title="二．文件及目录匹配，其中："></a>二．文件及目录匹配，其中：</h3><ol><li>-f和!-f用来判断是否存在文件</li><li>-d和!-d用来判断是否存在目录</li><li>-e和!-e用来判断是否存在文件或目录</li><li>-x和!-x用来判断文件是否可执行</li></ol><h3 id="三．rewrite指令的最后一项参数为flag标记，flag标记有："><a href="#三．rewrite指令的最后一项参数为flag标记，flag标记有：" class="headerlink" title="三．rewrite指令的最后一项参数为flag标记，flag标记有："></a>三．rewrite指令的最后一项参数为flag标记，flag标记有：</h3><ol><li>last    相当于apache里面的[L]标记，表示rewrite。</li><li>break本条规则匹配完成后，终止匹配，不再匹配后面的规则。</li><li>redirect  返回302临时重定向，浏览器地址会显示跳转后的URL地址。</li><li>permanent  返回301永久重定向，浏览器地址会显示跳转后的URL地址。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用last和break实现URI重写，浏览器地址栏不变。</span><br><span class="line">使用alias指令必须用last标记;</span><br><span class="line">使用proxy_pass指令时，需要使用break标记。</span><br><span class="line">Last标记在本条rewrite规则执行完毕后，会对其所在server&#123;......&#125;标签重新发起请求</span><br><span class="line">break标记则在本条规则匹配完成后，终止匹配。</span><br></pre></td></tr></table></figure><h3 id="四．NginxRewrite-规则相关指令"><a href="#四．NginxRewrite-规则相关指令" class="headerlink" title="四．NginxRewrite 规则相关指令"></a>四．NginxRewrite 规则相关指令</h3><h5 id="1-break指令"><a href="#1-break指令" class="headerlink" title="1. break指令"></a>1. break指令</h5><ul><li>使用环境：server,location,if;</li><li>该指令的作用是完成当前的规则集，不再处理rewrite指令。</li></ul><h5 id="2-if指令"><a href="#2-if指令" class="headerlink" title="2.if指令"></a>2.if指令</h5><ul><li>使用环境：server,location</li><li>该指令用于检查一个条件是否符合，如果条件符合，则执行大括号内的语句。If指令不支持嵌套，不支持多个条件&amp;&amp;和||处理。</li></ul><h5 id="3-return指令"><a href="#3-return指令" class="headerlink" title="3.return指令"></a>3.return指令</h5><ul><li>语法：return code ;</li><li>使用环境：server,location,if;</li></ul><p>该指令用于结束规则的执行并返回状态码给客户端。<br>示例：如果访问的URL以”.sh”或”.bash”结尾，则返回403状态码</p><pre><code>location ~ .*\.(sh|bash)?${　　　　return 403;}</code></pre><h5 id="4-rewrite-指令"><a href="#4-rewrite-指令" class="headerlink" title="4.rewrite 指令"></a>4.rewrite 指令</h5><ul><li>语法：rewriteregex replacement flag</li><li>使用环境：server,location,if</li></ul><p>该指令根据表达式来重定向URI，或者修改字符串。指令根据配置文件中的顺序来执行。注意重写表达式只对相对路径有效。如果你想配对主机名，你应该使用if语句，示例如下：</p><pre><code>if ( $host ~* www\.(.*) ){　　　　set  $host_without_www $1;　　　　rewrite  ^(.*)$   http://$host_without_www$1 permanent;}</code></pre><h5 id="5-Set指令"><a href="#5-Set指令" class="headerlink" title="5.Set指令"></a>5.Set指令</h5><ul><li>语法：setvariable value ; 默认值:none; 使用环境：server,location,if;</li><li>该指令用于定义一个变量，并给变量赋值。变量的值可以为文本、变量以及文本变量的联合。<br>　<br>示例：set $varname “hello world”;</li></ul><h5 id="6-Uninitialized-variable-warn指令"><a href="#6-Uninitialized-variable-warn指令" class="headerlink" title="6.Uninitialized_variable_warn指令"></a>6.Uninitialized_variable_warn指令</h5><ul><li>语法：uninitialized_variable_warnon|off</li><li>使用环境：http,server,location,if</li></ul><p>该指令用于开启和关闭未初始化变量的警告信息，默认值为开启。</p><h3 id="五．Nginx的Rewrite规则编写实例"><a href="#五．Nginx的Rewrite规则编写实例" class="headerlink" title="五．Nginx的Rewrite规则编写实例"></a>五．Nginx的Rewrite规则编写实例</h3><h5 id="1-当访问的文件和目录不存在时，重定向到某个php文件"><a href="#1-当访问的文件和目录不存在时，重定向到某个php文件" class="headerlink" title="1.当访问的文件和目录不存在时，重定向到某个php文件"></a>1.当访问的文件和目录不存在时，重定向到某个php文件</h5><pre><code>if ( !-e $request_filename ){    Rewrite ^/(.*)$ index.php last;}</code></pre><h5 id="2-目录对换-123456-xxxx-gt-xxxx-id-123456"><a href="#2-目录对换-123456-xxxx-gt-xxxx-id-123456" class="headerlink" title="2.目录对换 /123456/xxxx  ====&gt;  /xxxx?id=123456"></a>2.目录对换 /123456/xxxx  ====&gt;  /xxxx?id=123456</h5><pre><code>rewrite ^/(\d+)/(.+)/  /$2?id=$1 last;</code></pre><h5 id="3-如果客户端使用的是IE浏览器，则重定向到-ie目录下"><a href="#3-如果客户端使用的是IE浏览器，则重定向到-ie目录下" class="headerlink" title="3.如果客户端使用的是IE浏览器，则重定向到/ie目录下"></a>3.如果客户端使用的是IE浏览器，则重定向到/ie目录下</h5><pre><code>if( $http_user_agent  ~ MSIE){</code></pre><p>Rewrite ^(.*)$ /ie/$1 break;<br>    }</p><h5 id="4-禁止访问多个目录"><a href="#4-禁止访问多个目录" class="headerlink" title="4.禁止访问多个目录"></a>4.禁止访问多个目录</h5><pre><code>location ~ ^/(cron|templates)/{    deny all;    break;}</code></pre><h5 id="5-禁止访问以-data开头的文件"><a href="#5-禁止访问以-data开头的文件" class="headerlink" title="5.禁止访问以/data开头的文件"></a>5.禁止访问以/data开头的文件</h5><pre><code>location ~ ^/data{    deny all;}</code></pre><h5 id="6-禁止访问以-sh-flv-mp3为文件后缀名的文件"><a href="#6-禁止访问以-sh-flv-mp3为文件后缀名的文件" class="headerlink" title="6.禁止访问以.sh,.flv,.mp3为文件后缀名的文件"></a>6.禁止访问以.sh,.flv,.mp3为文件后缀名的文件</h5><pre><code>location ~ .*\.(sh|flv|mp3)${    return 403;}</code></pre><h5 id="7-设置某些类型文件的浏览器缓存时间"><a href="#7-设置某些类型文件的浏览器缓存时间" class="headerlink" title="7.设置某些类型文件的浏览器缓存时间"></a>7.设置某些类型文件的浏览器缓存时间</h5><pre><code>location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)${    expires 30d;}location ~ .*\.(js|css)${    expires 1h;}</code></pre><h5 id="8-给favicon-ico和robots-txt设置过期时间"><a href="#8-给favicon-ico和robots-txt设置过期时间" class="headerlink" title="8.给favicon.ico和robots.txt设置过期时间;"></a>8.给favicon.ico和robots.txt设置过期时间;</h5><p>这里为favicon.ico为99天,robots.txt为7天并不记录404错误日志</p><pre><code>location ~(favicon.ico){    log_not_found off;    expires 99d;    break;}location ~(robots.txt) {    log_not_found off;    expires 7d;    break;}</code></pre><h5 id="9-设定某个文件的过期时间-这里为600秒，并不记录访问日志"><a href="#9-设定某个文件的过期时间-这里为600秒，并不记录访问日志" class="headerlink" title="9.设定某个文件的过期时间;这里为600秒，并不记录访问日志"></a>9.设定某个文件的过期时间;这里为600秒，并不记录访问日志</h5><pre><code>location ^~ /html/scripts/loadhead_1.js {    access_log  off;    root /opt/lampp/htdocs/web;    expires 600;    break;}</code></pre><h5 id="10-文件反盗链并设置过期时间"><a href="#10-文件反盗链并设置过期时间" class="headerlink" title="10.文件反盗链并设置过期时间"></a>10.文件反盗链并设置过期时间</h5><p>　<br>这里的return412 为自定义的http状态码，默认为403，方便找出正确的盗链的请求</p><pre><code>“rewrite ^/ http://img.linuxidc.net/leech.gif;” 显示一张防盗链图片“access_log off;” 不记录访问日志，减轻压力“expires 3d”  所有文件3天的浏览器缓存location ~*^.+\.(jpg|jpeg|gif|png|swf|rar|zip|css|js)$ {    valid_referers none blocked *.linuxidc.com*.linuxidc.net localhost 208.97.167.194;    if ($invalid_referer)     {　　　　　　rewrite ^/ http://img.linuxidc.net/leech.gif;　　　　　　return 412;　　　　　　break;    }    access_log  off;    root /opt/lampp/htdocs/web;    expires 3d;    break;}</code></pre><h5 id="11-只允许固定ip访问网站，并加上密码"><a href="#11-只允许固定ip访问网站，并加上密码" class="headerlink" title="11.只允许固定ip访问网站，并加上密码"></a>11.只允许固定ip访问网站，并加上密码</h5><pre><code>root /opt/htdocs/www;allow  208.97.167.194; allow  222.33.1.2; allow  231.152.49.4;deny  all;auth_basic “C1G_ADMIN”;auth_basic_user_file htpasswd;</code></pre><h5 id="12将多级目录下的文件转成一个文件，增强seo效果"><a href="#12将多级目录下的文件转成一个文件，增强seo效果" class="headerlink" title="12将多级目录下的文件转成一个文件，增强seo效果"></a>12将多级目录下的文件转成一个文件，增强seo效果</h5><pre><code>/job-123-456-789.html 指向/job/123/456/789.htmlrewrite ^/job-([0-9]+)-([0-9]+)-([0-9]+)\.html$ /job/$1/$2/jobshow_$3.html last;</code></pre><h5 id="13-文件和目录不存在的时候重定向："><a href="#13-文件和目录不存在的时候重定向：" class="headerlink" title="13.文件和目录不存在的时候重定向："></a>13.文件和目录不存在的时候重定向：</h5><pre><code>if (!-e $request_filename){    proxy_pass http://127.0.0.1;}</code></pre><h5 id="14-将根目录下某个文件夹指向2级目录"><a href="#14-将根目录下某个文件夹指向2级目录" class="headerlink" title="14.将根目录下某个文件夹指向2级目录"></a>14.将根目录下某个文件夹指向2级目录</h5><p>如/shanghaijob/ 指向 /area/shanghai/<br>如果你将last改成permanent，那么浏览器地址栏显是/location/shanghai/</p><pre><code>　　rewrite ^/([0-9a-z]+)job/(.*)$ /area/$1/$2last;</code></pre><p>面例子有个问题是访问/shanghai时将不会匹配</p><pre><code>　　rewrite ^/([0-9a-z]+)job$ /area/$1/ last;</code></pre><p>Rewrite ^/([0-9a-z]+)job/(.*)$ /area/$1/$2last;</p><p>这样/shanghai 也可以访问了，但页面中的相对链接无法使用，</p><blockquote><p>如./list_1.html真实地址是/area/shanghia/list_1.html会变成/list_1.html,导至无法访问。<br>那我加上自动跳转也是不行咯</p></blockquote><pre><code>(-d $request_filename)它有个条件是必需为真实目录，而我的rewrite不是的，所以没有效果if (-d $request_filename){rewrite ^/(.*)([^/])$ http://$host/$1$2/permanent;}</code></pre><p>知道原因后就好办了，让我手动跳转吧</p><pre><code>rewrite ^/([0-9a-z]+)job$ /$1job/permanent;rewrite ^/([0-9a-z]+)job/(.*)$ /area/$1/$2last;</code></pre><h5 id="15-域名跳转"><a href="#15-域名跳转" class="headerlink" title="15.域名跳转"></a>15.域名跳转</h5><pre><code>server{    listen      80;    server_name  jump.linuxidc.com;    index index.html index.htm index.php;    root  /opt/lampp/htdocs/www;    rewrite ^/ http://www.linuxidc.com/;    access_log  off;}</code></pre><h5 id="16-多域名转向"><a href="#16-多域名转向" class="headerlink" title="16.多域名转向"></a>16.多域名转向</h5><pre><code>server_name  www.linuxidc.com www.linuxidc.net;index index.html index.htm index.php;root  /opt/lampp/htdocs;if ($host ~ &quot;linuxidc\.net&quot;) {    rewrite ^(.*) http://www.linuxidc.com$1permanent;}</code></pre><h3 id="六．nginx全局变量"><a href="#六．nginx全局变量" class="headerlink" title="六．nginx全局变量"></a>六．nginx全局变量</h3><pre><code>​arg_PARAMETER    #这个变量包含GET请求中，如果有变量PARAMETER时的值。args                    #这个变量等于请求行中(GET请求)的参数，如：foo=123&amp;bar=blahblah;binary_remote_addr #二进制的客户地址。body_bytes_sent    #响应时送出的body字节数数量。即使连接中断，这个数据也是精确的。content_length    #请求头中的Content-length字段。content_type      #请求头中的Content-Type字段。cookie_COOKIE    #cookie COOKIE变量的值document_root    #当前请求在root指令中指定的值。document_uri      #与uri相同。host                #请求主机头字段，否则为服务器名称。hostname          #Set to themachine’s hostname as returned by gethostnamehttp_HEADERis_args              #如果有args参数，这个变量等于”?”，否则等于”&quot;，空值。http_user_agent    #客户端agent信息http_cookie          #客户端cookie信息limit_rate            #这个变量可以限制连接速率。query_string          #与args相同。request_body_file  #客户端请求主体信息的临时文件名。request_method    #客户端请求的动作，通常为GET或POST。remote_addr          #客户端的IP地址。remote_port          #客户端的端口。remote_user          #已经经过Auth Basic Module验证的用户名。request_completion #如果请求结束，设置为OK. 当请求未结束或如果该请求不是请求链串的最后一个时，为空(Empty)。request_method    #GET或POSTrequest_filename  #当前请求的文件路径，由root或alias指令与URI请求生成。request_uri          #包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。不能修改。scheme                #HTTP方法（如http，https）。server_protocol      #请求使用的协议，通常是HTTP/1.0或HTTP/1.1。server_addr          #服务器地址，在完成一次系统调用后可以确定这个值。server_name        #服务器名称。server_port          #请求到达服务器的端口号。</code></pre><h3 id="七．Apache和Nginx规则的对应关系"><a href="#七．Apache和Nginx规则的对应关系" class="headerlink" title="七．Apache和Nginx规则的对应关系"></a>七．Apache和Nginx规则的对应关系</h3><pre><code>Apache的RewriteCond对应Nginx的ifApache的RewriteRule对应Nginx的rewriteApache的[R]对应Nginx的redirectApache的[P]对应Nginx的lastApache的[R,L]对应Nginx的redirectApache的[P,L]对应Nginx的lastApache的[PT,L]对应Nginx的last</code></pre><p>例如：允许指定的域名访问本站，其他的域名一律转向<a href="http://www.linuxidc.net" target="_blank" rel="noopener">www.linuxidc.net</a></p><h5 id="Apache"><a href="#Apache" class="headerlink" title="Apache:"></a>Apache:</h5><pre><code>RewriteCond %{HTTP_HOST} !^(.*?)\.aaa\.com$[NC]RewriteCond %{HTTP_HOST} !^localhost$ RewriteCond %{HTTP_HOST}!^192\.168\.0\.(.*?)$RewriteRule ^/(.*)$ http://www.linuxidc.net[R,L]</code></pre><h5 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx:"></a>Nginx:</h5><pre><code>if( $host ~* ^(.*)\.aaa\.com$ ){    set $allowHost &apos;1&apos;;}if( $host ~* ^localhost ){    set $allowHost &apos;1&apos;;}if( $host ~* ^192\.168\.1\.(.*?)$ ){    set $allowHost &apos;1&apos;;}if( $allowHost !~ &apos;1&apos; ){    Rewrite ^/(.*)$ http://www.linuxidc.netredirect ;} </code></pre><h5 id="nginx-conf-配置文件"><a href="#nginx-conf-配置文件" class="headerlink" title="nginx conf 配置文件"></a>nginx conf 配置文件</h5><pre><code>nginx进程数，建议设置为等于CPU总核心数.worker_processes 8;全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]error_log /var/log/nginx/error.log info;进程文件pid /var/run/nginx.pid;一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。worker_rlimit_nofile 65535;工作模式与连接数上限events{        #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ];  epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。    　　use epoll;    　　#单个进程最大连接数（最大连接数=连接数*进程数）    　　worker_connections 65535;}设定http服务器http{​    include mime.types; #文件扩展名与文件类型映射表    default_type application/octet-stream; #默认文件类型    #charset utf-8; #默认编码    server_names_hash_bucket_size 128; #服务器名字的hash表大小    client_header_buffer_size 32k; #上传文件大小限制    large_client_header_buffers 4 64k; #设定请求缓    client_max_body_size 8m; #设定请求缓     sendfile on; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为  on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。    autoindex on; #开启目录列表访问，合适下载服务器，默认关闭。    tcp_nopush on; #防止网络阻塞    tcp_nodelay on; #防止网络阻塞    keepalive_timeout 120; #长连接超时时间，单位是秒​    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。    fastcgi_connect_timeout 300;    fastcgi_send_timeout 300;    fastcgi_read_timeout 300;    fastcgi_buffer_size 64k;    fastcgi_buffers 4 64k;    fastcgi_busy_buffers_size 128k;    fastcgi_temp_file_write_size 128k;​    #gzip模块设置    gzip on; #开启gzip压缩输出    gzip_min_length 1k; #最小压缩文件大小    gzip_buffers 4 16k; #压缩缓冲区    gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）    gzip_comp_level 2; #压缩等级    gzip_types text/plain application/x-javascript text/css application/xml;    #压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。    gzip_vary on;    #limit_zone crawler $binary_remote_addr 10m; #开启限制IP连接数的时候需要使用​    upstream blog.ha97.com {        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。        server 192.168.80.121:80 weight=3;        server 192.168.80.122:80 weight=2;        server 192.168.80.123:80 weight=3;    }    虚拟主机的配置    server    {    ​    listen 80;　　　　#监听端口    　　　　server_name aa.cn www.aa.cn ; #server_name end  #域名可以有多个，用空格隔开    ​    index index.html index.htm index.php;  # 设置访问主页    　　　　set $subdomain &apos;&apos;;  # 绑定目录为二级域名 bbb.aa.com  根目录 /bbb  文件夹         　　　　if ( $host ~* &quot;(?:(\w+\.){0,})(\b(?!www\b)\w+)\.\b(?!(com|org|gov|net|cn)\b)\w+\.[a-zA-Z]+&quot; ) { set $subdomain &quot;/$2&quot;; }    root /home/wwwroot/aa.cn/web$subdomain;# 访问域名跟目录      include rewrite/dedecms.conf; #rewrite end   #载入其他配置文件    ​    location ~ .*.(php|php5)?$        {            　　fastcgi_pass 127.0.0.1:9000;            　　fastcgi_index index.php;            　　include fastcgi.conf;        }        #图片缓存时间设置        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$        {            　　expires 10d;        }        #JS和CSS缓存时间设置        location ~ .*.(js|css)?$        {            　　expires 1h;        }    }​    日志格式设定​    log_format access &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;    &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;    &apos;&quot;$http_user_agent&quot; $http_x_forwarded_for&apos;;    #定义本虚拟主机的访问日志    access_log /var/log/nginx/ha97access.log access;​    #对 &quot;/&quot; 启用反向代理    location / {​        proxy_pass http://127.0.0.1:88;        proxy_redirect off;        proxy_set_header X-Real-IP $remote_addr;        #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        #以下是一些反向代理的配置，可选。        proxy_set_header Host $host;        client_max_body_size 10m; #允许客户端请求的最大单文件字节数        client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数，        proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时)        proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时)        proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时)        proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小        proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的设置        proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2）        proxy_temp_file_write_size 64k;        #设定缓存文件夹大小，大于这个值，将从upstream服务器传​    }​        设定查看Nginx状态的地址​    location /NginxStatus {​        stub_status on;        access_log on;        auth_basic &quot;NginxStatus&quot;;        auth_basic_user_file conf/htpasswd;        #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。​    }​    #本地动静分离反向代理配置    #所有jsp的页面均交由tomcat或resin处理    location ~ .(jsp|jspx|do)?$ {​        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_pass http://127.0.0.1:8080;​    }​        #所有静态文件由nginx直接读取不经过tomcat或resin    location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$    {　　 expires 15d;　　 }    location ~ .*.(js|css)?$    { 　　expires 1h;　　 }}</code></pre><h5 id="nginx-在thinkphp-的url-重写"><a href="#nginx-在thinkphp-的url-重写" class="headerlink" title="nginx 在thinkphp  的url 重写"></a>nginx 在thinkphp  的url 重写</h5><p>在/usr/local/nginx/conf/vhost/你的域名配置文件 中添加</p><pre><code>location / {　　if (!-e $request_filename) {　　rewrite ^/(.*)/(.*)/(.*)/*$ /index.php?m=$1&amp;c=$2&amp;a=$3 last;  # thinkphp 的配置文件中 &apos;URL_MODEL&apos; =&gt; 1   PATHINFO模式​       #或者  rewrite  ^(.*)$  /index.php?s=$1  last;　　　　 # thinkphp 的配置文件中 &apos;URL_MODEL&apos; =&gt;3   兼容模式​       #或者  rewrite  /(.*)$  /index.php/$1  last;          # thinkphp 的配置文件中 &apos;URL_MODEL&apos; =&gt; 2  REWRITE模式　　break;　　}} </code></pre><h5 id="路径-pathinfo-模式-thinkphp-添加"><a href="#路径-pathinfo-模式-thinkphp-添加" class="headerlink" title="路径 pathinfo 模式[ thinkphp ] 添加"></a>路径 pathinfo 模式[ thinkphp ] 添加</h5><pre><code>location ~ \.php(.*)$ {　　fastcgi_pass   127.0.0.1:9000;　　fastcgi_index  index.php;　　fastcgi_split_path_info  ^((?U).+\.php)(/?.+)$;　　fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;　　fastcgi_param  PATH_INFO  $fastcgi_path_info;　　fastcgi_param  PATH_TRANSLATED  $document_root$fastcgi_path_info;　　include        fastcgi_params;}</code></pre><h5 id="重写-url-省略index-php"><a href="#重写-url-省略index-php" class="headerlink" title="重写 url +省略index.php"></a>重写 url +省略index.php</h5><pre><code>location / {　　try_files $uri /index.php?$uri;}</code></pre><p>nginx -s reload 或者 /usr/local/nginx/sbin/nginx -s reload 重新加载Nginx配置文件</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nginx 总的 配置文件 位置 /usr/local/nginx/conf/nginx.conf&lt;br&gt;nginx 正则匹配&lt;/p&gt;
&lt;h3 id=&quot;一．正则表达式匹配，其中：&quot;&gt;&lt;a href=&quot;#一．正则表达式匹配，其中：&quot; class=&quot;headerlink&quot; title=&quot;一．正则表达式匹配，其中：&quot;&gt;&lt;/a&gt;一．正则表达式匹配，其中：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;~ 为区分大小写匹配&lt;/li&gt;
&lt;li&gt;~* 为不区分大小写匹配&lt;/li&gt;
&lt;li&gt;!~和!~*分别为区分大小写不匹配及不区分大小写不匹配&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="Nginx" scheme="https://icocos.github.io/tags/Nginx/"/>
    
      <category term="配置文件" scheme="https://icocos.github.io/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>linux命令--查找与统计（grep、awk、sort、uniq、wc）</title>
    <link href="https://icocos.github.io/2018/10/16/linux%E5%91%BD%E4%BB%A4--%E6%9F%A5%E6%89%BE%E4%B8%8E%E7%BB%9F%E8%AE%A1%EF%BC%88grep%E3%80%81awk%E3%80%81sort%E3%80%81uniq%E3%80%81wc%EF%BC%89/"/>
    <id>https://icocos.github.io/2018/10/16/linux命令--查找与统计（grep、awk、sort、uniq、wc）/</id>
    <published>2018-10-16T10:47:41.000Z</published>
    <updated>2019-05-22T09:17:27.178Z</updated>
    
    <content type="html"><![CDATA[<p>在做日志分析时或者配置分析时，通常会遇到查找出符合某一条件的行，并统计，主要应用的就是grep、awk、sort、uniq、wc五个命令</p><h5 id="1-grep命令"><a href="#1-grep命令" class="headerlink" title="1. grep命令"></a>1. grep命令</h5><p>grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p><a id="more"></a><p>语法格式为：</p><pre><code>grep [option] pattern file //pattern 通常可以为正则表达式</code></pre><p>常见的参数为：</p><p>选项</p><pre><code>-a ：将 binary 文件以 text 文件的方式搜寻数据-c ：计算找到 &apos;搜寻字符串&apos; 的次数-i ：忽略大小写的不同，所以大小写视为相同-n ：顺便输出行号-v ：反向选择，亦即显示出没有 &apos;搜寻字符串&apos; 内容的那一行！--color=auto ：可以将找到的关键词部分加上颜色的显示喔！</code></pre><h5 id="2-awk命令"><a href="#2-awk命令" class="headerlink" title="2.awk命令"></a>2.awk命令</h5><p>  awk命令通常是将所列出的行，根据条件打印出某一列或几列</p><blockquote><p>常用形式为：awk  -F ‘:’  ‘BEGIN {print “name,shell”}  {if($1=”root”) print $1”,”$7} END {print “blue,/bin/nosh”}’  </p></blockquote><h5 id="3-sort命令"><a href="#3-sort命令" class="headerlink" title="3.sort命令"></a>3.sort命令</h5><p>sort排序原则：sort将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。</p><pre><code>sort [optional] filename</code></pre><p>常用参数：</p><pre><code>-u：去除重复行-r：默认是升序排序，-r是改为降序-o：将排序结果写入到源文件-n：默认是通过ASCII码值排序，但是这时会出现10比2小的情况，-n就是说要以数值进行排序-k和-t：-k是指定以哪一列进行排序，-t是指定分隔符</code></pre><p>举例：</p><ul><li><p>（1）sort -n -t “ “ -k 2 -k 3 facebook.txt  //人数相同的按照员工平均工资升序排序</p></li><li><p>（2） sort -n -t ‘ ‘ -k 3r -k 2 facebook.txt //按照员工工资降序排序，如果员工人数相同的，则按照公司人数升序排序</p></li><li><p>（3）sort -t ‘ ‘ -k 1.2 facebook.txt //从公司英文名称的第二个字母开始进行排序</p></li><li><p>（4）sort -t ‘ ‘ -k 1.2,1.2 -k 3,3nr facebook.txt //只针对公司英文名称的第二个字母进行排序，如果相同的按照员工工资进行降序排序</p></li></ul><h5 id="4-uniq命令"><a href="#4-uniq命令" class="headerlink" title="4.uniq命令"></a>4.uniq命令</h5><p>uniq命令可以去除排序过的文件中的重复行，因此uniq经常和sort合用。也就是说，为了使uniq起作用，所有的重复行必须是相邻的。</p><pre><code>-i   ：忽略大小写字符的不同；-c  ：进行计数,即统计该行的重复次数-u  ：显示不存在的行-d：显示存在重复的行</code></pre><h5 id="5-wc-命令"><a href="#5-wc-命令" class="headerlink" title="5.wc  命令"></a>5.wc  命令</h5><p>统计指定文件中的字节数、字数、行数，并将统计结果显示输出。该命令统计指定文件中的字节数、字数、行数。如果没有给出文件名，则从标准输入读取。wc同时也给出所指定文件的总统计数。</p><ul><li>-c 统计字节数。</li><li>-l 统计行数。</li><li>-m 统计字符数。这个标志不能与 -c 标志一起使用。</li><li>-w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。</li><li>-L 打印最长行的长度。</li><li>-help 显示帮助信息</li><li>–version 显示版本信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# wc test.txt</span><br><span class="line">7  8 70 test.txt</span><br></pre></td></tr></table></figure><ul><li>7 表示行数</li><li>8 表示单词数</li><li>70  字节数</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做日志分析时或者配置分析时，通常会遇到查找出符合某一条件的行，并统计，主要应用的就是grep、awk、sort、uniq、wc五个命令&lt;/p&gt;
&lt;h5 id=&quot;1-grep命令&quot;&gt;&lt;a href=&quot;#1-grep命令&quot; class=&quot;headerlink&quot; title=&quot;1. grep命令&quot;&gt;&lt;/a&gt;1. grep命令&lt;/h5&gt;&lt;p&gt;grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>iOS游戏——渠道越狱打包流程</title>
    <link href="https://icocos.github.io/2018/10/09/iOS%E6%B8%B8%E6%88%8F%E2%80%94%E2%80%94%E6%B8%A0%E9%81%93%E8%B6%8A%E7%8B%B1%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/"/>
    <id>https://icocos.github.io/2018/10/09/iOS游戏——渠道越狱打包流程/</id>
    <published>2018-10-09T02:15:50.000Z</published>
    <updated>2019-05-20T09:55:29.143Z</updated>
    
    <content type="html"><![CDATA[<p>关于iOS普通ipa打包这里就不说了，只要注意苹果的一些协议条款，基本上步骤都是傻瓜式的，如果不知道如何打包iOS普通ipa包，请出门左转，度娘在哪里等你！</p><blockquote><p>那么，如何将app打包成越狱包，越狱iphone在cydia源上下载安装，这样的需求在互联网游戏行业是非常普遍的，尤其是各种马甲包横行的时代！</p></blockquote><h6 id="关于越狱相关内容，请看这里"><a href="#关于越狱相关内容，请看这里" class="headerlink" title="关于越狱相关内容，请看这里"></a>关于越狱相关内容，请看这里</h6><ul><li><a href="https://www.52pojie.cn/thread-683139-1-1.html" target="_blank" rel="noopener">iOS越狱解除工具</a></li><li><a href="https://www.baidu.com/link?url=1tVxiDdLIbOv2qstGpFdZEOf-18kIJHyyGSXt77CmMo8goYBtfcIYXJNkWePH5bR&amp;wd=&amp;eqid=88fc6288000136f6000000065bc81910" target="_blank" rel="noopener">ios越狱原理详解</a></li></ul><a id="more"></a><h3 id="常见deb包打包方式"><a href="#常见deb包打包方式" class="headerlink" title="常见deb包打包方式"></a>常见deb包打包方式</h3><h5 id="1、第一种方式："><a href="#1、第一种方式：" class="headerlink" title="1、第一种方式："></a>1、第一种方式：</h5><p>自定义目录下 如desktop创建文件夹，起名test，test内新建文件夹Payload<br>把xcode Build好的.app（Products目录中）拷到Payload目录中<br>打开终端，cd指令 到test文件目录下，执行 </p><pre><code>zip -r “xxx.ipa” *         注意里面的空格：(zip -r “xxx.ipa”[空格]* )</code></pre><p>ipa包就打好了，可以安装到越狱手机上试试看</p><blockquote><p>注意事项：Debug或Release的Any iOS SDK都设置为正式发布证书，经测试该越狱包可正常接收推送。</p></blockquote><h5 id="2、第二种方式："><a href="#2、第二种方式：" class="headerlink" title="2、第二种方式："></a>2、第二种方式：</h5><p>在xcode中点击Product-&gt;Archive,完成后会弹出Organizer，点右边的Distribute，弹出一个向导对话框，点击“Export as Xcode Archive”，选择位置，会在那个位置生成后缀名是.xcarchive的文件<br>右键“显示包内容”-&gt;”Products”-&gt;”applications” 然后找到那个应用程序，</p><blockquote><p>将其拖到iTunes里面，在itunes的【应用程序】里找到这个文件，然后右键“在Finder 中显示”，便可找到ipa文件了<br>….</p></blockquote><p>ipa包就打好了，可以安装到越狱手机上试试看</p><h3 id="最近发现了一种更好的方式"><a href="#最近发现了一种更好的方式" class="headerlink" title="最近发现了一种更好的方式"></a>最近发现了一种更好的方式</h3><p>致谢： <a href="http://www.zhaoxiaodan.com/" target="_blank" rel="noopener">胖梁的技术笔记</a></p><h5 id="1-修改编译选项重新打包"><a href="#1-修改编译选项重新打包" class="headerlink" title="1.修改编译选项重新打包"></a>1.修改编译选项重新打包</h5><p>在工程的Build Settings -&gt; Code Signing -&gt; Code Signing Identity选项, 将 Debug 和 Release 下的 Any iOS SDK都设置为 Don’t Code Sign然后在重新Archive</p><h5 id="2-准备目录"><a href="#2-准备目录" class="headerlink" title="2.准备目录"></a>2.准备目录</h5><p>创建一个目录用来打包,如tmp,tmp下建DEBIAN和Applications两个目录, DEBIAN下建一个文本文件control tmp目录结构如下:</p><pre><code>-DEBIAN---control-Applications</code></pre><p>control文件就是打包时的配置文件,它也会作为deb包的配置被打包到包中, 文件例子:</p><pre><code>Package: com.sharedream.gameName: 游戏测试Version: 0.1-1Description: 游戏测试游戏,开发中...Section: 游戏Depends: firmware (&gt;= 4.3)Priority: optionalArchitecture: iphoneos-armAuthor: liangwei &lt;http://weibo.com/iamliangwei&gt;Homepage: http://weibo.com/iamliangweiIcon: file:///Applications/game.app/Icon.pngMaintainer: liangwei &lt;http://weibo.com/iamliangwei&gt;</code></pre><p>然后将xcode打包出来的.app文件整个拷贝到Applications目录下, 结构如下:</p><pre><code>-DEBIAN---control-Applications---game.app</code></pre><h5 id="3-打包"><a href="#3-打包" class="headerlink" title="3.打包"></a>3.打包</h5><p>退出至tmp的上层目录</p><pre><code>dpkg-deb -b tmp game.deb</code></pre><p>看到如下几行就是打包完成了</p><pre><code>warning, `com.sull.sample/DEBIAN/control&apos; contains user-defined field `Name&apos;warning, `com.sull.sample/DEBIAN/control&apos; contains user-defined field `Author&apos;warning, `com.sull.sample/DEBIAN/control&apos; contains user-defined field `Sponsor&apos;dpkg-deb: ignoring 3 warnings about the control file(s)</code></pre><p>拷贝到cydia源中, 重新扫描包生成Packages列表文件, 并压缩成Packages.bz2就可以啦</p><pre><code>dpkg-scanpackages -m debs &gt;Packagesbzip2 -zkf Packages</code></pre><blockquote><p>contains ununderstood data member data.tar.xz” 的安装错误</p></blockquote><p>是因为自从1.17.0版本的dpkg-deb开始, 默认使用xz格式来压缩data.tar文件<br>但是,cydia在ios提供的dpkg是1.14版本, 还没有支持xz这种压缩格式<br>所以我们需要设置”-Zgzip”参数给dpkg-deb 进行打包, 类似命令:</p><pre><code>dpkg-deb -Zgzip -b tmp game.deb</code></pre><h6 id="关于iOS普通包打包可以参考这里："><a href="#关于iOS普通包打包可以参考这里：" class="headerlink" title="关于iOS普通包打包可以参考这里："></a>关于iOS普通包打包可以参考这里：</h6><ul><li><a href="https://blog.csdn.net/zhanghow/article/details/60603461?utm_source=blogxgwz8" target="_blank" rel="noopener">https://blog.csdn.net/zhanghow/article/details/60603461?utm_source=blogxgwz8</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于iOS普通ipa打包这里就不说了，只要注意苹果的一些协议条款，基本上步骤都是傻瓜式的，如果不知道如何打包iOS普通ipa包，请出门左转，度娘在哪里等你！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;那么，如何将app打包成越狱包，越狱iphone在cydia源上下载安装，这样的需求在互联网游戏行业是非常普遍的，尤其是各种马甲包横行的时代！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;关于越狱相关内容，请看这里&quot;&gt;&lt;a href=&quot;#关于越狱相关内容，请看这里&quot; class=&quot;headerlink&quot; title=&quot;关于越狱相关内容，请看这里&quot;&gt;&lt;/a&gt;关于越狱相关内容，请看这里&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.52pojie.cn/thread-683139-1-1.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iOS越狱解除工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.baidu.com/link?url=1tVxiDdLIbOv2qstGpFdZEOf-18kIJHyyGSXt77CmMo8goYBtfcIYXJNkWePH5bR&amp;amp;wd=&amp;amp;eqid=88fc6288000136f6000000065bc81910&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ios越狱原理详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Games" scheme="https://icocos.github.io/categories/Games/"/>
    
    
      <category term="iOS游戏——渠道越狱打包流程" scheme="https://icocos.github.io/tags/iOS%E6%B8%B8%E6%88%8F%E2%80%94%E2%80%94%E6%B8%A0%E9%81%93%E8%B6%8A%E7%8B%B1%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/"/>
    
      <category term="游戏" scheme="https://icocos.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="越狱" scheme="https://icocos.github.io/tags/%E8%B6%8A%E7%8B%B1/"/>
    
  </entry>
  
  <entry>
    <title>MySQL拓展(extend)</title>
    <link href="https://icocos.github.io/2018/07/28/MySQL%E6%8B%93%E5%B1%95(extend)/"/>
    <id>https://icocos.github.io/2018/07/28/MySQL拓展(extend)/</id>
    <published>2018-07-28T04:14:14.000Z</published>
    <updated>2019-05-22T09:17:26.135Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、分区表的原理"><a href="#一、分区表的原理" class="headerlink" title="一、分区表的原理"></a>一、分区表的原理</h3><blockquote><p>对用户来说，分区表是一个独立的逻辑表，但是底层mysql将其分成了多个物理的子表，这对用户来说是透明的，每一个分区表都会使用一个独立的表文件。  </p></blockquote><h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h5><blockquote><p>创建表的时候通过partition by子句定义每个分区存放的数据，执行查询的时候，优化器会根据分区定义过滤那些没有我们需要数据的分区，这样查询只查询所需的数据所在分区</p></blockquote><p>分区的主要目的是将数据按照一个比较粗的粒度分在不同的表中，这样可以将相关的数据存放在一起，而且要一次删除整个分区也十分方便</p><a id="more"></a><h6 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h6><ol><li>表非常大，无法全部存在内存，或者只在表的最后有热点数据，其他都是历史数据  </li><li>分区表的数据更易维护，可以对独立的分区进行独立的操作  </li><li>分区表的数据可以分布在不同的机器上，从而高效的使用资源</li></ol><h3 id="二、分库分表的原理"><a href="#二、分库分表的原理" class="headerlink" title="二、分库分表的原理"></a>二、分库分表的原理</h3><blockquote><p>通过一些HASH算法或者工具将一张数据表垂直或者水平的进行物理切分</p></blockquote><h6 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h6><ol><li>单表数据达到百万甚至千万的级别</li><li>解决表锁的问题</li></ol><h4 id="水平分割"><a href="#水平分割" class="headerlink" title="水平分割"></a>水平分割</h4><p>此时表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询效率  </p><h6 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h6><ol><li>表中的数据有独立性，例如表中记录各个地区或各个时间段的数据，有些数据常用，有些数据不常用 </li><li>需要把数据存放在多个介质上  </li></ol><h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><ol><li>给应用增加复杂度，通常查询需要多个表名，查询所有的数据都需要union操作</li></ol><h4 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h4><p>将主键和一些列放在一张表，然后把主键和其他列放在另外一张表  </p><h6 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h6><ol><li>表中一些列常用，一些列不常用  </li><li>可以使数据行变小，一个数据页能存储更多的数据，减少查询I/O次数</li></ol><h6 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h6><ol><li>管理冗余列，查询所有的数据都需要join操作</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、分区表的原理&quot;&gt;&lt;a href=&quot;#一、分区表的原理&quot; class=&quot;headerlink&quot; title=&quot;一、分区表的原理&quot;&gt;&lt;/a&gt;一、分区表的原理&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;对用户来说，分区表是一个独立的逻辑表，但是底层mysql将其分成了多个物理的子表，这对用户来说是透明的，每一个分区表都会使用一个独立的表文件。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;原理：&quot;&gt;&lt;a href=&quot;#原理：&quot; class=&quot;headerlink&quot; title=&quot;原理：&quot;&gt;&lt;/a&gt;原理：&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;创建表的时候通过partition by子句定义每个分区存放的数据，执行查询的时候，优化器会根据分区定义过滤那些没有我们需要数据的分区，这样查询只查询所需的数据所在分区&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分区的主要目的是将数据按照一个比较粗的粒度分在不同的表中，这样可以将相关的数据存放在一起，而且要一次删除整个分区也十分方便&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Nginx负载均衡入门</title>
    <link href="https://icocos.github.io/2018/07/24/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%85%A5%E9%97%A8/"/>
    <id>https://icocos.github.io/2018/07/24/Nginx负载均衡入门/</id>
    <published>2018-07-24T10:18:04.000Z</published>
    <updated>2019-05-21T06:02:16.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>负载均衡（Load Balance）其意思就是分摊到多个操作单元上进行执行，从而共同完成工作任务。通过核心调度者，保证所有后端服务器都将性能充分发挥，从而保持服务器集群的整体性能最优。</p><a id="more"></a><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ol><li><p>[加权]随机算法</p><p> 通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。可以按后端机器的配置设置随机概率的权重。调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</p></li><li><p>[加权]轮询算法</p><p> 将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。可以按后端机器的配置为轮询中的服务器附加一定权重的算法。比如服务器1权重1，服务器2权重2，服务器3权重3，则顺序为1-2-2-3-3-3-1-2-2-3-3-3- ……</p><p> 当服务器群中各服务器的处理能力相同时，且每笔业务处理量差异不大时，最适合使用这种算法。 </p></li><li><p>[加权]最小连接算法</p><p> 在多个服务器中，与处理连接数(会话数)最少的服务器进行通信的算法。由于后端服务器的配置不尽相同，对于请求的处理有快有慢，最小连接数法根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</p><p> 可以事先为每台服务器分配处理连接的数量，并将客户端请求转至连接数最少的服务器上。</p></li><li><p>源地址哈希法</p><p> 根据获取客户端的IP地址，通过哈希函数计算得到一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，相同的IP客户端，如果服务器列表不变，将映射到同一个后台服务器进行访问。</p><p> 当客户端有一系列业务需要处理而必须和一个服务器反复通信时，该算法能够以流(会话)为单位，保证来自相同客户端的通信能够一直在同一服务器中进行处理。</p></li></ol><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># server1</span><br><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    server_name local.load.com;</span><br><span class="line">    index index.html;</span><br><span class="line">    root /home/www;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Load Balance</span><br><span class="line">upstream load.com.conf &#123;</span><br><span class="line">    server 192.168.1.101:80;</span><br><span class="line">    server 192.168.1.102:80;</span><br><span class="line">    server 127.0.0.1:8080;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"># web server</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name local.load.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass              http://load.com.conf;</span><br><span class="line">        #proxy_set_header        Host    $host;</span><br><span class="line">        #proxy_set_header        X-Real-IP       $remotr_addr;</span><br><span class="line">        #proxy_set_header        X-Forwarde-For  $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># server2 192.168.1.101</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name local.load.com;</span><br><span class="line">    root /home/www;</span><br><span class="line">    location / &#123;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># server3 192.168.1.102</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name local.load.com;</span><br><span class="line">    root /home/www;</span><br><span class="line">    location / &#123;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="详细配置"><a href="#详细配置" class="headerlink" title="详细配置"></a>详细配置</h3><p>轮询模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream load.com.conf &#123;</span><br><span class="line">   server 192.168.0.1;</span><br><span class="line">   server 192.168.0.2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加权轮询模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream load.com.conf &#123;</span><br><span class="line">   server 192.168.0.1 weight=3;</span><br><span class="line">   server 192.168.0.2 weight=2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源地址哈希法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream load.com.conf &#123;</span><br><span class="line">   ip_hash;</span><br><span class="line">   server 192.168.0.1 weight=3;</span><br><span class="line">   server 192.168.0.2 weight=2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fair（第三方）：按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream load.com.conf &#123;  </span><br><span class="line">  server server1;  </span><br><span class="line">  server server2;  </span><br><span class="line">  fair;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>url_hash（第三方）：按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</p><p>例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream load.com.conf &#123;  </span><br><span class="line">  server squid1:3128;  </span><br><span class="line">  server squid2:3128;  </span><br><span class="line">  hash $request_uri;  </span><br><span class="line">  hash_method crc32;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">upstream bakend &#123;</span><br><span class="line">  ip_hash;  </span><br><span class="line">  server 127.0.0.1:9090 down;  </span><br><span class="line">  server 127.0.0.1:8080 weight=2;  </span><br><span class="line">  server 127.0.0.1:6060;  </span><br><span class="line">  server 127.0.0.1:7070 backup;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要使用负载均衡的server中增加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_pass http://bakend/;</span><br></pre></td></tr></table></figure><p>每个设备的状态设置为：</p><ul><li>down 表示单前的server暂时不参与负载 </li><li>weight 默认为1.weight越大，负载的权重就越大。 </li><li>max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误 </li><li>fail_timeout:max_fails次失败后，暂停的时间。 </li><li>backup： 其它所有的非backup机器down或者忙的时候，请求backup</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;负载均衡&quot;&gt;&lt;a href=&quot;#负载均衡&quot; class=&quot;headerlink&quot; title=&quot;负载均衡&quot;&gt;&lt;/a&gt;负载均衡&lt;/h1&gt;&lt;p&gt;负载均衡（Load Balance）其意思就是分摊到多个操作单元上进行执行，从而共同完成工作任务。通过核心调度者，保证所有后端服务器都将性能充分发挥，从而保持服务器集群的整体性能最优。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="Nginx" scheme="https://icocos.github.io/tags/Nginx/"/>
    
      <category term="负载均衡" scheme="https://icocos.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
</feed>
