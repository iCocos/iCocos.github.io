<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iCocos</title>
  
  <subtitle>www.icocos.cn</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://icocos.github.io/"/>
  <updated>2018-12-28T02:53:30.442Z</updated>
  <id>https://icocos.github.io/</id>
  
  <author>
    <name>曹理鹏@iCocos</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP——PHP经典面试二</title>
    <link href="https://icocos.github.io/2018/12/28/PHP%E2%80%94%E2%80%94PHP%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E4%BA%8C/"/>
    <id>https://icocos.github.io/2018/12/28/PHP——PHP经典面试二/</id>
    <published>2018-12-28T14:22:18.000Z</published>
    <updated>2018-12-28T02:53:30.442Z</updated>
    
    <content type="html"><![CDATA[<p>HP经典面试二…..</p><h2 id="HP经典面试二"><a href="#HP经典面试二" class="headerlink" title="HP经典面试二"></a>HP经典面试二</h2><h3 id="isset、empty、is-null的区别"><a href="#isset、empty、is-null的区别" class="headerlink" title="isset、empty、is_null的区别"></a>isset、empty、is_null的区别</h3><p>isset 判断变量是否定义或者是否为空</p><pre><code>变量存在返回ture，否则返回false变量定义不赋值返回falseunset一个变量，返回false变量赋值为null，返回false</code></pre><p>empty：判断变量的值是否为空，能转换为false的都是空，为空返回true，反之返回false。</p><pre><code>&quot;&quot;,0,&quot;0&quot;,NULL，FALSE都认为为空，返回true没有任何属性的对象都认为是空</code></pre><p>is_null：检测传入的值(值、变量、表达式)是否为null</p><pre><code>定义了，但是赋值为Null定义了，但是没有赋值unset一个变量</code></pre><h3 id="前端调试的工具"><a href="#前端调试的工具" class="headerlink" title="前端调试的工具"></a>前端调试的工具</h3><pre><code>Firefox的firebugChrome的开发工具EmmetJSON格式校验工具</code></pre><h3 id="简单描述mysql中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）（新浪网技术部）"><a href="#简单描述mysql中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）（新浪网技术部）" class="headerlink" title="简单描述mysql中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）（新浪网技术部）"></a>简单描述mysql中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）（新浪网技术部）</h3><pre><code>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。普通索引(由关键字KEY或INDEX定义的索引)的唯一任务是加快对数据的访问速度。普通索引允许被索引的数据列包含重复的值。如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。也就是说，唯一索引可以保证数据记录的唯一性。主键，是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引，这就是联合索引。索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件。</code></pre><h3 id="数据库中的事务是什么"><a href="#数据库中的事务是什么" class="headerlink" title="数据库中的事务是什么?"></a>数据库中的事务是什么?</h3><pre><code>事务（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。ACID 四大特性,原子性、隔离性、一致性、持久性。</code></pre><h3 id="了解XSS攻击吗？如何防止？"><a href="#了解XSS攻击吗？如何防止？" class="headerlink" title="了解XSS攻击吗？如何防止？"></a>了解XSS攻击吗？如何防止？</h3><pre><code>XSS是跨站脚本攻击，首先是利用跨站脚本漏洞以一个特权模式去执行攻击者构造的脚本，然后利用不安全的Activex控件执行恶意的行为。使用htmlspecialchars()函数对提交的内容进行过滤，使字符串里面的特殊符号实体化。</code></pre><h3 id="SQL注入漏洞产生的原因？如何防止？"><a href="#SQL注入漏洞产生的原因？如何防止？" class="headerlink" title="SQL注入漏洞产生的原因？如何防止？"></a>SQL注入漏洞产生的原因？如何防止？</h3><pre><code>SQL注入产生的原因：程序开发过程中不注意规范书写sql语句和对特殊字符进行过滤，导致客户端可以通过全局变量POST和GET提交一些sql语句正常执行。</code></pre><p>防止SQL注入的方式：</p><pre><code>开启配置文件中的magic_quotes_gpc 和 magic_quotes_runtime设置执行sql语句时使用addslashes进行sql语句转换Sql语句书写尽量不要省略双引号和单引号。过滤掉sql语句中的一些关键词：update、insert、delete、select、 * 。提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不易被猜到的。Php配置文件中设置register_globals为off,关闭全局变量注册控制错误信息，不要在浏览器上输出错误信息，将错误信息写到日志文件中。</code></pre><h3 id="PHP网站的主要攻击方式有哪些？"><a href="#PHP网站的主要攻击方式有哪些？" class="headerlink" title="PHP网站的主要攻击方式有哪些？"></a>PHP网站的主要攻击方式有哪些？</h3><pre><code>命令注入(Command Injection)eval 注入(Eval Injection)客户端脚本攻击(Script Insertion)跨网站脚本攻击(Cross Site Scripting, XSS)SQL 注入攻击(SQL injection)跨网站请求伪造攻击(Cross Site RequestForgeries, CSRF)Session 会话劫持(Session Hijacking)Session 固定攻击(Session Fixation)HTTP 响应拆分攻击(HTTP Response Splitting)文件上传漏洞(File Upload Attack)目录穿越漏洞(Directory Traversal)远程文件包含攻击(Remote Inclusion)动态函数注入攻击(Dynamic VariableEvaluation)URL 攻击(URL attack)表单提交欺骗攻击(Spoofed FormSubmissions)HTTP 请求欺骗攻击(Spoofed HTTP Requests)</code></pre><h3 id="框架中什么是单一入口和多入口-，-单一入口的优缺点？"><a href="#框架中什么是单一入口和多入口-，-单一入口的优缺点？" class="headerlink" title="框架中什么是单一入口和多入口 ， 单一入口的优缺点？"></a>框架中什么是单一入口和多入口 ， 单一入口的优缺点？</h3><pre><code>多口就是通过访问不同的文件来完成用户请求。单一入口只 web 程序所有的请求都指向一个脚本文件的。单一入口更容易控制权限，方便对 http 请求可以进行安全性检查。缺点：URL 看起来不那么美观，特别是对搜索引擎来说不友好。</code></pre><h2 id="对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题："><a href="#对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题：" class="headerlink" title="对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题："></a>对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题：</h2><h3 id="索引的目的是什么？"><a href="#索引的目的是什么？" class="headerlink" title="索引的目的是什么？"></a>索引的目的是什么？</h3><pre><code>快速访问数据表中的特定信息，提高检索速度创建唯一性索引，保证数据库表中每一行数据的唯一性。加速表和表之间的连接使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间</code></pre><h3 id="索引对数据库系统的负面影响是什么？"><a href="#索引对数据库系统的负面影响是什么？" class="headerlink" title="索引对数据库系统的负面影响是什么？"></a>索引对数据库系统的负面影响是什么？</h3><p>负面影响：<br>    创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。</p><h3 id="为数据表建立索引的原则有哪些？"><a href="#为数据表建立索引的原则有哪些？" class="headerlink" title="为数据表建立索引的原则有哪些？"></a>为数据表建立索引的原则有哪些？</h3><pre><code>在最频繁使用的、用以缩小查询范围的字段上建立索引。在频繁使用的、需要排序的字段上建立索引</code></pre><h3 id="什么情况下不宜建立索引？"><a href="#什么情况下不宜建立索引？" class="headerlink" title="什么情况下不宜建立索引？"></a>什么情况下不宜建立索引？</h3><pre><code>对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等。</code></pre><h2 id="简述在MySQL数据库中MyISAM和InnoDB的区别"><a href="#简述在MySQL数据库中MyISAM和InnoDB的区别" class="headerlink" title="简述在MySQL数据库中MyISAM和InnoDB的区别"></a>简述在MySQL数据库中MyISAM和InnoDB的区别</h2><pre><code>区别于其他数据库的最重要的特点就是其插件式的表存储引擎。切记：存储引擎是基于表的，而不是数据库。</code></pre><h3 id="InnoDB与MyISAM的区别："><a href="#InnoDB与MyISAM的区别：" class="headerlink" title="InnoDB与MyISAM的区别："></a>InnoDB与MyISAM的区别：</h3><pre><code>InnoDB存储引擎: 主要面向OLTP(Online Transaction Processing，在线事务处理)方面的应用，是第一个完整支持ACID事务的存储引擎(BDB第一个支持事务的存储引擎，已经停止开发)。</code></pre><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>行锁设计、支持外键；</p><pre><code>支持类似于Oracle风格的一致性非锁定读(即：默认情况下读取操作不会产生锁)；InnoDB将数据放在一个逻辑的表空间中，由InnoDB自身进行管理。从MySQL4.1版本开始，可以将每个InnoDB存储引擎的表单独存放到一个独立的ibd文件中；InnoDB通过使用MVCC(多版本并发控制：读不会阻塞写，写也不会阻塞读)来获得高并发性，并且实现了SQL标准的4种隔离级别(默认为REPEATABLE级别)；InnoDB还提供了插入缓冲(insert buffer)、二次写(double write)、自适应哈希索引(adaptive hash index)、预读(read ahead)等高性能和高可用的功能；InnoDB采用了聚集(clustered)的方式来存储表中的数据，每张标的存储都按主键的顺序存放(如果没有显式的在建表时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键)；InnoDB表会有三个隐藏字段：除了上面提到了6字节的DB_ROW_ID外，还有6字节的DB_TX_ID(事务ID)和7字节的DB_ROLL_PTR(指向对应回滚段的地址)。这个可以通过innodb monitor看到；MyISAM存储引擎: 是MySQL官方提供的存储引擎，主要面向OLAP(Online Analytical Processing,在线分析处理)方面的应用。特点：</code></pre><p>不支持事务，支持表所和全文索引。操作速度快；<br>MyISAM存储引擎表由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。MySQL数据库只缓存其索引文件，数据文件的缓存交给操作系统本身来完成；<br>MySQL5.0版本开始，MyISAM默认支持256T的单表数据；</p><h3 id="解释MySQL外连接、内连接与自连接的区别"><a href="#解释MySQL外连接、内连接与自连接的区别" class="headerlink" title="解释MySQL外连接、内连接与自连接的区别"></a>解释MySQL外连接、内连接与自连接的区别</h3><pre><code>先说什么是交叉连接: 交叉连接又叫笛卡尔积，它是指不使用任何条件，直接将一个表的所有记录和另一个表中的所有记录一一匹配。内连接 则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合条件的记录不会出现在结果集中，即内连接只连接匹配的行。外连接 其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或两个表中的所有数据行，这三种情况依次称之为左外连接，右外连接，和全外连接。左外连接，也称左连接，左表为主表，左表中的所有记录都会出现在结果集中，对于那些在右表中并没有匹配的记录，仍然要显示，右边对应的那些字段值以NULL来填充。右外连接，也称右连接，右表为主表，右表中的所有记录都会出现在结果集中。左连接和右连接可以互换，MySQL目前还不支持全外连接。</code></pre><h3 id="写出三种以上MySQL数据库存储引擎的名称（提示：不区分大小写）"><a href="#写出三种以上MySQL数据库存储引擎的名称（提示：不区分大小写）" class="headerlink" title="写出三种以上MySQL数据库存储引擎的名称（提示：不区分大小写）"></a>写出三种以上MySQL数据库存储引擎的名称（提示：不区分大小写）</h3><pre><code>MyISAM、InnoDB、BDB（BerkeleyDB）、Merge、Memory（Heap）、Example、Federated、Archive、CSV、Blackhole、MaxDB 等等十几个引擎</code></pre><h3 id="什么是面向对象？主要特征是什么？几大原则是什么？"><a href="#什么是面向对象？主要特征是什么？几大原则是什么？" class="headerlink" title="什么是面向对象？主要特征是什么？几大原则是什么？"></a>什么是面向对象？主要特征是什么？几大原则是什么？</h3><pre><code>面向对象是程序的一种设计模式，它利于提高程序的重用性，使程序机构更加清晰。 主要特征是：封装、继承、多态。五大基本原则： 单一职责原则；开放封闭原则；替换原则； 依赖原则； 接口分离原则。</code></pre><h3 id="什么是静态路由，其特点是什么-什么是动态路由，其特点是什么"><a href="#什么是静态路由，其特点是什么-什么是动态路由，其特点是什么" class="headerlink" title="什么是静态路由，其特点是什么?什么是动态路由，其特点是什么?"></a>什么是静态路由，其特点是什么?什么是动态路由，其特点是什么?</h3><p>参考答案：<br>    　　静态路由是由系统管理员设计与构建的路由表规定的路由。适用于网关数量有限的场 合，且网络拓朴结构不经常变化的网络。其缺点是不能动态地适用网络状况的变化，当 网络状况变化后必须由网络管理员修改路由表。<br>        动态路由是由路由选择协议而动态构建的，路由协议之间通过交换各自所拥有的路由信 息实时更新路由表的内容。动态路由可以自动学习网络的拓朴结构，并更新路由表。其 缺点是路由广播更新信息将占据大量的网络带宽。</p><h3 id="使用过-Memcache-缓存吗，如果使用过，能够简单的描述一下它的工作原理吗？"><a href="#使用过-Memcache-缓存吗，如果使用过，能够简单的描述一下它的工作原理吗？" class="headerlink" title="使用过 Memcache 缓存吗，如果使用过，能够简单的描述一下它的工作原理吗？"></a>使用过 Memcache 缓存吗，如果使用过，能够简单的描述一下它的工作原理吗？</h3><pre><code>Memcahce 是把所有的数据保存在内存当中，采用 hash 表的方式，每条数据由 key 和 value 组成，每个 key 是独一无二的，当要访问某个值的时候先按照找到值，然后返回结果。Memcahce 采用 LRU 算法来逐渐把过期数据清除掉。</code></pre><h3 id="列举流行的-Ajax-框架？说明-Ajax-实现原理是什么及-json-在-Ajax-中起什么作用？"><a href="#列举流行的-Ajax-框架？说明-Ajax-实现原理是什么及-json-在-Ajax-中起什么作用？" class="headerlink" title="列举流行的 Ajax 框架？说明 Ajax 实现原理是什么及 json 在 Ajax 中起什么作用？"></a>列举流行的 Ajax 框架？说明 Ajax 实现原理是什么及 json 在 Ajax 中起什么作用？</h3><p>流行的 Ajax 框架有 jQuery，Prototype，Dojo，MooTools。</p><pre><code>Ajax 的工作原理是一个页面的指定位置可以加载另一个页面所有的输出内容，这样就实现了一个静态页面也能获取到数据库中的返回数据信息了。所以 Ajax 技术实现了一个静态网页在不刷新整个页面的情况下与服务器通信，减少了用户等待时间，同时也从而降低了网络流量，增强了客户体验的友好程度。在使用 Ajax 时，涉及到数据传输，即将数据从服务器返回到客户端，服务器端和客户端分别使用不同的脚步语言来处理数据，这就需要一种通用的数据格式，XML 和 json 就是最常用的两种，而 json 比 XML 更简单。</code></pre><h3 id="Myql中的事务回滚机制概述"><a href="#Myql中的事务回滚机制概述" class="headerlink" title="Myql中的事务回滚机制概述"></a>Myql中的事务回滚机制概述</h3><p>事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位，事务回滚是指将该事务已经完成的对数据库的更新操作撤销。</p><p>　　要同时修改数据库中两个不同表时，如果它们不是一个事务的话，当第一个表修改完，可能第二个表修改过程中出现了异常而没能修改，此时就只有第二个表依旧是未修改之前的状态，而第一个表已经被修改完毕。而当你把它们设定为一个事务的时候，当第一个表修改完，第二表修改出现异常而没能修改，第一个表和第二个表都要回到未修改的状态，这就是所谓的事务回滚。</p>]]></content>
    
    <summary type="html">
    
      PHP经典面试二....
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="PHP经典面试二" scheme="https://icocos.github.io/tags/PHP%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E4%BA%8C/"/>
    
  </entry>
  
  <entry>
    <title>PHP——PHP经典面试一</title>
    <link href="https://icocos.github.io/2018/12/26/PHP%E2%80%94%E2%80%94PHP%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E4%B8%80/"/>
    <id>https://icocos.github.io/2018/12/26/PHP——PHP经典面试一/</id>
    <published>2018-12-26T14:21:11.000Z</published>
    <updated>2018-12-28T02:44:45.626Z</updated>
    
    <content type="html"><![CDATA[<p>PHP经典面试一…..</p><h2 id="PHP经典面试一"><a href="#PHP经典面试一" class="headerlink" title="PHP经典面试一"></a>PHP经典面试一</h2><p>本文章将持续更新，希望能在评论区发表自己的见解和认为比较经典的题目，后续笔者会在适当的节点对本文章进行分类和层次划分。文章中的不足之处望多指点，纠正!</p><h3 id="双引号和单引号的区别"><a href="#双引号和单引号的区别" class="headerlink" title="双引号和单引号的区别"></a>双引号和单引号的区别</h3><pre><code>双引号解释变量，单引号不解释变量双引号里插入单引号，其中单引号里如果有变量的话，变量解释双引号的变量名后面必须要有一个非数字、字母、下划线的特殊字符，或者用{}讲变量括起来，否则会将变量名后面的部分当做一个整体，引起语法错误双引号解释转义字符，单引号不解释转义字符，但是解释&apos;\和\\能使单引号字符尽量使用单引号，单引号的效率比双引号要高（因为双引号要先遍历一遍，判断里面有没有变量，然后再进行操作，而单引号则不需要判断）</code></pre><h3 id="常用的超全局变量-8个"><a href="#常用的超全局变量-8个" class="headerlink" title="常用的超全局变量(8个)"></a>常用的超全局变量(8个)</h3><pre><code>$_GET -----&gt;get传送方式$POST -----&gt;post传送方式$REQUEST -----&gt;可以接收到get和post两种方式的值***$GLOBALS -----&gt;所有的变量都放在里面$FILE -----&gt;上传文件使用$SERVER -----&gt;系统环境变量* **$SESSION -----&gt;会话控制的时候会用到$COOKIE -----&gt;会话控制的时候会用到</code></pre><h3 id="HTTP中POST、GET、PUT、DELETE方式的区别"><a href="#HTTP中POST、GET、PUT、DELETE方式的区别" class="headerlink" title="HTTP中POST、GET、PUT、DELETE方式的区别"></a>HTTP中POST、GET、PUT、DELETE方式的区别</h3><pre><code>HTTP定义了与服务器交互的不同的方法，最基本的是POST、GET、PUT、DELETE，与其比不可少的URL的全称是资源描述符，我们可以这样理解：url描述了一个网络上资源，而post、get、put、delegate就是对这个资源进行增、删、改、查的操作！</code></pre><h3 id="表单中get和post提交方式的区别"><a href="#表单中get和post提交方式的区别" class="headerlink" title="表单中get和post提交方式的区别"></a>表单中get和post提交方式的区别</h3><pre><code>get是把参数数据队列加到提交表单的action属性所指的url中，值和表单内各个字段一一对应，从url中可以看到；post是通过HTTPPOST机制，将表单内各个字段与其内容防止在HTML的head中一起传送到action属性所指的url地址，用户看不到这个过程对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据get传送的数据量较小，post传送的数据量较大，一般被默认不受限制，但在理论上，IIS4中最大量为80kb，IIS5中为1000k，get安全性非常低，post安全性较高</code></pre><p>========= </p><pre><code>GET请求会向数据库发索取数据的请求，从而来获取信息，该请求就像数据库的select操作一样，只是用来查询一下数据，不会修改、增加数据，不会影响资源的内容，即该请求不会产生副作用。无论进行多少次操作，结果都是一样的。与GET不同的是，PUT请求是向服务器端发送数据的，从而改变信息，该请求就像数据库的update操作一样，用来修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。POST请求同PUT请求类似，都是向服务器端发送数据的，但是该请求会改变数据的种类等资源，就像数据库的insert操作一样，会创建新的内容。几乎目前所有的提交操作都是用POST请求的。DELETE请求顾名思义，就是用来删除某一个资源的，该请求就像数据库的delete操作。</code></pre><h2 id="PHP介绍"><a href="#PHP介绍" class="headerlink" title="PHP介绍"></a>PHP介绍</h2><p>Hypertext Preprocessor—-超文本预处理器<br>Personal Home Page 原始名称</p><pre><code>目标用途: 允许web开发人员快速编写动态生成的web页面，与其他页面相比，PHP是将程序嵌入到HTML文档中去执行，效率比完全生成HTML编辑的CGI高很多HTML: Hypertext Markup Language创始人: 拉姆斯勒·勒多夫Rasmus Lerdorf，1968年生，加拿大滑铁卢大学</code></pre><p>勒多夫最开始是为了维护个人网页，用prel语言写了维护程序，之后又用c进行了重写，最终衍生出php/fi</p><h3 id="时间轴"><a href="#时间轴" class="headerlink" title="时间轴:"></a>时间轴:</h3><pre><code>1995.06.08将PHP/FI公开释出1995 php2.0，加入了对MySQL的支持1997 php3.02000 php4.02008 php5.0</code></pre><p>由于php6.0没有完全解决Unicode编码，所以基本没有生产线上的应用，基本只是一款概念产品，很多功能已经在php5.3.3和php5.3.4上实现</p><h3 id="常见的IDE-Intergrated-Development-Environment-集成开发环境"><a href="#常见的IDE-Intergrated-Development-Environment-集成开发环境" class="headerlink" title="常见的IDE(Intergrated Development Environment): 集成开发环境"></a>常见的IDE(Intergrated Development Environment): 集成开发环境</h3><pre><code>Coda（mac）PHPStromAdobe DreamweaverNetBeans</code></pre><h3 id="常见文本编辑器，具备代码高亮："><a href="#常见文本编辑器，具备代码高亮：" class="headerlink" title="常见文本编辑器，具备代码高亮："></a>常见文本编辑器，具备代码高亮：</h3><pre><code>NodePad++SublimeText</code></pre><h2 id="PHP优势"><a href="#PHP优势" class="headerlink" title="PHP优势"></a>PHP优势</h2><h3 id="PHP特性"><a href="#PHP特性" class="headerlink" title="PHP特性:"></a>PHP特性:</h3><pre><code>php独特混合了C,Java,Prel以及PHP自创的语法可以比CGI或者Prel更快速去执行动态网页，与其他变成语言相比，PHP是讲程序嵌入到HTML文档中去执行，执行效率比完全生成HTML编辑的CGI要高很多，所有的CGI都能实现支持几乎所有流行的数据库以及操作系统PHP可以使用C,C++进行程序的扩展</code></pre><h3 id="PHP优势-1"><a href="#PHP优势-1" class="headerlink" title="PHP优势:"></a>PHP优势:</h3><pre><code>开放源代码免费性快捷性跨平台强效率高图形处理面向对象专业专注</code></pre><h3 id="PHP技术应用"><a href="#PHP技术应用" class="headerlink" title="PHP技术应用:"></a>PHP技术应用:</h3><pre><code>静态页面生成数据库缓存过程缓存div+css w3c标准大负荷分布式flex支持MVCSmarty模块引擎</code></pre><h3 id="PHP认证级别"><a href="#PHP认证级别" class="headerlink" title="PHP认证级别"></a>PHP认证级别</h3><pre><code>初级 IFE:Index Front Engineer 前端工程师中级 IPE:Index PHP Engineer PHP工程师高级 IAE:Index Architecture Engineer 架构工程师</code></pre><h3 id="echo、print-r、print、var-dump之间的区别"><a href="#echo、print-r、print、var-dump之间的区别" class="headerlink" title="echo、print_r、print、var_dump之间的区别"></a>echo、print_r、print、var_dump之间的区别</h3><pre><code>* echo、print是php语句，var_dump和print_r是函数* echo 输出一个或多个字符串，中间以逗号隔开，没有返回值是语言结构而不是真正的函数，因此不能作为表达式的一部分使用* print也是php的一个关键字，有返回值 只能打印出简单类型变量的值(如int，string)，如果字符串显示成功则返回true，否则返回false* print_r 可以打印出复杂类型变量的值(如数组、对象）以列表的形式显示，并以array、object开头，但print_r输出布尔值和NULL的结果没有意义，因为都是打印&quot;\n&quot;，因此var_dump()函数更适合调试* var_dump() 判断一个变量的类型和长度，并输出变量的数值</code></pre><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p>点击这儿查看HTTP状态码详解</p><h3 id="常见的HTTP状态码："><a href="#常见的HTTP状态码：" class="headerlink" title="常见的HTTP状态码："></a>常见的HTTP状态码：</h3><pre><code>200 - 请求成功301 - 资源(网页等)被永久转义到其他URL404 - 请求的资源(网页等)不存在505 - 内部服务器错误</code></pre><h3 id="HTTP状态码分类"><a href="#HTTP状态码分类" class="headerlink" title="HTTP状态码分类:"></a>HTTP状态码分类:</h3><pre><code>1** - 信息，服务器收到的请求，需要请求者继续执行操作2** - 成功，操作被成功接收并处理3** - 重定向，需要进一步的操作以完成请求4** - 客户端错误，请求包含语法错误或者无法完成请求5** 服务器错误，服务器在处理请求的过程中发生了错误</code></pre><h3 id="什么是魔术引号"><a href="#什么是魔术引号" class="headerlink" title="什么是魔术引号"></a>什么是魔术引号</h3><pre><code>魔术引号是一个将自动将进入PHP脚本的数据进行转义的过程，最好在编码时不要转义而在运行时根据需要而转义</code></pre><h3 id="如何获取客户端的ip-要求取得一个int-和服务器ip的代码"><a href="#如何获取客户端的ip-要求取得一个int-和服务器ip的代码" class="headerlink" title="如何获取客户端的ip(要求取得一个int)和服务器ip的代码"></a>如何获取客户端的ip(要求取得一个int)和服务器ip的代码</h3><pre><code>客户端：$_SERVER[&quot;REMOTE_ADDR&quot;];或者getenv(&apos;REMOTE_ADDR&apos;)ip2long进行转换服务器端：gethostbyname(&apos;www.baidu.com&apos;)</code></pre><h3 id="使用那些工具进行版本控制"><a href="#使用那些工具进行版本控制" class="headerlink" title="使用那些工具进行版本控制"></a>使用那些工具进行版本控制</h3><pre><code>cvs、svn、vss、git</code></pre><h3 id="优化数据库的方法"><a href="#优化数据库的方法" class="headerlink" title="优化数据库的方法"></a>优化数据库的方法</h3><p>MySQL数据库优化的八大方式（经典必看）点击获取</p><pre><code>选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置NOTNULL，例如&apos;省份&apos;、&apos;性别&apos;最好适用ENUM使用连接(JOIN)来代替子查询适用联合(UNION)来代替手动创建的临时表事务处理锁定表、优化事务处理适用外键，优化锁定表建立索引优化查询语句</code></pre><h3 id="是否使用过模板引擎？使用的模板引擎的名字是？"><a href="#是否使用过模板引擎？使用的模板引擎的名字是？" class="headerlink" title="是否使用过模板引擎？使用的模板引擎的名字是？"></a>是否使用过模板引擎？使用的模板引擎的名字是？</h3><pre><code>Smarty:Smarty算是一种很老的PHP模板引擎了，它曾是我使用这门语言模板的最初选择。虽然它的更新已经不算频繁了，并且缺少新一代模板引擎所具有的部分特性，但是它仍然值得一看。</code></pre><h3 id="对于大流量网站，采用什么方法来解决访问量的问题"><a href="#对于大流量网站，采用什么方法来解决访问量的问题" class="headerlink" title="对于大流量网站，采用什么方法来解决访问量的问题"></a>对于大流量网站，采用什么方法来解决访问量的问题</h3><pre><code>确认服务器硬件是否能够支持当前的流量数据库读写分离，优化数据表程序功能规则，禁止外部的盗链控制大文件的下载使用不同主机分流主要流量</code></pre><h3 id="语句include和require的区别是什么？为避免多次包含同一文件，可以用-语句代替他们"><a href="#语句include和require的区别是什么？为避免多次包含同一文件，可以用-语句代替他们" class="headerlink" title="语句include和require的区别是什么？为避免多次包含同一文件，可以用(?)语句代替他们"></a>语句include和require的区别是什么？为避免多次包含同一文件，可以用(?)语句代替他们</h3><pre><code>require是无条件包含，也就是如果一个流程里加入require，无论条件成立与否都会先执行require，当文件不存在或者无法打开的时候，会提示错误，并且会终止程序执行include有返回值，而require没有(可能因为如此require的速度比include快)，如果被包含的文件不存在的化，那么会提示一个错误，但是程序会继续执行下去注意:包含文件不存在或者语法错误的时候require是致命的，而include不是require_once表示了只包含一次，避免了重复包含</code></pre><h3 id="谈谈mvc的认识"><a href="#谈谈mvc的认识" class="headerlink" title="谈谈mvc的认识"></a>谈谈mvc的认识</h3><pre><code>由模型、视图、控制器完成的应用程序，由模型发出要实现的功能到控制器，控制器接收组织功能传递给视图</code></pre><h3 id="说明php中传值与传引用的区别，并说明传值什么时候传引用？"><a href="#说明php中传值与传引用的区别，并说明传值什么时候传引用？" class="headerlink" title="说明php中传值与传引用的区别，并说明传值什么时候传引用？"></a>说明php中传值与传引用的区别，并说明传值什么时候传引用？</h3><pre><code>变量默认总是传值赋值，那也就是说，当将一个表达式的值赋予一个变量时，整个表达式的值被赋值到目标变量，这意味着：当一个变量的赋予另外一个变量时，改变其中一个变量的值，将不会影响到另外一个变量</code></pre><p>php也提供了另外一种方式给变量赋值：引用赋值。这意味着新的变量简单的<strong>引用</strong>(换言之，成为了其别名或者指向)了原始变量。改动的新的变量将影响到原始变量，反之亦然。使用引用赋值，简单地将一个&amp;符号加到将要赋值的变量前(源变量)</p><pre><code>对象默认是传引用对于较大是的数据，传引用比较好，这样可以节省内存的开销</code></pre>]]></content>
    
    <summary type="html">
    
      文件处理在PHP开发中也是比较常见的，或者你使用的是缓存，但是毕竟根据需求总有用到文件的地方，所以.....
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="PHP经典面试一" scheme="https://icocos.github.io/tags/PHP%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E4%B8%80/"/>
    
  </entry>
  
  <entry>
    <title>PHP——接口设计规范</title>
    <link href="https://icocos.github.io/2018/12/25/PHP%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"/>
    <id>https://icocos.github.io/2018/12/25/PHP——接口设计规范/</id>
    <published>2018-12-25T15:26:01.000Z</published>
    <updated>2018-12-28T02:51:24.360Z</updated>
    
    <content type="html"><![CDATA[<p>任何事情都有规律可行，也有一定的规范性，但是认识或的，规范是死的，能够灵活应用就够了。比如iOS，Android，前段等等一些开发过程中都会有一些规范可寻，按照一定的规范写出来的东西能够更容易迭代与修复问题，更容易给后面的人接手……</p><h2 id="接口设计规范"><a href="#接口设计规范" class="headerlink" title="接口设计规范"></a>接口设计规范</h2><p>这里大概整理了一下APP开发接口的一些规范，我们可以根据实际开发，实际需求做相应的调整。</p><h3 id="1-制定规范"><a href="#1-制定规范" class="headerlink" title="1.制定规范"></a>1.制定规范</h3><pre><code>开发前一定要定好一个规范，比如要定好数据返回的通用参数和格式。关于数据格式，用的比较多的有xml和json，我建议用json，因为json比xml的好处更多。</code></pre><h3 id="2-精简的返回数据"><a href="#2-精简的返回数据" class="headerlink" title="2.精简的返回数据"></a>2.精简的返回数据</h3><pre><code>接口数据因符合需要什么返回什么的原则，比如要查询某个用户的余额和注册时间，网页里面的做法可能是select * from user where uid=1，但是接口一定要select balance,regtime from user where uid=1。因为接口返回数据是要有开销的，要流量的，能少返回数据就尽量少返回，这样可以大大的提高性能。</code></pre><h3 id="3-数据类型要严格"><a href="#3-数据类型要严格" class="headerlink" title="3.数据类型要严格"></a>3.数据类型要严格</h3><pre><code>要注意数据的类型，整数类型的数据一定要转为int，因为app客户端开发的java、object-c语言对数据类型比较严格，类型不对会照成app闪退。</code></pre><h3 id="4-要写接口文档"><a href="#4-要写接口文档" class="headerlink" title="4.要写接口文档"></a>4.要写接口文档</h3><pre><code>一定要写好接口文档，并按照模块写，而且还要书写规范，最好的格式是：接口请求地址；    请求参数（包括参数名、类型、是否必填）；    测试参数举例；返回参数（参数名，并注明每个参数的含义）。这样哪怕以后项目很大，以不会照成维护困难的问题。</code></pre><h3 id="5-保证代码正确性"><a href="#5-保证代码正确性" class="headerlink" title="5.保证代码正确性"></a>5.保证代码正确性</h3><pre><code>要验证保证代码正确无误，而且生成环境中要屏蔽掉错误，避免头部有额外的输出，照成返回的json等数据解析失败而导致app闪退等。</code></pre><h3 id="6-要优化代码的性能"><a href="#6-要优化代码的性能" class="headerlink" title="6.要优化代码的性能"></a>6.要优化代码的性能</h3><pre><code>app要求响应迅速，这样才能给用户比较好的体验感。所以移动接口端在处理业务逻辑的时候，要避免不要执行太复杂的sql语句，或者含有大量的循环，能做成缓存的尽量做缓存，比如将首页的热点模块信息可以存到redis缓存中。在不考虑网速的情况下，比较理想的接口响应时间应该是200毫秒以内。</code></pre><h3 id="7-不要随意更改旧接口"><a href="#7-不要随意更改旧接口" class="headerlink" title="7.不要随意更改旧接口"></a>7.不要随意更改旧接口</h3><pre><code>app不像网页，app一旦发布，有人使用之后，接口就不要乱修改了。   以后升级也是，修改要在保证接口原有结构之上进行额外的扩展，否则会导致调用旧版接口的app出现bug。</code></pre><h3 id="8-注意接口的安全"><a href="#8-注意接口的安全" class="headerlink" title="8. 注意接口的安全"></a>8. 注意接口的安全</h3><pre><code>安全高于一切，必须要保证接口的安全。电话号码等敏感信息在传输的过程中一定要加密，否则可能会被别人抓包到。拿取用户信息的接口一定要验证权限，以防止接口被恶意调用，泄密用户信息，甚至篡改信息。</code></pre><blockquote><p>处于安全考虑，应当在传值的时候加个验证字段，比如…?token=wedwdwfwf,将token值进行判断后再决定是否给予返回值，你还可以参考一下微信的借口，给用户提供了一个appid和appkey，token值需要根据这两个值去获取，并且获取到的token2小时的有效期，从很大程度上提高了安全性。</p></blockquote><p>希望对你实际开发中有用！！！</p>]]></content>
    
    <summary type="html">
    
      任何事情都有规律可行，也有一定的规范性，但是认识或的，规范是死的，能够灵活应用就够了。比如iOS，Android，前段等等一些开发过程中都会有一些规范可寻，按照一定的规范写出来的东西能够更容易迭代与修复问题，更容易给后面的人接手......
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="接口设计规范" scheme="https://icocos.github.io/tags/%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>PHP——服务器500错误总结</title>
    <link href="https://icocos.github.io/2018/12/25/PHP%E2%80%94%E2%80%94%E6%9C%8D%E5%8A%A1%E5%99%A8500%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/"/>
    <id>https://icocos.github.io/2018/12/25/PHP——服务器500错误总结/</id>
    <published>2018-12-25T13:57:45.000Z</published>
    <updated>2018-12-28T02:51:28.151Z</updated>
    
    <content type="html"><![CDATA[<p>之前做客户端开发的时候，经常出现500错误，当时能做的就是告诉后台：某某api出现了500，然后没有几分钟就好了。而且一个项目下来出现最多次数的也就是500……</p><h2 id="500错误"><a href="#500错误" class="headerlink" title="500错误"></a>500错误</h2><p>接触了服务器开发之后，自己在写一些简单接口的时候，也总是发现500，而且几乎所有的500都不是一样原因导致，所以就找了一些教程，并请教了有些大神，自己在接口开发中也掌握了不少相关了技巧。</p><p>如果你在学习或者开发中也遇到了，比较奇葩500错误，可以联系我，我们一起交流讨论，一并整理出来。</p><pre><code>出现500错误的原因是很多的，一般来说，如果程序出错，那么在浏览器内会返回给用户一个友好的错误提示，统一称之为服务器500错误。 解决的方法就是您必须在http中能够正确的获得错误信息，方法为：请打开浏览器，选择工具，internet选项，高级，在高级中的浏览项目里面有一个\&quot;显示http友好错误提示\&quot;的复选框，请取消该复选框，这样您可以获得正确的错误提示。 在获得正确的错误提示之后，您就可以根据该错误提示检查您具体的出错原因了</code></pre><p>HTTP 500错误一定是你的PHP代码有错误，PHP解释器执行不了。两个方法找错误</p><pre><code>1) 用有语法检查提示的编辑器，比如Eclipse打开你的文件看看有没有错误提示，注意require里面的文件也要检查2) 加error_log(&quot;error_message&quot;, 3, &quot;log.txt&quot;);在你想输出信息的地方，用这种方式找代码哪句有问题。</code></pre><p>当我我们一定时常注意log的日志，因为大部分错误或者异常在log都能清楚，或者通过分析找到问题所在并解决</p><pre><code>1 先看nginx error.log 指定的错误日记文件路径 找到这个日记文件看 里面信息2 再看  php-fpm.conf 里面指定的PHP错误日记的路径</code></pre><h3 id="具体如下"><a href="#具体如下" class="headerlink" title="具体如下"></a>具体如下</h3><pre><code>php_flag[display_errors] = offphp_admin_flag[log_errors] = onphp_admin_value[error_log] = /data/logs/fpm-php.log</code></pre><h3 id="在网上找到一段话，这是在windows上开发的时候出现的问题及解决方案，当然Mac上也差不多"><a href="#在网上找到一段话，这是在windows上开发的时候出现的问题及解决方案，当然Mac上也差不多" class="headerlink" title="在网上找到一段话，这是在windows上开发的时候出现的问题及解决方案，当然Mac上也差不多"></a>在网上找到一段话，这是在windows上开发的时候出现的问题及解决方案，当然Mac上也差不多</h3><pre><code>1、运行的用户数过多，对服务器造成的压力过大，服务器无法响应，则报HTTP500错误。减小用户数或者场景持续时间，问题得到解决。2、该做关联的地方没有去做关联，则报HTTP500错误。进行手工或者自动关联，问题得到解决。3、录制时请求的页面、图片等，在回放的时候服务器找不到，则报HTTP500错误，若该页面无关紧要，则可以在脚本中注释掉，问题将会得到解决。例如：有验证码的情况下，尽管测试时已经屏蔽了，但是录制的时候提交了请求，但回放的时候不存在响应。4、参数化时的取值有问题，则报HTTP500错误。可将参数化列表中的数值，拿到实际应用系统中进行测试，可排除问题。5、更换了应用服务器（中间件的更换，如tomcat、websphere、jboss等），还是利用原先录制的脚本去运行，则很可能报HTTP500错误。因为各种应用服务器处理的机制不一样，所录制的脚本也不一样，解决办法只有重新录制脚本。6、Windowsxp2 与ISS组件不兼容，则有可能导致HTTP500错误。对ISS组件进行调整后问题解决。7、系统开发程序写的有问题，则报HTTP500错误。例如有些指针问题没有处理好的，有空指针情况的存在。修改程序后问题解决。8、如果测试中所进行的操作涉及到数据库，如插入数据操作，若大数据量的情况下导致数据库中表空间已满，或者数据库连接池较小无法满足数据的存取等，都有可能导致HTTP500错误。调整数据库、修改连接池大小，问题解决。</code></pre><h2 id="下面是某教程网站上在Nginx上出现的一个棘手的500错误。。"><a href="#下面是某教程网站上在Nginx上出现的一个棘手的500错误。。" class="headerlink" title="下面是某教程网站上在Nginx上出现的一个棘手的500错误。。"></a>下面是某教程网站上在Nginx上出现的一个棘手的500错误。。</h2><p>原文地址：<a href="https://www.phpxy.com/article/109.html" target="_blank" rel="noopener">https://www.phpxy.com/article/109.html</a></p><h3 id="产生原因："><a href="#产生原因：" class="headerlink" title="产生原因："></a>产生原因：</h3><pre><code>恢复aliyun阿里云的镜像，发现不论如何访问服务器都提示500</code></pre><h3 id="出现了问500错误，第一件事情要处理的是查看日志。"><a href="#出现了问500错误，第一件事情要处理的是查看日志。" class="headerlink" title="出现了问500错误，第一件事情要处理的是查看日志。"></a>出现了问500错误，第一件事情要处理的是查看日志。</h3><pre><code>1. 日志系统是否记录了日志2. 发现日志系统未记录日志，所以说不好去发现问题。3. 解决nginx未记录日志的问题，在/usr/local/nginx/conf/vhost/ uluqu.com.conf下增加error_log选项指定至目录4. 发现nginx无法启动，错误提示 /var/log/nginx 目录未存在5.使用mkdir 创建/var/log/nginx 目录6. 重新启动nginx,php-fpm等，发现解决成功7. 打开错误日志目录，发现日志已生成8.访问 www.uluqu.com/index.php 和phpinfo.php 页面，查看日志中记录的两项错误9. 错误提醒分别为php parse error define错误，第二个是发现 memory allowed limit 类的错误。分析原因是内存不足或者未合理管理内存造的。10. 清理服务器内存 free -m 然后执行echo 1 &gt; /proc/sys/vm/drop_caches11. 再次判断可能因为php.ini文件出错，解决办法：修改php.ini中的memroy_limit参数12. 经查发现memroy_limit 这个参数写的是512而不是512M。修改参数，重启相关服务。13. 访问地址问题解决</code></pre><p>在运行PHP程序，通常会遇到“Fatal Error： Allowed memory size of xxxxxx bytes exhausted”的错误， 这个意味着PHP脚本使用了过多的内存，并超出了系统对其设置的允许最大内存。</p><blockquote><p>解决这个问题，首先需要查看你的程序是否分配了过多的内存，在程序没有问题的情况下，你可以通过一下方法来增加PHP的内存限制（memory_limit）。</p></blockquote><h3 id="检查php的内存限制值"><a href="#检查php的内存限制值" class="headerlink" title="检查php的内存限制值"></a>检查php的内存限制值</h3><pre><code>为了查看这个值，你需要建立一个空的php文件，比如view-php-info.php。然后将一下代码贴到里面。</code></pre><h3 id="memory-limit应该设为多少？"><a href="#memory-limit应该设为多少？" class="headerlink" title="memory_limit应该设为多少？"></a>memory_limit应该设为多少？</h3><pre><code>这个完全依赖于你的应用的要求。比如Wordpress，运行起核心代码需要32MB。Drupal 6则要求这个值最小为16MB，并推荐设置为32MB。如果你又安装不少的插件（plugins），尤其是那些要进行图像处理的模块，那么你可能需要128MB或更高的内存。</code></pre><h2 id="方法1：-php-ini"><a href="#方法1：-php-ini" class="headerlink" title="方法1： php.ini"></a>方法1： php.ini</h2><p>最简单或常用的方法是修改php.ini</p><h3 id="1-首先找到对你的网站生效的php-ini文件-由于有多个地方都可以设置php的参数，找到正确的配置文件，并进行更改是首先要做的一步。"><a href="#1-首先找到对你的网站生效的php-ini文件-由于有多个地方都可以设置php的参数，找到正确的配置文件，并进行更改是首先要做的一步。" class="headerlink" title="1.首先找到对你的网站生效的php.ini文件 由于有多个地方都可以设置php的参数，找到正确的配置文件，并进行更改是首先要做的一步。"></a>1.首先找到对你的网站生效的php.ini文件 由于有多个地方都可以设置php的参数，找到正确的配置文件，并进行更改是首先要做的一步。</h3><pre><code>对于Linux用户，你可以通过执行“php -i | grep Loaded Configuration File”来找到对应的配置文件。而Windows用户，你可以尝试修改你的php安装目录下的php.ini。</code></pre><h3 id="2-编辑php-ini-在php-ini中，找到“memory-limit”这一项，如果没有，你可以在文件的尾部自己增加这个参数。以下是一些设置范例"><a href="#2-编辑php-ini-在php-ini中，找到“memory-limit”这一项，如果没有，你可以在文件的尾部自己增加这个参数。以下是一些设置范例" class="headerlink" title="2.编辑php.ini 在php.ini中，找到“memory_limit”这一项，如果没有，你可以在文件的尾部自己增加这个参数。以下是一些设置范例"></a>2.编辑php.ini 在php.ini中，找到“memory_limit”这一项，如果没有，你可以在文件的尾部自己增加这个参数。以下是一些设置范例</h3><pre><code>memory_limit = 128M ; 可以将128M改为任何你想设置的值,保存文件</code></pre><h3 id="3-重启web-服务器-如果是web服务器使用Apache，-则执行："><a href="#3-重启web-服务器-如果是web服务器使用Apache，-则执行：" class="headerlink" title="3.重启web 服务器 如果是web服务器使用Apache， 则执行："></a>3.重启web 服务器 如果是web服务器使用Apache， 则执行：</h3><pre><code>httpd restart</code></pre><p>有些情况下，你可能不被允许私修改php.ini。比如如果你购买了虚拟主机服务，但是你的服务商确禁止你修改这个文件。那么，你可以需要考虑用其他方法来增加memory_limit的值。</p><h2 id="方法2：-htaccess"><a href="#方法2：-htaccess" class="headerlink" title="方法2： .htaccess"></a>方法2： .htaccess</h2><p>说明： 这种方法只有在php以Apache模块来执行时才生效。 在你的网站的根目录下找到“.htaccess”文件，如果没有，可以自己创建一个。然后把以下配置放入其中</p><pre><code>php_value memory_limit 128M ; 可以将128M改为任何你想设置的值</code></pre><h2 id="方法3：-运行时修改php的内存设置"><a href="#方法3：-运行时修改php的内存设置" class="headerlink" title="方法3： 运行时修改php的内存设置"></a>方法3： 运行时修改php的内存设置</h2><h3 id="在你的php代码中增加以下命令行即可。"><a href="#在你的php代码中增加以下命令行即可。" class="headerlink" title="在你的php代码中增加以下命令行即可。"></a>在你的php代码中增加以下命令行即可。</h3><pre><code>ini_set(&apos;memory_limit&apos;,&apos;128M&apos;);</code></pre><h3 id="memory-limit修改失败"><a href="#memory-limit修改失败" class="headerlink" title="memory_limit修改失败"></a>memory_limit修改失败</h3><pre><code>如果你使用虚拟主机，有可能会出现memory_limit的值修改失败。这个需要联系你的服务商看怎么处理，通常他们限制了可以设置的最大值或者根本就不允许你修改。如果他们的环境真的无法满足你的要求，那么你可能要考虑换一个主机服务商。</code></pre><h2 id="生产环境下故障处理一例"><a href="#生产环境下故障处理一例" class="headerlink" title="生产环境下故障处理一例"></a>生产环境下故障处理一例</h2><h3 id="现象说明："><a href="#现象说明：" class="headerlink" title="现象说明："></a>现象说明：</h3><pre><code>生产环境下，storage服务器上没有安装任何服务（如apache，nginx，IIS等）现在是纯命令行执行PHP跑PHP脚本，在脚本的执行过程中发现（脚本内容含每次取5000个文件然后执行其它操作）速度奇慢，在本地测试时分分钟内搞定的事，在线上要执行2个多小时，经过排查排除掉服务器负载问题、数据库问题、服务器网络问题后，认为可能是php.ini配置文件中的资源限制所引起，于是修改了一下memory_limit将默认值128M修改为1024M后再次执行原脚本，速度得到大幅度提升，现把此参数的含义说明一下。</code></pre><h3 id="修改后需不需要重启？"><a href="#修改后需不需要重启？" class="headerlink" title="修改后需不需要重启？"></a>修改后需不需要重启？</h3><pre><code>因为PHP没有守护进程一说，理论上你只要修改过以后，就会立即使用新的配置文件。</code></pre><h3 id="此值设置多大为好？"><a href="#此值设置多大为好？" class="headerlink" title="此值设置多大为好？"></a>此值设置多大为好？</h3><pre><code>建议根据应用需求来设置。物理服务器，如果内存够大的话建议限制内存较大一些如512M，1024M都可，如果是VPS之类的可能限制在128（默认）64M或者以下是比较合适的，特别是有web服务器的时候，一旦开启多个php的fast-cgi，估计服务器都卡的不动了。</code></pre><h3 id="参数语法"><a href="#参数语法" class="headerlink" title="参数语法"></a>参数语法</h3><pre><code>memory_limit integer</code></pre><p>本指令设定了一个脚本所能够申请到的最大内存字节数。</p><h3 id="指令作用"><a href="#指令作用" class="headerlink" title="指令作用"></a>指令作用</h3><pre><code>这有助于防止写得不好的脚本消耗光服务器上的可用内存。</code></pre><h3 id="在phpchina的论坛上，有人这样说："><a href="#在phpchina的论坛上，有人这样说：" class="headerlink" title="在phpchina的论坛上，有人这样说："></a>在phpchina的论坛上，有人这样说：</h3><pre><code>memory_limit是设置PHP使用内存时空间，一般设置为内存的四分之一，应该就差不多了。如512M内存设置128M,1G内存设置256M。</code></pre><p>设置太大会影响系统速度，因为系统和数据库及其他程序同样需要内存空间，一般系统和数据库内存空间是自己分配的。</p><h2 id="附三种修改方法"><a href="#附三种修改方法" class="headerlink" title="附三种修改方法"></a>附三种修改方法</h2><p>可能是分词程序的问题。只要搜索的字段达到十个汉字以上，就会出现诸如以下的错误</p><pre><code>Fatal error: Allowed memory size of 2345643 bytes exhausted</code></pre><p>上网找了方法。有3种办法。</p><h3 id="1-直接修改PHP-INI"><a href="#1-直接修改PHP-INI" class="headerlink" title="1.直接修改PHP.INI"></a>1.直接修改PHP.INI</h3><pre><code>memory_limit = 16M  ;</code></pre><p>但是我修改了没有用。据说是要重启服务器的。但是很显然。我的 是虚拟主机。所以有独立主机的可以这样修改。</p><h3 id="2-修改-htaccess"><a href="#2-修改-htaccess" class="headerlink" title="2.修改.htaccess"></a>2.修改.htaccess</h3><pre><code>php_value memory_limit 16M</code></pre><p>修改后直接出现500错误。可能是主机商限制</p><h3 id="3-直接在程序页面上修改。"><a href="#3-直接在程序页面上修改。" class="headerlink" title="3.直接在程序页面上修改。"></a>3.直接在程序页面上修改。</h3><pre><code>ini_set(’memory_limit’, ‘16M‘);</code></pre>]]></content>
    
    <summary type="html">
    
      之前做客户端开发的时候，经常出现500错误，当时能做的就是告诉后台：某某api出现了500，然后没有几分钟就好了。而且一个项目下来出现最多次数的也就是500......
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="500错误" scheme="https://icocos.github.io/tags/500%E9%94%99%E8%AF%AF/"/>
    
  </entry>
  
  <entry>
    <title>PHP——APP接口是怎么来的？</title>
    <link href="https://icocos.github.io/2018/12/23/PHP%E2%80%94%E2%80%94APP%E6%8E%A5%E5%8F%A3%E6%98%AF%E6%80%8E%E4%B9%88%E6%9D%A5%E7%9A%84%EF%BC%9F/"/>
    <id>https://icocos.github.io/2018/12/23/PHP——APP接口是怎么来的？/</id>
    <published>2018-12-23T12:34:42.000Z</published>
    <updated>2018-12-28T02:51:33.206Z</updated>
    
    <content type="html"><![CDATA[<p>学了差不多一个月的PHP，总想找个机会试试手，因为工作的原因每天能抽出来的时间真心少，这两天就开始在进行真正的PHP接口开发学习了，到今天为止，我终于知道我做iOS开发的时候发送请求返回的数据是这么来的…… </p><h2 id="APP接口"><a href="#APP接口" class="headerlink" title="APP接口"></a>APP接口</h2><p>PHP开发APP接口</p><h2 id="APP接口开发"><a href="#APP接口开发" class="headerlink" title="APP接口开发"></a>APP接口开发</h2><ol><li>APP接口简介</li><li>封装通讯接口方法</li><li>核心技术</li><li>APP接口实例</li></ol><p>接口请求流程</p><p>客户端-发送GET/POST请求-服务端-数据库/缓存-调用APP接口-客户端 </p><h2 id="APP接口简介"><a href="#APP接口简介" class="headerlink" title="APP接口简介"></a>APP接口简介</h2><ol><li>接口地址(url) ==== 函数名</li><li>GET或POST数据 ==== 函数的参数</li><li>这个接口输出的数据 ===== 函数的返回值</li></ol><p>API概述</p><pre><code>1、API 比开发 WEB 更简洁，但可能逻辑更复杂，API 只返回结果，也就是只完成数据输出，不呈现页面，2、WEB 开发，更多的是 GET 和 POST 请求，API 还有 PUT、DELETE 请求3、和 WEB 开发一样，首先需要一些相关的参数，这些参数，都会由客户端传过来，也许是 GET 也许是 POST，这个需要开发团队相互之间约定好，或者制定统一规范4、有了参数，根据应用需求，完成数据处理，例如：获取用户信息、发朋友圈、发消息、一局游戏结束数据提交等等5、数据逻辑处理完之后，返回客户端所需要用到的相关数据，例如：用户信息数组、朋友圈列表、消息状态、游戏结果数据等等，那数据是怎么返给客户端呢？常见有XML、JSON，设置相应的header并把要返回的数据直接打印出来即可6、客户端获取到你返回的数据后，在客户端本地和用户进行交互</code></pre><h3 id="APP接口介绍"><a href="#APP接口介绍" class="headerlink" title="APP接口介绍"></a>APP接口介绍</h3><p>首先要区别去面向对象中的接口</p><p>面向对象中的接口是一个抽象类，如PHP或者java中使用interface，iOS中使用的@interface，这里起到的是一个标准或者规范，适合多人开发使用。</p><p>APP中的接口：是指数据接口</p><p>APP发送HTTP请求，服务器根据请求的参数返回对应的接口数据，客户端解析数据并显示，客户端并不需要关心接口数据是这么实现的，这么返回的，只要发送请求根据返回的数据解析使用就可以！</p><blockquote><p>接口：包括接口地址，接口文件，接口数据</p></blockquote><h3 id="如何进行通讯"><a href="#如何进行通讯" class="headerlink" title="如何进行通讯"></a>如何进行通讯</h3><ol><li><p>-&gt;需要有一个客户端APP</p></li><li><p>-&gt;触发客户端APP的时候</p></li><li><p>-&gt;发送HTTP对应的地址GET/POST请求</p></li><li><p>-&gt;发送给服务端</p></li><li><p>-&gt;服务端收到接口请求之后会做相应的处理</p></li><li><p>-&gt;比如从数据库/缓存读取对应的数据</p></li><li><p>-&gt;返回给客户端</p></li><li><p>-&gt;客户端收到服务器返回的数据</p></li><li><p>-&gt;开始解析成自己想要的格式（XML、JSON）</p></li><li><p>-&gt;显示到界面上 </p></li></ol><h3 id="通讯格式区别"><a href="#通讯格式区别" class="headerlink" title="通讯格式区别"></a>通讯格式区别</h3><p>JSON的定义</p><pre><code>一种轻量级的数据交换格式，具有良好的可读和便于快速编写的特性。业内主流技术为其提供了完整的解决方案（有点类似于正则表达式 ，获得了当今大部分语言的支持），从而可以在不同平台间进行数据交换。JSON采用兼容性很高的文本格式，同时也具备类似于C语言体系的行为。</code></pre><p>XML的定义</p><pre><code>扩展标记语言 (Extensible Markup Language,XML) ，用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。 XML是标准通用标记语言 (SGML) 的子集，非常适合 Web 传输。XML 提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据。</code></pre><p>XML优缺点</p><p>缺点</p><pre><code>1. 格式统一, 符合标准2. 容易与其他系统进行远程交互, 数据共享比较方便</code></pre><p>缺点:</p><pre><code>1. XML文件格式文件庞大, 格式复杂, 传输占用带宽2. 服务器端和客户端都需要花费大量代码来解析XML, 不论服务器端和客户端代码变的异常复杂和不容易维护3. 客户端不同浏览器之间解析XML的方式不一致, 需要重复编写很多代码4. 服务器端和客户端解析XML花费资源和时间</code></pre><p>JSON优缺点</p><pre><code>那么除了XML格式, 还有没有其他格式, 有一种叫做JSON(JavaScript Object Notation) 的轻量级数据交换格式能够替代XML的工作.</code></pre><p>优点:</p><pre><code>1. 数据格式比较简单, 易于读写, 格式都是压缩的, 占用带宽小2. 易于解析这种语言, 客户端JavaScript可以简单的通过eval_r()进行JSON数据的读取3. 支持多种语言, 包括ActionScript, C, C#, ColdFusion, Java,JavaScript, Perl, PHP, Python, Ruby等语言服务器端语言, 便于服务器端的解析4. 在PHP世界, 已经有PHP-JSON和JSON-PHP出现了, 便于PHP序列化后的程序直接调用. PHP服务器端的对象、数组等能够直接生JSON格式, 便于客户端的访问提取.5. 因为JSON格式能够直接为服务器端代码使用, 大大简化了服务器端和客户端的代码开发量, 但是完成的任务不变, 且易于维护</code></pre><p>缺点:</p><pre><code>1. 没有XML格式这么推广的深入人心和使用广泛, 没有XML那么通用性2. JSON格式目前在Web Service中推广还属于初级阶段</code></pre><p>JSON 和 XML 优缺点的比较</p><pre><code>1. 在可读性方面，JSON和XML的数据可读性基本相同。JSON和XML的可读性可谓不相上下，一边是建议的语法，一边是规范的标签形式，很难分出胜负。2. 在可扩展性方面，XML天生有很好的扩展性，JSON当然也有，没有什么是XML能扩展，JSON不能的。3. 在编码难度方面，XML有丰富的编码工具，比如Dom4j、JDom等，JSON也有json.org提供的工具，但是JSON的编码明显比XML容易许多，即使不借助工具也能写出JSON的代码，可是要写好XML就不太容易了。4. 在解码难度方面，XML的解析得考虑子节点父节点，让人头昏眼花，而JSON的解析难度几乎为0。这一点XML输的真是没话说。5. 在流行度方面，XML已经被业界广泛的使用，而JSON才刚刚开始，但是在Ajax这个特定的领域，未来的发展一定是XML让位于JSON。到时Ajax应该变成Ajaj(AsynchronousJavascript and JSON)了。6. JSON和XML同样拥有丰富的解析手段。7. JSON相对于XML来讲，数据的体积小。8. JSON与JavaScript的交互更加方便。9. JSON对数据的描述性比XML较差。10. JSON的速度要远远快于XML。</code></pre><ul><li>protocol buffer</li></ul><p>现在还有一种据说是比较流行，但是目前还没有PHP的API，叫做protocol buffer</p><pre><code>protocol buffer是google的一个开源项目,它是用于结构化数据串行化的灵活、高效、自动的方法，例如XML，不过它比xml更小、更快、也更简单。你可以定义自己的数据结构，然后使用代码生成器生成的代码来读写这个数据结构。你甚至可以在无需重新部署程序的情况下更新数据结构。</code></pre><p>对于protocol buffer网上确实有不少好评，但是目前只有C++，java，python的API，希望以后有机会能试一试效果。</p><h3 id="APP接口做的那些事"><a href="#APP接口做的那些事" class="headerlink" title="APP接口做的那些事"></a>APP接口做的那些事</h3><p>获取数据：从数据库中或者缓存中获取数据，然后通过接口数据返回给客户端<br>提交数据：通过接口提交数据给服务器。然后服务器入库处理，或者其他处理</p><p>获取数据：GET请求</p><pre><code>界面显示数据，首页，广场，用户信息......</code></pre><p>提交数据：POST请求</p><pre><code>提交反馈，注册登录，修改用户信息......</code></pre><h2 id="封装通讯接口方法"><a href="#封装通讯接口方法" class="headerlink" title="封装通讯接口方法"></a>封装通讯接口方法</h2><h3 id="JSON方式封装通讯接口"><a href="#JSON方式封装通讯接口" class="headerlink" title="JSON方式封装通讯接口"></a>JSON方式封装通讯接口</h3><p>一. 生成JSON数据——数组方式</p><p>首先必须知道PHP生成接口数据的方法是json_encode($value),这个方法只能接口UTF-8编码数据，其他格式数据会返回null</p><p>首先我们定义一个简单的数组，然后使用json_encode方法将数组转成json数据</p><pre><code>$arrayName = array(&apos;id&apos; =&gt; 1,&apos;name&apos; =&gt; &apos;iCocos&apos;);echo $arrayName;echo json_encode($arrayName);</code></pre><p>浏览器输入对应的链接地址，答应结果</p><pre><code>ArrayArray{&quot;id&quot;:1,&quot;name&quot;:&quot;iCocos&quot;}</code></pre><p>当然如果你不是UTF8编码数据，可以使用字符编码之间转换函数iconv()，将对应的编码转成自己想要的编码</p><pre><code>iconv(&apos;原始编码&apos;,&apos;目标编码&apos;,&apos;数据变量&apos;)</code></pre><p>二. 通讯数据的标准格式</p><p>一般来说规范一点的后台开发人员都会有一套自己的标准</p><ul><li>code  状态吗（2XX-成功, 3XX重定向, 4XX客户端错误, 5XX服务器错误）</li><li>message 提示信息</li><li>data 返回数据<ul><li>id : 1</li><li>name : iCocos</li></ul></li></ul><p>如果你是做移动端的，到公司发现你们后台返回连这种标准都没有，哪怕是类似的，那么不用多说，建议还是闪人吧！</p><p>三. 下面我们简单的实战一下</p><p>首先定义一个工具类，用来把传递进来的数据和相应的信息转换成json，然后输出</p><p>定义一个PHPResponse.php文件，并且定义一个PHPResponse类，在类里面定义一个静态方法，并且简单的实现一些逻辑处理就进行转换输出</p><pre><code>&lt;?php/*** 相应类*/class PHPResponse{    //返回JSON数据方法    public static function jsonData($code, $message = &apos;&apos;, $data = array())    {        //如果code不是数字        if (!is_numeric($code)) {            # code...            return &apos;&apos;;        }        $res = array(            &apos;code&apos; =&gt; $code,            &apos;message&apos; =&gt; $message,            &apos;data&apos; =&gt; $data        );        echo var_dump($res);        //echo json_encode($res);        exit(); //exit;    }}</code></pre><p>因为这里只是简单的测试，所以在index.php中引入对应的文件，然后传递数据和对应的参数进上面的方法</p><pre><code>require_once(&apos;./PHPResponse.php&apos;);$arrRes = array(    &apos;id&apos; =&gt; 1,    &apos;name&apos; = &apos;iCocos&apos;);PHPResponse::jsonData(200, &apos;成功&apos;, $arrRes);</code></pre><p>浏览器输入对应的路径，就能看到真实的数据返回</p><pre><code>array(3) {     [&quot;code&quot;]=&gt; int(200)     [&quot;message&quot;]=&gt; string(6) &quot;成功&quot;     [&quot;data&quot;]=&gt; array(2) {         [&quot;id&quot;]=&gt; int(1)         [&quot;name&quot;]=&gt; string(6) &quot;iCocos&quot;     } }</code></pre><h3 id="生成XML数据"><a href="#生成XML数据" class="headerlink" title="生成XML数据"></a>生成XML数据</h3><ol><li><p>组装字符串</p></li><li><p>使用系统类</p><ul><li>DomDocument</li><li>XMLWrite</li><li>SimpleXML</li></ul></li></ol><p>这里使用字符串的方式，其实在学习iOS的时候就有了解过这一点：</p><pre><code>public static function xmlToEncode($data) {    $xml = &quot;&lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos;?&gt;\n&quot;;    $xml = &quot;&lt;root&gt;\n&quot;;    $xml = &quot;&lt;code&gt;200&lt;/code&gt;\n&quot;;    $xml = &quot;&lt;message&gt;返回成功&lt;/message&gt;\n&quot;;    $xml = &quot;&lt;data&gt;\n&quot;;    $xml = &quot;&lt;id&gt;1&lt;/id&gt;\n&quot;;    $xml = &quot;&lt;name&gt;iCocos&lt;name&gt;\n&quot;;    $xml = &quot;&lt;/data&gt;\n&quot;;    $xml = &quot;&lt;/root&gt;\n&quot;;    echo $xml;}</code></pre><blockquote><p>注意：xml节点不能使用数字</p></blockquote><p>浏览器输入后测试显示就是平时我们看到的xml数据格式</p><pre><code>&lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos;?&gt;&lt;root&gt;    &lt;code&gt;200&lt;/code&gt;    &lt;message&gt;返回成功&lt;/message&gt;    &lt;data&gt;        &lt;id&gt;1&lt;/id&gt;        &lt;name&gt;iCocos&lt;name&gt;    &lt;/data&gt;&lt;/root&gt;</code></pre><p>当然可能你直接看到的是这样的，这是因为浏览器自动帮我们解析,属于来说就是Content-Type:text/html,而我们需要显示的是Content-Type:text/xml，只要右键查看源码就可以查看</p><pre><code>200 返回成功 1 iCocos</code></pre><p>如果想要显示的时候就自动解析成xml，只要调用对应的php方法就可以</p><pre><code>heaer(&quot;Content-Type:text/xml&quot;);</code></pre><h3 id="XML方式封装通讯数据方法：响应的格式和json是一样的"><a href="#XML方式封装通讯数据方法：响应的格式和json是一样的" class="headerlink" title="XML方式封装通讯数据方法：响应的格式和json是一样的"></a>XML方式封装通讯数据方法：响应的格式和json是一样的</h3><p>XML方式其实现在来讲的话使用并不高，我经历了几家公司都使用的json，但是作为php开发也是必须要会。</p><p>首先定义一个工具类，用来把传递进来的数据和相应的信息转换成xml，然后输出</p><p>定义一个PHPResponse.php文件，并且定义一个PHPResponse类，在类里面定义一个静态方法，并且简单的实现一些逻辑处理就进行转换输出</p><pre><code>/*** 按xml方式输出通信数据* @param integer $code 状态码* @param string $message 提示信息* @param array $data 数据* return string*/public static function xmlEncode($code, $message, $data = array()) {    if(!is_numeric($code)) {        return &apos;&apos;;    }    $result = array(        &apos;code&apos; =&gt; $code,        &apos;message&apos; =&gt; $message,        &apos;data&apos; =&gt; $data,    );    header(&quot;Content-Type:text/xml&quot;);    $xml = &quot;&lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos;?&gt;\n&quot;;    $xml .= &quot;&lt;root&gt;\n&quot;;    $xml .= self::xmlToEncode($result);    $xml .= &quot;&lt;/root&gt;&quot;;    echo $xml;}</code></pre><p>解析数组，返回xml数据</p><pre><code>public static function xmlToEncode($data) {    $xml = $attr = &quot;&quot;;    foreach($data as $key =&gt; $value) {        if(is_numeric($key)) {        $attr = &quot; id=&apos;{$key}&apos;&quot;;        $key = &quot;item&quot;;    }    $xml .= &quot;&lt;{$key}{$attr}&gt;&quot;;    $xml .= is_array($value) ? self::xmlToEncode($value) : $value; //如果value是数组就循环便利执行这个方法    $xml .= &quot;&lt;/{$key}&gt;\n&quot;;    }    return $xml;}</code></pre><p>调用</p><pre><code>$arrayName = array(    &apos;id&apos; =&gt; 1,    &apos;name&apos; =&gt; &apos;iCocos&apos;);</code></pre><p>PHPResponse::xmlEncode(200,’success’,$arrayName);</p><p>输入浏览器测试地址可以看到</p><pre><code>&lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos;?&gt;&lt;root&gt;    &lt;code&gt;200&lt;/code&gt;    &lt;message&gt;返回成功&lt;/message&gt;    &lt;data&gt;        &lt;id&gt;1&lt;/id&gt;        &lt;name&gt;iCocos&lt;name&gt;    &lt;/data&gt;&lt;/root&gt;</code></pre><p>这里如果实际开发坑定没有这么简单，但是复杂的地方也就是数组比较多数组，或分层</p><blockquote><p>到上面位置就可以实现平时开发中最最最简单的接口数据。</p></blockquote><h3 id="综合方式封装通讯数据方法"><a href="#综合方式封装通讯数据方法" class="headerlink" title="综合方式封装通讯数据方法"></a>综合方式封装通讯数据方法</h3><p>一：定义一个通用的接口文件，并且定义一个基类</p><pre><code>&lt;?php/*** 定义API抽象类*/abstract class Api {    const JSON = &apos;Json&apos;;    const XML = &apos;Xml&apos;;    const ARR = &apos;Array&apos;;    /**    * 定义工厂方法    * param string $type 返回数据类型    */    public static function factory($type = self::JSON) {        $type = isset($_GET[&apos;format&apos;]) ? $_GET[&apos;format&apos;] : $type;        $resultClass = ucwords($type);        require_once(&apos;./Response/&apos; . $type . &apos;.php&apos;);        return new $resultClass();    }    abstract function response($code, $message, $data);}</code></pre><p>二：XML数据解析与响应方法，继承自API</p><pre><code>&lt;?php/*** @author by singwa* @date*/class Xml extends Api {public function response($code, $message = &apos;&apos;, $data = array()) {    if(!is_numeric($code)) {        return &apos;&apos;;    }    $result = array(        &apos;code&apos; =&gt; $code,        &apos;message&apos; =&gt; $message,        &apos;data&apos; =&gt; $data    );    header(&apos;Content-Type:text/xml&apos;);        $xml = &quot;&lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos;?&gt;\n&quot;;        $xml .= &quot;&lt;root&gt;&quot;;        $xml .= self::xmlToEncode($result);        $xml .= &quot;&lt;/root&gt;&quot;;        echo $xml;    }    public static  function xmlToEncode($result) {        $xml = $attr = &apos;&apos;;        foreach($result as $key =&gt; $value) {            if(is_numeric($key)) {                $attr = &quot; id=&apos;&quot; . $key . &quot;&apos;&quot;;                $key = &quot;item&quot;;            }            $xml .= &quot;&lt;{$key}{$attr}&gt;&quot;;            $xml .= is_array($value) ? self::xmlToEncode($value) : $value;            $xml .= &quot;&lt;/{$key}&gt;\n&quot;;        }        return $xml;    }}</code></pre><p>三：JSON数据解析与响应方法，继承自API</p><pre><code>&lt;?php/*** 按xml方式输出通信数据*/class Json extends Api {public function response($code, $message = &apos;&apos;, $data = array()) {        if(!(is_numeric($code))) {            return &apos;&apos;;        }        $result = array(            &apos;code&apos; =&gt; $code,            &apos;message&apos; =&gt; $message,            &apos;data&apos; =&gt; $data        );        echo json_encode($result);        exit;    }}</code></pre><blockquote><p>是不是感觉json比xml简单很多，这也是为什么很多公司都使用的是json的原因。</p></blockquote><p>四：然后就是入口文件，通过入口文件调用方法，根据传入的类型解析成对应的格式，这也是前面讲到的面向对象的特性</p><pre><code>&lt;?phpclass Response {const JSON = &quot;json&quot;;/*** 按综合方式输出通信数据* @param integer $code 状态码* @param string $message 提示信息* @param array $data 数据* @param string $type 数据类型* return string*/public static function show($code, $message = &apos;&apos;, $data = array(), $type = self::JSON) {    if(!is_numeric($code)) {        return &apos;&apos;;    }    $type = isset($_GET[&apos;format&apos;]) ? $_GET[&apos;format&apos;] : self::JSON;    $result = array(        &apos;code&apos; =&gt; $code,        &apos;message&apos; =&gt; $message,        &apos;data&apos; =&gt; $data,    );    if($type == &apos;json&apos;) {        self::json($code, $message, $data);        exit;    } elseif($type == &apos;array&apos;) {        var_dump($result);    } elseif($type == &apos;xml&apos;) {        self::xmlEncode($code, $message, $data);        exit;    } else {        // TODO    }}/*** 按json方式输出通信数据* @param integer $code 状态码* @param string $message 提示信息* @param array $data 数据* return string*/public static function json($code, $message = &apos;&apos;, $data = array()) {    if(!is_numeric($code)) {        return &apos;&apos;;    }    $result = array(        &apos;code&apos; =&gt; $code,        &apos;message&apos; =&gt; $message,        &apos;data&apos; =&gt; $data    );    echo json_encode($result);    exit;}/*** 按xml方式输出通信数据* @param integer $code 状态码* @param string $message 提示信息* @param array $data 数据* return string*/public static function xmlEncode($code, $message, $data = array()) {    if(!is_numeric($code)) {        return &apos;&apos;;    }    $result = array(        &apos;code&apos; =&gt; $code,        &apos;message&apos; =&gt; $message,        &apos;data&apos; =&gt; $data,    );    header(&quot;Content-Type:text/xml&quot;);    $xml = &quot;&lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos;?&gt;\n&quot;;    $xml .= &quot;&lt;root&gt;\n&quot;;    $xml .= self::xmlToEncode($result);    $xml .= &quot;&lt;/root&gt;&quot;;    echo $xml;}public static function xmlToEncode($data) {    $xml = $attr = &quot;&quot;;    foreach($data as $key =&gt; $value) {        if(is_numeric($key)) {                $attr = &quot; id=&apos;{$key}&apos;&quot;;                $key = &quot;item&quot;;            }            $xml .= &quot;&lt;{$key}{$attr}&gt;&quot;;            $xml .= is_array($value) ? self::xmlToEncode($value) : $value;            $xml .= &quot;&lt;/{$key}&gt;\n&quot;;        }        return $xml;    }}</code></pre><p>五：最后就可以在浏览器输入对应的接口地址，传入对应的参数，就能得到想要的格式的数据</p><h2 id="说在最后，实际项目中，我们在开发-API-时应该注意的几个点（仅供参考）"><a href="#说在最后，实际项目中，我们在开发-API-时应该注意的几个点（仅供参考）" class="headerlink" title="说在最后，实际项目中，我们在开发 API 时应该注意的几个点（仅供参考）"></a>说在最后，实际项目中，我们在开发 API 时应该注意的几个点（仅供参考）</h2><pre><code>1、单文件实现多接口的形式有很多种，例如：if..elseif.. 或 switch 或 很多框架里用到的统一入口通过调用类函数的形式实现2、数据输出建议使用json，json具有很强的跨平台性，大多编程语言都支持json解析，json正在逐步取代xml，成为网络数据的通用格式3、为了保证接口安全，一定要加入鉴权体系4、对于线上的API，务必关闭所有错误显示，可以把错误写到日志里，PHP中，可以通过 error_reporting(0) 屏蔽所有错误这样做的目的，一方面是保护接口安全，防止输出不该打印的错误信息    另一方面是保证输出的是正确的数据格式，如json，假如不是标准的json格式，客户端在解析时就会出错，由此影响客户端的正常运转    PS：我们平时在使用手机APP时，手机会闪退，多半是这个原因，即接口调用异常5、开发 API 和 WEB 有一定的区别，如果是 WEB 的话，如果程序写的有问题，比如有个notice 或 warning 级别的错误，在 WEB 里可能不会有什么问题，也许就只是导致 WEB 的某个部分错位或乱码。但如果是 API，就会严重调用的客户端了，如果是手机APP，那闪推啥的，是必然的，如果同样也是Web调用，也可能会出现  Server Error 了6、一定要重点考虑稳定性和响应速度，因为我们在使用手机APP时，都不希望APP经常闪推、而且希望应用很流畅7、不要随便使用一些 PHP 开源框架，原因概括起来有两点：    1）如6所述，客户端一般对 API 响应速度有极高要求，目前PHP领域的开源框架非常多，根据笔者的了解，目前比较流行的框架，普遍做的比较重，而且基本都是为WEB而生，因此，框架多了很多 API 用不到的东西，框架在加载和执行冗余文件时，实际是在消耗你的性能    2）如4和5所述，框架对于WEB开发，是件很幸福的事，但对于 API 而言，你实在不敢想象它会给你出什么岔子，因为很多框架并没有全面的考虑到 API 场景</code></pre>]]></content>
    
    <summary type="html">
    
      学习PHP快要一个月了，总想找个机会试试手，因为工作的原因每天能抽出来的时间真心少，这两天就开始在进行真正的PHP接口开发学习了，到今天为止，我终于知道我做iOS开发的时候发送请求返回的数据是这么来的......
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="APP接口" scheme="https://icocos.github.io/tags/APP%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>PHP——核心技术之缓存</title>
    <link href="https://icocos.github.io/2018/12/20/PHP%E2%80%94%E2%80%94%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B9%8B%E7%BC%93%E5%AD%98/"/>
    <id>https://icocos.github.io/2018/12/20/PHP——核心技术之缓存/</id>
    <published>2018-12-20T11:57:18.000Z</published>
    <updated>2018-12-28T02:53:27.788Z</updated>
    
    <content type="html"><![CDATA[<p>缓存在所有开发里面可是说是有着具足其中的作用，或者对平时开发中并不显见，但是为了考虑性能，考虑实际应用，考虑用户的顾虑，那么缓存就不得不慎重考虑，PHP中也是同样…… </p><h2 id="APP接口"><a href="#APP接口" class="headerlink" title="APP接口"></a>APP接口</h2><p>首先在这之前推荐一篇文章：</p><p><a href="http://www.cnblogs.com/timothy-lai/p/5532166.html" target="_blank" rel="noopener">PHP9大缓存技术</a></p><h2 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a>核心技术</h2><h3 id="静态缓存"><a href="#静态缓存" class="headerlink" title="静态缓存"></a>静态缓存</h3><p>保存在磁盘上的静态文件，用PHP生成数据放入静态文件中</p><p>一：操作缓存</p><ol><li>生成</li><li>获取</li><li>删除</li></ol><p>实现案例</p><pre><code>&lt;?phpclass File {    private $_dir;    const EXT = &apos;.txt&apos;;    public function __construct() {        $this-&gt;_dir = dirname(__FILE__) . &apos;/files/&apos;;    }    public function cacheData($key, $value = &apos;&apos;, $cacheTime = 0) {    $filename = $this-&gt;_dir  . $key . self::EXT;    if($value !== &apos;&apos;) { // 将value值写入缓存    if(is_null($value)) {        return @unlink($filename);    }    $dir = dirname($filename);    if(!is_dir($dir)) {        mkdir($dir, 0777);    }    $cacheTime = sprintf(&apos;%011d&apos;, $cacheTime);        return file_put_contents($filename,$cacheTime . json_encode($value));    }    if(!is_file($filename)) {        return FALSE;    }     $contents = file_get_contents($filename);    $cacheTime = (int)substr($contents, 0 ,11);    $value = substr($contents, 11);    if($cacheTime !=0 &amp;&amp; ($cacheTime + filemtime($filename) &lt; time())) {        unlink($filename);        return FALSE;    }    return json_decode($value, true);    }}$file = new File();echo $file-&gt;cacheData(&apos;test1&apos;);</code></pre><h3 id="Memcache和Redis缓存技术"><a href="#Memcache和Redis缓存技术" class="headerlink" title="Memcache和Redis缓存技术"></a>Memcache和Redis缓存技术</h3><p>简单总结</p><p>1、 Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等。<br>2、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。<br>3、虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘<br>4、过期策略–memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通过例如expire 设定，例如expire name 10<br>5、分布式–设定memcache集群，利用magent做一主多从;redis可以做一主多从。都可以一主一从<br>6、存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）<br>7、灾难恢复–memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复<br>8、Redis支持数据的备份，即master-slave模式的数据备份。</p><p>分类总结 </p><p>（1）数据结构：Memcache只支持key value存储方式，Redis支持更多的数据类型，比如Key value，hash，list，set，zset；</p><p>（2）多线程：Memcache支持多线程，redis支持单线程；CPU利用方面Memcache优于redis；</p><p>（3）持久化：Memcache不支持持久化，Redis支持持久化；</p><p>（4）内存利用率：memcache高，redis低（采用压缩的情况下比memcache高）；</p><p>（5）过期策略：memcache过期后，不删除缓存，会导致下次取数据数据的问题，Redis有专门线程，清除缓存数据；</p><p>整体性对比 </p><p>1）性能对比：由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起 Memcached，还是稍有逊色。</p><p>2）内存使用效率对比：使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。</p><p>3）Redis支持服务器端的数据操作：Redis相比Memcached来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在Memcached 里，你需要将数据拿到客户端来进行类似的修改再set回去。这大大增加了网络IO的次数和数据体积。在Redis中，这些复杂的操作通常和一般的 GET/SET一样高效。所以，如果需要缓存能够支持更复杂的结构和操作，那么Redis会是不错的选择。</p><p>后面会有专门的文章介绍Memcache与Redis原理，使用与总结</p><ol><li>设置缓存操作</li><li>获取缓存操作</li><li>删除缓存操作</li></ol><p>分别以命令和PHP的方式</p>]]></content>
    
    <summary type="html">
    
      缓存在所有开发里面可是说是有着具足其中的作用，或者对平时开发中并不显见，但是为了考虑性能，考虑实际应用，考虑用户的顾虑，那么缓存就不得不慎重考虑，PHP中也是同样......
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="缓存" scheme="https://icocos.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>PHP——文件上传下载原理与配置</title>
    <link href="https://icocos.github.io/2018/12/19/PHP%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>https://icocos.github.io/2018/12/19/PHP——文件上传下载原理与配置/</id>
    <published>2018-12-19T15:31:21.000Z</published>
    <updated>2018-12-28T02:51:42.102Z</updated>
    
    <content type="html"><![CDATA[<p>关于PHP上传和下载的原理一句话总结就是：将客户端文件上传到服务器端，再将服务器端的文件（临时文件）移动到指定目录即可。……</p><h2 id="文件上传下载原理与配置"><a href="#文件上传下载原理与配置" class="headerlink" title="文件上传下载原理与配置"></a>文件上传下载原理与配置</h2><h2 id="一、上传原理与配置"><a href="#一、上传原理与配置" class="headerlink" title="一、上传原理与配置"></a>一、上传原理与配置</h2><h3 id="1-1-原理"><a href="#1-1-原理" class="headerlink" title="1.1 原理"></a>1.1 原理</h3><p>将客户端文件上传到服务器端，再将服务器端的文件（临时文件）移动到指定目录即可。</p><h3 id="1-2-客户端配置"><a href="#1-2-客户端配置" class="headerlink" title="1.2 客户端配置"></a>1.2 客户端配置</h3><p>所需：表单页面（选择上传文件）；</p><p>具体而言：发送方式为POST，添加enctype=”multipart/form-data”属性，两者缺一不可（但是，优缺点并存，这里也限定了上传的方式和上传的文件之后的调用等方面，后面会说到）</p><pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;doAction.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;请选择您要上传的文件：&lt;input type=&quot;file&quot; name=&quot;myFile&quot; /&gt;&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;&lt;/form&gt;&lt;?php?&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>先是表单页面（请自动忽略前端问题。。。），关键就是form的属性；另外就是input 中用到了type=”file”这一点（体现到php的强大的拓展等等）。</p><p>然后是doAction</p><pre><code>&lt;?php//$_FILES:文件上传变量//print_r($_FILES);$filename=$_FILES[&apos;myFile&apos;][&apos;name&apos;];$type=$_FILES[&apos;myFile&apos;][&apos;type&apos;];$tmp_name=$_FILES[&apos;myFile&apos;][&apos;tmp_name&apos;];$size=$_FILES[&apos;myFile&apos;][&apos;size&apos;];$error=$_FILES[&apos;myFile&apos;][&apos;error&apos;];//将服务器上的临时文件移动到指定位置//方法一move_upload_file($tmp_name,$destination)//move_uploaded_file($tmp_name, &quot;uploads/&quot;.$filename);//文件夹应提前建立好，不然报错//方法二copy($src,$des)//以上两个函数都是成功返回真，否则返回false//copy($tmp_name, &quot;copies/&quot;.$filename);//注意，不能两个方法都对临时文件进行操作，临时文件似乎操作完就没了，我们试试反过来copy($tmp_name, &quot;copies/&quot;.$filename);move_uploaded_file($tmp_name, &quot;uploads/&quot;.$filename);//能够实现，说明move那个函数基本上相当于剪切；copy就是copy，临时文件还在//另外，错误信息也是不一样的，遇到错误可以查看或者直接报告给用户if ($error==0) {echo &quot;上传成功！&quot;;}else{switch ($error){case 1:echo &quot;超过了上传文件的最大值，请上传2M以下文件&quot;;break;case 2:echo &quot;上传文件过多，请一次上传20个及以下文件！&quot;;break;case 3:echo &quot;文件并未完全上传，请再次尝试！&quot;;break;case 4:echo &quot;未选择上传文件！&quot;;break;case 5:echo &quot;上传文件为0&quot;;break;}}</code></pre><p>先把print_r($_FILES)这个信息看一下</p><pre><code>Array([myFile] =&gt; Array([name] =&gt; 梁博_简历.doc[type] =&gt; application/msword[tmp_name] =&gt; D:\wamp\tmp\php1D78.tmp[error] =&gt; 0[size] =&gt; 75776))</code></pre><p>所以得到的是个二维数组，该怎么用，都是基本的东西（其实我喜欢降维再用）；</p><p>基本是一眼就懂的东西，不罗嗦，关键有两个：tmp_name临时文件名；error报错信息（代号，后面可以利用）；</p><p>然后这里看一下doAction后面一部分，利用报错信息来反馈给用户，需要说明的是为什么报错，和报错信息是什么都；</p><h3 id="1-3-关于报错"><a href="#1-3-关于报错" class="headerlink" title="1.3 关于报错"></a>1.3 关于报错</h3><p>–报错原因</p><pre><code>基本上都是超过或者不符合服务器关于上传文件的配置，那么服务器端配置有哪些呢？</code></pre><p>先考虑上传我们用了什么？POST，upload</p><p>所以在php.ini中找这么几项：</p><pre><code>file_upload:Onupload_tmp_dir=——临时文件保存目录；upload_max_filesize=2Mmax_file_uploads=20——允许一次上传的最大文件数量（注意和上面那个的区别，有没有size，别乱想）post_max_size=8M——post方式发送数据的最大值</code></pre><p>其他相关配置</p><pre><code>max_exectuion_time=-1——最大执行时间，避免程序不好占用服务器资源；max_input_time=60max_input_nesting_level=64——输入嵌套深度；memory_limit=128M——最大单线程的独立内存使用量</code></pre><p>总之都是有关资源的配置。</p><p>–错误号</p><p>以下（偷懒）引自<a href="http://blog.sina.com.cn/s/blog_3cdfaea201008utf.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_3cdfaea201008utf.html</a></p><pre><code>UPLOAD_ERR_OK             值：0; 没有错误发生，文件上传成功。UPLOAD_ERR_INI_SIZE      值：1; 上传的文件超过了 php.ini 中 upload_max_filesize 选项限制的值。UPLOAD_ERR_FORM_SIZE  值：2; 上传文件的大小超过了 HTML 表单中 MAX_FILE_SIZE 选项指定的值。UPLOAD_ERR_PARTIAL          值：3; 文件只有部分被上传。UPLOAD_ERR_NO_FILE          值：4; 没有文件被上传。 </code></pre><blockquote><p>注意：这个错误信息是第一步上传的信息，也就是上传到临时文件夹的情况，而不是move或者copy的情况。</p></blockquote><h2 id="二、上传相关限制"><a href="#二、上传相关限制" class="headerlink" title="二、上传相关限制"></a>二、上传相关限制</h2><h3 id="2-1-客户端限制"><a href="#2-1-客户端限制" class="headerlink" title="2.1 客户端限制"></a>2.1 客户端限制</h3><pre><code>&lt;form action=&quot;doAction2.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;MAX_FILE_SIZE&quot; value=&quot;101321&quot; /&gt;请选择您要上传的文件：&lt;input type=&quot;file&quot; name=&quot;myFile&quot; accept=&quot;image/jpeg,image/gif,text/html&quot;/&gt;&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;&lt;/form&gt;</code></pre><p>这里用input的属性对上传文件的大小和类型进行了限制，但是个人感觉：一，html代码是“可见的”；二，常不起作用（没找到原因，但因为第一个我也想放弃它，知道就好。</p><p>2.2 服务器端限制</p><p>主要限制大小和类型，再有就是方式。</p><pre><code>&lt;?phpheader(&apos;content-type:text/html;charset=utf-8&apos;);//接受文件，临时文件信息$fileinfo=$_FILES[&quot;myFile&quot;];//降维操作$filename=$fileinfo[&quot;name&quot;];$tmp_name=$fileinfo[&quot;tmp_name&quot;];$size=$fileinfo[&quot;size&quot;];$error=$fileinfo[&quot;error&quot;];$type=$fileinfo[&quot;type&quot;];//服务器端设定限制$maxsize=10485760;//10M,10*1024*1024$allowExt=array(&apos;jpeg&apos;,&apos;jpg&apos;,&apos;png&apos;,&apos;tif&apos;);//允许上传的文件类型（拓展名$ext=pathinfo($filename,PATHINFO_EXTENSION);//提取上传文件的拓展名//目的信息$path=&quot;uploads&quot;;if (!file_exists($path)) {  //当目录不存在，就创建目录mkdir($path,0777,true);chmod($path, 0777);}//$destination=$path.&quot;/&quot;.$filename;//得到唯一的文件名！防止因为文件名相同而产生覆盖$uniName=md5(uniqid(microtime(true),true)).$ext;//md5加密，uniqid产生唯一id，microtime做前缀if ($error==0) {if ($size&gt;$maxsize) {exit(&quot;上传文件过大！&quot;);}if (!in_array($ext, $allowExt)) {exit(&quot;非法文件类型&quot;);}if (!is_uploaded_file($tmp_name)) {exit(&quot;上传方式有误，请使用post方式&quot;);}if (@move_uploaded_file($tmp_name, $uniName)) {//@错误抑制符，不让用户看到警告echo &quot;文件&quot;.$filename.&quot;上传成功!&quot;;}else{echo &quot;文件&quot;.$filename.&quot;上传失败!&quot;;}//判断是否为真实图片（防止伪装成图片的病毒一类的if (!getimagesize($tmp_name)) {//getimagesize真实返回数组，否则返回falseexit(&quot;不是真正的图片类型&quot;);}}else{switch ($error){case 1:echo &quot;超过了上传文件的最大值，请上传2M以下文件&quot;;break;case 2:echo &quot;上传文件过多，请一次上传20个及以下文件！&quot;;break;case 3:echo &quot;文件并未完全上传，请再次尝试！&quot;;break;case 4:echo &quot;未选择上传文件！&quot;;break;case 7:echo &quot;没有临时文件夹&quot;;break;}}</code></pre><p>这里，具体实现都有注释，每一步其实都可以自己试试的，很有趣。</p><h3 id="2-3-封装"><a href="#2-3-封装" class="headerlink" title="2.3 封装"></a>2.3 封装</h3><p>函数</p><pre><code>&lt;?phpfunction uploadFile($fileInfo,$path,$allowExt,$maxSize){$filename=$fileInfo[&quot;name&quot;];$tmp_name=$fileInfo[&quot;tmp_name&quot;];$size=$fileInfo[&quot;size&quot;];$error=$fileInfo[&quot;error&quot;];$type=$fileInfo[&quot;type&quot;];//服务器端设定限制$ext=pathinfo($filename,PATHINFO_EXTENSION);//目的信息if (!file_exists($path)) {  mkdir($path,0777,true);chmod($path, 0777);}$uniName=md5(uniqid(microtime(true),true)).&apos;.&apos;.$ext;$destination=$path.&quot;/&quot;.$uniName;if ($error==0) {if ($size&gt;$maxSize) {exit(&quot;上传文件过大！&quot;);}if (!in_array($ext, $allowExt)) {exit(&quot;非法文件类型&quot;);}if (!is_uploaded_file($tmp_name)) {exit(&quot;上传方式有误，请使用post方式&quot;);}//判断是否为真实图片（防止伪装成图片的病毒一类的if (!getimagesize($tmp_name)) {//getimagesize真实返回数组，否则返回falseexit(&quot;不是真正的图片类型&quot;);}if (@move_uploaded_file($tmp_name, $destination)) {//@错误抑制符，不让用户看到警告echo &quot;文件&quot;.$filename.&quot;上传成功!&quot;;}else{echo &quot;文件&quot;.$filename.&quot;上传失败!&quot;;}}else{switch ($error){case 1:echo &quot;超过了上传文件的最大值，请上传2M以下文件&quot;;break;case 2:echo &quot;上传文件过多，请一次上传20个及以下文件！&quot;;break;case 3:echo &quot;文件并未完全上传，请再次尝试！&quot;;break;case 4:echo &quot;未选择上传文件！&quot;;break;case 7:echo &quot;没有临时文件夹&quot;;break;}}return $destination;}</code></pre><p>调用</p><pre><code>&lt;?phpheader(&apos;content-type:text/html;charset=utf-8&apos;);$fileInfo=$_FILES[&quot;myFile&quot;];$maxSize=10485760;//10M,10*1024*1024$allowExt=array(&apos;jpeg&apos;,&apos;jpg&apos;,&apos;png&apos;,&apos;tif&apos;);$path=&quot;uploads&quot;;include_once &apos;upFunc.php&apos;;uploadFile($fileInfo, $path, $allowExt, $maxSize);</code></pre><h2 id="三、多文件的上传实现"><a href="#三、多文件的上传实现" class="headerlink" title="三、多文件的上传实现"></a>三、多文件的上传实现</h2><h3 id="3-1-利用单文件封装"><a href="#3-1-利用单文件封装" class="headerlink" title="3.1 利用单文件封装"></a>3.1 利用单文件封装</h3><pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;doAction5.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;请选择您要上传的文件：&lt;input type=&quot;file&quot; name=&quot;myFile1&quot; /&gt;&lt;br/&gt;请选择您要上传的文件：&lt;input type=&quot;file&quot; name=&quot;myFile2&quot; /&gt;&lt;br/&gt;请选择您要上传的文件：&lt;input type=&quot;file&quot; name=&quot;myFile3&quot; /&gt;&lt;br/&gt;请选择您要上传的文件：&lt;input type=&quot;file&quot; name=&quot;myFile4&quot; /&gt;&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php//print_r($_FILES);header(&apos;content-type:text/html;charset=utf-8&apos;);include_once &apos;upFunc.php&apos;;foreach ($_FILES as $fileInfo){$file[]=uploadFile($fileInfo);}</code></pre><p>这里的思路，从print_r($_FILES)中去找，打印出来看到是个二维数组，很简单，遍历去用就好了！</p><p>上面那个function的定义改一下，给定一些默认值</p><pre><code>function uploadFile($fileInfo,$path=&quot;uploads&quot;,$allowExt=array(&apos;jpeg&apos;,&apos;jpg&apos;,&apos;png&apos;,&apos;tif&apos;),$maxSize=10485760){</code></pre><p>这样子，简单是简单，但遇到一些问题。</p><p>正常的上传4个图片是没问题，但要是中间激活了函数中的exit，就会立即停止，导致其他图片也无法上传。</p><h3 id="3-2-升级版封装"><a href="#3-2-升级版封装" class="headerlink" title="3.2 升级版封装"></a>3.2 升级版封装</h3><p>旨在实现针对多个或单个文件上传的封装</p><p>首先这样子写个静态文件</p><pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;doAction5.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;请选择您要上传的文件：&lt;input type=&quot;file&quot; name=&quot;myFile[]&quot; /&gt;&lt;br/&gt;请选择您要上传的文件：&lt;input type=&quot;file&quot; name=&quot;myFile[]&quot; /&gt;&lt;br/&gt;请选择您要上传的文件：&lt;input type=&quot;file&quot; name=&quot;myFile[]&quot; /&gt;&lt;br/&gt;请选择您要上传的文件：&lt;input type=&quot;file&quot; name=&quot;myFile[]&quot; /&gt;&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>打印一下$_FILES</p><pre><code>Array([myFile] =&gt; Array([name] =&gt; Array([0] =&gt; test32.png[1] =&gt; test32.png[2] =&gt; 333.png[3] =&gt; test41.png)[type] =&gt; Array([0] =&gt; image/png[1] =&gt; image/png[2] =&gt; image/png[3] =&gt; image/png)[tmp_name] =&gt; Array([0] =&gt; D:\wamp\tmp\php831C.tmp[1] =&gt; D:\wamp\tmp\php834C.tmp[2] =&gt; D:\wamp\tmp\php837C.tmp[3] =&gt; D:\wamp\tmp\php83BB.tmp)[error] =&gt; Array([0] =&gt; 0[1] =&gt; 0[2] =&gt; 0[3] =&gt; 0)[size] =&gt; Array([0] =&gt; 46174[1] =&gt; 46174[2] =&gt; 34196[3] =&gt; 38514)))</code></pre><p>可以得到一个三维数组。</p><p>复杂是复杂了，但复杂的有规律，各项数值都在一起了，很方便我们取值！！</p><p>所以先得到文件信息，变成单文件处理那种信息</p><pre><code>function getFiles(){$i=0;foreach($_FILES as $file){if(is_string($file[&apos;name&apos;])){ //单文件判定$files[$i]=$file;$i++;}elseif(is_array($file[&apos;name&apos;])){foreach($file[&apos;name&apos;] as $key=&gt;$val){ //我的天，这个$key用的diao$files[$i][&apos;name&apos;]=$file[&apos;name&apos;][$key];$files[$i][&apos;type&apos;]=$file[&apos;type&apos;][$key];$files[$i][&apos;tmp_name&apos;]=$file[&apos;tmp_name&apos;][$key];$files[$i][&apos;error&apos;]=$file[&apos;error&apos;][$key];$files[$i][&apos;size&apos;]=$file[&apos;size&apos;][$key];$i++;}}}return $files;}</code></pre><p>然后之前的那种exit错误，就把exit改一下就好了，这里用res</p><pre><code>function uploadFile($fileInfo,$path=&apos;./uploads&apos;,$flag=true,$maxSize=1048576,$allowExt=array(&apos;jpeg&apos;,&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;)){//$flag=true;//$allowExt=array(&apos;jpeg&apos;,&apos;jpg&apos;,&apos;gif&apos;,&apos;png&apos;);//$maxSize=1048576;//1M//判断错误号$res=array();if($fileInfo[&apos;error&apos;]===UPLOAD_ERR_OK){//检测上传得到小if($fileInfo[&apos;size&apos;]&gt;$maxSize){$res[&apos;mes&apos;]=$fileInfo[&apos;name&apos;].&apos;上传文件过大&apos;;}$ext=getExt($fileInfo[&apos;name&apos;]);//检测上传文件的文件类型if(!in_array($ext,$allowExt)){$res[&apos;mes&apos;]=$fileInfo[&apos;name&apos;].&apos;非法文件类型&apos;;}//检测是否是真实的图片类型if($flag){if(!getimagesize($fileInfo[&apos;tmp_name&apos;])){$res[&apos;mes&apos;]=$fileInfo[&apos;name&apos;].&apos;不是真实图片类型&apos;;}}//检测文件是否是通过HTTP POST上传上来的if(!is_uploaded_file($fileInfo[&apos;tmp_name&apos;])){$res[&apos;mes&apos;]=$fileInfo[&apos;name&apos;].&apos;文件不是通过HTTP POST方式上传上来的&apos;;}if($res) return $res;//$path=&apos;./uploads&apos;;if(!file_exists($path)){mkdir($path,0777,true);chmod($path,0777);}$uniName=getUniName();$destination=$path.&apos;/&apos;.$uniName.&apos;.&apos;.$ext;if(!move_uploaded_file($fileInfo[&apos;tmp_name&apos;],$destination)){$res[&apos;mes&apos;]=$fileInfo[&apos;name&apos;].&apos;文件移动失败&apos;;}$res[&apos;mes&apos;]=$fileInfo[&apos;name&apos;].&apos;上传成功&apos;;$res[&apos;dest&apos;]=$destination;return $res;}else{//匹配错误信息switch ($fileInfo [&apos;error&apos;]) {case 1 :$res[&apos;mes&apos;] = &apos;上传文件超过了PHP配置文件中upload_max_filesize选项的值&apos;;break;case 2 :$res[&apos;mes&apos;] = &apos;超过了表单MAX_FILE_SIZE限制的大小&apos;;break;case 3 :$res[&apos;mes&apos;] = &apos;文件部分被上传&apos;;break;case 4 :$res[&apos;mes&apos;] = &apos;没有选择上传文件&apos;;break;case 6 :$res[&apos;mes&apos;] = &apos;没有找到临时目录&apos;;break;case 7 :case 8 :$res[&apos;mes&apos;] = &apos;系统错误&apos;;break;}return $res;}}</code></pre><p>里面封装了两个小的</p><pre><code>function getExt($filename){return strtolower(pathinfo($filename,PATHINFO_EXTENSION));}/*** 产生唯一字符串* @return string*/function getUniName(){return md5(uniqid(microtime(true),true));}</code></pre><p>然后静态中，用multiple属性实现多个文件的输入；</p><pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;doAction6.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;请选择您要上传的文件：&lt;input type=&quot;file&quot; name=&quot;myFile[]&quot; multiple=&apos;multiple&apos; /&gt;&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;doAction6&lt;?php //print_r($_FILES);header(&quot;content-type:text/html;charset=utf-8&quot;);require_once &apos;upFunc2.php&apos;;require_once &apos;common.func.php&apos;;$files=getFiles();// print_r($files);foreach($files as $fileInfo){$res=uploadFile($fileInfo);echo $res[&apos;mes&apos;],&apos;&lt;br/&gt;&apos;;$uploadFiles[]=@$res[&apos;dest&apos;];}$uploadFiles=array_values(array_filter($uploadFiles));//print_r($uploadFiles);</code></pre><p>这样子的几个文件，就实现比较强大的面向过程的上传文件的功能（学的叫一个心酸。。。）；</p><h2 id="四、面向对象的文件上传"><a href="#四、面向对象的文件上传" class="headerlink" title="四、面向对象的文件上传"></a>四、面向对象的文件上传</h2><p>（不是很写的动了。。。先粘过来，再说吧。。。</p><pre><code>&lt;?php class upload{protected $fileName;protected $maxSize;protected $allowMime;protected $allowExt;protected $uploadPath;protected $imgFlag;protected $fileInfo;protected $error;protected $ext;/*** @param string $fileName* @param string $uploadPath* @param string $imgFlag* @param number $maxSize* @param array $allowExt* @param array $allowMime*/public function __construct($fileName=&apos;myFile&apos;,$uploadPath=&apos;./uploads&apos;,$imgFlag=true,$maxSize=5242880,$allowExt=array(&apos;jpeg&apos;,&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;),$allowMime=array(&apos;image/jpeg&apos;,&apos;image/png&apos;,&apos;image/gif&apos;)){$this-&gt;fileName=$fileName;$this-&gt;maxSize=$maxSize;$this-&gt;allowMime=$allowMime;$this-&gt;allowExt=$allowExt;$this-&gt;uploadPath=$uploadPath;$this-&gt;imgFlag=$imgFlag;$this-&gt;fileInfo=$_FILES[$this-&gt;fileName];}/*** 检测上传文件是否出错* @return boolean*/protected function checkError(){if(!is_null($this-&gt;fileInfo)){if($this-&gt;fileInfo[&apos;error&apos;]&gt;0){switch($this-&gt;fileInfo[&apos;error&apos;]){case 1:$this-&gt;error=&apos;超过了PHP配置文件中upload_max_filesize选项的值&apos;;break;case 2:$this-&gt;error=&apos;超过了表单中MAX_FILE_SIZE设置的值&apos;;break;case 3:$this-&gt;error=&apos;文件部分被上传&apos;;break;case 4:$this-&gt;error=&apos;没有选择上传文件&apos;;break;case 6:$this-&gt;error=&apos;没有找到临时目录&apos;;break;case 7:$this-&gt;error=&apos;文件不可写&apos;;break;case 8:$this-&gt;error=&apos;由于PHP的扩展程序中断文件上传&apos;;break;}return false;}else{return true;}}else{$this-&gt;error=&apos;文件上传出错&apos;;return false;}}/*** 检测上传文件的大小* @return boolean*/protected function checkSize(){if($this-&gt;fileInfo[&apos;size&apos;]&gt;$this-&gt;maxSize){$this-&gt;error=&apos;上传文件过大&apos;;return false;}return true;}/*** 检测扩展名* @return boolean*/protected function checkExt(){$this-&gt;ext=strtolower(pathinfo($this-&gt;fileInfo[&apos;name&apos;],PATHINFO_EXTENSION));if(!in_array($this-&gt;ext,$this-&gt;allowExt)){$this-&gt;error=&apos;不允许的扩展名&apos;;return false;}return true;}/*** 检测文件的类型* @return boolean*/protected function checkMime(){if(!in_array($this-&gt;fileInfo[&apos;type&apos;],$this-&gt;allowMime)){$this-&gt;error=&apos;不允许的文件类型&apos;;return false;}return true;}/*** 检测是否是真实图片* @return boolean*/protected function checkTrueImg(){if($this-&gt;imgFlag){if(!@getimagesize($this-&gt;fileInfo[&apos;tmp_name&apos;])){$this-&gt;error=&apos;不是真实图片&apos;;return false;}return true;}}/*** 检测是否通过HTTP POST方式上传上来的* @return boolean*/protected function checkHTTPPost(){if(!is_uploaded_file($this-&gt;fileInfo[&apos;tmp_name&apos;])){$this-&gt;error=&apos;文件不是通过HTTP POST方式上传上来的&apos;;return false;}return true;}/***显示错误 */protected function showError(){exit(&apos;&lt;span style=&quot;color:red&quot;&gt;&apos;.$this-&gt;error.&apos;&lt;/span&gt;&apos;);}/*** 检测目录不存在则创建*/protected function checkUploadPath(){if(!file_exists($this-&gt;uploadPath)){mkdir($this-&gt;uploadPath,0777,true);}}/*** 产生唯一字符串* @return string*/protected function getUniName(){return md5(uniqid(microtime(true),true));}/*** 上传文件* @return string*/public function uploadFile(){if($this-&gt;checkError()&amp;&amp;$this-&gt;checkSize()&amp;&amp;$this-&gt;checkExt()&amp;&amp;$this-&gt;checkMime()&amp;&amp;$this-&gt;checkTrueImg()&amp;&amp;$this-&gt;checkHTTPPost()){$this-&gt;checkUploadPath();$this-&gt;uniName=$this-&gt;getUniName();$this-&gt;destination=$this-&gt;uploadPath.&apos;/&apos;.$this-&gt;uniName.&apos;.&apos;.$this-&gt;ext;if(@move_uploaded_file($this-&gt;fileInfo[&apos;tmp_name&apos;], $this-&gt;destination)){return $this-&gt;destination;}else{$this-&gt;error=&apos;文件移动失败&apos;;$this-&gt;showError();}}else{$this-&gt;showError();}}}&lt;?php header(&apos;content-type:text/html;charset=utf-8&apos;);require_once &apos;upload.class.php&apos;;$upload=new upload(&apos;myFile1&apos;,&apos;imooc&apos;);$dest=$upload-&gt;uploadFile();echo $dest;</code></pre><h2 id="五、下载"><a href="#五、下载" class="headerlink" title="五、下载"></a>五、下载</h2><p>对于浏览器不识别的，可以直接下载，但对于能识别的，需要多一两步</p><pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;1.rar&quot;&gt;下载1.rar&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;1.jpg&quot;&gt;下载1.jpg&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;doDownload.php?filename=1.jpg&quot;&gt;通过程序下载1.jpg&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;doDownload.php?filename=../upload/nv.jpg&quot;&gt;下载nv.jpg&lt;/a&gt;&lt;?php?&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php $filename=$_GET[&apos;filename&apos;];header(&apos;content-disposition:attachment;filename=&apos;.basename($filename));header(&apos;content-length:&apos;.filesize($filename));readfile($filename);</code></pre><p>——————总结———————–</p><p><form action="doAction.php" method="post" enctype="multipart/form-data"></form></p><p><input type="file" name="myFile"><br></p><pre><code>二维数组的降维处理；$_FILES变量move_upload_file();copy();tmp_name临时文件；拓展名的提取；真实图片的验证；唯一文件名的生成；函数封装以及调用；利用单个文件函数实现多文件上传；小功能的封装；多文件的遍历；面向对象的开发过程；</code></pre>]]></content>
    
    <summary type="html">
    
      关于PHP上传和下载的原理一句话总结就是：将客户端文件上传到服务器端，再将服务器端的文件（临时文件）移动到指定目录即可。......
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="文件上传下载原理与配置" scheme="https://icocos.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>PHP——文件上传下载实战</title>
    <link href="https://icocos.github.io/2018/12/17/PHP%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%AE%9E%E6%88%98/"/>
    <id>https://icocos.github.io/2018/12/17/PHP——文件上传下载实战/</id>
    <published>2018-12-17T15:32:05.000Z</published>
    <updated>2018-12-28T02:50:10.007Z</updated>
    
    <content type="html"><![CDATA[<p>既然涉及到PHP开发APP接口，文件上传和下载是在所难免的，也许有些人会考虑第三方的，比如七牛，但是学习和使用终究还是要会的，所以，所以……</p><h2 id="文件上传下载实战"><a href="#文件上传下载实战" class="headerlink" title="文件上传下载实战"></a>文件上传下载实战</h2><p>以前一直在做iOS，最近转行去搞php开发，总觉得力不从心。这几天有个需求，是关于php的文件上传和下载的。给大家分享下自己的学习资料。</p><h3 id="1-先来个请求页面upload-html"><a href="#1-先来个请求页面upload-html" class="headerlink" title="1.先来个请求页面upload.html"></a>1.先来个请求页面upload.html</h3><pre><code>&lt;html&gt;  &lt;head&gt;  &lt;title&gt;Administration - upload new files&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;  &lt;h1&gt;Upload new news files&lt;/h1&gt;  &lt;form enctype=&quot;multipart/form-data&quot; action=&quot;upload.php&quot; method=post&gt;  &lt;input type=&quot;hidden&quot; name=&quot;MAX_FILE_SIZE&quot; value=&quot;1000000&quot;&gt;  Upload this file: &lt;input name=&quot;userfile&quot; type=&quot;file&quot;&gt;  &lt;input type=&quot;submit&quot; value=&quot;Send File&quot;&gt;  &lt;/form&gt;  &lt;/body&gt;  &lt;/html&gt;  </code></pre><h3 id="2-php处理客户端请求的数据upload-html"><a href="#2-php处理客户端请求的数据upload-html" class="headerlink" title="2.php处理客户端请求的数据upload.html"></a>2.php处理客户端请求的数据upload.html</h3><pre><code>&lt;html&gt;  &lt;head&gt;  &lt;title&gt;Uploading...&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;  &lt;h1&gt;Uploading file...&lt;/h1&gt;  &lt;?php  //Check to see if an error code was generated on the upload attempt  if ($_FILES[&apos;userfile&apos;][&apos;error&apos;] &gt; 0)  {  echo &apos;Problem: &apos;;  switch ($_FILES[&apos;userfile&apos;][&apos;error&apos;])  {  case 1:   echo &apos;File exceeded upload_max_filesize&apos;;  break;  case 2:   echo &apos;File exceeded max_file_size&apos;;  break;  case 3:   echo &apos;File only partially uploaded&apos;;  break;  case 4:   echo &apos;No file uploaded&apos;;  break;  case 6:   echo &apos;Cannot upload file: No temp directory specified.&apos;;  break;  case 7:   echo &apos;Upload failed: Cannot write to disk.&apos;;  break;  }  exit;  }  // Does the file have the right MIME type?  if ($_FILES[&apos;userfile&apos;][&apos;type&apos;] != &apos;text/plain&apos;)  {  echo &apos;Problem: file is not plain text&apos;;  exit;  }  // put the file where we&apos;d like it  $upfile = &apos;/uploads/&apos;.$_FILES[&apos;userfile&apos;][&apos;name&apos;];  if (is_uploaded_file($_FILES[&apos;userfile&apos;][&apos;tmp_name&apos;]))   {  if (!move_uploaded_file($_FILES[&apos;userfile&apos;][&apos;tmp_name&apos;], $upfile))  {  echo &apos;Problem: Could not move file to destination directory&apos;;  exit;  }  }   else   {  echo &apos;Problem: Possible file upload attack. Filename: &apos;;  echo $_FILES[&apos;userfile&apos;][&apos;name&apos;];  exit;  }  echo &apos;File uploaded successfully&lt;br&gt;&lt;br&gt;&apos;;   // reformat the file contents  $fp = fopen($upfile, &apos;r&apos;);  $contents = fread ($fp, filesize ($upfile));  fclose ($fp);  $contents = strip_tags($contents);  $fp = fopen($upfile, &apos;w&apos;);  fwrite($fp, $contents);  fclose($fp);  // show what was uploaded  echo &apos;Preview of uploaded file contents:&lt;br&gt;&lt;hr&gt;&apos;;  echo $contents;  echo &apos;&lt;br&gt;&lt;hr&gt;&apos;;  ?&gt;  &lt;/body&gt;  &lt;/html&gt;  </code></pre><h3 id="3-php文件下载"><a href="#3-php文件下载" class="headerlink" title="3.php文件下载"></a>3.php文件下载</h3><pre><code>&lt;?php  $filePath = &quot;template/&quot;;//此处给出你下载的文件在服务器的什么地方  $fileName = &quot;template.xls&quot;;  //此处给出你下载的文件名  $file = fopen($filePath . $fileName, &quot;r&quot;); //   打开文件  //输入文件标签  Header(&quot;Content-type:application/octet-stream &quot;);  Header(&quot;Accept-Ranges:bytes &quot;);  Header(&quot;Accept-Length:   &quot; . filesize($filePath . $fileName));  Header(&quot;Content-Disposition:   attachment;   filename= &quot; . $fileName);  //   输出文件内容  echo fread($file, filesize($filePath . $fileName));  fclose($file);  exit;  ?&gt;  </code></pre><blockquote><p>总的来说，上面的3个代码段只是简单介绍了php文件的上传下载，还有很多问题要解决，就例如上传大文件的时候怎么处理，批量上传、大文件下载等等问题。当然跟java一样，php也有很多框架可以解决这方面。</p></blockquote>]]></content>
    
    <summary type="html">
    
      既然涉及到PHP开发APP接口，文件上传和下载是在所难免的，也许有些人会考虑第三方的，比如七牛，但是学习和使用终究还是要会的，所以，所以......
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="文件上传下载实战" scheme="https://icocos.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>PHP——数据库优化的八种方式</title>
    <link href="https://icocos.github.io/2018/12/15/PHP%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E7%9A%84%E5%85%AB%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://icocos.github.io/2018/12/15/PHP——数据库优化的八种方式/</id>
    <published>2018-12-15T14:20:59.000Z</published>
    <updated>2018-12-28T02:53:15.220Z</updated>
    
    <content type="html"><![CDATA[<p>PHP——数据库优化的八种方式…..</p><h2 id="数据库优化的八种方式"><a href="#数据库优化的八种方式" class="headerlink" title="数据库优化的八种方式"></a>数据库优化的八种方式</h2><h2 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h2><p>关于数据库优化，网上有不少资料和方法，但是不少质量参差不齐，有些总结的不够到位，内容冗杂<br>偶尔发现了这篇文章，总结得很经典，文章流量也很大，所以拿到自己的总结文集中，积累优质文章，提升个人能力，希望对大家今后开发中也有帮助</p><h3 id="选取最适用的字段属性"><a href="#选取最适用的字段属性" class="headerlink" title="选取最适用的字段属性"></a>选取最适用的字段属性</h3><pre><code>MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。</code></pre><p>例如，在定义邮政编码这个字段时，如果将其设置为CHAR(255),显然给数据库增加了不必要的空间，甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段。</p><p>另外一个提高效率的方法是在可能的情况下，应该尽量把字段设置为NOTNULL，这样在将来执行查询的时候，数据库不用去比较NULL值。<br>对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。</p><h3 id="使用连接（JOIN）来代替子查询-Sub-Queries"><a href="#使用连接（JOIN）来代替子查询-Sub-Queries" class="headerlink" title="使用连接（JOIN）来代替子查询(Sub-Queries)"></a>使用连接（JOIN）来代替子查询(Sub-Queries)</h3><p>MySQL从4.1开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。例如，我们要将客户基本信息表中没有任何订单的客户删除掉，就可以利用子查询先从销售信息表中将所有发出订单的客户ID取出来，然后将结果传递给主查询，如下所示：</p><pre><code>DELETEFROMcustomerinfoWHERECustomerIDNOTin(SELECTCustomerIDFROMsalesinfo)</code></pre><p>使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接（JOIN）..替代。例如，假设我们要将所有没有订单记录的用户取出来，可以用下面这个查询完成：</p><pre><code>SELECT*FROMcustomerinfoWHERECustomerIDNOTin(SELECTCustomerIDFROMsalesinfo)</code></pre><p>如果使用连接（JOIN）..来完成这个查询工作，速度将会快很多。尤其是当salesinfo表中对CustomerID建有索引的话，性能将会更好，查询如下：</p><pre><code>SELECT*FROMcustomerinfoLEFTJOINsalesinfoONcustomerinfo.CustomerID=salesinfo.CustomerIDWHEREsalesinfo.CustomerIDISNULL</code></pre><p>连接（JOIN）..之所以更有效率一些，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。</p><h3 id="使用联合-UNION-来代替手动创建的临时表"><a href="#使用联合-UNION-来代替手动创建的临时表" class="headerlink" title="使用联合(UNION)来代替手动创建的临时表"></a>使用联合(UNION)来代替手动创建的临时表</h3><p>MySQL从4.0的版本开始支持union查询，它可以把需要使用临时表的两条或更多的select查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。使用union来创建查询的时候，我们只需要用UNION作为关键字把多个select语句连接起来就可以了，要注意的是所有select语句中的字段数目要想同。下面的例子就演示了一个使用UNION的查询。</p><pre><code>SELECTName,PhoneFROMclientUNIONSELECTName,BirthDateFROMauthorUNIONSELECTName,SupplierFROMproduct</code></pre><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条SQL语句就可以完成的。更多的时候是需要用到一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来。设想一下，要把某个数据同时插入两个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，造成第二个表中的操作没有完成，这样，就会造成数据的不完整，甚至会破坏数据库中的数据。要避免这种情况，就应该使用事务，它的作用是：要么语句块中每条语句都操作成功，要么都失败。换句话说，就是可以保持数据库中数据的一致性和完整性。事物以BEGIN关键字开始，COMMIT关键字结束。在这之间的一条SQL操作失败，那么，ROLLBACK命令就可以把数据库恢复到BEGIN开始之前的状态。</p><pre><code>BEGIN; INSERTINTOsalesinfoSETCustomerID=14;UPDATEinventorySETQuantity=11WHEREitem=&apos;book&apos;;COMMIT;</code></pre><p>事务的另一个重要作用是当多个用户同时使用相同的数据源时，它可以利用锁定数据库的方法来为用户提供一种安全的访问方式，这样可以保证用户的操作不被其它的用户所干扰。</p><h3 id="锁定表"><a href="#锁定表" class="headerlink" title="锁定表"></a>锁定表</h3><pre><code>尽管事务是维护数据库完整性的一个非常好的方法，但却因为它的独占性，有时会影响数据库的性能，尤其是在很大的应用系统中。由于在事务执行的过程中，数据库将会被锁定，因此其它的用户请求只能暂时等待直到该事务结束。如果一个数据库系统只有少数几个用户来使用，事务造成的影响不会成为一个太大的问题；但假设有成千上万的用户同时访问一个数据库系统，例如访问一个电子商务网站，就会产生比较严重的响应延迟。</code></pre><p>其实，有些情况下我们可以通过锁定表的方法来获得更好的性能。下面的例子就用锁定表的方法来完成前面一个例子中事务的功能。</p><pre><code>LOCKTABLEinventoryWRITESELECTQuantityFROMinventoryWHEREItem=&apos;book&apos;;...UPDATEinventorySETQuantity=11WHEREItem=&apos;book&apos;;UNLOCKTABLES</code></pre><p>这里，我们用一个select语句取出初始数据，通过一些计算，用update语句将新值更新到表中。包含有WRITE关键字的LOCKTABLE语句可以保证在UNLOCKTABLES命令被执行之前，不会有其它的访问来对inventory进行插入、更新或者删除的操作。</p><h3 id="使用外键"><a href="#使用外键" class="headerlink" title="使用外键"></a>使用外键</h3><pre><code>锁定表的方法可以维护数据的完整性，但是它却不能保证数据的关联性。这个时候我们就可以使用外键。</code></pre><p>例如，外键可以保证每一条销售记录都指向某一个存在的客户。在这里，外键可以把customerinfo表中的CustomerID映射到salesinfo表中CustomerID，任何一条没有合法CustomerID的记录都不会被更新或插入到salesinfo中。</p><pre><code>CREATETABLEcustomerinfo( CustomerIDINTNOTNULL,PRIMARYKEY(CustomerID))TYPE=INNODB;CREATETABLEsalesinfo( SalesIDINTNOTNULL,CustomerIDINTNOTNULL,PRIMARYKEY(CustomerID,SalesID),FOREIGNKEY(CustomerID)REFERENCEScustomerinfo(CustomerID)ONDELETECASCADE)TYPE=INNODB;</code></pre><blockquote><p>注意例子中的参数“ONDELETECASCADE”。该参数保证当customerinfo表中的一条客户记录被删除的时候，salesinfo表中所有与该客户相关的记录也会被自动删除。如果要在MySQL中使用外键，一定要记住在创建表的时候将表的类型定义为事务安全表InnoDB类型。该类型不是MySQL表的默认类型。定义的方法是在CREATETABLE语句中加上TYPE=INNODB。如例中所示。</p></blockquote><h3 id="使用索引"><a href="#使用索引" class="headerlink" title="使用索引"></a>使用索引</h3><pre><code>索引是提高数据库性能的常用方法，它可以令数据库服务器以比没有索引快得多的速度检索特定的行，尤其是在查询语句当中包含有MAX(),MIN()和ORDERBY这些命令的时候，性能提高更为明显。</code></pre><p>那该对哪些字段建立索引呢？</p><pre><code>一般说来，索引应建立在那些将用于JOIN,WHERE判断和ORDERBY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。对于一个ENUM类型的字段来说，出现大量重复值是很有可能的情况</code></pre><blockquote><p>例如customerinfo中的“province”..字段，在这样的字段上建立索引将不会有什么帮助；相反，还有可能降低数据库的性能。我们在创建表的时候可以同时创建合适的索引，也可以使用ALTERTABLE或CREATEINDEX在以后创建索引。此外，MySQL从版本3.23.23开始支持全文索引和搜索。全文索引在MySQL中是一个FULLTEXT类型索引，但仅能用于MyISAM类型的表。对于一个大的数据库，将数据装载到一个没有FULLTEXT索引的表中，然后再使用ALTERTABLE或CREATEINDEX创建索引，将是非常快的。但如果将数据装载到一个已经有FULLTEXT索引的表中，执行过程将会非常慢。</p></blockquote><h3 id="优化的查询语句"><a href="#优化的查询语句" class="headerlink" title="优化的查询语句"></a>优化的查询语句</h3><p>绝大多数情况下，使用索引可以提高查询的速度，但如果SQL语句使用不恰当的话，索引将无法发挥它应有的作用。</p><p>下面是应该注意的几个方面。</p><pre><code>首先，最好是在相同类型的字段间进行比较的操作。</code></pre><p>在MySQL3.23版之前，这甚至是一个必须的条件。例如不能将一个建有索引的INT字段和BIGINT字段进行比较；但是作为特殊的情况，在CHAR类型的字段和VARCHAR类型字段的字段大小相同的时候，可以将它们进行比较。</p><pre><code>其次，在建有索引的字段上尽量不要使用函数进行操作。</code></pre><p>例如，在一个DATE类型的字段上使用YEAE()函数时，将会使索引不能发挥应有的作用。所以，下面的两个查询虽然返回的结果一样，但后者要比前者快得多。</p><pre><code>第三，在搜索字符型字段时，我们有时会使用LIKE关键字和通配符，这种做法虽然简单，但却也是以牺牲系统性能为代价的。</code></pre><p>例如下面的查询将会比较表中的每一条记录。</p><pre><code>SELECT*FROMbooksWHEREnamelike&quot;MySQL%&quot;</code></pre><p>但是如果换用下面的查询，返回的结果一样，但速度就要快上很多：</p><pre><code>SELECT*FROMbooksWHEREname＞=&quot;MySQL&quot;andname＜&quot;MySQM&quot;</code></pre><p>最后，应该注意避免在查询中让MySQL进行自动类型转换，因为转换过程也会使索引变得不起作用。</p>]]></content>
    
    <summary type="html">
    
      PHP——数据库优化的八种方式....
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="数据库优化的八种方式" scheme="https://icocos.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E7%9A%84%E5%85%AB%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>PHP——数据库操作</title>
    <link href="https://icocos.github.io/2018/12/15/PHP%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"/>
    <id>https://icocos.github.io/2018/12/15/PHP——数据库操作/</id>
    <published>2018-12-15T11:30:21.000Z</published>
    <updated>2018-12-28T02:53:19.004Z</updated>
    
    <content type="html"><![CDATA[<p>关于数据库操作，在PHP开发中可谓是重中之重，其他开发想iOS，Android如果只是做一个简单的App可以不用对数据库操作，但是PHP开发中没有数据库操作就等于一尊雕塑，PHP中数据库首选MYSql，不用问为什么，因为他们是天合之作，谁用谁知道……</p><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><h2 id="PHP支持的数据库"><a href="#PHP支持的数据库" class="headerlink" title="PHP支持的数据库"></a>PHP支持的数据库</h2><pre><code>PHP通过安装相应的扩展来实现数据库操作，现代应用程序的设计离不开数据库的应用，当前主流的数据库有MsSQL，MySQL，Sybase，Db2，Oracle，PostgreSQL，Access等，这些数据库PHP都能够安装扩展来支持，一般情况下常说的LAMP架构指的是：Linux、Apache、Mysql、PHP，因此Mysql数据库在PHP中的应用非常广泛，我们会在本章中简单的了解Mysql的操作方法。</code></pre><h2 id="数据库拓展"><a href="#数据库拓展" class="headerlink" title="数据库拓展"></a>数据库拓展</h2><p>PHP中一个数据库可能有一个或者多个扩展，其中既有官方的，也有第三方提供的。像Mysql常用的扩展有原生的mysql库，也可以使用增强版的mysqli扩展，还可以使用PDO进行连接与操作。</p><p>不同的扩展提供基本相近的操作方法，不同的是可能具备一些新特性，以及操作性能可能会有所不同。</p><p>mysql扩展进行数据库连接的方法：</p><pre><code>$link = mysql_connect(&apos;mysql_host&apos;, &apos;mysql_user&apos;, &apos;mysql_password&apos;);</code></pre><p>mysqli扩展：</p><pre><code>$link = mysqli_connect(&apos;mysql_host&apos;, &apos;mysql_user&apos;, &apos;mysql_password&apos;);</code></pre><p>PDO扩展</p><pre><code>$dsn = &apos;mysql:dbname=testdb;host=127.0.0.1&apos;;$user = &apos;dbuser&apos;;$password = &apos;dbpass&apos;;$dbh = new PDO($dsn, $user, $password);</code></pre><h2 id="链接数据库"><a href="#链接数据库" class="headerlink" title="链接数据库"></a>链接数据库</h2><p>PHP要对数据库进行操作，首先要做的是与数据库建立连接，通常我们使用mysql_connect函数进行数据库连接，该函数需要指定数据库的地址，用户名及密码。</p><pre><code>$host = &apos;localhost&apos;;$user = &apos;code1&apos;;$pass = &apos;&apos;;$link = mysql_connect($host, $user, $pass);</code></pre><p>PHP连接数据库的方式类似于直接在命令行下通过进行连接，类似：mysql -hlocalhost -ucode1 -p，当连接成功以后，我们需要选择一个操作的数据库，通过mysql_select_db函数来选择数据库。</p><pre><code>mysql_select_db(&apos;code1&apos;);</code></pre><p>通常我们会先设置一下当前连接使用的字符编码，一般的我们会使用utf8编码。</p><pre><code>mysql_query(&quot;set names &apos;utf8&apos;&quot;);</code></pre><p>通过上面的步骤，我们就与数据库建立了连接，可以进行数据操作了。</p><h2 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h2><p>在数据库建立连接以后就可以进行查询，采用mysql_query加sql语句的形式向数据库发送查询指令。</p><pre><code>$res = mysql_query(&apos;select * from user limit 1&apos;);</code></pre><p>对于查询类的语句会返回一个资源句柄（resource），可以通过该资源获取查询结果集中的数据。</p><pre><code>$row = mysql_fetch_array($res);var_dump($row);</code></pre><p>默认的，PHP使用最近的数据库连接执行查询，但如果存在多个连接的情况，则可以通过参数指令从那个连接中进行查询。</p><pre><code>$link1 = mysql_connect(&apos;127.0.0.1&apos;, &apos;code1&apos;, &apos;&apos;);$link2 = mysql_connect(&apos;127.0.0.1&apos;, &apos;code1&apos;, &apos;&apos;, true); //开启一个新的连接$res = mysql_query(&apos;select * from user limit 1&apos;, $link1); //从第一个连接中查询数据</code></pre><h2 id="插入数据库"><a href="#插入数据库" class="headerlink" title="插入数据库"></a>插入数据库</h2><p>当我们了解了如何使用mysql_query进行数据查询以后，那么类似的，插入数据其实也是通过执行一个sql语句来实现，例如：</p><pre><code>$sql = &quot;insert into user(name, age, class) values(&apos;李四&apos;, 18, &apos;高三一班&apos;)&quot;;mysql_query($sql); //执行插入语句</code></pre><p>通常数据都是存储在变量或者数组中，因此sql语句需要先进行字符串拼接得到。</p><pre><code>$name = &apos;李四&apos;;$age = 18;$class = &apos;高三一班&apos;;$sql = &quot;insert into user(name, age, class) values(&apos;$name&apos;, &apos;$age&apos;, &apos;$class&apos;)&quot;;mysql_query($sql); //执行插入语句</code></pre><p>在mysql中，执行插入语句以后，可以得到自增的主键id,通过PHP的mysql_insert_id函数可以获取该id。</p><pre><code>$uid = mysql_insert_id();</code></pre><p>这个id的作用非常大，通常可以用来判断是否插入成功，或者作为关联ID进行其他的数据操作。</p><h2 id="获取查询结果"><a href="#获取查询结果" class="headerlink" title="获取查询结果"></a>获取查询结果</h2><p>通过前面的章节，我们发现PHP操作数据库跟MySql客户端上操作极为相似，先进行连接，然后执行sql语句，再然后获取我们想要的结果集。</p><p>PHP有多个函数可以获取数据集中的一行数据，最常用的是mysql_fetch_array，可以通过设定参数来更改行数据的下标，默认的会包含数字索引的下标以及字段名的关联索引下标。</p><pre><code>$sql = &quot;select * from user limit 1&quot;;$result = mysql_query($sql);$row = mysql_fetch_array($result);</code></pre><p>可以通过设定参数MYSQL_NUM只获取数字索引数组，等同于mysql_fetch_row函数，如果设定参数为MYSQL_ASSOC则只获取关联索引数组，等同于mysql_fetch_assoc函数。</p><pre><code>$row = mysql_fetch_row($result);$row = mysql_fetch_array($result, MYSQL_NUM); //这两个方法获取的数据是一样的$row = mysql_fetch_assoc($result);$row = mysql_fetch_array($result, MYSQL_ASSOC);</code></pre><p>如果要获取数据集中的所有数据，我们通过循环来遍历整个结果集。</p><pre><code>$data = array();while ($row = mysql_fetch_array($result)) {$data[] = $row;}</code></pre><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p>上一节中，我们了解到通过循环可以获取一个查询的所有数据，在实际应用中，我们并不希望一次性获取数据表中的所有数据，那样性能会非常的低，因此会使用翻页功能，每页仅显示10条或者20条数据。</p><p>通过mysql的limit可以很容易的实现分页，limit m,n表示从m行后取n行数据，在PHP中我们需要构造m与n来实现获取某一页的所有数据。</p><p>假定当前页为$page，每页显示$n条数据，那么m为当前页前面所有的数据，既$m = ($page-1) * $n，在知道了翻页原理以后，那么我们很容易通过构造SQL语句在PHP中实现数据翻页。</p><pre><code>$page = 2;$n = 2;$m = ($page - 1) * $n;$sql = &quot;select * from user limit $m, $n&quot;;$result = mysql_query($sql);//循环获取当前页的数据$data = array();while ($row = mysql_fetch_assoc($result)) {$data[] = $row;}</code></pre><p>在上面的例子中，我们使用了$m与$n变量来表示偏移量与每页数据条数，但我们推荐使用更有意义的变量名来表示，比如$pagesize, $start, $offset等，这样更容易理解，有助于团队协作开发。</p><h2 id="更新与删除"><a href="#更新与删除" class="headerlink" title="更新与删除"></a>更新与删除</h2><p>数据的更新与删除相对比较简单，只需要构建好相应的sql语句，然后调用mysql_query执行就能完成相应的更新与删除操作。</p><pre><code>$sql = &quot;update user set name = &apos;曹操&apos; where id=2 limit 1&quot;;if (mysql_query($sql)) {echo &apos;更新成功&apos;;}</code></pre><p>同样的删除可以使用类似以下的代码：</p><pre><code>$sql = &quot;delete from user where id=2 limit 1&quot;;if (mysql_query($sql)) {echo &apos;删除成功&apos;;}</code></pre><p>对于删除与更新操作，可以通过mysql_affected_rows函数来获取更新过的数据行数，如果数据没有变化，则结果为0。</p><pre><code>$sql = &quot;update user set name = &apos;曹操&apos; where id=2 limit 1&quot;;if (mysql_query($sql)) {echo mysql_affected_rows();}</code></pre><h2 id="关闭数据库"><a href="#关闭数据库" class="headerlink" title="关闭数据库"></a>关闭数据库</h2><p>当数据库操作完成以后，可以使用mysql_close关闭数据库连接，默认的，当PHP执行完毕以后，会自动的关闭数据库连接。</p><pre><code>mysql_close();</code></pre><p>虽然PHP会自动关闭数据库连接，一般情况下已经满足需求，但是在对性能要求比较高的情况下，可以在进行完数据库操作之后尽快关闭数据库连接，以节省资源，提高性能。</p><p>在存在多个数据库连接的情况下，可以设定连接资源参数来关闭指定的数据库连接。</p><pre><code>$link = mysql_connect($host, $user, $pass);mysql_close($link);</code></pre><blockquote><p>关于数据库的操作这里只是简单的整理一下，后期或抽出专门的时间，使用专门的章节详细介绍使用与实战数据库的操作。</p></blockquote>]]></content>
    
    <summary type="html">
    
      关于数据库操作，在PHP开发中可谓是重中之重，其他开发想iOS，Android如果只是做一个简单的App可以不用对数据库操作，但是PHP开发中没有数据库操作就等于一尊雕塑，PHP中数据库首选MYSql，不用问为什么，因为他们是天合之作，谁用谁知道......
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="数据库操作" scheme="https://icocos.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>PHP——session和cookie</title>
    <link href="https://icocos.github.io/2018/12/13/PHP%E2%80%94%E2%80%94session%E5%92%8Ccookie/"/>
    <id>https://icocos.github.io/2018/12/13/PHP——session和cookie/</id>
    <published>2018-12-13T15:29:10.000Z</published>
    <updated>2018-12-28T02:53:05.342Z</updated>
    
    <content type="html"><![CDATA[<p>关于session和cookie之前做iOS开发的时候听过，也试着去了解过，但是因为项目中并没有实际应用就没有研究过了，但是PHP开发的话必须了解并熟悉他们的使用，我目前的理解就是。cookie数据保存在客户端,session数据保存在服务器端……</p><h2 id="session和cookie"><a href="#session和cookie" class="headerlink" title="session和cookie"></a>session和cookie</h2><h2 id="cookie简介"><a href="#cookie简介" class="headerlink" title="cookie简介"></a>cookie简介</h2><p>Cookie是存储在客户端浏览器中的数据，我们通过Cookie来跟踪与存储用户数据。一般情况下，Cookie通过HTTP headers从服务端返回到客户端。多数web程序都支持Cookie的操作，因为Cookie是存在于HTTP的标头之中，所以必须在其他信息输出以前进行设置，类似于header函数的使用限制。</p><blockquote><p>PHP通过setcookie函数进行Cookie的设置，任何从浏览器发回的Cookie，PHP都会自动的将他存储在$_COOKIE的全局变量之中，因此我们可以通过$_COOKIE[‘key’]的形式来读取某个Cookie值。</p></blockquote><p>PHP中的Cookie具有非常广泛的使用，经常用来存储用户的登录信息，购物车等，且在使用会话Session时通常使用Cookie来存储会话id来识别用户，Cookie具备有效期，当有效期结束之后，Cookie会自动的从客户端删除。同时为了进行安全控制，Cookie还可以设置域跟路径，我们会在稍后的章节中详细的讲解他们。</p><h3 id="官方文档的介绍"><a href="#官方文档的介绍" class="headerlink" title="官方文档的介绍"></a>官方文档的介绍</h3><pre><code>PHP 透明地支持 HTTP cookie。cookie 是一种在远程浏览器端储存数据并以此来跟踪和识别用户的机制。可以用 setcookie() 或 setrawcookie() 函数来设置 cookie。cookie 是 HTTP 标头的一部分，因此 setcookie() 函数必须在其它信息被输出到浏览器前调用，这和对 header() 函数的限制类似。可以使用输出缓冲函数来延迟脚本的输出，直到按需要设置好了所有的 cookie 或者其它 HTTP 标头。如果 variables_order 中包括“C”，则任何从客户端发送的 cookie 都会被自动包括进 $_COOKIE 自动全局数组。如果希望对一个 cookie 变量设置多个值，则需在 cookie 的名称后加 [] 符号。根据 register_globals 的设置，可以从 cookie 建立普通的 PHP 变量。但是不推荐依赖于此特性，因为出于安全原因此选项通常是关闭的。在早期的 PHP 版本中，当 track_vars 配置选项打开时（此选项自 PHP 4.0.3 后总是打开的），系统还会设定 $HTTP_COOKIE_VARS。会话机制（Session）在 PHP 中用于保存并发访问中的一些数据。这使可以帮助创建更为人性化的程序，增加站点的吸引力。关于会话机制的更多信息，请参见会话处理函数一章。</code></pre><h2 id="设置cookie"><a href="#设置cookie" class="headerlink" title="设置cookie"></a>设置cookie</h2><p>PHP设置Cookie最常用的方法就是使用setcookie函数，setcookie具有7个可选参数，我们常用到的为前5个：</p><pre><code>name（ Cookie名）可以通过$_COOKIE[&apos;name&apos;] 进行访问value（Cookie的值）expire（过期时间）Unix时间戳格式，默认为0，表示浏览器关闭即失效path（有效路径）如果路径设置为&apos;/&apos;，则整个网站都有效domain（有效域）默认整个域名都有效，如果设置了&apos;www.imooc.com&apos;,则只在www子域中有效</code></pre><p>使用案例</p><pre><code>$value = &apos;test&apos;;setcookie(&quot;TestCookie&quot;, $value);setcookie(&quot;TestCookie&quot;, $value, time()+3600);  //有效期一小时setcookie(&quot;TestCookie&quot;, $value, time()+3600, &quot;/path/&quot;, &quot;imooc.com&quot;); //设置路径与域</code></pre><p>PHP中还有一个设置Cookie的函数setrawcookie，setrawcookie跟setcookie基本一样，唯一的不同就是value值不会自动的进行urlencode，因此在需要的时候要手动的进行urlencode。</p><pre><code>setrawcookie(&apos;cookie_name&apos;, rawurlencode($value), time()+60*60*24*365); </code></pre><p>因为Cookie是通过HTTP标头进行设置的，所以也可以直接使用header方法进行设置。</p><pre><code>header(&quot;Set-Cookie:cookie_name=value&quot;);</code></pre><h2 id="cookie的删除与过期时间"><a href="#cookie的删除与过期时间" class="headerlink" title="cookie的删除与过期时间"></a>cookie的删除与过期时间</h2><p>通过前面的章节，我们了解了设置cookie的函数，但是我们却发现php中没有删除Cookie的函数，在PHP中删除cookie也是采用setcookie函数来实现。</p><pre><code>setcookie(&apos;test&apos;, &apos;&apos;, time()-1); </code></pre><blockquote><p>可以看到将cookie的过期时间设置到当前时间之前，则该cookie会自动失效，也就达到了删除cookie的目的。之所以这么设计是因为cookie是通过HTTP的标头来传递的，客户端根据服务端返回的Set-Cookie段来进行cookie的设置，如果删除cookie需要使用新的Del-Cookie来实现，则HTTP头就会变得复杂，实际上仅通过Set-Cookie就可以简单明了的实现Cookie的设置、更新与删除。</p></blockquote><p>了解原理以后，我们也可以直接通过header来删除cookie。</p><pre><code>header(&quot;Set-Cookie:test=1393832059; expires=&quot;.gmdate(&apos;D, d M Y H:i:s \G\M\T&apos;, time()-1));</code></pre><p>这里用到了gmdate，用来生成格林威治标准时间，以便排除时差的影响。</p><h2 id="cookie的有效路径"><a href="#cookie的有效路径" class="headerlink" title="cookie的有效路径"></a>cookie的有效路径</h2><p>cookie中的路径用来控制设置的cookie在哪个路径下有效，默认为’/‘，在所有路径下都有，当设定了其他路径之后，则只在设定的路径以及子路径下有效，例如：</p><pre><code>setcookie(&apos;test&apos;, time(), 0, &apos;/path&apos;);</code></pre><p>上面的设置会使test在/path以及子路径/path/abc下都有效，但是在根目录下就读取不到test的cookie值。</p><p>一般情况下，大多是使用所有路径的，只有在极少数有特殊需求的时候，会设置路径，这种情况下只在指定的路径中才会传递cookie值，可以节省数据的传输，增强安全性以及提高性能。</p><p>当我们设置了有效路径的时候，不在当前路径的时候则看不到当前cookie。</p><pre><code>setcookie(&apos;test&apos;, &apos;1&apos;,0, &apos;/path&apos;);  var_dump($_COOKIE[&apos;test&apos;]);  </code></pre><h2 id="session与cookie的异同"><a href="#session与cookie的异同" class="headerlink" title="session与cookie的异同"></a>session与cookie的异同</h2><p>cookie将数据存储在客户端，建立起用户与服务器之间的联系，通常可以解决很多问题，但是cookie仍然具有一些局限：</p><pre><code>cookie相对不是太安全，容易被盗用导致cookie欺骗单个cookie的值最大只能存储4k每次请求都要进行网络传输，占用带宽</code></pre><p>session是将用户的会话数据存储在服务端，没有大小限制，通过一个session_id进行用户识别，PHP默认情况下session id是通过cookie来保存的，因此从某种程度上来说，seesion依赖于cookie。但这不是绝对的，session id也可以通过参数来实现，只要能将session id传递到服务端进行识别的机制都可以使用session。</p><pre><code>&lt;?php//开始使用sessionsession_start();//设置一个session$_SESSION[&apos;test&apos;] = time();//显示当前的session_idecho &quot;session_id:&quot;.session_id();echo &quot;&lt;br&gt;&quot;;//读取session值echo $_SESSION[&apos;test&apos;];//销毁一个sessionunset($_SESSION[&apos;test&apos;]);echo &quot;&lt;br&gt;&quot;;var_dump($_SESSION);</code></pre><h2 id="使用session"><a href="#使用session" class="headerlink" title="使用session"></a>使用session</h2><p>在PHP中使用session非常简单，先执行session_start方法开启session，然后通过全局变量$_SESSION进行session的读写。</p><pre><code>session_start();$_SESSION[&apos;test&apos;] = time();var_dump($_SESSION);</code></pre><p>session会自动的对要设置的值进行encode与decode，因此session可以支持任意数据类型，包括数据与对象等。</p><pre><code>session_start();$_SESSION[&apos;ary&apos;] = array(&apos;name&apos; =&gt; &apos;jobs&apos;);$_SESSION[&apos;obj&apos;] = new stdClass();var_dump($_SESSION);</code></pre><p>默认情况下，session是以文件形式存储在服务器上的，因此当一个页面开启了session之后，会独占这个session文件，这样会导致当前用户的其他并发访问无法执行而等待。可以采用缓存或者数据库的形式存储来解决这个问题，这个我们会在一些高级的课程中讲到。</p><h2 id="删除与销毁session"><a href="#删除与销毁session" class="headerlink" title="删除与销毁session"></a>删除与销毁session</h2><p>删除某个session值可以使用PHP的unset函数，删除后就会从全局变量$_SESSION中去除，无法访问。</p><pre><code>session_start();$_SESSION[&apos;name&apos;] = &apos;jobs&apos;;unset($_SESSION[&apos;name&apos;]);echo $_SESSION[&apos;name&apos;]; //提示name不存在</code></pre><p>如果要删除所有的session，可以使用session_destroy函数销毁当前session，session_destroy会删除所有数据，但是session_id仍然存在。</p><pre><code>session_start();$_SESSION[&apos;name&apos;] = &apos;jobs&apos;;$_SESSION[&apos;time&apos;] = time();session_destroy();</code></pre><p>值得注意的是，session_destroy并不会立即的销毁全局变量$_SESSION中的值，只有当下次再访问的时候，$_SESSION才为空，因此如果需要立即销毁$_SESSION，可以使用unset函数。</p><pre><code>session_start();$_SESSION[&apos;name&apos;] = &apos;jobs&apos;;$_SESSION[&apos;time&apos;] = time();unset($_SESSION);session_destroy(); var_dump($_SESSION); //此时已为空</code></pre><p>如果需要同时销毁cookie中的session_id，通常在用户退出的时候可能会用到，则还需要显式的调用setcookie方法删除session_id的cookie值。</p><h2 id="session实战-登录"><a href="#session实战-登录" class="headerlink" title="session实战-登录"></a>session实战-登录</h2><p>session可以用来存储多种类型的数据，因此具有很多的用途，常用来存储用户的登录信息，购物车数据，或者一些临时使用的暂存数据等。</p><p>用户在登录成功以后，通常可以将用户的信息存储在session中，一般的会单独的将一些重要的字段单独存储，然后所有的用户信息独立存储。</p><pre><code>$_SESSION[&apos;uid&apos;] = $userinfo[&apos;uid&apos;];$_SESSION[&apos;userinfo&apos;] = $userinfo;</code></pre><p>一般来说，登录信息既可以存储在sessioin中，也可以存储在cookie中，他们之间的差别在于session可以方便的存取多种数据类型，而cookie只支持字符串类型，同时对于一些安全性比较高的数据，cookie需要进行格式化与加密存储，而session存储在服务端则安全性较高。</p><pre><code>&lt;?phpsession_start();//假设用户登录成功获得了以下用户数据$userinfo = array(&apos;uid&apos;  =&gt; 10000,&apos;name&apos; =&gt; &apos;spark&apos;,&apos;email&apos; =&gt; &apos;spark@imooc.com&apos;,&apos;sex&apos;  =&gt; &apos;man&apos;,&apos;age&apos;  =&gt; &apos;18&apos;);header(&quot;content-type:text/html; charset=utf-8&quot;);/* 将用户信息保存到session中 */$_SESSION[&apos;uid&apos;] = $userinfo[&apos;uid&apos;];$_SESSION[&apos;name&apos;] = $userinfo[&apos;name&apos;];$_SESSION[&apos;userinfo&apos;] = $userinfo;//* 将用户数据保存到cookie中的一个简单方法 */$secureKey = &apos;imooc&apos;; //加密密钥$str = serialize($userinfo); //将用户信息序列化//用户信息加密前$str = base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, md5($secureKey), $str, MCRYPT_MODE_ECB));//用户信息加密后//将加密后的用户数据存储到cookie中setcookie(&apos;userinfo&apos;, $str);//当需要使用时进行解密$str = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, md5($secureKey), base64_decode($str), MCRYPT_MODE_ECB);$uinfo = unserialize($str);echo &quot;解密后的用户信息：&lt;br&gt;&quot;;print_r($uinfo);</code></pre>]]></content>
    
    <summary type="html">
    
      关于session和cookie之前做iOS开发的时候听过，也试着去了解过，但是因为项目中并没有实际应用就没有研究过了，但是PHP开发的话必须了解并熟悉他们的使用，我目前的理解就是。cookie数据保存在客户端,session数据保存在服务器端......
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="session和cookie" scheme="https://icocos.github.io/tags/session%E5%92%8Ccookie/"/>
    
  </entry>
  
  <entry>
    <title>PHP——GET/POST方式总结</title>
    <link href="https://icocos.github.io/2018/12/12/PHP%E2%80%94%E2%80%94GET-POST%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://icocos.github.io/2018/12/12/PHP——GET-POST方式总结/</id>
    <published>2018-12-12T15:28:43.000Z</published>
    <updated>2018-12-28T02:49:41.611Z</updated>
    
    <content type="html"><![CDATA[<p> 关于PHP开发中大部分使用的是GET和POST的方式，这是HTTP的请求方式，当然还有其他的方式，有机会可以了解一下……</p><h2 id="GET-POST方式总结"><a href="#GET-POST方式总结" class="headerlink" title="GET/POST方式总结"></a>GET/POST方式总结</h2><p>HTTP协议中共定义了八种方法或者叫“动作”来表明对Request-URI指定的资源的不同操作方式，具体介绍如下： </p><pre><code>OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送&apos;*&apos;的请求来测试服务器的功能性。 HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 GET：向特定的资源发出请求。 POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。 PUT：向指定资源位置上传其最新内容。 DELETE：请求服务器删除Request-URI所标识的资源。 TRACE：回显服务器收到的请求，主要用于测试或诊断。 </code></pre><p>CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p><blockquote><p>虽然HTTP的请求方式有8种，但是我们在实际应用中常用的也就是get和post，其他请求方式也都可以通过这两种方式间接的来实现。</p></blockquote><h2 id="这里主要说其中最重要的两种：GET-和-POST"><a href="#这里主要说其中最重要的两种：GET-和-POST" class="headerlink" title="这里主要说其中最重要的两种：GET 和 POST"></a>这里主要说其中最重要的两种：GET 和 POST</h2><p>在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。</p><pre><code>GET - 从指定的资源请求数据。POST - 向指定的资源提交要被处理的数据</code></pre><h3 id="GET-方法"><a href="#GET-方法" class="headerlink" title="GET 方法"></a>GET 方法</h3><blockquote><p>请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：</p></blockquote><pre><code>/test/demo_form.asp?name1=value1&amp;name2=value2</code></pre><p>有关 GET 请求的其他一些注释：</p><pre><code>GET 请求可被缓存GET 请求保留在浏览器历史记录中GET 请求可被收藏为书签GET 请求不应在处理敏感数据时使用GET 请求有长度限制GET 请求只应当用于取回数据</code></pre><h3 id="POST-方法"><a href="#POST-方法" class="headerlink" title="POST 方法"></a>POST 方法</h3><p>请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：</p><pre><code>POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2</code></pre><p>有关 POST 请求的其他一些注释：</p><pre><code>POST 请求不会被缓存POST 请求不会保留在浏览器历史记录中POST 不能被收藏为书签POST 请求对数据长度没有要求</code></pre><h3 id="下面的表格比较了两种-HTTP-方法：GET-和-POST。"><a href="#下面的表格比较了两种-HTTP-方法：GET-和-POST。" class="headerlink" title="下面的表格比较了两种 HTTP 方法：GET 和 POST。"></a>下面的表格比较了两种 HTTP 方法：GET 和 POST。</h3><table><thead><tr><th>区别</th><th style="text-align:center">GET</th><th style="text-align:right">POST</th></tr></thead><tbody><tr><td>后退按钮/刷新</td><td style="text-align:center">无害</td><td style="text-align:right">数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td></tr><tr><td>书签</td><td style="text-align:center">可收藏为书签</td><td style="text-align:right">不可收藏为书签</td></tr><tr><td>缓存</td><td style="text-align:center">能被缓存</td><td style="text-align:right">不能缓存</td></tr><tr><td>编码类型</td><td style="text-align:center">application/x-www-form-urlencoded</td><td style="text-align:right">application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td></tr><tr><td>历史</td><td style="text-align:center">参数保留在浏览器历史中。</td><td style="text-align:right">参数不会保存在浏览器历史中。</td></tr><tr><td>对数据长度的限制</td><td style="text-align:center">是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td><td style="text-align:right">无限制。</td></tr><tr><td>对数据类型的限制</td><td style="text-align:center">只允许 ASCII 字符。</td><td style="text-align:right">没有限制。也允许二进制数据。</td></tr><tr><td>安全性</td><td style="text-align:center">与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。</td><td style="text-align:right">在发送密码或其他敏感信息时绝不要使用 GET ！    POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td></tr><tr><td>可见性</td><td style="text-align:center">数据在 URL 中对所有人都是可见的。</td><td style="text-align:right">数据不会显示在 URL 中。</td></tr></tbody></table><h2 id="PHP之GET-POST方式总结（六种）"><a href="#PHP之GET-POST方式总结（六种）" class="headerlink" title="PHP之GET/POST方式总结（六种）"></a>PHP之GET/POST方式总结（六种）</h2><h3 id="方法1-用file-get-contents-以get方式获取内容："><a href="#方法1-用file-get-contents-以get方式获取内容：" class="headerlink" title="方法1: 用file_get_contents 以get方式获取内容："></a>方法1: 用file_get_contents 以get方式获取内容：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line"><span class="variable">$url</span>=<span class="string">'http://www.jb51.net/'</span>;</span><br><span class="line"><span class="variable">$html</span> = file_get_contents(<span class="variable">$url</span>);</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$html</span>;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="方法2-用fopen打开url-以get方式获取内容："><a href="#方法2-用fopen打开url-以get方式获取内容：" class="headerlink" title="方法2: 用fopen打开url, 以get方式获取内容："></a>方法2: 用fopen打开url, 以get方式获取内容：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line"><span class="variable">$fp</span> = fopen(<span class="variable">$url</span>, ‘r<span class="string">');</span></span><br><span class="line"><span class="string">stream_get_meta_data($fp);</span></span><br><span class="line"><span class="string">while(!feof($fp)) &#123;</span></span><br><span class="line"><span class="string">$result .= fgets($fp, 1024);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">echo “url body: $result”;</span></span><br><span class="line"><span class="string">fclose($fp);</span></span><br><span class="line"><span class="string">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="方法3：用file-get-contents函数-以post方式获取url"><a href="#方法3：用file-get-contents函数-以post方式获取url" class="headerlink" title="方法3：用file_get_contents函数,以post方式获取url"></a>方法3：用file_get_contents函数,以post方式获取url</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line"><span class="variable">$data</span> = array (‘foo<span class="string">' =&gt; ‘bar'</span>);</span><br><span class="line"><span class="variable">$data</span> = http_build_query(<span class="variable">$data</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$opts</span> = array (</span><br><span class="line">‘http<span class="string">' =&gt; array (</span></span><br><span class="line"><span class="string">‘method'</span> =&gt; ‘POST<span class="string">',</span></span><br><span class="line"><span class="string">‘header'</span>=&gt; “Content-type: application/x-www-form-urlencodedrn” .</span><br><span class="line">“Content-Length: ” . strlen(<span class="variable">$data</span>) . “rn”,</span><br><span class="line">‘content<span class="string">' =&gt; $data</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$context = stream_context_create($opts);</span></span><br><span class="line"><span class="string">$html = file_get_contents(‘http://localhost/e/admin/test.html'</span>, <span class="literal">false</span>, <span class="variable">$context</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$html</span>;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="方法4：用fsockopen函数打开url，以get方式获取完整的数据，包括header和body-fsockopen需要-PHP-ini-中-allow-url-fopen-选项开启"><a href="#方法4：用fsockopen函数打开url，以get方式获取完整的数据，包括header和body-fsockopen需要-PHP-ini-中-allow-url-fopen-选项开启" class="headerlink" title="方法4：用fsockopen函数打开url，以get方式获取完整的数据，包括header和body,fsockopen需要 PHP.ini 中 allow_url_fopen 选项开启"></a>方法4：用fsockopen函数打开url，以get方式获取完整的数据，包括header和body,fsockopen需要 PHP.ini 中 allow_url_fopen 选项开启</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line"><span class="keyword">function</span> get_url (<span class="variable">$url</span>,<span class="variable">$cookie</span>=<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$url</span> = parse_url(<span class="variable">$url</span>);</span><br><span class="line"><span class="variable">$query</span> = <span class="variable">$url</span>[path].”?”.<span class="variable">$url</span>[query];</span><br><span class="line"><span class="built_in">echo</span> “Query:”.<span class="variable">$query</span>;</span><br><span class="line"><span class="variable">$fp</span> = fsockopen( <span class="variable">$url</span>[host], <span class="variable">$url</span>[port]?<span class="variable">$url</span>[port]:80 , <span class="variable">$errno</span>, <span class="variable">$errstr</span>, 30);</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$fp</span>) &#123;</span><br><span class="line"><span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="variable">$request</span> = “GET <span class="variable">$query</span> HTTP/1.1rn”;</span><br><span class="line"><span class="variable">$request</span> .= “Host: <span class="variable">$url</span>[host]rn”;</span><br><span class="line"><span class="variable">$request</span> .= “Connection: Closern”;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$cookie</span>) <span class="variable">$request</span>.=”Cookie:  <span class="variable">$cookien</span>”;</span><br><span class="line"><span class="variable">$request</span>.=”rn”;</span><br><span class="line">fwrite(<span class="variable">$fp</span>,<span class="variable">$request</span>);</span><br><span class="line"><span class="keyword">while</span>(!@feof(<span class="variable">$fp</span>)) &#123;</span><br><span class="line"><span class="variable">$result</span> .= @fgets(<span class="variable">$fp</span>, 1024);</span><br><span class="line">&#125;</span><br><span class="line">fclose(<span class="variable">$fp</span>);</span><br><span class="line"><span class="built_in">return</span> <span class="variable">$result</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//获取url的html部分，去掉header</span><br><span class="line"><span class="keyword">function</span> GetUrlHTML(<span class="variable">$url</span>,<span class="variable">$cookie</span>=<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$rowdata</span> = get_url(<span class="variable">$url</span>,<span class="variable">$cookie</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$rowdata</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$body</span>= stristr(<span class="variable">$rowdata</span>,”rnrn”);</span><br><span class="line"><span class="variable">$body</span>=substr(<span class="variable">$body</span>,4,strlen(<span class="variable">$body</span>));</span><br><span class="line"><span class="built_in">return</span> <span class="variable">$body</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="方法5：用fsockopen函数打开url，以POST方式获取完整的数据，包括header和body"><a href="#方法5：用fsockopen函数打开url，以POST方式获取完整的数据，包括header和body" class="headerlink" title="方法5：用fsockopen函数打开url，以POST方式获取完整的数据，包括header和body"></a>方法5：用fsockopen函数打开url，以POST方式获取完整的数据，包括header和body</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line"><span class="keyword">function</span> HTTP_Post(<span class="variable">$URL</span>,<span class="variable">$data</span>,<span class="variable">$cookie</span>, <span class="variable">$referrer</span>=”<span class="string">")</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// parsing the given URL</span></span><br><span class="line"><span class="string"><span class="variable">$URL_Info</span>=parse_url(<span class="variable">$URL</span>);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// Building referrer</span></span><br><span class="line"><span class="string">if(<span class="variable">$referrer</span>==”"</span>) // <span class="keyword">if</span> not given use this script as referrer</span><br><span class="line"><span class="variable">$referrer</span>=”111″;</span><br><span class="line"></span><br><span class="line">// making string from <span class="variable">$data</span></span><br><span class="line">foreach(<span class="variable">$data</span> as <span class="variable">$key</span>=&gt;<span class="variable">$value</span>)</span><br><span class="line"><span class="variable">$values</span>[]=”<span class="variable">$key</span>=”.urlencode(<span class="variable">$value</span>);</span><br><span class="line"><span class="variable">$data_string</span>=implode(“&amp;”,<span class="variable">$values</span>);</span><br><span class="line"></span><br><span class="line">// Find out <span class="built_in">which</span> port is needed – <span class="keyword">if</span> not given use standard (=80)</span><br><span class="line"><span class="keyword">if</span>(!isset(<span class="variable">$URL_Info</span>[<span class="string">"port"</span>]))</span><br><span class="line"><span class="variable">$URL_Info</span>[<span class="string">"port"</span>]=80;</span><br><span class="line"></span><br><span class="line">// building POST-request:</span><br><span class="line"><span class="variable">$request</span>.=”POST “.<span class="variable">$URL_Info</span>[<span class="string">"path"</span>].” HTTP/1.1n”;</span><br><span class="line"><span class="variable">$request</span>.=”Host: “.<span class="variable">$URL_Info</span>[<span class="string">"host"</span>].”n”;</span><br><span class="line"><span class="variable">$request</span>.=”Referer: <span class="variable">$referern</span>”;</span><br><span class="line"><span class="variable">$request</span>.=”Content-type: application/x-www-form-urlencodedn”;</span><br><span class="line"><span class="variable">$request</span>.=”Content-length: “.strlen(<span class="variable">$data_string</span>).”n”;</span><br><span class="line"><span class="variable">$request</span>.=”Connection: closen”;</span><br><span class="line"></span><br><span class="line"><span class="variable">$request</span>.=”Cookie:  <span class="variable">$cookien</span>”;</span><br><span class="line"></span><br><span class="line"><span class="variable">$request</span>.=”n”;</span><br><span class="line"><span class="variable">$request</span>.=<span class="variable">$data_string</span>.”n”;</span><br><span class="line"></span><br><span class="line"><span class="variable">$fp</span> = fsockopen(<span class="variable">$URL_Info</span>[<span class="string">"host"</span>],<span class="variable">$URL_Info</span>[<span class="string">"port"</span>]);</span><br><span class="line">fputs(<span class="variable">$fp</span>, <span class="variable">$request</span>);</span><br><span class="line"><span class="keyword">while</span>(!feof(<span class="variable">$fp</span>)) &#123;</span><br><span class="line"><span class="variable">$result</span> .= fgets(<span class="variable">$fp</span>, 1024);</span><br><span class="line">&#125;</span><br><span class="line">fclose(<span class="variable">$fp</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> <span class="variable">$result</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="方法6-使用curl库，使用curl库之前，可能需要查看一下php-ini是否已经打开了curl扩展"><a href="#方法6-使用curl库，使用curl库之前，可能需要查看一下php-ini是否已经打开了curl扩展" class="headerlink" title="方法6:使用curl库，使用curl库之前，可能需要查看一下php.ini是否已经打开了curl扩展"></a>方法6:使用curl库，使用curl库之前，可能需要查看一下php.ini是否已经打开了curl扩展</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line"><span class="variable">$ch</span> = curl_init();</span><br><span class="line"><span class="variable">$timeout</span> = 5;</span><br><span class="line">curl_setopt (<span class="variable">$ch</span>, CURLOPT_URL, ‘http://www.jb51.net/<span class="string">');</span></span><br><span class="line"><span class="string">curl_setopt ($ch, CURLOPT_RETURNTRANSFER, 1);</span></span><br><span class="line"><span class="string">curl_setopt ($ch, CURLOPT_CONNECTTIMEOUT, $timeout);</span></span><br><span class="line"><span class="string">$file_contents = curl_exec($ch);</span></span><br><span class="line"><span class="string">curl_close($ch);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">echo $file_contents;</span></span><br><span class="line"><span class="string">?&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      关于PHP开发中大部分使用的是GET和POST的方式，这是HTTP的请求方式，当然还有其他的方式，有机会可以了解一下......
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="GET/POST方式总结" scheme="https://icocos.github.io/tags/GET-POST%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>PHP——CURL初探</title>
    <link href="https://icocos.github.io/2018/12/12/PHP%E2%80%94%E2%80%94CURL%E5%88%9D%E6%8E%A2/"/>
    <id>https://icocos.github.io/2018/12/12/PHP——CURL初探/</id>
    <published>2018-12-12T12:30:45.000Z</published>
    <updated>2018-12-28T02:52:47.204Z</updated>
    
    <content type="html"><![CDATA[<p> cURL 是一个利用URL语法规定来传输文件和数据的工具，支持很多协议，如HTTP、FTP、TELNET等。最爽的是，PHP也支持 cURL 库。本文将介绍 cURL 的一些高级特性，以及在PHP中如何运用它……</p><h2 id="CURL初探"><a href="#CURL初探" class="headerlink" title="CURL初探"></a>CURL初探</h2><h2 id="1-cURL介绍"><a href="#1-cURL介绍" class="headerlink" title="1.cURL介绍"></a>1.cURL介绍</h2><p>　　cURL 是一个利用URL语法规定来传输文件和数据的工具，支持很多协议，如HTTP、FTP、TELNET等。最爽的是，PHP也支持 cURL 库。本文将介绍 cURL 的一些高级特性，以及在PHP中如何运用它。</p><h2 id="2-基本结构"><a href="#2-基本结构" class="headerlink" title="2.基本结构"></a>2.基本结构</h2><pre><code>在学习更为复杂的功能之前，先来看一下在PHP中建立cURL请求的基本步骤：</code></pre><h3 id="（1）初始化"><a href="#（1）初始化" class="headerlink" title="（1）初始化"></a>（1）初始化</h3><pre><code>　　　　curl_init()</code></pre><h3 id="（2）设置变量"><a href="#（2）设置变量" class="headerlink" title="（2）设置变量"></a>（2）设置变量</h3><p>　　　　curl_setopt() 。最为重要，一切玄妙均在此。有一长串cURL参数可供设置，它们能指定URL请求的各个细节。要一次性全部看完并理解可能比较困难，所以今天我们只试一下那些更常用也更有用的选项。</p><h3 id="（3）执行并获取结果"><a href="#（3）执行并获取结果" class="headerlink" title="（3）执行并获取结果"></a>（3）执行并获取结果</h3><pre><code>　　　　curl_exec()</code></pre><h3 id="（4）释放cURL句柄"><a href="#（4）释放cURL句柄" class="headerlink" title="（4）释放cURL句柄"></a>（4）释放cURL句柄</h3><pre><code>　　　　curl_close()</code></pre><h2 id="3-cURL实现Get和Post"><a href="#3-cURL实现Get和Post" class="headerlink" title="3.cURL实现Get和Post"></a>3.cURL实现Get和Post</h2><h3 id="3-1-Get方式实现"><a href="#3-1-Get方式实现" class="headerlink" title="3.1 Get方式实现"></a>3.1 Get方式实现</h3><pre><code>　　//初始化　　$ch = curl_init();　　//设置选项，包括URL　　curl_setopt($ch, CURLOPT_URL, &quot;http://www.jb51.net&quot;);　　curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);　　curl_setopt($ch, CURLOPT_HEADER, 0);　　//执行并获取HTML文档内容　　$output = curl_exec($ch);　　//释放curl句柄　　curl_close($ch);　　//打印获得的数据　　print_r($output);</code></pre><h3 id="3-2-Post方式实现"><a href="#3-2-Post方式实现" class="headerlink" title="3.2 Post方式实现"></a>3.2 Post方式实现</h3><pre><code>　　$url = &quot;http://localhost/web_services.php&quot;;　　$post_data = array (&quot;username&quot; =&gt; &quot;bob&quot;,&quot;key&quot; =&gt; &quot;12345&quot;);　　$ch = curl_init();　　curl_setopt($ch, CURLOPT_URL, $url);　　curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);　　// post数据　　curl_setopt($ch, CURLOPT_POST, 1);　　// post的变量　　curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);　　$output = curl_exec($ch);　　curl_close($ch);　　//打印获得的数据　　print_r($output);</code></pre><p>　　</p><p>　　以上方式获取到的数据是json格式的，使用json_decode函数解释成数组。</p><pre><code>　　$output_array = json_decode($output,true);</code></pre><p>　　如果使用json_decode($output)解析的话，将会得到object类型的数据。</p>]]></content>
    
    <summary type="html">
    
      cURL 是一个利用URL语法规定来传输文件和数据的工具，支持很多协议，如HTTP、FTP、TELNET等。最爽的是，PHP也支持 cURL 库。本文将介绍 cURL 的一些高级特性，以及在PHP中如何运用它......
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="CURL初探" scheme="https://icocos.github.io/tags/CURL%E5%88%9D%E6%8E%A2/"/>
    
  </entry>
  
  <entry>
    <title>PHP——分页与实现</title>
    <link href="https://icocos.github.io/2018/12/10/PHP%E2%80%94%E2%80%94%E5%88%86%E9%A1%B5%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://icocos.github.io/2018/12/10/PHP——分页与实现/</id>
    <published>2018-12-10T14:20:15.000Z</published>
    <updated>2018-12-28T02:49:10.250Z</updated>
    
    <content type="html"><![CDATA[<p>分页与实现….</p><h2 id="分页与实现"><a href="#分页与实现" class="headerlink" title="分页与实现"></a>分页与实现</h2><p>逻辑准备</p><p>实现分页，我们需要获取准备以下属性和方法</p><pre><code>属性{数据总条数每一页显示的条数计算出总页数获取当前是第几页显示上一页显示下一页显示首页显示尾页每一页的url数据限制limit}方法{构造函数计算总页数获取当前页获取上一页获取下一页获取首页获取尾页获取当前页面url获取上一页url获取下一页url获取首页url获取尾页irl生成limit记录重新生成url地址显示分页链接，显示分页情况}</code></pre><p>根据上面的逻辑，下一步将文字转换为代码</p><p>首先，我们先声明一个Page类，按照逻辑进行属性声明,并且进行初始化</p><pre><code>class Page{//记录总条数protected $total;//每页显示几条protected $nums;//总页数protected $totalPages;//当前页码protected $currentPage;//上一页页码protected $prevPage;//下一页页码protected $nextPage;//首页页码protected $firstPage;//尾页页码protected $endPage;//urlprotected $url;//limit,传到数据库的limitprotected $limit;//构造函数，初始化public function __construct($total, $nums){$this-&gt;total = $total;$this-&gt;nums = $nums;$this-&gt;totalPages = $this-&gt;getTotalPages();$this-&gt;currentPage = $this-&gt;getCurrentPage();$this-&gt;getPrevPage();$this-&gt;getNextPage();$this-&gt;getFirstPage();$this-&gt;getEndPage();$this-&gt;getUrl();}}</code></pre><p>接下来我们开始完善方法</p><p>计算总页数</p><pre><code>protected funciton getTotalPages(){return ceil($this-&gt;total / $this-&gt;$nums);}</code></pre><p>获取当前页码</p><pre><code>protected function getCurentPage(){//判断如果存在page参数并且page大于0，返回实际值，否则返回1if(isset($_GET[&apos;page&apos;]) &amp;&amp; intval($_GET[&apos;page&apos;]) &gt; 0){$this-&gt;currentPage = intval($_GET[&apos;page&apos;]);} else {$this-&gt;currentPage = 1;}return $this-&gt;currentPage;}</code></pre><p>获取上一页</p><pre><code>protected function getPrevPage(){$this-&gt;prevPage = $this-&gt;currentPage - 1;if($this-&gt;prevPage &lt;　１){$this-&gt;prevPage = 1;}return $this-&gt;prevPage;}</code></pre><p>获取下一页</p><pre><code>protected function getNextPage(){$this-&gt;nextPage = $this-&gt;currentPage + 1;return $this-&gt;nextPage;}</code></pre><p>获取首页</p><pre><code>protected function getFirstPage(){$this-&gt;firstPage = 1;return $this-&gt;firstPage;}</code></pre><p>获取尾页</p><pre><code>protected function getEndPage(){$this-&gt;endPage = $this-&gt;totalPages;return $this-&gt;endPage;}</code></pre><p>接下来开始拼接每个页码的url</p><p>获取当前页的url</p><pre><code>protected function getCurrentUrl(){return $this-&gt;url.&apos;$page=&apos;.$this-&gt;currentPage;}</code></pre><p>获取前一页的url</p><pre><code>protected function getPrevUrl(){return $this-&gt;url.&apos;&amp;page=&apos;.$this-&gt;prevPage;}</code></pre><p>获取下一页的url</p><pre><code>protected function getNextUrl(){return $this-&gt;url.&apos;&amp;page=&apos;.$this-&gt;nextPage;}</code></pre><p>获取首页的url</p><pre><code>protected function getFirstUrl(){return $this-&gt;url.&apos;&amp;page=&apos;.$this-&gt;firstPage;}</code></pre><p>获取尾页的url</p><pre><code>protected function getEndUrl(){return $this-&gt;url.&apos;&amp;page=&apos;.$this-&gt;endPage;}</code></pre><p>生成limit记录</p><pre><code>public function limit(){return ($this-&gt;currentPage - 1) * $this-&gt;nums.&apos;,&apos;.$this-&gt;nums;}</code></pre><p>生成url地址</p><pre><code>public function getUrl(){//获取当前页面的文件位置$url = $_SERVER[&apos;REQUEST_URI&apos;];//将url参数解析成数组$parse = parse_url($url);//获得域名地址$path  = $parse[&apos;path&apos;];//获取参数$query = isset($parse[&apos;query&apos;]) ? $parse[&apos;query&apos;] : false;//如果有参数，把page这个参数先给干掉，因为我们要重新拼接if($query){parse_str($query,$query);//干掉page参数，保留其他参数unset($query[&apos;page&apos;]);//http_build_query拼将参数拼接成请求$uri = $parse[&apos;path&apos;].&apos;?&apos;.http_build_query($query);} else {$uri = rtrim($parse[&apos;path&apos;],&apos;?&apos;).&apos;?&apos;;}//智能识别https和http协议和端口号$protocal = (isset($_SERVER[&apos;SERVER_PORT&apos;]) &amp;&amp; $_SERVER[&apos;SERVER_PORT&apos;] == 443) ? &apos;https://&apos; : &apos;http://&apos;;switch ($_SERVER[&apos;SERVER_PORT&apos;]) {case 80:case 443:$uri = $protocal.$_SERVER[&apos;SERVER_NAME&apos;].$uri;break;default:$uri = $protocal.$_SERVER[&apos;SERVER_NAME&apos;].&apos;:&apos;.$_SERVER[&apos;SERVER_PORT&apos;].$uri;break;}$this-&gt;url = $uri;}</code></pre><p>到此所有的逻辑方面都已经处理完啦，接下来的render()函数用来显示分页的链接</p><pre><code>public function render(){return array([&apos;first&apos; =&gt; $this-&gt;getFirstUrl()],[&apos;prev&apos;  =&gt; $this-&gt;getPrevUrl()],[&apos;current&apos; =&gt; $this-&gt;getCurrentUrl()],[&apos;next&apos;  =&gt; $this-&gt;getNextUrl()],[&apos;end&apos;   =&gt; $this-&gt;getEndUrl()]);}</code></pre><p>哦也，就这么愉快的结束啦,</p><p>使用方法如下</p><pre><code>//new一个对象$page = new Page(102,10);//打印出来上页/下页/首页/尾页……的urlvar_dump($page-&gt;render());</code></pre><p>后记</p><pre><code>$url = http://www.zhyunfe.com/OOP/Page.class.php?page=1parse_url($url):将url的文件路径和参数分开并保存到数组中...........................................  array (size=2).  &apos;path&apos; =&gt; string &apos;/OOP/Page.class.php&apos; (length=36).  &apos;query&apos; =&gt; string &apos;page=1&apos; (length=6).............................................$query = &quot;page=1&amp;num=2&amp;sex=男&quot;parse_str($query,$query):将带参数的字符串解析成数组........................................... array.  &apos;page&apos; =&gt; 1.  &apos;num&apos;  =&gt; 2.  &apos;sex&apos;  =&gt; &apos;男&apos;.............................................$query = [&apos;num&apos;=&gt;1,&apos;sex&apos;=&gt;&apos;男&apos;]http_build_query($query):使用给出的关联（或下标）数组生成一个经过 URL-encode 的请求字符串。 .......................................... string.  &quot;num=1&amp;&amp;sex=&apos;男&apos;&quot;............................................$_SERVER[&apos;SERVER_PORT&apos;] 获取端口号$_SERVER[&apos;SERVER_NAME&apos;] 当前运行脚本所在的服务器的主机名。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定</code></pre>]]></content>
    
    <summary type="html">
    
      分页与实现.....
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="分页与实现" scheme="https://icocos.github.io/tags/%E5%88%86%E9%A1%B5%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>PHP——正则表达式</title>
    <link href="https://icocos.github.io/2018/12/09/PHP%E2%80%94%E2%80%94%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://icocos.github.io/2018/12/09/PHP——正则表达式/</id>
    <published>2018-12-09T15:15:33.000Z</published>
    <updated>2018-12-28T02:49:02.275Z</updated>
    
    <content type="html"><![CDATA[<p>也许你之前听过，也许你之前用过，当然或许你之前没有听过或者没有接触过，说实话，做了这么久iOS开发，我也就用过两次，不知道是个人原因还是什么，但是其实正则表达式是几乎所有编程里面都有的，如果真的要说，估计要几个月，而且还说不完….. </p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><p>首先，如果你对正则感兴趣，我相信下面比较适合你的需求，不管是不是开始PHP开发，其他都是一样的，只是结合具体语言和语法实现想要的功能。</p><p><a href="http://www.cnblogs.com/deerchao/archive/2006/08/24/zhengzhe30fengzhongjiaocheng.html" target="_blank" rel="noopener">正则表达式30分钟入门教程</a></p><h2 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h2><p>正则表达式是对字符串进行操作的一种逻辑公式，就是用一些特定的字符组合成一个规则字符串，称之为正则匹配模式。</p><pre><code>$p = &apos;/apple/&apos;;$str = &quot;apple banna&quot;;if (preg_match($p, $str)) {echo &apos;matched&apos;;}</code></pre><p>其中字符串’/apple/‘就是一个正则表达式，他用来匹配源字符串中是否存在apple字符串。</p><p>PHP中使用PCRE库函数进行正则匹配，比如上例中的preg_match用于执行一个正则匹配，常用来判断一类字符模式是否存在。</p><h2 id="正则表达式基本语法"><a href="#正则表达式基本语法" class="headerlink" title="正则表达式基本语法"></a>正则表达式基本语法</h2><p>PCRE库函数中，正则匹配模式使用分隔符与元字符组成，分隔符可以是非数字、非反斜线、非空格的任意字符。经常使用的分隔符是正斜线(/)、hash符号(#) 以及取反符号(~)，例如：</p><pre><code>/foo bar/#^[^0-9]$#~php~</code></pre><p>如果模式中包含分隔符，则分隔符需要使用反斜杠（\）进行转义。</p><pre><code>/http:\/\//</code></pre><p>如果模式中包含较多的分割字符，建议更换其他的字符作为分隔符，也可以采用preg_quote进行转义。</p><pre><code>$p = &apos;http://&apos;;$p = &apos;/&apos;.preg_quote($p, &apos;/&apos;).&apos;/&apos;;echo $p;</code></pre><p>分隔符后面可以使用模式修饰符，模式修饰符包括：i, m, s, x等，例如使用i修饰符可以忽略大小写匹配：</p><pre><code>$str = &quot;Http://www.imooc.com/&quot;;if (preg_match(&apos;/http/i&apos;, $str)) {echo &apos;匹配成功&apos;;}</code></pre><h2 id="元字符与转义"><a href="#元字符与转义" class="headerlink" title="元字符与转义"></a>元字符与转义</h2><p>正则表达式中具有特殊含义的字符称之为元字符，常用的元字符有：</p><pre><code>\ 一般用于转义字符^ 断言目标的开始位置(或在多行模式下是行首)$ 断言目标的结束位置(或在多行模式下是行尾). 匹配除换行符外的任何字符(默认)[ 开始字符类定义] 结束字符类定义| 开始一个可选分支( 子组的开始标记) 子组的结束标记? 作为量词，表示 0 次或 1 次匹配。位于量词后面用于改变量词的贪婪特性。 (查阅量词)* 量词，0 次或多次匹配+ 量词，1 次或多次匹配{ 自定义量词开始标记} 自定义量词结束标记</code></pre><p>使用案例</p><pre><code>//下面的\s匹配任意的空白符，包括空格，制表符，换行符。[^\s]代表非空白符。[^\s]+表示一次或多次匹配非空白符。$p = &apos;/^我[^\s]+(苹果|香蕉)$/&apos;;$str = &quot;我喜欢吃苹果&quot;;if (preg_match($p, $str)) {echo &apos;匹配成功&apos;;}</code></pre><p>元字符具有两种使用场景，一种是可以在任何地方都能使用，另一种是只能在方括号内使用，在方括号内使用的有：</p><pre><code>\ 转义字符^ 仅在作为第一个字符(方括号内)时，表明字符类取反- 标记字符范围</code></pre><p>其中^在反括号外面，表示断言目标的开始位置，但在方括号内部则代表字符类取反，方括号内的减号-可以标记字符范围，例如0-9表示0到9之间的所有数字。</p><pre><code>//下面的\w匹配字母或数字或下划线。$p = &apos;/[\w\.\-]+@[a-z0-9\-]+\.(com|cn)/&apos;;$str = &quot;我的邮箱是Spark.eric@imooc.com&quot;;preg_match($p, $str, $match);echo $match[0];</code></pre><h2 id="两种常见模式：贪婪与懒惰"><a href="#两种常见模式：贪婪与懒惰" class="headerlink" title="两种常见模式：贪婪与懒惰"></a>两种常见模式：贪婪与懒惰</h2><p>正则表达式中每个元字符匹配一个字符，当使用+之后将会变的贪婪，它将匹配尽可能多的字符，但使用问号?字符时，它将尽可能少的匹配字符，既是懒惰模式。</p><h3 id="贪婪模式："><a href="#贪婪模式：" class="headerlink" title="贪婪模式："></a>贪婪模式：</h3><p>在可匹配与可不匹配的时候，优先匹配</p><pre><code>//下面的\d表示匹配数字$p = &apos;/\d+\-\d+/&apos;;$str = &quot;我的电话是010-12345678&quot;;preg_match($p, $str, $match);echo $match[0]; //结果为：010-12345678</code></pre><h3 id="懒惰模式："><a href="#懒惰模式：" class="headerlink" title="懒惰模式："></a>懒惰模式：</h3><p>在可匹配与可不匹配的时候，优先不匹配</p><pre><code>$p = &apos;/\d?\-\d?/&apos;;$str = &quot;我的电话是010-12345678&quot;;preg_match($p, $str, $match);echo $match[0];  //结果为：0-1</code></pre><p>当我们确切的知道所匹配的字符长度的时候，可以使用{}指定匹配字符数</p><pre><code>$p = &apos;/\d{3}\-\d{8}/&apos;;$str = &quot;我的电话是010-12345678&quot;;preg_match($p, $str, $match);echo $match[0]; //结果为：010-12345678</code></pre><h2 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h2><p>使用正则表达式的目的是为了实现比字符串处理函数更加灵活的处理方式，因此跟字符串处理函数一样，其主要用来判断子字符串是否存在、字符串替换、分割字符串、获取模式子串等。</p><p>PHP使用PCRE库函数来进行正则处理，通过设定好模式，然后调用相关的处理函数来取得匹配结果。</p><p>preg_match用来执行一个匹配，可以简单的用来判断模式是否匹配成功，或者取得一个匹配结果，他的返回值是匹配成功的次数0或者1，在匹配到1次以后就会停止搜索。</p><pre><code>$subject = &quot;abcdef&quot;;$pattern = &apos;/def/&apos;;preg_match($pattern, $subject, $matches);print_r($matches); //结果为：Array ( [0] =&gt; def )</code></pre><p>上面的代码简单的执行了一个匹配，简单的判断def是否能匹配成功，但是正则表达式的强大的地方是进行模式匹配，因此更多的时候，会使用模式：</p><pre><code>$subject = &quot;abcdef&quot;;$pattern = &apos;/a(.*?)d/&apos;;preg_match($pattern, $subject, $matches);print_r($matches); //结果为：Array ( [0] =&gt; abcd [1] =&gt; bc )</code></pre><p>通过正则表达式可以匹配一个模式，得到更多的有用的数据。</p><h2 id="查找匹配结果"><a href="#查找匹配结果" class="headerlink" title="查找匹配结果"></a>查找匹配结果</h2><p>preg_match只能匹配一次结果，但很多时候我们需要匹配所有的结果，preg_match_all可以循环获取一个列表的匹配结果数组。</p><pre><code>$p = &quot;|&lt;[^&gt;]+&gt;(.*?)&lt;/[^&gt;]+&gt;|i&quot;;$str = &quot;&lt;b&gt;example: &lt;/b&gt;&lt;div align=left&gt;this is a test&lt;/div&gt;&quot;;preg_match_all($p, $str, $matches);print_r($matches);</code></pre><p>可以使用preg_match_all匹配一个表格中的数据：</p><pre><code>$p = &quot;/&lt;tr&gt;&lt;td&gt;(.*?)&lt;\/td&gt;\s*&lt;td&gt;(.*?)&lt;\/td&gt;\s*&lt;\/tr&gt;/i&quot;;$str = &quot;&lt;table&gt; &lt;tr&gt;&lt;td&gt;Eric&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;John&lt;/td&gt;&lt;td&gt;26&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt;&quot;;preg_match_all($p, $str, $matches);print_r($matches);</code></pre><p>$matches结果排序为$matches[0]保存完整模式的所有匹配, $matches[1] 保存第一个子组的所有匹配，以此类推</p><h2 id="正则搜索与替换"><a href="#正则搜索与替换" class="headerlink" title="正则搜索与替换"></a>正则搜索与替换</h2><p>正则表达式的搜索与替换在某些方面具有重要用途，比如调整目标字符串的格式，改变目标字符串中匹配字符串的顺序等。</p><p>例如我们可以简单的调整字符串的日期格式：</p><pre><code>$string = &apos;April 15, 2014&apos;;$pattern = &apos;/(\w+) (\d+), (\d+)/i&apos;;$replacement = &apos;$3, ${1} $2&apos;;echo preg_replace($pattern, $replacement, $string); //结果为：2014, April 15</code></pre><p>其中${1}与$1的写法是等效的，表示第一个匹配的字串，$2代表第二个匹配的。</p><p>通过复杂的模式，我们可以更加精确的替换目标字符串的内容。</p><pre><code>$patterns = array (&apos;/(19|20)(\d{2})-(\d{1,2})-(\d{1,2})/&apos;,&apos;/^\s*{(\w+)}\s*=/&apos;);$replace = array (&apos;\3/\4/\1\2&apos;, &apos;$\1 =&apos;);//\3等效于$3,\4等效于$4，依次类推echo preg_replace($patterns, $replace, &apos;{startDate} = 1999-5-27&apos;); //结果为：$startDate = 5/27/1999//详细解释下结果：(19|20)表示取19或者20中任意一个数字，(\d{2})表示两个数字，(\d{1,2})表示1个或2个数字，(\d{1,2})表示1个或2个数字。^\s*{(\w+)\s*=}表示以任意空格开头的，并且包含在{}中的字符，并且以任意空格结尾的，最后有个=号的。</code></pre><p>用正则替换来去掉多余的空格与字符：</p><pre><code>$str = &apos;one     two&apos;;$str = preg_replace(&apos;/\s+/&apos;, &apos; &apos;, $str);echo $str; // 结果改变为&apos;one two&apos;</code></pre><h2 id="常见案例"><a href="#常见案例" class="headerlink" title="常见案例"></a>常见案例</h2><p>正则匹配常用在表单验证上，一些字段会有一定的格式要求，比如用户名一般都要求必须是字母、数字或下划线组成，邮箱、电话等也都有自己的规则，因此使用正则表达式可以很好的对这些字段进行验证。</p><pre><code>&lt;?php$user = array(&apos;name&apos; =&gt; &apos;spark1985&apos;,&apos;email&apos; =&gt; &apos;spark@imooc.com&apos;,&apos;mobile&apos; =&gt; &apos;13312345678&apos;);//进行一般性验证if (empty($user)) {die(&apos;用户信息不能为空&apos;);}if (strlen($user[&apos;name&apos;]) &lt; 6) {die(&apos;用户名长度最少为6位&apos;);}//用户名必须为字母、数字与下划线if (!preg_match(&apos;/^\w+$/i&apos;, $user[&apos;name&apos;])) {die(&apos;用户名不合法&apos;);}//验证邮箱格式是否正确if (!preg_match(&apos;/^[\w\.]+@\w+\.\w+$/i&apos;, $user[&apos;email&apos;])) {die(&apos;邮箱不合法&apos;);}//手机号必须为11位数字，且为1开头if (!preg_match(&apos;/^1\d{10}$/i&apos;, $user[&apos;mobile&apos;])) {die(&apos;手机号不合法&apos;);}echo &apos;用户信息验证成功&apos;;</code></pre>]]></content>
    
    <summary type="html">
    
      也许你之前听过，也许你之前用过，当然或许你之前没有听过或者没有接触过，说实话，做了这么久iOS开发，我也就用过两次，不知道是个人原因还是什么，但是其实正则表达式是几乎所有编程里面都有的，如果真的要说，估计要几个月，而且还说不完.....
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="正则表达式" scheme="https://icocos.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>PHP——异常处理</title>
    <link href="https://icocos.github.io/2018/12/09/PHP%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://icocos.github.io/2018/12/09/PHP——异常处理/</id>
    <published>2018-12-09T13:30:04.000Z</published>
    <updated>2018-12-28T02:52:36.423Z</updated>
    
    <content type="html"><![CDATA[<p>关于异常处理和了解，我相信是任何一门语言或者做任何开发的程序员都应该知道的东西，如果你没用过可以理解，但是如果你说没有听过，那么对不起，请绕道……</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h2 id="抛出一个异常"><a href="#抛出一个异常" class="headerlink" title="抛出一个异常"></a>抛出一个异常</h2><p>从PHP5开始，PHP支持异常处理，异常处理是面向对象一个重要特性，PHP代码中的异常通过throw抛出，异常抛出之后，后面的代码将不会再被执行。</p><p>既然抛出异常会中断程序执行，那么为什么还需要使用异常处理？</p><p>异常抛出被用于在遇到未知错误，或者不符合预先设定的条件时，通知客户程序，以便进行其他相关处理，不至于使程序直接报错中断。</p><p>当代码中使用了try catch的时候，抛出的异常会在catch中捕获，否则会直接中断。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><pre><code>try{//可能出现错误或异常的代码//catch表示捕获，Exception是php已定义好的异常类} catch(Exception $e){//对异常处理，方法：//1、自己处理//2、不处理，将其再次抛出}</code></pre><h3 id="处理处理程序应当包括："><a href="#处理处理程序应当包括：" class="headerlink" title="处理处理程序应当包括："></a>处理处理程序应当包括：</h3><p>Try - 使用异常的函数应该位于 “try”  代码块内。如果没有触发异常，则代码将照常继续执行。但是如果异常被触发，会抛出一个异常。<br>Throw - 这里规定如何触发异常。注意：每一个 “throw” 必须对应至少一个 “catch”，当然可以对应多个”catch”<br>Catch - “catch” 代码块会捕获异常，并创建一个包含异常信息的对象。</p><pre><code>//创建可抛出一个异常的函数function checkNum($number){if($number&gt;1){throw new Exception(&quot;异常提示-数字必须小于等于1&quot;);}return true;}//在 &quot;try&quot; 代码块中触发异常try{checkNum(2);//如果异常被抛出，那么下面一行代码将不会被输出echo &apos;如果能看到这个提示，说明你的数字小于等于1&apos;;}catch(Exception $e){//捕获异常echo &apos;捕获异常: &apos; .$e-&gt;getMessage();}</code></pre><p>上面代码将获得类似这样一个错误：</p><p>捕获异常:: 异常提示-数字必须小于等于1</p><p>例子解释：</p><p>上面的代码抛出了一个异常，并捕获了它：</p><pre><code>创建 checkNum() 函数。它检测数字是否大于 1。如果是，则抛出一个异常。在 &quot;try&quot; 代码块中调用 checkNum() 函数。checkNum() 函数中的异常被抛出&quot;catch&quot; 代码块接收到该异常，并创建一个包含异常信息的对象 ($e)。通过从这个 exception 对象调用 $e-&gt;getMessage()，输出来自该异常的错误消息</code></pre><h2 id="异常类与异常处理"><a href="#异常类与异常处理" class="headerlink" title="异常类与异常处理"></a>异常类与异常处理</h2><p>PHP具有很多异常处理类，其中Exception是所有异常处理的基类。</p><p>Exception具有几个基本属性与方法，其中包括了：</p><pre><code>message 异常消息内容code 异常代码file 抛出异常的文件名line 抛出异常在该文件的行数</code></pre><p>其中常用的方法有：</p><pre><code>getTrace 获取异常追踪信息getTraceAsString 获取异常追踪信息的字符串getMessage 获取出错信息</code></pre><p>如果必要的话，可以通过继承Exception类来建立自定义的异常处理类。</p><pre><code>//自定义的异常类，继承了PHP的异常基类Exceptionclass MyException extends Exception {function getInfo() {return &apos;自定义错误信息&apos;;}}try {//使用异常的函数应该位于 &quot;try&quot;  代码块内。如果没有触发异常，则代码将照常继续执行。但是如果异常被触发，会抛出一个异常。throw new MyException(&apos;error&apos;);//这里规定如何触发异常。注意：每一个 &quot;throw&quot; 必须对应至少一个 &quot;catch&quot;，当然可以对应多个&quot;catch&quot;} catch(Exception $e) {//&quot;catch&quot; 代码块会捕获异常，并创建一个包含异常信息的对象echo $e-&gt;getInfo();//获取自定义的异常信息echo $e-&gt;getMessage();//获取继承自基类的getMessage信息}</code></pre><h2 id="捕捉异常信息"><a href="#捕捉异常信息" class="headerlink" title="捕捉异常信息"></a>捕捉异常信息</h2><p>在了解了异常处理的基本原理之后，我们可以通过try catch来捕获异常，我们将执行的代码放在try代码块中，一旦其中的代码抛出异常，就能在catch中捕获。</p><p>这里我们只是通过案例来了解try catch的机制以及异常捕获的方法，在实际应用中，不会轻易的抛出异常，只有在极端情况或者非常重要的情况下，才会抛出异常，抛出异常，可以保障程序的正确性与安全，避免导致不可预知的bug。</p><p>一般的异常处理流程代码为：</p><pre><code>try {throw new Exception(&apos;wrong&apos;);} catch(Exception $ex) {echo &apos;Error:&apos;.$ex-&gt;getMessage().&apos;&lt;br&gt;&apos;;echo $ex-&gt;getTraceAsString().&apos;&lt;br&gt;&apos;;}echo &apos;异常处理后，继续执行其他代码&apos;;</code></pre><h2 id="获取错误发生所在位置"><a href="#获取错误发生所在位置" class="headerlink" title="获取错误发生所在位置"></a>获取错误发生所在位置</h2><p>在异常被捕获之后，我们可以通过异常处理对象获取其中的异常信息，前面我们已经了解捕获方式，以及获取基本的错误信息。</p><p>在实际应用中，我们通常会获取足够多的异常信息，然后写入到错误日志中。</p><p>通过我们需要将报错的文件名、行号、错误信息、异常追踪信息等记录到日志中，以便调试与修复问题</p><pre><code>&lt;?phptry {throw new Exception(&apos;wrong&apos;);} catch(Exception $ex) {$msg = &apos;Error:&apos;.$ex-&gt;getMessage().&quot;\n&quot;;$msg.= $ex-&gt;getTraceAsString().&quot;\n&quot;;$msg.= &apos;异常行号：&apos;.$ex-&gt;getLine().&quot;\n&quot;;$msg.= &apos;所在文件：&apos;.$ex-&gt;getFile().&quot;\n&quot;;//将异常信息记录到日志中PHP异常处理之   file_put_contents(&apos;error.log&apos;, $msg);}</code></pre>]]></content>
    
    <summary type="html">
    
      关于异常处理和了解，我相信是任何一门语言或者做任何开发的程序员都应该知道的东西，如果你没用过可以理解，但是如果你说没有听过，那么对不起，请绕道......
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="异常处理" scheme="https://icocos.github.io/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>PHP——图像与图像操作</title>
    <link href="https://icocos.github.io/2018/12/07/PHP%E2%80%94%E2%80%94%E5%9B%BE%E5%83%8F%E4%B8%8E%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/"/>
    <id>https://icocos.github.io/2018/12/07/PHP——图像与图像操作/</id>
    <published>2018-12-07T15:29:55.000Z</published>
    <updated>2018-12-28T02:48:49.682Z</updated>
    
    <content type="html"><![CDATA[<p>PHP关于图像处理其实还是挺重要的，只是如果你只是做API开发的话，其实根本用不到，但是做Web的话可算是一个比较重要的技术，既然看到这里我们就简单了解一下……</p><h2 id="图像与图像操作"><a href="#图像与图像操作" class="headerlink" title="图像与图像操作"></a>图像与图像操作</h2><h2 id="GD库简介"><a href="#GD库简介" class="headerlink" title="GD库简介"></a>GD库简介</h2><p>GD指的是Graphic Device，PHP的GD库是用来处理图形的扩展库，通过GD库提供的一系列API，可以对图像进行处理或者直接生成新的图片。</p><p>PHP除了能进行文本处理以外，通过GD库，可以对JPG、PNG、GIF、SWF等图片进行处理。GD库常用在图片加水印，验证码生成等方面。</p><p>PHP默认已经集成了GD库，只需要在安装的时候开启就行。</p><pre><code>header(&quot;content-type: image/png&quot;);$img=imagecreatetruecolor(100, 100);$red=imagecolorallocate($img, 0xFF, 0x00, 0x00);imagefill($img, 0, 0, $red);imagepng($img);imagedestroy($img);</code></pre><h2 id="绘制线条"><a href="#绘制线条" class="headerlink" title="绘制线条"></a>绘制线条</h2><p>要对图形进行操作，首先要新建一个画布，通过imagecreatetruecolor函数可以创建一个真彩色的空白图片：</p><pre><code>$img = imagecreatetruecolor(100, 100);</code></pre><p>GD库中对于画笔所用的颜色，需要通过imagecolorallocate函数进行分配，通过参数设定RGB的颜色值来确定画笔的颜色：</p><pre><code>$red = imagecolorallocate($img, 0xFF, 0x00, 0x00);</code></pre><p>然后我们通过调用绘制线段函数imageline进行线条的绘制，通过指定起点跟终点来最终得到线条。</p><pre><code>imageline($img, 0, 0, 100, 100, $red);</code></pre><p>线条绘制好以后，通过header与imagepng进行图像的输出。</p><pre><code>header(&quot;content-type: image/png&quot;);imagepng($img);</code></pre><p>最后可以调用imagedestroy释放该图片占用的内存。</p><pre><code>imagedestroy($img);</code></pre><p>通过上面的步骤，可以发现PHP绘制图形非常的简单，但很多时候我们不只是需要输出图片，可能我们还需要得到一个图片文件，可以通过imagepng函数指定文件名将绘制后的图像保存到文件中。</p><pre><code>imagepng($img, &apos;img.png&apos;);</code></pre><h2 id="绘制文字"><a href="#绘制文字" class="headerlink" title="绘制文字"></a>绘制文字</h2><p>GD库可以进行多种图形的基本操作，常用的有绘制线条，背景填充，画矩形，绘制文字等。</p><p>跟绘制线条类似，首先需要新建一个图片与初始化颜色。</p><pre><code>$img = imagecreatetruecolor(100, 100);$red = imagecolorallocate($img, 0xFF, 0x00, 0x00);</code></pre><p>然后使用imagestring函数来进行文字的绘制，这个函数的参数很多：imagestring ( resource $image , int $font , int $x , int $y , string $s , int $col )，可以通过$font来设置字体的大小，x,y设置文字显示的位置，$s是要绘制的文字,$col是文字的颜色。</p><pre><code>imagestring($img, 5, 0, 0, &quot;Hello world&quot;, $red);header(&quot;content-type: image/png&quot;);imagepng($img);imagedestroy($img);</code></pre><h2 id="输出图形文件"><a href="#输出图形文件" class="headerlink" title="输出图形文件"></a>输出图形文件</h2><p>前面我们已经了解到，通过imagepng可以直接输出图像到浏览器，但是很多时候，我们希望将处理好的图像保存到文件，以便可以多次使用。通过指定路径参数将图像保存到文件中。</p><pre><code>$filename = &apos;img.png&apos;;imagepng($img, $filename);</code></pre><p>使用imagepng可以将图像保存成png格式，如果要保存成其他格式需要使用不同的函数，使用imagejpeg将图片保存成jpeg格式，imagegif将图片保存成gif格式，需要说明的是，imagejpeg会对图片进行压缩，因此还可以设置一个质量参数。</p><pre><code>$filename = &apos;img.jpg&apos;;​imagejpeg($img, $filename, 80);</code></pre><h2 id="生成图形验证码"><a href="#生成图形验证码" class="headerlink" title="生成图形验证码"></a>生成图形验证码</h2><p>简单的验证码其实就是在图片中输出了几个字符，通过我们前面章节讲到的imagestring函数就能实现。</p><p>但是在处理上，为了使验证码更加的安全，防止其他程序自动识别，因此常常需要对验证码进行一些干扰处理，通常会采用绘制一些噪点，干扰线段，对输出的字符进行倾斜、扭曲等操作。</p><p>可以使用imagesetpixel绘制点来实现噪点干扰，但是只绘制一个点的作用不大，因此这里常常会使用循环进行随机绘制。</p><pre><code>for($i=0;$i&lt;50;$i++) {imagesetpixel($im, rand(0, 100) , rand(0, 100) , $black); imagesetpixel($im, rand(0, 100) , rand(0, 100) , $green);} </code></pre><p>实例</p><pre><code>&lt;?php$img = imagecreatetruecolor(100, 40);$black = imagecolorallocate($img, 0x00, 0x00, 0x00);$green = imagecolorallocate($img, 0x00, 0xFF, 0x00);$white = imagecolorallocate($img, 0xFF, 0xFF, 0xFF);imagefill($img,0,0,$white);//生成随机的验证码$code = &apos;&apos;;for($i = 0; $i &lt; 4; $i++) {$code .= rand(0, 9);}imagestring($img, 5, 10, 10, $code, $black);//加入噪点干扰for($i=0;$i&lt;50;$i++) {imagesetpixel($img, rand(0, 100) , rand(0, 100) , $black); imagesetpixel($img, rand(0, 100) , rand(0, 100) , $green);}//输出验证码header(&quot;content-type: image/png&quot;);imagepng($img);imagedestroy($img);</code></pre><h2 id="加水印"><a href="#加水印" class="headerlink" title="加水印"></a>加水印</h2><p>给图片添加水印的方法一般有两种，一种是在图片上面加上一个字符串，另一种是在图片上加上一个logo或者其他的图片。</p><p>因为这里处理的是已经存在的图片，所以可以直接从已存在的图片建立画布，通过imagecreatefromjpeg可以直接从图片文件创建图像。</p><pre><code>$im = imagecreatefromjpeg($filename);</code></pre><p>创建图像对象以后，我们就可以通过前面的GD函数，绘制字符串到图像上。如果要加的水印是一个logo图片，那么就需要再建立一个图像对象，然后通过GD函数imagecopy将logo的图像复制到源图像中。</p><pre><code>$logo = imagecreatefrompng($filename);imagecopy($im, $logo, 15, 15, 0, 0, $width, $height);</code></pre><p>当将logo图片复制到原图片上以后，将加水印后的图片输出保存就完成了加水印处理。</p><pre><code>imagejpeg($im, $filename);</code></pre><p>使用案例</p><pre><code>&lt;?php//这里仅仅是为了案例需要准备一些素材图片$url = &apos;http://www.iyi8.com/uploadfile/2014/0521/20140521105216901.jpg&apos;;$content = file_get_contents($url);$filename = &apos;tmp.jpg&apos;;file_put_contents($filename, $content);$url = &apos;http://wiki.ubuntu.org.cn/images/3/3b/Qref_Edubuntu_Logo.png&apos;;file_put_contents(&apos;logo.png&apos;, file_get_contents($url));//开始添加水印操作$im = imagecreatefromjpeg($filename);$logo = imagecreatefrompng(&apos;logo.png&apos;);$size = getimagesize(&apos;logo.png&apos;);imagecopy($im, $logo, 15, 15, 0, 0, $size[0], $size[1]); header(&quot;content-type: image/jpeg&quot;);imagejpeg($im);</code></pre>]]></content>
    
    <summary type="html">
    
      PHP关于图像处理其实还是挺重要的，只是如果你只是做API开发的话，其实根本用不到，但是做Web的话可算是一个比较重要的技术，既然看到这里我们就简单了解一下......
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="图像与图像操作" scheme="https://icocos.github.io/tags/%E5%9B%BE%E5%83%8F%E4%B8%8E%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>PHP——文件处理</title>
    <link href="https://icocos.github.io/2018/12/06/PHP%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    <id>https://icocos.github.io/2018/12/06/PHP——文件处理/</id>
    <published>2018-12-06T15:59:33.000Z</published>
    <updated>2018-12-28T02:52:25.292Z</updated>
    
    <content type="html"><![CDATA[<p>文件处理在PHP开发中也是比较常见的，或者你使用的是缓存，但是毕竟根据需求总有用到文件的地方，所以…..</p><h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h2><h2 id="读取文件内容"><a href="#读取文件内容" class="headerlink" title="读取文件内容"></a>读取文件内容</h2><p>PHP具有丰富的文件操作函数，最简单的读取文件的函数为file_get_contents，可以将整个文件全部读取到一个字符串中。</p><pre><code>$content = file_get_contents(&apos;./test.txt&apos;);</code></pre><p>file_get_contents也可以通过参数控制读取内容的开始点以及长度。</p><pre><code>$content = file_get_contents(&apos;./test.txt&apos;, null, null, 100, 500);</code></pre><p>PHP也提供类似于C语言操作文件的方法，使用fopen，fgets，fread等方法，fgets可以从文件指针中读取一行，freads可以读取指定长度的字符串。</p><pre><code>$fp = fopen(&apos;./text.txt&apos;, &apos;rb&apos;);while(!feof($fp)) {echo fgets($fp); //读取一行}fclose($fp);$fp = fopen(&apos;./text.txt&apos;, &apos;rb&apos;);$contents = &apos;&apos;;while(!feof($fp)) {$contents .= fread($fp, 4096); //一次读取4096个字符}fclose($fp);</code></pre><p>使用fopen打开的文件，最好使用fclose关闭文件指针，以避免文件句柄被占用。</p><h2 id="判断文件是否存在"><a href="#判断文件是否存在" class="headerlink" title="判断文件是否存在"></a>判断文件是否存在</h2><p>一般情况下在对文件进行操作的时候需要先判断文件是否存在，PHP中常用来判断文件存在的函数有两个is_file与file_exists.</p><pre><code>$filename = &apos;./test.txt&apos;;if (file_exists($filename)) {echo file_get_contents($filename);}</code></pre><p>如果只是判断文件存在，使用file_exists就行，file_exists不仅可以判断文件是否存在，同时也可以判断目录是否存在，从函数名可以看出，is_file是确切的判断给定的路径是否是一个文件。</p><pre><code>$filename = &apos;./test.txt&apos;;if (is_file($filename)) {echo file_get_contents($filename);}</code></pre><p>更加精确的可以使用is_readable与is_writeable在文件是否存在的基础上，判断文件是否可读与可写。</p><pre><code>$filename = &apos;./test.txt&apos;;if (is_writeable($filename)) {file_put_contents($filename, &apos;test&apos;);}if (is_readable($filename)) {echo file_get_contents($filename);}</code></pre><h2 id="获取修改时间"><a href="#获取修改时间" class="headerlink" title="获取修改时间"></a>获取修改时间</h2><p>文件有很多元属性，包括：文件的所有者、创建时间、修改时间、最后的访问时间等。</p><pre><code>fileowner：获得文件的所有者filectime：获取文件的创建时间filemtime：获取文件的修改时间fileatime：获取文件的访问时间</code></pre><p>其中最常用的是文件的修改时间，通过文件的修改时间，可以判断文件的时效性，经常用在静态文件或者缓存数据的更新。</p><pre><code>$mtime = filemtime($filename);echo &apos;修改时间：&apos;.date(&apos;Y-m-d H:i:s&apos;, filemtime($filename));</code></pre><p>使用案例</p><pre><code>&lt;?php$filename = &apos;/data/webroot/usercode/code/resource/test.txt&apos;;echo &apos;所有者：&apos;.fileowner($filename).&apos;&lt;br&gt;&apos;;echo &apos;创建时间：&apos;.filectime($filename).&apos;&lt;br&gt;&apos;;echo &apos;修改时间：&apos;.filemtime($filename).&apos;&lt;br&gt;&apos;;echo &apos;最后访问时间：&apos;.fileatime($filename).&apos;&lt;br&gt;&apos;;//给$mtime赋值为文件的修改时间$mtime = time(); //通过计算时间差 来判断文件内容是否有效if (time() - $mtime &gt; 3600) {echo &apos;&lt;br&gt;缓存已过期&apos;;} else {echo file_get_contents($filename);}</code></pre><h2 id="获取文件大小"><a href="#获取文件大小" class="headerlink" title="获取文件大小"></a>获取文件大小</h2><p>通过filesize函数可以取得文件的大小，文件大小是以字节数表示的。</p><pre><code>$filename = &apos;/data/webroot/usercode/resource/test.txt&apos;;$size = filesize($filename);</code></pre><p>如果要转换文件大小的单位，可以自己定义函数来实现。</p><pre><code>function getsize($size, $format = &apos;kb&apos;) {$p = 0;if ($format == &apos;kb&apos;) {$p = 1;} elseif ($format == &apos;mb&apos;) {$p = 2;} elseif ($format == &apos;gb&apos;) {$p = 3;}$size /= pow(1024, $p);return number_format($size, 3);}$filename = &apos;/data/webroot/usercode/code/resource/test.txt&apos;;$size = filesize($filename);$size = getsize($size, &apos;kb&apos;); //进行单位转换echo $size.&apos;kb&apos;;</code></pre><p>值得注意的是，没法通过简单的函数来取得目录的大小，目录的大小是该目录下所有子目录以及文件大小的总和，因此需要通过递归的方法来循环计算目录的大小。</p>]]></content>
    
    <summary type="html">
    
      文件处理在PHP开发中也是比较常见的，或者你使用的是缓存，但是毕竟根据需求总有用到文件的地方，所以.....
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="文件处理" scheme="https://icocos.github.io/tags/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>PHP——时间与日期处理</title>
    <link href="https://icocos.github.io/2018/12/06/PHP%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E4%B8%8E%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86/"/>
    <id>https://icocos.github.io/2018/12/06/PHP——时间与日期处理/</id>
    <published>2018-12-06T15:29:44.000Z</published>
    <updated>2018-12-28T02:48:34.674Z</updated>
    
    <content type="html"><![CDATA[<p>关于时间与日期的处理，根据这么多年iOS开发的经验，我觉得在PHP中可以说是无处不在，只是可能如果你做的比较好的话，处理一次或者抽好了就可以通用……</p><h2 id="时间与日期处理"><a href="#时间与日期处理" class="headerlink" title="时间与日期处理"></a>时间与日期处理</h2><pre><code>首先我们需要知道PHP中关于时间的处理时间戳应该算是最好的方案，一个字：快！</code></pre><h2 id="获取当前时间戳"><a href="#获取当前时间戳" class="headerlink" title="获取当前时间戳"></a>获取当前时间戳</h2><p>UNIX 时间戳（英文叫做：timestamp）是 PHP 中关于时间与日期的一个很重要的概念，它表示从 1970年1月1日 00:00:00 到当前时间的秒数之和。</p><p>PHP提供了内置函数 time() 来取得服务器当前时间的时间戳。那么获取当前的UNIX时间戳就很简单了。</p><pre><code>$time = time();echo $time;//1396193923，这个数字表示从1970年1月1日 00:00:00 到我输出这个脚本时经历了1396193923秒</code></pre><h2 id="获取当前日期"><a href="#获取当前日期" class="headerlink" title="获取当前日期"></a>获取当前日期</h2><p>php内置了date()函数，来取得当前的日期。</p><pre><code>函数说明：date(时间戳的格式, 规定时间戳【默认是当前的日期和时间，可选】)返回值：函数日期和时间</code></pre><p>例子：</p><pre><code>//date函数，第二个参数取默认值的情况echo date(&quot;Y-m-d&quot;);//2014-03-30//date函数，第二个参数有值的情况echo date(&quot;Y-m-d&quot;,&apos;1396193923&apos;);//2014-03-30,1396193923表示2014-03-30的unix时间戳</code></pre><h2 id="获取日期对应的时间戳"><a href="#获取日期对应的时间戳" class="headerlink" title="获取日期对应的时间戳"></a>获取日期对应的时间戳</h2><p>UNIX 时间戳（英文叫做：timestamp）是 PHP 中关于时间与日期的一个很重要的概念，它表示从 1970年1月1日 00:00:00 到当前时间的秒数之和。</p><p>PHP提供了内置函数strtotime实现功能：获取某个日期的时间戳，或获取某个时间的时间戳。例如：</p><pre><code>echo strtotime(&apos;2014-04-29&apos;);//1398700800，这个数字表示从1970年1月1日 00:00:00 到2014年4月29号经历了1398700800秒echo strtotime(&apos;2014-04-29 00:00:01&apos;);//1398700801，这个数字表示从1970年1月1日 00:00:00 到2014-04-29 00:00:01时经历了1398700801秒</code></pre><p>大家发现上面的规律了吗，其实strtotime(‘2014-04-29’)相当于strtotime(‘2014-04-29 00:00:00’)</p><h2 id="格式化日期"><a href="#格式化日期" class="headerlink" title="格式化日期"></a>格式化日期</h2><p>strtotime函数预期接受一个包含美国英语日期格式的字符串并尝试将其解析为 Unix 时间戳。</p><pre><code>函数说明：strtotime(要解析的时间字符串, 计算返回值的时间戳【默认是当前的时间，可选】)返回值：成功则返回时间戳，否则返回 FALSE</code></pre><p>比如</p><pre><code>echo strtotime(&quot;now&quot;);//相当于将英文单词now直接等于现在的日期和时间，并把这个日期时间转化为unix时间戳。这个效果跟echo time();一样。echo strtotime(&quot;+1 seconds&quot;);//相当于将现在的日期和时间加上了1秒，并把这个日期时间转化为unix时间戳。这个效果跟echo time()+1;一样。echo strtotime(&quot;+1 day&quot;);//相当于将现在的日期和时间加上了1天。echo strtotime(&quot;+1 week&quot;);//相当于将现在的日期和时间加上了1周。echo strtotime(&quot;+1 week 3 days 7 hours 5 seconds&quot;);//相当于将现在的日期和时间加上了1周3天7小时5秒。</code></pre><h2 id="格式化格林威治时间"><a href="#格式化格林威治时间" class="headerlink" title="格式化格林威治时间"></a>格式化格林威治时间</h2><p>gmdate 函数能格式化一个GMT的日期和时间，返回的是格林威治标准时（GMT）。</p><p>举个例子，我们现在所在的中国时区是东八区，领先格林威治时间8个小时，有时候也叫GMT+8，那么服务器运行以下脚本返回的时间应该是这样的：<br>当前时间假定是2014-05-01 15:15:22</p><pre><code>echo date(&apos;Y-m-d H:i:s&apos;, time()); //输出为：2014-05-01 15:15:22 echo gmdate(&apos;Y-m-d H:i:s&apos;, time()); //输出为：2014-05-01 07:15:22 因为格林威治时间是现在中国时区的时间减去8个小时，所以相对于现在时间要少8个小时</code></pre>]]></content>
    
    <summary type="html">
    
      关于时间与日期的处理，根据这么多年iOS开发的经验，我觉得在PHP中可以说是无处不在，只是可能如果你做的比较好的话，处理一次或者抽好了就可以通用......
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="时间与日期处理" scheme="https://icocos.github.io/tags/%E6%97%B6%E9%97%B4%E4%B8%8E%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>PHP——万物皆对象</title>
    <link href="https://icocos.github.io/2018/12/04/PHP%E2%80%94%E2%80%94%E4%B8%87%E7%89%A9%E7%9A%86%E5%AF%B9%E8%B1%A1/"/>
    <id>https://icocos.github.io/2018/12/04/PHP——万物皆对象/</id>
    <published>2018-12-04T15:08:54.000Z</published>
    <updated>2018-12-28T02:48:26.387Z</updated>
    
    <content type="html"><![CDATA[<p>所谓万物皆对象，我相信做过面向对象开发的人应该都知道这个到底，但是真正理解开发中的面向对应只有真实动手开发并且慢慢总结才能知道里面的含义，iOS可谓是纯面向对象的语言，当然还有很多其他的….</p><h2 id="万物皆对象"><a href="#万物皆对象" class="headerlink" title="万物皆对象"></a>万物皆对象</h2><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><p>通常定义一个汽车类的方法为：</p><pre><code>class Car {  //定义一个Car类$name = &apos;汽车&apos;; //属性function getName() { //方法return $this-&gt;name; //返回}}</code></pre><blockquote><p>方法内部可以使用$this伪变量调用对象的属性或者方法</p></blockquote><p>类是一类东西的结构描述，而对象则是一类东西的一个具体实例，例如汽车这个名词可以理解为汽车的总类，但这辆汽车则是一个具体的汽车对象。</p><p>对象通过new关键字进行实例化：</p><pre><code>$car = new Car();  //实例化一个对象或者可以这样：$className = &apos;Car&apos;;$car = new $className();echo $car-&gt;getName(); //调用对象的方法</code></pre><p>类与对象看起来比较相似，但实际上有本质的区别，类是抽象的概念，对象是具体的实例。类可以使程序具有可重用性。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>在类中定义的变量称之为属性，通常属性跟数据库中的字段有一定的关联，因此也可以称作“字段”。属性声明是由关键字 public，protected 或者 private 开头，后面跟一个普通的变量声明来组成。属性的变量可以设置初始化的默认值，默认值必须是常量。</p><p>访问控制的关键字代表的意义为：</p><p>public：公开的<br>protected：受保护的<br>private：私有的</p><pre><code>class Car {    //定义公共属性    public $name = &apos;汽车&apos;;    //定义受保护的属性    protected $corlor = &apos;白色&apos;;    //定义私有属性    private $price = &apos;100000&apos;;}</code></pre><p>默认都为public，外部可以访问。一般通过-&gt;对象操作符来访问对象的属性或者方法，对于静态属性则使用::双冒号进行访问。当在类成员方法内部调用的时候，可以使用$this伪变量调用当前对象的属性。</p><pre><code>$car = new Car();echo $car-&gt;name;   //调用对象的属性echo $car-&gt;color;  //错误 受保护的属性不允许外部调用echo $car-&gt;price;  //错误 私有属性不允许外部调用</code></pre><p>受保护的属性与私有属性不允许外部调用，在类的成员方法内部是可以调用的。</p><pre><code>class Car{    private $price = &apos;1000&apos;;    public function getPrice() {            return $this-&gt;price; //内部访问私有属性    ​    }}</code></pre><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><pre><code>方法就是在类中的function，很多时候我们分不清方法与函数有什么差别，在面向过程的程序设计中function叫做函数，在面向对象中function则被称之为方法</code></pre><p>同属性一样，类的方法也具有public，protected 以及 private 的访问控制。</p><p>访问控制的关键字代表的意义为：<br>public：公开的<br>protected：受保护的<br>private：私有的</p><p>实例方法</p><pre><code>class Car {public function getName() {return &apos;汽车&apos;;}​}$car = new Car();echo $car-&gt;getName();</code></pre><p>类方法</p><p>使用关键字static修饰的，称之为静态方法，静态方法不需要实例化对象，可以通过类名直接调用，操作符为双冒号::。</p><pre><code>class Car {public static function getName() {return &apos;汽车&apos;;}​}echo Car::getName(); //结果为“汽车”</code></pre><h3 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h3><p>PHP5可以在类中使用__construct()定义一个构造函数，具有构造函数的类，会在每次对象创建的时候调用该函数，因此常用来在对象创建的时候进行一些初始化工作。</p><pre><code>class Car {function __construct() {print &quot;构造函数被调用\n&quot;; //进行一些初始化工作}}$car = new Car(); //实例化的时候 会自动调用构造函数__construct，这里会输出一个字符串</code></pre><p>在子类中如果定义了<strong>construct则不会调用父类的</strong>construct，如果需要同时调用父类的构造函数，需要使用parent::__construct()显式的调用。</p><pre><code>class Car {function __construct() {print &quot;父类构造函数被调用\n&quot;;}}class Truck extends Car {function __construct() {print &quot;子类构造函数被调用\n&quot;;parent::__construct();}}$car = new Truck();</code></pre><p>同样，PHP5支持析构函数，使用__destruct()进行定义，析构函数指的是当某个对象的所有引用被删除，或者对象被显式的销毁时会执行的函数。</p><pre><code>class Car {function __construct() {print &quot;构造函数被调用 \n&quot;;}function __destruct() {print &quot;析构函数被调用 \n&quot;;}}$car = new Car(); //实例化时会调用构造函数echo &apos;使用后，准备销毁car对象 \n&apos;;unset($car); //销毁时会调用析构函数</code></pre><p>当PHP代码执行完毕以后，会自动回收与销毁对象，因此一般情况下不需要显式的去销毁对象。</p><h3 id="Static静态关键字"><a href="#Static静态关键字" class="headerlink" title="Static静态关键字"></a>Static静态关键字</h3><p>静态属性与方法可以在不实例化类的情况下调用，直接使用类名::方法名的方式进行调用。静态属性不允许对象使用-&gt;操作符调用。</p><pre><code>class Car {private static $speed = 10;public static function getSpeed() {return self::$speed;}}echo Car::getSpeed();  //调用静态方法</code></pre><p>静态方法也可以通过变量来进行动态调用</p><pre><code>$func = &apos;getSpeed&apos;;$className = &apos;Car&apos;;echo $className::$func();  //动态调用静态方法</code></pre><p>静态方法中，$this伪变量不允许使用。可以使用self，parent，static在内部调用静态方法与属性。</p><pre><code>class Car {private static $speed = 10;public static function getSpeed() {return self::$speed;}public static function speedUp() {return self::$speed+=10;}}class BigCar extends Car {public static function start() {parent::speedUp();}}BigCar::start();echo BigCar::getSpeed();</code></pre><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><pre><code>被定义为公有的类成员可以在任何地方被访问。被定义为受保护的类成员则可以被其自身以及其子类和父类访问。被定义为私有的类成员则只能被其定义所在的类访问</code></pre><p>类属性必须定义为公有、受保护、私有之一。为兼容PHP5以前的版本，如果采用 var 定义，则被视为公有。</p><pre><code>class Car {$speed = 10; //错误 属性必须定义访问控制public $name;   //定义共有属性}</code></pre><p>类中的方法可以被定义为公有、私有或受保护。如果没有设置这些关键字，则该方法默认为公有。</p><pre><code>class Car {​    //默认为共有方法function turnLeft() {}}</code></pre><p>如果构造函数定义成了私有方法，则不允许直接实例化对象了，这时候一般通过静态方法进行实例化，在设计模式中会经常使用这样的方法来控制对象的创建，比如单例模式只允许有一个全局唯一的对象。</p><pre><code>class Car {private function __construct() {echo &apos;object create&apos;;}private static $_object = null;public static function getInstance() {if (empty(self::$_object)) {self::$_object = new Car(); //内部方法可以调用私有方法，因此这里可以创建对象}return self::$_object;}}//$car = new Car(); //这里不允许直接实例化对象$car = Car::getInstance(); //通过静态方法来获得一个实例</code></pre><h3 id="对象继承"><a href="#对象继承" class="headerlink" title="对象继承"></a>对象继承</h3><p>继承是面向对象程序设计中常用的一个特性，汽车是一个比较大的类，我们也可以称之为基类，除此之外，汽车还分为卡车、轿车、东风、宝马等，因为这些子类具有很多相同的属性和方法，可以采用继承汽车类来共享这些属性与方法，实现代码的复用。</p><pre><code>&lt;?phpclass Car {public $speed = 0; //汽车的起始速度是0public function speedUp() {$this-&gt;speed += 10;return $this-&gt;speed;}}//定义继承于Car的Truck类class Truck extends Car {public function speedUp() {parent::speedUp();$this-&gt;speed += 50;return $this-&gt;speed;}}$car = new Truck();$car-&gt;speedUp();echo $car-&gt;speed;</code></pre><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>PHP中的重载指的是动态的创建属性与方法，是通过魔术方法来实现的。属性的重载通过<strong>set，</strong>get，<strong>isset，</strong>unset来分别实现对不存在属性的赋值、读取、判断属性是否设置、销毁属性。</p><pre><code>class Car {private $ary = array();public function __set($key, $val) {$this-&gt;ary[$key] = $val;}public function __get($key) {if (isset($this-&gt;ary[$key])) {return $this-&gt;ary[$key];}return null;}public function __isset($key) {if (isset($this-&gt;ary[$key])) {return true;}return false;}public function __unset($key) {unset($this-&gt;ary[$key]);}}$car = new Car();$car-&gt;name = &apos;汽车&apos;;  //name属性动态创建并赋值echo $car-&gt;name;</code></pre><p>方法的重载通过<strong>call来实现，当调用不存在的方法的时候，将会转为参数调用</strong>call方法，当调用不存在的静态方法时会使用__callStatic重载。</p><pre><code>class Car {public $speed = 0;public function __call($name, $args) {if ($name == &apos;speedUp&apos;) {$this-&gt;speed += 10;}}}$car = new Car();$car-&gt;speedUp(); //调用不存在的方法会使用重载echo $car-&gt;speed;</code></pre><h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><p>对象比较，当同一个类的两个实例的所有属性都相等时，可以使用比较运算符==进行判断，当需要判断两个变量是否为同一个对象的引用时，可以使用全等运算符===进行判断。</p><pre><code>class Car {}$a = new Car();$b = new Car();if ($a == $b) echo &apos;==&apos;;   //trueif ($a === $b) echo &apos;===&apos;; //false</code></pre><p>对象复制，在一些特殊情况下，可以通过关键字clone来复制一个对象，这时__clone方法会被调用，通过这个魔术方法来设置属性的值。</p><pre><code>class Car {public $name = &apos;car&apos;;public function __clone() {$obj = new Car();$obj-&gt;name = $this-&gt;name;}}$a = new Car();$a-&gt;name = &apos;new car&apos;;$b = clone $a;var_dump($b);</code></pre><p>对象序列化，可以通过serialize方法将对象序列化为字符串，用于存储或者传递数据，然后在需要的时候通过unserialize将字符串反序列化成对象进行使用。</p><pre><code>class Car {public $name = &apos;car&apos;;}$a = new Car();$str = serialize($a); //对象序列化成字符串echo $str.&apos;&lt;br&gt;&apos;;$b = unserialize($str); //反序列化为对象var_dump($b);</code></pre>]]></content>
    
    <summary type="html">
    
      所谓万物皆对象，我相信做过面向对象开发的人应该都知道这个到底，但是真正理解开发中的面向对应只有真实动手开发并且慢慢总结才能知道里面的含义，iOS可谓是纯面向对象的语言，当然还有很多其他的....
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="万物皆对象" scheme="https://icocos.github.io/tags/%E4%B8%87%E7%89%A9%E7%9A%86%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
</feed>
