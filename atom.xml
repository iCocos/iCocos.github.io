<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iCocos</title>
  
  <subtitle>www.icocos.cn</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://icocos.github.io/"/>
  <updated>2018-10-18T05:20:02.194Z</updated>
  <id>https://icocos.github.io/</id>
  
  <author>
    <name>曹理鹏@iCocos</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cocos2dx lua 绑定详解与实战</title>
    <link href="https://icocos.github.io/2018/10/18/cocos2dx-lua-%E7%BB%91%E5%AE%9A%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98/"/>
    <id>https://icocos.github.io/2018/10/18/cocos2dx-lua-绑定详解与实战/</id>
    <published>2018-10-18T05:04:37.000Z</published>
    <updated>2018-10-18T05:20:02.194Z</updated>
    
    <content type="html"><![CDATA[<p>我们平时在开发cocos2dx lua游戏的时候的，会遇到这样的情况：</p><ul><li>在c++层定义了一些类，我们需要将这些类导出给Lua来使用，从而完成在c++层实现起来容易的需要，这个时候就需要将整个类作为模块导出。</li><li>而Cocos2d-x正是采用的这种思想，将Cocos中的类导出供用户使用，而不是再写一套Lua代码，用户使用Cocos导出的这套接口，在Lua脚本层写游戏代码。</li><li>为了更好的理解这部分的内容，可以先看一下在Lua中调用c++函数这篇博客，了解c++中调用Lua的机制。该博客中我们将c++中需要导出的函数放到了一个模块中，其中我们手动的做了一些工作。</li></ul><a id="more"></a><p>前面我们说到了，Lua的本质是C，不是C++，Lua提供给C用的API也都是基于面向过程的C函数来用的，要把C++类注册进Lua形成一个一个的table环境是不太容易一下子办到的事。</p><p>为了实现我们的需求，同样也是官方的需求，在Cocos 2.x版本的时候，使用的是tolua++这个工具，但是这个工具用起来相当的麻烦，耗费体力，所以现在使用的是<a href="https://github.com/cocos2d/bindings-generator" target="_blank" rel="noopener">bindings-generator</a>工具（官方用Python写的一个工具），这个东西底层使用的也应该是tolua++。</p><blockquote><p>这里只针对iOS平台，Android和其他平台在tolua中README.mdown中有具体介绍，其他步骤基本上一样！</p></blockquote><p>在项目跟目录framework/cocos2d-x/cocos中创建mybinding文件夹，里面创建一个MyBinding.h文件(mybinding, MyBinding自定义)，输入如下测试代码</p><pre><code>#include &quot;cocos2d.h&quot;namespace cocos2d {class MyBinding: public Ref {public:virtual bool init() {return true;}void sayBinding() {log(&quot;Hello Binding Lua&quot;);}MyBinding();~MyBinding();}}</code></pre><p>在framework/cocos2d-x/tools/tolua，新建一个配置文件，这里命名cocos2dx_binding.ini</p><p>输入下面代码：（处理标记修改处其他所有都一样）</p><pre><code>[cocos2dx_binding] # 标记修改# the prefix to be added to the generated functions. You might or might not use this in your own# templatesprefix = cocos2dx_binding # 标记修改# create a target namespace (in javascript, this would create some code like the equiv. to `ns = ns || {}`)# all classes will be embedded in that namespacetarget_namespace = cc # 标记修改# --------- ?#android_headers = -I%(androidndkdir)s/platforms/android-19/arch-arm/usr/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.7/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.7/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.8/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.8/includeandroid_headers = -I%(androidndkdir)s/platforms/android-19/arch-arm/usr/lib -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/include# --------- ?android_flags = -D_SIZE_T_DEFINED_#clang_headers = -I%(clangllvmdir)s/lib/clang/%(clang_version)s/includeclang_headers = -I%(clangllvmdir)s/lib64/clang/5.0/includeclang_flags = -nostdinc -x c++ -std=c++11 -U __SSE__# --------- ?# -I%(cocosdir)s/jsext -I%(cocosdir)s/jsext/system -I%(cocosdir)s/jsext/alipay  -I%(cocosdir)s/jsext/video -I%(cocosdir)s/jsext/webview -I%(cocosdir)s/jsext/umengcocos_headers = -I%(cocosdir)s -I%(cocosdir)s/cocos -I%(cocosdir)s/cocos/base -I%(cocosdir)s/cocos/platform/android -I%(cocosdir)s/extensions -I%(cocosdir)s/external -I%(cocosdir)s/cocos/editor-support -I%(cocosdir)s/cocos/network -I%(cocosdir)s/cocos/ui/UIEditBox -I%(cocosdir)s/cocos/ui#cocos_headers = -I%(cocosdir)s -I%(cocosdir)s/cocos -I%(cocosdir)s/cocos/platform/androidcocos_flags = -DANDROIDcxxgenerator_headers =# extra arguments for clangextra_arguments = %(android_headers)s %(clang_headers)s %(cxxgenerator_headers)s %(cocos_headers)s %(android_flags)s %(clang_flags)s %(cocos_flags)s %(extra_flags)s# what headers to parse 头文件路径headers = %(cocosdir)s/cocos/mybinding/MyBinding.h # 标记修改# what classes to produce code for. You can use regular expressions here. When testing the regular# expression, it will be enclosed in &quot;^$&quot;, like this: &quot;^Menu*$&quot;.#包含的类，新添加文件需要修改classes = MyBinding.* # 标记修改#需要在js里面派生的类#classes_need_extend = MyBinding # 标记修改# what should we skip? in the format ClassName::[function function]# ClassName is a regular expression, but will be used like this: &quot;^ClassName$&quot; functions are also# regular expressions, they will not be surrounded by &quot;^$&quot;. If you want to skip a whole class, just# add a single &quot;*&quot; as functions. See bellow for several examples. A special class name is &quot;*&quot;, which# will apply to all class names. This is a convenience wildcard to be able to skip similar named# functions from all classes.skip =rename_functions =rename_classes =# for all class names, should we remove something when registering in the target VM?remove_prefix =# classes for which there will be no &quot;parent&quot; lookupclasses_have_no_parents =# base classes which will be skipped when their sub-classes found them.base_classes_to_skip = Ref# classes that create no constructor# Set is special and we will use a hand-written constructorabstract_classes =# Determining whether to use script object(js object) to control the lifecycle of native(cpp) object or the other way around. Supported values are &apos;yes&apos; or &apos;no&apos;.script_control_cpp = no</code></pre><p>注意检查一下三个头文件对应的路径及文件问题</p><p>android_headers<br>clang_headers<br>cocos_headers</p><ul><li>说明内容：<ul><li>•[title]：要配置将被使用的工具/ tolua的/ gengindings.py脚本的称号。一般来说，标题可以是文件名。</li><li>•prefix：要配置一个函数名的前缀，通常，我们还可以使用文件名作为前缀。</li><li>•target_namespace：要配置在脚本层模块的名字。在这里，我们使用cc作为模块名，当你想在脚本层REF的名称，您必须将一个名为前缀，CC在名称的前面。例如，CustomClass可以参考作为cc.CustomClass。</li><li>•headers：要配置所有需要解析的头文件和％（cocosdir）s是的Cocos2d-x的引擎的根路径。</li><li>•classes：要配置所有绑定所需的类。在这里，它支持正则表达式。因此，我们可以设置MyCustomClass。*在这里，用于查找多个特定的用法，你可以对照到tools/tolua/cocos2dx.ini。</li><li>•skip：要配置需要被忽略的功能。现在绑定发电机无法解析的void *类型，并委托类型，所以这些类型的需要进行手动绑定。而在这种情况下，你应该忽略所有这些类型，然后再手动将它们绑定。你可以对照到配置文件路径下的cocos/scripting/lua-bindings/auto 。</li><li>•rename_functions：要配置的功能需要在脚本层进行重命名。由于某些原因，开发者希望更多的脚本友好的API，所以配置选项就是为了这个目的。</li><li>•rename_classes：不在使用。</li><li>•remove_prefix：不在使用。</li><li>•classes_have_no_parents：要配置是过滤器所需要的父类。这个选项是很少修改。</li><li>•abstract_classes：要配置的公共构造并不需要导出的类。</li><li>•script_control_cpp：是的。要配置脚本层是否管理对象的生命周期。如果没有，那么C++层关心他们的生命周期。现在，它是不完善的，以控制原生对象的续航时间在脚本层。所以，你可以简单地把它设置为no</li></ul></li></ul><p>修改framework/cocos2d-x/tools/tolua里面的genbindings.py。有个cmd_args键值对的配置，增加下面代码，作为自定义绑定配置</p><pre><code>&apos;cocos2dx_binding.ini&apos; : (&apos;cocos2dx_binding&apos;, &apos;lua_cocos2dx_binding_auto&apos;), \</code></pre><blockquote><p>注：python注释为#，这里将cmd_args其他的元素注释掉是因为这些文件都是生成过得，没必要再生成浪费时间<br>这行代码表示在cocos2dx_custom中找到cocos2dx_custom的模块，然后生成lua_cocos2dx_custom_auto文件</p></blockquote><p>这里要确保NDK_ROOT，和PYTHON_BIN安装切配置好了,然后在framework/cocos2d-x/tools/tolua执行</p><pre><code>./genbindings.py</code></pre><p>之前./genbindings.py之前，请先查看官方tolua中README文件，按照对应的流程，安装好需要的依赖，和相应的库，下面是我这边3.17最新的README</p><pre><code>* The OSX 10.1&lt;!--0 has a built-in python2.7 and if your os don&apos;t have python2.7 then use [Homebrew](http://brew.sh/) to install the python and use pip install the python dependencies.&lt;pre&gt;brew install python&lt;/pre&gt;* Install python dependices by pip.&lt;pre&gt;sudo easy_install pipsudo pip install PyYAMLsudo pip install Cheetah&lt;/pre&gt;* Download NDK 64bit r10c or later from [Android Ndk](https://developer.android.com/ndk/downloads/index.html)* Run&lt;pre&gt;export NDK_ROOT=/path/to/android-ndk-10c./genbindings.py&lt;/pre&gt;--&gt;</code></pre><p>大概意思就是下载r10c之后版的NDK本，然后安装python(这一步一般Mac都有，但是最好安装到2.x)。</p><p>大概意思就是安装，pip， PyYAML， Cheetah</p><p>…….</p><p>执行./genbindings.py之后生成在</p><pre><code>工程目录\frameworks\cocos2d-x\cocos\scripting\lua-bindings\auto</code></pre><p>下便有了两个生成的文件</p><pre><code>lua_cocos2dx_custom_auto.cpplua_cocos2dx_custom_auto.hpp</code></pre><p>进入到文件夹</p><pre><code>C:\Users\user\Documents\Cocos\Link\frameworks\cocos2d-x\cocos\scripting\lua-bindings\manual打开CCLuaStack.cpp，添加#include &quot;lua_cocos2dx_custom_auto.hpp&quot;register_all_cocos2dx_custom(_state);</code></pre><h3 id="期间遇到的错误"><a href="#期间遇到的错误" class="headerlink" title="期间遇到的错误"></a>期间遇到的错误</h3><h5 id="错误一"><a href="#错误一" class="headerlink" title="错误一"></a>错误一</h5><pre><code>Traceback (most recent call last):File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1799, in &lt;module&gt;main()File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1772, in main&apos;clang_args&apos;: (config.get(s, &apos;extra_arguments&apos;, 0, dict(userconfig.items(&apos;DEFAULT&apos;))) or &quot;&quot;).split(&quot; &quot;),File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/ConfigParser.py&quot;, line 623, in getreturn self._interpolate(section, option, value, d)File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/ConfigParser.py&quot;, line 691, in _interpolateself._interpolate_some(option, L, rawval, section, vars, 1)File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/ConfigParser.py&quot;, line 726, in _interpolate_somesection, map, depth + 1)File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/ConfigParser.py&quot;, line 723, in _interpolate_someoption, section, rest, var)InterpolationMissingOptionError: Bad value substitution:section: [cocos2dx_custom]option : extra_argumentskey    : clang_versionrawval : /include</code></pre><p>路径错误</p><pre><code>#clang_headers = -I%(clangllvmdir)s/lib/clang/%(clang_version)s/includeclang_headers = -I%(clangllvmdir)s/lib64/clang/5.0/include  # --------- ?</code></pre><h5 id="错误二"><a href="#错误二" class="headerlink" title="错误二"></a>错误二</h5><pre><code>Traceback (most recent call last):File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1799, in &lt;module&gt;main()File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1795, in maingenerator.generate_code()File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1444, in generate_codeself._parse_headers()File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1487, in _parse_headersraise Exception(&quot;Fatal error in parsing headers&quot;)Exception: Fatal error in parsing headers---------------------------------Generating lua bindings fails.---------------------------------</code></pre><p>C++语法错误</p><h5 id="错误三"><a href="#错误三" class="headerlink" title="错误三"></a>错误三</h5><pre><code>Generating bindings for cocos2dx_custom...Using userconfig[(&apos;androidndkdir&apos;, &apos;/Users/iCocos/tools/android-ndk-r16b&apos;), (&apos;clangllvmdir&apos;, &apos;/Users/iCocos/tools/android-ndk-r16b/toolchains/llvm/prebuilt/darwin-x86_64&apos;), (&apos;gcc_toolchain_dir&apos;, &apos;/Users/iCocos/tools/android-ndk-r16b/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64&apos;), (&apos;cocosdir&apos;, &apos;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x&apos;), (&apos;cxxgeneratordir&apos;, &apos;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator&apos;), (&apos;extra_flags&apos;, &apos;&apos;)].... Generating bindings for target lua.... .... Processing section cocos2dx_customTraceback (most recent call last):File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1799, in &lt;module&gt;main()File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1795, in maingenerator.generate_code()File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1444, in generate_codeself._parse_headers()File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1478, in _parse_headerstu = self.index.parse(header, self.clang_args)File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/clang/cindex.py&quot;, line 2602, in parseself)File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/clang/cindex.py&quot;, line 2714, in from_sourceraise TranslationUnitLoadError(&quot;Error parsing translation unit.&quot;)TranslationUnitLoadError: Error parsing translation unit.---------------------------------Generating lua bindings fails.---------------------------------</code></pre><p>路径错误</p><pre><code>#android_headers = -I%(androidndkdir)s/platforms/android-19/arch-arm/usr/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.7/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.7/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.8/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.8/includeandroid_headers = -I%(androidndkdir)s/platforms/android-19/arch-arm/usr/lib -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/include</code></pre><h5 id="错误四"><a href="#错误四" class="headerlink" title="错误四"></a>错误四</h5><pre><code>====Errors in parsing headers:1. &lt;severity = Fatal,location = &lt;SourceLocation file &apos;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/cocos/platform/android/CCPlatformDefine-android.h&apos;, line 33, column 10&gt;,details = &quot;&apos;android/log.h&apos; file not found&quot;&gt;====</code></pre><h3 id="提示成功"><a href="#提示成功" class="headerlink" title="提示成功"></a>提示成功</h3><pre><code>---------------------------------Generating lua bindings succeeds.---------------------------------</code></pre><p>######致谢：</p><ul><li><a href="https://blog.csdn.net/never_QH/article/details/45148835" target="_blank" rel="noopener">https://blog.csdn.net/never_QH/article/details/45148835</a></li><li><a href="http://geekgaoyang.herokuapp.com/blog/2015/02/11/cocos2d-x-tutorial-of-binding-c-plus-plus-class-to-lua-usage/" target="_blank" rel="noopener">http://geekgaoyang.herokuapp.com/blog/2015/02/11/cocos2d-x-tutorial-of-binding-c-plus-plus-class-to-lua-usage/</a></li><li><a href="https://www.cnblogs.com/ZhYQ-Note/p/5939783.html" target="_blank" rel="noopener">https://www.cnblogs.com/ZhYQ-Note/p/5939783.html</a></li><li><a href="http://www.bubuko.com/infodetail-1210197.html" target="_blank" rel="noopener">http://www.bubuko.com/infodetail-1210197.html</a></li><li><a href="https://www.jianshu.com/p/9bd4d5518d53" target="_blank" rel="noopener">https://www.jianshu.com/p/9bd4d5518d53</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们平时在开发cocos2dx lua游戏的时候的，会遇到这样的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在c++层定义了一些类，我们需要将这些类导出给Lua来使用，从而完成在c++层实现起来容易的需要，这个时候就需要将整个类作为模块导出。&lt;/li&gt;
&lt;li&gt;而Cocos2d-x正是采用的这种思想，将Cocos中的类导出供用户使用，而不是再写一套Lua代码，用户使用Cocos导出的这套接口，在Lua脚本层写游戏代码。&lt;/li&gt;
&lt;li&gt;为了更好的理解这部分的内容，可以先看一下在Lua中调用c++函数这篇博客，了解c++中调用Lua的机制。该博客中我们将c++中需要导出的函数放到了一个模块中，其中我们手动的做了一些工作。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>cocos2dx lua 与 C/C++ 交互入门</title>
    <link href="https://icocos.github.io/2018/10/16/cocos2dx-lua-%E4%B8%8E-C-C-%E4%BA%A4%E4%BA%92%E5%85%A5%E9%97%A8/"/>
    <id>https://icocos.github.io/2018/10/16/cocos2dx-lua-与-C-C-交互入门/</id>
    <published>2018-10-16T05:03:46.000Z</published>
    <updated>2018-10-18T05:17:02.233Z</updated>
    
    <content type="html"><![CDATA[<h5 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h5><ul><li>中间栈<ul><li>1.中间件栈<ul><li>C/C++访问Lua数据和函数</li><li>Lua访问C/C++数据和函数</li></ul></li></ul></li><li>集成Lua<ul><li>集成Lua环境到C_Cpp项目中</li></ul></li><li>C/C++ 调用Lua<ul><li>C/C++调用Lua之标准Lua读取类</li><li>C/C++调用Lua中的变量</li><li>C/C++调用Lua中的函数</li><li>C/C++调用Lua之遍历和获取Table的值</li></ul></li><li>Lua 调用 C/C++<ul><li>1.Lua调用C/C++函数<ul><li>深入理解编写C函数上</li><li>深入理解编写C函数下</li></ul></li><li>2.Lua调用C/C++之标准C模块</li></ul></li><li>待续</li></ul><a id="more"></a><h2 id="中间栈"><a href="#中间栈" class="headerlink" title="中间栈"></a>中间栈</h2><blockquote><p>lua(<a href="https://www.lua.org/)作为一种轻量级的脚本语言" target="_blank" rel="noopener">https://www.lua.org/)作为一种轻量级的脚本语言</a>, 以其简单的语法结构, 方便的c++集成能力, 高效的执行效率收到广大游戏开发者的热爱, 也是cocos2d-x官方首次引入的脚本语言.</p></blockquote><p>作为一种脚本语言, lua是在一个运行时环境(State)里执行的, 这个运行时环境保存了脚本运行所需的内存空间, 创建的全局变量, 加载的库文件等. 在这个运行时环境里还有一个栈空间(Stack), 其作用就是在lua和c语言进行数据传递和函数调用. lua原生实现了很多c api对栈空间进行操作, 让开发者能够方便地实现lua脚本代码与c编译代码的双向通信.</p><h4 id="1-中间件栈"><a href="#1-中间件栈" class="headerlink" title="1.中间件栈"></a>1.中间件栈</h4><blockquote><p>背后其实是lua和c api的互相调用, 所有c++的功能都要通过一层c函数的包装, 这点是要牢记在心的, 这也正是lua-binding的核心.</p></blockquote><p>cocos2d-x提供的lua-bingding工具使用libclang分析c++源码, 提取语法树, 将c++的类成员函数封装为c函数, 然后根据参数类型自动调用lua c api, 实现对栈空间的操作, 将c++的数据传递给lua. lua脚本加载编译好的c++库, 就可以自由调用c++里面的类对象和成员函数了; c++的代码则可以直接使用lua c api, 执行一段lua脚本, 并通过栈空间获取返回结果.</p><p>开始撸代码 ——————————- 华丽的分割线 ——————————-</p><ol><li>创建一个Lua管理类，</li></ol><p>用利用栈的原理，使用C++简单访问Lua</p><h6 id="h文件"><a href="#h文件" class="headerlink" title=".h文件"></a>.h文件</h6><pre><code>#ifndef LuaInterface01_h#define LuaInterface01_h#include &lt;stdio.h&gt;#include &quot;lua.hpp&quot;class LuaInterface01 {public:static LuaInterface01 *shareInterface();private:static LuaInterface01 *i;void init();};#endif /* LuaInterface01_hpp */</code></pre><h6 id="cpp文件"><a href="#cpp文件" class="headerlink" title=".cpp文件"></a>.cpp文件</h6><pre><code>#include &quot;LuaInterface01.h&quot;#include &quot;cocos2d.h&quot;#include &lt;string&gt;USING_NS_CC;using namespace std;LuaInterface01 *LuaInterface01::i = NULL;LuaInterface01 *LuaInterface01::shareInterface() {if (!i) {i = new LuaInterface01;i -&gt; init();}return i;}void LuaInterface01::init() {// 创建一个Lua状态指针lua_State *luaState = luaL_newstate();luaL_openlibs(luaState);string path = CCFileUtils::sharedFileUtils()-&gt;fullPathForFilename(&quot;Interface01.lua&quot;);luaL_dofile(luaState, path.c_str());lua_pcall(luaState, 0, 0, 0); // Hello iCocos LuaInterface01!}</code></pre><p>新建一个.lua的访问类文件，并且输入</p><pre><code>print(&quot;Hello iCocos LuaInterface01!&quot;)</code></pre><p>控制答应结果：</p><pre><code>Hello iCocos LuaInterface01!</code></pre><blockquote><p>下面用简单的Lua与C/C++互调，验证中间件栈， 如果想了解更多或者更详细的实现Lua与C/C++，请略过本小结，滑到第三部分，或者通过目录寻找需要的内容！</p></blockquote><h6 id="C-C-访问Lua数据和函数"><a href="#C-C-访问Lua数据和函数" class="headerlink" title="C/C++访问Lua数据和函数"></a>C/C++访问Lua数据和函数</h6><ol><li>创建一个Lua管理类，</li></ol><h6 id="h文件-1"><a href="#h文件-1" class="headerlink" title=".h文件"></a>.h文件</h6><pre><code>#ifndef LuaInterface02_h#define LuaInterface02_h#include &lt;stdio.h&gt;#include &quot;lua.hpp&quot;#include &quot;cocos2d.h&quot;USING_NS_CC;class LuaInterface02 {public:LuaInterface02();~LuaInterface02();static LuaInterface02 *shareInterface();void init();void readVariable();void loadFunstion();private:static LuaInterface02 *i;lua_State *m_pLuaState;};#endif /* LuaInterface02_h */</code></pre><h6 id="cpp文件-1"><a href="#cpp文件-1" class="headerlink" title=".cpp文件"></a>.cpp文件</h6><pre><code>#include &quot;LuaInterface02.h&quot;#include &lt;string&gt;using namespace std;LuaInterface02 *LuaInterface02::i = NULL;LuaInterface02::LuaInterface02() {}LuaInterface02::~LuaInterface02() {if (m_pLuaState) {lua_close(m_pLuaState);m_pLuaState = NULL;}}LuaInterface02 *LuaInterface02::shareInterface() {if (!i) {i = new LuaInterface02;i -&gt; init();}return i;}void LuaInterface02::init() {m_pLuaState = luaL_newstate();luaL_openlibs(m_pLuaState);}void LuaInterface02::readVariable() {string path = CCFileUtils::sharedFileUtils()-&gt;fullPathForFilename(&quot;Interface02.lua&quot;);luaL_dofile(m_pLuaState, path.c_str());int err_relt = lua_pcall(m_pLuaState, 0, 0, 0);CCAssert(err_relt, &quot;读取Lua文件错误&quot;);lua_getglobal(m_pLuaState, &quot;username&quot;);char *rlt = (char*)lua_tostring(m_pLuaState, -1);  //lua_tonumber,lua_tobooleanCCLOG(&quot;rlt is : %s&quot;, rlt);lua_pop(m_pLuaState, 1);}void LuaInterface02::loadFunstion() {string path = CCFileUtils::sharedFileUtils()-&gt;fullPathForFilename(&quot;Interface02.lua&quot;);luaL_dofile(m_pLuaState, path.c_str());int err_relt = lua_pcall(m_pLuaState, 0, 0, -1);CCAssert(err_relt != -1, &quot;读取Lua文件错误&quot;);lua_getglobal(m_pLuaState, &quot;getResult&quot;);lua_pushnumber(m_pLuaState, 12);err_relt = lua_pcall(m_pLuaState, 1, 2, -1); // 1： 一个参数， 2：两个参数 ， -1：当出错的时候的返回值CCAssert(err_relt != -1, &quot;访问函数报错&quot;);char *rlt = (char*)lua_tostring(m_pLuaState, -1);  //lua_tonumber,lua_tobooleanCCLOG(&quot;rlt is : %s&quot;, rlt);char *rlt2 = (char*)lua_tostring(m_pLuaState, -2);  //lua_tonumber,lua_tobooleanCCLOG(&quot;rlt2 is : %s&quot;, rlt2);}</code></pre><p>新建一个.lua的访问类文件，并且输入</p><pre><code>username = &quot;iCocos&quot;function getResult(x)print(&quot;Enter Result&quot;)print(&quot;x:&quot;..x)return &quot;OK&quot;,&quot;Function&quot;end</code></pre><p>控制答应结果：</p><pre><code>rlt is : iCocosEnter Resultx:12rlt is : Functionrlt2 is : OK</code></pre><h6 id="Lua访问C-C-数据和函数"><a href="#Lua访问C-C-数据和函数" class="headerlink" title="Lua访问C/C++数据和函数"></a>Lua访问C/C++数据和函数</h6><p>LuaInterface02.h中增加函数</p><pre><code>// 调用C++static int l_show(lua_State * L) {lua_pushstring(L, &quot;String from C/C++&quot;);return 1;}</code></pre><p>然后在init()中输入执行方法</p><pre><code>// 调用C++lua_pushcfunction(m_pLuaState, l_show);lua_setglobal(m_pLuaState, &quot;show&quot;);</code></pre><p>然后在.lua的访问类文件，并且输入</p><pre><code>print(show())</code></pre><p>控制答应结果：</p><pre><code>String from C/C++</code></pre><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote><p>简单点讲就是维护了一个堆栈，需要交互的数据通过入栈，出栈操作来传递数据。而具体脚本语言的实现机制，一般来说都会有一个编译模块、一个虚拟机（执行）模块、一套类型实现及数据管理模块，通常还会有一个供外部操作的接口，如lua c api，这个接口让嵌入方得以操作脚本状态（如访问变量、调用函数、管理内存），实现交互。</p></blockquote><p>最后，总结一下，所有程序最终都是以机器码的形式被硬件CPU执行，从这个角度去看，不同语言的代码并没有本质区别，最终都是被编译器编译从二进制机器码，而所谓交互，就是在处理共享数据而已。</p><ul><li>注意</li><li>Lua与C/C++或C/C++语言之前那通信过程中，实际上更多的时候是对栈顶的元素进行操作</li><li>从栈顶往下看索引是-1-2-3…</li><li>从栈底往上看索引是1，2，3…</li><li>无论从Lua调C/C++，还是C/C++调Lua，参数值都是最先被压入到栈顶的，最后结果值才会被压入到栈顶</li></ul><h2 id="集成Lua"><a href="#集成Lua" class="headerlink" title="集成Lua"></a>集成Lua</h2><h4 id="集成Lua环境到C-C-项目中"><a href="#集成Lua环境到C-C-项目中" class="headerlink" title="集成Lua环境到C/C++项目中"></a>集成Lua环境到C/C++项目中</h4><blockquote><p>下载并获取到Lua源代码(src文件夹就是lua源码)<a href="https://www.lua.org/" target="_blank" rel="noopener">https://www.lua.org/</a></p></blockquote><p>在lua中文件类型有三种</p><ul><li>.c c文件</li><li>.h 头文件</li><li>.o 可执行文件</li></ul><h5 id="开始接入"><a href="#开始接入" class="headerlink" title="开始接入"></a>开始接入</h5><ul><li>接入Lua到C/C++的时候需要删除</li><li>lua.c</li><li>luac.c</li><li>MakeFile</li></ul><p>新建一个Xcode项目，拷贝src文件夹到项目中就可以了</p><h5 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h5><blockquote><p>在llex.c中trydecpoint, 修改里面decpoint=“getlocaldecpoint”</p><p>decpoint=’.’</p><p>如果不改会导致编译报错</p></blockquote><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>新建一个C++文件，在头文件中输入</p><pre><code>#include &lt;stdio.h&gt;#include &quot;lua.hpp&quot;#include &quot;cocos2d.h&quot;USING_NS_CC;class TestInportLua {public:void test() {lua_State *state = luaL_newstate();luaL_openlibs(state);luaL_dofile(state, &quot;res/test.lua&quot;);}}#endif /* TestInportLua_h */</code></pre><h2 id="C-C-调用Lua"><a href="#C-C-调用Lua" class="headerlink" title="C/C++ 调用Lua"></a>C/C++ 调用Lua</h2><h4 id="C-C-调用Lua之标准Lua读取类"><a href="#C-C-调用Lua之标准Lua读取类" class="headerlink" title="C/C++调用Lua之标准Lua读取类"></a>C/C++调用Lua之标准Lua读取类</h4><ol><li>创建一个Lua管理类，</li></ol><h6 id="h文件-2"><a href="#h文件-2" class="headerlink" title=".h文件"></a>.h文件</h6><pre><code>#ifndef LuaInterface03_hpp#define LuaInterface03_hpp#include &quot;cocos2d.h&quot;#include &quot;lua.hpp&quot;#include &lt;string&gt;USING_NS_CC;using namespace std;class LuaInterface03 {public:LuaInterface03();~LuaInterface03();static LuaInterface03 *shareInterface();void readVailable();void loadFunciton();private:static LuaInterface03 *i;lua_State *m_pLuaState;void init();};#endif /* LuaInterface03_hpp */</code></pre><h6 id="cpp文件-2"><a href="#cpp文件-2" class="headerlink" title=".cpp文件"></a>.cpp文件</h6><pre><code>#include &quot;LuaInterface03.h&quot;LuaInterface03 *LuaInterface03::i = NULL;LuaInterface03::LuaInterface03(){}LuaInterface03::~LuaInterface03(){lua_close(m_pLuaState);m_pLuaState = NULL;}void LuaInterface03::init() {// 创建一个新的状态m_pLuaState = luaL_newstate();// 打开所有系统提供的库luaL_openlibs(m_pLuaState);// 完整路径string path = CCFileUtils::sharedFileUtils()-&gt;fullPathForFilename(&quot;LuaInterface03.lua&quot;);// 读取文件luaL_dofile(m_pLuaState, path.c_str());// 启动调用文件lua_pcall(m_pLuaState, 0, 0, -1);}LuaInterface03 *LuaInterface03::shareInterface() {if (!i) {i = new LuaInterface03;i -&gt; init();}return i;}</code></pre><p>新建一个.lua的访问类文件，并且输入</p><pre><code>print(&quot;=======&gt; I am Lua Config&quot;)</code></pre><p>控制答应结果：</p><pre><code>=======&gt; I am Lua Config</code></pre><h4 id="C-C-调用Lua中的变量"><a href="#C-C-调用Lua中的变量" class="headerlink" title="C/C++调用Lua中的变量"></a>C/C++调用Lua中的变量</h4><p>增加方法和对应的实现，用来获取变量</p><pre><code>void configWindowContentSize();void LuaInterface03::configWindowContentSize() {lua_getglobal(m_pLuaState, &quot;width&quot;);// 是否能转换成numberif (lua_isnumber(m_pLuaState, -1)) {int width = (int)lua_tonumber(m_pLuaState, -1);CCLOG(&quot;width: %i&quot;, width);}lua_getglobal(m_pLuaState, &quot;height&quot;);if (lua_isnumber(m_pLuaState, -1)) {int height = (int)lua_tonumber(m_pLuaState, -1);CCLOG(&quot;height: %i&quot;, height);}}</code></pre><p>Lua中增加变量</p><pre><code>width = 320height = 640</code></pre><p>控制答应结果：</p><pre><code>width: 320height: 640</code></pre><h4 id="C-C-调用Lua中的函数"><a href="#C-C-调用Lua中的函数" class="headerlink" title="C/C++调用Lua中的函数"></a>C/C++调用Lua中的函数</h4><p>增加方法和对应的实现，用来获取变量</p><pre><code>void callLuaFunctionContent();void LuaInterface03::callLuaFunctionContent() {lua_getglobal(m_pLuaState, &quot;test1&quot;);int err_relt = lua_pcall(m_pLuaState, 0, 0, -1);CCAssert(err_relt != -1, &quot;访问函数报错&quot;);lua_getglobal(m_pLuaState, &quot;test2&quot;);lua_pushstring(m_pLuaState, &quot;test2 调用&quot;);err_relt = lua_pcall(m_pLuaState, 1, 0, -1); // 1： 一个参数， 2：两个参数 ， -1：当出错的时候的返回值CCAssert(err_relt != -1, &quot;访问函数报错&quot;);lua_getglobal(m_pLuaState, &quot;test3&quot;);err_relt = lua_pcall(m_pLuaState, 0, 0, -1);CCAssert(err_relt != -1, &quot;访问函数报错&quot;);char* rlt = (char*)lua_tostring(m_pLuaState, -1);CCLOG(&quot;rlt is %s&quot;,rlt);lua_getglobal(m_pLuaState, &quot;test4&quot;);lua_pushnumber(m_pLuaState, 10);err_relt = lua_pcall(m_pLuaState, 1, 2, -1); // 1： 一个参数， 2：两个参数 ， -1：当出错的时候的返回值CCAssert(err_relt != -1, &quot;访问函数报错&quot;);int rlt2 = (int)lua_tonumber(m_pLuaState, -1);CCLOG(&quot;rlt is %i&quot;,rlt2);lua_getglobal(m_pLuaState, &quot;test5&quot;);lua_pushnumber(m_pLuaState, 100);err_relt = lua_pcall(m_pLuaState, 1, 2, -1); // 1： 一个参数， 2：两个参数 ， -1：当出错的时候的返回值CCAssert(err_relt != -1, &quot;访问函数报错&quot;);int rlt3 = (int)lua_tonumber(m_pLuaState, -1);int rlt4 = (int)lua_tonumber(m_pLuaState, -1);CCLOG(&quot;rlt is %i&quot;,rlt3);CCLOG(&quot;rlt is %i&quot;,rlt4);}</code></pre><p>Lua中增加变量</p><pre><code>function test1()print(&quot;call lua function&quot;)endfunction test2(var)print(&quot;call lua function&quot;, var)endfunction test3()return &quot;I am Lua test3&quot;endfunction test4(var)var = var + 10return varendfunction test5(var)t = 10var = var + 10return t, varend</code></pre><p>控制答应结果：</p><pre><code>call lua functioncall lua function test1 调用</code></pre><h4 id="C-C-调用Lua之遍历和获取Table的值"><a href="#C-C-调用Lua之遍历和获取Table的值" class="headerlink" title="C/C++调用Lua之遍历和获取Table的值"></a>C/C++调用Lua之遍历和获取Table的值</h4><p>增加方法</p><pre><code>char* getField(lua_State *L, const char* key);char* getField(lua_State *L, const char* key) {char *rlt = NULL;lua_pushstring(L, key);lua_gettable(L, -2);if (lua_isstring(L, -1)) {rlt = (char*)lua_tostring(L, -1);lua_pop(L, 1);return rlt;}return &quot;error&quot;;}</code></pre><p>初始化方法(void LuaInterface03::init())中增加如下代码</p><pre><code>lua_getglobal(m_pLuaState, &quot;application&quot;);if (lua_isnumber(m_pLuaState, -1)) {char *width = getField(m_pLuaState, &quot;width&quot;);char *height = getField(m_pLuaState, &quot;height&quot;);CCLOG(&quot;width:%s&quot;, width);CCLOG(&quot;height:%s&quot;, height);int nWidth = atoi(width);int nHeight = atoi(height);}</code></pre><p>Lua中增加Table</p><pre><code>application = {width = 320,height = 640,}</code></pre><h2 id="Lua-调用-C-C"><a href="#Lua-调用-C-C" class="headerlink" title="Lua 调用 C/C++"></a>Lua 调用 C/C++</h2><h4 id="1-Lua调用C-C-函数"><a href="#1-Lua调用C-C-函数" class="headerlink" title="1.Lua调用C/C++函数"></a>1.Lua调用C/C++函数</h4><ol><li>创建一个Lua管理类，</li></ol><h6 id="h文件-3"><a href="#h文件-3" class="headerlink" title=".h文件"></a>.h文件</h6><pre><code>#ifndef LuaInterface04_hpp#define LuaInterface04_hpp#include &lt;stdio.h&gt;#include &quot;cocos2d.h&quot;#include &quot;lua.hpp&quot;#include &lt;string&gt;USING_NS_CC;using namespace std;class LuaInterface04 {public:LuaInterface04();~LuaInterface04();static LuaInterface04 *shareInterface();static int l_getMyName(lua_State * L)private:static LuaInterface04 *i;lua_State *m_pLuaState;void init();};#endif /* LuaInterface04_hpp */</code></pre><h6 id="cpp文件-3"><a href="#cpp文件-3" class="headerlink" title=".cpp文件"></a>.cpp文件</h6><pre><code>#include &quot;LuaInterface04.h&quot;LuaInterface04 *LuaInterface04::i = NULL;LuaInterface04::LuaInterface04(){}LuaInterface04::LuaInterface04(){if (m_pLuaState) {lua_close(m_pLuaState);m_pLuaState = NULL;}}// 调用C++static int l_getMyName(lua_State * L) {lua_pushstring(L, &quot;String from C/C++&quot;);return 1;}void LuaInterface04::init() {// 创建一个新的状态m_pLuaState = luaL_newstate();// 打开所有系统提供的库luaL_openlibs(m_pLuaState);// 调用C++lua_pushcfunction(m_pLuaState, l_getMyName);lua_setglobal(m_pLuaState, &quot;getMyName&quot;);string path = CCFileUtils::sharedFileUtils()-&gt;fullPathForFilename(&quot;Interface04.lua&quot;);luaL_dofile(m_pLuaState, path.c_str());lua_pcall(m_pLuaState, 0, 0, -1);}LuaInterface04 *LuaInterface04::shareInterface() {if (!i) {i = new LuaInterface04;i -&gt; init();}return i;}</code></pre><p>新建一个.lua的访问类文件，并且输入</p><pre><code>print(&quot;Begin&quot;)print(getMyName())print(&quot;End&quot;)</code></pre><p>控制答应结果：</p><pre><code>BeginString from C/C++End</code></pre><h6 id="深入理解编写C函数上"><a href="#深入理解编写C函数上" class="headerlink" title="深入理解编写C函数上"></a>深入理解编写C函数上</h6><p>增加register_my_function方法</p><h6 id="h"><a href="#h" class="headerlink" title=".h"></a>.h</h6><pre><code>static int l_showName(lua_State *L);static int l_showYoueName(lua_State *L);static void register_my_function(lua_State *L);</code></pre><h6 id="cpp"><a href="#cpp" class="headerlink" title=".cpp"></a>.cpp</h6><pre><code>static int l_showName(lua_State *L) {const char * value1 = luaL_checkstring(L, -1);const char * value2 = luaL_checkstring(L, -2);const char * value3 = luaL_checkstring(L, -3);CCLOG(&quot;value1 is :%s&quot;, value1);CCLOG(&quot;value2 is :%s&quot;, value2);CCLOG(&quot;value3 is :%s&quot;, value3);//lua_pushstring(L, value1);return 1;}static int l_showYoueName(lua_State *L) {const char * value = luaL_checkstring(L, -1);lua_pushstring(L, value);return 1;}static void register_my_function(lua_State *L) {lua_pushcfunction(L, LuaInterface04::l_getMyName);lua_setglobal(L, &quot;getMyName&quot;);lua_pushcfunction(L, LuaInterface04::l_getMyName);lua_setglobal(L, &quot;showName&quot;);lua_pushcfunction(L, LuaInterface04::l_getMyName);lua_setglobal(L, &quot;show&quot;);}</code></pre><p>在init中输入如下替换原始的调用方法</p><pre><code>// 调用C++//lua_pushcfunction(m_pLuaState, l_getMyName);//lua_setglobal(m_pLuaState, &quot;getMyName&quot;);register_my_function(m_pLuaState);</code></pre><p>新建一个.lua的访问类文件，并且输入</p><pre><code>showName(&quot;Hello iCocos&quot;)show(&quot;Hello iCocos&quot;， &quot;Hello Lua&quot;)</code></pre><h6 id="深入理解编写C函数下"><a href="#深入理解编写C函数下" class="headerlink" title="深入理解编写C函数下"></a>深入理解编写C函数下</h6><p>增加register_my_function方法</p><h6 id="h-1"><a href="#h-1" class="headerlink" title=".h"></a>.h</h6><pre><code>static int lua_showreturn1(lua_State * L);static int lua_showreturn2(lua_State * L);static int lua_showreturn3(lua_State * L);static int lua_showtable(lua_State * L);static int lua_showtable2(lua_State * L);</code></pre><h6 id="cpp-1"><a href="#cpp-1" class="headerlink" title=".cpp"></a>.cpp</h6><pre><code>//print(lua_showreturn1())static int lua_showreturn1(lua_State * L) {CCLOG(&quot;I am no return&quot;);return 0;}//print(lua_showreturn2())static int lua_showreturn2(lua_State * L) {CCLOG(&quot;I am one values&quot;);lua_pushstring(L, &quot;I am one values&quot;);return 1;}//print(lua_showreturn3())static int lua_showreturn3(lua_State * L) {CCLOG(&quot;I am two values&quot;);lua_pushstring(L, &quot;I am value one&quot;);lua_pushstring(L, &quot;I am value two&quot;);return 1;}//print(lua_showtable())static int lua_showtable(lua_State * L) {CCLOG(&quot;I am a table&quot;);lua_newtable(L);char str[20] = {0};for (int i = 1; i &lt;= 10; i++) {lua_pushnumber(L, i); // 压入keysprintf(str, &quot;numert is : %i&quot;, i);lua_pushstring(L, str); // 压入valuelua_settable(L, -3); // 将前面的key和value保存到table中}return 1;}//print(lua_showtable2())static int lua_showtable2(lua_State * L) {CCLOG(&quot;I am a table2&quot;);lua_newtable(L);char str[20] = {0};int looper = 1;while (looper &lt;= 10) {sprintf(str, &quot;key%i&quot;, looper);lua_pushstring(L, str); // 压入valuelooper++;lua_settable(L, -3); // 将前面的key和value保存到table中}return 1;}</code></pre><p>在init中输入如下替换原始的调用方法</p><pre><code>// 调用C++//lua_pushcfunction(m_pLuaState, l_getMyName);//lua_setglobal(m_pLuaState, &quot;getMyName&quot;);lua_pushcfunction(L, LuaInterface04::lua_showreturn1);lua_setglobal(L, &quot;showreturn1&quot;);lua_pushcfunction(L, LuaInterface04::lua_showreturn2);lua_setglobal(L, &quot;showreturn2&quot;);lua_pushcfunction(L, LuaInterface04::lua_showreturn3);lua_setglobal(L, &quot;showreturn3&quot;);lua_pushcfunction(L, LuaInterface04::lua_showtable);lua_setglobal(L, &quot;getMyTable&quot;);lua_pushcfunction(L, LuaInterface04::lua_showtable2);lua_setglobal(L, &quot;getMyTable2&quot;);</code></pre><p>新建一个.lua的访问类文件，并且输入</p><pre><code>print(showreturn1())print(showreturn2())print(showreturn3())local t = getMyTable()for k, v in pairs(t) doprint(k, v)endlocal t2 = getMyTable2()for k, v in pairs(t2) doprint(k, v)end</code></pre><h4 id="2-Lua调用C-C-之标准C模块"><a href="#2-Lua调用C-C-之标准C模块" class="headerlink" title="2.Lua调用C/C++之标准C模块"></a>2.Lua调用C/C++之标准C模块</h4><p>在lua中init.c</p><pre><code>static int showResult1(lua_State * L) {lua_pushstring(L, &quot;I am showResult1&quot;);return 1;}static int showResult2(lua_State * L) {const char *value = luaL_checkstring(L, -1);//string rel = strcat(&quot;iCocos&quot;, value);lua_pushstring(L, value);return 1;}static const luaL_Reg myLibs[] = {{&quot;result1&quot;, showResult1},{&quot;result2&quot;, showResult2},{NULL, NULL},};int luaopen_my_lib(lua_State * L) {//luaL_newLib(L, myLibs);luaL_register(L, &quot;my_lib&quot;, myLibs);return 1;}</code></pre><p>在static const luaL_Reg loadedlibs[] 里面增加</p><pre><code>{&quot;my_lib&quot;, luaopen_my_lib},</code></pre><p>在lua中引入并调用方法</p><pre><code>--- 已入包local my_lib = require &quot;my_lib&quot;--- 调用方法print(my_lib.result1())print(my_lib.result2(&quot;I am showResult2&quot;))</code></pre><h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2><ul><li>后续的学习和开发，会相继介绍和分析一下totua，luajit，手动和自动绑定，第三个引入(支付，分析，分析，统计)，插件引入(sqlite，json,zlib)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;中间栈&lt;ul&gt;
&lt;li&gt;1.中间件栈&lt;ul&gt;
&lt;li&gt;C/C++访问Lua数据和函数&lt;/li&gt;
&lt;li&gt;Lua访问C/C++数据和函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;集成Lua&lt;ul&gt;
&lt;li&gt;集成Lua环境到C_Cpp项目中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C/C++ 调用Lua&lt;ul&gt;
&lt;li&gt;C/C++调用Lua之标准Lua读取类&lt;/li&gt;
&lt;li&gt;C/C++调用Lua中的变量&lt;/li&gt;
&lt;li&gt;C/C++调用Lua中的函数&lt;/li&gt;
&lt;li&gt;C/C++调用Lua之遍历和获取Table的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Lua 调用 C/C++&lt;ul&gt;
&lt;li&gt;1.Lua调用C/C++函数&lt;ul&gt;
&lt;li&gt;深入理解编写C函数上&lt;/li&gt;
&lt;li&gt;深入理解编写C函数下&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2.Lua调用C/C++之标准C模块&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;待续&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>cocos2dx lua —— Http请求总结与实战(封装)</title>
    <link href="https://icocos.github.io/2018/10/13/cocos2dx-lua-%E2%80%94%E2%80%94-Http%E8%AF%B7%E6%B1%82%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AE%9E%E6%88%98-%E5%B0%81%E8%A3%85/"/>
    <id>https://icocos.github.io/2018/10/13/cocos2dx-lua-——-Http请求总结与实战-封装/</id>
    <published>2018-10-13T07:38:55.000Z</published>
    <updated>2018-10-18T05:16:47.698Z</updated>
    
    <content type="html"><![CDATA[<p>今天的主题是关于cocos2dx lua实现短链接网络请求，使用Http实现基本的服务器网络数据获取，关于长链接（socket后续文件或者遇到需要的时候回特别实现与处理）</p><blockquote><p>关于Http这里就不多做介绍了，不过，作为一个程序员，网络请求是开发中最多也是最重要的一环节，这里比较建议，搞懂http的整个请求流程！</p></blockquote><p>推荐：<a href="https://blog.csdn.net/yezitoo/article/details/78193794" target="_blank" rel="noopener">一次完整的HTTP请求过程</a></p><a id="more"></a><p>在有了基本的Lua知识和cocos2dx lua基本的了解和学习之后，我有了一个初步的cocos2dx lua开发常识，然后就开始在上面实现基本的界面，并根据界面操作请求和响应数据！</p><h3 id="入口场景"><a href="#入口场景" class="headerlink" title="入口场景"></a>入口场景</h3><p>在main中初始化场景中必要的UI.</p><p>创建一个背景图片和一个按钮，实现点击按钮跳转到另外一个场景，进行网络请求和数据获取</p><pre><code>--- @class MainScenelocal MainScene = class(&quot;MainScene&quot;,cc.load(&quot;mvc&quot;).ViewBase)---onEnterfunction MainScene:onEnter()    print(&quot;onEnter&quot;)end---createStaticButton 通用创建按钮方法---@param node table---@param imageName table---@param x table---@param y table---@param callBack tablelocal function createStaticButton(node, imageName, x, y, callBack)    local btn = ccui.Button:create(imageName, imageName)    btn:move(x, y)    btn:addClickEventListener(callBack)    btn:addTo(node)end-------onCreatefunction MainScene:onCreate()    -- 初始化背景    display.newSprite(&quot;HelloWorld.png&quot;)        :move(display.center)        :addTo(self)    -- 初始化按钮    createStaticButton(self, &quot;button_start.png&quot;, display.cx, display.cy-150, function ()        self:getApp():enterScene(&quot;ApiRequest&quot;)    end)endreturn MainScene</code></pre><h3 id="网络应用场景-ApiRequest"><a href="#网络应用场景-ApiRequest" class="headerlink" title="网络应用场景(ApiRequest)"></a>网络应用场景(ApiRequest)</h3><p>然后开始处理跳转之后的ApiRequest，和相关请求逻辑，这里主要是使用我们封装好的CocosRequest实现基本上的请求逻辑，然后拿到数据之后我们就可以根据实际UI和具体业务逻辑做处理</p><blockquote><p>注意</p></blockquote><blockquote><p>测试的时候，将local url = “<a href="https://xxxx?cmd=501001&amp;uid=628941&amp;novelid=3782&quot;中的值换成自己的地址就可以" target="_blank" rel="noopener">https://xxxx?cmd=501001&amp;uid=628941&amp;novelid=3782&quot;中的值换成自己的地址就可以</a></p></blockquote><pre><code>require &quot;json&quot;local CocosRequest = require &quot;app.CocosRequest&quot;--- @class ApiRequestlocal ApiRequest = class(&quot;ApiRequest&quot;, cc.load(&quot;mvc&quot;).ViewBase)----local MainScene = class(&quot;MainScene&quot;, function() return display.newScene(&quot;MainScene&quot;) end)---onEnterfunction ApiRequest:onEnter()    print(&quot;onEnter&quot;)end-----onCreatefunction ApiRequest:onCreate()    ----------------------- 创建自定义事件 start    local function eventCustomListener1(event)        local str = &quot;response: &quot;..event._usedata        --labelStatusCode:setString(str)        -- 如果返回的是 json 数据，这里解析        local data =  json.decode(event._usedata)        table.foreach(data,         function(key, var)             print(&quot;-----&quot;..key)             table.foreach(var,                function(a, b)                   print(a..&quot;-&quot;..b)                end)         end)    end    local listener1 = cc.EventListenerCustom:create(&quot;customEvent1&quot;,eventCustomListener1)    cc.Director:getInstance():setNotificationNode(cc.Node:create())    local eventDispatcher = cc.Director:getInstance():getNotificationNode():getEventDispatcher()    eventDispatcher:addEventListenerWithFixedPriority(listener1, 6)    -- 将事件分配器赋值到CocosRequest.eventDispatcher    -- 用来在http请求返回的回调函数中使用，因为回调函数是在异步线程中执行，必须用自定义事件更新ui线程数据    local tmpHttp = CocosRequest:getInstance()    tmpHttp.eventDispatcher = eventDispatcher    ----------------------- 创建自定义事件 end    local tmp = CocosRequest:getInstance()    local function callback(xhr)        local event = cc.EventCustom:new(&quot;customEvent1&quot;)        event._usedata = xhr.response        eventDispatcher:dispatchEvent(event)        print(&quot;post callback code = &quot;..xhr.statusText)    end    local type = tmp.POST    local url = &quot;https://xxxx?cmd=501001&amp;uid=628941&amp;novelid=3782&quot;    local dataPost = {}    dataPost.data = &quot;hello&quot;    dataPost.aaa = &quot;world&quot;    dataPost.bbb = &quot;yang&quot;    tmp:send(type, url, dataPost, callback)endreturn ApiRequest</code></pre><h3 id="网络请求封装-CocosRequest"><a href="#网络请求封装-CocosRequest" class="headerlink" title="网络请求封装(CocosRequest)"></a>网络请求封装(CocosRequest)</h3><p>最后才是我们的重头戏，CocosRequest是直接使用cocos2dx lua提供的XMLHttpRequest实现，其实就是做了一套逻辑，具体细节可以根据项目调整(此处已经测试通过，可直接拷贝使用)</p><pre><code>require &quot;json&quot;CocosRequest = {}CocosRequest.__index = CocosRequestCocosRequest.instance = nilCocosRequest.callback = nilCocosRequest.POST = &quot;POST&quot;CocosRequest.GET = &quot;GET&quot;function CocosRequest:new()    local self = {}    setmetatable(self,CocosRequest)    return selfendfunction CocosRequest:getInstance()    if nil == self.instance then        self.instance = self:new()    end    return self.instanceend-- 数据转换，将请求数据由 table 型转换成 string，参数：tablefunction CocosRequest:dataParse(data)    if &quot;table&quot; ~= type(data) then        print(&quot;data is not a table&quot;)        return nil    end    local tmp = {}    for key, value in pairs(data) do        table.insert(tmp,key..&quot;=&quot;..value)    end    local newData = &quot;&quot;    for i=1,#tmp do        newData = newData..tostring(tmp[i])        if i&lt;#tmp then            newData = newData..&quot;&amp;&amp;&quot;        end    end    print(&quot;------- name is &quot;..newData)    return newDataend-- 发送数据，参数：string，string，tablefunction CocosRequest:send(type, url, data, callback)    local xhr = cc.XMLHttpRequest:new() --new 一个http request 实例    self.callback = callback    --设置需要执行的函数    local newData = self:dataParse(data)    if nil == newData or &quot;&quot; == newData then        return    end    -- response回调函数    local function responseCallback()        print(&quot;CocosRequest - &quot;..xhr.response)        if nil ~= self.callback then            self.callback(xhr)        else            print(&quot;callback is nil&quot;)        end    end    -- 设置返回值类型及回调函数    xhr.responseType = cc.XMLHTTPREQUEST_RESPONSE_STRING    xhr:registerScriptHandler(responseCallback)    -- 请求方式判断    if self.POST == type then        xhr:open(self.POST, url)        xhr:registerScriptHandler(responseCallback)        xhr:send(newData)    elseif self.GET == type then        xhr:open(self.GET, url..&quot;?&quot;..newData)        xhr:send()    else        print(&quot;ERROR : type only can be \&quot;Post\&quot; or \&quot;GET\&quot;&quot;)    endend---------------------return CocosRequest</code></pre><p>由于在Web中使用XMLHTTPRequest对象发出HTTP请求很普遍,Cocos2dxL<br>AP对其进行了移植,可以在 Cocos2 d-x LumP中使用 XMLHTTPRequest对象<br>XMLHTTPRequest对象中几个常用的函数和属性如下</p><ul><li>(1)open(),与服务器连接,创建新的请求</li><li>(2)send(),向服务器发送请求</li><li>(3)abort(),退出当前请求</li><li>(4)readyState属性,提供当前请求的就绪状态,其中4表示准备就绪</li><li>(5)tatus属性,提供当前HTTP请求状态码,其中200表示成功请求</li><li>(6)respomseText属性,服务器返回的请求响应</li><li>(7) onreadystatechange属性。设置回调函数,当服务器处理完请求后就会自动调用该<br>函数。</li></ul><p>其中open和send函数,以及onreadystatechange属性是HTTP请求的关键。open函<br>数有以下5个参数可以使用</p><ul><li>(1) request-type:发送请求的类型。典型的值是GET或POST,也可以发送HEAD<br>请求</li><li>(2) url:要请求连接的URL</li><li>(3) asynch:如果希望使用异步连接则为true,否则为 false。该参数是可选的,默认为</li><li>(4) username:如果需要身份验证,则可以在此指定用户名。该可选参数没有默认值</li><li>(5) password:如果需要身份验证,则可以在此指定口令。该可选参数没有默认值。</li></ul><h3 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h3><p>下面是我们验证返回后的服务器数据(未做处理)</p><pre><code>[    {        &quot;code&quot;:1,        &quot;msg&quot;:&quot;操作成功&quot;,        &quot;data&quot;:[            {                &quot;novelid&quot;:&quot;3782&quot;,                &quot;uid&quot;:&quot;628875&quot;,                &quot;cid&quot;:&quot;5&quot;,                &quot;title&quot;:&quot;零下记忆&quot;,                &quot;cover&quot;:&quot;http://xxxx/img/cb/2f/f1/cb2ff155bbda8387f4b8efe917c46cd3.jpg&quot;,                &quot;scover&quot;:&quot;http://xxxx/img/cb/2f/f1/cb2ff155bbda8387f4b8efe917c46cd3.jpg&quot;,                &quot;shareimg&quot;:&quot;http://xxxx/img/ed/68/e6/ed68e67f77841ac76be189f0a04aa030.jpg&quot;,                &quot;intro&quot;:&quot;&quot;,                &quot;tags&quot;:&quot;悬疑&quot;,                &quot;reason&quot;:&quot;&quot;,                &quot;issingle&quot;:&quot;1&quot;,                &quot;sort&quot;:&quot;0&quot;,                &quot;hits&quot;:&quot;0&quot;,                &quot;reads&quot;:&quot;18753&quot;,                &quot;clues&quot;:20,                &quot;likes&quot;:&quot;1&quot;,                &quot;unlikes&quot;:&quot;0&quot;,                &quot;cmts&quot;:&quot;0&quot;,                &quot;favs&quot;:&quot;2&quot;,                &quot;words&quot;:&quot;18420&quot;,                &quot;chapters&quot;:&quot;35&quot;,                &quot;pub_chapters&quot;:&quot;35&quot;,                &quot;chapter_index&quot;:&quot;1&quot;,                &quot;pubtime&quot;:&quot;0&quot;,                &quot;updatetime&quot;:&quot;1539337440&quot;,                &quot;addtime&quot;:&quot;1534222233&quot;,                &quot;resversion&quot;:&quot;30&quot;,                &quot;isuser&quot;:&quot;0&quot;,                &quot;status&quot;:&quot;1&quot;,                &quot;wstatus&quot;:&quot;1&quot;,                &quot;offsale&quot;:&quot;0&quot;,                &quot;chapterstatus&quot;:&quot;-1&quot;,                &quot;leadrole&quot;:{                    &quot;roleid&quot;:&quot;8478&quot;,                    &quot;rolename&quot;:&quot;炽念&quot;                },                &quot;cname&quot;:&quot;推理&quot;,                &quot;isnew&quot;:0,                &quot;fatime&quot;:&quot;8月14日&quot;,                &quot;isreading&quot;:1,                &quot;iscomplete&quot;:1,                &quot;isfav&quot;:0,                &quot;liketype&quot;:0,                &quot;shareinfo&quot;:{                    &quot;type&quot;:1,                    &quot;title&quot;:&quot;零下记忆&quot;,                    &quot;intro&quot;:&quot;&quot;,                    &quot;img&quot;:&quot;http://xxxx/img/ed/68/e6/ed68e67f77841ac76be189f0a04aa030.jpg&quot;,                    &quot;url&quot;:&quot;http://xxxx/novel/startReading?novelid=3782&amp;chl=jmt&quot;                },                &quot;userinfo&quot;:{                    &quot;uid&quot;:&quot;628875&quot;,                    &quot;username&quot;:&quot;writer10&quot;,                    &quot;nickname&quot;:&quot;离经易道&quot;,                    &quot;headurl&quot;:&quot;http://xxxx/headimg/bb/d3/b6/628875_1_bbd3b631717ad615f38a6670573a375c_300x300.jpg?v=1526708983&quot;,                    &quot;sex&quot;:&quot;1&quot;,                    &quot;vtype&quot;:&quot;0&quot;,                    &quot;regtype&quot;:&quot;2&quot;,                    &quot;vname&quot;:&quot;&quot;,                    &quot;vicon&quot;:&quot;&quot;,                    &quot;isfollow&quot;:0                }            }        ],        &quot;cmd&quot;:501001,        &quot;time&quot;:1539677040    }]</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的主题是关于cocos2dx lua实现短链接网络请求，使用Http实现基本的服务器网络数据获取，关于长链接（socket后续文件或者遇到需要的时候回特别实现与处理）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于Http这里就不多做介绍了，不过，作为一个程序员，网络请求是开发中最多也是最重要的一环节，这里比较建议，搞懂http的整个请求流程！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;推荐：&lt;a href=&quot;https://blog.csdn.net/yezitoo/article/details/78193794&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一次完整的HTTP请求过程
&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS游戏——渠道越狱打包流程</title>
    <link href="https://icocos.github.io/2018/10/09/iOS%E6%B8%B8%E6%88%8F%E2%80%94%E2%80%94%E6%B8%A0%E9%81%93%E8%B6%8A%E7%8B%B1%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/"/>
    <id>https://icocos.github.io/2018/10/09/iOS游戏——渠道越狱打包流程/</id>
    <published>2018-10-09T02:15:50.000Z</published>
    <updated>2018-10-18T05:26:19.564Z</updated>
    
    <content type="html"><![CDATA[<p>关于iOS普通ipa打包这里就不说了，只要注意苹果的一些协议条款，基本上步骤都是傻瓜式的，如果不知道如何打包iOS普通ipa包，请出门左转，度娘在哪里等你！</p><p>那么，如何将app打包成越狱包，越狱iphone在cydia源上下载安装，这样的需求在互联网游戏行业是非常普遍的，尤其是各种马甲包横行的时代！</p><h6 id="关于越狱相关内容，请看这里"><a href="#关于越狱相关内容，请看这里" class="headerlink" title="关于越狱相关内容，请看这里"></a>关于越狱相关内容，请看这里</h6><ul><li><a href="https://www.52pojie.cn/thread-683139-1-1.html" target="_blank" rel="noopener">iOS越狱解除工具</a></li><li><a href="https://www.baidu.com/link?url=1tVxiDdLIbOv2qstGpFdZEOf-18kIJHyyGSXt77CmMo8goYBtfcIYXJNkWePH5bR&amp;wd=&amp;eqid=88fc6288000136f6000000065bc81910" target="_blank" rel="noopener">ios越狱原理详解</a></li></ul><a id="more"></a><h3 id="常见deb包打包方式"><a href="#常见deb包打包方式" class="headerlink" title="常见deb包打包方式"></a>常见deb包打包方式</h3><h5 id="1、第一种方式："><a href="#1、第一种方式：" class="headerlink" title="1、第一种方式："></a>1、第一种方式：</h5><p>自定义目录下 如desktop创建文件夹，起名test，test内新建文件夹Payload<br>把xcode Build好的.app（Products目录中）拷到Payload目录中<br>打开终端，cd指令 到test文件目录下，执行 </p><pre><code>zip -r “xxx.ipa” *         注意里面的空格：(zip -r “xxx.ipa”[空格]* )</code></pre><p>ipa包就打好了，可以安装到越狱手机上试试看</p><blockquote><p>注意事项：Debug或Release的Any iOS SDK都设置为正式发布证书，经测试该越狱包可正常接收推送。</p></blockquote><h5 id="2、第二种方式："><a href="#2、第二种方式：" class="headerlink" title="2、第二种方式："></a>2、第二种方式：</h5><p>在xcode中点击Product-&gt;Archive,完成后会弹出Organizer，点右边的Distribute，弹出一个向导对话框，点击“Export as Xcode Archive”，选择位置，会在那个位置生成后缀名是.xcarchive的文件<br>右键“显示包内容”-&gt;”Products”-&gt;”applications” 然后找到那个应用程序，</p><blockquote><p>将其拖到iTunes里面，在itunes的【应用程序】里找到这个文件，然后右键“在Finder 中显示”，便可找到ipa文件了<br>….</p></blockquote><p>ipa包就打好了，可以安装到越狱手机上试试看</p><h3 id="最近发现了一种更好的方式"><a href="#最近发现了一种更好的方式" class="headerlink" title="最近发现了一种更好的方式"></a>最近发现了一种更好的方式</h3><p>致谢： <a href="http://www.zhaoxiaodan.com/" target="_blank" rel="noopener">胖梁的技术笔记</a></p><h5 id="1-修改编译选项重新打包"><a href="#1-修改编译选项重新打包" class="headerlink" title="1.修改编译选项重新打包"></a>1.修改编译选项重新打包</h5><p>在工程的Build Settings -&gt; Code Signing -&gt; Code Signing Identity选项, 将 Debug 和 Release 下的 Any iOS SDK都设置为 Don’t Code Sign然后在重新Archive</p><h5 id="2-准备目录"><a href="#2-准备目录" class="headerlink" title="2.准备目录"></a>2.准备目录</h5><p>创建一个目录用来打包,如tmp,tmp下建DEBIAN和Applications两个目录, DEBIAN下建一个文本文件control tmp目录结构如下:</p><pre><code>-DEBIAN---control-Applications</code></pre><p>control文件就是打包时的配置文件,它也会作为deb包的配置被打包到包中, 文件例子:</p><pre><code>Package: com.sharedream.gameName: 游戏测试Version: 0.1-1Description: 游戏测试游戏,开发中...Section: 游戏Depends: firmware (&gt;= 4.3)Priority: optionalArchitecture: iphoneos-armAuthor: liangwei &lt;http://weibo.com/iamliangwei&gt;Homepage: http://weibo.com/iamliangweiIcon: file:///Applications/game.app/Icon.pngMaintainer: liangwei &lt;http://weibo.com/iamliangwei&gt;</code></pre><p>然后将xcode打包出来的.app文件整个拷贝到Applications目录下, 结构如下:</p><pre><code>-DEBIAN---control-Applications---game.app</code></pre><h5 id="3-打包"><a href="#3-打包" class="headerlink" title="3.打包"></a>3.打包</h5><p>退出至tmp的上层目录</p><pre><code>dpkg-deb -b tmp game.deb</code></pre><p>看到如下几行就是打包完成了</p><pre><code>warning, `com.sull.sample/DEBIAN/control&apos; contains user-defined field `Name&apos;warning, `com.sull.sample/DEBIAN/control&apos; contains user-defined field `Author&apos;warning, `com.sull.sample/DEBIAN/control&apos; contains user-defined field `Sponsor&apos;dpkg-deb: ignoring 3 warnings about the control file(s)</code></pre><p>拷贝到cydia源中, 重新扫描包生成Packages列表文件, 并压缩成Packages.bz2就可以啦</p><pre><code>dpkg-scanpackages -m debs &gt;Packagesbzip2 -zkf Packages</code></pre><blockquote><p>contains ununderstood data member data.tar.xz” 的安装错误</p></blockquote><p>是因为自从1.17.0版本的dpkg-deb开始, 默认使用xz格式来压缩data.tar文件<br>但是,cydia在ios提供的dpkg是1.14版本, 还没有支持xz这种压缩格式<br>所以我们需要设置”-Zgzip”参数给dpkg-deb 进行打包, 类似命令:</p><pre><code>dpkg-deb -Zgzip -b tmp game.deb</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于iOS普通ipa打包这里就不说了，只要注意苹果的一些协议条款，基本上步骤都是傻瓜式的，如果不知道如何打包iOS普通ipa包，请出门左转，度娘在哪里等你！&lt;/p&gt;
&lt;p&gt;那么，如何将app打包成越狱包，越狱iphone在cydia源上下载安装，这样的需求在互联网游戏行业是非常普遍的，尤其是各种马甲包横行的时代！&lt;/p&gt;
&lt;h6 id=&quot;关于越狱相关内容，请看这里&quot;&gt;&lt;a href=&quot;#关于越狱相关内容，请看这里&quot; class=&quot;headerlink&quot; title=&quot;关于越狱相关内容，请看这里&quot;&gt;&lt;/a&gt;关于越狱相关内容，请看这里&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.52pojie.cn/thread-683139-1-1.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iOS越狱解除工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.baidu.com/link?url=1tVxiDdLIbOv2qstGpFdZEOf-18kIJHyyGSXt77CmMo8goYBtfcIYXJNkWePH5bR&amp;amp;wd=&amp;amp;eqid=88fc6288000136f6000000065bc81910&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ios越狱原理详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>cocos2dx lua注册事件详解</title>
    <link href="https://icocos.github.io/2018/10/05/cocos2dx-lua%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>https://icocos.github.io/2018/10/05/cocos2dx-lua注册事件详解/</id>
    <published>2018-10-05T02:23:16.000Z</published>
    <updated>2018-10-18T05:32:41.734Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习cocos2dx lua的时候，遇到了一些关于事件注册的逻辑！</p><p>结合用户实际操作和游戏的真实需求，关于事件在游戏中还是使用非常多的，所以特此记录一下</p><blockquote><p>事件(网络)</p><blockquote><p>事件是可以被控件识别的操作。如按下确定按钮，选择某个单选按钮或者复选框。每一种控件有自己可以识别的事件，如窗体的加载、单击、双击等事件，编辑框（文本框）的文本改变事件，等等。</p></blockquote></blockquote><h6 id="事件是用户对窗口上各种组件的操作。"><a href="#事件是用户对窗口上各种组件的操作。" class="headerlink" title="事件是用户对窗口上各种组件的操作。"></a>事件是用户对窗口上各种组件的操作。</h6><ul><li>事件有系统事件和用户事件。<ul><li>1.系统事件由系统激发，如时间间隔24小时，银行储蓄的存款日期增加一天。</li><li>2.用户事件由用户激发，如用户点击按钮，在文本框中显示特定的文本。事件驱动控件执行某项功能。</li></ul></li></ul><h6 id="触发事件的对象称为事件发送者；接收事件的对象称为事件接受者；"><a href="#触发事件的对象称为事件发送者；接收事件的对象称为事件接受者；" class="headerlink" title="触发事件的对象称为事件发送者；接收事件的对象称为事件接受者；"></a>触发事件的对象称为事件发送者；接收事件的对象称为事件接受者；</h6><blockquote><p>注: 这里只针对用户事件！</p></blockquote><a id="more"></a><h4 id="cocos2dx中事件的类型"><a href="#cocos2dx中事件的类型" class="headerlink" title="cocos2dx中事件的类型"></a>cocos2dx中事件的类型</h4><!--more--><ul><li>registerScriptTouchHandler             注册触屏事件</li><li>registerScriptTapHandler                  注册点击事件</li><li>registerScriptHandler                         注册基本事件 包括 触屏 层的进入 退出 事件</li><li>registerScriptKeypadHandler           注册键盘事件</li><li>registerScriptAccelerateHandler      注册加速事件</li></ul><p>在3.x之前事件的注册可以直接使用这些方式来注册，</p><p>而在3.x中由于加入了C++11的特性，而对事件的分发机制通过事件分发器EventDispatcher 来进行统一的管理。</p><h3 id="【事件分发器】"><a href="#【事件分发器】" class="headerlink" title="【事件分发器】"></a>【事件分发器】</h3><p>事件分发器EventDispatcher，用于统一管理事件监听器的所有事件的分发。</p><ul><li>事件监听器主要有：<ul><li>触摸事件     : EventListenerTouchOneByOne、EventListenerTouchAllAtOnce</li><li>鼠标响应事件 : EventListenerMouse</li><li>键盘响应事件 : EventListenerKeyboard</li><li>加速计事件   : EventListenerAcceleration</li><li>自定义事件   : EventListenerCustom</li><li>物理碰撞事件 : EventListenerPhysicsContact</li><li>游戏手柄事件 : EventListenerController</li></ul></li></ul><h5 id="1、-eventDispatcher"><a href="#1、-eventDispatcher" class="headerlink" title="1、_eventDispatcher"></a>1、_eventDispatcher</h5><p>_eventDispatcher是Node的属性，通过Director::getInstance()-&gt;getEventDispatcher() 获得。</p><ul><li>_eventDispatcher的工作由三部分组成：<ul><li>（1）事件分发器 ：EventDispatcher。</li><li>（2）事件类型   ：EventTouch, EventKeyboard 等。</li><li>（3）事件监听器 ：EventListenerTouch, EventListenerKeyboard 等。</li></ul></li></ul><p>监听器实现了各种触发后的逻辑，在适当时候由事件分发器分发事件类型，然后调用相应类型的监听器。</p><h5 id="2、添加-删除监听器"><a href="#2、添加-删除监听器" class="headerlink" title="2、添加/删除监听器"></a>2、添加/删除监听器</h5><ul><li><p>添加监听器：</p><ul><li>addEventListenerWithSceneGraphPriority ，</li><li>addEventListenerWithFixedPriority 。</li></ul></li><li><p>删除监听器：</p><ul><li>removeEventListener ，</li><li>removeAllEventListeners 。</li></ul></li></ul><h5 id="3、主要函数"><a href="#3、主要函数" class="headerlink" title="3、主要函数"></a>3、主要函数</h5><p>包含监听器的添加、删除、暂停、恢复，优先级的设置，手动分发事件等。</p><pre><code>class EventDispatcher : public Ref{/*** 添加监听器*     - addEventListenerWithSceneGraphPriority*     - addEventListenerWithFixedPriority*     - addCustomEventListener*///使用 场景图的优先级 为指定事件添加一个监听.//listener : 指定要监听的事件.//node     : 这个节点的绘制顺序是基于监听优先级.//优先级   : 0void addEventListenerWithSceneGraphPriority(EventListener* listener, Node* node);//使用 一定的优先级 为指定事件添加一个监听.//listener      : 指定要监听的事件.//fixedPriority : 这个监听器的固定优先级.//优先级        : fixedPriority。(但是不能为0，因为他是场景图的基本优先级)void addEventListenerWithFixedPriority(EventListener* listener, int fixedPriority);//用户自定义监听器EventListenerCustom* addCustomEventListener(const std::string &amp;eventName, const std::function&lt;void(EventCustom*)&gt;&amp; callback);/*** 删除监听器*     - removeEventListener*     - removeEventListenersForType*     - removeEventListenersForTarget*     - removeCustomEventListeners*     - removeAllEventListeners*///删除指定监听器void removeEventListener(EventListener* listener);//删除某类型对应的所有监听器//EventListener::Type:://  单点触摸 : TOUCH_ONE_BY_ONE//  多点触摸 : TOUCH_ALL_AT_ONCE//  键盘     : KEYBOARD//  鼠标     : MOUSE//  加速计   : ACCELERATION//  自定义   : CUSTOMvoid removeEventListenersForType(EventListener::Type listenerType);//删除绑定在节点target上的所有监听器void removeEventListenersForTarget(Node* target, bool recursive = false);//删除名字为customEventName的所有自定义监听器void removeCustomEventListeners(const std::string&amp; customEventName);//移除所有监听器void removeAllEventListeners();/*** 暂停、恢复在节点target上的所有监听器*     - pauseEventListenersForTarget*     - resumeEventListenersForTarget*/void pauseEventListenersForTarget(Node* target, bool recursive = false);void resumeEventListenersForTarget(Node* target, bool recursive = false);/*** 其他*     - setPriority*     - setEnabled*     - dispatchEvent*     - dispatchCustomEvent*///设置某监听器的优先级void setPriority(EventListener* listener, int fixedPriority);//启用事件分发器void setEnabled(bool isEnabled);bool isEnabled() const;//手动派发自定义事件void dispatchEvent(Event* event);//给名字为eventName的自定义监听器, 绑定用户数据void dispatchCustomEvent(const std::string &amp;eventName, void *optionalUserData = nullptr);}</code></pre><h5 id="4、关于事件监听器的优先权"><a href="#4、关于事件监听器的优先权" class="headerlink" title="4、关于事件监听器的优先权"></a>4、关于事件监听器的优先权</h5><p>通过 addEventListenerWithSceneGraphPriority 添加的监听器，优先权为0。<br>通过 addEventListenerWithFixedPriority 添加的监听器，可以自定义优先权，但不能为0。</p><ul><li>优先级越低，越先响应事件。</li><li>如果优先级相同，则上层的（z轴）先接收触摸事件。</li></ul><h5 id="5、使用步骤"><a href="#5、使用步骤" class="headerlink" title="5、使用步骤"></a>5、使用步骤</h5><ul><li>（1）获取事件分发器：<ul><li>dispatcher = Director::getInstance()-&gt;getEventDispatcher();</li></ul></li><li>（2）创建监听器：<ul><li>auto listener = EventListenerTouchOneByOne::create();</li></ul></li><li>（3）绑定响应事件函数：<ul><li>listener-&gt;onTouchBegan = CC_CALLBACK_2(callback, this);</li></ul></li><li>（4）将监听器添加到事件分发器dispatcher中：<ul><li>dispatcher-&gt;addEventListenerWithSceneGraphPriority(Listener, this);</li></ul></li><li>（5）编写回调响应函数：<ul><li>bool callback(Touch<em> touch, Event</em> event) { … }</li></ul></li></ul><h3 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h3><p>先来看看项目用用到的一些简单时间的操作， 两种方式创建使用</p><h5 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h5><p>根据用户手机在屏幕触摸的位置，对场景或者场景中的精灵，控件的做一些处理，这种类型偏向于触摸屏的设备。</p><pre><code>local function onTouchBegan(touch, event)local location = touch:getLocation()local visiableSize = cc.Director:getInstance():getVisibleSize()local origin = cc.Director:getInstance():getVisibleOrigin()local finalX = location.x - (origin.x + visiableSize.width/2)local finalY = location.y - (origin.y + visiableSize.height/2)finalX, finalY 根据实际屏幕计算触摸点endlocal listener = cc.EventListenerTouchOneByOne:create()listener:registerScriptHandler(onTouchBegan, cc.Handler.EVENT_TOUCH_BEGAN)local eventDiapatcher = self:getEventDispatcher()eventDiapatcher:addEventListenerWithSceneGraphPriority(listener, self)</code></pre><h5 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h5><p>这里是coco2dx 定义的一套键盘字节码，每一个键盘上的键都对应一个数字，我们可以根据用户按键对精灵和界面做控制，这种偏向于桌面版的游戏！</p><h6 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h6><pre><code>-- 键盘监听器local listener = cc.EventListenerKeyboard:create()listener:registerScriptHandler(function(keyCode, event)if self.tank ~= nil then-- wif keyCode == 146 thenself.tank:MoveBegin(&quot;up&quot;)-- selseif keyCode == 142 thenself.tank:MoveBegin(&quot;down&quot;)-- aelseif keyCode == 124 thenself.tank:MoveBegin(&quot;left&quot;)-- delseif keyCode == 127 thenself.tank:MoveBegin(&quot;right&quot;)endendend, cc.Handler.EVENT_KEYBOARD_PRESSED) --- cc.Handler.EVENT_KEYBOARD_RELEASED)local eventDiapatcher = self:getEventDispatcher()eventDiapatcher:addEventListenerWithSceneGraphPriority(listener, self)</code></pre><h6 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h6><pre><code>local function keyboardPressed(keyCode, event)-- upif keyCode == 28 thenself:MoveCursor(0, 1)-- downelseif keyCode == 29 thenself:MoveCursor(0, -1)-- leftelseif keyCode == 26 thenself:MoveCursor(-1, 0)-- rightelseif keyCode == 27 thenself:MoveCursor(1, 0)-- page upelseif keyCode == 38 thenself:SwitchCursor(-1)-- page downelseif keyCode == 44 thenself:SwitchCursor(1)-- enterelseif keyCode == 38 thenself:Place()-- deleteelseif keyCode == 44 thenself:Delete()-- F3elseif keyCode == 49 thenself:Load()-- F4elseif keyCode == 50 thenself:Save()endprint(&quot;key board ???????? keyCode&quot;, keyCode)end-- 键盘监听器local listener = cc.EventListenerKeyboard:create()listener:registerScriptHandler(keyboardPressed, cc.Handler.EVENT_KEYBOARD_PRESSED)local eventDiapatcher = self:getEventDispatcher()eventDiapatcher:addEventListenerWithSceneGraphPriority(listener, self)</code></pre><p>这里主要说一下codeKey，codeKey是cocos2dx定义的一套键盘的代码，每个平台几乎是通用的</p><h3 id="【触摸事件】"><a href="#【触摸事件】" class="headerlink" title="【触摸事件】"></a>【触摸事件】</h3><h5 id="1、单点触摸：EventListenerTouchOneByOne"><a href="#1、单点触摸：EventListenerTouchOneByOne" class="headerlink" title="1、单点触摸：EventListenerTouchOneByOne"></a>1、单点触摸：EventListenerTouchOneByOne</h5><p>单点触摸监听器相关：</p><pre><code>static EventListenerTouchOneByOne* create();std::function&lt;bool(Touch*, Event*)&gt; onTouchBegan; //只有这个返回值为 boolstd::function&lt;void(Touch*, Event*)&gt; onTouchMoved;std::function&lt;void(Touch*, Event*)&gt; onTouchEnded;std::function&lt;void(Touch*, Event*)&gt; onTouchCancelled;</code></pre><p>使用举例：</p><pre><code>//获取事件分发器auto dispatcher = Director::getInstance()-&gt;getEventDispatcher();//创建单点触摸监听器 EventListenerTouchOneByOneauto touchListener = EventListenerTouchOneByOne::create();//单点触摸响应事件绑定touchListener-&gt;onTouchBegan     = CC_CALLBACK_2(HelloWorld::onTouchBegan, this);touchListener-&gt;onTouchMoved     = CC_CALLBACK_2(HelloWorld::onTouchMoved, this);touchListener-&gt;onTouchEnded     = CC_CALLBACK_2(HelloWorld::onTouchEnded, this);touchListener-&gt;onTouchCancelled = CC_CALLBACK_2(HelloWorld::onTouchCancelled, this);//在事件分发器中，添加触摸监听器，事件响应委托给 this 处理dispatcher-&gt;addEventListenerWithSceneGraphPriority(touchListener, this);//单点触摸事件响应函数bool onTouchBegan(Touch *touch, Event *unused_event)     { CCLOG(&quot;began&quot;); return true; }void onTouchMoved(Touch *touch, Event *unused_event)     { CCLOG(&quot;moved&quot;); }void onTouchEnded(Touch *touch, Event *unused_event)     { CCLOG(&quot;ended&quot;); }void onTouchCancelled(Touch *touch, Event *unused_event) { CCLOG(&quot;cancelled&quot;); }</code></pre><h5 id="2、多点触摸：EventListenerTouchAllAtOnce"><a href="#2、多点触摸：EventListenerTouchAllAtOnce" class="headerlink" title="2、多点触摸：EventListenerTouchAllAtOnce"></a>2、多点触摸：EventListenerTouchAllAtOnce</h5><p>多点触摸监听器相关：</p><pre><code>static EventListenerTouchAllAtOnce* create();std::function&lt;void(const std::vector&lt;Touch*&gt;&amp;, Event*)&gt; onTouchesBegan;std::function&lt;void(const std::vector&lt;Touch*&gt;&amp;, Event*)&gt; onTouchesMoved;std::function&lt;void(const std::vector&lt;Touch*&gt;&amp;, Event*)&gt; onTouchesEnded;std::function&lt;void(const std::vector&lt;Touch*&gt;&amp;, Event*)&gt; onTouchesCancelled;</code></pre><p>使用举例：</p><pre><code>//获取事件分发器auto dispatcher = Director::getInstance()-&gt;getEventDispatcher();//创建多点触摸监听器 EventListenerTouchAllAtOnceauto touchesListener = EventListenerTouchAllAtOnce::create();//多点触摸响应事件绑定touchesListener-&gt;onTouchesBegan     = CC_CALLBACK_2(HelloWorld::onTouchesBegan, this);touchesListener-&gt;onTouchesMoved     = CC_CALLBACK_2(HelloWorld::onTouchesMoved, this);touchesListener-&gt;onTouchesEnded     = CC_CALLBACK_2(HelloWorld::onTouchesEnded, this);touchesListener-&gt;onTouchesCancelled = CC_CALLBACK_2(HelloWorld::onTouchesCancelled, this);//在事件分发器中，添加触摸监听器，事件响应委托给 this 处理dispatcher-&gt;addEventListenerWithSceneGraphPriority(touchesListener, this);//多点触摸事件响应函数void onTouchesBegan(const std::vector&lt;Touch*&gt;&amp; touches, Event *unused_event)    { CCLOG(&quot;began&quot;); }void onTouchesMoved(const std::vector&lt;Touch*&gt;&amp; touches, Event *unused_event)    { CCLOG(&quot;moved&quot;); }void onTouchesEnded(const std::vector&lt;Touch*&gt;&amp; touches, Event *unused_event)    { CCLOG(&quot;ended&quot;); }void onTouchesCancelled(const std::vector&lt;Touch*&gt;&amp;touches, Event *unused_event) { CCLOG(&quot;cancelled&quot;); }</code></pre><h3 id="【鼠标事件】"><a href="#【鼠标事件】" class="headerlink" title="【鼠标事件】"></a>【鼠标事件】</h3><p>EventListenerMouse，主要用于监听鼠标的点击、松开、移动、滚轮的事件。</p><p>鼠标事件监听器相关：</p><pre><code>static EventListenerMouse* create();std::function&lt;void(Event* event)&gt; onMouseDown;     //按下鼠标, 单击鼠标std::function&lt;void(Event* event)&gt; onMouseUp;   //松开鼠标, 按下的状态下松开std::function&lt;void(Event* event)&gt; onMouseMove;  //移动鼠标, 在屏幕中移动std::function&lt;void(Event* event)&gt; onMouseScroll;//滚动鼠标, 滚动鼠标的滚轮</code></pre><p>使用举例：</p><pre><code>//获取事件分发器auto dispatcher = Director::getInstance()-&gt;getEventDispatcher();//创建鼠标事件监听器 EventListenerMouseEventListenerMouse* mouseListenter = EventListenerMouse::create();//鼠标事件响应函数mouseListenter-&gt;onMouseDown   = CC_CALLBACK_1(HelloWorld::onMouseDown,   this);mouseListenter-&gt;onMouseUp     = CC_CALLBACK_1(HelloWorld::onMouseUp,     this);mouseListenter-&gt;onMouseMove   = CC_CALLBACK_1(HelloWorld::onMouseMove,   this);mouseListenter-&gt;onMouseScroll = CC_CALLBACK_1(HelloWorld::onMouseScroll, this);//添加鼠标事件监听器，事件响应处理委托给thisdispatcher-&gt;addEventListenerWithSceneGraphPriority(mouseListenter, this);//事件响应函数void onMouseDown(Event* event)   { CCLOG(&quot;Down&quot;); }void onMouseUp(Event* event)     { CCLOG(&quot;UP&quot;); }void onMouseMove(Event* event)   { CCLOG(&quot;MOVE&quot;); }void onMouseScroll(Event* event) { CCLOG(&quot;Scroll&quot;); }</code></pre><h3 id="【键盘事件】"><a href="#【键盘事件】" class="headerlink" title="【键盘事件】"></a>【键盘事件】</h3><p>EventListenerKeyboard，主要用于监听键盘某个键的按下、松开的事件。</p><p>键盘事件监听器相关：</p><pre><code>static EventListenerKeyboard* create();std::function&lt;void(EventKeyboard::KeyCode, Event*)&gt; onKeyPressed;  //按下某键std::function&lt;void(EventKeyboard::KeyCode, Event*)&gt; onKeyReleased; //松开某键//键盘按键枚举类型 EventKeyboard::KeyCode//KeyCode的值对应的不是键盘的键值、也不是ASCII码，只是纯粹的枚举类型//如://  EventKeyboard::KeyCode::KEY_A//  EventKeyboard::KeyCode::KEY_1//  EventKeyboard::KeyCode::KEY_F1//  EventKeyboard::KeyCode::KEY_SPACE//  EventKeyboard::KeyCode::KEY_ALT//  EventKeyboard::KeyCode::KEY_SHIFT</code></pre><p>使用举例：</p><pre><code>////获取事件分发器auto dispatcher = Director::getInstance()-&gt;getEventDispatcher();//创建键盘按键事件监听器EventListenerKeyboard* keyboardListener = EventListenerKeyboard::create();//绑定事件响应函数keyboardListener-&gt;onKeyPressed = CC_CALLBACK_2(HelloWorld::onKeyPressed, this);keyboardListener-&gt;onKeyReleased = CC_CALLBACK_2(HelloWorld::onKeyReleased, this);//添加监听器dispatcher-&gt;addEventListenerWithSceneGraphPriority(keyboardListener, this);//事件响应函数void onKeyPressed(EventKeyboard::KeyCode keyCode, Event* event) {if (EventKeyboard::KeyCode::KEY_J == keyCode) {CCLOG(&quot;Pressed: J&quot;);}}void onKeyReleased(EventKeyboard::KeyCode keyCode, Event* event) {if (EventKeyboard::KeyCode::KEY_SPACE == keyCode) {CCLOG(&quot;Released: SPACE&quot;);}}</code></pre><h3 id="【加速计事件】"><a href="#【加速计事件】" class="headerlink" title="【加速计事件】"></a>【加速计事件】</h3><p>EventListenerAcceleration，主要用于监听移动设备的所受重力方向感应事件。</p><p>重力感应来自移动设备的加速计，通常支持 (X, Y, Z) 三个方向的加速度感应，所以又称为三向加速计。在实际应用中，可以根据3个方向的力度大小来计算手机倾斜的角度或方向。</p><h5 id="1、加速计信息类Acceleration"><a href="#1、加速计信息类Acceleration" class="headerlink" title="1、加速计信息类Acceleration"></a>1、加速计信息类Acceleration</h5><p>该类中每个方向的加速度，大小都为一个重力加速度大小。</p><pre><code>//加速计信息class Acceleration{double x; double y; double z;};</code></pre><h5 id="2、开启加速计感应"><a href="#2、开启加速计感应" class="headerlink" title="2、开启加速计感应"></a>2、开启加速计感应</h5><p>在使用加速计事件监听器之前，需要先启用此硬件设备：</p><pre><code>Device::setAccelerometerEnabled(true);</code></pre><h5 id="3、加速计监听器相关"><a href="#3、加速计监听器相关" class="headerlink" title="3、加速计监听器相关"></a>3、加速计监听器相关</h5><pre><code>static EventListenerAcceleration* create(const std::function&lt;void(Acceleration*, Event*)&gt;&amp; callback);std::function&lt;void(Acceleration*, Event*)&gt; onAccelerationEvent;</code></pre><h5 id="4、使用举例"><a href="#4、使用举例" class="headerlink" title="4、使用举例"></a>4、使用举例</h5><pre><code>//标签: 显示加速计信息label = Label::createWithTTF(&quot;no used&quot;, &quot;Marker Felt.ttf&quot;, 12);label-&gt;setPosition(visibleSize / 2);this-&gt;addChild(label);//小球: 可视化加速计ball = Sprite::create(&quot;ball.png&quot;);ball-&gt;setPosition(visibleSize / 2);this-&gt;addChild(ball);//获取事件分发器auto dispatcher = Director::getInstance()-&gt;getEventDispatcher();//需要开启移动设备的加速计Device::setAccelerometerEnabled(true);//创建加速计事件监听器auto accelerationListener = EventListenerAcceleration::create(CC_CALLBACK_2(HelloWorld::onAccelerationEvent, this));//添加加速计监听器dispatcher-&gt;addEventListenerWithSceneGraphPriority(accelerationListener, this);//事件响应函数void HelloWorld::onAccelerationEvent(Acceleration* acceleration, Event* event){char s[100];sprintf(s, &quot;X: %f; Y: %f; Z:%f; &quot;, acceleration-&gt;x, acceleration-&gt;y, acceleration-&gt;z);label-&gt;setString(s);//改变小球ball的位置float x = ball-&gt;getPositionX() + acceleration-&gt;x * 10;float y = ball-&gt;getPositionY() + acceleration-&gt;y * 10;Vec2 pos = Vec2(x, y);pos.clamp(ball-&gt;getContentSize() / 2, Vec2(288, 512) - ball-&gt;getContentSize() / 2);ball-&gt;setPosition(pos); //设置位置}</code></pre><h3 id="【自定义事件】"><a href="#【自定义事件】" class="headerlink" title="【自定义事件】"></a>【自定义事件】</h3><p>以上是系统自带的事件类型，事件由系统内部自动触发，如 触摸屏幕，键盘响应等。</p><p>EventListenerCustom 自定义事件，它不是由系统自动触发，而是人为的干涉。</p><p>它的出现，使得2.x中的 观察者模式 NotificationCenter（订阅发布消息） 被无情的遗弃了。</p><blockquote><p>在 3.x 中，使用EventListenerCustom来实现消息的订阅与发布。</p></blockquote><p>学习它之前，最好了解一下 NotificationCenter 这个类的用法。</p><blockquote><p>NotificationCenter 的用法参见：<a href="http://shahdza.blog.51cto.com/2410787/1611575" target="_blank" rel="noopener">http://shahdza.blog.51cto.com/2410787/1611575</a></p></blockquote><h5 id="1、创建自定义监听器"><a href="#1、创建自定义监听器" class="headerlink" title="1、创建自定义监听器"></a>1、创建自定义监听器</h5><p>该监听器，就相当于是订阅消息。即与NotificationCenter的 addObserver 类似。</p><pre><code>//eventName : 监听器名字，即消息的名称//callback  : 监听器函数，即消息的回调函数static EventListenerCustom* create(const std::string&amp; eventName, const std::function&lt;void(EventCustom*)&gt;&amp; callback);</code></pre><h5 id="2、分发自定义事件"><a href="#2、分发自定义事件" class="headerlink" title="2、分发自定义事件"></a>2、分发自定义事件</h5><p>自定义的事件监听器，需要通过手动的方式，将事件分发出去。</p><blockquote><p>通过 EventCustom(string eventName);       来设置需要发布消息的数据信息，eventName为消息名称。</p></blockquote><p>其中EventCustom可以通过setUserData来绑定想要传递的消息数据。</p><blockquote><p>通过 dispatcher-&gt;dispatchEvent(&amp;event); 来手动将事件分发出去。即发布消息。</p></blockquote><p>这与NotificationCenter的 postNotification 类似。</p><pre><code>EventCustom event(&quot;custom_event&quot;);event-&gt;setUserData((void*)123); // 绑定消息传递的数据，可以为任意类型void。dispatcher-&gt;dispatchEvent(&amp;event); // 发布名称为&quot;custom_event&quot;的消息。</code></pre><h5 id="3、使用举例"><a href="#3、使用举例" class="headerlink" title="3、使用举例"></a>3、使用举例</h5><pre><code>//获取事件分发器auto dispatcher = Director::getInstance()-&gt;getEventDispatcher();//创建自定义事件监听器//监听器名字  : &quot;custom_event&quot;//事件响应函数: HelloWorld::onCustomEventauto customListener = EventListenerCustom::create(&quot;custom_event&quot;, CC_CALLBACK_1(HelloWorld::onCustomEvent, this));//添加自定义事件监听器，优先权为1dispatcher-&gt;addEventListenerWithFixedPriority(customListener, 1);//手动分发监听器的事件，通过dispatchEvent发布名称为custom_event的消息。EventCustom event = EventCustom(&quot;custom_event&quot;);event-&gt;setUserData((void*)123); // 绑定消息传递的数据，可以为任意类型void。dispatcher-&gt;dispatchEvent(&amp;event);//消息事件回调函数void HelloWorld::onCustomEvent(EventCustom* event){// 获取消息传递的数据int* data = (int*)event-&gt;getUserData()CCLOG(&quot;onCustomEvent data = %d&quot;, data);}</code></pre><h5 id="4、说明"><a href="#4、说明" class="headerlink" title="4、说明"></a>4、说明</h5><blockquote><p>每个自定义的事件监听器，都有一个监听器名字eventName。即为订阅的消息名称。</p></blockquote><blockquote><p>需要通过 dispatcher-&gt;dispatchEvent(&amp;event); 来手动将事件分发出去。即为发布消息。</p></blockquote><blockquote><p>可以通过 dispatcher-&gt;dispatchCustomEvent(,); 来给自定义事件监听器绑定一个用户数据。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习cocos2dx lua的时候，遇到了一些关于事件注册的逻辑！&lt;/p&gt;
&lt;p&gt;结合用户实际操作和游戏的真实需求，关于事件在游戏中还是使用非常多的，所以特此记录一下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;事件(网络)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;事件是可以被控件识别的操作。如按下确定按钮，选择某个单选按钮或者复选框。每一种控件有自己可以识别的事件，如窗体的加载、单击、双击等事件，编辑框（文本框）的文本改变事件，等等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;事件是用户对窗口上各种组件的操作。&quot;&gt;&lt;a href=&quot;#事件是用户对窗口上各种组件的操作。&quot; class=&quot;headerlink&quot; title=&quot;事件是用户对窗口上各种组件的操作。&quot;&gt;&lt;/a&gt;事件是用户对窗口上各种组件的操作。&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;事件有系统事件和用户事件。&lt;ul&gt;
&lt;li&gt;1.系统事件由系统激发，如时间间隔24小时，银行储蓄的存款日期增加一天。&lt;/li&gt;
&lt;li&gt;2.用户事件由用户激发，如用户点击按钮，在文本框中显示特定的文本。事件驱动控件执行某项功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&quot;触发事件的对象称为事件发送者；接收事件的对象称为事件接受者；&quot;&gt;&lt;a href=&quot;#触发事件的对象称为事件发送者；接收事件的对象称为事件接受者；&quot; class=&quot;headerlink&quot; title=&quot;触发事件的对象称为事件发送者；接收事件的对象称为事件接受者；&quot;&gt;&lt;/a&gt;触发事件的对象称为事件发送者；接收事件的对象称为事件接受者；&lt;/h6&gt;&lt;blockquote&gt;
&lt;p&gt;注: 这里只针对用户事件！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>cocos2d-x lua —— 元表metatable</title>
    <link href="https://icocos.github.io/2018/09/22/cocos2d-x-lua-%E2%80%94%E2%80%94-%E5%85%83%E8%A1%A8metatable/"/>
    <id>https://icocos.github.io/2018/09/22/cocos2d-x-lua-——-元表metatable/</id>
    <published>2018-09-22T04:48:00.000Z</published>
    <updated>2018-10-18T05:15:06.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lua表"><a href="#Lua表" class="headerlink" title="Lua表"></a>Lua表</h2><p>关于Lua表的介绍，这里有一段出自网络的介绍：</p><blockquote><p>Lua的表本质其实是个类似HashMap的东西，其元素是很多的Key-Value对.<br>如果尝试访问了一个表中并不存在的元素时，就会触发Lua的一套查找机制，也是凭借这个机制，才能够实现“面向对象”的。</p></blockquote><a id="more"></a><p>那么有时候我们可能会遇到这样的一段代码：</p><pre><code>myTable = {}  print(myTable.A) --这里试图打印myTable并不存在的成员A  </code></pre><blockquote><p>执行结果：nil</p></blockquote><blockquote><blockquote><p>输出为nil的原因很简单，myTable中并没有A这个成员，这符合我们平时对HashMap的认知。但对于Lua表，如果myTable有元表，情况就不同了。</p></blockquote></blockquote><h2 id="Lua元表"><a href="#Lua元表" class="headerlink" title="Lua元表"></a>Lua元表</h2><blockquote><p>元表像是一个备用查找表，说白了假设表A的元表是B，那么如果在A中找不到的东西就会尝试在B中去找。</p></blockquote><ul><li>在Lua中，metatable是被译作元表，Lua 中的每个值都可以用一个 metatable。这个 metatable 就是一个原始的 Lua table ，它用来定义原始值在特定操作下的行为。</li><li>一个 metatable 可以控制一个对象做数学运算操作、比较操作、连接操作、取长度操作、取下标操作时的行为，metatable 中还可以定义一个函数，让 userdata 作垃圾收集时调用它。对于这些操作，Lua 都将其关联上一个被称作事件的指定健。</li><li>当 Lua 需要对一个值发起这些操作中的一个时，它会去检查值中 metatable 中是否有对应事件。如果有的话，键名对应的值（元方法）将控制 Lua 怎样做这个操作。</li></ul><p>#####metatable通过其包含的函数来给所挂接的table定义一些特殊的操作，包括:</p><ul><li>__add: 定义所挂接table的加法操作</li><li>__mul: 定义乘法操作</li><li>__div: 定义除法操作</li><li>__sub: 定义减法操作</li><li>__unm: 定义负操作, 即: -table的含义</li><li>__tostring: 定义当table作为tostring()函式之参数被呼叫时的行为(例如: print(table)时将呼叫tostring(table)作为输出结果)</li><li>__concat: 定义连接操作(“..”运算符)</li><li>__index: 定义当table中不存在的key值被试图获取时的行为</li><li>__newindex: 定义在table中产生新key值时的行为</li></ul><h5 id="这里主要说一下-index"><a href="#这里主要说一下-index" class="headerlink" title="这里主要说一下_index"></a>这里主要说一下_index</h5><h2 id="index："><a href="#index：" class="headerlink" title="__index："></a>__index：</h2><p>如果A的元表是B，那么如果访问了一个A中不存在的成员，就会访问查找B中有没有这个成员。这个过程大体是这样，但却不完全是这样，实际上，即使将A的元表设置为B，而且B中也确实有这个成员，返回结果仍然会是nil，原因就是B的<strong>index元方法没有赋值。按照我的理解，</strong>index方法是用来确定一个表在被作为元表时的查找方法</p><pre><code>father = {      house=1  }  son = {      car=1  }  setmetatable(son, father) --把son的metatable设置为father  print(son.house) </code></pre><p>输出的结果是nil，但如果把代码改为</p><pre><code>father = {      house=1  }  father.__index = father -- 把father的__index方法指向自己  son = {      car=1  }  setmetatable(son, father)  print(son.house) </code></pre><p>输出的结果为1，符合预期。</p><p>在上述例子中，访问son.house时，son中没有house这个成员，但Lua接着发现son有元表father，于是此时father被当做元表来查找，此时，Lua并不是直接在father中找名为house的成员，而是调用father的<strong>index方法，如果</strong>index方法为nil，则返回nil，如果是一个表（上例中father的<strong>index方法等于自己，就是这种情况），那么就到</strong>index方法所指的这个表中查找名为house的成员，于是，最终找到了house成员。</p><blockquote><p>注：<strong>index方法除了可以是一个表，还可以是一个函数，如果是一个函数，</strong>index方法被调用时将返回该函数的返回值。</p></blockquote><p>相信到这里，应该已经很好理解了。</p><h5 id="总结一句就是：index是-当我们访问一个表中的元素不存在时，则会触发去寻找index元方法，如果不存在，则返回nil，如果存在，则返回结果。"><a href="#总结一句就是：index是-当我们访问一个表中的元素不存在时，则会触发去寻找index元方法，如果不存在，则返回nil，如果存在，则返回结果。" class="headerlink" title="总结一句就是：index是:当我们访问一个表中的元素不存在时，则会触发去寻找index元方法，如果不存在，则返回nil，如果存在，则返回结果。"></a>总结一句就是：<strong>index是:当我们访问一个表中的元素不存在时，则会触发去寻找</strong>index元方法，如果不存在，则返回nil，如果存在，则返回结果。</h5><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul><li>_newindex：当给你的表中不存在的值进行赋值时，lua解释器则会寻找__newindex元方法，发现存在该方法，则执行该方法进行赋值，注意，是使用rawset来进行赋值，至于原因，后面会讲到。</li><li>rawget是为了绕过<strong>index而出现的，直接点，就是让</strong>index方法的重写无效。</li></ul><h4 id="Lua查找一个表元素时的规则（出自网络）"><a href="#Lua查找一个表元素时的规则（出自网络）" class="headerlink" title="Lua查找一个表元素时的规则（出自网络）"></a>Lua查找一个表元素时的规则（出自网络）</h4><ul><li>1.在表中查找，如果找到，返回该元素，找不到则继续</li><li>2.判断该表是否有元表，如果没有元表，返回nil，有元表则继续</li><li>3.判断元表有没有<strong>index方法，如果</strong>index方法为nil，则返回nil；如果<strong>index方法是一个表，则重复1、2、3；如果</strong>index方法是一个函数，则返回该函数的返回值</li></ul><p>参考链接：<a href="https://blog.csdn.net/wangbin_jxust/article/details/12108189" target="_blank" rel="noopener">https://blog.csdn.net/wangbin_jxust/article/details/12108189</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Lua表&quot;&gt;&lt;a href=&quot;#Lua表&quot; class=&quot;headerlink&quot; title=&quot;Lua表&quot;&gt;&lt;/a&gt;Lua表&lt;/h2&gt;&lt;p&gt;关于Lua表的介绍，这里有一段出自网络的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Lua的表本质其实是个类似HashMap的东西，其元素是很多的Key-Value对.&lt;br&gt;如果尝试访问了一个表中并不存在的元素时，就会触发Lua的一套查找机制，也是凭借这个机制，才能够实现“面向对象”的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>cocos2dx——项目启动流程与跨平台原理</title>
    <link href="https://icocos.github.io/2018/09/14/cocos2dx%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://icocos.github.io/2018/09/14/cocos2dx——项目启动流程与跨平台原理/</id>
    <published>2018-09-14T06:44:48.000Z</published>
    <updated>2018-10-14T05:07:41.233Z</updated>
    
    <content type="html"><![CDATA[<p>最近大部分空余时间都在开始学习cocos2d游戏开发相关技术，作为一个游戏行业菜鸟级别的选手，我觉得基础很重要，所以我决定从cocos2dx启动流程和快平台原理开始！</p><blockquote><p>注:这里只针对Lua做相关介绍，为什么是Lua，有过cocos2dx经验的朋友应该都知道Lua小，快，简单，而且比较大众化，而C++就不多多说了，大部分程序员都有畏惧心理，当然也有一些C++比较好，或者有独特爱好和专研朋友！</p></blockquote><p><img src="http://pd1l3bbt7.bkt.clouddn.com/cocos2dx/data/cocoslaunch001.jpg" alt="曹理鹏(iCocos)-梦工厂"></p><p>关于其他平台基本上的流程和原理其实是一样的，可以直接参考！</p><a id="more"></a><h3 id="什么是Lua"><a href="#什么是Lua" class="headerlink" title="什么是Lua"></a>什么是Lua</h3><ul><li>百科:<ul><li>Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</li><li>Lua由标准C编写而成，几乎在所有操作系统和平台上都可以编译，运行。Lua并没有提供强大的库，这是由它的定位决定的。所以Lua不适合作为开发独立应用程序的语言。</li><li>Lua 有一个同时进行的JIT项目，提供在特定平台上的即时编译功能。</li></ul></li></ul><blockquote><p>很多应用程序、游戏使用LUA作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。这其中包括魔兽世界、博德之门、愤怒的小鸟、QQ三国、VOCALOID3、太阳神三国杀、游戏王ygocore等。</p></blockquote><h5 id="Cocos2d-lua，其实只是Cocos2d引擎添加了Lua绑定的版本。"><a href="#Cocos2d-lua，其实只是Cocos2d引擎添加了Lua绑定的版本。" class="headerlink" title="Cocos2d-lua，其实只是Cocos2d引擎添加了Lua绑定的版本。"></a>Cocos2d-lua，其实只是Cocos2d引擎添加了Lua绑定的版本。</h5><p>Cocos2d这里就不解释了，懒得拷贝，只是关于cocos创建和使用的时候需要注意的是</p><blockquote><p>cocos new TestProj -d Desktop/ -l lua，这里的引擎其实是同一套，只是创建工程时提供了不同语言的桥接层</p></blockquote><ul><li>使用C++语言和Cocos2d-x引擎进行开发时，我们写的代码是直接调用引擎的API的，因为引擎也是用C++语言编写，不需要进行语言转换</li><li>使用Lua语言和Cocos2d-x引擎进行开发时，我们写的代码通过LuaEngine执行，而LuaEngine封装了Cocos2d-x引擎的API，所以就相当于使用Lua脚本在调用Cocos2d-x的API了</li></ul><h3 id="各个平台的入口"><a href="#各个平台的入口" class="headerlink" title="各个平台的入口"></a>各个平台的入口</h3><h5 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h5><pre><code>#import &lt;UIKit/UIKit.h&gt;int main(int argc, char *argv[]) {    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];    int retVal = UIApplicationMain(argc, argv, nil, @&quot;AppController&quot;);    [pool release];    return retVal;}</code></pre><h5 id="Mac-OS"><a href="#Mac-OS" class="headerlink" title="Mac OS"></a>Mac OS</h5><pre><code>#import &lt;Cocoa/Cocoa.h&gt;int main(int argc, char *argv[]) {    return NSApplicationMain(argc, (const char **)argv);}</code></pre><h5 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h5><pre><code>int main(int argc,char *argv){    AppDelegate app;    return Application::getInstance()-&gt;run();}</code></pre><h5 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h5><pre><code>void cocos_android_app_init(JNIENV* env){    appDelegate.reset(new AppDelegate());    //新版本 : AppDelegate *pAppDelegate = new AppDelegate();}</code></pre><ul><li>Android启动流程概述<ul><li><ol><li>配置文件Manifest</li></ol></li><li><ol start="2"><li>AppActivity</li></ol></li><li><ol start="3"><li>onCreate</li></ol></li><li><ol start="4"><li>super.onCreate</li></ol></li><li><ol start="5"><li>onLoadNativeLibraries</li></ol></li><li><ol start="6"><li>System.loadLibrary(libName);</li></ol></li><li><ol start="7"><li>触发cocos_android_app_init（在main.cpp）中</li></ol></li><li><ol start="8"><li>再由库执行调用对应的Lua代码</li></ol></li><li>……</li></ul></li></ul><h5 id="由于笔者一直着力于iOS平台，所以这里以iOS为例，其他平台可参考："><a href="#由于笔者一直着力于iOS平台，所以这里以iOS为例，其他平台可参考：" class="headerlink" title="由于笔者一直着力于iOS平台，所以这里以iOS为例，其他平台可参考："></a>由于笔者一直着力于iOS平台，所以这里以iOS为例，其他平台可参考：</h5><h4 id="1-main函数入口"><a href="#1-main函数入口" class="headerlink" title="1. main函数入口"></a>1. main函数入口</h4><p>iOSApp中打开程序，加载完动态库，和一些必备的初始化和准备(rebase, bind,SetUp)之后,会回到main函数开始执行真正的程序代码</p><pre><code>int main(int argc, char *argv[]) {    @autoreleasepool {        return UIApplicationMain(argc, argv, nil, @&quot;AppController&quot;);    }}</code></pre><p>Main函数里面会调用UIApplicationMain， UIApplicationMain会一路走完这些流程</p><pre><code>+ 根据principalClassName传递的类名创建UIApplication对象+ 创建UIApplication代理对象，给UIApplication对象设置代理+ 开启主运行时间循环，处理事件，保持程序一直运行+ 加载info.plist，判断下是否指定了main，如果指定了，就会去加载</code></pre><p>我们可以看到这里设置的代理是AppController，然后看看AppController</p><h4 id="2-代理对象AppController"><a href="#2-代理对象AppController" class="headerlink" title="2. 代理对象AppController"></a>2. 代理对象AppController</h4><p>AppController里面有个    didFinishLaunchingWithOptions，这个是程序加载完毕的监听方法</p><pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {cocos2d::Application *app = cocos2d::Application::getInstance();// Initialize the GLView attributesapp-&gt;initGLContextAttrs();cocos2d::GLViewImpl::convertAttrs();// Override point for customization after application launch.// Add the view controller&apos;s view to the window and display.window = [[UIWindow alloc] initWithFrame: [[UIScreen mainScreen] bounds]];// Use RootViewController to manage CCEAGLView_viewController = [[RootViewController alloc]init];_viewController.wantsFullScreenLayout = YES;// Set RootViewController to windowif ( [[UIDevice currentDevice].systemVersion floatValue] &lt; 6.0){// warning: addSubView doesn&apos;t work on iOS6[window addSubview: _viewController.view];}else{// use this method on ios6[window setRootViewController:_viewController];}[window makeKeyAndVisible];[[UIApplication sharedApplication] setStatusBarHidden:true];// IMPORTANT: Setting the GLView should be done after creating the RootViewControllercocos2d::GLView *glview = cocos2d::GLViewImpl::createWithEAGLView((__bridge void *)_viewController.view);cocos2d::Director::getInstance()-&gt;setOpenGLView(glview);//run the cocos2d-x game sceneapp-&gt;run();return YES;}</code></pre><p>前面分别：获取Director，GLView设置GLView，最后执行run</p><h4 id="3-run-cocos2d-delegate"><a href="#3-run-cocos2d-delegate" class="headerlink" title="3. run cocos2d delegate"></a>3. run cocos2d delegate</h4><p>我们看看run方法里面，这里的run方法很关键，</p><pre><code>int Application::run(){    if (applicationDidFinishLaunching())    {        [[CCDirectorCaller sharedDirectorCaller] startMainLoop];    }    return 0;}</code></pre><p>有个applicationDidFinishLaunching，其实这里cocos2d默认的代理，在class中</p><h4 id="4-cocos2d配置，lua加载"><a href="#4-cocos2d配置，lua加载" class="headerlink" title="4. cocos2d配置，lua加载"></a>4. cocos2d配置，lua加载</h4><p>这里在coco2d的代理中，可以看到一堆的初始化配置和加载，然后就开始获取并执行脚本lua(通过lua脚本显示并处理Scene逻辑)</p><pre><code>bool AppDelegate::applicationDidFinishLaunching(){    // set default FPS    Director::getInstance()-&gt;setAnimationInterval(1.0 / 60.0f);    // register lua module    auto engine = LuaEngine::getInstance();    ScriptEngineManager::getInstance()-&gt;setScriptEngine(engine);    lua_State* L = engine-&gt;getLuaStack()-&gt;getLuaState();    lua_module_register(L);    register_all_packages();    LuaStack* stack = engine-&gt;getLuaStack();    stack-&gt;setXXTEAKeyAndSign(&quot;2dxLua&quot;, strlen(&quot;2dxLua&quot;), &quot;XXTEA&quot;, strlen(&quot;XXTEA&quot;));    //register custom function    //LuaStack* stack = engine-&gt;getLuaStack();    //register_custom_function(stack-&gt;getLuaState());    #if CC_64BITS        FileUtils::getInstance()-&gt;addSearchPath(&quot;src/64bit&quot;);    #endif        FileUtils::getInstance()-&gt;addSearchPath(&quot;src&quot;);        FileUtils::getInstance()-&gt;addSearchPath(&quot;res&quot;);        if (engine-&gt;executeScriptFile(&quot;main.lua&quot;))        {            return false;        }    return true;}</code></pre><h5 id="原生集成补充"><a href="#原生集成补充" class="headerlink" title="原生集成补充"></a>原生集成补充</h5><p>如果你是直接在原生嵌入而不是夸平台会看到这里其实是创建并返回Scene</p><pre><code>bool AppDelegate::applicationDidFinishLaunching() {    // initialize director    auto director = Director::getInstance();    auto glview = director-&gt;getOpenGLView();    if(!glview) {        glview = GLViewImpl::create(&quot;Fiction_Single&quot;);        director-&gt;setOpenGLView(glview);    }    // turn on display FPS    // director-&gt;setDisplayStats(true);    // set FPS. the default value is 1.0/60 if you don&apos;t call this    director-&gt;setAnimationInterval(1.0f / 60);    register_all_packages();    //SpriteFrameCache::getInstance()-&gt;removeSpriteFrames();    //SpriteFrameCache::getInstance()-&gt;removeUnusedSpriteFrames();    // create a scene. it&apos;s an autorelease object    // 初始化与运行主场景    auto scene = GameMainLayer::MainScene();    // 初始化与运行主场景    director-&gt;runWithScene(scene);    return true;}</code></pre><p>游戏逻辑就可以从这个Scene中的init函数开始，添加UI层，添加事件监听器，添加游戏层等等…如果我们有一些统计、资源管理器等，也可以在AppDelegate的applicationDidFinishLaunching函数中来进行。</p><h4 id="5-Lua脚本初始化"><a href="#5-Lua脚本初始化" class="headerlink" title="5. Lua脚本初始化"></a>5. Lua脚本初始化</h4><p>再来看”main.lua”，这个时候我们就开始开发查看main.lua文件</p><p>从MyApp开始，初始化，然后执行run运行程序</p><pre><code>cc.FileUtils:getInstance():setPopupNotify(false)require &quot;config&quot;require &quot;cocos.init&quot;local function main()    require(&quot;app.MyApp&quot;):create():run()endlocal status, msg = xpcall(main, __G__TRACKBACK__)if not status then    print(msg)end</code></pre><p>这里很重要的一个方法是run(),run()方法是设置启动View，</p><h4 id="6-指定Scene"><a href="#6-指定Scene" class="headerlink" title="6. 指定Scene"></a>6. 指定Scene</h4><p>如果想指定启动，而不是使用默认的Scene，</p><p>local function main()<br>    require(“app.MyApp”):create():run(“StartScene”)<br>end</p><p>默认不设置会选择MainScene，如果仔细再AppBase里面会看到这样一行代码</p><pre><code>function AppBase:ctor(configs)self.configs_ = {    viewsRoot  = &quot;app.views&quot;,    modelsRoot = &quot;app.models&quot;,    defaultSceneName = &quot;MainScene&quot;,}.....</code></pre><h4 id="7-根据脚本指定Scene，"><a href="#7-根据脚本指定Scene，" class="headerlink" title="7. 根据脚本指定Scene，"></a>7. 根据脚本指定Scene，</h4><p>上面说了，如果没有设置就会试着用默认的Scene，run里面的逻辑就是去真正指定Scene，</p><pre><code>-- 创建完对象之后，就到了这一步function AppBase:run(initSceneName)    initSceneName = initSceneName or self.configs_.defaultSceneName    self:enterScene(initSceneName)  -- 如果没有指定第一个Scene，则第一个Scene为MainSceneend-- 生成并进入第一个Scenefunction AppBase:enterScene(sceneName, transition, time, more)    local view = self:createView(sceneName)     -- 前去生成View    view:showWithScene(transition, time, more)  -- 因为MainScene继承自ViewBase类，这里就吊用ViewBase的方法了    return viewend</code></pre><blockquote><p>建议仔细读一下AppBase，ViewBase！</p></blockquote><h4 id="8-自定义Scene-StartScene"><a href="#8-自定义Scene-StartScene" class="headerlink" title="8. 自定义Scene(StartScene)"></a>8. 自定义Scene(StartScene)</h4><p>这个时候就会首先从StartScene开始，</p><pre><code>local StartScene = class(&quot;StartScene&quot;, cc.load(&quot;mvc&quot;).ViewBase)function StartScene:onCreate()    display.newSprite(&quot;HelloWorld.png&quot;)    :move(display.center)    :addTo(self)    cc.Label:createWithSystemFont(&quot;cocos2dx Run StartScene&quot;, &quot;Arial&quot;, 60)    :move(display.cx, display.cy + 200)    :addTo(self)endreturn StartScene</code></pre><h4 id="然后后面步骤就是从StartScene开始，写脚本代码，处理UI，网络和逻辑等，"><a href="#然后后面步骤就是从StartScene开始，写脚本代码，处理UI，网络和逻辑等，" class="headerlink" title="然后后面步骤就是从StartScene开始，写脚本代码，处理UI，网络和逻辑等，"></a>然后后面步骤就是从StartScene开始，写脚本代码，处理UI，网络和逻辑等，</h4><p>到这里就基本上完成cocos2dx Lua启动流程，其他C++,JS原理和流程其实都差不多, 只是执行的方法或者代码不一样而已</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实关于coocs2dx之前的版本我不了解，就我目前了解到的，其实就是由通用程序入口到跨平台程序入口</p><p>基本的流程如下</p><ul><li>初始化Director</li><li>新建GLView，然后进行一些设置</li><li>新建Scene</li><li>使用Director运行这个场景</li></ul><hr><pre><code>bool AppDelegate::applicationDidFinishLaunching()//程序入口 -&gt; 跨平台程序入口{    auto director = Director::getInstance();    auto glview = director-&gt;getOpenGLView();    if(!glview)    {        glview = GLViewImpl::create(&quot;my test&quot;);        director-&gt;setOpenGLView(glview);    }    //初始化、资源适配、屏幕适配、运行第一个场景...    glview-&gt;setDesignResolutionSize();    auto scene = Hellow::scene();    director-&gt;runWithScene(scene);    return scene;}</code></pre><blockquote><p>通过上面我们其实可以知道，cocos2d_lua_bindings库提供了Lua对Cocos2d引擎的绑定，相当于通过注册Module的方式对Cocos2d引擎提供的（相关的）API进行了一次封装（把常用的功能封装成一个函数newScene）。</p></blockquote><p>相对于Cocos2d-x C++工程来说，Cocos2d-x生成的Lua语言工程提供了对Cocos2d引擎的Lua语言封装。将Cocos2d引擎API绑定到对应的Lua语言函数，在调用到这些函数时，会执行对应的Cocos2d引擎API, 其实最终还是调用的C++代码和对应的引擎代码。</p><h3 id="跨平台原理"><a href="#跨平台原理" class="headerlink" title="跨平台原理"></a>跨平台原理</h3><blockquote><ol><li>AppDelegate 作为跨平台程序入口，在这之上做了另一层的封装，封装了不同平台的不同实现。比如我们通常认为一个程序是由 main 函数开始运行，那我们就去找寻，我们看到了在 proj.linux 目录下存在 main.cpp 文件。</li></ol></blockquote><blockquote><ol start="2"><li>在main.cpp 中 CCApplication::sharedApplication()–&gt;run(); 这一句看起，这一句标志着， cocos2d-x 程序正式开始运行.</li></ol></blockquote><blockquote><ol start="3"><li>定位到 sharedApplication() 方法的实现，在CCAplication类中我们可以看到从 sharedApplication() 方法，在调用 run() 方法，在这之前，我们需要调用到它的构造函数，否则不能运行，这就是为什么在 CCApplication::sharedApplication()–&gt;run(); 之前，我们首先有语句 AppDelegate app; <blockquote><p>创建 AppDelegate 变量的原因是 AppDelegate 是 CCApplication 的子类，在创建子类对象的时候，调用其构造函数的同时，父类构造函数也会执行，然后就将 AppDelegate 的对象赋给了 CCApplication 的静态变量，而在 AppDelegate 之中我们实现了 applicationDidFinishLaunching方法，所以在 CCApplication 中 run 方法的开始处调用的就是 AppDelegate 之中的实现。</p></blockquote></li></ol></blockquote><blockquote><ol start="3"><li>我们在此方法中我们初始化了一些变量，创建了第一个 CCScene 场景等，之后的控制权，便全权交给了CCDirector::sharedDirector()–&gt;mainLoop(); 方法了。</li></ol></blockquote><p><img src="http://pd1l3bbt7.bkt.clouddn.com/cocos2dx/data/cocoalaunch002.jpg" alt="曹理鹏(iCocos)-梦工厂"></p><ul><li><p>在cocos2d-x的文件夹下，有一个platform文件夹，里面存放了跨平台的封装接口。</p></li><li><p>当前目录下有CCApplicationProtocol.h头文件，子目录有win32,Android,IOS三个文件夹，里面分别存放跨平台需要的函数，其中包括CCApplication。</p></li><li><p>而AppDelegate 类则是继承自CCApplication。CCApplication又继承自CCApplicationProtocol。</p></li><li><p>在CCApplicationProtocol中定义了applicationDidFinishLaunching虚方法,由CCApplication 继承， AppDelegate 实现的。以此实现了跨平台。</p></li></ul><blockquote><p>为了充分发挥硬件性能，手机游戏通常使用Native App开发模式，这就造成开发商要为iOS 和Android平台用户开发不同的应用，无论是产品迭代还是运行维护都非常麻烦。</p></blockquote><p>Cocos2d-x在iOS，Android等移动平台之上，封装了一层C++接口，从而屏蔽了平台的差异性，通过平台宏来控制使用哪个平台的代码，向开发者提供C++接口调用。这些接口主要包括UI、事件和网络，封装UI主要是使用OpenGL ES的接口来写UI，封装事件和网络，均是使用C++接口对原生接口进行一层封装。</p><ul><li>具体更多启动相关细节，可以参考这里<ul><li><a href="https://www.jianshu.com/p/781d835c88c9" target="_blank" rel="noopener">https://www.jianshu.com/p/781d835c88c9</a></li><li><a href="http://www.cocos2d-x.org/docs/cocos2d-x/zh/about/learn.html" target="_blank" rel="noopener">http://www.cocos2d-x.org/docs/cocos2d-x/zh/about/learn.html</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近大部分空余时间都在开始学习cocos2d游戏开发相关技术，作为一个游戏行业菜鸟级别的选手，我觉得基础很重要，所以我决定从cocos2dx启动流程和快平台原理开始！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注:这里只针对Lua做相关介绍，为什么是Lua，有过cocos2dx经验的朋友应该都知道Lua小，快，简单，而且比较大众化，而C++就不多多说了，大部分程序员都有畏惧心理，当然也有一些C++比较好，或者有独特爱好和专研朋友！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://pd1l3bbt7.bkt.clouddn.com/cocos2dx/data/cocoslaunch001.jpg&quot; alt=&quot;曹理鹏(iCocos)-梦工厂&quot;&gt;&lt;/p&gt;
&lt;p&gt;关于其他平台基本上的流程和原理其实是一样的，可以直接参考！&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS——请求依赖多种解决方案</title>
    <link href="https://icocos.github.io/2018/08/23/iOS%E2%80%94%E2%80%94%E8%AF%B7%E6%B1%82%E4%BE%9D%E8%B5%96%E5%A4%9A%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://icocos.github.io/2018/08/23/iOS——请求依赖多种解决方案/</id>
    <published>2018-08-22T18:39:08.000Z</published>
    <updated>2018-08-22T15:37:09.220Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>iOS开发中如何解决网络请求的依赖关系(同时应用于业务层)</p><ul><li>比如：一个(或多个)接口的请求需要依赖于另一个(或多个)网络请求的结果？</li></ul></li><li><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul><li>操作依赖 – NSOperation</li><li>逻辑判断 – if/else</li><li>线程同步 – 组队列</li><li>线程同步 – 阻塞任务</li><li>线程同步 – 信号量机制</li></ul></li></ul><a id="more"></a><h3 id="操作依赖-–-NSOperation"><a href="#操作依赖-–-NSOperation" class="headerlink" title="操作依赖 – NSOperation"></a>操作依赖 – NSOperation</h3><p>NSOperation 操作依赖和优先级（不适用，异步网络请求并不是立刻返回，无法保证回调时再开启下一个网络请求）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Do any additional setup after loading the view, typically from a nib.</span><br><span class="line">//创建队列</span><br><span class="line">NSOperationQueue *queue=[[NSOperationQueue alloc] init];</span><br><span class="line">//创建操作</span><br><span class="line">NSBlockOperation *operation1=[NSBlockOperation blockOperationWithBlock:^()&#123;</span><br><span class="line">    NSLog(@<span class="string">"执行第1次操作，线程：%@"</span>,[NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">NSBlockOperation *operation2=[NSBlockOperation blockOperationWithBlock:^()&#123;</span><br><span class="line">    NSLog(@<span class="string">"执行第2次操作，线程：%@"</span>,[NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">NSBlockOperation *operation3=[NSBlockOperation blockOperationWithBlock:^()&#123;</span><br><span class="line">    NSLog(@<span class="string">"执行第3次操作，线程：%@"</span>,[NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">//添加依赖</span><br><span class="line">[operation1 addDependency:operation2];</span><br><span class="line">[operation2 addDependency:operation3];</span><br><span class="line">//将操作添加到队列中去</span><br><span class="line">[queue addOperation:operation1];</span><br><span class="line">[queue addOperation:operation2];</span><br><span class="line">[queue addOperation:operation3];</span><br></pre></td></tr></table></figure><h3 id="逻辑判断-–-if-else"><a href="#逻辑判断-–-if-else" class="headerlink" title="逻辑判断 – if/else"></a>逻辑判断 – if/else</h3><p>上一个网络请求的响应回调后，下一网络请求的才开始执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSString *urlString = @<span class="string">"http://www.icocos.cn"</span>;</span><br><span class="line">    </span><br><span class="line">AFHTTPSessionManager *manger =[AFHTTPSessionManager manager];</span><br><span class="line">    </span><br><span class="line">[manger GET:urlString parameters:nil progress:^(NSProgress * _Nonnull downloadProgress) &#123;</span><br><span class="line">    </span><br><span class="line">&#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class="line">    NSLog(@<span class="string">"成功"</span>);</span><br><span class="line">    /////////////////////////////////////////////</span><br><span class="line">    // TODO： 执行下一个请求</span><br><span class="line">    /////////////////////////////////////////////</span><br><span class="line">&#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line">    NSLog(@<span class="string">"%@"</span>,error);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>但是这样会存在一个概率性的问题，就会有可能根本拿不到结果，或者由于网络慢和用户操作之间的关系导致不可预料的问题。</p><h3 id="线程同步-–-组队列（dispatch-group）"><a href="#线程同步-–-组队列（dispatch-group）" class="headerlink" title="线程同步 – 组队列（dispatch_group）"></a>线程同步 – 组队列（dispatch_group）</h3><p>dispatch_group是GCD(Grand Central Dispatch)中的一组方法，他有一个组的概念，可以把相关的任务归并到一个组内来执行，通过监听组内所有任务的执行情况来做相应处理。</p><ul><li>1.dispatch_group_async<ul><li>将代码块dispatch_block_t block放入队列dispatch_queue_t queue中执行；并和调度组dispatch_group_t group相互关联；如果提交到dispatch_queue_t queue中的block全都执行完毕会调用dispatch_group_notify并且dispatch_group_wait会停止等待；</li></ul></li><li>2.dispatch_group_enter(group)、dispatch_group_leave(group)<ul><li>和内存管理的引用计数类似，我们可以认为group也持有一个整形变量(只是假设)，当调用enter时计数加1，调用leave时计数减1，当计数为0时会调用dispatch_group_notify并且dispatch_group_wait会停止等待；</li></ul></li><li>3.dispatch_group_notify<ul><li>当关联到dispatch_group_t上的dispatch_group_async任务执行完毕或者是关联在上面的dispatch_group_enter、dispatch_group_leave成对出现了。参数中的dispatch_block_t block会被提交到dispatch_queue_t queue中执行。 </li></ul></li><li>4.dispatch_group_wait<ul><li>和dispatch_group_notify功能类似(多了一个dispatch_time_t参数可以设置超时时间)，在group上任务完成前，dispatch_group_wait会阻塞当前线程(所以不能放在主线程调用)一直等待；当group上任务完成，或者等待时间超过设置的超时时间会结束等待； </li></ul></li><li>5………..</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">bashdispatch_queue_t dispatchQueue = dispatch_queue_create(&quot;icocos.queue.next&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_queue_t globalQueue = dispatch_get_global_queue(0, 0);</span><br><span class="line">    dispatch_group_t dispatchGroup = dispatch_group_create();</span><br><span class="line">    dispatch_group_async(dispatchGroup, dispatchQueue, ^()&#123;</span><br><span class="line">        </span><br><span class="line">        dispatch_async(globalQueue, ^&#123;</span><br><span class="line">           </span><br><span class="line">            sleep(5);</span><br><span class="line">            NSLog(@&quot;请求任务一完成&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_async(dispatchGroup, dispatchQueue, ^()&#123;</span><br><span class="line">        </span><br><span class="line">        dispatch_async(globalQueue, ^&#123;</span><br><span class="line">            </span><br><span class="line">            sleep(8);</span><br><span class="line">            NSLog(@&quot;请求任务二完成&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_notify(dispatchGroup, dispatch_get_main_queue(), ^()&#123;</span><br><span class="line">        NSLog(@&quot;notify：请求任务都完成了&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程同步-–阻塞任务（dispatch-barrier）："><a href="#线程同步-–阻塞任务（dispatch-barrier）：" class="headerlink" title="线程同步 –阻塞任务（dispatch_barrier）："></a>线程同步 –阻塞任务（dispatch_barrier）：</h3><p>一个dispatch barrier 允许在一个并发队列中创建一个同步点。当在并发队列中遇到一个barrier, 他会延迟执行barrier的block,等待所有在barrier之前提交的blocks执行结束。 这时，barrier block自己开始执行。 之后， 队列继续正常的执行操作。</p><blockquote><p>调用这个函数总是在barrier block被提交之后立即返回，不会等到block被执行。当barrier block到并发队列的最前端，他不会立即执行。相反，队列会等到所有当前正在执行的blocks结束执行。到这时，barrier才开始自己执行。所有在barrier block之后提交的blocks会等到barrier block结束之后才执行。</p></blockquote><ul><li>dispatch_barrier_async函数的作用<ul><li>1.实现高效率的数据库访问和文件访问</li><li>2.避免数据竞争</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* 创建并发队列 */</span><br><span class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(<span class="string">"test.concurrent.queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">/* 添加两个并发操作A和B，即A和B会并发执行 */</span><br><span class="line">dispatch_async(concurrentQueue, ^()&#123;</span><br><span class="line">    NSLog(@<span class="string">"请求OperationA"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(concurrentQueue, ^()&#123;</span><br><span class="line">    NSLog(@<span class="string">"请求OperationB"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">/* 添加barrier障碍操作，会等待前面的并发操作结束，并暂时阻塞后面的并发操作直到其完成 */</span><br><span class="line">dispatch_barrier_async(concurrentQueue, ^()&#123;</span><br><span class="line">    NSLog(@<span class="string">"请求OperationBarrier!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">/* 继续添加并发操作C和D，要等待barrier障碍操作结束才能开始 */</span><br><span class="line">dispatch_async(concurrentQueue, ^()&#123;</span><br><span class="line">    NSLog(@<span class="string">"请求OperationC"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(concurrentQueue, ^()&#123;</span><br><span class="line">    NSLog(@<span class="string">"请求OperationD"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="线程同步-–-信号量机制（dispatch-semaphore）："><a href="#线程同步-–-信号量机制（dispatch-semaphore）：" class="headerlink" title="线程同步 – 信号量机制（dispatch_semaphore）："></a>线程同步 – 信号量机制（dispatch_semaphore）：</h3><ul><li>信号量：<ul><li>就是一种可用来控制访问资源的数量的标识，设定了一个信号量，在线程访问之前，加上信号量的处理，则可告知系统按照我们指定的信号量数量来执行多个线程。</li></ul></li></ul><blockquote><p>其实，这有点类似锁机制了，只不过信号量都是系统帮助我们处理了，我们只需要在执行线程之前，设定一个信号量值，并且在使用时，加上信号量处理方法就行了。</p></blockquote><h5 id="信号量主要有3个函数"><a href="#信号量主要有3个函数" class="headerlink" title="信号量主要有3个函数"></a>信号量主要有3个函数</h5><pre><code>创建信号量，参数：信号量的初值，如果小于0则会返回NULLdispatch_semaphore_create（信号量值）//等待降低信号量dispatch_semaphore_wait（信号量，等待时间）//提高信号量dispatch_semaphore_signal(信号量)</code></pre><p>注意，正常的使用顺序是先降低然后再提高，这两个函数通常成对使用。　</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">- (void)getToken</span><br><span class="line">&#123;</span><br><span class="line">    //以上请求的设置忽略</span><br><span class="line">    NSURLSessionDataTask *task = [mySession dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            NSLog(@<span class="string">"get Token"</span>);</span><br><span class="line">            //拿到token，传给request请求做参数</span><br><span class="line">            [self request:token];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            NSLog(@<span class="string">"token error:%@"</span>,error.description);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;];</span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)request:(NSString *)params</span><br><span class="line">&#123;</span><br><span class="line">    //请求的设置忽略</span><br><span class="line">    NSURLSessionDataTask *task = [mySession dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            NSLog(@<span class="string">"request success"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            NSLog(@<span class="string">"request error:%@----"</span>,error.description);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 指定调用</span><br><span class="line">- (IBAction)buttonPress:(UIButton *)sender</span><br><span class="line">&#123;</span><br><span class="line">    //创建一个并行队列</span><br><span class="line">    dispatch_queue_t queque = dispatch_queue_create(<span class="string">"GoyakodCreated"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    //异步执行</span><br><span class="line">    dispatch_async(queque, ^&#123;</span><br><span class="line">        dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line">        [self getToken:semaphore];</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        [self request];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@<span class="string">"main thread"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)getToken:(dispatch_semaphore_t)semaphore</span><br><span class="line">&#123;</span><br><span class="line">    //以上请求的设置忽略</span><br><span class="line">    NSURLSessionDataTask *task = [mySession dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            NSLog(@<span class="string">"get Token"</span>);</span><br><span class="line">           //成功拿到token，发送信号量:</span><br><span class="line">            dispatch_semaphore_signal(semaphore);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            NSLog(@<span class="string">"token error:%@"</span>,error.description);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;];</span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;iOS开发中如何解决网络请求的依赖关系(同时应用于业务层)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比如：一个(或多个)接口的请求需要依赖于另一个(或多个)网络请求的结果？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h4 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;操作依赖 – NSOperation&lt;/li&gt;
&lt;li&gt;逻辑判断 – if/else&lt;/li&gt;
&lt;li&gt;线程同步 – 组队列&lt;/li&gt;
&lt;li&gt;线程同步 – 阻塞任务&lt;/li&gt;
&lt;li&gt;线程同步 – 信号量机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://icocos.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://icocos.github.io/tags/iOS/"/>
    
      <category term="网络层" scheme="https://icocos.github.io/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title> 开发必备理论常识：HTTP-&gt;HTTPS</title>
    <link href="https://icocos.github.io/2018/08/18/%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E7%90%86%E8%AE%BA%E5%B8%B8%E8%AF%86%EF%BC%9AHTTP-HTTPS/"/>
    <id>https://icocos.github.io/2018/08/18/开发必备理论常识：HTTP-HTTPS/</id>
    <published>2018-08-18T05:11:14.000Z</published>
    <updated>2018-08-11T05:17:58.997Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li><p>超文本传输协议（HTTP，HyperText Transfer Protocol)</p><ul><li>是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</li></ul></li><li><p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer）</p><ul><li>是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 </li></ul></li></ul><p>HTTPS句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。</p><a id="more"></a><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>HTTP是一个基于TCP的协议,而TCP是一种可靠的传输层协议.</p><blockquote><p>TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP/IP做传输层协议将它发到网络上。</p></blockquote><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><blockquote><p>HTTP+加密+认证+完整性保护=HTTPS</p></blockquote><p>是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><ul><li>HTTPS协议的主要作用可以分为两种：<ul><li>一种是建立一个信息安全通道，来保证数据传输的安全；</li><li>另一种就是确认网站的真实性。</li></ul></li></ul><p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。</p><h3 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h3><ul><li><p>SSL：（Secure Socket Layer，安全套接字层）</p><ul><li>位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。</li></ul></li><li><p>TLS：（Transport Layer Security，传输层安全协议）</p><ul><li>用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。</li></ul></li></ul><p>SSL是Netscape开发的专门用于保护Web通讯的，目前版本为3.0.最新版本的TLS 1.0是IETE（工程任务组）指定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本。两者差别极小，可以理解为SSL 3.1，它是写入了RFC的。　　</p><ul><li><p>SSL的作用</p><ul><li><p>（1）、认证用户和服务器，确保数据发送到正确的客户机和服务器；</p></li><li><p>（2）、加密数据以防止数据中途被窃取；</p></li><li><p>（3）、维护数据的完整性，确保数据在传输过程中不被改变。</p></li></ul></li></ul><p>而SSL证书指的是在SSL通信中验证通信双方身份的数字文件，一般分为服务器证书和客户端证书，我们通常说的SSL证书主要指服务器证书，SSL证书由受信任的数字证书颁发机构CA（如VeriSign，GlobalSign，WoSign等），在验证服务器身份后颁发，具有服务器身份验证和数据传输加密功能，分为扩展验证型(EV)SSL证书、组织验证型(OV)SSL证书、和域名验证型（DV）SSL证书。</p><h3 id="CA证书"><a href="#CA证书" class="headerlink" title="CA证书"></a>CA证书</h3><blockquote><p>CA（Certificate Authority）是负责管理和签发证书的第三方权威机构，是所有行业和公众都信任的、认可的。</p></blockquote><p>CA证书，就是CA颁发的证书，可用于验证网站是否可信（针对HTTPS）、验证某文件是否可信（是否被篡改）等，也可以用一个证书来证明另一个证书是真实可信，最顶级的证书称为根证书。除了根证书（自己证明自己是可靠），其它证书都要依靠上一级的证书，来证明自己。</p><h3 id="HTTP-amp-HTTPS区别："><a href="#HTTP-amp-HTTPS区别：" class="headerlink" title="HTTP&amp;HTTPS区别："></a>HTTP&amp;HTTPS区别：</h3><p>简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p><ol><li>https协议需要到ca申请证书或自制证书。</li><li>http的信息是明文传输，https则是具有安全性的ssl加密。</li><li>http是直接与TCP进行数据传输，而https是经过一层SSL（OSI表示层），用的端口也不一样，前者是80（需要国内备案），后者是443。</li><li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ol><p>HTTP&amp;HTTPS综合区别：<a href="https://blog.csdn.net/hanjianqiang2468/article/details/52605849" target="_blank" rel="noopener">https://blog.csdn.net/hanjianqiang2468/article/details/52605849</a></p><blockquote><p>注意: https加密是在传输层</p></blockquote><p>https报文在被包装成tcp报文的时候完成加密的过程，无论是https的header域也好，body域也罢都是会被加密的。</p><p>当使用tcpdump或者wireshark之类的tcp层工具抓包，获取是加密的内容，而如果用应用层抓包，使用Charels(Mac)、Fildder(Windows)抓包工具，那当然看到是明文的。</p><h3 id="握手过程"><a href="#握手过程" class="headerlink" title="握手过程"></a>握手过程</h3><h5 id="HTTP三次握手"><a href="#HTTP三次握手" class="headerlink" title="HTTP三次握手"></a>HTTP三次握手</h5><p><img src="http://pd1l3bbt7.bkt.clouddn.com/2018/common/http_s/http_https_001.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>HTTP（HyperText Transfer Protocol)超文本传输协议是互联网上应用最为广泛的一种网络协议。由于信息是明文传输，所以被认为是不安全的。而关于HTTP的三次握手，其实就是使用三次TCP握手确认建立一个HTTP连接。</p><blockquote><p>SYN（synchronous）是TCP/IP建立连接时使用的握手信号、Sequence number（序列号）、Acknowledge number（确认号码），三个箭头指向就代表三次握手，完成三次握手，客户端与服务器开始传送数据。</p></blockquote><ul><li><p>第一次握手：</p><ul><li>客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；</li></ul></li><li><p>第二次握手：</p><ul><li>服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li></ul></li><li><p>第三次握手：</p><ul><li>客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li></ul></li></ul><h6 id="建立TCP连接时会发生-三次握手-three-way-handshake"><a href="#建立TCP连接时会发生-三次握手-three-way-handshake" class="headerlink" title="建立TCP连接时会发生:三次握手(three-way handshake)"></a>建立TCP连接时会发生:三次握手(three-way handshake)</h6><ul><li>firefox &gt; nginx [SYN] 在么</li><li>nginx &gt; firefox [SYN, ACK] 在</li><li>firefox &gt; nginx [ACK] 知道了</li></ul><h5 id="为什么断开需要四次握手"><a href="#为什么断开需要四次握手" class="headerlink" title="为什么断开需要四次握手:"></a>为什么断开需要四次握手:</h5><p>关于四次握手的详细过程这里就不过多介绍，请自行百度，这里简单说一下需要执行的步骤，和为什么连接是三次，二断开时四次</p><h6 id="关闭TCP连接时会发生-四次挥手-four-way-handshake"><a href="#关闭TCP连接时会发生-四次挥手-four-way-handshake" class="headerlink" title="关闭TCP连接时会发生:四次挥手(four-way handshake)"></a>关闭TCP连接时会发生:四次挥手(four-way handshake)</h6><ul><li>firefox &gt; nginx [FIN] 我要关闭连接了</li><li>nginx &gt; firefox [ACK] 知道了,等我发完包先</li><li>nginx &gt; firefox [FIN] 我也关闭连接了</li><li>firefox &gt; nginx [ACK] 好的,知道了</li></ul><h6 id="解释原因："><a href="#解释原因：" class="headerlink" title="解释原因："></a>解释原因：</h6><ul><li>TCP建立连接要进行3次握手,而断开连接要进行4次,这是由于TCP的半关闭造成的,因为TCP连接是全双工的(</li><li>即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭,这个单方向的关闭就叫半关闭.</li><li>关闭的方法是一方完成它的数据传输后,就发送一个FIN来向另一方通告将要终止这个方向的连接.当一端收到一个FIN,它必须</li><li>通知应用层TCP连接已终止了这个方向的数据传送,发送FIN通常是应用层进行关闭的结果.</li></ul><h6 id="另一种解释："><a href="#另一种解释：" class="headerlink" title="另一种解释："></a>另一种解释：</h6><ul><li>这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</li></ul><blockquote><p>补充</p></blockquote><blockquote><blockquote><p>SYN: synchronization(同步)</p></blockquote></blockquote><blockquote><blockquote><p>ACK: acknowledgement(确认:告知已收到)</p></blockquote></blockquote><blockquote><blockquote><p>FIN: finish(结束)</p></blockquote></blockquote><h5 id="HTTPS握手："><a href="#HTTPS握手：" class="headerlink" title="HTTPS握手："></a>HTTPS握手：</h5><p><img src="http://pd1l3bbt7.bkt.clouddn.com/2018/common/http_s/http_https_002.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。具体是如何进行加密，解密，验证的，且看下图，下面的称为一次握手。</p><ul><li><p>1.客户端发起HTTPS请求</p></li><li><p>2.服务端的配置</p><ul><li>采用HTTPS协议的服务器必须要有一套数字证书，可以是自己制作或者CA证书。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用CA证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。公钥给别人加密使用，私钥给自己解密使用。</li></ul></li><li><p>3.传送证书</p><ul><li>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等。</li></ul></li><li><p>4.客户端解析证书</p><ul><li>这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值，然后用证书对该随机值进行加密。</li></ul></li><li><p>5.传送加密信息</p><ul><li>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</li></ul></li><li><p>6.服务段解密信息</p><ul><li>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</li></ul></li><li><p>7.传输加密后的信息</p><ul><li>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</li></ul></li><li><p>8.客户端解密信息</p><ul><li>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。</li></ul></li></ul><blockquote><p>注意: HTTPS中整个握手过程第三方即使监听到了数据，也束手无策。</p></blockquote><h6 id="为什么HTTPS是安全的？"><a href="#为什么HTTPS是安全的？" class="headerlink" title="为什么HTTPS是安全的？"></a>为什么HTTPS是安全的？</h6><blockquote><p>在HTTPS握手的第四步中，如果站点的证书是不受信任的，会显示出现下面确认界面，确认了网站的真实性。另外第六和八步，使用客户端私钥加密解密，保证了数据传输的安全。</p></blockquote><hr><h3 id="app与后台通信完整流程"><a href="#app与后台通信完整流程" class="headerlink" title="app与后台通信完整流程"></a>app与后台通信完整流程</h3><ul><li>1.建立连接：前台后台建立连接。 </li><li>2.发送请求：打开连接后，app向后台发送请求。</li><li>3.发送响应：后台处理完请求后，要向app发送响应消息。 <ul><li>后台通过关键词：路径映射，Dispatcher分发机制等方式处理app的请求</li></ul></li><li>4.断开连接：以上交互完成后可以断开连接了。</li></ul><h3 id="浏览器执行过程"><a href="#浏览器执行过程" class="headerlink" title="浏览器执行过程"></a>浏览器执行过程</h3><ul><li>1.首先嘛，你得在浏览器里输入要网址:</li><li>2.浏览器查找域名的IP地址</li><li>3.浏览器给web服务器发送一个HTTP请求</li><li>4.facebook服务的永久重定向响应.服务器给浏览器响应一个301永久重定向响应，这样浏览器就会问“<a href="http://www.facebook.com/”" target="_blank" rel="noopener">http://www.facebook.com/”</a> 而非“<a href="http://facebook.com/”。" target="_blank" rel="noopener">http://facebook.com/”。</a></li><li>5.浏览器跟踪重定向地址.浏览器知道了“<a href="http://www.facebook.com/”才是要访问的正确地址，所以它会发送另一个获取请求：" target="_blank" rel="noopener">http://www.facebook.com/”才是要访问的正确地址，所以它会发送另一个获取请求：</a></li><li>6.服务器“处理”请求.服务器接收到获取请求，然后处理并返回一个响应。</li><li>7.服务器发回一个HTML响应.</li><li>8.浏览器开始显示HTML.</li><li>9.浏览器发送获取嵌入在HTML中的对象。在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。</li><li>10.浏览器发送异步（AJAX）请求。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;超文本传输协议（HTTP，HyperText Transfer Protocol)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HTTPS句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。&lt;/p&gt;
    
    </summary>
    
      <category term="Others" scheme="https://icocos.github.io/categories/Others/"/>
    
    
      <category term="开发" scheme="https://icocos.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="HTTP+HTTPS" scheme="https://icocos.github.io/tags/HTTP-HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>iOS(OC+cocos2dx)游戏APP磁盘空间爆增(文稿与数据)</title>
    <link href="https://icocos.github.io/2018/08/16/iOS-OC-cocos2dx-%E6%B8%B8%E6%88%8FAPP%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E7%88%86%E5%A2%9E-%E6%96%87%E7%A8%BF%E4%B8%8E%E6%95%B0%E6%8D%AE/"/>
    <id>https://icocos.github.io/2018/08/16/iOS-OC-cocos2dx-游戏APP磁盘空间爆增-文稿与数据/</id>
    <published>2018-08-16T15:45:06.000Z</published>
    <updated>2018-08-17T01:53:47.674Z</updated>
    
    <content type="html"><![CDATA[<p>这段时间在开发公司的新产品二次元游戏(<a href="https://zhongchou.modian.com/item/26767.html?_ga=2.202445201.1279037149.1534326302-1820221530.1531384229" target="_blank" rel="noopener">零下记忆</a>)，由于接触coco2dx不久，很多东西还在摸索，也没少加班，所以都没有时间整理和发文了。</p><p>但是最近(从周一开始),发现了一个特别其他的Bug，App磁盘数据报增，幸好我手机是64G的，不然估计会爆炸！</p><p>先来张爆图！</p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/cocos2dx/data/cocos2dx_data001.png" alt="曹理鹏(iCocos)-梦工厂"></p><a id="more"></a><p>这个产品是在Objective-C原生架构的基础上接入cocos2dx(C++)，所以导致部分文件或者类需要使用MRC模式。</p><h5 id="我曾尝试过"><a href="#我曾尝试过" class="headerlink" title="我曾尝试过"></a>我曾尝试过</h5><ol><li>使用模拟器针对不同时段操作，计算沙盒文件大小。</li><li>借助部门同事的越狱机导包寻找导致爆增的具体文件。</li><li>多次删除App，关闭可能存在问题原因的代码。</li><li>借助内存泄漏框架自动记录，内存变化与位置。</li><li>借助Xcode自带Instrument定点查找具体位置和代码。</li><li>通过Stack Overflow查询更多可能导致的原因。</li></ol><p>经过一次次排查，和一个个问题的处理，最终通过多次杀进程，和运行测试，终于处理完成，不过还有待优化！ </p><h6 id="下面是具体原因和流程。"><a href="#下面是具体原因和流程。" class="headerlink" title="下面是具体原因和流程。"></a>下面是具体原因和流程。</h6><h3 id="清理缓存："><a href="#清理缓存：" class="headerlink" title="清理缓存："></a>清理缓存：</h3><h5 id="清理cocos2dx缓存："><a href="#清理cocos2dx缓存：" class="headerlink" title="清理cocos2dx缓存："></a>清理cocos2dx缓存：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CCAnimationCache::purgeSharedAnimationCache();</span><br><span class="line">CCSpriteFrameCache::purgeSharedSpriteFrameCache();</span><br><span class="line">CCTextureCache::purgeSharedTextureCache();</span><br><span class="line">    </span><br><span class="line">CCSpriteFrameCache::sharedSpriteFrameCache()-&gt;removeUnusedSpriteFrames();</span><br><span class="line">CCTextureCache::sharedTextureCache()-&gt;removeUnusedTextures();</span><br><span class="line">CCTextureCache::sharedTextureCache()-&gt;removeAllTextures();</span><br><span class="line"></span><br><span class="line">Director::getInstance()-&gt;getTextureCache()-&gt;removeAllTextures();</span><br></pre></td></tr></table></figure><h5 id="清理运行磁盘，内存或者缓存"><a href="#清理运行磁盘，内存或者缓存" class="headerlink" title="清理运行磁盘，内存或者缓存"></a>清理运行磁盘，内存或者缓存</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">+ (void)clearAllCache &#123;</span><br><span class="line">    [[SDImageCache sharedImageCache] clearMemory];</span><br><span class="line">    [[SDImageCache sharedImageCache] clearDiskOnCompletion:nil];</span><br><span class="line">    // 拿到cachePath路径的下一级目录的子文件夹</span><br><span class="line">    // contentsOfDirectoryAtPath:error:递归</span><br><span class="line">    // subpathsAtPath:不递归</span><br><span class="line">    NSArray *subpathArray = [fileManager contentsOfDirectoryAtPath:cachePath error:nil];</span><br><span class="line">    // 如果数组为空，说明没有缓存或者用户已经清理过，此时直接<span class="built_in">return</span></span><br><span class="line">    <span class="keyword">if</span> (subpathArray.count == 0) &#123;</span><br><span class="line"><span class="comment">#ifdef DEBUG</span></span><br><span class="line">        NSLog(@<span class="string">"cachePath缓存清理完成"</span>);</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">    &#125;</span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    NSString *filePath = nil;</span><br><span class="line">    BOOL flag = NO;</span><br><span class="line">    <span class="keyword">for</span> (NSString *subpath <span class="keyword">in</span> subpathArray) &#123;</span><br><span class="line">        filePath = [cachePath stringByAppendingPathComponent:subpath];</span><br><span class="line">        <span class="keyword">if</span> ([fileManager fileExistsAtPath:cachePath]) &#123;</span><br><span class="line">            // 删除子文件夹</span><br><span class="line">            BOOL isRemoveSuccessed = [fileManager removeItemAtPath:filePath error:&amp;error];</span><br><span class="line">            <span class="keyword">if</span> (isRemoveSuccessed) &#123; // 删除成功</span><br><span class="line">                flag = YES;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (NO == flag) &#123;</span><br><span class="line"><span class="comment">#ifdef DEBUG</span></span><br><span class="line">        NSLog(@<span class="string">"已经清理了所有可以访问的文件,不可访问的文件无法删除"</span>);  // 调试阶段才打印</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>记忆中此处大概处理了1-3G</p></blockquote><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>通过Stack Overflow和相应代码调试最后发现：</p><blockquote><p>原来是把sprite和控件都retain了，需要手动release，才能释放图片。</p></blockquote><p>所以我得找到对应的cocos2dx项目代码，对创建和操作的对象进行release操作，这里比较蛋疼，得一个个找！</p><ul><li>处理中遇到个问题：<ul><li>removeTexture执行release后，不管有没有被gl释放掉，都从列表里删除。</li></ul></li></ul><p>但是如果load进来的node被addChild到场景中，应该是不需要retain的，addChild会自动retain，这里不清楚，cocos2dx引擎设计者在load里加retain是为了什么，</p><blockquote><p>这里所导致的问题，几乎是使用过程中内存暴涨</p></blockquote><h3 id="环境与配置-主要原因"><a href="#环境与配置-主要原因" class="headerlink" title="环境与配置(主要原因):"></a>环境与配置(主要原因):</h3><p>通过多次测试发现沙盒文件中的temp中有一堆文件stack-logs.xxxxx.index</p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/cocos2dx/data/cocos2dx_data002.png" alt="曹理鹏(iCocos)-梦工厂"></p><ul><li>同时控制台也打印了一大堆看不懂也搜不到的内容</li></ul><p><img src="http://pd1l3bbt7.bkt.clouddn.com/cocos2dx/data/cocos2dx_data003.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>结合以上几点才初步猜测可能是因为配置环境的问题，查阅资料后发现这与Xcode设置有关,具体配置原因我也不记得了，印象中是当时配置接入cocos2dx的时候，遇到了一些问题，点过了一次，但是现在想想好像当时的操作并没有什么卵用！</p><ul><li>Edit Scheme中Diagnostics有个logging分类，下面有个Malloc Stack选项，将勾选取消。</li></ul><p><img src="http://pd1l3bbt7.bkt.clouddn.com/cocos2dx/data/cocos2dx_data004.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>处理完后立刻验证了一下,重装App,多次执行杀进程和实际测试用，在tmp下并没有产生那个文件stack-logs.xxxxx.index,磁盘占用也处于稳定状态,再打开手机设置查看存储空间，也很正常。</p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/cocos2dx/data/cocos2dx_data005.png" alt="曹理鹏(iCocos)-梦工厂"></p><blockquote><p>以上文稿与数据的15.7中有13M多属于App下载的资源文件。</p></blockquote><p>That’s all for today.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这段时间在开发公司的新产品二次元游戏(&lt;a href=&quot;https://zhongchou.modian.com/item/26767.html?_ga=2.202445201.1279037149.1534326302-1820221530.1531384229&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;零下记忆&lt;/a&gt;)，由于接触coco2dx不久，很多东西还在摸索，也没少加班，所以都没有时间整理和发文了。&lt;/p&gt;
&lt;p&gt;但是最近(从周一开始),发现了一个特别其他的Bug，App磁盘数据报增，幸好我手机是64G的，不然估计会爆炸！&lt;/p&gt;
&lt;p&gt;先来张爆图！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pd1l3bbt7.bkt.clouddn.com/cocos2dx/data/cocos2dx_data001.png&quot; alt=&quot;曹理鹏(iCocos)-梦工厂&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS游戏" scheme="https://icocos.github.io/categories/iOS%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="iOS游戏" scheme="https://icocos.github.io/tags/iOS%E6%B8%B8%E6%88%8F/"/>
    
      <category term="磁盘管理" scheme="https://icocos.github.io/tags/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>游戏引擎——cocos2dx入门</title>
    <link href="https://icocos.github.io/2018/08/09/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94cocos2dx%E5%85%A5%E9%97%A8/"/>
    <id>https://icocos.github.io/2018/08/09/游戏引擎——cocos2dx入门/</id>
    <published>2018-08-09T12:40:17.000Z</published>
    <updated>2018-09-14T13:26:51.595Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><blockquote><p>Cocos2d-x是一个开源的移动2D游戏框架，MIT许可证下发布的。这是一个C++ Cocos2d-iPhone项目的版本。Cocos2d-X发展的重点是围绕Cocos2d跨平台，Cocos2d-x提供的框架。手机游戏，可以写在C++或者Lua中，使用API是Cocos2d-iPhone完全兼容。Cocos2d-x项目可以很容易地建立和运行在iOS，Android，黑莓Blackberry等操作系统中。Cocos2d-x还支持Windows、Mac和Linux等桌面操作系统，因此，开发者编写的源代码很容易在桌面操作系统中编辑和调试。</p></blockquote><h4 id="cocos2dx-与-UNITY3D"><a href="#cocos2dx-与-UNITY3D" class="headerlink" title="cocos2dx 与 UNITY3D"></a>cocos2dx 与 UNITY3D</h4><a id="more"></a><p>一、区别:</p><ul><li>1、COCOS2D开源,有文档支持,论坛资料庞杂博大；UNITY3D闭源,有强大的文档支持,论坛资料一样的庞杂博大。</li><li>2、COCOS2D免费；UNITY3D收费。</li><li>3、COCOS2D的跨平台,需要大量重写代码；UNITY3D的跨平台,程序员只需要选选按钮就淡定许多的搞定了。</li></ul><p>二、拓展:</p><ul><li>1、不同:<ul><li>COCOS2D拥有令人发指的可定制性；UNITY3D有一个专门为订制而写的类库。</li></ul></li><li>2、相同:<ul><li>UNITY3D和 COCOS2D-X都是跨平台的游戏开发引擎。</li></ul></li></ul><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>现代化的 C++ API</li><li>立足于 C++ 同时支持 JavaScript/Lua 作为开发语言</li><li>可以跨平台部署, 支持 iOS、Android、Windows、macOS 和 Linux</li><li>可以在 PC 端完成游戏的测试，最终发布到移动端</li><li>完善的游戏功能支持，包含精灵、动作、动画、粒子特效、场景转换、事件、文件 IO、数据持久化、骨骼动画、3D</li></ul><h4 id="家族成员"><a href="#家族成员" class="headerlink" title="家族成员"></a>家族成员</h4><blockquote><p>cocos2d是一个基于MIT协议的开源框架，用于构建游戏、应用程序和其他图形界面交互应用。可以让你在创建自己的多平台游戏时节省很多的时间。</p></blockquote><h6 id="Cocos2d-html5-："><a href="#Cocos2d-html5-：" class="headerlink" title="Cocos2d-html5 ："></a>Cocos2d-html5 ：</h6><ul><li>Cocos2d-HTML5 是基于 HTML5 规范集的 Cocos2d引擎分支，具有跨平台的能力和强大的性能，是 Cocos2d 系列引擎随着互联网技术演进而产生的一个分支，该分支基于 HTML5 规范集，目标是可对游戏进行跨平台部署，Cocos2d-HTML5 采用 MIT 开源协议，设计上保持Cocos2d家族的传统架构，并可联合 Cocos2d-x JavaScript-binding 接口，最大程度地实现游戏代码在不同平台上的复用。</li></ul><h6 id="JSB-："><a href="#JSB-：" class="headerlink" title="JSB ："></a>JSB ：</h6><ul><li>Cocos2d-x JavaScript-binding 是使用 SpiderMonkey 引擎实现 C++ 接口到 JavaSciprt 的绑定方案，它可以使用 Js 快速开发游戏，以更简单的语法实现功能，并且能与 Cocos2D-HTML5 相互兼容，使同一套代码，运行两个平台，这是相比使用 Lua 实现的一个明显优势。</li></ul><h6 id="Cocos-Studio-："><a href="#Cocos-Studio-：" class="headerlink" title="Cocos Studio ："></a>Cocos Studio ：</h6><ul><li>Cocos Studio 是一套基于 Cocos2d-x 引擎的工具集，包括 UI编辑器，动画编辑器，场景编辑器和数据编辑器。 UI 编辑器和动画编辑器主要面向美术，而场景编辑器和数据编辑器则面向游戏策划，这四个工具合在一起构成了一套完整的游戏开发体系，帮助开发者进一步降低开发难度，提高开发效率，减少开发成本。</li></ul><p>Cocos2d也拥有几个主要版本，包括Cocos2d-iPhone、Cocos2d-X，以及被社区普遍看好的Cocos2d-HTML5和JavaScript bindings for Cocos2d-X。</p><h4 id="关于lua，c-，JS"><a href="#关于lua，c-，JS" class="headerlink" title="关于lua，c++，JS"></a>关于lua，c++，JS</h4><p>允许开发人员使用 C++、Javascript 及 Lua 三种语言来进行游戏开发。</p><blockquote><p>支持所有常见平台，包括 iOS、Android、Windows、macOS、Linux。</p></blockquote><ol><li><p>运行效率：</p><blockquote><p>Lua 的性能在各种测试里都比 JavaScript 快不少。而移动设备上存在不支持 JIT 的情况（未越狱的 iOS 设备），Lua 对比 JavaScript 的性能优势就更明显。</p></blockquote></li><li><p>安全性：</p><blockquote><p>现在 cocos2d-x 使用 LuaJIT 来执行 Lua，所以可以把 Lua 代码编译为字节码再打包到游戏里。由于 LuaJIT 的字节码是高度优化过的，所以目前还没有反编译工具。而 JS 虽然也可以用字节码，但从目前的情况看还达不到 LuaJIT 的安全性。</p></blockquote></li><li><p>与 C/C++ 的交互：</p><blockquote><p>Lua 原本就是作为嵌入式语言来设计的，所以天然和 C/C++ 很容易交互。JS 这方面是个劣势。</p></blockquote></li><li><p>与 Java/Objective-C 的交互：</p><blockquote><p>不管是 quick-cocos2d-x 里提供的 luaoc/luaj 模块，还是 wax, luajava 这些开源项目，都让我们可以绕过 C/C++ 层实现 Lua 和 Java/Objc 的交互。这个优势在游戏发行阶段，集成各种第三方 SDK 时绝对会节约巨量时间！！！</p></blockquote></li></ol><p>游戏是非常消耗资源的每时每刻都要大量的计算，</p><ul><li>假如有个方法 让 C语言来实现 并且把它完成的时间定义为 1个单位 的时间</li><li>那么同样的数据结构的方法在其他语言中     <ul><li>java 需要 8个单位       </li><li>lua需要30个单位       </li><li>python需要200个单位       </li><li>php需要462个单位       </li><li>javascript需要621个单位</li></ul></li></ul><p>所以在需要大量计算的环节，代码的结构时间复杂度比较高的 情况下用 C++（肯没直接用C快，但一定比java快）来写，   现在的CPU计算能力都还是蛮高的，所以没必要完全用C++ ，用一些其他的语言开发速度可以大大加快。 </p><h6 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h6><ul><li>项目不需要热更新的时候用c++</li><li>lua，c++都可以用的时候c++更熟悉的用c++</li><li>c++效率比lua高</li><li>lua项目的底层框架还是要c++搭比较好</li><li>c++老司机转其他语言比较轻松。</li></ul><p>最终使用那种方式还是需要结合个人，语言，需求，性能综合考虑</p><ul><li>当然，cocos2d-x 目前明显是在主推 JS 的解决方案，因为 JS 可以跨越移动设备、桌面的界限，实现一套程序跑任意平台。不过我个人认为以当前 HTML5 的发展情况，对于要强调体验的游戏来说，HTML5 还要一些时间。</li></ul><blockquote><p>网友评价：<br>前面提到 JS 更容易面向对象，我想可能是因为大家对 Lua 还不够了解造成的错觉。实际上，Lua 和 JS 实现面向对象的机制几乎是一样的。JS 基于 prototype，Lua 基于 metatable，在我看来仅仅是名字不同而已。</p></blockquote><p>从目前的市场情况来说，Lua 明显是更理性的选择：成熟、安全性高、众多大作采用。</p><ul><li>推荐<ul><li>官方文档：<a href="http://www.cocos2d-x.org/docs/cocos2d-x/zh/about/learn.html" target="_blank" rel="noopener">http://www.cocos2d-x.org/docs/cocos2d-x/zh/about/learn.html</a></li><li>OC/Swift - C++交互与混编:<a href="http://edu.51cto.com/center/course/lesson/index?id=57316" target="_blank" rel="noopener">http://edu.51cto.com/center/course/lesson/index?id=57316</a></li><li>入门实战-飞机大战游戏：<a href="http://www.maiziedu.com/course/662-9914/" target="_blank" rel="noopener">http://www.maiziedu.com/course/662-9914/</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Cocos2d-x是一个开源的移动2D游戏框架，MIT许可证下发布的。这是一个C++ Cocos2d-iPhone项目的版本。Cocos2d-X发展的重点是围绕Cocos2d跨平台，Cocos2d-x提供的框架。手机游戏，可以写在C++或者Lua中，使用API是Cocos2d-iPhone完全兼容。Cocos2d-x项目可以很容易地建立和运行在iOS，Android，黑莓Blackberry等操作系统中。Cocos2d-x还支持Windows、Mac和Linux等桌面操作系统，因此，开发者编写的源代码很容易在桌面操作系统中编辑和调试。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;cocos2dx-与-UNITY3D&quot;&gt;&lt;a href=&quot;#cocos2dx-与-UNITY3D&quot; class=&quot;headerlink&quot; title=&quot;cocos2dx 与 UNITY3D&quot;&gt;&lt;/a&gt;cocos2dx 与 UNITY3D&lt;/h4&gt;
    
    </summary>
    
      <category term="cocos2dx" scheme="https://icocos.github.io/categories/cocos2dx/"/>
    
    
      <category term="cocos2dx" scheme="https://icocos.github.io/tags/cocos2dx/"/>
    
      <category term="游戏" scheme="https://icocos.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>初识游戏——cocos2dx初探</title>
    <link href="https://icocos.github.io/2018/06/15/%E5%88%9D%E8%AF%86%E6%B8%B8%E6%88%8F%E2%80%94%E2%80%94cocos2dx%E5%88%9D%E6%8E%A2/"/>
    <id>https://icocos.github.io/2018/06/15/初识游戏——cocos2dx初探/</id>
    <published>2018-06-15T15:49:12.000Z</published>
    <updated>2018-08-06T18:33:42.291Z</updated>
    
    <content type="html"><![CDATA[<p>前端时间一直在忙项目，也提到了关于是一个AVG游戏项目，近期由于最新需求，需要开发iOS 游戏，之前做了这么久一直没有感觉到真正游戏或者游戏开发的存在，这一次，好像真的要步入游戏开发了。</p><p>所以整理了一下。</p><a id="more"></a><blockquote><p>具体概念和基本使用就不做介绍了，因为那些都太枯燥了，这里先说说整个环境搭建（以Mac为例），然后根据实际开发整理一些有意义的东西</p></blockquote><h5 id="先来看看官方"><a href="#先来看看官方" class="headerlink" title="先来看看官方"></a>先来看看官方</h5><p><a href="http://docs.cocos.com/cocos2d-x/manual/zh/" target="_blank" rel="noopener">http://docs.cocos.com/cocos2d-x/manual/zh/</a></p><h2 id="搭建开发环境-iOS"><a href="#搭建开发环境-iOS" class="headerlink" title="搭建开发环境 - iOS"></a>搭建开发环境 - iOS</h2><h4 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h4><pre><code>Cocos2d-x v3.17，下载后解压，下载参见：Cocos官网页面:http://www.cocos.com/downloadXcode 9 下载后安装，下载参见：Apple官网页面;https://developer.apple.com/download/more/或者前往App Store下载</code></pre><h4 id="配置步骤："><a href="#配置步骤：" class="headerlink" title="配置步骤："></a>配置步骤：</h4><ul><li><p>打开 cocos2d-x-3.17/build/cocos2d_tests.xcodeproj</p></li><li><p>在 Xcode 顶部工具栏选择 cpp-tests iOS，iPhone 7 Plus，点击运行，项目将自动编译运行，效果如图：</p></li></ul><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/000001.png" alt="曹理鹏(iCocos)-梦工厂"></p><h4 id="如何调试-Debug"><a href="#如何调试-Debug" class="headerlink" title="如何调试(Debug)"></a>如何调试(Debug)</h4><ul><li>点击代码行左侧的空白，设置断点</li><li>运行 cpp-tests</li></ul><p>操作 App 触发断点，IDE 将卡在断点处，视图会自动变化，左侧导航栏可以查看运行堆栈，底部窗口可以查看变量的值：</p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/000002.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>这里严格来说，其实不算是环境搭建，而是下载引擎，运行官方demo而已，那么下面我们开始简单的搭建一个实际项目，并后续从零开始做一个真正的游戏</p><h2 id="实际开发配置"><a href="#实际开发配置" class="headerlink" title="实际开发配置"></a>实际开发配置</h2><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><pre><code>登录Cocos2d-x 的官网 http://www.cocos2d-x.org点击download 下载最新的版本</code></pre><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/000003.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>点击超链接，将会下载得到一个Cocos2d-x-3.17.zip 压缩包</p><pre><code>将下载的压缩包进行解压，打开得到的文件夹，其结构目录如下</code></pre><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/000004.png" alt="曹理鹏(iCocos)-梦工厂"></p><ul><li>build :多平台下的架构文件存放的目录</li><li>cocos 框架核心目录 里面存放了Cocos2d-x的核心代码。</li><li>docs：文档目录 可以使用该目录下的doxygen.config 文件创建离线文档</li><li>extensions:扩展目录 存放了一些官方的扩展 包括更多图形用户界面的控制功能 网络访问 CocosBuilder 等</li><li>external：存放扩展需要用到的物理引擎 包括box2d和chipmunk</li><li>licenses: cocos2d依赖很多开源项目，所有的授权许可文件都在这个目录</li><li>plugin:plugin-x 项目目录，plugin -x  是一个可以快速接入第三方idk的框架</li><li>templates：该目录包括在不同集成环境及不同平台中创建Cocos2d-x 新项目的模板</li><li>test：测试项目 这是我们最开始用到的文件 在 cpp-tests 项目中包含所有类的用法 lua 和js 样本也在这个目录</li><li>tools： 需要用到的工具 Cocos2d-console 目录中包含了创建Cocos2d-x项目的脚本 可以针对不同的平台进行开发环境的搭建 同时 还包括将c++绑定至lua 及JavaScript 的脚本文件</li></ul><h4 id="Cocos2d-x的安装和配置"><a href="#Cocos2d-x的安装和配置" class="headerlink" title="Cocos2d-x的安装和配置"></a>Cocos2d-x的安装和配置</h4><p>Cocos2d-x 从2.1.4 版 之后已经不再支持使用模板来生成项目 而是使用官方提供的python 直接创建项目 也就是说Cocos2d-x 不能安装到Xcode上面，不能使用Xcode的Cocos2d-x模板一步一步的生成项目，只能使用Xcode来打开已经创建好的项目</p><h4 id="创建项目的步骤如下："><a href="#创建项目的步骤如下：" class="headerlink" title="创建项目的步骤如下："></a>创建项目的步骤如下：</h4><ul><li>打开终端 进入Cocos2d-x3.14 目录执行./setup.py  运行该文件用来 配置系统的一些环境变量</li></ul><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/000005.png" alt="曹理鹏(iCocos)-梦工厂"></p><ul><li>打开终端 执行Cocos new HelloCpp -p org.cocos2dx -l cpp -d codes</li></ul><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/000006.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>如果一切正常 则项目创建成功 关闭终端 再次进入Cocos2d-3.14目录这时候 会发现新建的codes目录</p><p>进入该目录发现新建的HelloCpp项目 进入proj.ios_mac 双击HelloCPP.xcodeproj 文件 使用快捷键（command+run）运行程序 就可以在iOS模拟器上看到经典的hello world 画面</p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/000007.png" alt="曹理鹏(iCocos)-梦工厂"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端时间一直在忙项目，也提到了关于是一个AVG游戏项目，近期由于最新需求，需要开发iOS 游戏，之前做了这么久一直没有感觉到真正游戏或者游戏开发的存在，这一次，好像真的要步入游戏开发了。&lt;/p&gt;
&lt;p&gt;所以整理了一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://icocos.github.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="https://icocos.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
      <category term="cocos2dx初探" scheme="https://icocos.github.io/tags/cocos2dx%E5%88%9D%E6%8E%A2/"/>
    
  </entry>
  
  <entry>
    <title>Golang——groutine和channel底层机制</title>
    <link href="https://icocos.github.io/2018/06/12/Golang%E2%80%94%E2%80%94groutine%E5%92%8Cchannel%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6/"/>
    <id>https://icocos.github.io/2018/06/12/Golang——groutine和channel底层机制/</id>
    <published>2018-06-12T15:49:12.000Z</published>
    <updated>2018-08-06T17:26:22.420Z</updated>
    
    <content type="html"><![CDATA[<p>goroutine, channel其实可以认为是golang中runtime的一部分，当然golang的runtime还包含Garbage collection，内存分配，垃圾回收，interfaces, maps,slices等一些高级功能</p><a id="more"></a><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><blockquote><p>我们知道Golang系统默认支持原始并发(加入协程与管道)，不想其他语言一样，需要写一堆的代码，还没有几个能写好的。</p></blockquote><p>Golang使用Groutine和channels实现了CSP(Communicating Sequential Processes)模型，channles负责goroutine通信。</p><h3 id="goroutinue"><a href="#goroutinue" class="headerlink" title="goroutinue"></a>goroutinue</h3><p>goroutine是Golang实现的用户空间的轻量级的线程，有runtime调度器调度，与操作系统的thread有多对一的关系</p><ul><li>goroutinue，本质上就是协程。但有两点不同：<ul><li>1.goroutinue可以实现并行，多个协程可以在多个处理器同时跑。而协程同一时刻只能在一个处理器上跑（把宿主语言想象成单线程的就好了）。</li><li>2.goroutine之间的通信是通过channel，而协程的通信是通过yield和resume()操作。</li></ul></li></ul><h4 id="goroutine-scheduler"><a href="#goroutine-scheduler" class="headerlink" title="goroutine scheduler"></a>goroutine scheduler</h4><p>goroutine scheduler 是Go runtime的一个重要的组成部分。他负责追踪，调度每个goroutine运行，实际上是从应用程序的process所属的thread pool中分配一个thread来执行这个goroutine。因此，和java虚拟机中的Java thread和OS thread映射概念类似，每个goroutine只有分配到一个OS thread才能运行。</p><h3 id="Chanel"><a href="#Chanel" class="headerlink" title="Chanel"></a>Chanel</h3><p>Channel是Go中的一个核心类型，你可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication)</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul><li>ch := make(chan Task, 3) // hchan（src/runtime/chan.go）</li></ul><p>创建channel时在该进程的heap申请一块内存，创建一个hchan结构体，返回执行该内存的指针(ch变量本身是一个指针，在函数间传递的时候是同一个channel)</p><p>channel使用一个唤醒队列保存groutine之间传递的数据，使用两个list保存goroutine(向该chan发生数据，从该chan接受数据),还有一个mutex保证操作安全</p><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><p>M是操作系统的线程，G是用户启动的goroutine，P是与调度相关的context，每个M都拥有一个P，P维护了一个能够运行的goutine队列，用于该线程执行。</p><h4 id="发生接受数据"><a href="#发生接受数据" class="headerlink" title="发生接受数据"></a>发生接受数据</h4><p>向channel发送和从channel接收数据主要涉及hchan里的四个成员变量</p><pre><code>buf(指向dataqsiz元素的数组)，sendx，recvx，lock(锁定保护HCHA中的所有字段)</code></pre><ul><li>初始化的时候hchan中buf为空，sendx，recvx为0：</li><li>向chan发生数据的时候，会对buf加锁，然后将要发生的数据copy到buf中，并sendx+1，最后释放buf的锁。</li><li>从chan接受数据的时候，会对buf加锁，然后将buf里面的数据copy到变量对应的内存，并recvx+1，最后释放buf的锁。</li></ul><p>底层通过hchan中的buf，使用copy内存的方式通讯，达到共享内存目的</p><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><ul><li>当想已满的chan发生数据，runtime检测到对应的hchan已经满了，会通知调度器，调度器将发送至置为waiting，移除与线程M的关系，<br>然后从P的runqueue中选择一个goroutine在线程M中执行，此时发送者处于阻塞状态，但是操作系统线程非阻塞，所以只消耗少量资源。</li><li>发送者阻塞后会创建一个自己的结构体sudog，然后放到sendq(发送阻塞列表：保存channel相关变量的指针，如发送或者接收数据的变量的地址&amp;copy)</li><li>从chan接收数据时，会通知调度器，将发送者状态设置为runnable，并且将其加入P的runqueue，等待线程执行</li></ul><blockquote><p>注意：如果接受者先运行，那么他会从一个空的chanl中取数据，这个时候会直接阻塞，通发送者阻塞一样，也会创建一个自己的结构体sudog，保存接收数据的变量的地址，<br>但是该sudog不是放在recvq(接收阻塞列表)，当再想chan发送数据的时候，runtime辟谷没有对hchan中buf加锁，而是直接将发送的数据copy到接收者的结构体sudog对应的elem指向的内存地址</p></blockquote><h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><p>goroutine, channel其实可以认为是golang中runtime的一部分，当然golang的runtime还包含Garbage collection，内存分配，垃圾回收，interfaces, maps,slices等一些高级功能</p><blockquote><p>1.4之前，runtime还是由C语言所编写的，官方计划，1.5版本将去除C的代码，runtime将完全由Go语言来完成，不论何种方式，runtime和用户编译后的代码被linker静态链接起来，形成一个可执行文件。这个文件从操作系统角度来说是一个user space的独立的可执行文件。</p></blockquote><p>从运行的角度来说，这个文件由2部分组成，一部分是用户的代码，另一部分就是runtime。runtime通过接口函数调用来管理goroutine, channel及其他一些高级的功能。从用户代码发起的调用操作系统API的调用都会被runtime拦截并处理。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><blockquote><p>goroutine的调度器是在线程之上的多路复用。channel的实现是仅仅的关联在调度器之上，compiler也是紧密的和goroutine调度器关联在一起，不仅仅创建goroutine，而且也管理着stack，防止stack溢出。goroutine是一个执行的stack+一个控制的struct。调度器分配goroutine在线程上执行，当一个线程阻塞了或者调用一个非Go的函数(CGO调用)，那么调度器就会开始一个新的线程来运行其他的goroutine.</p></blockquote><ul><li>推荐文章<ul><li><a href="https://blog.csdn.net/whatday/article/details/74453089" target="_blank" rel="noopener">https://blog.csdn.net/whatday/article/details/74453089</a></li><li><a href="https://blog.csdn.net/kongdefei5000/article/details/75209005" target="_blank" rel="noopener">https://blog.csdn.net/kongdefei5000/article/details/75209005</a></li><li><a href="https://www.zhihu.com/question/20862617" target="_blank" rel="noopener">https://www.zhihu.com/question/20862617</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;goroutine, channel其实可以认为是golang中runtime的一部分，当然golang的runtime还包含Garbage collection，内存分配，垃圾回收，interfaces, maps,slices等一些高级功能&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://icocos.github.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="https://icocos.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
      <category term="groutine和channel底层机制" scheme="https://icocos.github.io/tags/groutine%E5%92%8Cchannel%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Golang——Http服务初探</title>
    <link href="https://icocos.github.io/2018/06/07/Golang%E2%80%94%E2%80%94Http%E6%9C%8D%E5%8A%A1%E5%88%9D%E6%8E%A2/"/>
    <id>https://icocos.github.io/2018/06/07/Golang——Http服务初探/</id>
    <published>2018-06-07T15:49:12.000Z</published>
    <updated>2018-08-06T18:33:42.537Z</updated>
    
    <content type="html"><![CDATA[<p>这里开始之前，先来说说golang中http服务的内部机制(所有其他库都是在此基础延伸)</p><a id="more"></a><p>这里开始之前，先来说说golang中http服务中三个重要的方法(所有其他库都是在此基础延伸)</p><ul><li>func Handle<ul><li>func Handle(pattern string, handler Handler)<blockquote><p>Handle registers the handler for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched.</p></blockquote></li></ul></li><li>func HandleFunc<ul><li>func HandleFunc(pattern string, handler func(ResponseWriter, *Request))<blockquote><p>HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched.</p></blockquote></li></ul></li><li>func ListenAndServe<ul><li>func ListenAndServe(addr string, handler Handler) error<blockquote><p>ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Handler is typically nil, in which case the DefaultServeMux is used.</p></blockquote></li></ul></li></ul><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>ListenAndServe是用于在指定的TCP 网络地址addr 进行监听，然后调用服务端处理程序来处理传入的连<br>接请求。该方法有两个参数：第一个参数addr 即监听地址；第二个参数表示服务端处理程序，<br>通常为空，这意味着服务端调用 http.DefaultServeMux 进行处理，而服务端编写的业务逻<br>辑处理程序 http.Handle() 或 http.HandleFunc() 默认注入 http.DefaultServeMux 中</p></blockquote><p>下面以三种不同的方式实现最Golang中基本的Http Server</p><h2 id="默认方式"><a href="#默认方式" class="headerlink" title="默认方式"></a>默认方式</h2><p> 默认handler，处理路由注册</p><pre><code>//===================================Http 1===================================//func Http_Server1() {    http.HandleFunc(&quot;/&quot;, sayServer1)    err := http.ListenAndServe(&quot;:8080&quot;, nil)    if err != nil {        panic(err)    }}func sayServer1(w http.ResponseWriter, r *http.Request) {    io.WriteString(w,&quot;sayServer1 Http Service&quot;)}</code></pre><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/1.png" alt="曹理鹏(iCocos)-梦工厂"></p><h2 id="自定义方式"><a href="#自定义方式" class="headerlink" title="自定义方式"></a>自定义方式</h2><p>自己实现hander，注册到max中，在注册路由</p><pre><code>//===================================Http 2===================================//func Http_Server2() {    mux := http.NewServeMux()    mux.Handle(&quot;/&quot;, &amp;myHanlder{})    mux.HandleFunc(&quot;/hello&quot;, sayServer2)    err := http.ListenAndServe(&quot;:8080&quot;, mux)    if err != nil {        panic(err)    }}type myHanlder struct{}func (*myHanlder) ServeHTTP(w http.ResponseWriter, r *http.Request) {    io.WriteString(w,&quot;Http Service: &quot;+ r.URL.String())}func sayServer2(w http.ResponseWriter, r *http.Request) {    io.WriteString(w,&quot;sayServer2 Http Service&quot;)}</code></pre><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/20.png" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/21.png" alt="曹理鹏(iCocos)-梦工厂"></p><h2 id="底层拓展方式"><a href="#底层拓展方式" class="headerlink" title="底层拓展方式"></a>底层拓展方式</h2><p>底层实现路由注册，多用户封装</p><pre><code>//===================================Http 3===================================//var mux map[string]func(http.ResponseWriter, *http.Request) // 路由指定func Http_Server3() {    server := http.Server{        Addr:&quot;:8080&quot;,        Handler:&amp;mHandler{},        ReadTimeout:5*time.Second,    }     注册    mux = make(map[string]func(http.ResponseWriter, *http.Request))    mux[&quot;/hello&quot;] = sayServer3    mux[&quot;/golang&quot;] = golang    err := server.ListenAndServe()    if err != nil {        panic(err)    }}type mHandler struct {}func (*mHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {    if h,ok := mux[r.URL.String()]; ok {        h(w,r)        return    }    io.WriteString(w,&quot;Http Service Custome: &quot;+ r.URL.String())}func sayServer3(w http.ResponseWriter, r *http.Request) {    io.WriteString(w,&quot;sayServer3 Http Service&quot;)}func golang(w http.ResponseWriter, r *http.Request) {    io.WriteString(w,&quot;golang Http Service&quot;)}</code></pre><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/30.png" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/31.png" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/32.png" alt="曹理鹏(iCocos)-梦工厂"></p><h2 id="Beego你好世界"><a href="#Beego你好世界" class="headerlink" title="Beego你好世界"></a>Beego你好世界</h2><p>其实上面只是作为个简单的入门了解，一般实际开发中，那么做的还是不多，我们大部分都会选择使用第三方，比如PHP中的ThinkPHP，Yii，在Golang中也有几个不错的第三个可以使用，而且目前已经很成熟了，至少可以满足目前几乎大部分公司的业务需求<br>比如beego(国人开发)，gin，dotweb，echo这些都是笔者通过技术群或者网络热门程度了解到在Golang中还不错的的库，而且使用中和非常多。</p><p>这里我简单以beego作为案例尝试下，没有什么技术含量，勿喷</p><h4 id="下载安装-前提：配置GOPATH"><a href="#下载安装-前提：配置GOPATH" class="headerlink" title="下载安装(前提：配置GOPATH)"></a>下载安装(前提：配置GOPATH)</h4><pre><code>go get github.com/astaxie/beego</code></pre><h4 id="创建文件-hello-go"><a href="#创建文件-hello-go" class="headerlink" title="创建文件 hello.go"></a>创建文件 hello.go</h4><pre><code>//================================Hello World!!===============================//package mainimport &quot;github.com/astaxie/beego&quot;type HomeController struct {    beego.Controller}func (this *HomeController) Get() {    this.Ctx.WriteString(&quot;Hello World!!&quot;)}func Http_Hello() {    beego.Router(&quot;/&quot;, &amp;HomeController{})    beego.Run()}</code></pre><h4 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h4><pre><code>go build -o hello hello.go./hello</code></pre><h4 id="浏览效果"><a href="#浏览效果" class="headerlink" title="浏览效果"></a>浏览效果</h4><p>打开浏览器并访问 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/beego.png" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/0.png" alt="曹理鹏(iCocos)-梦工厂"></p><h2 id="关闭http服务"><a href="#关闭http服务" class="headerlink" title="关闭http服务"></a>关闭http服务</h2><p>在go1.8中新增了一个新特性，利用Shutdown(ctx context.Context) 优雅地关闭http服务。</p><p>Shutdown 将无中断的关闭正在活跃的连接，然后平滑的停止服务。处理流程如下：</p><pre><code>首先关闭所有的监听;然后关闭所有的空闲连接;然后无限期等待连接处理完毕转为空闲，并关闭;如果提供了 带有超时的Context，将在服务关闭前返回 Context的超时错误;</code></pre><p>利用这个特性改造一下v3版本的程序，实现一个关闭http的提示</p><pre><code>// 主动关闭服务器var server *http.Serverfunc main() {    // 一个通知退出的chan    quit := make(chan os.Signal)    signal.Notify(quit, os.Interrupt)    mux := http.NewServeMux()    mux.Handle(&quot;/&quot;, &amp;myHandler{})    mux.HandleFunc(&quot;/bye&quot;, sayBye)    server = &amp;http.Server{        Addr:         &quot;:1210&quot;,        WriteTimeout: time.Second * 4,        Handler:      mux,    }    go func() {        // 接收退出信号        &lt;-quit        if err := server.Close(); err != nil {            log.Fatal(&quot;Close server:&quot;, err)        }    }()    log.Println(&quot;Starting v3 httpserver&quot;)    err := server.ListenAndServe()    if err != nil {        // 正常退出        if err == http.ErrServerClosed {            log.Fatal(&quot;Server closed under request&quot;)        } else {            log.Fatal(&quot;Server closed unexpected&quot;, err)        }    }    log.Fatal(&quot;Server exited&quot;)}type myHandler struct{}func (*myHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {    w.Write([]byte(&quot;this is version 3&quot;))}// 关闭httpfunc sayBye(w http.ResponseWriter, r *http.Request) {    w.Write([]byte(&quot;bye bye ,shutdown the server&quot;))     // 没有输出    err := server.Shutdown(nil)    if err != nil {        log.([]byte(&quot;shutdown the server err&quot;))    }}</code></pre><p>尝试访问<a href="http://localhost:1210/bye" target="_blank" rel="noopener">http://localhost:1210/bye</a> 在控制台会得到以下提示结果，平滑关闭http服务成功:</p><p><a href="https://www.jianshu.com/p/be3d9cdc680b" target="_blank" rel="noopener">https://www.jianshu.com/p/be3d9cdc680b</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里开始之前，先来说说golang中http服务的内部机制(所有其他库都是在此基础延伸)&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://icocos.github.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="https://icocos.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Http服务初探" scheme="https://icocos.github.io/tags/Http%E6%9C%8D%E5%8A%A1%E5%88%9D%E6%8E%A2/"/>
    
  </entry>
  
  <entry>
    <title>Golang——文件IO处理</title>
    <link href="https://icocos.github.io/2018/06/03/Golang%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6IO%E5%A4%84%E7%90%86/"/>
    <id>https://icocos.github.io/2018/06/03/Golang——文件IO处理/</id>
    <published>2018-06-03T15:49:12.000Z</published>
    <updated>2018-08-06T18:33:42.532Z</updated>
    
    <content type="html"><![CDATA[<p>读写文件应该是在开发过程中经常遇到的，今天要跟大家一起分享的就是在golang的世界中，如何读写文件</p><a id="more"></a><p>读写文件应该是在开发过程中经常遇到的，今天简单看看golang的世界中，如何读写文件。</p><h3 id="读取文件方法速度比较"><a href="#读取文件方法速度比较" class="headerlink" title="读取文件方法速度比较"></a>读取文件方法速度比较</h3><pre><code>package mainimport (    &quot;bufio&quot;    &quot;fmt&quot;    &quot;io&quot;    &quot;io/ioutil&quot;    &quot;os&quot;    &quot;time&quot;)func read0(path string) string {    f, err := ioutil.ReadFile(path)    if err != nil {        fmt.Printf(&quot;%s\n&quot;, err)        panic(err)    }    return string(f)}func read1(path string) string {    fi, err := os.Open(path)    if err != nil {        panic(err)    }    defer fi.Close()    chunks := make([]byte, 1024, 1024)    buf := make([]byte, 1024)    for {        n, err := fi.Read(buf)        if err != nil &amp;&amp; err != io.EOF {        panic(err)    }    if 0 == n {        break    }        chunks = append(chunks, buf[:n]...)    }    return string(chunks)}func read2(path string) string {    fi, err := os.Open(path)    if err != nil {        panic(err)    }    defer fi.Close()    r := bufio.NewReader(fi)    chunks := make([]byte, 1024, 1024)    buf := make([]byte, 1024)    for {        n, err := r.Read(buf)        if err != nil &amp;&amp; err != io.EOF {            panic(err)        }        if 0 == n {            break        }        chunks = append(chunks, buf[:n]...)    }    return string(chunks)}func read3(path string) string {    fi, err := os.Open(path)    if err != nil {        panic(err)    }    defer fi.Close()    fd, err := ioutil.ReadAll(fi)    return string(fd)}func main() {    file := &quot;test.log&quot;    start := time.Now()    read0(file)    t0 := time.Now()    fmt.Printf(&quot;Cost time %v\n&quot;, t0.Sub(start))    read1(file)    t1 := time.Now()    fmt.Printf(&quot;Cost time %v\n&quot;, t1.Sub(t0))    read2(file)    t2 := time.Now()    fmt.Printf(&quot;Cost time %v\n&quot;, t2.Sub(t1))    read3(file)    t3 := time.Now()    fmt.Printf(&quot;Cost time %v\n&quot;, t3.Sub(t2))}</code></pre><p>运行结果对比：</p><pre><code>Cost time 4.0105msCost time 11.5043msCost time 7.0042msCost time 2.4983msCost time 4.4925msCost time 11.0053msCost time 5.0082msCost time 2.9992msCost time 3.9866msCost time 15.0085msCost time 7.5054msCost time 2.5035msCost time 4.9989msCost time 14.0112msCost time 7.5045msCost time 3.508msCost time 3.0043msCost time 15.0265msCost time 8.9884msCost time 2.0036ms</code></pre><h3 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h3><pre><code>//=================================== Files ===================================//func File_Server() {    mux := http.NewServeMux()    mux.Handle(&quot;/&quot;, &amp;fileHanlder{})    mux.HandleFunc(&quot;/hello&quot;, sayServer2)    wd, err := os.Getwd()    if err != nil {        panic(err)    }    mux.Handle(&quot;/static/&quot;, http.StripPrefix(&quot;/static/&quot;, http.FileServer(http.Dir(wd))))    err = http.ListenAndServe(&quot;:8080&quot;, mux)    if err != nil {        panic(err)    }}type fileHanlder struct{}func (*fileHanlder) ServeHTTP(w http.ResponseWriter, r *http.Request) {    io.WriteString(w,&quot;Http Service: &quot;+ r.URL.String())}func sayServer2(w http.ResponseWriter, r *http.Request) {    io.WriteString(w,&quot;sayServer2 Http Service&quot;)}</code></pre><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/file.png" alt="曹理鹏(iCocos)-梦工厂"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读写文件应该是在开发过程中经常遇到的，今天要跟大家一起分享的就是在golang的世界中，如何读写文件&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://icocos.github.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="https://icocos.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
      <category term="文件操作" scheme="https://icocos.github.io/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Go——Golang Response Snippets</title>
    <link href="https://icocos.github.io/2018/06/01/Go%E2%80%94%E2%80%94Golang-Response-Snippets/"/>
    <id>https://icocos.github.io/2018/06/01/Go——Golang-Response-Snippets/</id>
    <published>2018-06-01T15:49:12.000Z</published>
    <updated>2018-08-06T18:33:42.372Z</updated>
    
    <content type="html"><![CDATA[<p>做过后端开发的应该都知道，我们遇到最多的就是返回数据给客户端，就和客户端要搭界面一样，重复操作着，但是却有必不可少，今天我们来简单说说Golang Response Snippets</p><a id="more"></a><h5 id="Golang-Response-Snippets-JSON-XML-and-more"><a href="#Golang-Response-Snippets-JSON-XML-and-more" class="headerlink" title="Golang Response Snippets: JSON, XML and more"></a>Golang Response Snippets: JSON, XML and more</h5><blockquote><p>Taking inspiration from the Rails layouts and rendering guide, I thought it’d be a nice idea to build a snippet collection illustrating some common HTTP responses for Go web applications.</p></blockquote><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/response.png" alt="曹理鹏(iCocos)-梦工厂"></p><p><a href="https://www.alexedwards.net/blog/golang-response-snippets" target="_blank" rel="noopener">Golang Response Snippets</a></p><h2 id="只返回header"><a href="#只返回header" class="headerlink" title="只返回header"></a>只返回header</h2><p>对于一些请求而言，不需要返回任何的数据，只是返回一个header即可，大大提高了返回服务器响应速度。</p><p>先了解一下net/http包中的几个方法：</p><pre><code>//给一个key设定为响应的value.func (h Header) Set(key, value string)// WriteHeader该方法发送HTTP回复的头域和状态码。如果没有被显式调用，第一次调用Write时会触发隐式调用WriteHeader(http.StatusOK)。因此，显示调用WriterHeader主要用于发送错误状态码。WriteHeader(int) </code></pre><p>在使用的时候，我们可以这么做</p><pre><code>package mainimport (    &quot;net/http&quot;)func main() {    http.HandleFunc(&quot;/&quot;, foo)    http.ListenAndServe(&quot;:8080&quot;, nil)}func foo(w http.ResponseWriter, r *http.Request) {    w.Header().Set(&quot;Server&quot;, &quot;A Go Web Server&quot;)    w.WriteHeader(200)} </code></pre><h5 id="通过curl进行请求：curl-i-localhost-8080"><a href="#通过curl进行请求：curl-i-localhost-8080" class="headerlink" title="通过curl进行请求：curl -i localhost:8080"></a>通过curl进行请求：curl -i localhost:8080</h5><pre><code>curl -i localhost:8080HTTP/1.1 200 OKServer: A Go Web ServerDate: Mon, 29 Jan 2018 02:52:41 GMTContent-Length: 0Content-Type: text/plain; charset=utf-8 </code></pre><h2 id="返回文本"><a href="#返回文本" class="headerlink" title="返回文本"></a>返回文本</h2><p>这个不常用，但是也介绍一下而已。</p><p>用到的方法：</p><pre><code>// Write向连接中写入数据，该数据作为HTTP response的一部分。如果被调用时还没有调用WriteHeader，本方法会先调用WriteHeader(http.StatusOK)。//如果Header中没有&quot;Content-Type&quot;键，本方法会使用包函数DetectContentType检查数据的前512字节，将返回值作为该键的值Write([]byte) (int, error) </code></pre><h5 id="返回文本实际使用方法"><a href="#返回文本实际使用方法" class="headerlink" title="返回文本实际使用方法"></a>返回文本实际使用方法</h5><pre><code>package mainimport (    &quot;net/http&quot;)func main() {    http.HandleFunc(&quot;/&quot;, foo)    http.ListenAndServe(&quot;:8080&quot;, nil)}func foo(w http.ResponseWriter, r *http.Request) {    w.Write([]byte(&quot;I am Gopher&quot;))} </code></pre><h5 id="通过curl进行请求：curl-i-localhost-8080-1"><a href="#通过curl进行请求：curl-i-localhost-8080-1" class="headerlink" title="通过curl进行请求：curl -i localhost:8080"></a>通过curl进行请求：curl -i localhost:8080</h5><pre><code>curl -i localhost:8080HTTP/1.1 200 OKDate: Mon, 29 Jan 2018 03:02:00 GMTContent-Length: 11Content-Type: text/plain; charset=utf-8I am Gopher </code></pre><h2 id="返回JSON"><a href="#返回JSON" class="headerlink" title="返回JSON"></a>返回JSON</h2><p>Go语言里的标准库”encoding/json”</p><p>转换对应表：</p><pre><code>bool类型 转换成JSON中的boolean整型，浮点型转换成JSON中的Number字符串转换成JSON中的字符串（&quot;&quot;而不是&apos;&apos;）结构体转换成JSON中的Object[]byte 会先base64然后转换成JSON中的字符串（&quot;&quot;而不是&apos;&apos;）map 转换成JSON中的Objectinterface{} 会按内部的类型进行实际转换nil 会转换成JSON中的Null</code></pre><p>encodeing/json几乎常用的就两个方法：</p><pre><code>func Marshal(v interface{}) ([]byte, error)func Unmarshal(data []byte, v interface{}) error</code></pre><p>顾名思义“Marshal”将Go对象进行转换成JSON，而”Unmarshal”则是将JSON转换成Go对象。</p><pre><code>package mainimport (    &quot;encoding/json&quot;    &quot;net/http&quot;) // 为了对应关系可以一一对应上，我们需要手动的为结构体打上Tag，才能转换到正确的JSON // structTag还有一些其他有用的属性，比如： //     omitempty 如果JSON字段为空则忽略 //     - 直接忽略 type Profile struct {    Name    string   `json:&quot;name&quot;`    Hobbies []string `json:&quot;hobbies&quot;`}func main() {    http.HandleFunc(&quot;/&quot;, foo)    http.ListenAndServe(&quot;:8080&quot;, nil)}func foo(w http.ResponseWriter, r *http.Request) {    profile := Profile{&quot;SuperWang&quot;, []string{&quot;football&quot;, &quot;programming&quot;}}    js, err := json.Marshal(profile)    if err != nil {        http.Error(w, err.Error(), http.StatusInternalServerError)        return    }    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)    w.Write(js)} </code></pre><p>有时候你想更灵活的使用JSON，这个时候就要用到json.RawMessage，多数情况下，我们不会使用到它。在JSON中，有一个字段的格式是未知的，比如可能是string，也可能是int，那么这个时候就要用到*json.RawMessage了。</p><p>不过在转换的过程中，如果我们定义的是结构体，跟Map会有一些不同，以下几点是要注意的：</p><pre><code>结构体的成员必须是大写开头使用Marshal时会按结构体成员的变量名做为KeyUnmarshal时会自动匹配结构体成员，大小写不敏感，如果JSON中有多余字段，会直接抛弃，如果缺少某个字段，则会忽略对结构体成员赋值</code></pre><h5 id="通过curl进行请求：curl-i-localhost-8080-2"><a href="#通过curl进行请求：curl-i-localhost-8080-2" class="headerlink" title="通过curl进行请求：curl -i localhost:8080"></a>通过curl进行请求：curl -i localhost:8080</h5><pre><code>curl -i localhost:8080HTTP/1.1 200 OKContent-Type: application/jsonDate: Mon, 29 Jan 2018 03:10:52 GMTContent-Length: 57{&quot;name&quot;:&quot;SuperWang&quot;,&quot;hobbies&quot;:[&quot;football&quot;,&quot;programming&quot;]}</code></pre><h2 id="返回XML"><a href="#返回XML" class="headerlink" title="返回XML"></a>返回XML</h2><p>很久之前，很多人讨论xml和json孰是孰非，渐渐地xml越来越被人们遗忘。<br>但是一些接口还是需要使用xml的，比如xmpp协议。</p><pre><code>package mainimport (    &quot;encoding/xml&quot;    &quot;net/http&quot;)type Profile struct {    Name    string    Hobbies []string `xml:&quot;Hobbies&gt;Hobby&quot;`}func main() {    http.HandleFunc(&quot;/&quot;, foo)    http.ListenAndServe(&quot;:8080&quot;, nil)}func foo(w http.ResponseWriter, r *http.Request) {    profile := Profile{&quot;SuperWang&quot;, []string{&quot;football&quot;, &quot;programming&quot;}}    x, err := xml.MarshalIndent(profile, &quot;&quot;, &quot;  &quot;)    if err != nil {        http.Error(w, err.Error(), http.StatusInternalServerError)        return    }    w.Header().Set(&quot;Content-Type&quot;, &quot;application/xml&quot;)    w.Write(x)} </code></pre><p>通过curl进行请求：curl -i localhost:8080</p><pre><code>curl -i localhost:8080HTTP/1.1 200 OKContent-Type: application/xmlDate: Mon, 29 Jan 2018 03:16:00 GMTContent-Length: 129&lt;Profile&gt;  &lt;Name&gt;SuperWang&lt;/Name&gt;  &lt;Hobbies&gt;    &lt;Hobby&gt;football&lt;/Hobby&gt;    &lt;Hobby&gt;programming&lt;/Hobby&gt;  &lt;/Hobbies&gt;&lt;/Profile&gt; </code></pre><h2 id="返回文件"><a href="#返回文件" class="headerlink" title="返回文件"></a>返回文件</h2><p>通过接口，返回一张图片，一个文本文件等等，都是很常见的。</p><pre><code>package mainimport (    &quot;net/http&quot;    &quot;path&quot;)func main() {    http.HandleFunc(&quot;/&quot;, foo)    http.ListenAndServe(&quot;:8080&quot;, nil)}func foo(w http.ResponseWriter, r *http.Request) {    fp := path.Join(&quot;images&quot;, &quot;foo.png&quot;)    http.ServeFile(w, r, fp)} </code></pre><p>建一个images文件夹，放入foo.png文件，运行，</p><h5 id="运行，浏览器输入："><a href="#运行，浏览器输入：" class="headerlink" title="运行，浏览器输入："></a>运行，浏览器输入：</h5><ul><li><a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></li></ul><h2 id="返回HTML"><a href="#返回HTML" class="headerlink" title="返回HTML"></a>返回HTML</h2><p>下面是返回一个HTML的网页。</p><pre><code>package mainimport (    &quot;html/template&quot;    &quot;net/http&quot;    &quot;path&quot;)type Profile struct {    Name    string    Hobbies []string}func main() {    http.HandleFunc(&quot;/&quot;, foo)    http.ListenAndServe(&quot;:8080&quot;, nil)}func foo(w http.ResponseWriter, r *http.Request) {    profile := Profile{&quot;SpuerWang&quot;, []string{&quot;snowboarding&quot;, &quot;programming&quot;}}    fp := path.Join(&quot;templates&quot;, &quot;index.html&quot;)    tmpl, err := template.ParseFiles(fp)    if err != nil {        http.Error(w, err.Error(), http.StatusInternalServerError)        return    }    if err := tmpl.Execute(w, profile); err != nil {        http.Error(w, err.Error(), http.StatusInternalServerError)    }} </code></pre><p>新建文件夹templates，在里面新建文件inde.html:</p><pre><code>&lt;h1&gt;Title {{ .Name }}&lt;/h1&gt;&lt;p&gt;.....&lt;/p&gt;</code></pre><h5 id="运行，浏览器输入：-1"><a href="#运行，浏览器输入：-1" class="headerlink" title="运行，浏览器输入："></a>运行，浏览器输入：</h5><ul><li><a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做过后端开发的应该都知道，我们遇到最多的就是返回数据给客户端，就和客户端要搭界面一样，重复操作着，但是却有必不可少，今天我们来简单说说Golang Response Snippets&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://icocos.github.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="https://icocos.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Response" scheme="https://icocos.github.io/tags/Response/"/>
    
  </entry>
  
  <entry>
    <title>Go——简单说说goroutine和channel</title>
    <link href="https://icocos.github.io/2018/05/29/Go%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4goroutine%E5%92%8Cchannel/"/>
    <id>https://icocos.github.io/2018/05/29/Go——简单说说goroutine和channel/</id>
    <published>2018-05-29T15:41:55.000Z</published>
    <updated>2018-08-06T17:26:22.452Z</updated>
    
    <content type="html"><![CDATA[<p>Go 语言中的 channel 是实现  goroutine 间无锁通信的关键机制，他使得写多线程并发程序变得简单、灵活、触手可得，今天我们来简单说说goroutine和channel</p><a id="more"></a><h4 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h4><ul><li>Go 语言中的 channel 是实现  goroutine 间无锁通信的关键机制，他使得写多线程并发程序变得简单、灵活、触手可得</li></ul><p>channel是消息传递的机制，用于多线程环境下lock free synchronization.</p><ul><li>它同时具备2个特性：<ol><li>消息传递</li><li>同步</li></ol></li></ul><ul><li>参考文章：<ul><li><a href="https://blog.csdn.net/kongdefei5000/article/details/75209005" target="_blank" rel="noopener">https://blog.csdn.net/kongdefei5000/article/details/75209005</a></li><li><a href="https://blog.csdn.net/nobugtodebug/article/details/45396507" target="_blank" rel="noopener">https://blog.csdn.net/nobugtodebug/article/details/45396507</a></li></ul></li></ul><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><blockquote><p>channel 分类： 不带缓存 channel， 带缓存 channel</p></blockquote><p>无缓冲的与有缓冲channel有着重大差别，那就是一个是同步的 一个是非同步的。</p><pre><code>c1:=make(chan int)         无缓冲c2:=make(chan int,1)      有缓冲c1&lt;-1</code></pre><ul><li>无缓冲： 不仅仅是向 c1 通道放 1，而是一直要等有别的携程 &lt;-c1 接手了这个参数，那么c1&lt;-1才会继续下去，要不然就一直阻塞着。</li><li>有缓冲： c2&lt;-1 则不会阻塞，因为缓冲大小是1(其实是缓冲大小为0)，只有当放第二个值的时候，第一个还没被人拿走，这时候才会阻塞。</li></ul><h5 id="不带缓存-channel"><a href="#不带缓存-channel" class="headerlink" title="不带缓存 channel"></a>不带缓存 channel</h5><pre><code>（a）创建channel    make(chan type)    e.g.   ch := make(chan int)（b）通信方式(由于chan操作类似于Queue，为便于理解这里用EnQueue,DeQueue来描述通信操作)    EnQueue:    ch &lt;- typevar        DeQueue:   var :=  &lt;- ch    e.g.    ch &lt;- 1    v := &lt;-ch</code></pre><ul><li>关键：<ul><li>调用channel EnQueue 操作之后被阻塞住（不管channel是否为空），直到写的数据被读取掉。</li><li>调用channel DeQueue 操作时，如果channel中有数据则被读出，如果为空则阻塞住，直到有人往里面EnQueue数据。</li></ul></li></ul><h5 id="带缓存-channel"><a href="#带缓存-channel" class="headerlink" title="带缓存 channel"></a>带缓存 channel</h5><pre><code>（a）创建channel    make(chan type, size)    e.g.  ch := make(chan int, 9)（b）通信方式    同不带缓存channel</code></pre><ul><li>关键：<ul><li>当channel中元素小于等于channel size时，调用channel EnQueue 操作后数据被放入到缓存中（非阻塞）；</li><li>当channel满以后，如果再调用EnQueue操作就会被阻塞住直到有元素被DeQueue出来。</li><li>调用channel DeQueue 操作时，如果channel 为空则阻塞住直到有人往里面EnQueue数据，否则直接DeQueue出元素。</li></ul></li></ul><blockquote><p>注意: </p></blockquote><blockquote><p>需要特别注意的是两者对于range操作的区别：</p></blockquote><blockquote><p>无缓存channel是EnQueue一个数据被range读一个；</p></blockquote><blockquote><p>而带缓存channel是EnQueue满之后被range整个一起拿出来用(这个机制对于用户是透明的，用户看到的还是一个一个拿出来)，或者timeout时间到之后即使channel没有满也会被range拿出来。</p></blockquote><blockquote><p>另外，channel 关闭之后，循环读channel操作(e.g. for v:=range channel) 读完channel中剩余数据会自动跳出循环。</p></blockquote><ul><li>参考网络介绍：</li></ul><blockquote><p>顾名思义，就是通道。通道的目的是用来传递数据。在一个通道上我们可以执行数据的发送(Send)和接受(Receive)操作。对于非缓冲的 channel 而言，Receive 方法执行时，会判断该通道上是否有值，如果没有就会等待(阻塞)，直到有一个值为止。同样，在 channel 上有值，而尚未被一个 Receiver 接受的时候，Send 方法也会阻塞，直到 Channel 变空。这样，通过一个简单的机制就可以保证 Send 和 Receive 总是在不同的时间执行的，而且只有 Send 之后才能 Receive. 这样就避免了常规的多线程编程中数据共享的问题。正如 Go 语言的文档一句话所说：</p></blockquote><blockquote><p>Do not communicate by sharing memory; instead, share memory by communicating.</p></blockquote><blockquote><p>不要通过共享内存来沟通;而是通过沟通来共享内存。</p></blockquote><blockquote><p>在常规的多线程编程里，我们总是定义好一些类变量，如果这些变量有可能被多个线程同时访问，那么就需要加锁。这样带来了一定的编程复杂性，如果代码写的稍有bug，则会导致读/写到错误的值。</p></blockquote><blockquote><p>而通过 channel 来沟通，我们得到了一个更为清晰的沟通方式。两个线程(或者 goroutine)要读写相同的数据，则创建一个通道，双方通过对这个通道执行 Send / Receive 的操作来设值或取值即可，相对而言，比较不容易出错。</p></blockquote><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><ul><li>goroutine的并发模型定义为以下几个要点：<ul><li>基于Thread的轻量级协程</li><li>通过channel来进行协程间的消息传递</li><li>只暴露协程，屏蔽线程操作的接口</li></ul></li></ul><h4 id="goroutine原理"><a href="#goroutine原理" class="headerlink" title="goroutine原理"></a>goroutine原理</h4><blockquote><p>Golang的runtime实现了goroutine和OS thread的M:N模型，因此实际的goroutine是基于线程的更加轻量级的实现，我们便可以在Golang中大量创建goroutine而不用担心昂贵的context swtich所带来的开销。goroutine之间，我们可以通过channel来进行交互。由于go已将将所有system call都wrap到了标准库中，在针对这些systemcall进行调用时会主动标记goroutine为阻塞状态并保存现场，交由scheduler执行。所以在golang中，在大部分情况下我们可以非常安心地在goroutine中使用阻塞操作而不用担心并发性受到影响。</p></blockquote><p>在操作系统的OS Thread和编程语言的User Thread之间，实际上存在3中线程对应模型，也就是：1:1，1:N，M:N。</p><ul><li>N:1是说，多个（N）用户线程始终在一个内核线程上跑，context上下文切换确实很快，但是无法真正的利用多核。</li><li>1:1是说，一个用户线程就只在一个内核线程上跑，这时可以利用多核，但是上下文switch很慢，频繁切换效率很低。</li><li>M:N是说， 多个goroutine在多个内核线程上跑，这个看似可以集齐上面两者的优势，但是无疑增加了调度的难度。</li></ul><p>goroutine google runtime默认的实现为M:N的模型，于是这样可以根据具体的操作类型（操作系统阻塞或非阻塞操作）调整goroutine和OS Thread的映射情况，显得更加的灵活。</p><h5 id="在goroutine实现中，有三个最重要的数据结构，分别为G-M-P："><a href="#在goroutine实现中，有三个最重要的数据结构，分别为G-M-P：" class="headerlink" title="在goroutine实现中，有三个最重要的数据结构，分别为G M P："></a>在goroutine实现中，有三个最重要的数据结构，分别为G M P：</h5><pre><code>G：代表一个goroutineM：代表 一个OS ThreadP：一个P和一个M进行绑定，代表在这个OS Thread上的调度器</code></pre><blockquote><p>goroutine - 可以大致理解为一种轻量级的线程(或微线程)，它是一种“分配在同一个地址空间内的，能够并行执行的函数”。同时，它是轻量级的，不需要像分配线程那样分配独立的栈空间。所以理论上讲，我们可以很容易的分配很多个 goroutine, 让它们并发执行，而其开销则比多线程程序要小得多，从而可以让程序支持比较大的并发性。</p></blockquote><h5 id="goroutinue，本质上就是协程。但有两点不同："><a href="#goroutinue，本质上就是协程。但有两点不同：" class="headerlink" title="goroutinue，本质上就是协程。但有两点不同："></a>goroutinue，本质上就是协程。但有两点不同：</h5><ol><li>goroutinue可以实现并行，也就是说，多个协程可以在多个处理器同时跑。而协程同一时刻只能在一个处理器上跑（把宿主语言想象成单线程的就好了）。</li><li>goroutine之间的通信是通过channel，而协程的通信是通过yield和resume()操作。</li></ol><h5 id="那么如果有两个A-B两个协程-在放入和取出数据时都只能用int类型的数据进行通信"><a href="#那么如果有两个A-B两个协程-在放入和取出数据时都只能用int类型的数据进行通信" class="headerlink" title="那么如果有两个A,B两个协程 在放入和取出数据时都只能用int类型的数据进行通信"></a>那么如果有两个A,B两个协程 在放入和取出数据时都只能用int类型的数据进行通信</h5><ul><li>如 取数据 &lt;- channel 放数据 channel &lt;- 1</li></ul><blockquote><p>协程之间可以通过在通道中放入-取出数据的方式进行通信</p></blockquote><h2 id="3种优雅的Go-channel用法"><a href="#3种优雅的Go-channel用法" class="headerlink" title="3种优雅的Go channel用法"></a>3种优雅的Go channel用法</h2><p>写Go的人应该都听过Rob Pike的这句话</p><pre><code>Do not communicate by sharing memory; instead, share memory by communicating.</code></pre><p>相信很多朋友和我一样，在实际应用中总感觉不到好处，为了用channel而用。但以我的切身体会来说，这是写代码时碰到的场景不复杂、对channel不熟悉导致的，所以希望这篇文章能给大家带来点新思路，对Golang优雅的channel有更深的认识 ：）</p><h3 id="Fan-In-Out"><a href="#Fan-In-Out" class="headerlink" title="Fan In/Out"></a>Fan In/Out</h3><p>数据的输出有时候需要做扇出／入（FanIn／Out），但是在函数中调用常常得修改接口，而且上下游对于数据的依赖程度非常高，所以一般使用通过channel进行Fan In／Out，这样就可以轻易实现类似于shell里的管道。</p><pre><code>func fanIn(input1, input2 &lt;-chan string) &lt;-chan string {    c := make(chan string)    go func() {        for {            select {                case s := &lt;-input1:  c &lt;- s                case s := &lt;-input2:  c &lt;- s            }        }    }()    return c}</code></pre><h3 id="同步Goroutine"><a href="#同步Goroutine" class="headerlink" title="同步Goroutine"></a>同步Goroutine</h3><p>两个goroutine之间同步状态，例如A goroutine需要让B goroutine退出，一般做法如下：</p><pre><code>func main() {    g = make(chan int)    quit = make(chan bool)    go B()    for i := 0; i &lt; 3; i++ {        g &lt;- i    }    quit &lt;- true // 没办法等待B的退出只能Sleep    fmt.Println(&quot;Main quit&quot;)}func B() {    for {        select {            case i := &lt;-g:            fmt.Println(i + 1)            case &lt;-quit:            fmt.Println(&quot;B quit&quot;)            return        }    }}</code></pre><h5 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h5><pre><code>/*Output:123Main quit*/</code></pre><p>可是了main函数没办法等待B合适地退出，所以B quit 没办法打印，程序直接退出了。然而，chan是Go里的第一对象，所以可以把chan传入chan中，所以上面的代码可以把quit 定义为chan chan bool，以此控制两个goroutine的同步</p><pre><code>func main() {    g = make(chan int)    quit = make(chan chan bool)    go B()    for i := 0; i &lt; 5; i++ {        g &lt;- i    }    wait := make(chan bool)    quit &lt;- wait    &lt;-wait //这样就可以等待B的退出了    fmt.Println(&quot;Main Quit&quot;)}func B() {    for {        select {            case i := &lt;-g:            fmt.Println(i + 1)            case c := &lt;-quit:            c &lt;- true            fmt.Println(&quot;B Quit&quot;)            return        }    }}</code></pre><h5 id="Log-1"><a href="#Log-1" class="headerlink" title="Log"></a>Log</h5><pre><code>/* Output123B QuitMain Quit*/</code></pre><h3 id="分布式递归调用"><a href="#分布式递归调用" class="headerlink" title="分布式递归调用"></a>分布式递归调用</h3><p>在现实生活中，如果你要找美国总统聊天，你会怎么做？第一步打电话给在美国的朋友，然后他们也会发动自己的关系网，再找可能认识美国总统的人，以此类推，直到找到为止。这在Kadmelia分布式系统中也是一样的，如果需要获取目标ID信息，那么就不停地查询，被查询节点就算没有相关信息，也会返回它觉得最近节点，直到找到ID或者等待超时。 好了，这个要用Go来实现怎么做呢？</p><pre><code>func recursiveCall(ctx context.Context, id []byte, initialNodes []*node){    seen := map[string]*node{} //已见过的节点记录    request := make(chan *node, 3) //设置请求节点channel    // 输入初始节点    go func() {        for _, n := range initialNodes {            request &lt;- n        }    }()    OUT:    for {        //循环直到找到数据        if data != nil {            return        }        // 在新的请求，超时和上层取消请求中select        select {            case n := &lt;-request:            go func() {                // 发送新的请求                response := s.sendQuery(ctx, n, MethodFindValue, id)                select {                    case &lt;-ctx.Done():                    case msg :=&lt;-response:                    seen[responseToNode(response)] = n //更新已见过的节点信息                    // 加载新的节点                    for _, rn := range LoadNodeInfoFromByte(msg[PayLoadStart:]) {                        mu.Lock()                        _, ok := seen[rn.HexID()]                        mu.Unlock()                        // 见过了，跳过这个节点                        if ok {                            continue                        }                        AddNode(rn)                        // 将新的节点送入channel                        request &lt;- rn                        }                    }                }            }()            case &lt;-time.After(500 * time.Millisecond):            break OUT // break至外层，否则仅仅是跳至loop外            case &lt;-ctx.Done():            break OUT        }    }    return}</code></pre><p>这时的buffered channel类似于一个局部queue，对需要的节点进行处理，但这段代码的精妙之处在于，这里的block操作是select的，随时可以取消，而不是要等待或者对queue的长度有认识。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go 语言中的 channel 是实现  goroutine 间无锁通信的关键机制，他使得写多线程并发程序变得简单、灵活、触手可得，今天我们来简单说说goroutine和channel&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://icocos.github.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="https://icocos.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
      <category term="goroutine和channel" scheme="https://icocos.github.io/tags/goroutine%E5%92%8Cchannel/"/>
    
  </entry>
  
  <entry>
    <title>Go——函数与方法的奇妙之处</title>
    <link href="https://icocos.github.io/2018/05/25/Go%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95%E7%9A%84%E5%A5%87%E5%A6%99%E4%B9%8B%E5%A4%84/"/>
    <id>https://icocos.github.io/2018/05/25/Go——函数与方法的奇妙之处/</id>
    <published>2018-05-25T14:44:39.000Z</published>
    <updated>2018-08-06T17:26:22.335Z</updated>
    
    <content type="html"><![CDATA[<p>有过（面向对象）编程经验的应该都知道方法或者函数，比如在C，PHP，swift，OC，Java，kotlin等都有函数或者方法的存在，或者有二者的存在，只是有些人没有太过留意，比如PHP中就有这样的现象，而iOS中除了存在方法和行数，方法还分类方法和对象方法。</p><a id="more"></a><p>有过（面向对象）编程经验的应该都知道方法或者函数，比如在C，PHP，swift，OC，Java，kotlin等都有函数或者方法的存在，或者有二者的存在，只是有些人没有太过留意，比如PHP中就有这样的现象，而iOS中除了存在方法和行数，方法还分类方法和对象方法。</p><blockquote><p>那么Golang中方法和行数的本质意义其实差不多，只是定义和使用的语法不同而已。</p></blockquote><p>这里我们就来说说Golang中函数与方法，</p><h2 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h2><h5 id="行数定义"><a href="#行数定义" class="headerlink" title="行数定义"></a>行数定义</h5><pre><code>func function_name( [parameter list] ) [return_types]{   body of the function}</code></pre><h5 id="不允许函数内嵌定义"><a href="#不允许函数内嵌定义" class="headerlink" title="不允许函数内嵌定义"></a>不允许函数内嵌定义</h5><pre><code>func main() {    func swap(x, y string) (string, string) {    return y, x    }}</code></pre><h5 id="支持多返回值、支持命名返回值"><a href="#支持多返回值、支持命名返回值" class="headerlink" title="支持多返回值、支持命名返回值"></a>支持多返回值、支持命名返回值</h5><pre><code>func split(sum int) (x, y int) {    return}</code></pre><h5 id="函数只能判断是否为nil"><a href="#函数只能判断是否为nil" class="headerlink" title="函数只能判断是否为nil"></a>函数只能判断是否为nil</h5><pre><code>fmt.Println(add == nil)//fmt.Println(add == 1)  //错误 mismatched types func(int, int) int and int)</code></pre><h5 id="参数视为局部变量，因此不能声明同名变量"><a href="#参数视为局部变量，因此不能声明同名变量" class="headerlink" title="参数视为局部变量，因此不能声明同名变量"></a>参数视为局部变量，因此不能声明同名变量</h5><pre><code>func add(a, b int) int {    a := 2}</code></pre><h5 id="不支持默认参数、已”-”命名的参赛也不能忽略"><a href="#不支持默认参数、已”-”命名的参赛也不能忽略" class="headerlink" title="不支持默认参数、已”_”命名的参赛也不能忽略"></a>不支持默认参数、已”_”命名的参赛也不能忽略</h5><pre><code>func add(a, b int, _ bool) int {    return a + b}func main() {    fmt.Println(add(1,2, true))    //fmt.Println(add(1,2) // 错误：not enough arguments in call to add}</code></pre><h5 id="支持可变参数"><a href="#支持可变参数" class="headerlink" title="支持可变参数"></a>支持可变参数</h5><pre><code>func test(str string, a ...int) {    fmt.Println(&quot;%T, %v\n&quot;, str, a)}func main() {    test(&quot;a&quot;, 1, 2, 3)}</code></pre><h5 id="可以在函数内定义匿名函数"><a href="#可以在函数内定义匿名函数" class="headerlink" title="可以在函数内定义匿名函数"></a>可以在函数内定义匿名函数</h5><pre><code>func main() {    func (s string) {        fmt.Println(s)    } (&quot;hello, go!&quot;)}</code></pre><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><pre><code>// This function `intSeq` returns another function, which// we define anonymously in the body of `intSeq`. The// returned function _closes over_ the variable `i` to// form a closure.func intSeq() func() int {    i := 0    return func() int {        i += 1        return i    }}func main() {    // We call `intSeq`, assigning the result (a function)    // to `nextInt`. This function value captures its    // own `i` value, which will be updated each time    // we call `nextInt`.    nextInt := intSeq()    // See the effect of the closure by calling `nextInt`    // a few times.    fmt.Println(nextInt())    fmt.Println(nextInt())    fmt.Println(nextInt())    // To confirm that the state is unique to that    // particular function, create and test a new one.    newInts := intSeq()    fmt.Println(newInts())}</code></pre><ul><li>注意<ul><li>函数的左花括号也不能另起一行</li><li>不支持函数重载</li></ul></li></ul><h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h2><h5 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h5><pre><code>func (r Recevier) function_name(){   body of the method}</code></pre><h5 id="定义和使用："><a href="#定义和使用：" class="headerlink" title="定义和使用："></a>定义和使用：</h5><pre><code>type Vertex struct {    X, Y float64}func (v Vertex) Abs() float64 {    return math.Sqrt(v.X*v.X + v.Y*v.Y)}func main() {    v := Vertex{3, 4}    fmt.Println(v.Abs())}</code></pre><h5 id="下面来仔细看看官方对方法给出的一个例子"><a href="#下面来仔细看看官方对方法给出的一个例子" class="headerlink" title="下面来仔细看看官方对方法给出的一个例子"></a>下面来仔细看看官方对方法给出的一个例子</h5><pre><code>package mainimport &quot;fmt&quot;type rect struct {    width, height int}// This `area` method has a _receiver type_ of `*rect`.func (r *rect) area() int {    return r.width * r.height}// Methods can be defined for either pointer or value// receiver types. Here&apos;s an example of a value receiver.func (r rect) perim() int {    return 2*r.width + 2*r.height}func main() {    r := rect{width: 10, height: 5}    // Here we call the 2 methods defined for our struct.    fmt.Println(&quot;area: &quot;, r.area())    fmt.Println(&quot;perim:&quot;, r.perim())    // Go automatically handles conversion between values    // and pointers for method calls. You may want to use    // a pointer receiver type to avoid copying on method    // calls or to allow the method to mutate the    // receiving struct.    rp := &amp;r    fmt.Println(&quot;area: &quot;, rp.area())    fmt.Println(&quot;perim:&quot;, rp.perim())}</code></pre><blockquote><p>其实是利用方法求长方形的周长和面积，其中也给出了receiver作为指针和值的区别</p></blockquote><ul><li>这里也简单说下：什么时候receiver用指针<ul><li>1 改变receiver的值</li><li>2 struct本身非常的大，这样拷贝的代价是很昂贵的</li><li>3 如果struct的一个method中receiver为指针，那么其他的method的receiver最好也要用指针。</li></ul></li></ul><h2 id="方法与函数的区别"><a href="#方法与函数的区别" class="headerlink" title="方法与函数的区别"></a>方法与函数的区别</h2><p>在golang的世界中，一定要区分 方法和函数。</p><p>Go中没有类的概念，但是我们可以在一些类型上定义一些方法，也就是所谓的方法，跟函数不同。</p><ul><li>方法和函数定义语法区别在于：<ul><li>方法是针对对象的（有些是针对类）</li><li>函数是针对全局的（Golang中指包），</li><li>方法前置实例接受参数，这个receiver可以是基础类型也可以是指针。</li></ul></li></ul><blockquote><p>虽然Go语言没有类的概念，但它支持的数据类型可以定义对应的method(s)。本质上说，所谓的method(s)其实就是函数，只不过与普通函数相比，这类函数是作用在某个数据类型上的，所以在函数签名中，会有个receiver(接收器)来表明当前定义的函数会作用在该receiver上。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有过（面向对象）编程经验的应该都知道方法或者函数，比如在C，PHP，swift，OC，Java，kotlin等都有函数或者方法的存在，或者有二者的存在，只是有些人没有太过留意，比如PHP中就有这样的现象，而iOS中除了存在方法和行数，方法还分类方法和对象方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://icocos.github.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="https://icocos.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
      <category term="函数与方法" scheme="https://icocos.github.io/tags/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Go语言中的Array、Slice、Map和Set</title>
    <link href="https://icocos.github.io/2018/05/22/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84Array%E3%80%81Slice%E3%80%81Map%E5%92%8CSet/"/>
    <id>https://icocos.github.io/2018/05/22/Go语言中的Array、Slice、Map和Set/</id>
    <published>2018-05-22T15:01:33.000Z</published>
    <updated>2018-08-09T09:08:36.310Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言中和其他语言一样，存在数组，Map(iOS中的字典)，但是还有一个比较特殊的Slice，他其实底层还是数组，今天我们来简单说说Go语言中的Array、Slice、Map和Set</p><a id="more"></a><h2 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array(数组)"></a>Array(数组)</h2><h5 id="内部机制"><a href="#内部机制" class="headerlink" title="内部机制"></a>内部机制</h5><blockquote><p>在 Go 语言中数组是固定长度的数据类型，它包含相同类型的连续的元素，这些元素可以是内建类型，像数字和字符串，也可以是结构类型，元素可以通过唯一的索引值访问，从 0 开始。</p></blockquote><p>数组是很有价值的数据结构，因为它的内存分配是连续的，内存连续意味着可是让它在 CPU 缓存中待更久，所以迭代数组和移动元素都会非常迅速。</p><h5 id="数组声明和初始化"><a href="#数组声明和初始化" class="headerlink" title="数组声明和初始化"></a>数组声明和初始化</h5><p>通过指定数据类型和元素个数(数组长度)来声明数组。</p><pre><code>// 声明一个长度为5的整数数组var array [5]int</code></pre><p>一旦数组被声明了，那么它的数据类型跟长度都不能再被改变。如果你需要更多的元素，那么只能创建一个你想要长度的新的数组，然后把原有数组的元素拷贝过去。</p><blockquote><p>Go 语言中任何变量被声明时，都会被默认初始化为各自类型对应的 0 值，数组当然也不例外。当一个数组被声明时，它里面包含的每个元素都会被初始化为 0 值。</p></blockquote><p>一种快速创建和初始化数组的方法是使用数组字面值。数组字面值允许我们声明我们需要的元素个数并指定数据类型：</p><pre><code>// 声明一个长度为5的整数数组// 初始化每个元素array := [5]int{7, 77, 777, 7777, 77777}</code></pre><p>如果你把长度写成 …，Go 编译器将会根据你的元素来推导出长度：</p><pre><code>// 通过初始化值的个数来推导出数组容量array := [...]int{7, 77, 777, 7777, 77777}</code></pre><p>如果我们知道想要数组的长度，但是希望对指定位置元素初始化，可以这样：</p><pre><code>// 声明一个长度为5的整数数组// 为索引为1和2的位置指定元素初始化// 剩余元素为0值array := [5]int{1: 77, 2: 777}</code></pre><h5 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h5><p>使用 [] 操作符来访问数组元素：</p><pre><code>array := [5]int{7, 77, 777, 7777, 77777}// 改变索引为2的元素的值array[2] = 1</code></pre><p>我们可以定义一个指针数组：</p><pre><code>array := [5]*int{0: new(int), 1: new(int)}// 为索引为0和1的元素赋值*array[0] = 7*array[1] = 77</code></pre><p>在 Go 语言中数组是一个值，所以可以用它来进行赋值操作。一个数组可以被赋值给任意相同类型的数组：</p><pre><code>var array1 [5]stringarray2 := [5]string{&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;, &quot;Yellow&quot;, &quot;Pink&quot;}array1 = array2</code></pre><p>注意数组的类型同时包括数组的长度和可以被存储的元素类型，数组类型完全相同才可以互相赋值，比如下面这样就不可以：</p><pre><code>var array1 [4]stringarray2 := [5]string{&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;, &quot;Yellow&quot;, &quot;Pink&quot;}array1 = array2// 编译器会报错Compiler Error:cannot use array2 (type [5]string) as type [4]string in assignment</code></pre><p>拷贝一个指针数组实际上是拷贝指针值，而不是指针指向的值：</p><pre><code>var array1 [3]*stringarray2 := [3]*string{new(string), new(string), new(string)}*array2[0] = &quot;Red&quot;*array2[1] = &quot;Blue&quot;*array2[2] = &quot;Green&quot;array1 = array2// 赋值完成后，两组指针数组指向同一字符串</code></pre><h5 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h5><p>数组总是一维的，但是可以组合成多维的。多维数组通常用于有父子关系的数据或者是坐标系数据：</p><pre><code>// 声明一个二维数组var array [4][2]int// 使用数组字面值声明并初始化array := [4][2]int{{10, 11}, {20, 21}, {30, 31}, {40, 41}}// 指定外部数组索引位置初始化array := [4][2]int{1: {20, 21}, 3: {40, 41}}// 同时指定内外部数组索引位置初始化array := [4][2]int{1: {0: 20}, 3: {1: 41}}</code></pre><p>同样通过 [] 操作符来访问数组元素：</p><pre><code>var array [2][2]intarray[0][0] = 0array[0][1] = 1array[1][0] = 2array[1][1] = 3</code></pre><p>也同样的相同类型的多维数组可以相互赋值：</p><pre><code>var array1 = [2][2]intvar array2 = [2][2]intarray[0][0] = 0array[0][1] = 1array[1][0] = 2array[1][1] = 3array1 = array2</code></pre><p>因为数组是值，我们可以拷贝单独的维：</p><pre><code>var array3 [2]int = array1[1]var value int = array1[1][0]</code></pre><h5 id="在函数中传递数组"><a href="#在函数中传递数组" class="headerlink" title="在函数中传递数组"></a>在函数中传递数组</h5><p>在函数中传递数组是非常昂贵的行为，因为在函数之间传递变量永远是传递值，所以如果变量是数组，那么意味着传递整个数组，即使它很大很大很大。。。</p><p>举个栗子，创建一个有百万元素的整形数组，在64位的机器上它需要8兆的内存空间，来看看我们声明它和传递它时发生了什么：</p><pre><code>var array [1e6]intfoo(array)func foo(array [1e6]int) {  ...}</code></pre><p>每一次 foo 被调用，8兆内存将会被分配在栈上。一旦函数返回，会弹栈并释放内存，每次都需要8兆空间。</p><p>Go 语言当然不会这么傻，有更好的方法来在函数中传递数组，那就是传递指向数组的指针，这样每次只需要分配8字节内存：</p><pre><code>var array [1e6]intfoo(&amp;array)func foo(array *[1e6]int){  ...}</code></pre><p>但是注意如果你在函数中改变指针指向的值，那么原始数组的值也会被改变。幸运的是 slice(切片)可以帮我们处理好这些问题，来一起看看。</p><h2 id="Slice-切片"><a href="#Slice-切片" class="headerlink" title="Slice(切片)"></a>Slice(切片)</h2><h5 id="内部机制和基础"><a href="#内部机制和基础" class="headerlink" title="内部机制和基础"></a>内部机制和基础</h5><p>slice 是一种可以动态数组，可以按我们的希望增长和收缩。它的增长操作很容易使用，因为有内建的 append 方法。我们也可以通过 relice 操作化简 slice。因为 slice 的底层内存是连续分配的，所以 slice 的索引，迭代和垃圾回收性能都很好。</p><p>slice 是对底层数组的抽象和控制。它包含 Go 需要对底层数组管理的三种元数据，分别是：</p><ol><li>指向底层数组的指针</li><li>slice 中元素的长度</li><li>slice 的容量(可供增长的最大值)</li></ol><h5 id="创建和初始化"><a href="#创建和初始化" class="headerlink" title="创建和初始化"></a>创建和初始化</h5><p>Go 中创建 slice 有很多种方法，我们一个一个来看。</p><p>第一个方法是使用内建的函数 make。当我们使用 make 创建时，一个选项是可以指定 slice 的长度：</p><pre><code>slice := make([]string, 5)</code></pre><p>如果只指定了长度，那么容量默认等于长度。我们可以分别指定长度和容量：</p><pre><code>slice := make([]int, 3, 5)</code></pre><p>当我们分别指定了长度和容量，我们创建的 slice 就可以拥有一开始并没有访问的底层数组的容量。上面代码的 slice 中，可以访问3个元素，但是底层数组有5个元素。两个与长度不相干的元素可以被 slice 来用。新创建的 slice 同样可以共享底层数组和已存在的容量。</p><p>不允许创建长度大于容量的 slice：</p><pre><code>slice := make([]int, 5, 3)Compiler Error:len larger than cap in make([]int)</code></pre><p>惯用的创建 slice 的方法是使用 slice 字面量。跟创建数组很类似，不过不用指定 []里的值。初始的长度和容量依赖于元素的个数：</p><pre><code>// 创建一个字符串 slice// 长度和容量都是 5slice := []string{&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;, &quot;Yellow&quot;, &quot;Pink&quot;}</code></pre><p>在使用 slice 字面量创建 slice 时有一种方法可以初始化长度和容量，那就是初始化索引。下面是个例子：</p><pre><code>// 创建一个字符串 slice// 初始化一个有100个元素的空的字符串 sliceslice := []string{99: &quot;&quot;}nil 和 empty slice</code></pre><p>有的时候我们需要创建一个 nil slice，创建一个 nil slice 的方法是声明它但不初始化它：</p><pre><code>var slice []int</code></pre><p>创建一个 nil slice 是创建 slice 最基本的方法，很多标准库和内建函数都可以使用它。当我们想要表示一个并不存在的 slice 时它变得非常有用，比如一个返回 slice 的函数中发生异常的时候。</p><p>创建 empty slice 的方法就是声明并初始化一下：</p><pre><code>// 使用 make 创建silce := make([]int, 0)// 使用 slice 字面值创建slice := []int{}</code></pre><p>empty slice 包含0个元素并且底层数组没有分配存储空间。当我们想要表示一个空集合时它很有用处，比如一个数据库查询返回0个结果。</p><blockquote><p>不管我们用 nil slice 还是 empty slice，内建函数 append，len和cap的工作方式完全相同。</p></blockquote><h5 id="使用-slice"><a href="#使用-slice" class="headerlink" title="使用 slice"></a>使用 slice</h5><p>为一个指定索引值的 slice 赋值跟之前数组赋值的做法完全相同。改变单个元素的值使用 [] 操作符：</p><pre><code>slice := []int{10, 20, 30, 40, 50}slice[1] = 25</code></pre><p>我们可以在底层数组上对一部分数据进行 slice 操作，来创建一个新的 slice：</p><pre><code>// 长度为5，容量为5slice := []int{10, 20, 30, 40, 50}// 长度为2，容量为4newSlice := slice[1:3]</code></pre><p>在 slice 操作之后我们得到了两个 slice，它们共享底层数组。但是它们能访问底层数组的范围却不同，newSlice 不能访问它头指针前面的值。</p><p>计算任意 new slice 的长度和容量可以使用下面的公式：</p><pre><code>对于 slice[i:j] 和底层容量为 k 的数组长度：j - i容量：k - i</code></pre><p>必须再次明确一下现在是两个 slice 共享底层数组，因此只要有一个 slice 改变了底层数组的值，那么另一个也会随之改变：</p><pre><code>slice := []int{10, 20, 30, 40, 50}newSlice := slice[1:3]newSlice[1] = 35</code></pre><p>改变 newSlice 的第二个元素的值，也会同样改变 slice 的第三个元素的值。</p><p>一个 slice 只能访问它长度范围内的索引，试图访问超出长度范围的索引会产生一个运行时错误。容量只可以用来增长，它只有被合并到长度才可以被访问：</p><pre><code>slice := []int{10, 20, 30, 40, 50}newSlice := slice[1:3]newSlice[3] = 45Runtime Exception:panic: runtime error: index out of range</code></pre><p>容量可以被合并到长度里，通过内建的 append 函数。</p><h5 id="slice-增长"><a href="#slice-增长" class="headerlink" title="slice 增长"></a>slice 增长</h5><p>slice 比 数组的优势就在于它可以按照我们的需要增长，我们只需要使用 append 方法，然后 Go 会为我们做好一切。</p><p>使用 append 方法时我们需要一个源 slice 和需要附加到它里面的值。当 append 方法返回时，它返回一个新的 slice，append 方法总是增长 slice 的长度，另一方面，如果源 slice 的容量足够，那么底层数组不会发生改变，否则会重新分配内存空间。</p><pre><code>// 创建一个长度和容量都为5的 sliceslice := []int{10, 20, 30, 40, 50}// 创建一个新的 slicenewSlice := slice[1:3]// 为新的 slice append 一个值newSlice = append(newSlice, 60)</code></pre><p>因为 newSlice 有可用的容量，所以在 append 操作之后 slice 索引为 3 的值也变成了 60，之前说过这是因为 slice 和 newSlice 共享同样的底层数组。</p><p>如果没有足够可用的容量，append 函数会创建一个新的底层数组，拷贝已存在的值和将要被附加的新值：</p><pre><code>// 创建长度和容量都为4的 sliceslice := []int{10, 20, 30, 40}// 附加一个新值到 slice，因为超出了容量，所以会创建新的底层数组newSlice := append(slice, 50)</code></pre><p>append 函数重新创建底层数组时，容量会是现有元素的两倍(前提是元素个数小于1000)，如果元素个数超过1000，那么容量会以 1.25 倍来增长。</p><h5 id="slice-的第三个索引参数"><a href="#slice-的第三个索引参数" class="headerlink" title="slice 的第三个索引参数"></a>slice 的第三个索引参数</h5><p>slice 还可以有第三个索引参数来限定容量，它的目的不是为了增加容量，而是提供了对底层数组的一个保护机制，以方便我们更好的控制 append 操作，举个栗子：</p><pre><code>source := []string{&quot;apple&quot;, &quot;orange&quot;, &quot;plum&quot;, &quot;banana&quot;, &quot;grape&quot;}// 接着我们在源 slice 之上创建一个新的 sliceslice := source[2:3:4]</code></pre><p>新创建的 slice 长度为 1，容量为 2，可以看出长度和容量的计算公式也很简单：</p><pre><code>对于 slice[i:j:k]  或者 [2:3:4]长度： j - i       或者   3 - 2容量： k - i       或者   4 - 2</code></pre><p>如果我们试图设置比可用容量更大的容量，会得到一个运行时错误：</p><pre><code>slice := source[2:3:6]Runtime Error:panic: runtime error: slice bounds out of range</code></pre><p>限定容量最大的用处是我们在创建新的 slice 时候限定容量与长度相同，这样以后再给新的 slice 增加元素时就会分配新的底层数组，而不会影响原有 slice 的值：</p><pre><code>source := []string{&quot;apple&quot;, &quot;orange&quot;, &quot;plum&quot;, &quot;banana&quot;, &quot;grape&quot;}// 接着我们在源 slice 之上创建一个新的 slice// 并且设置长度和容量相同slice := source[2:3:3]// 添加一个新元素slice = append(slice, &quot;kiwi&quot;)</code></pre><p>如果没有第三个索引参数限定，添加 kiwi 这个元素时就会覆盖掉 banana。</p><p>内建函数 append 是一个变参函数，意思就是你可以一次添加多个元素，比如：</p><pre><code>s1 := []int{1, 2}s2 := []int{3, 4}fmt.Printf(&quot;%v\n&quot;, append(s1, s2...))Output:[1 2 3 4]</code></pre><h5 id="迭代-slice"><a href="#迭代-slice" class="headerlink" title="迭代 slice"></a>迭代 slice</h5><p>slice 也是一种集合，所以可以被迭代，用 for 配合 range 来迭代：</p><pre><code>slice := []int{10, 20, 30, 40, 50}for index, value := range slice {  fmt.Printf(&quot;Index: %d  Value: %d\n&quot;, index, value)}Output:Index: 0  Value: 10Index: 1  Value: 20Index: 2  Value: 30Index: 3  Value: 40Index: 4  Value: 50</code></pre><p>当迭代时 range 关键字会返回两个值，第一个是索引值，第二个是索引位置值的拷贝。注意：返回的是值的拷贝而不是引用，如果我们把值的地址作为指针使用，会得到一个错误，来看看为啥：</p><pre><code>slice := []int{10, 20, 30 ,40}for index, value := range slice {  fmt.Printf(&quot;Value: %d  Value-Addr: %X  ElemAddr: %X\n&quot;, value, &amp;value, &amp;slice[index])}Output:Value: 10  Value-Addr: 10500168  ElemAddr: 1052E100Value: 20  Value-Addr: 10500168  ElemAddr: 1052E104Value: 30  Value-Addr: 10500168  ElemAddr: 1052E108Value: 40  Value-Addr: 10500168  ElemAddr: 1052E10C</code></pre><p>value 变量的地址总是相同的因为它只是包含一个拷贝。如果想得到每个元素的真是地址可以使用 &amp;slice[index]。</p><p>如果不需要索引值，可以使用 _ 操作符来忽略它：</p><pre><code>slice := []int{10, 20, 30, 40}for _, value := range slice {  fmt.Printf(&quot;Value: %d\n&quot;, value)}Output:Value: 10Value: 20Value: 30Value: 40</code></pre><p>range 总是从开始一次遍历，如果你想控制遍历的step，就用传统的 for 循环：</p><pre><code>slice := []int{10, 20, 30, 40}for index := 2; index &lt; len(slice); index++ {  fmt.Printf(&quot;Index: %d  Value: %d\n&quot;, index, slice[index])}Output:Index: 2  Value: 30Index: 3  Value: 40</code></pre><p>同数组一样，另外两个内建函数 len 和 cap 分别返回 slice 的长度和容量。</p><h5 id="多维-slice"><a href="#多维-slice" class="headerlink" title="多维 slice"></a>多维 slice</h5><p>也是同数组一样，slice 可以组合为多维的 slice：</p><pre><code>slice := [][]int{{10}, {20, 30}}</code></pre><p>需要注意的是使用 append 方法时的行为，比如我们现在对 slice[0] 增加一个元素：</p><pre><code>slice := [][]int{{10}, {20, 30}}slice[0] = append(slice[0], 20)</code></pre><p>那么只有 slice[0] 会重新创建底层数组，slice[1] 则不会。</p><h5 id="在函数间传递-slice"><a href="#在函数间传递-slice" class="headerlink" title="在函数间传递 slice"></a>在函数间传递 slice</h5><p>在函数间传递 slice 是很廉价的，因为 slice 相当于是指向底层数组的指针，让我们创建一个很大的 slice 然后传递给函数调用它：</p><pre><code>slice := make([]int, 1e6)slice = foo(slice)func foo(slice []int) []int {    ...    return slice}</code></pre><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h5 id="内部机制-1"><a href="#内部机制-1" class="headerlink" title="内部机制"></a>内部机制</h5><ul><li><p>map 是一种无序的键值对的集合。map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。</p></li><li><p>map 是一种集合，所以我们可以像迭代数组和 slice 那样迭代它。不过，map 是无序的，我们无法决定它的返回顺序，这是因为 map 是使用 hash 表来实现的。</p></li></ul><p>map 的 hash 表包含了一个桶集合(collection of buckets)。当我们存储，移除或者查找键值对(key/value pair)时，都会从选择一个桶开始。在映射(map)操作过程中，我们会把指定的键值(key)传递给 hash 函数(又称散列函数)。hash 函数的作用是生成索引，索引均匀的分布在所有可用的桶上。hash 表算法详见：July的博客—从头到尾彻底解析 hash 表算法</p><h5 id="创建和初始化-1"><a href="#创建和初始化-1" class="headerlink" title="创建和初始化"></a>创建和初始化</h5><p>Go 语言中有多种方法创建和初始化 map。我们可以使用内建函数 make 也可以使用 map 字面值：</p><pre><code>// 通过 make 来创建dict := make(map[string]int)// 通过字面值创建dict := map[string]string{&quot;Red&quot;: &quot;#da1337&quot;, &quot;Orange&quot;: &quot;#e95a22&quot;}</code></pre><p>使用字面值是创建 map 惯用的方法(为什么不使用make)。初始化 map 的长度依赖于键值对的数量。</p><p>map 的键可以是任意内建类型或者是 struct 类型，map 的值可以是使用 ==操作符的表达式。slice，function 和 包含 slice 的 struct 类型不可以作为 map 的键，否则会编译错误：</p><pre><code>dict := map[[]string]int{}Compiler Exception:invalid map key type []string</code></pre><h5 id="使用-map"><a href="#使用-map" class="headerlink" title="使用 map"></a>使用 map</h5><p>给 map 赋值就是指定合法类型的键，然后把值赋给键：</p><pre><code>colors := map[string]string{}colors[&quot;Red&quot;] = &quot;#da1337&quot;</code></pre><p>如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对，否则会报运行时错误：</p><pre><code>var colors map[string]stringcolors[&quot;Red&quot;] = &quot;#da1337&quot;Runtime Error:panic: runtime error: assignment to entry in nil map</code></pre><p>测试 map 的键是否存在是 map 操作的重要部分，因为它可以让我们判断是否可以执行一个操作，或者是往 map 里缓存一个值。它也可以被用来比较两个 map 的键值对是否匹配或者缺失。</p><p>从 map 里检索一个值有两种选择，我们可以同时检索值并且判断键是否存在：</p><pre><code>value, exists := colors[&quot;Blue&quot;]if exists {  fmt.Println(value)}</code></pre><p>另一种选择是只返回值，然后判断是否是零值来确定键是否存在。但是只有你确定零值是非法值的时候这招才管用：</p><pre><code>value := colors[&quot;Blue&quot;]if value != &quot;&quot; {  fmt.Println(value)}</code></pre><p>当索引一个 map 取值时它总是会返回一个值，即使键不存在。上面的例子就返回了对应类型的零值。</p><p>迭代一个 map 和迭代数组和 slice 是一样的，使用 range 关键字，不过在迭代 map 时我们不使用 index/value 而使用 key/value 结构：</p><pre><code>colors := map[string]string{    &quot;AliceBlue&quot;:   &quot;#f0f8ff&quot;,    &quot;Coral&quot;:       &quot;#ff7F50&quot;,    &quot;DarkGray&quot;:    &quot;#a9a9a9&quot;,    &quot;ForestGreen&quot;: &quot;#228b22&quot;,}for key, value := range colors {  fmt.Printf(&quot;Key: %s  Value: %s\n&quot;, key, value)}</code></pre><p>如果我们想要从 map 中移除一个键值对，使用内建函数 delete(要是也能返回移除是否成功就好了，哎。。。)：</p><pre><code>delete(colors, &quot;Coral&quot;)for key, value := range colors {  fmt.Println(&quot;Key: %s  Value: %s\n&quot;, key, value)}</code></pre><h5 id="在函数间传递-map"><a href="#在函数间传递-map" class="headerlink" title="在函数间传递 map"></a>在函数间传递 map</h5><p>在函数间传递 map 不是传递 map 的拷贝。所以如果我们在函数中改变了 map，那么所有引用 map 的地方都会改变：</p><pre><code>func main() {  colors := map[string]string{     &quot;AliceBlue&quot;:   &quot;#f0f8ff&quot;,     &quot;Coral&quot;:       &quot;#ff7F50&quot;,     &quot;DarkGray&quot;:    &quot;#a9a9a9&quot;,     &quot;ForestGreen&quot;: &quot;#228b22&quot;,  }  for key, value := range colors {      fmt.Printf(&quot;Key: %s  Value: %s\n&quot;, key, value)  }  removeColor(colors, &quot;Coral&quot;)  for key, value := range colors {      fmt.Printf(&quot;Key: %s  Value: %s\n&quot;, key, value)  }}func removeColor(colors map[string]string, key string) {    delete(colors, key)}</code></pre><p>执行会得到以下结果：</p><pre><code>Key: AliceBlue Value: #F0F8FFKey: Coral Value: #FF7F50Key: DarkGray Value: #A9A9A9Key: ForestGreen Value: #228B22Key: AliceBlue Value: #F0F8FFKey: DarkGray Value: #A9A9A9Key: ForestGreen Value: #228B22</code></pre><p>可以看出来传递 map 也是十分廉价的，类似 slice。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Go 语言本身是不提供 set 的，但是我们可以自己实现它，下面就来试试：</p><pre><code>package mainimport(  &quot;fmt&quot;  &quot;sync&quot;)type Set struct {  m map[int]bool  sync.RWMutex}func New() *Set {  return &amp;Set{    m: map[int]bool{},  }}func (s *Set) Add(item int) {  s.Lock()  defer s.Unlock()  s.m[item] = true}func (s *Set) Remove(item int) {  s.Lock()  s.Unlock()  delete(s.m, item)}func (s *Set) Has(item int) bool {  s.RLock()  defer s.RUnlock()  _, ok := s.m[item]  return ok}func (s *Set) Len() int {  return len(s.List())}func (s *Set) Clear() {  s.Lock  defer s.Unlock()  s.m = map[int]bool{}}func (s *Set) IsEmpty() bool {  if s.Len() == 0 {    return true  }  return false}func (s *Set) List() []int {  s.RLock()  defer s.RUnlock()  list := []int{}  for item := range s.m {    list = append(list, item)  }  return list}func main() {  // 初始化  s := New()  s.Add(1)  s.Add(1)  s.Add(2)  s.Clear()  if s.IsEmpty() {    fmt.Println(&quot;0 item&quot;)  }  s.Add(1)  s.Add(2)  s.Add(3)  if s.Has(2) {    fmt.Println(&quot;2 does exist&quot;)  }  s.Remove(2)  s.Remove(3)  fmt.Println(&quot;list of all items&quot;, S.List())}</code></pre><ul><li>注意我们只是使用了 int 作为键，你可以自己实现用 interface{} 作为键，做成更通用的 Set，另外，这个实现是线程安全的。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>数组是 slice 和 map 的底层结构。</li><li>slice 是 Go 里面惯用的集合数据的方法，map 则是用来存储键值对。</li><li>内建函数 make 用来创建 slice 和 map，并且为它们指定长度和容量等等。slice 和 map 字面值也可以做同样的事。</li><li>slice 有容量的约束，不过可以通过内建函数 append 来增加元素。</li><li>map 没有容量一说，所以也没有任何增长限制。</li><li>内建函数 len 可以用来获得 slice 和 map 的长度。</li><li>内建函数 cap 只能作用在 slice 上。</li><li>可以通过组合方式来创建多维数组和 slice。map 的值可以是 slice 或者另一个 map。slice 不能作为 map 的键。</li><li>在函数之间传递 slice 和 map 是相当廉价的，因为他们不会传递底层数组的拷贝。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go语言中和其他语言一样，存在数组，Map(iOS中的字典)，但是还有一个比较特殊的Slice，他其实底层还是数组，今天我们来简单说说Go语言中的Array、Slice、Map和Set&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://icocos.github.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="https://icocos.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Array、Slice、Map、Set" scheme="https://icocos.github.io/tags/Array%E3%80%81Slice%E3%80%81Map%E3%80%81Set/"/>
    
  </entry>
  
  <entry>
    <title>Golang知识图谱</title>
    <link href="https://icocos.github.io/2018/05/10/Golang%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    <id>https://icocos.github.io/2018/05/10/Golang知识图谱/</id>
    <published>2018-05-10T02:49:12.000Z</published>
    <updated>2018-08-06T18:33:42.390Z</updated>
    
    <content type="html"><![CDATA[<p>一张图介绍Golang知识图谱，查漏补缺，还能装逼</p><a id="more"></a><p><img src="http://pd1l3bbt7.bkt.clouddn.com/18addimags/Golang/05/golangallstudydata.png" alt="曹理鹏(iCocos)-梦工厂"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一张图介绍Golang知识图谱，查漏补缺，还能装逼&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://icocos.github.io/categories/Go/"/>
    
    
      <category term="Go基础" scheme="https://icocos.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Golang知识图谱" scheme="https://icocos.github.io/tags/Golang%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
  </entry>
  
</feed>
