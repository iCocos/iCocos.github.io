<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iCocos</title>
  
  <subtitle>www.icocos.cn</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://icocos.github.io/"/>
  <updated>2019-05-22T09:04:41.409Z</updated>
  <id>https://icocos.github.io/</id>
  
  <author>
    <name>曹理鹏@iCocos</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>架构篇——MySQL高可用集群(PXC)详解</title>
    <link href="https://icocos.github.io/2019/06/11/%E6%9E%B6%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4-PXC-%E8%AF%A6%E8%A7%A3/"/>
    <id>https://icocos.github.io/2019/06/11/架构篇——MySQL高可用集群-PXC-详解/</id>
    <published>2019-06-11T09:56:41.000Z</published>
    <updated>2019-05-22T09:04:41.409Z</updated>
    
    <content type="html"><![CDATA[<h5 id="在介绍PXC之前，先来看一个相关的技术：MyCat"><a href="#在介绍PXC之前，先来看一个相关的技术：MyCat" class="headerlink" title="在介绍PXC之前，先来看一个相关的技术：MyCat"></a>在介绍PXC之前，先来看一个相关的技术：MyCat</h5><h3 id="MyCat简介"><a href="#MyCat简介" class="headerlink" title="MyCat简介"></a>MyCat简介</h3><p>MyCat是阿里开源的分布式数据库分库分表中间件</p><blockquote><p>MyCat是一个开源的分布式数据库系统，是一个实现了MySQL协议的服务器，前端用户可以把它看作是一个数据库代理，用MySQL客户端工具和命令行访问，而其后端可以用MySQL原生协议与多个MySQL服务器通信，也可以用JDBC协议与大多数主流数据库服务器通信</p></blockquote><h4 id="MyCat功能"><a href="#MyCat功能" class="headerlink" title="MyCat功能:"></a>MyCat功能:</h4><ul><li>数据库读写分离(写操作在主,读操作在从数据库)</li><li>读的负载均衡(一主多从)</li><li>垂直拆分(将表分开为多个数据库)</li><li>水平拆分(对表取模拆分)</li></ul><a id="more"></a><blockquote><p>MyCAT是mysql中间件，前身是阿里大名鼎鼎的Cobar，Cobar在开源了一段时间后，不了了之。于是MyCAT扛起了这面大旗，在大数据时代，其重要性愈发彰显。这篇文章主要是MyCAT的入门部署。</p></blockquote><ul><li>更多相关可以参考这里：<a href="https://www.jianshu.com/p/c6e29d724fca" target="_blank" rel="noopener">https://www.jianshu.com/p/c6e29d724fca</a></li></ul><p>下面是MyCat结合PXC的架构图</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2019/phps/pxc.png"></p><h3 id="PXC简介"><a href="#PXC简介" class="headerlink" title="PXC简介"></a>PXC简介</h3><p>PXC是percona公司的percona  xtraDB  cluster，简称PXC。它是基于Galera协议的高可用集群方案。可以实现多个节点间的数据同步复制以及读写，并且可保障数据库的服务高可用及数据强一致性。</p><blockquote><p>PXC就属于一套近乎完美的MySQL高可用集群架构方案；</p></blockquote><h5 id="主要特点是：-读写强一致性-牺牲性能"><a href="#主要特点是：-读写强一致性-牺牲性能" class="headerlink" title="主要特点是： 读写强一致性(牺牲性能)"></a>主要特点是： 读写强一致性(牺牲性能)</h5><h5 id="PXC特性"><a href="#PXC特性" class="headerlink" title="PXC特性"></a>PXC特性</h5><ul><li>1）同步复制，事务要么在所有节点提交或不提交。</li><li>2）多主复制，可以在任意节点进行写操作。</li><li>3）在从服务器上并行应用事件，真正意义上的并行复制。</li><li>4）节点自动配置，数据一致性，不再是异步复制。</li></ul><p>PXC最大的优势：强一致性、无同步延迟</p><ul><li><p>优点总结：</p><ul><li>服务高可用</li><li>可以达到时时同步(并发复制)，无延迟现象发生</li><li>完全兼容MySQL</li><li>对于集群中新节点的加入(自动部署)，维护起来很简单</li><li>数据的强一致性</li><li>多个可同时读写节点，可实现写扩展，不过最好事先进行分库分表，让各个节点分别写不同的表或者库，避免让galera解决数据冲突；</li></ul></li><li><p>不足之处总结：</p><ul><li>只支持Innodb存储引擎</li><li>存在多节点update更新问题，也就是写放大问题</li><li>在线DDL语句，锁表问题</li><li>sst针对新节点加入的传输代价过高的问题</li><li>所有表都要有主键；</li><li>不支持LOCK TABLE等显式锁操作；</li><li>锁冲突、死锁问题相对更多；</li><li>不支持XA；</li></ul></li></ul><p>事实上，采用PXC的主要目的是解决数据的一致性问题，高可用是顺带实现的。因为PXC存在写扩大以及短板效应，并发效率会有较大损失，类似semi sync replication机制。</p><pre><code>网络说明基于Galere协议的高可用方案：pxc+ Galera是Codership提供的多主数据同步复制机制，可以实现多个节点间的数据同步复制以及读写，并且+ 可保障数据库的服务高可用及数据一致性。+ 基于Galera的高可用方案主要有MariaDB Galera Cluster和Percona XtraDB Cluster（简称PXC），目前PXC用的会比较多一些。+ mariadb的集群原理跟PXC一样,maridb-cluster其实就是PXC，两者原理是一样的。</code></pre><h3 id="PXC原理"><a href="#PXC原理" class="headerlink" title="PXC原理"></a>PXC原理</h3><p>Percona XtraDB Cluster（简称PXC集群）提供了MySQL高可用的一种实现方法。</p><ul><li>1）集群是有节点组成的，推荐配置至少3个节点，但是也可以运行在2个节点上。</li><li>2）每个节点都是普通的mysql/percona服务器，可以将现有的数据库服务器组成集群，反之，也可以将集群拆分成单独的服务器。</li><li>3）每个节点都包含完整的数据副本。</li></ul><p>PXC集群主要由两部分组成：Percona Server with XtraDB和Write Set Replication patches（使用了Galera library，一个通用的用于事务型应用的同步、多主复制插件）。</p><p>PXC会使用大概是4个端口号</p><ul><li>3306 数据库对外服务的端口号</li><li>4444 请求SST SST: 指数据一个镜象传输 xtrabackup , rsync ,mysqldump </li><li>4567 : 组成员之间进行沟通的一个端口号</li><li>4568 : 传输IST用的。相对于SST来说的一个增量。</li></ul><blockquote><p>注：安装PXC过程中， iptables 禁掉 ，selinux 也禁掉</p></blockquote><h3 id="PXC的操作流程："><a href="#PXC的操作流程：" class="headerlink" title="PXC的操作流程："></a>PXC的操作流程：</h3><ul><li>首先客户端先发起一个事务，该事务先在本地执行，执行完成之后就要发起对事务的提交操作了。</li><li>在提交之前需要将产生的复制写集广播出去，然后获取到一个全局的事务ID号，一并传送到另一个节点上面。</li><li>通过合并数据之后，发现没有冲突数据，执行apply_cd和commit_cb动作，否则就需要取消此次事务的操作。</li><li>当前server节点通过验证之后，执行提交操作，并返回OK，如果验证没通过，则执行回滚。</li><li>在生产中至少要有3个节点的集群环境，如果其中一个节点没有验证通过，出现了数据冲突，那么此时采取的方式就是讲出现不一致的节点踢出集群环境，而且它自己会执行shutdown命令，自动关机。</li></ul><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>部署环境： CentOS7.X</p><h5 id="1、执行-命令-vi-etc-selinux-config"><a href="#1、执行-命令-vi-etc-selinux-config" class="headerlink" title="1、执行 命令   vi /etc/selinux/config"></a>1、执行 命令   vi /etc/selinux/config</h5><pre><code>SELINUX=disabled   #修改该项为disabled</code></pre><h5 id="2、执行命令-setenforce-0"><a href="#2、执行命令-setenforce-0" class="headerlink" title="2、执行命令   setenforce 0"></a>2、执行命令   setenforce 0</h5><h5 id="3、查看防火墙是否开启-systemctl-status-firewalld"><a href="#3、查看防火墙是否开启-systemctl-status-firewalld" class="headerlink" title="3、查看防火墙是否开启     systemctl status firewalld"></a>3、查看防火墙是否开启     systemctl status firewalld</h5><p>如果防火墙是开启状态，则开放端口 3306 、4444、4567、4568</p><pre><code>firewall-cmd --add-port=3306/tcp --permanent     #开放了3306端口</code></pre><p>开放完4个端口后，重新加载防火墙规则</p><pre><code>firewall-cmd --reload</code></pre><h5 id="4、安装Persona仓库"><a href="#4、安装Persona仓库" class="headerlink" title="4、安装Persona仓库"></a>4、安装Persona仓库</h5><pre><code>yum install http://www.percona.com/downloads/percona-release/redhat/0.1-4/percona-release-0.1-4.noarch.rpm</code></pre><h5 id="5、安装PXC（保证服务器没有装MySQL）卸载MySQL-参考链接：https-blog-csdn-net-tjcyjd-article-details-52189182"><a href="#5、安装PXC（保证服务器没有装MySQL）卸载MySQL-参考链接：https-blog-csdn-net-tjcyjd-article-details-52189182" class="headerlink" title="5、安装PXC（保证服务器没有装MySQL）卸载MySQL 参考链接：https://blog.csdn.net/tjcyjd/article/details/52189182"></a>5、安装PXC（保证服务器没有装MySQL）卸载MySQL 参考链接：<a href="https://blog.csdn.net/tjcyjd/article/details/52189182" target="_blank" rel="noopener">https://blog.csdn.net/tjcyjd/article/details/52189182</a></h5><pre><code>yum install Percona-XtraDB-Cluster-57</code></pre><h5 id="6、开启PXC服务"><a href="#6、开启PXC服务" class="headerlink" title="6、开启PXC服务"></a>6、开启PXC服务</h5><pre><code>service mysql start</code></pre><h5 id="7、查看安装数据库的临时密码并记住"><a href="#7、查看安装数据库的临时密码并记住" class="headerlink" title="7、查看安装数据库的临时密码并记住"></a>7、查看安装数据库的临时密码并记住</h5><pre><code>grep &apos;temporary password&apos; /var/log/mysqld.log</code></pre><h5 id="8、登录MySQL数据库"><a href="#8、登录MySQL数据库" class="headerlink" title="8、登录MySQL数据库"></a>8、登录MySQL数据库</h5><pre><code>mysql -u root -p</code></pre><p>输入临时密码, 登录成功后修改密码</p><pre><code>ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;你的密码&apos;;</code></pre><h5 id="9、停止MySQL服务"><a href="#9、停止MySQL服务" class="headerlink" title="9、停止MySQL服务"></a>9、停止MySQL服务</h5><pre><code>service mysql stop   （某些版本使用mysqld）</code></pre><h5 id="10、配置节点"><a href="#10、配置节点" class="headerlink" title="10、配置节点"></a>10、配置节点</h5><pre><code>vi  /etc/percona-xtradb-cluster.conf.d/wsrep.cnf</code></pre><p>修改配置文件</p><pre><code># Cluster connection URL contains IPs of nodes#If no IP is found, this implies that a new cluster needs to be created,#in order to do that you need to bootstrap this node#集群中节点的IP地址（本机填最后）wsrep_cluster_address=gcomm://ip地址,IP地址,IP地址（用,号隔开）# In order for Galera to work correctly binlog format should be ROWbinlog_format=ROW# MyISAM storage engine has only experimental supportdefault_storage_engine=InnoDB# Slave thread to usewsrep_slave_threads= 8wsrep_log_conflicts# This changes how InnoDB autoincrement locks are managed and is a requirement for Galerainnodb_autoinc_lock_mode=2# Node IP address#当前节点IPwsrep_node_address=IP地址# Cluster name#集群名称wsrep_cluster_name=pxc-cluster#If wsrep_node_name is not specified,  then system hostname will be used#当前节点名称wsrep_node_name=pxc-cluster-node-1#pxc_strict_mode allowed values: DISABLED,PERMISSIVE,ENFORCING,MASTER#不使用实验功能pxc_strict_mode=ENFORCING# SST method#状态快照传输（sst）方法，官方建议wsrep_sst_method=xtrabackup-v2#Authentication for SST method#用户凭证（mysql的用户名和密码）wsrep_sst_auth=&quot;用户名:密码&quot;</code></pre><p>剩下的节点修改当前节点名、当前节点IP、集群中的节点IP，其他相同</p><blockquote><p>注：1—10步骤  每个节点都要配置一次</p></blockquote><h5 id="11、初始化集群节点"><a href="#11、初始化集群节点" class="headerlink" title="11、初始化集群节点"></a>11、初始化集群节点</h5><p>其中一个节点使用 systemctl start <a href="mailto:mysql@bootstrap.service" target="_blank" rel="noopener">mysql@bootstrap.service</a> 启动</p><h6 id="登录mysql"><a href="#登录mysql" class="headerlink" title="登录mysql"></a>登录mysql</h6><pre><code>mysql -u root -p</code></pre><p>开启 wsrep_causal_reads</p><pre><code>set wsrep_causal_reads =1;</code></pre><h5 id="12、创建配置文件中对应的用户"><a href="#12、创建配置文件中对应的用户" class="headerlink" title="12、创建配置文件中对应的用户"></a>12、创建配置文件中对应的用户</h5><blockquote><p>所有节点的IP都要创建</p></blockquote><p>创建用户：    </p><pre><code>CREATE USER &apos;用户名&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;密码&apos;;  </code></pre><p>刷新权限：   </p><pre><code>GRANT all privileges ON *.* TO &apos;用户名&apos;@&apos;localhost&apos; ;FLUSH PRIVILEGES;</code></pre><p>创建用户：</p><pre><code>CREATE USER &apos;用户名&apos;@&apos;当前需要访问数据库的IP地址&apos; IDENTIFIED BY &apos;密码&apos;;  </code></pre><p>刷新权限：</p><pre><code>GRANT all privileges ON *.* TO &apos;用户名&apos;@&apos;当前节点IP地址&apos; ;FLUSH PRIVILEGES;</code></pre><h5 id="13、其他节点使用-service-mysql-start-启动-，登录mysql，配置wsrep-causal-reds，set-wsrep-causal-reads-1"><a href="#13、其他节点使用-service-mysql-start-启动-，登录mysql，配置wsrep-causal-reds，set-wsrep-causal-reads-1" class="headerlink" title="13、其他节点使用   service mysql start  启动 ，登录mysql，配置wsrep_causal_reds，set wsrep_causal_reads =1;"></a>13、其他节点使用   service mysql start  启动 ，登录mysql，配置wsrep_causal_reds，set wsrep_causal_reads =1;</h5><h5 id="14、其他节点启动成功后在引导节点（使用-systemctl-start-mysql-bootstrap-service-命令启动的节点）"><a href="#14、其他节点启动成功后在引导节点（使用-systemctl-start-mysql-bootstrap-service-命令启动的节点）" class="headerlink" title="14、其他节点启动成功后在引导节点（使用 systemctl start mysql@bootstrap.service 命令启动的节点）"></a>14、其他节点启动成功后在引导节点（使用 systemctl start <a href="mailto:mysql@bootstrap.service" target="_blank" rel="noopener">mysql@bootstrap.service</a> 命令启动的节点）</h5><p>验证集群：</p><pre><code>show status like &apos;wsrep%&apos;;  </code></pre><h5 id="15、节点数据同步验证"><a href="#15、节点数据同步验证" class="headerlink" title="15、节点数据同步验证"></a>15、节点数据同步验证</h5><p>在当前节点创建一个数据库 </p><pre><code>CREATE DATABASE percona;</code></pre><p>启动其他节点的数据库服务，进去后会发现新建的数据库，同理 其他节点创建的数据  当前节点也能看到</p><p>注意：服务的启动和停止要对应</p><pre><code>service mysql stop   ------&gt;  启动时用service mysql start</code></pre><p>或者 </p><pre><code>systemctl stop mysql@bootstrap.service   -----&gt;  启用是用 systemctl start mysql@bootstrap.service </code></pre><ul><li>更多相关实战配置可以参考这里：<a href="https://www.jianshu.com/p/0b7c050dfab6" target="_blank" rel="noopener">https://www.jianshu.com/p/0b7c050dfab6</a></li></ul><h5 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h5><ul><li>带你玩转Mysql高可用方案–PXC<ul><li><a href="https://blog.csdn.net/zisefeizhu/article/details/81873466" target="_blank" rel="noopener">https://blog.csdn.net/zisefeizhu/article/details/81873466</a></li></ul></li><li><p>Docker搭建PXC集群</p><ul><li><a href="https://blog.csdn.net/weixin_41141219/article/details/82767832" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41141219/article/details/82767832</a></li></ul></li><li><p>MySQL高可用方案－PXC环境部署记录: 详细教程</p><ul><li><a href="http://www.cnblogs.com/kevingrace/p/5685371.html" target="_blank" rel="noopener">http://www.cnblogs.com/kevingrace/p/5685371.html</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;在介绍PXC之前，先来看一个相关的技术：MyCat&quot;&gt;&lt;a href=&quot;#在介绍PXC之前，先来看一个相关的技术：MyCat&quot; class=&quot;headerlink&quot; title=&quot;在介绍PXC之前，先来看一个相关的技术：MyCat&quot;&gt;&lt;/a&gt;在介绍PXC之前，先来看一个相关的技术：MyCat&lt;/h5&gt;&lt;h3 id=&quot;MyCat简介&quot;&gt;&lt;a href=&quot;#MyCat简介&quot; class=&quot;headerlink&quot; title=&quot;MyCat简介&quot;&gt;&lt;/a&gt;MyCat简介&lt;/h3&gt;&lt;p&gt;MyCat是阿里开源的分布式数据库分库分表中间件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MyCat是一个开源的分布式数据库系统，是一个实现了MySQL协议的服务器，前端用户可以把它看作是一个数据库代理，用MySQL客户端工具和命令行访问，而其后端可以用MySQL原生协议与多个MySQL服务器通信，也可以用JDBC协议与大多数主流数据库服务器通信&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;MyCat功能&quot;&gt;&lt;a href=&quot;#MyCat功能&quot; class=&quot;headerlink&quot; title=&quot;MyCat功能:&quot;&gt;&lt;/a&gt;MyCat功能:&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;数据库读写分离(写操作在主,读操作在从数据库)&lt;/li&gt;
&lt;li&gt;读的负载均衡(一主多从)&lt;/li&gt;
&lt;li&gt;垂直拆分(将表分开为多个数据库)&lt;/li&gt;
&lt;li&gt;水平拆分(对表取模拆分)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="MySQL" scheme="https://icocos.github.io/tags/MySQL/"/>
    
      <category term="PXC集群" scheme="https://icocos.github.io/tags/PXC%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>架构篇——MySQL主从复制(Master-Slave)详解</title>
    <link href="https://icocos.github.io/2019/06/09/%E6%9E%B6%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-Master-Slave-%E8%AF%A6%E8%A7%A3/"/>
    <id>https://icocos.github.io/2019/06/09/架构篇——MySQL主从复制-Master-Slave-详解/</id>
    <published>2019-06-09T09:55:42.000Z</published>
    <updated>2019-05-22T09:04:36.347Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h3><p>Mysql主从又叫Replication、AB复制(不同于PXC)。简单讲就是A与B两台机器做主从后，在A上写数据，另外一台B也会跟着写数据，实现数据实时同步</p><blockquote><p>mysql主从是基于binlog，主上需开启binlog才能进行主从</p></blockquote><h5 id="主从过程大概有3个步骤"><a href="#主从过程大概有3个步骤" class="headerlink" title="主从过程大概有3个步骤"></a>主从过程大概有3个步骤</h5><ul><li>主将更改操作记录到binlog里</li><li>从将主的binlog事件（sql语句） 同步本机上并记录在relaylog里</li><li>从根据relaylog里面的sql语句按顺序执行</li></ul><a id="more"></a><h4 id="主从作用"><a href="#主从作用" class="headerlink" title="主从作用"></a>主从作用</h4><pre><code>实时灾备，用于故障切换读写分离，提供查询服务备份，避免影响业务</code></pre><h4 id="主从形式"><a href="#主从形式" class="headerlink" title="主从形式"></a>主从形式</h4><ul><li>一主一从</li><li>主主复制</li><li>一主多从—扩展系统读取的性能，因为读是在从库读取的</li><li>多主一从—5.7版本开始支持</li><li>联级复制</li></ul><p>MySQL数据库自身提供的主从复制功能可以方便的实现数据的多处自动备份，实现数据库的拓展。多个数据备份不仅可以加强数据的安全性，通过实现读写分离还能进一步提升数据库的负载性能。</p><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><blockquote><p>MySQL之间数据复制的基础是二进制日志文件（binary log file）。一台MySQL数据库一旦启用二进制日志后，其作为master，它的数据库中所有操作都会以“事件”的方式记录在二进制日志中，其他数据库作为slave通过一个I/O线程与主服务器保持通信，并监控master的二进制日志文件的变化，如果发现master二进制日志文件发生变化，则会把变化复制到自己的中继日志中，然后slave的一个SQL线程会把相关的“事件”执行到自己的数据库中，以此实现从数据库和主数据库的一致性，也就实现了主从复制。</p></blockquote><ul><li>主库将所有的写操作记录在binlog日志中，并生成log dump线程，将binlog日志传给从库的I/O线程</li><li>从库生成两个线程，一个是I/O线程，另一个是SQL线程</li><li>I/O线程去请求主库的binlog日志，并将binlog日志中的文件写入relay log（中继日志）中</li><li>SQL线程会读取relay loy中的内容，并解析成具体的操作，来实现主从的操作一致，达到最终数据一致的目的</li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>实现MySQL主从复制需要进行的配置：</p><ul><li><p>主服务器：</p><ul><li>开启二进制日志</li><li>配置唯一的server-id</li><li>获得master二进制日志文件名及位置</li><li>创建一个用于slave和master通信的用户账号</li></ul></li><li><p>从服务器：</p><ul><li>配置唯一的server-id</li><li>使用master分配的用户账号读取master二进制日志</li><li>启用slave服务</li></ul></li></ul><h4 id="具体实现过程如下："><a href="#具体实现过程如下：" class="headerlink" title="具体实现过程如下："></a>具体实现过程如下：</h4><p>主从复制配置步骤：</p><ul><li>确保从数据库与主数据库里的数据一致</li><li>在主数据库里创建一个同步账户授权给从数据库使用</li><li>配合主数据库（修改配置文件）</li><li>配置从数据库（修改配置文件）</li></ul><h5 id="一、准备工作："><a href="#一、准备工作：" class="headerlink" title="一、准备工作："></a>一、准备工作：</h5><ol><li>主从数据库版本最好一致</li><li>主从数据库内数据保持一致</li></ol><p>搭建两台MYSQL服务器，一台作为主服务器，一台作为从服务器，主服务器进行写操作，从服务器进行读操作</p><pre><code>+ 主数据库：192.168.0.1 /Linux-MySQL+ 从数据库：192.168.0.2 /Linux-MySQL</code></pre><h5 id="二、主数据库master修改："><a href="#二、主数据库master修改：" class="headerlink" title="二、主数据库master修改："></a>二、主数据库master修改：</h5><p>1.修改mysql配置</p><p>找到主数据库的配置文件my.cnf(或者my.ini)，我的在/etc/mysql/my.cnf,在[mysqld]部分插入如下两行：</p><pre><code>[mysqld]log-bin=mysql-bin #开启二进制日志server-id=1 #设置server-id</code></pre><p>2.重启mysql，创建用于同步的用户账号</p><p>打开mysql会话shell</p><pre><code>mysql -hlocalhost -uname -ppassword</code></pre><p>创建用户：用户：rel1密码：slavepass</p><p>3.授权</p><p>主服务器授权从服务器特定账号登录</p><pre><code>mysql&gt; CREATE USER &apos;repl&apos;@&apos;192.168.0.2&apos; IDENTIFIED BY &apos;slavepass&apos;;#创建用户mysql&gt; GRANT REPLICATION SLAVE ON *.* TO &apos;repl&apos;@&apos;192.168.0.2&apos;;#分配权限mysql&gt;flush privileges;   #刷新权限</code></pre><p>4.查看master状态，记录二进制文件名(mysql-bin.000003)和位置(73)：</p><pre><code>mysql &gt; SHOW MASTER STATUS;+------------------+----------+--------------+------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |+------------------+----------+--------------+------------------+| mysql-bin.000003 | 73       | test         | manual,mysql     |+------------------+----------+--------------+------------------+</code></pre><h5 id="三、从服务器slave修改："><a href="#三、从服务器slave修改：" class="headerlink" title="三、从服务器slave修改："></a>三、从服务器slave修改：</h5><p>1.修改mysql配置</p><p>同样找到my.cnf配置文件，添加server-id</p><pre><code>[mysqld]server-id=2 #设置server-id，必须唯一</code></pre><p>2.重启mysql，打开mysql会话，执行同步SQL语句(需要主服务器主机名，登陆凭据，二进制文件的名称和位置)：<br>复制代码</p><pre><code>mysql&gt; CHANGE MASTER TO    -&gt;     MASTER_HOST=&apos;192.168.0.1&apos;,    -&gt;     MASTER_USER=&apos;rep1&apos;,    -&gt;     MASTER_PASSWORD=&apos;slavepass&apos;,    -&gt;     MASTER_LOG_FILE=&apos;mysql-bin.000003&apos;,    -&gt;     MASTER_LOG_POS=73;</code></pre><p>3.启动slave同步进程：</p><pre><code>mysql&gt;start slave;</code></pre><p>4.查看slave状态：</p><pre><code>mysql&gt; show slave status\G;*************************** 1. row ***************************               Slave_IO_State: Waiting for master to send event                  Master_Host: 192.168.0.1                  Master_User: rep1                  Master_Port: 3306                Connect_Retry: 60              Master_Log_File: mysql-bin.000013          Read_Master_Log_Pos: 11662               Relay_Log_File: mysqld-relay-bin.000022                Relay_Log_Pos: 11765        Relay_Master_Log_File: mysql-bin.000013             Slave_IO_Running: Yes            Slave_SQL_Running: Yes              Replicate_Do_DB:           Replicate_Ignore_DB:         ...</code></pre><p>当Slave_IO_Running和Slave_SQL_Running都为YES的时候就表示主从同步设置成功了。</p><p>接下来就可以进行一些验证了，比如在主master数据库的test数据库的一张表中插入一条数据，在slave的test库的相同数据表中查看是否有新增的数据即可验证主从复制功能是否有效，还可以关闭slave（mysql&gt;stop slave;）,然后再修改master，看slave是否也相应修改（停止slave后，master的修改不会同步到slave），就可以完成主从复制功能的验证了。</p><p>还可以用到的其他相关参数：</p><blockquote><p>master开启二进制日志后默认记录所有库所有表的操作，可以通过配置来指定只记录指定的数据库甚至指定的表的操作，具体在mysql配置文件的[mysqld]可添加修改如下选项：</p></blockquote><pre><code># 不同步哪些数据库  binlog-ignore-db = mysql  binlog-ignore-db = test  binlog-ignore-db = information_schema  # 只同步哪些数据库，除此之外，其他不同步  binlog-do-db = game  </code></pre><blockquote><p>如之前查看master状态时就可以看到只记录了test库，忽略了manual和mysql库。</p></blockquote><h3 id="操作流程汇总"><a href="#操作流程汇总" class="headerlink" title="操作流程汇总"></a>操作流程汇总</h3><h5 id="关闭防火墙以SELINUX"><a href="#关闭防火墙以SELINUX" class="headerlink" title="关闭防火墙以SELINUX"></a>关闭防火墙以SELINUX</h5><pre><code>[root@icocos ~]# systemctl stop firewalld[root@icocos ~]# systemctl disable firewalld[root@icocos ~]#  sed -ri &apos;s/(SELINUX=).*/\1disabled/g&apos; /etc/selinux/config[root@icocos ~]# setenforce 0</code></pre><h5 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h5><pre><code>安装依赖包[root@icocos ~]# yum -y install ncurses-devel openssl-devel openssl cmake mariadb-devel</code></pre><h5 id="创建用户和组"><a href="#创建用户和组" class="headerlink" title="创建用户和组"></a>创建用户和组</h5><pre><code>[root@icocos ~]# groupadd -r -g 306 mysql[root@icocos ~]# useradd -M -s /sbin/nologin -g 306 -u 306 mysql</code></pre><h5 id="下载二进制格式的mysql软件包"><a href="#下载二进制格式的mysql软件包" class="headerlink" title="下载二进制格式的mysql软件包"></a>下载二进制格式的mysql软件包</h5><pre><code>[root@icocos ~]# cd /usr/src/[root@icocos src]#wget https://downloads.mysql.com/archives/get/file/mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz</code></pre><h5 id="解压软件至-usr-local"><a href="#解压软件至-usr-local" class="headerlink" title="解压软件至/usr/local/"></a>解压软件至/usr/local/</h5><pre><code>[root@icocos src]# lsdebug  kernels  mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz[root@icocos src]# tar xf mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz -C /usr/local/[root@icocos src]#  ls  /usr/local/bin  etc  games  include  lib  lib64  libexec  mysql-5.7.22-linux-glibc2.12-x86_64  sbin  share  src[root@icocos src]#  cd  /usr/local/[root@icocos local]# ln -sv mysql-5.7.22-linux-glibc2.12-x86_64/ mysql&quot;mysql&quot; -&gt; &quot;mysql-5.7.22-linux-glibc2.12-x86_64/&quot;[root@icocos local]# ll总用量 0drwxr-xr-x. 2 root root   6 11月  5 2016 bindrwxr-xr-x. 2 root root   6 11月  5 2016 etcdrwxr-xr-x. 2 root root   6 11月  5 2016 gamesdrwxr-xr-x. 2 root root   6 11月  5 2016 includedrwxr-xr-x. 2 root root   6 11月  5 2016 libdrwxr-xr-x. 2 root root   6 11月  5 2016 lib64drwxr-xr-x. 2 root root   6 11月  5 2016 libexeclrwxrwxrwx. 1 root root  36 9月   7 22:20 mysql -&gt; mysql-5.7.22-linux-glibc2.12-x86_64/drwxr-xr-x. 9 root root 129 9月   7 22:19 mysql-5.7.22-linux-glibc2.12-x86_64drwxr-xr-x. 2 root root   6 11月  5 2016 sbindrwxr-xr-x. 5 root root  49 9月   3 23:02 sharedrwxr-xr-x. 2 root root   6 11月  5 2016 src</code></pre><h5 id="修改目录-usr-locaal-mysql的属主属组"><a href="#修改目录-usr-locaal-mysql的属主属组" class="headerlink" title="修改目录/usr/locaal/mysql的属主属组"></a>修改目录/usr/locaal/mysql的属主属组</h5><pre><code>[root@icocos local]# chown -R mysql.mysql /usr/local/mysql[root@icocos local]#  ll /usr/local/mysql -dlrwxrwxrwx. 1 mysql mysql 36 9月   7 22:20 /usr/local/mysql -&gt; mysql-5.7.22-linux-glibc2.12-x86_64/</code></pre><h5 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h5><pre><code>[root@icocos local]# ls /usr/local/mysqlbin  COPYING  docs  include  lib  man  README  share  support-files[root@icocos local]# cd[root@icocos ~]# echo &apos;export PATH=/usr/local/mysql/bin:$PATH&apos; &gt; /etc/profile.d/mysql.sh[root@icocos ~]# . /etc/profile.d/mysql.sh[root@icocos ~]# echo $PATH/usr/local/mysql/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</code></pre><h5 id="建立数据存放目录"><a href="#建立数据存放目录" class="headerlink" title="建立数据存放目录"></a>建立数据存放目录</h5><pre><code>[root@icocos ~]# cd /usr/local/mysql[root@icocos mysql]# mkdir /opt/data[root@icocos mysql]#  chown -R mysql.mysql /opt/data/[root@icocos mysql]#  ll /opt/总用量 0drwxr-xr-x. 2 mysql mysql 6 9月   7 22:25 data</code></pre><h5 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h5><pre><code>[root@icocos mysql]# /usr/local/mysql/bin/mysqld --initialize --user=mysql --datadir=/opt/data///这个命令的最后会生成一个临时密码，此处密码是1EbNA-k*BtKo</code></pre><h5 id="配置mysql"><a href="#配置mysql" class="headerlink" title="配置mysql"></a>配置mysql</h5><pre><code>[root@icocos ~]# ln -sv /usr/local/mysql/include/ /usr/local/include/mysql&quot;/usr/local/include/mysql&quot; -&gt; &quot;/usr/local/mysql/include/&quot;[root@icocos ~]# echo &apos;/usr/local/mysql/lib&apos; &gt; /etc/ld.so.conf.d/mysql.conf[root@icocos ~]#  ldconfig -v</code></pre><h5 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h5><pre><code>[root@icocos ~]# cat &gt; /etc/my.cnf &lt;&lt;EOF&gt; [mysqld]&gt; basedir = /usr/local/mysql&gt; datadir = /opt/data&gt; socket = /tmp/mysql.sock&gt; port = 3306&gt; pid-file = /opt/data/mysql.pid&gt; user = mysql&gt; skip-name-resolve&gt; EOF</code></pre><h5 id="配置服务启动脚本"><a href="#配置服务启动脚本" class="headerlink" title="配置服务启动脚本"></a>配置服务启动脚本</h5><pre><code>[root@icocos ~]# cp -a /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld[root@icocos ~]#  sed -ri &apos;s#^(basedir=).*#\1/usr/local/mysql#g&apos; /etc/init.d/mysqld[root@icocos ~]# sed -ri &apos;s#^(datadir=).*#\1/opt/data#g&apos; /etc/init.d/mysqld</code></pre><h5 id="启动mysql"><a href="#启动mysql" class="headerlink" title="启动mysql"></a>启动mysql</h5><pre><code>[root@icocos ~]#  service mysqld startStarting MySQL.Logging to &apos;/opt/data/icocos.err&apos;... SUCCESS![root@icocos ~]#  ps -ef|grep mysqlroot       4897      1  0 22:38 pts/2    00:00:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/opt/data --pid-file=/opt/data/mysql.pidmysql      5075   4897  6 22:38 pts/2    00:00:01 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/opt/data --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=icocos.err --pid-file=/opt/data/mysql.pid --socket=/tmp/mysql.sock --port=3306root       5109   4668  0 22:38 pts/2    00:00:00 grep --color=auto mysql[root@icocos ~]# ss -antlState       Recv-Q Send-Q                     Local Address:Port                                    Peer Address:Port              LISTEN      0      128                                    *:22                                                 *:*                  LISTEN      0      100                            127.0.0.1:25                                                 *:*                  LISTEN      0      128                                   :::22                                                :::*                  LISTEN      0      100                                  ::1:25                                                :::*                  LISTEN      0      80                                    :::3306                                              :::*                  </code></pre><h5 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h5><p>使用临时密码修改</p><pre><code>[root@icocos ~]# mysql -uroot -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.7.22Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; set password = password(&apos;123456&apos;);Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; quitBye</code></pre><h5 id="mysql主从配置"><a href="#mysql主从配置" class="headerlink" title="mysql主从配置"></a>mysql主从配置</h5><p>确保从数据库与主数据库的数据一样先在主数据库创建所需要同步的库和表</p><pre><code>[root@icocos ~]# mysql -uroot -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 4Server version: 5.7.22 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. AlOracle is a registered trademark of Oracle Corporation andaffiliates. Other names may be trademarks of their respectowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the currmysql&gt; create database yan;Query OK, 1 row affected (0.00 sec)mysql&gt; create database lisi;Query OK, 1 row affected (0.00 sec)mysql&gt; create database wangwu;Query OK, 1 row affected (0.00 sec)mysql&gt; use yan;Database changedmysql&gt; create table tom (id int not null,name varchar(100)not null ,age tinyint);Query OK, 0 rows affected (11.83 sec)mysql&gt; insert tom (id,name,age) values(1,&apos;zhangshan&apos;,20),(2,&apos;wangwu&apos;,7),(3,&apos;lisi&apos;,23);Query OK, 3 rows affected (0.07 sec)Records: 3  Duplicates: 0  Warnings: 0mysql&gt; select * from tom;+----+-----------+------+| id | name      | age  |+----+-----------+------+|  1 | zhangshan |   20 ||  2 | wangwu    |    7 ||  3 | lisi      |   23 |+----+-----------+------+3 rows in set (0.00 sec)</code></pre><h5 id="备份主库"><a href="#备份主库" class="headerlink" title="备份主库"></a>备份主库</h5><p>备份主库时需要另开一个终端，给数据库上读锁，避免在备份期间有其他人在写入导致数据同步的不一致</p><pre><code>[root@icocos ~]# mysql -uroot -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 5Server version: 5.7.22 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; flush tables with read lock;Query OK, 0 rows affected (0.76 sec)</code></pre><p>此锁表的终端必须在备份完成以后才能退出（退出锁表失效）</p><h5 id="备份主库并将备份文件传送到从库"><a href="#备份主库并将备份文件传送到从库" class="headerlink" title="备份主库并将备份文件传送到从库"></a>备份主库并将备份文件传送到从库</h5><pre><code>[root@icocos ~]# mysqldump -uroot -p123456 --all-databases &gt; /opt/all-20180907.sqlmysqldump: [Warning] Using a password on the command line interface can be insecure.[root@icocos ~]# ls /opt/all-20180907.sql  data[root@icocos ~]# scp /opt/all-20180907.sql root@192.168.0.2:/opt/The authenticity of host &apos;192.168.0.2 (192.168.0.2)&apos; can&apos;t be established.ECDSA key fingerprint is SHA256:7mLj77SFk7sPkhjpMPfdK3nZ98hOuyP4OKzjXeijSJ0.ECDSA key fingerprint is MD5:a0:1b:eb:7f:f0:b6:7b:73:97:91:4c:f3:b1:89:d8:ea.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;192.168.0.2&apos; (ECDSA) to the list of known hosts.root@192.168.0.2&apos;s password:all-20180907.sql       100%  784KB 783.3KB/s   00:01    </code></pre><h5 id="解除主库的锁表状态，直接退出交互式界面即可"><a href="#解除主库的锁表状态，直接退出交互式界面即可" class="headerlink" title="解除主库的锁表状态，直接退出交互式界面即可"></a>解除主库的锁表状态，直接退出交互式界面即可</h5><pre><code>mysql&gt; quitBye</code></pre><h5 id="在从库上恢复主库的备份并查看是否与主库的数据保持一致"><a href="#在从库上恢复主库的备份并查看是否与主库的数据保持一致" class="headerlink" title="在从库上恢复主库的备份并查看是否与主库的数据保持一致"></a>在从库上恢复主库的备份并查看是否与主库的数据保持一致</h5><pre><code>[root@icocos ~]# mysql -uroot -p123456 &lt; /opt/all-20180907.sqlmysql: [Warning] Using a password on the command line interface can be insecure.[root@icocos ~]# mysql -uroot -p123456mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 4Server version: 5.7.22 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || lisi               || mysql              || performance_schema || sys                || wangwu             || yan                |+--------------------+7 rows in set (0.18 sec)mysql&gt; use yan;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; select * from tom;+----+-----------+------+| id | name      | age  |+----+-----------+------+|  1 | zhangshan |   20 ||  2 | wangwu    |    7 ||  3 | lisi      |   23 |+----+-----------+------+3 rows in set (0.06 sec)</code></pre><h5 id="在主数据库创建一个同步账户授权给从数据使用"><a href="#在主数据库创建一个同步账户授权给从数据使用" class="headerlink" title="在主数据库创建一个同步账户授权给从数据使用"></a>在主数据库创建一个同步账户授权给从数据使用</h5><pre><code>[root@icocos ~]# mysql -uroot -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 7Server version: 5.7.22 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; create user &apos;repl&apos;@&apos;192.168.0.2&apos; identified by &apos;123456&apos;;Query OK, 0 rows affected (5.50 sec)mysql&gt; grant replication slave on *.* to &apos;repl&apos;@&apos;192.168.0.2&apos;;Query OK, 0 rows affected (0.04 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.09 sec)</code></pre><h5 id="配置主数据库编辑配置文件"><a href="#配置主数据库编辑配置文件" class="headerlink" title="配置主数据库编辑配置文件"></a>配置主数据库编辑配置文件</h5><pre><code>[root@icocos ~]# vim /etc/my.cnf[root@icocos ~]# cat /etc/my.cnf[mysqld]basedir = /usr/local/mysqldatadir = /opt/datasocket = /tmp/mysql.sockport = 3306pid-file = /opt/data/mysql.piduser = mysqlskip-name-resolve//添加以下内容log-bin=mysql-bin //启用binlog日志server-id=1 //主数据库服务器唯一标识符 主的必须必从大log-error=/opt/data/mysql.log</code></pre><h5 id="重启mysql服务"><a href="#重启mysql服务" class="headerlink" title="重启mysql服务"></a>重启mysql服务</h5><pre><code>[root@icocos ~]# service mysqld restartShutting down MySQL..... SUCCESS!Starting MySQL.Logging to &apos;/opt/data/mysql.log&apos;................................ SUCCESS![root@icocos ~]# ss -antlState       Recv-Q Send-Q Local Address:Port               Peer Address:Port              LISTEN      0      128     *:22                  *:*                  LISTEN      0      100    127.0.0.1:25                  *:*                  LISTEN      0      128    :::22                 :::*                  LISTEN      0      100       ::1:25                 :::*                  LISTEN      0      80     :::3306               :::*</code></pre><h5 id="查看主库的状态"><a href="#查看主库的状态" class="headerlink" title="查看主库的状态"></a>查看主库的状态</h5><pre><code>mysql&gt; show master status;+------------------+----------+--------------+------------------+-------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+------------------+----------+--------------+------------------+-------------------+| mysql-bin.000001 |      154 |              |                  |                   |+------------------+----------+--------------+------------------+-------------------+1 row in set (0.00 sec)</code></pre><h5 id="配置从数据库"><a href="#配置从数据库" class="headerlink" title="配置从数据库"></a>配置从数据库</h5><p>编辑配置文件</p><pre><code>[root@icocos ~]# cat /etc/my.cnf[mysqld]basedir = /usr/local/mysqldatadir = /opt/datasocket = /tmp/mysql.sockport = 3306pid-file = /opt/data/mysql.piduser = mysqlskip-name-resolve//添加以下内容：server-id=2 //设置从库的唯一标识符 从的必须比主小relay-log=mysql-relay-bin //启用中继日志relay logerror-log=/opt/data/mysql.log</code></pre><h5 id="重启从库的mysql服务"><a href="#重启从库的mysql服务" class="headerlink" title="重启从库的mysql服务"></a>重启从库的mysql服务</h5><pre><code>[root@icocos ~]# service mysqld restartShutting down MySQL.. SUCCESS!Starting MySQL.. SUCCESS![root@icocos ~]# ss -antlState       Recv-Q Send-Q Local Address:Port               Peer Address:Port              LISTEN      0      128     *:22                  *:*                  LISTEN      0      100    127.0.0.1:25                  *:*                  LISTEN      0      128    :::22                 :::*                  LISTEN      0      100       ::1:25                 :::*                  LISTEN      0      80     :::3306               :::*                  </code></pre><h5 id="配置并启动主从复制"><a href="#配置并启动主从复制" class="headerlink" title="配置并启动主从复制"></a>配置并启动主从复制</h5><pre><code>mysql&gt; change master to    -&gt; master_host=&apos;192.168.0.1&apos;,    -&gt; master_user=&apos;repl&apos;,    -&gt; master_password=&apos;123456&apos;,    -&gt; master_log_file=&apos;mysql-bin.000001&apos;,    -&gt; master_log_pos=154;Query OK, 0 rows affected, 2 warnings (0.28 sec)</code></pre><h5 id="查看从服务器状态"><a href="#查看从服务器状态" class="headerlink" title="查看从服务器状态"></a>查看从服务器状态</h5><pre><code>mysql&gt; show slave status\G;*************************** 1. row ***************************               Slave_IO_State: Waiting for master to send event                  Master_Host: 192.168.0.1                  Master_User: repl                  Master_Port: 3306                Connect_Retry: 60              Master_Log_File: mysql-bin.000001          Read_Master_Log_Pos: 154               Relay_Log_File: mysql-relay-bin.000003                Relay_Log_Pos: 320        Relay_Master_Log_File: mysql-bin.000001             Slave_IO_Running: Yes                                     //此处必须是yes            Slave_SQL_Running: Yes                                    //此处必须是yes                     Replicate_Do_DB:          Replicate_Ignore_DB:           Replicate_Do_Table:       Replicate_Ignore_Table:      Replicate_Wild_Do_Table:  Replicate_Wild_Ignore_Table:                   Last_Errno: 0                   Last_Error:                 Skip_Counter: 0          Exec_Master_Log_Pos: 154              Relay_Log_Space: 527              Until_Condition: None               Until_Log_File:                Until_Log_Pos: 0           Master_SSL_Allowed: No           Master_SSL_CA_File:           Master_SSL_CA_Path:              Master_SSL_Cert:            Master_SSL_Cipher:               Master_SSL_Key:        Seconds_Behind_Master: 0Master_SSL_Verify_Server_Cert: No                Last_IO_Errno: 0                Last_IO_Error:               Last_SQL_Errno: 0               Last_SQL_Error:  Replicate_Ignore_Server_Ids:             Master_Server_Id: 1                  Master_UUID: 5abf1791-b2af-11e8-b6ad-000c2980fbb4             Master_Info_File: /opt/data/master.info                    SQL_Delay: 0          SQL_Remaining_Delay: NULL      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates           Master_Retry_Count: 86400                  Master_Bind:      Last_IO_Error_Timestamp:     Last_SQL_Error_Timestamp:               Master_SSL_Crl:           Master_SSL_Crlpath:           Retrieved_Gtid_Set:            Executed_Gtid_Set:                Auto_Position: 0         Replicate_Rewrite_DB:                 Channel_Name:           Master_TLS_Version:1 row in set (0.00 sec)ERROR:No query specified</code></pre><h5 id="测试验证在主服务器的yan库的tom表插入数据"><a href="#测试验证在主服务器的yan库的tom表插入数据" class="headerlink" title="测试验证在主服务器的yan库的tom表插入数据:"></a>测试验证在主服务器的yan库的tom表插入数据:</h5><pre><code>mysql&gt; use yan;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; select * from tom;+----+-----------+------+| id | name      | age  |+----+-----------+------+|  1 | zhangshan |   20 ||  2 | wangwu    |    7 ||  3 | lisi      |   23 |+----+-----------+------+3 rows in set (0.09 sec)mysql&gt; insert tom(id,name,age) value (4,&quot;yyl&quot;,18);Query OK, 1 row affected (0.14 sec)mysql&gt; select * from tom;+----+-----------+------+| id | name      | age  |+----+-----------+------+|  1 | zhangshan |   20 ||  2 | wangwu    |    7 ||  3 | lisi      |   23 ||  4 | yyl       |   18 |+----+-----------+------+4 rows in set (0.00 sec)</code></pre><h5 id="在从数据库查看是否数据同步"><a href="#在从数据库查看是否数据同步" class="headerlink" title="在从数据库查看是否数据同步"></a>在从数据库查看是否数据同步</h5><pre><code>mysql&gt; use yan;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; select * from tom;+----+-----------+------+| id | name      | age  |+----+-----------+------+|  1 | zhangshan |   20 ||  2 | wangwu    |    7 ||  3 | lisi      |   23 ||  4 | yyl       |   18 |+----+-----------+------+4 rows in set (0.00 sec)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;主从&quot;&gt;&lt;a href=&quot;#主从&quot; class=&quot;headerlink&quot; title=&quot;主从&quot;&gt;&lt;/a&gt;主从&lt;/h3&gt;&lt;p&gt;Mysql主从又叫Replication、AB复制(不同于PXC)。简单讲就是A与B两台机器做主从后，在A上写数据，另外一台B也会跟着写数据，实现数据实时同步&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mysql主从是基于binlog，主上需开启binlog才能进行主从&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;主从过程大概有3个步骤&quot;&gt;&lt;a href=&quot;#主从过程大概有3个步骤&quot; class=&quot;headerlink&quot; title=&quot;主从过程大概有3个步骤&quot;&gt;&lt;/a&gt;主从过程大概有3个步骤&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;主将更改操作记录到binlog里&lt;/li&gt;
&lt;li&gt;从将主的binlog事件（sql语句） 同步本机上并记录在relaylog里&lt;/li&gt;
&lt;li&gt;从根据relaylog里面的sql语句按顺序执行&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="MySQL" scheme="https://icocos.github.io/tags/MySQL/"/>
    
      <category term="主从复制" scheme="https://icocos.github.io/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>MySQL锁机制和PHP锁机制</title>
    <link href="https://icocos.github.io/2019/06/06/MySQL%E9%94%81%E6%9C%BA%E5%88%B6%E5%92%8CPHP%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>https://icocos.github.io/2019/06/06/MySQL锁机制和PHP锁机制/</id>
    <published>2019-06-06T10:47:41.000Z</published>
    <updated>2019-05-27T02:39:08.392Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PHP中的文件锁-（锁的是文件，不是表）"><a href="#PHP中的文件锁-（锁的是文件，不是表）" class="headerlink" title="PHP中的文件锁 （锁的是文件，不是表）"></a>PHP中的文件锁 （锁的是文件，不是表）</h3><p>文件锁的文件与表有什么关系？：一点关系也没有，与令牌相似，谁拿到谁操作。所以表根本没锁。<br>测试时，有个文件就行，叫什么名无所谓</p><p>bool flock ( int handle, int operation [, int &amp;wouldblock] );<br>flock() 操作的 handle 必须是一个已经打开的文件指针。operation 可以是以下值之一：</p><ul><li>要取得共享锁定（读取程序），将 operation 设为 LOCK_SH（PHP 4.0.1 以前的版本设置为 1）</li><li>要取得独占锁定（写入程序），将 operation 设为 LOCK_EX（PHP 4.0.1 以前的版本中设置为 2）</li><li>要释放锁定（无论共享或独占），将 operation 设为 LOCK_UN（PHP 4.0.1 以前的版本中设置为 3）</li><li>如果你不希望 flock() 在锁定时堵塞，则给 operation 加上 LOCK_NB（PHP 4.0.1 以前的版本中设置为4）</li></ul><a id="more"></a><h4 id="建两个文件"><a href="#建两个文件" class="headerlink" title="建两个文件"></a>建两个文件</h4><!--more--><h5 id="1-a-php"><a href="#1-a-php" class="headerlink" title="(1) a.php"></a>(1) a.php</h5><pre><code>$file = &quot;temp.txt&quot;;   $fp = fopen($file , &apos;w&apos;);   if(flock($fp , LOCK_EX)){        fwrite($fp , &quot;abc\n&quot;);        sleep(10);        fwrite($fp , &quot;123\n&quot;);       flock($fp , LOCK_UN);   }   fclose($fp);  </code></pre><h5 id="2-b-php"><a href="#2-b-php" class="headerlink" title="(2) b.php"></a>(2) b.php</h5><pre><code>$file = &quot;temp.txt&quot;;   $fp = fopen($file , &apos;r&apos;);   echo fread($fp , 100);   fclose($fp);  </code></pre><p>运行 a.php 后，马上运行 b.php ，可以看到输出：</p><pre><code>abc</code></pre><p>等 a.php 运行完后运行 b.php ，可以看到输出：</p><pre><code>abc123</code></pre><p>显然，当 a.php 写文件时数据太大，导致时间比较长时，这时 b.php 读取数据不完整</p><p>修改 b.php 为：</p><pre><code>$file = &quot;temp.txt&quot;;   $fp = fopen($file , &apos;r&apos;);   if(flock($fp , LOCK_EX)){       echo fread($fp , 100);       flock($fp , LOCK_UN);   } else{       echo &quot;Lock file failed...\n&quot;;   }   fclose($fp);  </code></pre><p>运行 a.php 后，马上运行 b.php ，可以发现 b.php 会等到 a.php 运行完成后(即 10 秒后)才显示：</p><pre><code>abc123</code></pre><p>读取数据完整，但时间过长，他要等待写锁释放。</p><p>修改 b.php 为：</p><pre><code>$file = &quot;temp.txt&quot;;   $fp = fopen($file , &apos;r&apos;);   if(flock($fp , LOCK_SH | LOCK_NB)){       echo fread($fp , 100);       flock($fp , LOCK_UN);   } else{       echo &quot;Lock file failed...\n&quot;;   }   fclose($fp);  </code></pre><p>运行 a.php 后，马上运行 b.php ，可以看到输出：<br>    Lock file failed…</p><p>证明可以返回锁文件失败状态，而不是向上面一样要等很久。</p><h5 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h5><blockquote><p>建议作文件缓存时，选好相关的锁，不然可能导致读取数据不完整，或重复写入数据。<br>file_get_contents 好像选择不了锁，不知道他默认用的什么锁，反正和不锁得到的输出一样，是不完整的数据。</p></blockquote><p>我是要做文件缓存，所以只需要知道是否有写锁存在即可，有的话就查数据库就可以了。<br>测试环境：Linux(Ubuntu 6) , PHP 5.1.2 , Apache 2</p><h5 id="再转："><a href="#再转：" class="headerlink" title="再转："></a>再转：</h5><p>文件锁有两种：共享锁和排他锁，也就是读锁(LOCK_SH)和写锁(LOCK_EX)<br>文件的锁一般这么使用：</p><pre><code>$fp = fopen(&quot;filename&quot;, &quot;a&quot;);   flock($fp, LOCK_SH) or die(&quot;lock error&quot;)   $str = fread($fp, 1024);   flock($fp, LOCK_UN);   fclose($fp);  </code></pre><blockquote><p>注意fwrite之后，文件立即就被更新了，而不是等fwrite然后fclose之后文件才会更新，这个可以通过在fwrite之后fclose之前读取这个文件进行检查 </p></blockquote><p>但是什么时候使用lock_ex什么时候使用lock_sh呢？ </p><h5 id="读的时候："><a href="#读的时候：" class="headerlink" title="读的时候："></a>读的时候：</h5><p>如果不想出现dirty数据，那么最好使用lock_sh共享锁。可以考虑以下三种情况： </p><ol><li>如果读的时候没有加共享锁，那么其他程序要写的话（不管这个写是加锁还是不加锁）都会立即写成功。如果正好读了一半，然后被其他程序给写了，那么读的后一半就有可能跟前一半对不上（前一半是修改前的，后一半是修改后的） </li><li>如果读的时候加上了共享锁（因为只是读，没有必要使用排他锁），这个时候，其他程序开始写，这个写程序没有使用锁，那么写程序会直接修改这个文件，也会导致前面一样的问题 </li><li>最理想的情况是，读的时候加锁(lock_sh),写的时候也进行加锁(lock_ex),这样写程序会等着读程序完成之后才进行操作，而不会出现贸然操作的情况 </li></ol><h5 id="写的时候："><a href="#写的时候：" class="headerlink" title="写的时候："></a>写的时候：</h5><p>如果多个写程序不加锁同时对文件进行操作，那么最后的数据有可能一部分是a程序写的，一部分是b程序写的<br>如果写的时候加锁了，这个时候有其他的程序来读，那么他会读到什么东西呢？ </p><ol><li>如果读程序没有申请共享锁，那么他会读到dirty的数据。比如写程序要写a,b,c三部分，写完a,这时候读读到的是a，继续写b，这时候读读到的是ab，然后写c，这时候读到的是abc. </li><li>如果读程序在之前申请了共享锁，那么读程序会等写程序将abc写完并释放锁之后才进行读。</li></ol><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>项目中应该只使用PHP中的文件锁，尽量避免锁表，因为如果表被锁定了，那么整个网站中所有和这个表相关的功能都被拖慢了（例如：前台很多用户一直下订单，商品表mysql锁表，其他与商品表相关的操作一直处于阻塞状态【读不出来商品表】，因为一个功能把整个网站速度拖慢）。</p><blockquote><p> 比如在一个O2O外卖项目中，中午12-2点，晚上6点都是订单高并发时，这种情况下，MySQL锁显然是不考虑的，用户体验太差。其实根据实际的需求，外卖可以不用设计库存量的，当然除了秒杀活动模块还是需要php文件锁的。</p></blockquote><p>应用场景：</p><ol><li>高并发下单时，减库存量时要加锁</li><li>高并发抢单、抢票时要使用</li></ol><p>MySQL锁示例代码：</p><pre><code>&lt;?php /**模拟秒杀活动-- 商品100件CREATE TABLE a(    id int comment &apos;模拟100件活动商品的数量&apos;);INSERT INTO a VALUES(100);模仿：以10的并发量访问这个脚本！    使用apache自带的ab.exe软件 */ error_reporting(0); mysql_connect(&apos;localhost&apos;,&apos;root&apos;,&apos;admin123&apos;); mysql_select_db(&apos;test&apos;); # mysql 锁 mysql_query(&apos;LOCK TABLE a WRITE&apos;);// 只有一个客户端可以锁定表，其他客户端阻塞在这 $rs = mysql_query(&apos;SELECT id FROM a&apos;); $id = mysql_result($rs, 0, 0); if($id &gt; 0) {     --$id;     mysql_query(&apos;UPDATE a SET id=&apos;.$id); } # mysql 解锁 mysql_query(&apos;UNLOCK TABLES&apos;);</code></pre><p>PHP文件锁示例代码：</p><pre><code>&lt;?php /**模拟秒杀活动-- 商品100件CREATE TABLE a(    id int comment &apos;模拟100件活动商品的数量&apos;);INSERT INTO a VALUES(100);模仿：以10的并发量访问这个脚本！    使用apache自带的ab.exe软件 */ error_reporting(0); mysql_connect(&apos;localhost&apos;,&apos;root&apos;,&apos;admin123&apos;); mysql_select_db(&apos;test&apos;); # php中的文件锁 $fp = fopen(&apos;./a.lock&apos;, &apos;r&apos;); // php的文件锁和表没关系，随便一个文件即可 flock($fp, LOCK_EX);// 排他锁 $rs = mysql_query(&apos;SELECT id FROM a&apos;); $id = mysql_result($rs, 0, 0); if($id &gt; 0) {     --$id;     mysql_query(&apos;UPDATE a SET id=&apos;.$id); } # php的文件锁，释放锁 flock($fp, LOCK_UN); fclose($fp);</code></pre><h3 id="MYSQL中的锁："><a href="#MYSQL中的锁：" class="headerlink" title="MYSQL中的锁："></a>MYSQL中的锁：</h3><p>语法 ：<br>LOCK TABLE 表名1 READ|WRITE, 表名2 READ|WRITE ……………… 【锁表】<br>UNLOCK TABLES  【释放表】</p><ul><li>Read:读锁|共享锁 ： 所有的客户端只能读这个表不能写这个表</li><li>Write:写锁|排它锁： 所有当前锁定客户端可以操作这个表，其他客户端只能阻塞</li></ul><blockquote><p>注意：在锁表的过程中只能操作被锁定的表，如果要操作其他表，必须把所有要操作的表都锁定起来！</p></blockquote><h5 id="1-表级锁定（table-level）"><a href="#1-表级锁定（table-level）" class="headerlink" title="1.表级锁定（table-level）"></a>1.表级锁定（table-level）</h5><p>表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并大度大打折扣。使用表级锁定的主要是MyISAM等一些非事务性存储引擎。</p><h5 id="2-行级锁定（row-level）"><a href="#2-行级锁定（row-level）" class="headerlink" title="2.行级锁定（row-level）"></a>2.行级锁定（row-level）</h5><p>行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。<br>虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。使用行级锁定的主要是InnoDB存储引擎。</p><h5 id="3-页级锁定（page-level）"><a href="#3-页级锁定（page-level）" class="headerlink" title="3.页级锁定（page-level）"></a>3.页级锁定（page-level）</h5><p>页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。<br>在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。</p><h5 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h5><ul><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；  </li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；    </li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。  </li></ul><p>适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</p><h3 id="二、表级锁定"><a href="#二、表级锁定" class="headerlink" title="二、表级锁定"></a>二、表级锁定</h3><p>在mysql中，MyISAM引擎使用的锁定机制完全是mysql的表级锁定，下面将以MYISAM引擎作为示例</p><h5 id="1-MySQL表级锁的模式"><a href="#1-MySQL表级锁的模式" class="headerlink" title="1.MySQL表级锁的模式"></a>1.MySQL表级锁的模式</h5><blockquote><p>MySQL的表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。  </p></blockquote><ul><li>兼容性：  <ul><li>对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；  </li><li>对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；  </li><li>MyISAM表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。</li></ul></li></ul><h5 id="2-加锁"><a href="#2-加锁" class="headerlink" title="2.加锁"></a>2.加锁</h5><blockquote><p>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。</p></blockquote><h5 id="3-MyISAM锁的优化"><a href="#3-MyISAM锁的优化" class="headerlink" title="3.MyISAM锁的优化"></a>3.MyISAM锁的优化</h5><blockquote><p>对于MyISAM存储引擎，虽然使用表级锁定在锁定实现的过程中比实现行级锁定或者页级锁所带来的附加成本都要小，锁定本身所消耗的资源也是最少。但是由于锁定的颗粒度比较到，所以造成锁定资源的争用情况也会比其他的锁定级别都要多，从而在较大程度上会降低并发处理能力。所以，在优化MyISAM存储引擎锁定问题的时候，最关键的就是如何让其提高并发度。由于锁定级别是不可能改变的了，所以我们首先需要尽可能让锁定的时间变短，然后就是让可能并发进行的操作尽可能的并发。</p></blockquote><ul><li>（1）查询表锁争用情况</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like &apos;table%&apos;;</span><br><span class="line">+----------------------------+---------+</span><br><span class="line">| Variable_name              | Value   |</span><br><span class="line">+----------------------------+---------+</span><br><span class="line">| Table_locks_immediate      | 100     |</span><br><span class="line">| Table_locks_waited         | 11      |</span><br><span class="line">+----------------------------+---------+</span><br></pre></td></tr></table></figure><p>这里有两个状态变量记录MySQL内部表级锁定的情况，两个变量说明如下：</p><ul><li>Table_locks_immediate：产生表级锁定的次数;  </li><li>Table_locks_waited：出现表级锁定争用而发生等待的次数；</li></ul><p>两个状态值都是从系统启动后开始记录，出现一次对应的事件则数量加1。如果这里的Table_locks_waited状态值比较高，那么说明系统中表级锁定争用现象比较严重，就需要进一步分析为什么会有较多的锁定资源争用了</p><ul><li>（2）缩短锁定时间</li></ul><p>如何让锁定时间尽可能的短呢？唯一的办法就是让我们的Query执行时间尽可能的短。</p><pre><code>+ a)尽两减少大的复杂Query，将复杂Query分拆成几个小的Query分布进行；  + b)尽可能的建立足够高效的索引，让数据检索更迅速；  + c)尽量让MyISAM存储引擎的表只存放必要的信息，控制字段类型；  + d)利用合适的机会优化MyISAM表数据文件</code></pre><ul><li>(3)分离并行的操作</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;PHP中的文件锁-（锁的是文件，不是表）&quot;&gt;&lt;a href=&quot;#PHP中的文件锁-（锁的是文件，不是表）&quot; class=&quot;headerlink&quot; title=&quot;PHP中的文件锁 （锁的是文件，不是表）&quot;&gt;&lt;/a&gt;PHP中的文件锁 （锁的是文件，不是表）&lt;/h3&gt;&lt;p&gt;文件锁的文件与表有什么关系？：一点关系也没有，与令牌相似，谁拿到谁操作。所以表根本没锁。&lt;br&gt;测试时，有个文件就行，叫什么名无所谓&lt;/p&gt;
&lt;p&gt;bool flock ( int handle, int operation [, int &amp;amp;wouldblock] );&lt;br&gt;flock() 操作的 handle 必须是一个已经打开的文件指针。operation 可以是以下值之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要取得共享锁定（读取程序），将 operation 设为 LOCK_SH（PHP 4.0.1 以前的版本设置为 1）&lt;/li&gt;
&lt;li&gt;要取得独占锁定（写入程序），将 operation 设为 LOCK_EX（PHP 4.0.1 以前的版本中设置为 2）&lt;/li&gt;
&lt;li&gt;要释放锁定（无论共享或独占），将 operation 设为 LOCK_UN（PHP 4.0.1 以前的版本中设置为 3）&lt;/li&gt;
&lt;li&gt;如果你不希望 flock() 在锁定时堵塞，则给 operation 加上 LOCK_NB（PHP 4.0.1 以前的版本中设置为4）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>PHP-高并发和大流量的解决方案</title>
    <link href="https://icocos.github.io/2019/06/03/PHP-%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%A7%E6%B5%81%E9%87%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://icocos.github.io/2019/06/03/PHP-高并发和大流量的解决方案/</id>
    <published>2019-06-03T10:47:41.000Z</published>
    <updated>2019-05-22T09:17:16.637Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-高并发的概念"><a href="#一-高并发的概念" class="headerlink" title="一  高并发的概念"></a>一  高并发的概念</h3><p>在互联网时代，并发，高并发通常是指并发访问。也就是在某个时间点，有多少个访问同时到来。</p><h3 id="二-高并发架构相关概念"><a href="#二-高并发架构相关概念" class="headerlink" title="二  高并发架构相关概念"></a>二  高并发架构相关概念</h3><ul><li>1、QPS (每秒查询率) : 每秒钟请求或者查询的数量，在互联网领域，指每秒响应请求数(指HTTP请求)</li><li>2、PV（Page View）：综合浏览量，即页面浏览量或者点击量，一个访客在24小时内访问的页面数量</li></ul><blockquote><p>–注：同一个人浏览你的网站的同一页面，只记做一次pv</p></blockquote><ul><li>3、吞吐量（fetches/sec） ：单位时间内处理的请求数量 （通常由QPS和并发数决定）</li><li>4、响应时间：从请求发出到收到响应花费的时间</li><li>5、独立访客（UV）：一定时间范围内，相同访客多次访问网站，只计算为1个独立访客</li><li>6、带宽：计算带宽需关注两个指标，峰值流量和页面的平均大小</li><li>7、日网站带宽： PV/统计时间（换算到秒） <em> 平均页面大小（kb）</em> 8</li></ul><a id="more"></a><h3 id="三-需要注意点："><a href="#三-需要注意点：" class="headerlink" title="三 需要注意点："></a>三 需要注意点：</h3><ul><li>1、QPS不等于并发连接数（QPS是每秒HTTP请求数量，并发连接数是系统同时处理的请求数量）</li><li>2、峰值每秒请求数（QPS）= （总PV数<em>80%）/ （六小时秒数</em>20%）【代表80%的访问量都集中在20%的时间内】</li><li>3、压力测试： 测试能承受的最大并发数 以及测试最大承受的QPS值</li><li>4、常用的性能测试工具【ab，wrk，httpload，Web Bench，Siege，Apache JMeter】</li></ul><h3 id="四-优化"><a href="#四-优化" class="headerlink" title="四 优化"></a>四 优化</h3><h5 id="1、当QPS小于50时"><a href="#1、当QPS小于50时" class="headerlink" title="1、当QPS小于50时"></a>1、当QPS小于50时</h5><p>​    优化方案:为一般小型网站,不用考虑优化</p><h5 id="2、当QPS达到100时-遇到数据查询瓶颈"><a href="#2、当QPS达到100时-遇到数据查询瓶颈" class="headerlink" title="2、当QPS达到100时,遇到数据查询瓶颈"></a>2、当QPS达到100时,遇到数据查询瓶颈</h5><p>​    优化方案: 数据库缓存层,数据库的负载均衡</p><h5 id="3、当QPS达到800时-遇到带宽瓶颈"><a href="#3、当QPS达到800时-遇到带宽瓶颈" class="headerlink" title="3、当QPS达到800时, 遇到带宽瓶颈"></a>3、当QPS达到800时, 遇到带宽瓶颈</h5><p>​    优化方案:CDN加速,负载均衡</p><h5 id="4、当QPS达到1000时"><a href="#4、当QPS达到1000时" class="headerlink" title="4、当QPS达到1000时"></a>4、当QPS达到1000时</h5><p>​    优化方案: 做html静态缓存</p><h5 id="5、当QPS达到2000时"><a href="#5、当QPS达到2000时" class="headerlink" title="5、当QPS达到2000时"></a>5、当QPS达到2000时</h5><p>​    优化方案: 做业务分离,分布式存储</p><h3 id="五、高并发解决方案案例"><a href="#五、高并发解决方案案例" class="headerlink" title="五、高并发解决方案案例:"></a>五、高并发解决方案案例:</h3><h5 id="1、流量优化"><a href="#1、流量优化" class="headerlink" title="1、流量优化"></a>1、流量优化</h5><p>​    防盗链处理(去除恶意请求)</p><h5 id="2、前端优化"><a href="#2、前端优化" class="headerlink" title="2、前端优化"></a>2、前端优化</h5><ul><li>(1) 减少HTTP请求[将css,js等合并]</li><li>(2) 添加异步请求(先不将所有数据都展示给用户,用户触发某个事件,才会异步请求数据)</li><li>(3) 启用浏览器缓存和文件压缩</li><li>(4) CDN加速</li><li>(5) 建立独立的图片服务器(减少I/O)</li></ul><h5 id="3、服务端优化"><a href="#3、服务端优化" class="headerlink" title="3、服务端优化"></a>3、服务端优化</h5><ul><li>(1) 页面静态化</li><li>(2) 并发处理</li><li>(3) 队列处理</li></ul><h5 id="4、数据库优化"><a href="#4、数据库优化" class="headerlink" title="4、数据库优化"></a>4、数据库优化</h5><ul><li>(1) 数据库缓存</li><li>(2) 分库分表,分区</li><li>(3) 读写分离</li><li>(4) 负载均衡</li></ul><h5 id="5、web服务器优化"><a href="#5、web服务器优化" class="headerlink" title="5、web服务器优化"></a>5、web服务器优化</h5><ul><li><p>(1) nginx反向代理实现负载均衡</p></li><li><p>(2) lvs实现负载均衡</p></li></ul><h5 id="关于海亮数据"><a href="#关于海亮数据" class="headerlink" title="关于海亮数据"></a>关于海亮数据</h5><p>业务场景, 每天产生百万左右的日志,总量过亿, 准即时分析</p><ol><li>不需要使用复杂的技术栈, PHP本身即可处理, 时间也可接受</li><li>可简单使用多开CLI进程的方式,每个CLI对应一个日志源, 不需要引入多线程之类的技术, 适合日志源较固定的业务场景.</li><li>提前过滤不需要保留的日志,如:爬虫, 业务中无用的日志, 我的业务场景 中可过滤掉90%的无效 日志</li><li>事先确认分析需求, 只根据需求对日志进行分析.  此处详解</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.我使用第三方UA解析库对 UA进行分析,结果详细,但占用CPU过高,处理时间不理想</span><br><span class="line"></span><br><span class="line">b.根据业务需求,只分析是否爬虫以及操作系统(android,iOS,其它), 这样分析速度提升一个数量级</span><br></pre></td></tr></table></figure><ol start="5"><li>多种PHP技术并用: 本地文件缓存, 精细设计断点续操作, 批量插入数据库, 人性化的界面输出.</li><li>对异常进行分析, 有些异常使用简单的延时重试即可处理.</li><li>最重要的, 是要相信PHP, 如果有PHP不能实现的功能 , 那只是因为你的水平不够, 而不是PHP的问题. </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-高并发的概念&quot;&gt;&lt;a href=&quot;#一-高并发的概念&quot; class=&quot;headerlink&quot; title=&quot;一  高并发的概念&quot;&gt;&lt;/a&gt;一  高并发的概念&lt;/h3&gt;&lt;p&gt;在互联网时代，并发，高并发通常是指并发访问。也就是在某个时间点，有多少个访问同时到来。&lt;/p&gt;
&lt;h3 id=&quot;二-高并发架构相关概念&quot;&gt;&lt;a href=&quot;#二-高并发架构相关概念&quot; class=&quot;headerlink&quot; title=&quot;二  高并发架构相关概念&quot;&gt;&lt;/a&gt;二  高并发架构相关概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;1、QPS (每秒查询率) : 每秒钟请求或者查询的数量，在互联网领域，指每秒响应请求数(指HTTP请求)&lt;/li&gt;
&lt;li&gt;2、PV（Page View）：综合浏览量，即页面浏览量或者点击量，一个访客在24小时内访问的页面数量&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;–注：同一个人浏览你的网站的同一页面，只记做一次pv&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;3、吞吐量（fetches/sec） ：单位时间内处理的请求数量 （通常由QPS和并发数决定）&lt;/li&gt;
&lt;li&gt;4、响应时间：从请求发出到收到响应花费的时间&lt;/li&gt;
&lt;li&gt;5、独立访客（UV）：一定时间范围内，相同访客多次访问网站，只计算为1个独立访客&lt;/li&gt;
&lt;li&gt;6、带宽：计算带宽需关注两个指标，峰值流量和页面的平均大小&lt;/li&gt;
&lt;li&gt;7、日网站带宽： PV/统计时间（换算到秒） &lt;em&gt; 平均页面大小（kb）&lt;/em&gt; 8&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>PHP书籍汇总与推荐</title>
    <link href="https://icocos.github.io/2019/06/01/PHP%E4%B9%A6%E7%B1%8D%E6%B1%87%E6%80%BB%E4%B8%8E%E6%8E%A8%E8%8D%90/"/>
    <id>https://icocos.github.io/2019/06/01/PHP书籍汇总与推荐/</id>
    <published>2019-06-01T14:22:18.000Z</published>
    <updated>2019-05-30T03:02:52.484Z</updated>
    
    <content type="html"><![CDATA[<h5 id="先来推荐一波我最近在看，和准备看的书籍或者文档"><a href="#先来推荐一波我最近在看，和准备看的书籍或者文档" class="headerlink" title="先来推荐一波我最近在看，和准备看的书籍或者文档"></a>先来推荐一波我最近在看，和准备看的书籍或者文档</h5><p>首先作为一个PHP开发人员，官方手册是必看的，没看过或者说不看都不算一个合格的PHP程序员</p><a id="more"></a><ul><li><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2019/books/docs.png"></li></ul><h3 id="关于MySQL"><a href="#关于MySQL" class="headerlink" title="关于MySQL"></a>关于MySQL</h3><ul><li><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2019/books/mysql01.png"></p></li><li><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2019/books/mysql02.png"></p></li><li><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2019/books/mysql03.png"></p></li><li><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2019/books/mysql04.png"></p></li></ul><h3 id="关于PHP"><a href="#关于PHP" class="headerlink" title="关于PHP"></a>关于PHP</h3><ul><li><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2019/books/php01.png"></li></ul><h3 id="关于实战优化"><a href="#关于实战优化" class="headerlink" title="关于实战优化"></a>关于实战优化</h3><ul><li><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2019/books/php02.png"></p></li><li><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2019/books/php03.png"></p></li></ul><h3 id="PHP底层原理"><a href="#PHP底层原理" class="headerlink" title="PHP底层原理"></a>PHP底层原理</h3><ul><li><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2019/books/tipi.png"></li></ul><h5 id="【初阶】（基础知识及入门）"><a href="#【初阶】（基础知识及入门）" class="headerlink" title="【初阶】（基础知识及入门）"></a>【初阶】（基础知识及入门）</h5><ol><li>《PHP与MySQL程序设计（第4版）》  <a href="http://item.jd.com/10701892.html" target="_blank" rel="noopener">http://item.jd.com/10701892.html</a></li><li>《深入浅出MySQL 数据库开发 优化与管理维护 第2版》 <a href="http://item.jd.com/11381295.html" target="_blank" rel="noopener">http://item.jd.com/11381295.html</a> </li><li>《实战Nginx：取代Apache的高性能Web服务器》 <a href="http://dwz.cn/2K1ryn" target="_blank" rel="noopener">http://dwz.cn/2K1ryn</a> </li><li>《Redis 实战》 <a href="http://item.jd.com/11791607.html" target="_blank" rel="noopener">http://item.jd.com/11791607.html</a> </li><li>《MongoDB权威指南 第2版》 <a href="http://item.jd.com/11384782.html" target="_blank" rel="noopener">http://item.jd.com/11384782.html</a></li><li>《Linux系统命令及Shell脚本实践指南》 <a href="http://item.jd.com/11354663.html" target="_blank" rel="noopener">http://item.jd.com/11354663.html</a></li></ol><!--more--><h5 id="【中阶】（基本系统知识相关，可阅读类似书籍）"><a href="#【中阶】（基本系统知识相关，可阅读类似书籍）" class="headerlink" title="【中阶】（基本系统知识相关，可阅读类似书籍）"></a>【中阶】（基本系统知识相关，可阅读类似书籍）</h5><ol><li>《图解HTTP》 <a href="http://item.jd.com/11449491.html" target="_blank" rel="noopener">http://item.jd.com/11449491.html</a></li><li>《图解TCP/IP 第5版》 <a href="http://item.jd.com/11253710.html" target="_blank" rel="noopener">http://item.jd.com/11253710.html</a></li><li>《大话设计模式》 <a href="http://item.jd.com/10079261.html" target="_blank" rel="noopener">http://item.jd.com/10079261.html</a></li><li>《大话数据结构》 <a href="http://item.jd.com/10663703.html" target="_blank" rel="noopener">http://item.jd.com/10663703.html</a></li><li>《编译原理（第2版）》 <a href="http://item.jd.com/10058776.html" target="_blank" rel="noopener">http://item.jd.com/10058776.html</a></li><li>《Linux C 编程一站式学习》 <a href="http://dwz.cn/2K1C3n" target="_blank" rel="noopener">http://dwz.cn/2K1C3n</a> </li><li>《PHP应用程序安全编程》 <a href="http://dwz.cn/2K317p" target="_blank" rel="noopener">http://dwz.cn/2K317p</a></li><li>《高性能PHP应用开发》  <a href="http://dwz.cn/2K1kcy" target="_blank" rel="noopener">http://dwz.cn/2K1kcy</a> </li><li>《PHP核心技术与最佳实践》 <a href="http://item.jd.com/11123177.html" target="_blank" rel="noopener">http://item.jd.com/11123177.html</a></li><li>《高性能MySQL（第3版）》 <a href="http://item.jd.com/11220393.html" target="_blank" rel="noopener">http://item.jd.com/11220393.html</a></li><li>《深入理解MariaDB与MySQL》  <a href="http://item.jd.com/11835700.html" target="_blank" rel="noopener">http://item.jd.com/11835700.html</a></li><li>《构建高可用Linux服务器（第3版）》 <a href="http://item.jd.com/11557939.html" target="_blank" rel="noopener">http://item.jd.com/11557939.html</a></li></ol><h5 id="【中高阶】（深入理解系统）"><a href="#【中高阶】（深入理解系统）" class="headerlink" title="【中高阶】（深入理解系统）"></a>【中高阶】（深入理解系统）</h5><ol><li>《深入理解计算机系统（原书第2版）》 <a href="http://item.jd.com/10360906.html" target="_blank" rel="noopener">http://item.jd.com/10360906.html</a></li><li>《现代操作系统（原书第3版）》  <a href="http://item.jd.com/10058893.html" target="_blank" rel="noopener">http://item.jd.com/10058893.html</a></li><li>《数据库系统概念（原书第6版）》 <a href="http://item.jd.com/10954261.html" target="_blank" rel="noopener">http://item.jd.com/10954261.html</a></li><li>《数据库系统实现（第2版）》 <a href="http://item.jd.com/10060181.html" target="_blank" rel="noopener">http://item.jd.com/10060181.html</a></li><li>《UNIX环境高级编程（第3版）》 <a href="http://item.jd.com/11469694.html" target="_blank" rel="noopener">http://item.jd.com/11469694.html</a></li><li>《UNIX网络编程 卷1 套接字联网API（第3版）》 <a href="http://item.jd.com/11728741.html" target="_blank" rel="noopener">http://item.jd.com/11728741.html</a></li><li>《Linux高性能服务器编程》 <a href="http://item.jd.com/11252777.html" target="_blank" rel="noopener">http://item.jd.com/11252777.html</a></li></ol><h5 id="【高阶】（深入理解服务原理）"><a href="#【高阶】（深入理解服务原理）" class="headerlink" title="【高阶】（深入理解服务原理）"></a>【高阶】（深入理解服务原理）</h5><ol><li>《深入理解PHP内核》 <a href="http://www.php-internals.com/book/" target="_blank" rel="noopener">http://www.php-internals.com/book/</a></li><li>《深入理解MySQL》 <a href="http://item.jd.com/10063042.html" target="_blank" rel="noopener">http://item.jd.com/10063042.html</a></li><li>《MySQL技术内幕：InnoDB存储引擎（第2版）》 <a href="http://item.jd.com/11252326.html" target="_blank" rel="noopener">http://item.jd.com/11252326.html</a> </li><li>《深入剖析Nginx》 <a href="http://item.jd.com/11226514.html" target="_blank" rel="noopener">http://item.jd.com/11226514.html</a></li><li>《深入理解Nginx：模块开发与架构解析》 <a href="http://item.jd.com/11217076.html" target="_blank" rel="noopener">http://item.jd.com/11217076.html</a> </li><li>《Redis设计与实现》 <a href="http://item.jd.com/11486101.html" target="_blank" rel="noopener">http://item.jd.com/11486101.html</a></li></ol><h5 id="【架构及升级】（Web架构、分布式、云计算、机器学习等方向）"><a href="#【架构及升级】（Web架构、分布式、云计算、机器学习等方向）" class="headerlink" title="【架构及升级】（Web架构、分布式、云计算、机器学习等方向）"></a>【架构及升级】（Web架构、分布式、云计算、机器学习等方向）</h5><ol><li>《大规模Web服务开发技术》 <a href="http://dwz.cn/2K2o1d" target="_blank" rel="noopener">http://dwz.cn/2K2o1d</a></li><li>《大型分布式网站架构设计与实践》 <a href="http://item.jd.com/11529266.html" target="_blank" rel="noopener">http://item.jd.com/11529266.html</a> </li><li>《大型网站技术架构 核心原理与案例分析》 <a href="http://item.jd.com/11322972.html" target="_blank" rel="noopener">http://item.jd.com/11322972.html</a></li><li>《大规模分布式系统架构与设计实战》 <a href="http://item.jd.com/11417660.html" target="_blank" rel="noopener">http://item.jd.com/11417660.html</a></li><li>《大规模分布式存储系统：原理解析与架构实战》 <a href="http://item.jd.com/11310547.html" target="_blank" rel="noopener">http://item.jd.com/11310547.html</a></li><li>《分布式系统：概念与设计（原书第5版）》 <a href="http://item.jd.com/11194499.html" target="_blank" rel="noopener">http://item.jd.com/11194499.html</a></li><li>《Hadoop权威指南（第3版 修订版）》 <a href="http://item.jd.com/11566298.html" target="_blank" rel="noopener">http://item.jd.com/11566298.html</a> </li><li><p>《Cassandra权威指南》 <a href="http://item.jd.com/10794341.html" target="_blank" rel="noopener">http://item.jd.com/10794341.html</a></p></li><li><p>《云计算架构技术与实践》 <a href="http://item.jd.com/11537731.html" target="_blank" rel="noopener">http://item.jd.com/11537731.html</a></p></li><li><p>《OpenStack开源云王者归来》 <a href="http://item.jd.com/11521443.html" target="_blank" rel="noopener">http://item.jd.com/11521443.html</a></p></li><li><p>《数据挖掘 概念与技术（原书第3版）》 <a href="http://item.jd.com/11056660.html" target="_blank" rel="noopener">http://item.jd.com/11056660.html</a> </p></li><li>《机器学习》 <a href="http://item.jd.com/10131321.html" target="_blank" rel="noopener">http://item.jd.com/10131321.html</a></li><li>《图解机器学习》 <a href="http://item.jd.com/11676112.html" target="_blank" rel="noopener">http://item.jd.com/11676112.html</a></li><li>《机器学习实战》 <a href="http://item.jd.com/11242112.html" target="_blank" rel="noopener">http://item.jd.com/11242112.html</a></li></ol><h5 id="【番外篇】（可以参考延展学习）"><a href="#【番外篇】（可以参考延展学习）" class="headerlink" title="【番外篇】（可以参考延展学习）"></a>【番外篇】（可以参考延展学习）</h5><ol><li>《深入PHP：面向对象、模式与实践（第3版）》 <a href="http://item.jd.com/10794350.html" target="_blank" rel="noopener">http://item.jd.com/10794350.html</a></li><li>《Linux网络编程（第2版）》 <a href="http://item.jd.com/11397772.html" target="_blank" rel="noopener">http://item.jd.com/11397772.html</a></li><li>《Linux多线程服务端编程 使用muduo C++网络库》 <a href="http://item.jd.com/11163782.html" target="_blank" rel="noopener">http://item.jd.com/11163782.html</a></li><li>《Linux运维之道》 <a href="http://item.jd.com/11375254.html" target="_blank" rel="noopener">http://item.jd.com/11375254.html</a></li><li>《Linux性能优化大师》 <a href="http://item.jd.com/11734651.html" target="_blank" rel="noopener">http://item.jd.com/11734651.html</a></li><li>《PostgreSQL修炼之道：从小工到专家》 <a href="http://item.jd.com/11684063.html" target="_blank" rel="noopener">http://item.jd.com/11684063.html</a> </li><li><p>《图解网络硬件》 <a href="http://item.jd.com/11506709.html" target="_blank" rel="noopener">http://item.jd.com/11506709.html</a> </p></li><li><p>《网络安全基础：网络攻防、协议与安全》 <a href="http://item.jd.com/10550797.html" target="_blank" rel="noopener">http://item.jd.com/10550797.html</a></p></li><li>《密码学原理与实践（第3版）》 <a href="http://item.jd.com/10067358.html" target="_blank" rel="noopener">http://item.jd.com/10067358.html</a></li><li>《黑客大曝光：网络安全机密与解决方案（第7版）》 <a href="http://item.jd.com/11307435.html" target="_blank" rel="noopener">http://item.jd.com/11307435.html</a></li><li><p>《黑客攻防技术宝典 Web实战篇 第2版》 <a href="http://item.jd.com/11020022.html" target="_blank" rel="noopener">http://item.jd.com/11020022.html</a></p></li><li><p>《精通正则表达式（第3版）》 <a href="http://item.jd.com/11070361.html" target="_blank" rel="noopener">http://item.jd.com/11070361.html</a></p></li><li>《Go语言编程》 <a href="http://item.jd.com/11067810.html" target="_blank" rel="noopener">http://item.jd.com/11067810.html</a></li><li>《Python基础教程（第2版 修订版）》 <a href="http://item.jd.com/11461683.html" target="_blank" rel="noopener">http://item.jd.com/11461683.html</a></li><li>《快学Scala》 <a href="http://item.jd.com/11113845.html" target="_blank" rel="noopener">http://item.jd.com/11113845.html</a></li><li>《Erlang/OTP并发编程实战》 <a href="http://item.jd.com/11037265.html" target="_blank" rel="noopener">http://item.jd.com/11037265.html</a></li><li>《函数式编程思维》 <a href="http://item.jd.com/11763847.html" target="_blank" rel="noopener">http://item.jd.com/11763847.html</a></li><li>《Android从入门到精通》 <a href="http://item.jd.com/11078112.html" target="_blank" rel="noopener">http://item.jd.com/11078112.html</a></li><li><p>《iOS开发指南》 <a href="http://item.jd.com/11681585.html" target="_blank" rel="noopener">http://item.jd.com/11681585.html</a></p></li><li><p>《搜索引擎：信息检索实践》 <a href="http://item.jd.com/10059723.html" target="_blank" rel="noopener">http://item.jd.com/10059723.html</a></p></li><li>《统计自然语言处理（第2版）》 <a href="http://item.jd.com/11314362.html" target="_blank" rel="noopener">http://item.jd.com/11314362.html</a></li><li>《这就是搜索引擎：核心技术详解》 <a href="http://item.jd.com/10893803.html" target="_blank" rel="noopener">http://item.jd.com/10893803.html</a></li><li>《Elasticsearch服务器开发（第2版）》 <a href="http://item.jd.com/11615450.html" target="_blank" rel="noopener">http://item.jd.com/11615450.html</a></li><li><p>《实战Elasticsearch、Logstash、Kibana》 <a href="http://item.jd.com/11706768.html" target="_blank" rel="noopener">http://item.jd.com/11706768.html</a></p></li><li><p>《推荐系统实践》 <a href="http://item.jd.com/11007625.html" target="_blank" rel="noopener">http://item.jd.com/11007625.html</a></p></li><li>《机器学习实践指南：案例应用解析》 <a href="http://item.jd.com/11447036.html" target="_blank" rel="noopener">http://item.jd.com/11447036.html</a> </li><li>《Hadoop实战（第2版）》 <a href="http://item.jd.com/11116710.html" target="_blank" rel="noopener">http://item.jd.com/11116710.html</a></li><li>《Hadoop大数据分析与挖掘实战》 <a href="http://item.jd.com/11837003.html" target="_blank" rel="noopener">http://item.jd.com/11837003.html</a></li><li>《Spark大数据处理：技术、应用与性能优化》 <a href="http://item.jd.com/11577088.html" target="_blank" rel="noopener">http://item.jd.com/11577088.html</a></li><li>《Spark机器学习》 <a href="http://item.jd.com/11763016.html" target="_blank" rel="noopener">http://item.jd.com/11763016.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;先来推荐一波我最近在看，和准备看的书籍或者文档&quot;&gt;&lt;a href=&quot;#先来推荐一波我最近在看，和准备看的书籍或者文档&quot; class=&quot;headerlink&quot; title=&quot;先来推荐一波我最近在看，和准备看的书籍或者文档&quot;&gt;&lt;/a&gt;先来推荐一波我最近在看，和准备看的书籍或者文档&lt;/h5&gt;&lt;p&gt;首先作为一个PHP开发人员，官方手册是必看的，没看过或者说不看都不算一个合格的PHP程序员&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="PHP面试题" scheme="https://icocos.github.io/tags/PHP%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>PHP闭包（Closure）初探</title>
    <link href="https://icocos.github.io/2019/05/24/PHP%E9%97%AD%E5%8C%85%EF%BC%88Closure%EF%BC%89%E5%88%9D%E6%8E%A2/"/>
    <id>https://icocos.github.io/2019/05/24/PHP闭包（Closure）初探/</id>
    <published>2019-05-24T10:47:41.000Z</published>
    <updated>2019-05-22T09:17:17.657Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉发现PHP已经出到了5.5版本，而自己一直在用PHP5.2，让我看起来像深山出来的小伙子一样，又土又落后。在我习惯在javascript中使用闭包之后，忽然间对PHP的闭包打起了兴趣。</p><blockquote><p>于是乎在网上下了个WAMP集成开发环境，是PHP5.3版本的（PHP5.3开始引入了闭包的特性），不得不说WAMP安装使用真的很方便。简单配置了一下，开始动手。</p></blockquote><a id="more"></a><h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><p>提到闭包就不得不想起匿名函数，也叫闭包函数（closures），貌似PHP闭包实现主要就是靠它。声明一个匿名函数是这样：</p><pre><code>$func = function() {}; //带结束符</code></pre><p>可以看到，匿名函数因为没有名字，如果要使用它，需要将其返回给一个变量。匿名函数也像普通函数一样可以声明参数，调用方法也相同：</p><p>​<br>    $func = function( $param ) {<br>        echo $param;<br>    };</p><pre><code>$func( &apos;some string&apos; );//输出：//some string</code></pre><p>顺便提一下，PHP在引入闭包之前，也有一个可以创建匿名函数的函数：create function，但是代码逻辑只能写成字符串，这样看起来很晦涩并且不好维护，所以很少有人用。</p><h5 id="实现闭包"><a href="#实现闭包" class="headerlink" title="实现闭包"></a>实现闭包</h5><p>将匿名函数在普通函数中当做参数传入，也可以被返回。这就实现了一个简单的闭包。</p><p>下边有三个例子</p><h6 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h6><pre><code>//在函数里定义一个匿名函数，并且调用它function printStr() {    $func = function( $str ) {        echo $str;    };    $func( &apos;some string&apos; );}printStr();</code></pre><h6 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h6><pre><code>//在函数中把匿名函数返回，并且调用它function getPrintStrFunc() {    $func = function( $str ) {        echo $str;    };    return $func;}$printStrFunc = getPrintStrFunc();$printStrFunc( &apos;some string&apos; );</code></pre><h6 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h6><pre><code>//把匿名函数当做参数传递，并且调用它function callFunc( $func ) {    $func( &apos;some string&apos; );}$printStrFunc = function( $str ) {    echo $str;};callFunc( $printStrFunc );//也可以直接将匿名函数进行传递。如果你了解js，这种写法可能会很熟悉callFunc( function( $str ) {    echo $str;} );</code></pre><blockquote><p>连接闭包和外界变量的关键字：USE</p></blockquote><p>闭包可以保存所在代码块上下文的一些变量和值。PHP在默认情况下，匿名函数不能调用所在代码块的上下文变量，而需要通过使用use关键字。</p><pre><code>function getMoney() {    $rmb = 1;    $dollar = 6;    $func = function() use ( $rmb ) {        echo $rmb;        echo $dollar;    };    $func();}getMoney();//输出：//1//报错，找不到dorllar变量</code></pre><p>可以看到，dollar没有在use关键字中声明，在这个匿名函数里也就不能获取到它，所以开发中要注意这个问题。</p><p>有人可能会想到，是否可以在匿名函数中改变上下文的变量，但我发现是不可以的：</p><pre><code>function getMoney() {    $rmb = 1;    $func = function() use ( $rmb ) {        echo $rmb;        //把$rmb的值加1        $rmb++;    };    $func();    echo $rmb;}getMoney();//输出：//1//1</code></pre><p>啊，原来use所引用的也只不过是变量的一个副本而已。但是我想要完全引用变量，而不是复制。</p><p>要达到这种效果，其实在变量前加一个 &amp; 符号就可以了：</p><pre><code>function getMoney() {    $rmb = 1;    $func = function() use ( &amp;$rmb ) {        echo $rmb;        //把$rmb的值加1        $rmb++;    };    $func();    echo $rmb;}getMoney();//输出：//1//2</code></pre><p>好，这样匿名函数就可以引用上下文的变量了。如果将匿名函数返回给外界，匿名函数会保存use所引用的变量，而外界则不能得到这些变量，这样形成‘闭包’这个概念可能会更清晰一些。</p><pre><code>function getMoneyFunc() {    $rmb = 1;    $func = function() use ( &amp;$rmb ) {        echo $rmb;        //把$rmb的值加1        $rmb++;    };    return $func;}$getMoney = getMoneyFunc();$getMoney();$getMoney();$getMoney();//输出：//1//2//3</code></pre><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote><p>PHP闭包的特性并没有太大惊喜，其实用CLASS就可以实现类似甚至强大得多的功能，更不能和js的闭包相提并论，只能期待PHP以后对闭包支持的改进。不过匿名函数还是挺有用的，比如在使用preg_replace_callback等之类的函数可以不用在外部声明回调函数了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知不觉发现PHP已经出到了5.5版本，而自己一直在用PHP5.2，让我看起来像深山出来的小伙子一样，又土又落后。在我习惯在javascript中使用闭包之后，忽然间对PHP的闭包打起了兴趣。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;于是乎在网上下了个WAMP集成开发环境，是PHP5.3版本的（PHP5.3开始引入了闭包的特性），不得不说WAMP安装使用真的很方便。简单配置了一下，开始动手。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>MySQL两种存储引擎- MyISAM和InnoDB 简单总结</title>
    <link href="https://icocos.github.io/2019/05/03/MySQL%E4%B8%A4%E7%A7%8D%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%20MyISAM%E5%92%8CInnoDB%20%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <id>https://icocos.github.io/2019/05/03/MySQL两种存储引擎- MyISAM和InnoDB 简单总结/</id>
    <published>2019-05-03T10:47:41.000Z</published>
    <updated>2019-05-22T09:17:26.545Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>MyISAM是MySQL的默认数据库引擎（5.5版之前），由早期的ISAM（Indexed Sequential Access Method：有索引的顺序访问方法）所改良。虽然性能极佳，但却有一个缺点：不支持事务处理（transaction）。不过，在这几年的发展下，MySQL也导入了InnoDB（另一种数据库引擎），以强化参考完整性与并发违规处理机制，后来就逐渐取代MyISAM。</p></li><li><p>InnoDB，是MySQL的数据库引擎之一，为MySQL AB发布binary的标准之一。InnoDB由Innobase Oy公司所开发，2006年五月时由甲骨文公司并购。与传统的ISAM与MyISAM相比，InnoDB的最大特色就是支持了ACID兼容的事务（Transaction）功能，类似于PostgreSQL。目前InnoDB采用双轨制授权，一是GPL授权，另一是专有软件授权。</p></li></ul><a id="more"></a><p>MyISAM和InnoDB两者之间有着明显区别，简单梳理如下:</p><h5 id="1-事务支持"><a href="#1-事务支持" class="headerlink" title="1) 事务支持"></a>1) 事务支持</h5><p>MyISAM不支持事务，而InnoDB支持。InnoDB的AUTOCOMMIT默认是打开的，即每条SQL语句会默认被封装成一个事务，自动提交，这样会影响速度，所以最好是把多条SQL语句显示放在begin和commit之间，组成一个事务去提交。</p><p>MyISAM是非事务安全型的，而InnoDB是事务安全型的，默认开启自动提交，宜合并事务，一同提交，减小数据库多次提交导致的开销，大大提高性能。</p><h5 id="2-存储结构"><a href="#2-存储结构" class="headerlink" title="2) 存储结构"></a>2) 存储结构</h5><p>MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。</p><p>InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</p><h5 id="3-存储空间"><a href="#3-存储空间" class="headerlink" title="3) 存储空间"></a>3) 存储空间</h5><p>MyISAM：可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。</p><p>InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。</p><h5 id="4-可移植性、备份及恢复"><a href="#4-可移植性、备份及恢复" class="headerlink" title="4) 可移植性、备份及恢复"></a>4) 可移植性、备份及恢复</h5><p>MyISAM：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。</p><p>InnoDB：免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。</p><h5 id="5-事务支持"><a href="#5-事务支持" class="headerlink" title="5) 事务支持"></a>5) 事务支持</h5><p>MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。</p><p>InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</p><h5 id="6-AUTO-INCREMENT"><a href="#6-AUTO-INCREMENT" class="headerlink" title="6) AUTO_INCREMENT"></a>6) AUTO_INCREMENT</h5><p>MyISAM：可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。</p><p>InnoDB：InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。</p><h5 id="7-表锁差异"><a href="#7-表锁差异" class="headerlink" title="7) 表锁差异"></a>7) 表锁差异</h5><p>MyISAM：只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。</p><p>InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</p><p>MyISAM锁的粒度是表级，而InnoDB支持行级锁定。简单来说就是, InnoDB支持数据行锁定，而MyISAM不支持行锁定，只支持锁定整个表。即MyISAM同一个表上的读锁和写锁是互斥的，MyISAM并发读写时如果等待队列中既有读请求又有写请求，默认写请求的优先级高，即使读请求先到，所以MyISAM不适合于有大量查询和修改并存的情况，那样查询进程会长时间阻塞。因为MyISAM是锁表，所以某项读操作比较耗时会使其他写进程饿死。</p><h5 id="8-全文索引"><a href="#8-全文索引" class="headerlink" title="8) 全文索引"></a>8) 全文索引</h5><p>MyISAM：支持(FULLTEXT类型的)全文索引</p><p>InnoDB：不支持(FULLTEXT类型的)全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。</p><p>全文索引是指对char、varchar和text中的每个词（停用词除外）建立倒排序索引。MyISAM的全文索引其实没啥用，因为它不支持中文分词，必须由使用者分词后加入空格再写到数据表里，而且少于4个汉字的词会和停用词一样被忽略掉。</p><blockquote><p>另外，MyIsam索引和数据分离，InnoDB在一起，MyIsam天生非聚簇索引，最多有一个unique的性质，InnoDB的数据文件本身就是主键索引文件，这样的索引被称为“聚簇索引”</p></blockquote><h5 id="9-表主键"><a href="#9-表主键" class="headerlink" title="9) 表主键"></a>9) 表主键</h5><p>MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。</p><p>InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。InnoDB的主键范围更大，最大是MyISAM的2倍。</p><h5 id="10-表的具体行数"><a href="#10-表的具体行数" class="headerlink" title="10) 表的具体行数"></a>10) 表的具体行数</h5><p>MyISAM：保存有表的总行数，如果select count(*) from table;会直接取出出该值。</p><p>InnoDB：没有保存表的总行数(只能遍历)，如果使用select count(*) from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。</p><h5 id="11-CURD操作"><a href="#11-CURD操作" class="headerlink" title="11) CURD操作"></a>11) CURD操作</h5><p>MyISAM：如果执行大量的SELECT，MyISAM是更好的选择。</p><p>InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。</p><h5 id="12-外键"><a href="#12-外键" class="headerlink" title="12) 外键"></a>12) 外键</h5><p>MyISAM：不支持</p><p>InnoDB：支持</p><h5 id="13-查询效率"><a href="#13-查询效率" class="headerlink" title="13) 查询效率"></a>13) 查询效率</h5><p>没有where的count(<em>)使用MyISAM要比InnoDB快得多。因为MyISAM内置了一个计数器，count(</em>)时它直接从计数器中读，而InnoDB必须扫描全表。所以在InnoDB上执行count(<em>)时一般要伴随where，且where中要包含主键以外的索引列。为什么这里特别强调“主键以外”？因为InnoDB中primary index是和raw data存放在一起的，而secondary index则是单独存放，然后有个指针指向primary key。所以只是count(</em>)的话使用secondary index扫描更快，而primary key则主要在扫描索引同时要返回raw data时的作用较大。MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM。</p><p>通过上述的分析，基本上可以考虑使用InnoDB来替代MyISAM引擎了，原因是InnoDB自身很多良好的特点，比如事务支持、存储 过程、视图、行级锁定等等，在并发很多的情况下，相信InnoDB的表现肯定要比MyISAM强很多。另外，任何一种表都不是万能的，只用恰当的针对业务类型来选择合适的表类型，才能最大的发挥MySQL的性能优势。如果不是很复杂的Web应用，非关键应用，还是可以继续考虑MyISAM的，这个具体情况可以自己斟酌。</p><h3 id="MyISAM和InnoDB两者的应用场景："><a href="#MyISAM和InnoDB两者的应用场景：" class="headerlink" title="MyISAM和InnoDB两者的应用场景："></a>MyISAM和InnoDB两者的应用场景：</h3><ul><li><p>1) MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。</p></li><li><p>2) InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。</p></li></ul><p>但是实际场景中，针对具体问题需要具体分析，一般而言可以遵循以下几个问题：</p><ul><li>数据库是否有外键？</li><li>是否需要事务支持？</li><li>是否需要全文索引？</li><li>数据库经常使用什么样的查询模式？在写多读少的应用中还是Innodb插入性能更稳定，在并发情况下也能基本，如果是对读取速度要求比较快的应用还是选MyISAM。</li><li>数据库的数据有多大？ 大尺寸倾向于innodb，因为事务日志，故障恢复。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;MyISAM是MySQL的默认数据库引擎（5.5版之前），由早期的ISAM（Indexed Sequential Access Method：有索引的顺序访问方法）所改良。虽然性能极佳，但却有一个缺点：不支持事务处理（transaction）。不过，在这几年的发展下，MySQL也导入了InnoDB（另一种数据库引擎），以强化参考完整性与并发违规处理机制，后来就逐渐取代MyISAM。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;InnoDB，是MySQL的数据库引擎之一，为MySQL AB发布binary的标准之一。InnoDB由Innobase Oy公司所开发，2006年五月时由甲骨文公司并购。与传统的ISAM与MyISAM相比，InnoDB的最大特色就是支持了ACID兼容的事务（Transaction）功能，类似于PostgreSQL。目前InnoDB采用双轨制授权，一是GPL授权，另一是专有软件授权。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引优化策略与笔记</title>
    <link href="https://icocos.github.io/2019/04/29/MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5%E4%B8%8E%E7%AC%94%E8%AE%B0/"/>
    <id>https://icocos.github.io/2019/04/29/MySQL索引优化策略与笔记/</id>
    <published>2019-04-29T10:47:41.000Z</published>
    <updated>2019-05-27T02:33:41.460Z</updated>
    
    <content type="html"><![CDATA[<p>面试知识，数据库索引优化</p><h4 id="什么问题？"><a href="#什么问题？" class="headerlink" title="什么问题？"></a>什么问题？</h4><pre><code>索引有什么代价？哪些场景下你需要建索引？或者有时候反过来问，哪些场景下不推荐建索引。建好索引之后，怎么才能最高效地利用索引？或者反过来问，请说出一个无法有效利用已建索引的案例。</code></pre><h4 id="索引的好处？"><a href="#索引的好处？" class="headerlink" title="索引的好处？"></a>索引的好处？</h4><blockquote><p>快速查询数据。</p></blockquote><a id="more"></a><h4 id="代价是什么？"><a href="#代价是什么？" class="headerlink" title="代价是什么？"></a>代价是什么？</h4><pre><code>索引需要占硬盘空间，这是空间方面的代价。一旦插入新的数据，就需要重新建索引，这是时间上的代价。</code></pre><h4 id="不同场景，不同对待。"><a href="#不同场景，不同对待。" class="headerlink" title="不同场景，不同对待。"></a>不同场景，不同对待。</h4><h5 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h5><blockquote><p>数据表规模不大，就几千行，即使不建索引，查询语句的返回时间也不长，这时建索引的意义就不大。当然，若就几千行，索引所占的空间也不多，所以这种情况下，顶多属于“性价比”不高。</p></blockquote><h4 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h4><blockquote><p> 某个商品表里有几百万条商品信息，同时每天会在一个时间点，往其中更新大概十万条左右的商品信息，现在用where语句查询特定商品时（比如where name = ‘XXX’）速度很慢。为了提升查询效率可以建索引，但当每天更新数据时，又会重建索引，这是要耗费时间的。这时就需要综合考虑，甚至可以在更新前删除索引，更新后再重建。</p></blockquote><h4 id="场景三"><a href="#场景三" class="headerlink" title="场景三"></a>场景三</h4><blockquote><p>因为在数据表里ID值都不相同，所以索引能发挥出比较大的作用。相反，如果某个字段重复率很高，如性别字段，或者某个字段大多数值是空（null），那么不建议对该字段建索引。</p></blockquote><h3 id="建立索引原则"><a href="#建立索引原则" class="headerlink" title="建立索引原则"></a>建立索引原则</h3><p>一定是有业务需求了才会建索引。比如在一个商品表里，我们经常要根据name做查询，如果没有索引，查询速度会很慢，这时就需要建索引。但在项目开发中，如果不经常根据商品编号查询，那么就没必要对编号建索引。</p><p>最后再强调一次，建索引是要付出代价的，没事别乱建着玩，同时在一个表上也不能建太多的索引。<br>具体的例子来看索引的正确用法</p><pre><code>语句一：select name from 商品表。不会用到索引，因为没有where语句。语句二：select * from 商品表 where name = ‘Java书’，会用到索引，如果项目里经常用到name来查询，且商品表的数据量很大，而name值的重复率又不高，那么建议建索引。语句三：select * from 商品表 where name like ‘Java%’ 这是个模糊查询，会用到索引，请大家记住，用like进行模糊查询时，如果第一个就是模糊的匹配符，比如where name like ‘%java’，那么在查询时不会走索引。在其他情况下，不论用了多少个%，也不论%的位置，只要不出现在第一个位置，那么都能用到索引。</code></pre><p>学生成绩表里有两个字段：姓名和成绩。现在对成绩这个整数类型的字段建索引。</p><pre><code>第一种情况，当数字型字段遇到非等值操作符时，无法用到索引。比如：</code></pre><p>​ select name from 学生成绩表 where 成绩&gt;95 , 一旦出现大于符号，就不能用到索引，为了用到索引，我们应该改一下SQL语句里的where从句：where 成绩 in (96,97,98,99,100)</p><pre><code>第二种情况，如果对索引字段进行了某种左值操作，那么无法用到索引。</code></pre><p>​ 能用到索引的写法：select name from 学生成绩表 where 成绩 = 60</p><p>​ 不能用到索引的写法：select name from 学生成绩表 where 成绩+40 = 100</p><pre><code>第三种情况，如果对索引字段进行了函数操作，那么无法用到索引。</code></pre><p>​ 比如SQL语句：select * from 商品表 where substr(name) = ‘J’，我们希望查询商品名首字母是J的记录，可一旦针对name使用函数，即使name字段上有索引，也无法用到。<br>​ </p><blockquote><p>非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据。</p></blockquote><p>不管以任何方式查询表， 最终都会利用主键通过聚集索引来定位到数据， 聚集索引（主键）是通往真实数据所在的唯一路径。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试知识，数据库索引优化&lt;/p&gt;
&lt;h4 id=&quot;什么问题？&quot;&gt;&lt;a href=&quot;#什么问题？&quot; class=&quot;headerlink&quot; title=&quot;什么问题？&quot;&gt;&lt;/a&gt;什么问题？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;索引有什么代价？哪些场景下你需要建索引？或者有时候反过来问，哪些场景下不推荐建索引。
建好索引之后，怎么才能最高效地利用索引？或者反过来问，请说出一个无法有效利用已建索引的案例。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;索引的好处？&quot;&gt;&lt;a href=&quot;#索引的好处？&quot; class=&quot;headerlink&quot; title=&quot;索引的好处？&quot;&gt;&lt;/a&gt;索引的好处？&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;快速查询数据。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>如何处理负载、高并发问题</title>
    <link href="https://icocos.github.io/2019/04/27/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%B4%9F%E8%BD%BD%E3%80%81%E9%AB%98%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/"/>
    <id>https://icocos.github.io/2019/04/27/如何处理负载、高并发问题/</id>
    <published>2019-04-27T10:47:41.000Z</published>
    <updated>2019-05-22T09:07:52.595Z</updated>
    
    <content type="html"><![CDATA[<p>从低成本、高性能和高扩张性的角度来说有如下处理方案：</p><h5 id="1、HTML静态化"><a href="#1、HTML静态化" class="headerlink" title="1、HTML静态化"></a>1、HTML静态化</h5><p>其实大家都知道，效率最高、消耗最小的就是纯静态化的html页面，所以我们尽可能使我们的  网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。</p><h5 id="2、图片服务器分离"><a href="#2、图片服务器分离" class="headerlink" title="2、图片服务器分离"></a>2、图片服务器分离</h5><p>​    把图片单独存储，尽量减少图片等大流量的开销，可以放在一些相关的平台上，如骑牛等</p><a id="more"></a><h5 id="3、数据库集群和库表散列及缓存"><a href="#3、数据库集群和库表散列及缓存" class="headerlink" title="3、数据库集群和库表散列及缓存"></a>3、数据库集群和库表散列及缓存</h5><p>数据库的并发连接为100，一台数据库远远不够，可以从读写分离、主从复制，数据库集群方面来着手。另外尽量减少数据库的访问，可以使用缓存数据库如memcache、redis。</p><h5 id="4、镜像："><a href="#4、镜像：" class="headerlink" title="4、镜像："></a>4、镜像：</h5><p>   尽量减少下载，可以把不同的请求分发到多个镜像端。</p><h5 id="5、负载均衡："><a href="#5、负载均衡：" class="headerlink" title="5、负载均衡："></a>5、负载均衡：</h5><p>   Apache的最大并发连接为1500，只能增加服务器，可以从硬件上着手，如F5服务器。当然硬件的成本比较高，我们往往从软件方面着手。</p><p>   负载均衡 （Load Balancing） 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力，同时能够提高网络的灵活性和可用性。目前使用最为广泛的负载均衡软件是Nginx、LVS、HAProxy。我分别来说下三种的优缺点:</p><h5 id="Nginx的优点是："><a href="#Nginx的优点是：" class="headerlink" title="Nginx的优点是："></a>Nginx的优点是：</h5><ol><li><p>工作在网络的7层之上，可以针对http应用做一些分流的策略，比如针对域名、目录结构，它的正则规则比HAProxy更为强大和灵活，这也是它目前广泛流行的主要原因之一，Nginx单凭这点可利用的场合就远多于LVS了。 </p></li><li><p>Nginx对网络稳定性的依赖非常小，理论上能ping通就就能进行负载功能，这个也是它的优势之一；相反LVS对网络稳定性依赖比较大，这点本人深有体会； </p></li><li><p>Nginx安装和配置比较简单，测试起来比较方便，它基本能把错误用日志打印出来。LVS的配置、测试就要花比较长的时间了，LVS对网络依赖比较大。 </p></li><li><p>可以承担高负载压力且稳定，在硬件不差的情况下一般能支撑几万次的并发量，负载度比LVS相对小些。 </p></li><li><p>Nginx可以通过端口检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点，不过其中缺点就是不支持url来检测。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而不满。 </p></li><li><p>Nginx不仅仅是一款优秀的负载均衡器/反向代理软件，它同时也是功能强大的Web应用服务器。LNMP也是近几年非常流行的web架构，在高流量的环境中稳定性也很好。 </p></li><li><p>Nginx现在作为Web反向加速缓存越来越成熟了，速度比传统的Squid服务器更快，可以考虑用其作为反向代理加速器。 </p></li><li><p>Nginx可作为中层反向代理使用，这一层面Nginx基本上无对手，唯一可以对比Nginx的就只有 lighttpd了，不过 lighttpd目前还没有做到Nginx完全的功能，配置也不那么清晰易读，社区资料也远远没Nginx活跃。 </p></li><li><p>Nginx也可作为静态网页和图片服务器，这方面的性能也无对手。还有Nginx社区非常活跃，第三方模块也很多。</p></li></ol><h5 id="Nginx的缺点是："><a href="#Nginx的缺点是：" class="headerlink" title="Nginx的缺点是："></a>Nginx的缺点是：</h5><ol><li>Nginx仅能支持http、https和Email协议，这样就在适用范围上面小些，这个是它的缺点。</li><li>对后端服务器的健康检查，只支持通过端口来检测，不支持通过url来检测。不支持Session的直接保持，但能通过ip_hash来解决。</li></ol><h4 id="LVS：使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability-、可靠性（Reliability-和可管理性（Manageability-。"><a href="#LVS：使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability-、可靠性（Reliability-和可管理性（Manageability-。" class="headerlink" title="LVS：使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability)、可靠性（Reliability)和可管理性（Manageability)。"></a>LVS：使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability)、可靠性（Reliability)和可管理性（Manageability)。</h4><h5 id="LVS的优点是："><a href="#LVS的优点是：" class="headerlink" title="LVS的优点是："></a>LVS的优点是：</h5><ol><li>抗负载能力强、是工作在网络4层之上仅作分发之用，没有流量的产生，这个特点也决定了它在负载均衡软件里的性能最强的，对内存和cpu资源消耗比较低。</li><li>配置性比较低，这是一个缺点也是一个优点，因为没有可太多配置的东西，所以并不需要太多接触，大大减少了人为出错的几率。</li><li>工作稳定，因为其本身抗负载能力很强，自身有完整的双机热备方案，如LVS+Keepalived，不过我们在项目实施中用得最多的还是LVS/DR+Keepalived。</li><li>无流量，LVS只分发请求，而流量并不从它本身出去，这点保证了均衡器IO的性能不会受到大流量的影响。</li><li>应用范围比较广，因为LVS工作在4层，所以它几乎可以对所有应用做负载均衡，包括http、数据库、在线聊天室等等。</li></ol><h5 id="LVS的缺点是："><a href="#LVS的缺点是：" class="headerlink" title="LVS的缺点是："></a>LVS的缺点是：</h5><ol><li>软件本身不支持正则表达式处理，不能做动静分离；而现在许多网站在这方面都有较强的需求，这个是Nginx/HAProxy+Keepalived的优势所在。</li><li>如果是网站应用比较庞大的话，LVS/DR+Keepalived实施起来就比较复杂了，特别后面有 Windows Server的机器的话，如果实施及配置还有维护过程就比较复杂了，相对而言，Nginx/HAProxy+Keepalived就简单多了。</li></ol><h5 id="HAProxy的特点是："><a href="#HAProxy的特点是：" class="headerlink" title="HAProxy的特点是："></a>HAProxy的特点是：</h5><ol><li>HAProxy也是支持虚拟主机的。</li><li>HAProxy的优点能够补充Nginx的一些缺点，比如支持Session的保持，Cookie的引导；同时支持通过获取指定的url来检测后端服务器的状态。</li><li>HAProxy跟LVS类似，本身就只是一款负载均衡软件；单纯从效率上来讲HAProxy会比Nginx有更出色的负载均衡速度，在并发处理上也是优于Nginx的。</li><li>HAProxy支持TCP协议的负载均衡转发，可以对MySQL读进行负载均衡，对后端的MySQL节点进行检测和负载均衡，大家可以用LVS+Keepalived对MySQL主从做负载均衡。</li><li>HAProxy负载均衡策略非常多，HAProxy的负载均衡算法现在具体有如下8种：</li></ol><p>① roundrobin，表示简单的轮询，这个不多说，这个是负载均衡基本都具备的；<br>② static-rr，表示根据权重，建议关注；<br>③ leastconn，表示最少连接者先处理，建议关注；<br>④ source，表示根据请求源IP，这个跟Nginx的IP_hash机制类似，我们用其作为解决session问题的一种方法，建议关注；<br>⑤ ri，表示根据请求的URI；<br>⑥ rl_param，表示根据请求的URl参数’balance url_param’ requires an URL parametername；<br>⑦ hdr(name)，表示根据HTTP请求头来锁定每一次HTTP请求；<br>⑧ rdp-cookie(name)，表示根据据cookie(name)来锁定并哈希每一次TCP请求。</p><h5 id="Nginx和LVS对比的总结："><a href="#Nginx和LVS对比的总结：" class="headerlink" title="Nginx和LVS对比的总结："></a>Nginx和LVS对比的总结：</h5><ol><li><p>Nginx工作在网络的7层，所以它可以针对http应用本身来做分流策略，比如针对域名、目录结构等，相比之下LVS并不具备这样的功能，所以Nginx单凭这点可利用的场合就远多于LVS了；但Nginx有用的这些功能使其可调整度要高于LVS，所以经常要去触碰触碰，触碰多了，人为出问题的几率也就会大。   </p></li><li><p>Nginx对网络稳定性的依赖较小，理论上只要ping得通，网页访问正常，Nginx就能连得通，这是Nginx的一大优势！Nginx同时还能区分内外网，如果是同时拥有内外网的节点，就相当于单机拥有了备份线路；LVS就比较依赖于网络环境，目前来看服务器在同一网段内并且LVS使用direct方式分流，效果较能得到保证。另外注意，LVS需要向托管商至少申请多一个ip来做Visual IP，貌似是不能用本身的IP来做VIP的。要做好LVS管理员，确实得跟进学习很多有关网络通信方面的知识，就不再是一个HTTP那么简单了。</p></li><li><p>Nginx安装和配置比较简单，测试起来也很方便，因为它基本能把错误用日志打印出来。LVS的安装和配置、测试就要花比较长的时间了；LVS对网络依赖比较大，很多时候不能配置成功都是因为网络问题而不是配置问题，出了问题要解决也相应的会麻烦得多。 </p></li><li><p>Nginx也同样能承受很高负载且稳定，但负载度和稳定度差LVS还有几个等级：Nginx处理所有流量所以受限于机器IO和配置；本身的bug也还是难以避免的。 </p></li><li><p>Nginx可以检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点。目前LVS中 ldirectd也能支持针对服务器内部的情况来监控，但LVS的原理使其不能重发请求。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而恼火。 </p></li><li><p>Nginx对请求的异步处理可以帮助节点服务器减轻负载，假如使用 apache直接对外服务，那么出现很多的窄带链接时apache服务器将会占用大量内存而不能释放，使用多一个Nginx做apache代理的话，这些窄带链接会被Nginx挡住，apache上就不会堆积过多的请求，这样就减少了相当多的资源占用。这点使用squid也有相同的作用，即使squid本身配置为不缓存，对apache还是有很大帮助的。 </p></li><li><p>Nginx能支持http、https和email（email的功能比较少用），LVS所支持的应用在这点上会比Nginx更多。在使用上，一般最前端所采取的策略应是LVS，也就是DNS的指向应为LVS均衡器，LVS的优点令它非常适合做这个任务。重要的ip地址，最好交由LVS托管，比如数据库的 ip、webservice服务器的ip等等，这些ip地址随着时间推移，使用面会越来越大，如果更换ip则故障会接踵而至。所以将这些重要ip交给 LVS托管是最为稳妥的，这样做的唯一缺点是需要的VIP数量会比较多。Nginx可作为LVS节点机器使用，一是可以利用Nginx的功能，二是可以利用Nginx的性能。当然这一层面也可以直接使用squid，squid的功能方面就比Nginx弱不少了，性能上也有所逊色于Nginx。Nginx也可作为中层代理使用，这一层面Nginx基本上无对手，唯一可以撼动Nginx的就只有lighttpd了，不过lighttpd目前还没有能做到 Nginx完全的功能，配置也不那么清晰易读。另外，中层代理的IP也是重要的，所以中层代理也拥有一个VIP和LVS是最完美的方案了。具体的应用还得具体分析，如果是比较小的网站（日PV小于1000万），用Nginx就完全可以了，如果机器也不少，可以用DNS轮询，LVS所耗费的机器还是比较多的；大型网站或者重要的服务，机器不发愁的时候，要多多考虑利用LVS。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从低成本、高性能和高扩张性的角度来说有如下处理方案：&lt;/p&gt;
&lt;h5 id=&quot;1、HTML静态化&quot;&gt;&lt;a href=&quot;#1、HTML静态化&quot; class=&quot;headerlink&quot; title=&quot;1、HTML静态化&quot;&gt;&lt;/a&gt;1、HTML静态化&lt;/h5&gt;&lt;p&gt;其实大家都知道，效率最高、消耗最小的就是纯静态化的html页面，所以我们尽可能使我们的  网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。&lt;/p&gt;
&lt;h5 id=&quot;2、图片服务器分离&quot;&gt;&lt;a href=&quot;#2、图片服务器分离&quot; class=&quot;headerlink&quot; title=&quot;2、图片服务器分离&quot;&gt;&lt;/a&gt;2、图片服务器分离&lt;/h5&gt;&lt;p&gt;​    把图片单独存储，尽量减少图片等大流量的开销，可以放在一些相关的平台上，如骑牛等&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="高负载" scheme="https://icocos.github.io/tags/%E9%AB%98%E8%B4%9F%E8%BD%BD/"/>
    
      <category term="高并发" scheme="https://icocos.github.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL 事务处理常见有两种方法</title>
    <link href="https://icocos.github.io/2019/04/26/MYSQL%20%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%B8%B8%E8%A7%81%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>https://icocos.github.io/2019/04/26/MYSQL 事务处理常见有两种方法/</id>
    <published>2019-04-26T10:47:41.000Z</published>
    <updated>2019-05-22T09:17:25.529Z</updated>
    
    <content type="html"><![CDATA[<p> MYSQL在操作大量的数据或者比较重要的数据的时候，事务处理很重要，比如银行的转账，支付，等等，作为开发人员事务是必须的一步。</p><h5 id="1、用-BEGIN-ROLLBACK-COMMIT来实现"><a href="#1、用-BEGIN-ROLLBACK-COMMIT来实现" class="headerlink" title="1、用 BEGIN, ROLLBACK, COMMIT来实现"></a>1、用 BEGIN, ROLLBACK, COMMIT来实现</h5><ul><li>BEGIN 开始一个事务</li><li>ROLLBACK 事务回滚</li><li>COMMIT 事务确认</li></ul><a id="more"></a><h5 id="2、直接用-SET-来改变-MySQL-的自动提交模式"><a href="#2、直接用-SET-来改变-MySQL-的自动提交模式" class="headerlink" title="2、直接用 SET 来改变 MySQL 的自动提交模式:"></a>2、直接用 SET 来改变 MySQL 的自动提交模式:</h5><ul><li>SET AUTOCOMMIT=0 禁止自动提交</li><li>SET AUTOCOMMIT=1 开启自动提交</li></ul><blockquote><p>注意的是，在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</p></blockquote><p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p><h3 id="一、php事务处理概述："><a href="#一、php事务处理概述：" class="headerlink" title="一、php事务处理概述："></a>一、php事务处理概述：</h3><ul><li><p>事务:是若干事件的集合</p></li><li><p>事务处理:当所有事件执行成功,事务才执行;若有任何一个事件不能成功执行,事务的其它事件也不被执行。</p></li></ul><p>只要你的MySQL版本支持BDB或InnoDB表类型，那么你的MySQL就具有事务处理的能力。这里面，又以InnoDB表类型用的最多，虽然后来发生了诸如Oracle收购InnoDB等令MySQL不爽的事情，但是这类商业事件与技术无关，下面就以InnoDB表类型为例简单说一下MySQL中的事务处理。</p><h3 id="二、php事务处理代码："><a href="#二、php事务处理代码：" class="headerlink" title="二、php事务处理代码："></a>二、php事务处理代码：</h3><pre><code>&lt;?phptry{$pdo=new PDO(&quot;mysql:host=localhost;dbname=psp&quot;,&quot;root&quot;,&quot;&quot;);$pdo-&gt;exec(&quot;set names utf8&quot;);$pdo-&gt;setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_EXCEPTION);//设置异常处理模式$pdo-&gt;setAttribute(PDO::ATTR_AUTOCOMMIT,0);//关闭自动提交}catch(PDOException $e){echo &quot;数据库连接失败&quot;;exit;}try{$age=10;$pdo-&gt;beginTransaction();//开始事务$affected_rows1=$pdo-&gt;exec(&quot;update kfry set k_age=k_age+{$age} where k_name=&apos;user1&apos;&quot;);$affected_rows2=$pdo-&gt;exec(&quot;update kfry set k_age=k_age-{$age} where k_name=&apos;user2&apos;&quot;);//随意更改使之执行成功或失败/* if($affected_rows1&amp;&amp;$affected_rows2){$pdo-&gt;commit();echo &quot;操作成功&quot;;}else{$pdo-&gt;rollback();} */if(!$affected_rows1)throw new PDOException(&quot;加入错误&quot;);if(!$affected_rows2)throw new PDOException(&quot;减少错误&quot;);echo &quot;操作成功&quot;;$pdo-&gt;commit();//如果执行到此处前面两个更新sql语句执行成功，整个事务执行成功}catch(PDOException $e){echo &quot;操作失败：&quot;.$e-&gt;getMessage();$pdo-&gt;rollback();//执行事务中的语句出了问题，整个事务全部撤销}$pdo-&gt;setAttribute(PDO::ATTR_AUTOCOMMIT,1);//测试是否成功echo &quot;\n操作结果为:\n&quot;;$sql=&quot;select * from kfry&quot;;$result=$pdo-&gt;query($sql);foreach($result as $v){echo $v[&apos;k_name&apos;].&quot; &quot;.$v[&apos;k_age&apos;].&quot;\n&quot;;}?&gt;</code></pre><p>以上就是php 事务处理详解的详细内容，更多请关注php中文网其它相关文章！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; MYSQL在操作大量的数据或者比较重要的数据的时候，事务处理很重要，比如银行的转账，支付，等等，作为开发人员事务是必须的一步。&lt;/p&gt;
&lt;h5 id=&quot;1、用-BEGIN-ROLLBACK-COMMIT来实现&quot;&gt;&lt;a href=&quot;#1、用-BEGIN-ROLLBACK-COMMIT来实现&quot; class=&quot;headerlink&quot; title=&quot;1、用 BEGIN, ROLLBACK, COMMIT来实现&quot;&gt;&lt;/a&gt;1、用 BEGIN, ROLLBACK, COMMIT来实现&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;BEGIN 开始一个事务&lt;/li&gt;
&lt;li&gt;ROLLBACK 事务回滚&lt;/li&gt;
&lt;li&gt;COMMIT 事务确认&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Web安全的一次探讨</title>
    <link href="https://icocos.github.io/2019/03/13/Web%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%80%E6%AC%A1%E6%8E%A2%E8%AE%A8/"/>
    <id>https://icocos.github.io/2019/03/13/Web安全的一次探讨/</id>
    <published>2019-03-13T04:14:14.000Z</published>
    <updated>2019-05-22T09:17:14.833Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、SQL注入攻击-SQL-Injection"><a href="#一、SQL注入攻击-SQL-Injection" class="headerlink" title="一、SQL注入攻击(SQL Injection)"></a>一、SQL注入攻击(SQL Injection)</h3><p>攻击者把sql命令插入到web表单的输入域或页面请求的字符串，欺骗服务器执行恶意的sql命令。常见的sql注入攻击类似：</p><h5 id="登录页面中输入内容直接用来构造动态的sql语句，例如："><a href="#登录页面中输入内容直接用来构造动态的sql语句，例如：" class="headerlink" title="登录页面中输入内容直接用来构造动态的sql语句，例如："></a>登录页面中输入内容直接用来构造动态的sql语句，例如：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$query = &apos;select * from users where login = &apos;. $username. &apos;and password = &apos;. $password;</span><br></pre></td></tr></table></figure><a id="more"></a><p>攻击者如果在用户名或者密码框输入<code>or &#39;1&#39; =1</code>，这样我们执行的sql语句就变成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where login = &apos;&apos; or &apos;1&apos; = 1 and ...</span><br></pre></td></tr></table></figure><p>这样就绕过了我们的登录验证。类似的还有很多，用户通过输入恶意的sql命令来绕过我们的验证，欺骗我们的系统。</p><h5 id="防范的方法："><a href="#防范的方法：" class="headerlink" title="防范的方法："></a>防范的方法：</h5><ol><li>检查变量数据类型和格式</li><li>过滤特殊的符号</li><li>绑定变量，使用预处理语句（当我们绑定变量的时候，就算有特殊字符sql也会认为是个变量而不是sql命令）</li></ol><h3 id="二、跨站脚本攻击-Cross-Site-Scripting-XSS；因为CSS被用了所以叫XSS"><a href="#二、跨站脚本攻击-Cross-Site-Scripting-XSS；因为CSS被用了所以叫XSS" class="headerlink" title="二、跨站脚本攻击(Cross Site Scripting, XSS；因为CSS被用了所以叫XSS)"></a>二、跨站脚本攻击(Cross Site Scripting, XSS；因为CSS被用了所以叫XSS)</h3><p>攻击者将恶意代码注入到网页上，其他用户在加载网页时就会执行代码，攻击者可能会得到各种私密的信息，如cookie等。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    echo &apos;你好！&apos;.$_GET[&apos;name&apos;];</span><br></pre></td></tr></table></figure><p>如果用户传入一段脚本<code>&lt;script&gt;[code]&lt;/script&gt;</code>，那么脚本也会执行，如果code的内容是获取到cookie并发送到某个指定的位置，获取了敏感的信息。亦或是利用用户的身份去执行一些不正当的操作。</p><h5 id="防范的方法：-1"><a href="#防范的方法：-1" class="headerlink" title="防范的方法："></a>防范的方法：</h5><ol><li>输出的时候过滤特殊的字符，转换成html编码，过滤输出的变量（PHP可以使用htmlspecialchars）</li></ol><h3 id="三、跨站请求伪造攻击-Cross-Site-Request-Forgeries-CSRF"><a href="#三、跨站请求伪造攻击-Cross-Site-Request-Forgeries-CSRF" class="headerlink" title="三、跨站请求伪造攻击(Cross Site Request Forgeries, CSRF)"></a>三、跨站请求伪造攻击(Cross Site Request Forgeries, CSRF)</h3><p>攻击者伪造目标用户的HTTP请求，然后此请求发送到有CSRF漏洞的网站，网站执行此请求后，引发跨站请求伪造攻击。攻击者利用隐蔽的HTTP连接，让目标用户在不注意的情况下单击这个链接，由于是用户自己点击的，而他又是合法用户拥有合法权限，所以目标用户能够在网站内执行特定的HTTP链接，从而达到攻击者的目的。  </p><blockquote><p>  用户刚刚登陆了银行A网站，建立了会话，A网站可以进行转账操作<code>http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000</code>在没有退出的情况下去访问危险网站B网站，B网站有一个图片是这样的<code>&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;</code>，不小心点了B网站，用户发现账上少了1000块。  </p></blockquote><p>可能有人会说，修改操作并不会用get请求。那么假设银行A网站的表单如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;Transfer.php&quot; method=&quot;POST&quot;&gt;</span><br><span class="line">    &lt;p&gt;ToBankId: &lt;input type=&quot;text&quot; name=&quot;toBankId&quot; /&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;Money: &lt;input type=&quot;text&quot; name=&quot;money&quot; /&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Transfer&quot; /&gt;&lt;/p&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>后台处理页面如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">session_start();</span><br><span class="line">if (isset($_REQUEST[&apos;toBankId&apos;] &amp;&amp; isset($_POST[&apos;money&apos;]))</span><br><span class="line">&#123;</span><br><span class="line">    buy_stocks($_REQUEST[&apos;toBankId&apos;],$_REQUEST[&apos;money&apos;]);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>B网站这时候也相应的改了代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">　　　　&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">　　　　　　function steal()</span><br><span class="line">　　　　　　&#123;</span><br><span class="line">          　　　　 iframe = document.frames[&quot;steal&quot;];</span><br><span class="line">　　     　　      iframe.document.Submit(&quot;transfer&quot;);</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&lt;/script&gt;</span><br><span class="line">　　&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">　　&lt;body onload=&quot;steal()&quot;&gt;</span><br><span class="line">　　　　&lt;iframe name=&quot;steal&quot; display=&quot;none&quot;&gt;</span><br><span class="line">　　　　　　&lt;form method=&quot;POST&quot; name=&quot;transfer&quot;　action=&quot;http://www.myBank.com/Transfer.php&quot;&gt;</span><br><span class="line">　　　　　　　　&lt;input type=&quot;hidden&quot; name=&quot;toBankId&quot; value=&quot;11&quot;&gt;</span><br><span class="line">　　　　　　　　&lt;input type=&quot;hidden&quot; name=&quot;money&quot; value=&quot;1000&quot;&gt;</span><br><span class="line">　　　　　　&lt;/form&gt;</span><br><span class="line">　　　　&lt;/iframe&gt;</span><br><span class="line">　　&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>用户一点到B网站，发现又少了1000块…….</p><h5 id="防范方法："><a href="#防范方法：" class="headerlink" title="防范方法："></a>防范方法：</h5><ul><li>对表单进行cookie hash校验，将一个随机值的hash写入cookie，每次提交表单，都在服务端对这个hash进行校验（建立在用户的cookie没有被盗取）</li></ul><h3 id="四、Session固定攻击-Session-Fixation"><a href="#四、Session固定攻击-Session-Fixation" class="headerlink" title="四、Session固定攻击(Session Fixation)"></a>四、Session固定攻击(Session Fixation)</h3><p>攻击者预先设定session id，让合法用户使用这个session id来访问被攻击的应用程序，一旦用户的会话ID被成功固定，攻击者就可以通过此session id来冒充用户访问应用程序。例如：  </p><ol><li>攻击者先访问目标网站，获得了自己的session_id，如SID=123</li><li>攻击者给目标用户发送链接，并带上了自己的session_id，如<code>http:///www.bank.com/?SID=123</code>，</li><li>目标用户点击了<code>http:///www.bank.com/?SID=123</code>，输入用户名密码登录，由于session_id不会变更，那么攻击者就可以通过访问<code>http:///www.bank.com/?SID=123</code>来获取目标用户的身份。</li></ol><h5 id="防范方法：-1"><a href="#防范方法：-1" class="headerlink" title="防范方法："></a>防范方法：</h5><ol><li>定期更改session_id</li><li>更改session_id的名字</li></ol><h3 id="五、Session劫持-Session-Hijacking"><a href="#五、Session劫持-Session-Hijacking" class="headerlink" title="五、Session劫持(Session Hijacking)"></a>五、Session劫持(Session Hijacking)</h3><p>攻击者利用各种手段来获取目标用户的session id。一旦获取到session id，那么攻击者可以利用目标用户的身份来登录网站，获取目标用户的操作权限。</p><h5 id="攻击者获取目标用户session-id的方法"><a href="#攻击者获取目标用户session-id的方法" class="headerlink" title="攻击者获取目标用户session id的方法:"></a>攻击者获取目标用户session id的方法:</h5><ol><li>暴力破解:尝试各种session id，直到破解为止;</li><li>计算:如果session id使用非随机的方式产生，那么就有可能计算出来;</li><li>窃取:使用网络截获，xss攻击等方法获得<br>防范方法：</li><li>定期更改session id</li><li>更改session的名称</li><li>关闭透明化session id</li><li>设置HttpOnly。通过设置Cookie的HttpOnly为true，可以防止客户端脚本访问这个Cookie，从而有效的防止XSS攻击。</li></ol><h3 id="六、文件上传漏洞-File-Upload-Attack"><a href="#六、文件上传漏洞-File-Upload-Attack" class="headerlink" title="六、文件上传漏洞(File Upload Attack)"></a>六、文件上传漏洞(File Upload Attack)</h3><p>攻击者利用程序缺陷绕过系统对文件的验证与处理策略将恶意代码上传到服务器并获得执行服务器端命令的能力。  </p><h5 id="常用的攻击手段有："><a href="#常用的攻击手段有：" class="headerlink" title="常用的攻击手段有："></a>常用的攻击手段有：</h5><ol><li>上传Web脚本代码，Web容器解释执行上传的恶意脚本；</li><li>上传Flash跨域策略文件crossdomain.xml，修改访问权限(其他策略文件利用方式类似)；</li><li>上传病毒、木马文件，诱骗用户和管理员下载执行；</li><li>上传包含脚本的图片，某些浏览器的低级版本会执行该脚本，用于钓鱼和欺诈。<br>总的来说，利用的上传文件要么具备可执行能力(恶意代码)，要么具备影响服务器行为的能力(配置文件)。<br>防范方法：  </li><li>文件上传的目录设置为不可执行；</li><li>判断文件类型，设置白名单。对于图片的处理，可以使用压缩函数或者resize函数，在处理图片的同时破坏图片中可能包含的HTML代码；</li><li>使用随机数改写文件名和文件路径：一个是上传后无法访问；再来就是像shell、.php 、.rar和crossdomain.xml这种文件，都将因为重命名而无法攻击；</li><li>单独设置文件服务器的域名：由于浏览器同源策略的关系，一系列客户端攻击将失效，比如上传crossdomain.xml、上传包含Javascript的XSS利用等问题将得到解决。</li></ol><h3 id="MYSQL安全"><a href="#MYSQL安全" class="headerlink" title="MYSQL安全"></a>MYSQL安全</h3><ol><li>使用预处理语句防止sql注入</li><li>写入数据库的数据要进行特殊字符转义</li><li>查询的错误信息不要返回给用户，将错误记录到日志   </li><li>定期做数据库备份</li><li>不给查询用户root权限，合理分配权限</li><li>关闭远程访问数据库的权限</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、SQL注入攻击-SQL-Injection&quot;&gt;&lt;a href=&quot;#一、SQL注入攻击-SQL-Injection&quot; class=&quot;headerlink&quot; title=&quot;一、SQL注入攻击(SQL Injection)&quot;&gt;&lt;/a&gt;一、SQL注入攻击(SQL Injection)&lt;/h3&gt;&lt;p&gt;攻击者把sql命令插入到web表单的输入域或页面请求的字符串，欺骗服务器执行恶意的sql命令。常见的sql注入攻击类似：&lt;/p&gt;
&lt;h5 id=&quot;登录页面中输入内容直接用来构造动态的sql语句，例如：&quot;&gt;&lt;a href=&quot;#登录页面中输入内容直接用来构造动态的sql语句，例如：&quot; class=&quot;headerlink&quot; title=&quot;登录页面中输入内容直接用来构造动态的sql语句，例如：&quot;&gt;&lt;/a&gt;登录页面中输入内容直接用来构造动态的sql语句，例如：&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$query = &amp;apos;select * from users where login = &amp;apos;. $username. &amp;apos;and password = &amp;apos;. $password;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>数据库查询速度优化之解决技巧</title>
    <link href="https://icocos.github.io/2019/03/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%E4%B9%8B%E8%A7%A3%E5%86%B3%E6%8A%80%E5%B7%A7/"/>
    <id>https://icocos.github.io/2019/03/11/数据库查询速度优化之解决技巧/</id>
    <published>2019-03-11T10:47:41.000Z</published>
    <updated>2019-05-22T09:17:29.029Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、对查询进行优化-应尽可能避免全表扫描"><a href="#1、对查询进行优化-应尽可能避免全表扫描" class="headerlink" title="1、对查询进行优化,应尽可能避免全表扫描"></a>1、对查询进行优化,应尽可能避免全表扫描</h3><p>首先应考虑在 where 及 order by 涉及的列上建立索引。<br>下面我们来以一个表中177条数据比较一下,全表扫描与建立索引之后性能的一个比较.</p><blockquote><p>从这两种方式查询数据库结果看,建立索引之后查询速度提高了些,现在数据量还不明显,如果表中有10万条速度,差异就会很明显了.</p></blockquote><a id="more"></a><h3 id="2、写数据语句时尽可能减少表的全局扫描"><a href="#2、写数据语句时尽可能减少表的全局扫描" class="headerlink" title="2、写数据语句时尽可能减少表的全局扫描"></a>2、写数据语句时尽可能减少表的全局扫描</h3><h5 id="2-1-减少where-字段值null判断"><a href="#2-1-减少where-字段值null判断" class="headerlink" title="2.1 减少where 字段值null判断"></a>2.1 减少where 字段值null判断</h5><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where pay_status = null</code></pre><p>如何这样做,就会导致引擎放弃使用索引而进行全表扫描<br>应该这样去设置(也就是在没有值时,我们在存数据库时自动默认给个o值,而不是什么都不写):</p><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where pay_status = 0</code></pre><h5 id="2-2-应尽量避免在-where-子句中使用-或-lt-gt-操作符"><a href="#2-2-应尽量避免在-where-子句中使用-或-lt-gt-操作符" class="headerlink" title="2.2 应尽量避免在 where 子句中使用!=或&lt;&gt;操作符"></a>2.2 应尽量避免在 where 子句中使用!=或&lt;&gt;操作符</h5><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where pay_status != null ;//或者SELECT * FROM &quot;tb_real_time_car&quot; where pay_status &lt;&gt; null ;</code></pre><p>这样写将导致引擎放弃使用索引而进行全表扫描。</p><h5 id="2-3-应尽量避免在-where-子句中使用-or-来连接条件"><a href="#2-3-应尽量避免在-where-子句中使用-or-来连接条件" class="headerlink" title="2.3 应尽量避免在 where 子句中使用 or 来连接条件"></a>2.3 应尽量避免在 where 子句中使用 or 来连接条件</h5><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where pay_status != null or enter_time = null; </code></pre><p>这样将导致引擎放弃使用索引而进行全表扫描</p><p>可以这样操作:</p><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where pay_status != null union all SELECT * FROM &quot;tb_real_time_car&quot; where enter_time = null; </code></pre><h5 id="2-4-in-和-not-in-也要慎用"><a href="#2-4-in-和-not-in-也要慎用" class="headerlink" title="2.4 in 和 not in 也要慎用"></a>2.4 in 和 not in 也要慎用</h5><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where rowed in [1,2,3,4]; //或者SELECT * FROM &quot;tb_real_time_car&quot; where rowed not in [1,2,3,4]; </code></pre><p>这样操作,也会导致全表扫描</p><p>可以这样来写:</p><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where rowed between 1 and 5; </code></pre><h5 id="2-5-少使用模糊匹配-like"><a href="#2-5-少使用模糊匹配-like" class="headerlink" title="2.5 少使用模糊匹配 like"></a>2.5 少使用模糊匹配 like</h5><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where enter_time like &apos;%2016-09-01%&apos;</code></pre><h5 id="2-6-应尽量避免在-where-子句中对字段进行表达式操作"><a href="#2-6-应尽量避免在-where-子句中对字段进行表达式操作" class="headerlink" title="2.6 应尽量避免在 where 子句中对字段进行表达式操作"></a>2.6 应尽量避免在 where 子句中对字段进行表达式操作</h5><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where rowid/4 =100;</code></pre><p>这样写,将导致引擎放弃使用索引而进行全表扫描</p><p>应该写成:</p><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where rowid =4*100;</code></pre><h5 id="2-7-任何地方都不要使用-通配符去查询所有"><a href="#2-7-任何地方都不要使用-通配符去查询所有" class="headerlink" title="2.7 任何地方都不要使用*通配符去查询所有"></a>2.7 任何地方都不要使用*通配符去查询所有</h5><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where rowid/4 =100;</code></pre><p>以通配符*去查询所有数据,这样做也是非常耗时的,我们应该需要什么字段就查询什么字段.</p><p>应该这样做:</p><pre><code>SELECT leave_time FROM &quot;tb_real_time_car&quot; where rowid/4 =100;</code></pre><h3 id="3、不要在条件判断时进行-算数运算"><a href="#3、不要在条件判断时进行-算数运算" class="headerlink" title="3、不要在条件判断时进行 算数运算"></a>3、不要在条件判断时进行 算数运算</h3><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where rowid/4 =100;</code></pre><p>所以不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算,这样系统将可能无法正确使用索引</p><p>应该这样做:</p><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where rowed =400;</code></pre><h3 id="4、很多时候用-exists-代替-in-是一个好的选择"><a href="#4、很多时候用-exists-代替-in-是一个好的选择" class="headerlink" title="4、很多时候用 exists 代替 in 是一个好的选择"></a>4、很多时候用 exists 代替 in 是一个好的选择</h3><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where rowed (select rowed from &quot;tb_real&quot;);</code></pre><p>应该这样来写:</p><pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where exists (select rowed from &quot;tb_real&quot; where rowed = tb_real.rowid);</code></pre><h3 id="5-论索引技巧"><a href="#5-论索引技巧" class="headerlink" title="5 论索引技巧"></a>5 论索引技巧</h3><h5 id="5-1-并不是所有索引对查询都有效"><a href="#5-1-并不是所有索引对查询都有效" class="headerlink" title="5.1 并不是所有索引对查询都有效"></a>5.1 并不是所有索引对查询都有效</h5><p>SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用</p><h5 id="5-2-索引并不是越多越好"><a href="#5-2-索引并不是越多越好" class="headerlink" title="5.2 索引并不是越多越好"></a>5.2 索引并不是越多越好</h5><p>索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p><h5 id="5-3-应尽可能的避免更新-clustered-索引数据列"><a href="#5-3-应尽可能的避免更新-clustered-索引数据列" class="headerlink" title="5.3 应尽可能的避免更新 clustered 索引数据列"></a>5.3 应尽可能的避免更新 clustered 索引数据列</h5><p>因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p><h5 id="5-4-尽量使用数字型字段"><a href="#5-4-尽量使用数字型字段" class="headerlink" title="5.4 尽量使用数字型字段"></a>5.4 尽量使用数字型字段</h5><p>若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p><h3 id="6-创建数据库时应该注意地方"><a href="#6-创建数据库时应该注意地方" class="headerlink" title="6 创建数据库时应该注意地方"></a>6 创建数据库时应该注意地方</h3><h5 id="6-1-尽可能的使用-varchar-nvarchar-代替-char-nchar"><a href="#6-1-尽可能的使用-varchar-nvarchar-代替-char-nchar" class="headerlink" title="6.1. 尽可能的使用 varchar/nvarchar 代替 char/nchar"></a>6.1. 尽可能的使用 varchar/nvarchar 代替 char/nchar</h5><p>因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p><h5 id="6-2-用表变量来代替临时表。"><a href="#6-2-用表变量来代替临时表。" class="headerlink" title="6.2 用表变量来代替临时表。"></a>6.2 用表变量来代替临时表。</h5><ol><li><p>如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p></li><li><p>在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p></li><li><p>如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p></li></ol><h5 id="6-3-避免频繁创建和删除临时表，以减少系统表资源的消耗。"><a href="#6-3-避免频繁创建和删除临时表，以减少系统表资源的消耗。" class="headerlink" title="6.3 避免频繁创建和删除临时表，以减少系统表资源的消耗。"></a>6.3 避免频繁创建和删除临时表，以减少系统表资源的消耗。</h5><h5 id="6-4-尽量避免使用游标"><a href="#6-4-尽量避免使用游标" class="headerlink" title="6.4 尽量避免使用游标"></a>6.4 尽量避免使用游标</h5><ol><li><p>因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p></li><li><p>使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p></li><li><p>与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p></li></ol><h3 id="7-数据放回时注意什么"><a href="#7-数据放回时注意什么" class="headerlink" title="7 数据放回时注意什么"></a>7 数据放回时注意什么</h3><h5 id="7-1-尽量避免大事务操作，提高系统并发能力。"><a href="#7-1-尽量避免大事务操作，提高系统并发能力。" class="headerlink" title="7.1 尽量避免大事务操作，提高系统并发能力。"></a>7.1 尽量避免大事务操作，提高系统并发能力。</h5><pre><code>这样可以有效提高系统的并发能力</code></pre><h5 id="7-2-尽量避免向客户端返回大数据量"><a href="#7-2-尽量避免向客户端返回大数据量" class="headerlink" title="7.2 尽量避免向客户端返回大数据量"></a>7.2 尽量避免向客户端返回大数据量</h5><pre><code>若数据量过大，应该考虑相应需求是否合理。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、对查询进行优化-应尽可能避免全表扫描&quot;&gt;&lt;a href=&quot;#1、对查询进行优化-应尽可能避免全表扫描&quot; class=&quot;headerlink&quot; title=&quot;1、对查询进行优化,应尽可能避免全表扫描&quot;&gt;&lt;/a&gt;1、对查询进行优化,应尽可能避免全表扫描&lt;/h3&gt;&lt;p&gt;首先应考虑在 where 及 order by 涉及的列上建立索引。&lt;br&gt;下面我们来以一个表中177条数据比较一下,全表扫描与建立索引之后性能的一个比较.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从这两种方式查询数据库结果看,建立索引之后查询速度提高了些,现在数据量还不明显,如果表中有10万条速度,差异就会很明显了.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>关于mysql最左前缀原则</title>
    <link href="https://icocos.github.io/2019/03/01/%E5%85%B3%E4%BA%8Emysql%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99/"/>
    <id>https://icocos.github.io/2019/03/01/关于mysql最左前缀原则/</id>
    <published>2019-03-01T10:47:41.000Z</published>
    <updated>2019-05-22T09:06:40.679Z</updated>
    
    <content type="html"><![CDATA[<h4 id="背景知识："><a href="#背景知识：" class="headerlink" title="背景知识："></a>背景知识：</h4><ol><li>mysql中可以使用explain关键字来查看sql语句的执行计划。</li><li>最左前缀原则主要使用在联合索引中</li><li>数据库版本Mysql5.5.53</li></ol><a id="more"></a><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>mysql建立多列索引（联合索引）有最左前缀的原则，即最左优先，如：</p><ul><li>如果有一个2列的索引(col1,col2),则已经对(col1)、(col1,col2)上建立了索引；</li><li>如果有一个3列索引(col1,col2,col3)，则已经对(col1)、(col1,col2)、(col1,col2,col3)上建立了索引；</li></ul><p>1、b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+树是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道第一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。</p><p>2、比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。（这种情况无法用到联合索引）</p><p>关于最左前缀的使用，有下面两条说明：</p><ul><li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a  = 1 and b = 2 and c &gt; 3 and d = 4  如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li><li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li></ul><p>联合索引有一个最左前缀原则，所以建立联合索引的时候，这个联合索引的字段顺序非常重要</p><p>下面写了例子说明这个：</p><pre><code>CREATE TABLE `test_myisam` (`id` int(11) NOT NULL AUTO_INCREMENT,`conference_id` varchar(200) NOT NULL,`account` varchar(100) DEFAULT NULL,`status` int(2) DEFAULT NULL COMMENT &apos;0:invite,  1:cancel_invite,  2:decline,  3:connect&apos;,`duration` bigint(20) unsigned DEFAULT NULL,`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,PRIMARY KEY (`id`)) ENGINE=myisam AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</code></pre><p>以上表结构，我想通过三列进行查询 account ,status,create_time进行查询统计。</p><h5 id="如何建立索引？"><a href="#如何建立索引？" class="headerlink" title="如何建立索引？"></a>如何建立索引？</h5><p>因为我们有可能按照acccount单独统计，或者按照account status，或者是account，status，create_time进行统计，如何建立索引？？？</p><p>下面是建立索引前后的对比600万数据</p><p>如何生成：执行如下脚本，account和日期不同还有status不同，分别生成一百万。</p><pre><code>CREATE  PROCEDURE `add_data_myisam_cp_27`()begindeclare v_rows int(10) default 1000000;declare v_count int(10) default 0;id_loop:LOOPinsert into test_myisam values(null,round(rand()*1000000000),&apos;cloudp&apos;,round(rand()*3),round(rand()*100000),&apos;2016-07-27 00:00:22&apos;);set v_count= v_count + 1;if v_count&gt;v_rows thenleave id_loop;end if;end loop id_loop;end;</code></pre><p>测试结果利用建立的索引性能提高了三倍：</p><pre><code>MariaDB [prf]&gt; select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and date(create_time)=&apos;2016-07-27&apos;;+----------+| count(1) |+----------+|   167400 |+----------+1 row in set (1.28 sec)MariaDB [prf]&gt; create index as_index on test_myisam(account,status,create_time);Query OK, 6000006 rows affected (31.60 sec)Records: 6000006  Duplicates: 0  Warnings: 0MariaDB [prf]&gt; select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and date(create_time)=&apos;2016-07-27&apos;;+----------+| count(1) |+----------+|   167400 |+----------+1 row in set (0.42 sec)MariaDB [prf]&gt; explain select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and date(create_time)=&apos;2016-07-27&apos;;+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+| id   | select_type | table       | type | possible_keys | key      | key_len | ref         | rows   | Extra                    |+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+|    1 | SIMPLE      | test_myisam | ref  | as_index      | as_index | 308     | const,const | 520216 | Using where; Using index |+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+1 row in set (0.00 sec)</code></pre><p>从1.28秒下降到0.42秒<br>但是这个date(create_time)会对每一列都会转换后对比，这里会比较消耗性能；</p><h5 id="如何利用上索引？？"><a href="#如何利用上索引？？" class="headerlink" title="如何利用上索引？？"></a>如何利用上索引？？</h5><p>修改为：</p><pre><code>MariaDB [prf]&gt; explain select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and date(create_time)=&apos;2016-07-27&apos;;+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+| id   | select_type | table       | type | possible_keys | key      | key_len | ref         | rows   | Extra                    |+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+|    1 | SIMPLE      | test_myisam | ref  | as_index      | as_index | 308     | const,const | 520216 | Using where; Using index |+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+1 row in set (0.00 sec)MariaDB [prf]&gt; select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and create_time  between &apos;2016-07-27&apos; and &apos;2016-07-28&apos;;+----------+| count(1) |+----------+|   167400 |+----------+1 row in set (0.15 sec)MariaDB [prf]&gt; explain select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and create_time  between &apos;2016-07-27&apos; and &apos;2016-07-28&apos;;+------+-------------+-------------+-------+---------------+----------+---------+------+--------+--------------------------+| id   | select_type | table       | type  | possible_keys | key      | key_len | ref  | rows   | Extra                    |+------+-------------+-------------+-------+---------------+----------+---------+------+--------+--------------------------+|    1 | SIMPLE      | test_myisam | range | as_index      | as_index | 312     | NULL | 174152 | Using where; Using index |+------+-------------+-------------+-------+---------------+----------+---------+------+--------+--------------------------+1 row in set (0.00 sec)</code></pre><p>如上效率又提高了三倍，是因为扫描的数据行数减少了，最后一个create_time如果不用索引需要扫描52016行，如果使用了索引扫描174152行，命中的行数为：167400行，命中率非常高了。</p><h5 id="这里有个疑问："><a href="#这里有个疑问：" class="headerlink" title="这里有个疑问："></a>这里有个疑问：</h5><blockquote><p> 如果按照天进行统计，create_time作为联合索引的第一列，如何使用上这个索引呢？？？？</p></blockquote><p>至今没有想清楚，如果这一列是date类型可以直接用上索引，如果在oracle中可以date(create_time)建立函数式索引。但是mysql貌似不支持函数式索引。</p><h5 id="一个解决方式是："><a href="#一个解决方式是：" class="headerlink" title="一个解决方式是："></a>一个解决方式是：</h5><blockquote><p>create_time定义为 date类型，在每一列存入的时候，通过触发器自动把这一行修改为date类型。</p></blockquote><p>如果有好的注意欢迎留言探讨，目前没有好的方式加上create_time，可以从业务上解决，就是每天的统计计算完成以后，直接把数据推到历史表中，统计结果单独存放。</p><h5 id="最后说一下关于索引失效的问题："><a href="#最后说一下关于索引失效的问题：" class="headerlink" title="最后说一下关于索引失效的问题："></a>最后说一下关于索引失效的问题：</h5><ol><li>如果条件中有or，即使其中有条件带索引也不会使用(<strong>这也是为什么尽量少用or的原因</strong>)。<strong>注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引</strong></li><li>对于多列索引，不是使用的第一部分，则不会使用索引（即不符合最左前缀原则）</li><li>like查询是以%开头</li><li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引</li><li>如果mysql估计使用全表扫描要比使用索引快,则不使用索引</li></ol><h6 id="此外，查看索引的使用情况"><a href="#此外，查看索引的使用情况" class="headerlink" title="此外，查看索引的使用情况"></a>此外，查看索引的使用情况</h6><ul><li><p>show status like ‘Handler_read%’;</p></li><li><p>handler_read_key:这个值越高越好，越高表示使用索引查询到的次数</p></li><li>handler_read_rnd_next:这个值越高，说明查询低效</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;背景知识：&quot;&gt;&lt;a href=&quot;#背景知识：&quot; class=&quot;headerlink&quot; title=&quot;背景知识：&quot;&gt;&lt;/a&gt;背景知识：&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;mysql中可以使用explain关键字来查看sql语句的执行计划。&lt;/li&gt;
&lt;li&gt;最左前缀原则主要使用在联合索引中&lt;/li&gt;
&lt;li&gt;数据库版本Mysql5.5.53&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="MySQL" scheme="https://icocos.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://icocos.github.io/tags/MySQL/"/>
    
      <category term="最佳左前缀" scheme="https://icocos.github.io/tags/%E6%9C%80%E4%BD%B3%E5%B7%A6%E5%89%8D%E7%BC%80/"/>
    
  </entry>
  
  <entry>
    <title>PHP之PHP-FPM入门</title>
    <link href="https://icocos.github.io/2019/02/24/PHP%E4%B9%8BPHP-FPM%E5%85%A5%E9%97%A8/"/>
    <id>https://icocos.github.io/2019/02/24/PHP之PHP-FPM入门/</id>
    <published>2019-02-24T10:18:51.000Z</published>
    <updated>2019-05-22T09:17:24.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHP-FPM"><a href="#PHP-FPM" class="headerlink" title="PHP-FPM"></a>PHP-FPM</h1><p>Nginx 和 PHP 通信的主要流程为：通过浏览器访问Url后，请求到web服务器，服务器根据配置文件，确定为PHP脚本文件，转发到PHP解析器，PHP解析器会解析php.ini文件初始化执行环境，然后处理请求，再以标准的数据格式返回处理结果，最后退出进程。</p><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><p>nginx和php-fpm通信有tcp socket和unix socket两种方式：</p><ul><li>unix socket方式：nginx和php-fpm的进程之间通信，速度快，消耗资源少。而tcp需要经过本地回环驱动，还要申请临时端口和tcp相关资源。</li></ul><a id="more"></a><blockquote><p>unix socket相比不是那么稳定，当并发连接数爆发时，会产生大量的长时缓存，在没有面向连接协议支撑的情况下，大数据包很有可能就直接出错并不会返回异常。</p></blockquote><p>虽然socket有更少的数据拷贝和上下文切换，更少的资源占用，但是如果数据都是错的，那还有什么用呢。另外使用unix socket的话，必须nginx和fpm在同一台机器上</p><ul><li>tcp socket方式：tcp协议能保证数据的正确性，可以跨服务器，当nginx和php-fpm不在同一台机器上时，只能使用这种方式，但性能不如unix socket。</li></ul><h2 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h2><p>CGI（Common Gateway Interface）是服务器与后台语言交互的协议，有了这个协议，开发者可以使用任何语言处理服务器转发过来的请求，动态地生成内容，保证了传递过来的数据是标准格式的,规定了以什么样的格式传哪些数据（URL、查询字符串、POST数据、HTTP header等等），方便了开发者。</p><h2 id="PHP-CGI"><a href="#PHP-CGI" class="headerlink" title="PHP-CGI"></a>PHP-CGI</h2><p>PHP语言对应与服务器交互的CGI程序就是PHP-CGI，标准的CGI程序对每个请求都会执行：PHP解析器解析php.ini文件，初始化执行环境。</p><p>CGI程序本身只能解析请求、返回结果，不会进程管理，所以有一个致命的缺点，那就是每处理一个请求都需要fork一个全新的进程，随着Web的兴起，高并发越来越成为常态，这样低效的方式明显不能满足需求，每一次web请求都会有启动和退出进程，也就是最为人诟病的fork-and-execute模式。</p><h2 id="FastCGI"><a href="#FastCGI" class="headerlink" title="FastCGI"></a>FastCGI</h2><p>FastCGI，允许在一个进程内处理多个请求，而不是一个请求处理完毕就直接结束进程，性能上有了很大的提高。</p><p>FastCGI会先启一个master进程，解析配置文件，初始化执行环境，然后再启动多个worker进程。当请求过来时，master会传递给一个worker，然后立即可以接受下一个请求，避免了重复创建进程。当worker不够用时，master可以根据配置预先启动几个worker等着。当然空闲worker太多时，也会停掉一些，这样就提高了性能，也节约了资源。</p><h2 id="PHP-FPM-1"><a href="#PHP-FPM-1" class="headerlink" title="PHP-FPM"></a>PHP-FPM</h2><p>PHP-FPM（FastCGI Process Manager）是FastCGI协议的一个实现，任何实现了FastCGI协议的服务器都能够与之通信。</p><p>FPM是一个PHP进程管理器，包含master和worker两种进程。</p><p>master进程只有一个，负责监听端口，接收来自服务器的请求，而worker进程则一般有多个（具体数量根据实际需要配置），每个进程内部都嵌入了一个PHP解释器，是PHP代码真正执行的地方。</p><p>从FPM接收到请求，到处理完毕，其具体的流程如下：</p><ul><li>FPM的master进程接收到请求。</li><li>master进程根据配置指派特定的worker进程进行请求处理</li><li>如果没有可用进程，返回错误，这也是我们配合Nginx遇到502错误比较多的原因。</li><li>worker进程处理请求，如果超时，返回504错误。</li><li>请求处理结束，返回结果。</li></ul><h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><p>Nginx不仅仅是一个Web服务器，也是一个功能强大的Proxy服务器，除了进行http请求的代理，也可以进行许多其他协议请求的代理，包括与FPM相关的FastCGI协议。</p><p>为了能够使Nginx理解FastCGI协议，Nginx提供了FastCGI模块来将http请求映射为对应的FastCGI请求。</p><blockquote><p>Nginx的FastCGI模块提供了fastcgi_param指令来主要处理这些映射关系，/usr/local/nginx/conf/fastcgi.conf 是Nginx的一个配置文件实例，其主要完成的工作是将Nginx中的变量翻译成PHP中能够理解的变量。</p></blockquote><p>除此之外，非常重要的就是fastcgi_pass指令了，这个指令用于指定FPM进程监听的地址，Nginx会把所有的PHP请求翻译成FastCGI请求之后再发送到这个地址。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;PHP-FPM&quot;&gt;&lt;a href=&quot;#PHP-FPM&quot; class=&quot;headerlink&quot; title=&quot;PHP-FPM&quot;&gt;&lt;/a&gt;PHP-FPM&lt;/h1&gt;&lt;p&gt;Nginx 和 PHP 通信的主要流程为：通过浏览器访问Url后，请求到web服务器，服务器根据配置文件，确定为PHP脚本文件，转发到PHP解析器，PHP解析器会解析php.ini文件初始化执行环境，然后处理请求，再以标准的数据格式返回处理结果，最后退出进程。&lt;/p&gt;
&lt;h2 id=&quot;通信方式&quot;&gt;&lt;a href=&quot;#通信方式&quot; class=&quot;headerlink&quot; title=&quot;通信方式&quot;&gt;&lt;/a&gt;通信方式&lt;/h2&gt;&lt;p&gt;nginx和php-fpm通信有tcp socket和unix socket两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;unix socket方式：nginx和php-fpm的进程之间通信，速度快，消耗资源少。而tcp需要经过本地回环驱动，还要申请临时端口和tcp相关资源。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>高并发大流解决量方案</title>
    <link href="https://icocos.github.io/2019/02/17/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%A4%A7%E6%B5%81%E8%A7%A3%E5%86%B3%E9%87%8F%E6%96%B9%E6%A1%88/"/>
    <id>https://icocos.github.io/2019/02/17/高并发大流解决量方案/</id>
    <published>2019-02-17T04:14:14.000Z</published>
    <updated>2019-05-22T09:17:27.845Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><ul><li>QPS:每秒钟请求或者查询的数量，通常是指每秒相应请求数（http）<ul><li>QPS不等于并发连接数，QPS是每秒的HTTP请求数量，并发连接数是指系统同时处理的请求数量  </li><li>峰值的每秒请求数（QPS）= (总PV数 <em> 80%)/(6小时秒数 </em> 20%)  </li><li>峰值QPS的计算规律主要是80%的访问量集中在20%的访问时间</li></ul></li><li>吞吐量：单位时间内处理请求的数量</li><li>响应时间：从请求发出到收到响应花费的时间</li><li>PV(page view)综合浏览量，即页面点击数。通常日PV在千万级就是高并发的网站</li><li>UV(unique visitor)独立访客，一定时间内相同访客访问网站，只计算为1个独立访客</li></ul><a id="more"></a><ul><li><p>带宽：计算带宽大小，我们需要关注两个指标，峰值流量和平均大小</p><blockquote><p>日网站的带宽 = PV/统计时间（秒） <em> 平均页面大小（KB） </em> 8  </p></blockquote></li><li><p>压力测试</p><ul><li>1.测试能承受的最大并发  </li><li>2.测试最大承受QPS值  </li></ul></li></ul><h5 id="ab-apache-benchmark-工具使用"><a href="#ab-apache-benchmark-工具使用" class="headerlink" title="ab(apache benchmark)工具使用:"></a>ab(apache benchmark)工具使用:</h5><p>ab会创建多个并发访问线程，模拟多个访问者同时对一个URL地址进行访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ab的基本使用</span><br><span class="line">ab -c 100 -n 5000 url</span><br><span class="line">并发请求100次，总共5000次</span><br><span class="line"></span><br><span class="line">测试时注意被测试机器的CPU、内存、网络都不超过最高限度的75%</span><br></pre></td></tr></table></figure><p>此处介绍一些QPS的数值：</p><ol><li>50：小型网站，一般服务器即可应付</li><li>100：假设数据库每次请求都在0.01秒内完成，单个页面只有一个sql，100QPS意味着1秒钟要完成100次请求，但是我们数据库不一定能完成100次查询。此时优化方案为：数据库缓存、数据库负载均衡</li><li>800：假设网站有百兆带宽，意味着实际出口的带宽为8M左右，如果每个页面只有10K，在这个QPS下，带宽已经吃完。此时的方案：CDN加速，负载均衡</li><li>1000： 假设使用nosql来缓存数据库查询（memcache或redis），每个页面对nosql的请求远大于直接对DB的请求</li><li>2000： 业务分离，做分布式存储</li></ol><h3 id="二、优化方案"><a href="#二、优化方案" class="headerlink" title="二、优化方案"></a>二、优化方案</h3><ul><li>流量优化：  </li></ul><ol><li>防盗链处理 </li><li>减少前端http请求（合并css、js等静态资源）</li><li>添加异步请求，减少http请求的并发量</li><li>启用浏览器的缓存和使用文件压缩</li><li>CDN加速，减轻服务器压力和带宽压力<ul><li>服务端优化  </li></ul><ol><li>页面静态化</li><li>并发处理</li></ol><ul><li>数据库优化  </li></ul><ol><li>数据库缓存</li><li>分库分表，分区操作</li><li>读写分离</li><li>负载均衡</li></ol><ul><li>web服务器优化  </li></ul><ol><li>负载均衡</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、概念&quot;&gt;&lt;a href=&quot;#一、概念&quot; class=&quot;headerlink&quot; title=&quot;一、概念&quot;&gt;&lt;/a&gt;一、概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;QPS:每秒钟请求或者查询的数量，通常是指每秒相应请求数（http）&lt;ul&gt;
&lt;li&gt;QPS不等于并发连接数，QPS是每秒的HTTP请求数量，并发连接数是指系统同时处理的请求数量  &lt;/li&gt;
&lt;li&gt;峰值的每秒请求数（QPS）= (总PV数 &lt;em&gt; 80%)/(6小时秒数 &lt;/em&gt; 20%)  &lt;/li&gt;
&lt;li&gt;峰值QPS的计算规律主要是80%的访问量集中在20%的访问时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;吞吐量：单位时间内处理请求的数量&lt;/li&gt;
&lt;li&gt;响应时间：从请求发出到收到响应花费的时间&lt;/li&gt;
&lt;li&gt;PV(page view)综合浏览量，即页面点击数。通常日PV在千万级就是高并发的网站&lt;/li&gt;
&lt;li&gt;UV(unique visitor)独立访客，一定时间内相同访客访问网站，只计算为1个独立访客&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>深入理解PHP之：Nginx 与 FPM 的工作机制</title>
    <link href="https://icocos.github.io/2019/02/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E4%B9%8B%EF%BC%9ANginx-%E4%B8%8E-FPM-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/"/>
    <id>https://icocos.github.io/2019/02/15/深入理解PHP之：Nginx-与-FPM-的工作机制/</id>
    <published>2019-02-15T09:54:22.000Z</published>
    <updated>2019-05-21T08:52:03.574Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>网络上有很多关于如何配置 Nginx + FPM 的文章，但它们更多从操作的角度出发，告诉我们怎么做，但却没有告诉我们为什么要这么做，本文从 Nginx 与 FPM 的工作机制出发，探讨配置背后的原理，让我们真正理解 Nginx 与 PHP 是如何协同工作的。</p><h4 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h4><p>要说 Nginx 与 PHP 是如何协同工作的，首先得说 CGI (Common Gateway Interface) 和 FastCGI 这两个协议。</p><a id="more"></a><blockquote><p>CGI 是 Web Server 与后台语言交互的协议，有了这个协议，开发者可以使用任何语言处理 Web Server 发来的请求，动态的生成内容。但 CGI 有一个致命的缺点，那就是每处理一个请求都需要 fork 一个全新的进程，随着 Web 的兴起，高并发越来越成为常态，这样低效的方式明显不能满足需求。就这样，FastCGI 诞生了，CGI 很快就退出了历史的舞台。FastCGI，顾名思义为更快的 CGI，它允许在一个进程内处理多个请求，而不是一个请求处理完毕就直接结束进程，性能上有了很大的提高。</p></blockquote><p>FPM (FastCGI Process Manager)，它是 FastCGI 的实现，任何实现了 FastCGI 协议的 Web Server 都能够与之通信。FPM 之于标准的 FastCGI，也提供了一些增强功能，具体可以参考官方文档：PHP: FPM Installation。</p><pre><code>FPM 是一个 PHP 进程管理器，包含 master 进程和 worker 进程两种进程：master 进程只有一个，负责监听端口，接收来自 Web Server 的请求，而 worker 进程则一般有多个 (具体数量根据实际需要配置)，每个进程内部都嵌入了一个 PHP 解释器，是 PHP 代码真正执行的地方，下图是我本机上 fpm 的进程情况，1一个 master 进程，3个 worker 进程：</code></pre><p><img src="http://img0.ph.126.net/WMv1Zu5I-rlmKMoUTc68-Q==/6631597730303787300.png" alt="fpm进程"></p><p>从 FPM 接收到请求，到处理完毕，其具体的流程如下：</p><pre><code>1. FPM 的 master 进程接收到请求2. master 进程根据配置指派特定的 worker进程进行请求处理，如果没有可用进程，返回错误，这也是我们配合 Nginx 遇到502错误比较多的原因。3. worker 进程处理请求，如果超时，返回504错误4. 请求处理结束，返回结果</code></pre><p>FPM 从接收到处理请求的流程就是这样了，那么 Nginx 又是如何发送请求给 fpm 的呢？这就需要从 Nginx 层面来说明了。</p><p>Nginx 不仅仅是一个 Web 服务器，也是一个功能强大的 Proxy 服务器，除了进行 http 请求的代理，也可以进行许多其他协议请求的代理，包括本文与 fpm 相关的 fastcgi 协议。为了能够使 Nginx 理解 fastcgi 协议，Nginx 提供了 fastcgi 模块来将 http 请求映射为对应的 fastcgi 请求。</p><blockquote><p>Nginx 的 fastcgi 模块提供了 fastcgi_param 指令来主要处理这些映射关系，下面 Ubuntu 下 Nginx 的一个配置文件，其主要完成的工作是将 Nginx 中的变量翻译成 PHP 中能够理解的变量。</p></blockquote><p><img src="http://img2.ph.126.net/QWqq90MIXEcQnTA7ft1WVg==/6631819831652599451.jpg" alt="fastcgi_param"></p><p>除此之外，非常重要的就是 fastcgi_pass 指令了，这个指令用于指定 fpm 进程监听的地址，Nginx 会把所有的 php 请求翻译成 fastcgi 请求之后再发送到这个地址。下面一个简单的可以工作的 Nginx 配置文件：</p><p><img src="http://img0.ph.126.net/tLal8xnxIanLB_mfp2dHUQ==/6631751661931678563.jpg" alt="nginx配置"></p><p>在这个配置文件中，我们新建了一个虚拟主机，监听在 80 端口，Web 根目录为 /home/rf/projects/wordpress。然后我们通过 location 指令，将所有的以 .php 结尾的请求都交给 fastcgi 模块处理，从而把所有的 php 请求都交给了 fpm 处理，从而完成 Nginx 到 fpm 的闭环。</p><p>如此以来，Nginx 与 FPM 通信的整个流程应该比较清晰了吧。</p><ol><li>nginx是web服务器，提供http服务。</li><li>php代码需要php解析器解析。所以这里要有个nginx和php解析器通信的问题。就出现了一个fastcgi的协议来解决通信问题。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;网络上有很多关于如何配置 Nginx + FPM 的文章，但它们更多从操作的角度出发，告诉我们怎么做，但却没有告诉我们为什么要这么做，本文从 Nginx 与 FPM 的工作机制出发，探讨配置背后的原理，让我们真正理解 Nginx 与 PHP 是如何协同工作的。&lt;/p&gt;
&lt;h4 id=&quot;内容：&quot;&gt;&lt;a href=&quot;#内容：&quot; class=&quot;headerlink&quot; title=&quot;内容：&quot;&gt;&lt;/a&gt;内容：&lt;/h4&gt;&lt;p&gt;要说 Nginx 与 PHP 是如何协同工作的，首先得说 CGI (Common Gateway Interface) 和 FastCGI 这两个协议。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="Nginx" scheme="https://icocos.github.io/tags/Nginx/"/>
    
      <category term="FPM" scheme="https://icocos.github.io/tags/FPM/"/>
    
  </entry>
  
  <entry>
    <title>LVS负载均衡（LVS简介、三种工作模式、十种调度算法）</title>
    <link href="https://icocos.github.io/2019/01/25/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%88LVS%E7%AE%80%E4%BB%8B%E3%80%81%E4%B8%89%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E3%80%81%E5%8D%81%E7%A7%8D%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%89/"/>
    <id>https://icocos.github.io/2019/01/25/LVS负载均衡（LVS简介、三种工作模式、十种调度算法）/</id>
    <published>2019-01-25T10:47:41.000Z</published>
    <updated>2019-05-22T09:17:26.696Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、LVS简介"><a href="#一、LVS简介" class="headerlink" title="一、LVS简介"></a>一、LVS简介</h3><p>LVS（Linux Virtual Server）即Linux虚拟服务器，是由章文嵩博士主导的开源负载均衡项目，目前LVS已经被集成到Linux内核模块中。</p><p>该项目在Linux内核中实现了基于IP的数据请求负载均衡调度方案，终端互联网用户从外部访问公司的外部负载均衡服务器，终端用户的Web请求会发送给LVS调度器，调度器根据自己预设的算法决定将该请求发送给后端的某台Web服务器，比如，轮询算法可以将外部的请求平均分发给后端的所有服务器，终端用户访问LVS调度器虽然会被转发到后端真实的服务器，但如果真实服务器连接的是相同的存储，提供的服务也是相同的服务，最终用户不管是访问哪台真实服务器，得到的服务内容都是一样的，整个集群对用户而言都是透明的。</p><a id="more"></a><blockquote><p> 最后根据LVS工作模式的不同，真实服务器会选择不同的方式将用户需要的数据发送到终端用户，LVS工作模式分为NAT模式、TUN模式、以及DR模式。</p></blockquote><h3 id="二、三种工作模式的解析。"><a href="#二、三种工作模式的解析。" class="headerlink" title="二、三种工作模式的解析。"></a>二、三种工作模式的解析。</h3><h5 id="1、基于NAT的LVS模式负载均衡"><a href="#1、基于NAT的LVS模式负载均衡" class="headerlink" title="1、基于NAT的LVS模式负载均衡"></a>1、基于NAT的LVS模式负载均衡</h5><p> NAT（Network Address Translation）即网络地址转换，其作用是通过数据报头的修改，使得位于企业内部的私有IP地址可以访问外网，以及外部用用户可以访问位于公司内部的私有IP主机。VS/NAT工作模式拓扑结构如图2所示，LVS负载调度器可以使用两块网卡配置不同的IP地址，eth0设置为私钥IP与内部网络通过交换设备相互连接，eth1设备为外网IP与外部网络联通。</p><ul><li>第一步，用户通过互联网DNS服务器解析到公司负载均衡设备上面的外网地址，相对于真实服务器而言，LVS外网IP又称VIP（Virtual IP Address），用户通过访问VIP，即可连接后端的真实服务器（Real Server），而这一切对用户而言都是透明的，用户以为自己访问的就是真实服务器，但他并不知道自己访问的VIP仅仅是一个调度器，也不清楚后端的真实服务器到底在哪里、有多少真实服务器。</li><li>第二步，用户将请求发送至124.126.147.168，此时LVS将根据预设的算法选择后端的一台真实服务器（192.168.0.1~192.168.0.3），将数据请求包转发给真实服务器，并且在转发之前LVS会修改数据包中的目标地址以及目标端口，目标地址与目标端口将被修改为选出的真实服务器IP地址以及相应的端口。</li><li>第三步，真实的服务器将响应数据包返回给LVS调度器，调度器在得到响应的数据包后会将源地址和源端口修改为VIP及调度器相应的端口，修改完成后，由调度器将响应数据包发送回终端用户，另外，由于LVS调度器有一个连接Hash表，该表中会记录连接请求及转发信息，当同一个连接的下一个数据包发送给调度器时，从该Hash表中可以直接找到之前的连接记录，并根据记录信息选出相同的真实服务器及端口信息。</li></ul><h5 id="2、基于TUN的LVS负载均衡"><a href="#2、基于TUN的LVS负载均衡" class="headerlink" title="2、基于TUN的LVS负载均衡"></a>2、基于TUN的LVS负载均衡</h5><p>在LVS（NAT）模式的集群环境中，由于所有的数据请求及响应的数据包都需要经过LVS调度器转发，如果后端服务器的数量大于10台，则调度器就会成为整个集群环境的瓶颈。我们知道，数据请求包往往远小于响应数据包的大小。因为响应数据包中包含有客户需要的具体数据，所以LVS（TUN）的思路就是将请求与响应数据分离，让调度器仅处理数据请求，而让真实服务器响应数据包直接返回给客户端。</p><p>VS/TUN工作模式拓扑结构如图3所示。其中，IP隧道（IP tunning）是一种数据包封装技术，它可以将原始数据包封装并添加新的包头（内容包括新的源地址及端口、目标地址及端口），从而实现将一个目标为调度器的VIP地址的数据包封装，通过隧道转发给后端的真实服务器（Real Server），通过将客户端发往调度器的原始数据包封装，并在其基础上添加新的数据包头（修改目标地址为调度器选择出来的真实服务器的IP地址及对应端口），LVS（TUN）模式要求真实服务器可以直接与外部网络连接，真实服务器在收到请求数据包后直接给客户端主机响应数据。</p><h5 id="3、基于DR的LVS负载均衡"><a href="#3、基于DR的LVS负载均衡" class="headerlink" title="3、基于DR的LVS负载均衡"></a>3、基于DR的LVS负载均衡</h5><p>在LVS（TUN）模式下，由于需要在LVS调度器与真实服务器之间创建隧道连接，这同样会增加服务器的负担。与LVS（TUN）类似，DR模式也叫直接路由模式，其体系结构如图4所示，该模式中LVS依然仅承担数据的入站请求以及根据算法选出合理的真实服务器，最终由后端真实服务器负责将响应数据包发送返回给客户端。与隧道模式不同的是，直接路由模式（DR模式）要求调度器与后端服务器必须在同一个局域网内，VIP地址需要在调度器与后端所有的服务器间共享，因为最终的真实服务器给客户端回应数据包时需要设置源IP为VIP地址，目标IP为客户端IP，这样客户端访问的是调度器的VIP地址，回应的源地址也依然是该VIP地址（真实服务器上的VIP），客户端是感觉不到后端服务器存在的。由于多台计算机都设置了同样一个VIP地址，所以在直接路由模式中要求调度器的VIP地址是对外可见的，客户端需要将请求数据包发送到调度器主机，而所有的真实服务器的VIP地址必须配置在Non-ARP的网络设备上，也就是该网络设备并不会向外广播自己的MAC及对应的IP地址，真实服务器的VIP对外界是不可见的，但真实服务器却可以接受目标地址VIP的网络请求，并在回应数据包时将源地址设置为该VIP地址。调度器根据算法在选出真实服务器后，在不修改数据报文的情况下，将数据帧的MAC地址修改为选出的真实服务器的MAC地址，通过交换机将该数据帧发给真实服务器。整个过程中，真实服务器的VIP不需要对外界可见。</p><h3 id="三、LVS负载均衡调度算法"><a href="#三、LVS负载均衡调度算法" class="headerlink" title="三、LVS负载均衡调度算法"></a>三、LVS负载均衡调度算法</h3><p>根据前面的介绍，我们了解了LVS的三种工作模式，但不管实际环境中采用的是哪种模式，调度算法进行调度的策略与算法都是LVS的核心技术，LVS在内核中主要实现了一下十种调度算法。</p><h5 id="1-轮询调度"><a href="#1-轮询调度" class="headerlink" title="1.轮询调度"></a>1.轮询调度</h5><p>轮询调度（Round Robin 简称’RR’）算法就是按依次循环的方式将请求调度到不同的服务器上，该算法最大的特点就是实现简单。轮询算法假设所有的服务器处理请求的能力都一样的，调度器会将所有的请求平均分配给每个真实服务器。</p><h5 id="2-加权轮询调度"><a href="#2-加权轮询调度" class="headerlink" title="2.加权轮询调度"></a>2.加权轮询调度</h5><p>加权轮询（Weight Round Robin 简称’WRR’）算法主要是对轮询算法的一种优化与补充，LVS会考虑每台服务器的性能，并给每台服务器添加一个权值，如果服务器A的权值为1，服务器B的权值为2，则调度器调度到服务器B的请求会是服务器A的两倍。权值越高的服务器，处理的请求越多。</p><h5 id="3-最小连接调度"><a href="#3-最小连接调度" class="headerlink" title="3.最小连接调度"></a>3.最小连接调度</h5><p>最小连接调度（Least Connections 简称’LC’）算法是把新的连接请求分配到当前连接数最小的服务器。最小连接调度是一种动态的调度算法，它通过服务器当前活跃的连接数来估计服务器的情况。调度器需要记录各个服务器已建立连接的数目，当一个请求被调度到某台服务器，其连接数加1；当连接中断或者超时，其连接数减1。</p><p>（集群系统的真实服务器具有相近的系统性能，采用最小连接调度算法可以比较好地均衡负载。)</p><h5 id="4-加权最小连接调度"><a href="#4-加权最小连接调度" class="headerlink" title="4.加权最小连接调度"></a>4.加权最小连接调度</h5><p>加权最少连接（Weight Least Connections 简称’WLC’）算法是最小连接调度的超集，各个服务器相应的权值表示其处理性能。服务器的缺省权值为1，系统管理员可以动态地设置服务器的权值。加权最小连接调度在调度新连接时尽可能使服务器的已建立连接数和其权值成比例。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。</p><h5 id="5-基于局部的最少连接"><a href="#5-基于局部的最少连接" class="headerlink" title="5.基于局部的最少连接"></a>5.基于局部的最少连接</h5><p>基于局部的最少连接调度（Locality-Based Least Connections 简称’LBLC’）算法是针对请求报文的目标IP地址的 负载均衡调度，目前主要用于Cache集群系统，因为在Cache集群客户请求报文的目标IP地址是变化的。这里假设任何后端服务器都可以处理任一请求，算法的设计目标是在服务器的负载基本平衡情况下，将相同目标IP地址的请求调度到同一台服务器，来提高各台服务器的访问局部性和Cache命中率，从而提升整个集群系统的处理能力。LBLC调度算法先根据请求的目标IP地址找出该目标IP地址最近使用的服务器，若该服务器是可用的且没有超载，将请求发送到该服务器；若服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则使用’最少连接’的原则选出一个可用的服务器，将请求发送到服务器。</p><h5 id="6-带复制的基于局部性的最少连接"><a href="#6-带复制的基于局部性的最少连接" class="headerlink" title="6.带复制的基于局部性的最少连接"></a>6.带复制的基于局部性的最少连接</h5><p>带复制的基于局部性的最少连接（Locality-Based Least Connections with Replication  简称’LBLCR’）算法也是针对目标IP地址的负载均衡，目前主要用于Cache集群系统，它与LBLC算法不同之处是它要维护从一个目标IP地址到一组服务器的映射，而LBLC算法维护从一个目标IP地址到一台服务器的映射。按’最小连接’原则从该服务器组中选出一一台服务器，若服务器没有超载，将请求发送到该服务器；若服务器超载，则按’最小连接’原则从整个集群中选出一台服务器，将该服务器加入到这个服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。</p><h5 id="7-目标地址散列调度"><a href="#7-目标地址散列调度" class="headerlink" title="7.目标地址散列调度"></a>7.目标地址散列调度</h5><p>目标地址散列调度（Destination Hashing 简称’DH’）算法先根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且并未超载，将请求发送到该服务器，否则返回空。</p><h5 id="8-源地址散列调度U"><a href="#8-源地址散列调度U" class="headerlink" title="8.源地址散列调度U"></a>8.源地址散列调度U</h5><p>源地址散列调度（Source Hashing  简称’SH’）算法先根据请求的源IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且并未超载，将请求发送到该服务器，否则返回空。它采用的散列函数与目标地址散列调度算法的相同，它的算法流程与目标地址散列调度算法的基本相似。</p><h5 id="9-最短的期望的延迟"><a href="#9-最短的期望的延迟" class="headerlink" title="9.最短的期望的延迟"></a>9.最短的期望的延迟</h5><p>最短的期望的延迟调度（Shortest Expected Delay 简称’SED’）算法基于WLC算法。举个例子吧，ABC三台服务器的权重分别为1、2、3 。那么如果使用WLC算法的话一个新请求进入时它可能会分给ABC中的任意一个。使用SED算法后会进行一个运算</p><p>A：（1+1）/1=2   B：（1+2）/2=3/2   C：（1+3）/3=4/3   就把请求交给得出运算结果最小的服务器。</p><h5 id="10-最少队列调度"><a href="#10-最少队列调度" class="headerlink" title="10.最少队列调度"></a>10.最少队列调度</h5><p>最少队列调度（Never Queue 简称’NQ’）算法，无需队列。如果有realserver的连接数等于0就直接分配过去，不需要在进行SED运算。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、LVS简介&quot;&gt;&lt;a href=&quot;#一、LVS简介&quot; class=&quot;headerlink&quot; title=&quot;一、LVS简介&quot;&gt;&lt;/a&gt;一、LVS简介&lt;/h3&gt;&lt;p&gt;LVS（Linux Virtual Server）即Linux虚拟服务器，是由章文嵩博士主导的开源负载均衡项目，目前LVS已经被集成到Linux内核模块中。&lt;/p&gt;
&lt;p&gt;该项目在Linux内核中实现了基于IP的数据请求负载均衡调度方案，终端互联网用户从外部访问公司的外部负载均衡服务器，终端用户的Web请求会发送给LVS调度器，调度器根据自己预设的算法决定将该请求发送给后端的某台Web服务器，比如，轮询算法可以将外部的请求平均分发给后端的所有服务器，终端用户访问LVS调度器虽然会被转发到后端真实的服务器，但如果真实服务器连接的是相同的存储，提供的服务也是相同的服务，最终用户不管是访问哪台真实服务器，得到的服务内容都是一样的，整个集群对用户而言都是透明的。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>PHP实现跨域解决方法</title>
    <link href="https://icocos.github.io/2019/01/17/PHP%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://icocos.github.io/2019/01/17/PHP实现跨域解决方法/</id>
    <published>2019-01-17T10:47:41.000Z</published>
    <updated>2019-05-22T09:17:23.963Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PHP实现跨域解决方法"><a href="#PHP实现跨域解决方法" class="headerlink" title="PHP实现跨域解决方法"></a>PHP实现跨域解决方法</h3><p>如果要实现跨域通过设置Access-Control-Allow-Origin来实现跨域。</p><pre><code>例如：客户端的域名是client.runoob.com，而请求的域名是server.runoob.com。</code></pre><p>如果直接使用ajax访问，会有以下错误：</p><pre><code>XMLHttpRequest cannot load http://server.runoob.com/server.php. No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource.Origin &apos;http://client.runoob.com&apos; is therefore not allowed access.</code></pre><a id="more"></a><h5 id="1、允许单个域名访问"><a href="#1、允许单个域名访问" class="headerlink" title="1、允许单个域名访问"></a>1、允许单个域名访问</h5><p>指定某域名（<a href="http://client.runoob.com）跨域访问，则只需在http://server.runoob.com/server.php文件头部添加如下代码：" target="_blank" rel="noopener">http://client.runoob.com）跨域访问，则只需在http://server.runoob.com/server.php文件头部添加如下代码：</a></p><pre><code>header(&apos;Access-Control-Allow-Origin:http://client.runoob.com&apos;);</code></pre><h5 id="2、允许多个域名访问"><a href="#2、允许多个域名访问" class="headerlink" title="2、允许多个域名访问"></a>2、允许多个域名访问</h5><p>指定多个域名（<a href="http://client1.runoob.com、http://client2.runoob.com等）跨域访问，则只需在http://server.runoob.com/server.php文件头部添加如下代码：" target="_blank" rel="noopener">http://client1.runoob.com、http://client2.runoob.com等）跨域访问，则只需在http://server.runoob.com/server.php文件头部添加如下代码：</a></p><pre><code>$origin = isset($_SERVER[&apos;HTTP_ORIGIN&apos;])? $_SERVER[&apos;HTTP_ORIGIN&apos;] : &apos;&apos;;  $allow_origin = array(      &apos;http://client1.runoob.com&apos;,      &apos;http://client2.runoob.com&apos;  );  if(in_array($origin, $allow_origin)){      header(&apos;Access-Control-Allow-Origin:&apos;.$origin);       }</code></pre><h5 id="3、允许所有域名访问"><a href="#3、允许所有域名访问" class="headerlink" title="3、允许所有域名访问"></a>3、允许所有域名访问</h5><p>允许所有域名访问则只需在<a href="http://server.runoob.com/server.php文件头部添加如下代码：" target="_blank" rel="noopener">http://server.runoob.com/server.php文件头部添加如下代码：</a></p><pre><code>header(&apos;Access-Control-Allow-Origin:*&apos;);</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>php解决跨域问题</p><pre><code>//需要在使用的方法加上跨域请求            header(&apos;content-type:application:json;charset=utf8&apos;);header(&apos;Access-Control-Allow-Origin:*&apos;);header(&apos;Access-Control-Allow-Methods:POST&apos;);header(&apos;Access-Control-Allow-Headers:x-requested-with,content-type&apos;);</code></pre><blockquote><p>待处理：JSON，代理 。。。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;PHP实现跨域解决方法&quot;&gt;&lt;a href=&quot;#PHP实现跨域解决方法&quot; class=&quot;headerlink&quot; title=&quot;PHP实现跨域解决方法&quot;&gt;&lt;/a&gt;PHP实现跨域解决方法&lt;/h3&gt;&lt;p&gt;如果要实现跨域通过设置Access-Control-Allow-Origin来实现跨域。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例如：客户端的域名是client.runoob.com，而请求的域名是server.runoob.com。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果直接使用ajax访问，会有以下错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;XMLHttpRequest cannot load http://server.runoob.com/server.php. No &amp;apos;Access-Control-Allow-Origin&amp;apos; header is present on the requested resource.Origin &amp;apos;http://client.runoob.com&amp;apos; is therefore not allowed access.
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>关于流量优化方案</title>
    <link href="https://icocos.github.io/2019/01/11/%E5%85%B3%E4%BA%8E%E6%B5%81%E9%87%8F%E4%BC%98%E5%8C%96/"/>
    <id>https://icocos.github.io/2019/01/11/关于流量优化/</id>
    <published>2019-01-11T04:14:14.000Z</published>
    <updated>2019-05-22T09:06:19.887Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、防盗链"><a href="#一、防盗链" class="headerlink" title="一、防盗链"></a>一、防盗链</h3><h5 id="盗链"><a href="#盗链" class="headerlink" title="盗链"></a>盗链</h5><blockquote><p>在自己的页面上展示一些并不在自己服务器上的内容。<br>获取他人服务器上的资源地址，绕过别人的资源展示页面，直接在自己的页面上向用户输出<br>防盗链则是防止别人通过技术手段盗取本站的资源，让不是本站展示的资源链接失效</p></blockquote><a id="more"></a><h5 id="防盗链原理："><a href="#防盗链原理：" class="headerlink" title="防盗链原理："></a>防盗链原理：</h5><p>通过referer或者签名（在资源地址后面带上一串签名，每次收到请求验证签名），网站可以检测目标访问的来源网页，如果是资源文件，则可以跟踪到他显示的网页地址。一旦检测到来源不是本站则进行组织或者返回指定页面。</p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><blockquote><p>Referer</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Nginx模块 ngx_http_referer_module 用来阻挡来源非法的域名请求</span><br><span class="line">Nginx指令 valid_referers 全局变量$invalid_referer</span><br><span class="line"></span><br><span class="line">valid_referers none|blocked|server_names|string....;</span><br><span class="line">none: referer 来源头部为空</span><br><span class="line">blocked: referer不为空，但是里面的值被代理或者防火墙删除了，这些值并不以http：//或者https://开头</span><br><span class="line">server_names: referer来源头部包含当前的server_names</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">location ~ .*\.(gif|jpeg|png|flv|swf|rar|zip)$</span><br><span class="line">&#123;</span><br><span class="line">    valid_referer none blocked haobin.com *.haobin.com;</span><br><span class="line">    if($invalid_referer)</span><br><span class="line">    &#123;</span><br><span class="line">        #return 403;</span><br><span class="line">        rewrite ^/http://www.haobin.com/403.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="如果有人伪造referer，可以通过签名的方法解决"><a href="#如果有人伪造referer，可以通过签名的方法解决" class="headerlink" title="如果有人伪造referer，可以通过签名的方法解决"></a>如果有人伪造referer，可以通过签名的方法解决</h5><blockquote><p>加密签名</p></blockquote><p>通过第三方模块HttpAccessKeyModule实现Nginx防盗链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">首先安装这个模块</span><br><span class="line">accesskey on|off    模块开关</span><br><span class="line">accesskey_hashmethod md5 | sha-1    指定签名加密方式</span><br><span class="line">accesskey_arg    GET参数的名称</span><br><span class="line">accesskey_signature     加密规则</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">location ~ .*\.(gif|jpeg|png|flv|swf|zip|rar)$</span><br><span class="line">&#123;</span><br><span class="line">    accesskey on;</span><br><span class="line">    accesskey_hashmethod md5;</span><br><span class="line">    accesskey_arg &quot;key&quot;;</span><br><span class="line">    accesskey_signature &quot;sign$remote_addr&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、减少HTTP请求"><a href="#二、减少HTTP请求" class="headerlink" title="二、减少HTTP请求"></a>二、减少HTTP请求</h3><h5 id="性能黄金法则："><a href="#性能黄金法则：" class="headerlink" title="性能黄金法则："></a>性能黄金法则：</h5><p>只有10%-20%的最终用户响应时间花在接受请求的HTML文档上，剩下的80%-90%时间花在HTML文档所引用的组件（图片、css、script等）进行的http请求上</p><h5 id="1-图片地图：允许在一个图片上关联多个url，目标的url选择取决于用户单击了图片上的哪个位置。"><a href="#1-图片地图：允许在一个图片上关联多个url，目标的url选择取决于用户单击了图片上的哪个位置。" class="headerlink" title="1.图片地图：允许在一个图片上关联多个url，目标的url选择取决于用户单击了图片上的哪个位置。"></a>1.图片地图：允许在一个图片上关联多个url，目标的url选择取决于用户单击了图片上的哪个位置。</h5><p>例如有五张图片，每张图片对应一个超链接。此时就产生了五个http请求，我们将五张图片合成为一张图片，然后以图片的位置定位超链接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">实现</span><br><span class="line">&lt;map&gt;</span><br><span class="line">    &lt;area&gt;&lt;/area&gt;</span><br><span class="line">    &lt;area&gt;&lt;/area&gt;</span><br><span class="line">    &lt;area&gt;&lt;/area&gt;</span><br><span class="line">    ........</span><br><span class="line">&lt;/map&gt;</span><br></pre></td></tr></table></figure><h5 id="2-CSS-Sprites（CSS-精灵）"><a href="#2-CSS-Sprites（CSS-精灵）" class="headerlink" title="2.CSS Sprites（CSS 精灵）"></a>2.CSS Sprites（CSS 精灵）</h5><p>通过使用合并图片，指定css的background-image和background-position来显示元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background-position属性</span><br><span class="line">background-position:x,y; x和y可以写正值也可以写负值，我们可以想象图片左上方(0,0)，以(0,0)坐标向右的是负数的x轴，以(0,0)坐标向下的是负数的y轴</span><br></pre></td></tr></table></figure><h5 id="3-合并脚本和样式表"><a href="#3-合并脚本和样式表" class="headerlink" title="3.合并脚本和样式表"></a>3.合并脚本和样式表</h5><h5 id="4-图片使用base64编码减少页面请求数"><a href="#4-图片使用base64编码减少页面请求数" class="headerlink" title="4.图片使用base64编码减少页面请求数"></a>4.图片使用base64编码减少页面请求数</h5><blockquote><p>采用Base64编码直接将图片嵌入网页当中</p></blockquote><h3 id="三、浏览器缓存和压缩技术"><a href="#三、浏览器缓存和压缩技术" class="headerlink" title="三、浏览器缓存和压缩技术"></a>三、浏览器缓存和压缩技术</h3><h5 id="1-HTTP缓存分类"><a href="#1-HTTP缓存分类" class="headerlink" title="1.HTTP缓存分类"></a>1.HTTP缓存分类</h5><blockquote><p>http缓存类型中，请求成功会有三种情况：</p></blockquote><pre><code>200 from cache：直接从本地缓存中获取相应，最快速，最省流量（network的size字段）  304 not modify： 协商缓存，浏览器在没有命中的情况下请求头中发送一定的校验数据到服务端，如果服务端没有改变，浏览器从本地缓存相应，返回304。 该方式，只返回一些基本的头信息，不发送实际的相应体200 ok： 以上两种缓存失败，服务器返回完整的相应。 该方式没有用到缓存，是最慢的。</code></pre><h5 id="2-本地缓存"><a href="#2-本地缓存" class="headerlink" title="2.本地缓存"></a>2.本地缓存</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Pragma： HTTP1.0的属性，该字段设置为no-cache，会告知浏览器禁用本地缓存</span><br><span class="line"></span><br><span class="line">Expires: HTTP1.0的属性，用来启用本地缓存。expires的值对应为一个类似</span><br><span class="line">Thu, 31 Dec 2017 20:11:20 GMT的格林威治时间，告诉浏览器如果还没有到该时间，则缓存有效，无须发送请求。这个时间是服务器返回的，是以服务器的时间为基准，如果服务器和客户端的时间不一致就可能产生差错。</span><br><span class="line"></span><br><span class="line">Cache-Control: 告知浏览器缓存过期的时间间隔。</span><br><span class="line">no-store: 禁止浏览器缓存</span><br><span class="line">no-cache: 不允许直接使用本地缓存，先发起请求和服务器协商</span><br><span class="line">max-age=delta-seconds: 告知浏览器响应本地缓存的最长期限，以秒为单位</span><br><span class="line"></span><br><span class="line">优先级：Pragrma &gt; Cache-Control &gt; Expires</span><br></pre></td></tr></table></figure><h5 id="3-协商缓存"><a href="#3-协商缓存" class="headerlink" title="3.协商缓存"></a>3.协商缓存</h5><blockquote><p>浏览器没有命中本地缓存，如果本地缓存过期或者响应不允许直接使用本地缓存，那么浏览器会发起服务端请求，服务端会验证数据是否被修改，如果没有被修改就通知浏览器使用本地缓存</p></blockquote><p>相关的Header：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: 通知浏览器资源的最后修改时间（一个格林威治时间）</span><br><span class="line">If-Modified-Since: 得到资源最后修改时间后，会将这个If-Modified-Since（Last-Modified的值）提交到服务器做检查，如果没有修改，就返回304</span><br><span class="line"></span><br><span class="line">ETag: HTTP1.1属性，指纹标识符，如果文件发生更改，指纹会改变</span><br><span class="line">If-None_Match: 本地缓存失效，会携带此值（ETage 的值）去请求服务端，服务端判断资源是否改变，如果没有改变，直接使用本地缓存，返回304</span><br></pre></td></tr></table></figure><h5 id="4-缓存对象的选择"><a href="#4-缓存对象的选择" class="headerlink" title="4.缓存对象的选择"></a>4.缓存对象的选择</h5><ul><li>不变的内容适合本地缓存：图像，js，css，可下载的媒体文件等</li><li>适合协商缓存的文件：HTML文件，经常替换的图片，经常修改的js、css等文件</li></ul><h5 id="5-Nginx配置缓存策略"><a href="#5-Nginx配置缓存策略" class="headerlink" title="5.Nginx配置缓存策略"></a>5.Nginx配置缓存策略</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*****通过PHP模拟Last-Modified-&gt;If-Modified-Since模式******</span><br><span class="line">// 读取上一次修改时间</span><br><span class="line">$since = $_SERVER[&apos;HTTP_IF_MODIFIED-SINCE&apos;];</span><br><span class="line">$lifetime = 3600; // 模拟缓存一分钟</span><br><span class="line">// 如果没过期就返回304</span><br><span class="line">if(strtotime($since) + $lifetiem &gt; time())&#123;</span><br><span class="line">    header(&apos;HTTP/1.1 304 NOT MODIFIED&apos;);</span><br><span class="line">    exit;</span><br><span class="line">&#125;</span><br><span class="line">// 返回Last-Modified相应头</span><br><span class="line">header(&apos;Last-Modified: &apos;.gmdate(&apos;D, d M Y H:i:s&apos;, time())). &apos;GMT&apos;);</span><br></pre></td></tr></table></figure><h5 id="Nginx缓存配置："><a href="#Nginx缓存配置：" class="headerlink" title="Nginx缓存配置："></a>Nginx缓存配置：</h5><blockquote><p>本地缓存配置指令：  </p></blockquote><pre><code>add_header： 添加状态码为2XX和3XX的响应头  add_header name value \[always]; 语法格式  可以通过该指令来设置Pragma/Expires/Cache-Control</code></pre><blockquote><p>expires指令： 通知浏览器过期时长  </p></blockquote><pre><code>expires time;  语法格式  为负值表示Cache-Control: no-cache   为正直表示Cache-Control:max-age=指定时间 </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Nginx缓存配置：</span><br><span class="line"># 遇到图片等资源就缓存30天</span><br><span class="line">location ~ .*\.(gif|jpeg|png|flv|swf|zip|rar)$</span><br><span class="line">&#123;</span><br><span class="line">    expires     30d;</span><br><span class="line">&#125;</span><br><span class="line">$ 遇到js/css等资源就缓存12小时</span><br><span class="line">location ~ .*\.(js|css)?$</span><br><span class="line">&#123;</span><br><span class="line">    expires     12h;</span><br><span class="line">&#125;</span><br><span class="line"># expires   max; 代表设置十年的缓存</span><br></pre></td></tr></table></figure><blockquote><p>Nginx协商缓存配置：  </p></blockquote><ul><li>ETage指令： 指定签名 </li><li>etage: on|off; 开关，默认是on</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.(gif|jpeg|png|flv|swf|zip|rar)$</span><br><span class="line">&#123;</span><br><span class="line">    # 默认是开启的</span><br><span class="line">    etag     off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-前端代码和资源的压缩"><a href="#6-前端代码和资源的压缩" class="headerlink" title="6.前端代码和资源的压缩"></a>6.前端代码和资源的压缩</h5><ul><li>JavaScript压缩：去掉多余的空格和回车，替换长变量名，简写代码等</li><li>CSS压缩： 同样是去掉空白符、注释并且优化CSS语义规则</li><li>图片压缩： 借助压缩工具压缩（tinypng、jpegMini、imageoption等）</li><li>Gzip压缩</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Nginx配置:</span><br><span class="line">gizp on|off;    #是否开启gzip</span><br><span class="line">gzip_buffers 32 4K|16 8k #缓冲（在内存中有几块 每块多大）</span><br><span class="line">gzip_comp_level [1-9] #压缩级别（推荐使用6） 级别越高，压缩越小，越占用CPU资源</span><br><span class="line">gzip_disable #正则表达式匹配UA 什么样的uri不进行gzip </span><br><span class="line">gzip_min_length 200 #开始压缩的最小长度</span><br><span class="line">gzip_http_version 1.0|1.1 #开始压缩的http版本协议</span><br><span class="line">gzip_types text/plain application/xml #对那些类型进行压缩，如text、css、html等</span><br></pre></td></tr></table></figure><p>现在前端有很多工具可以对资源进行压缩，打包等。如grunt、webpack等已经很流行了。比较流行的前端框架也有相应的脚手架来帮助打包：vue-cli、angular-cli等</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、防盗链&quot;&gt;&lt;a href=&quot;#一、防盗链&quot; class=&quot;headerlink&quot; title=&quot;一、防盗链&quot;&gt;&lt;/a&gt;一、防盗链&lt;/h3&gt;&lt;h5 id=&quot;盗链&quot;&gt;&lt;a href=&quot;#盗链&quot; class=&quot;headerlink&quot; title=&quot;盗链&quot;&gt;&lt;/a&gt;盗链&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;在自己的页面上展示一些并不在自己服务器上的内容。&lt;br&gt;获取他人服务器上的资源地址，绕过别人的资源展示页面，直接在自己的页面上向用户输出&lt;br&gt;防盗链则是防止别人通过技术手段盗取本站的资源，让不是本站展示的资源链接失效&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="服务器" scheme="https://icocos.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="流量" scheme="https://icocos.github.io/tags/%E6%B5%81%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>PHP高并发下单解决方案</title>
    <link href="https://icocos.github.io/2019/01/06/PHP%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E5%8D%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://icocos.github.io/2019/01/06/PHP高并发下单解决方案/</id>
    <published>2019-01-06T10:47:41.000Z</published>
    <updated>2019-05-22T09:17:17.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>1、使用文件锁</li><li>2、使用消息队列</li><li>3、如果是分布式集群服务器，就需要一个或多个队列服务器</li><li>4、使用Memcache锁</li></ul><a id="more"></a><h3 id="1、使用文件锁"><a href="#1、使用文件锁" class="headerlink" title="1、使用文件锁"></a>1、使用文件锁</h3><pre><code>&lt;?php$fp = fopen(&quot;order.lock&quot;, &quot;r&quot;);if(flock($fp,LOCK_EX)){//..处理订单的代码flock($fp,LOCK_UN);}fclose($fp);?&gt;</code></pre><h3 id="2、使用消息队列"><a href="#2、使用消息队列" class="headerlink" title="2、使用消息队列"></a>2、使用消息队列</h3><p>可以基于例如MemcacheQ等这样的消息队列。</p><p>比如有100张票可供用户抢，那么就可以把这100张票放到缓存中，读写时不要加锁。 当并发量大的时候，可能有500人左右抢票成功，这样对于500后面的请求可以直接转到活动结束的静态页面。进去的500个人中有400个人是不可能获得商品的。所以可以根据进入队列的先后顺序只能前100个人购买成功。后面400个人就直接转到活动结束页面。当然进去500个人只是举个例子，至于多少可以自己调整。而活动结束页面一定要用静态页面，不要用数据库。这样就减轻了数据库的压力。</p><h3 id="3、如果是分布式集群服务器，就需要一个或多个队列服务器"><a href="#3、如果是分布式集群服务器，就需要一个或多个队列服务器" class="headerlink" title="3、如果是分布式集群服务器，就需要一个或多个队列服务器"></a>3、如果是分布式集群服务器，就需要一个或多个队列服务器</h3><p>小米和淘宝的抢购还是有稍许不同的，小米重在抢的那瞬间，抢到了名额，就是你的，你就可以下单结算。而淘宝则重在付款的时候的过滤，做了多层过滤，比如要卖10件商品，他会让大于10的用户抢到，在付款的时候再进行并发过滤，一层层的减少一瞬间的并发量。</p><h3 id="4、使用Memcache锁"><a href="#4、使用Memcache锁" class="headerlink" title="4、使用Memcache锁"></a>4、使用Memcache锁</h3><pre><code>product_key 为票的keyproduct_lock_key 为票锁key当product_key存在于memcached中时，所有用户都可以进入下单流程。</code></pre><p>当进入支付流程时，首先往memcached存放add(product_lock_key, “1″),如果返回成功，进入支付流程。如果不成，则说明已经有人进入支付流程，则线程等待N秒，递归执行add操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;1、使用文件锁&lt;/li&gt;
&lt;li&gt;2、使用消息队列&lt;/li&gt;
&lt;li&gt;3、如果是分布式集群服务器，就需要一个或多个队列服务器&lt;/li&gt;
&lt;li&gt;4、使用Memcache锁&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://icocos.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://icocos.github.io/tags/PHP/"/>
    
      <category term="实战" scheme="https://icocos.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
</feed>
