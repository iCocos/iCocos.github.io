<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[架构篇——MySQL高可用集群(PXC)详解]]></title>
    <url>%2F2019%2F06%2F11%2F%E6%9E%B6%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4-PXC-%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在介绍PXC之前，先来看一个相关的技术：MyCatMyCat简介MyCat是阿里开源的分布式数据库分库分表中间件 MyCat是一个开源的分布式数据库系统，是一个实现了MySQL协议的服务器，前端用户可以把它看作是一个数据库代理，用MySQL客户端工具和命令行访问，而其后端可以用MySQL原生协议与多个MySQL服务器通信，也可以用JDBC协议与大多数主流数据库服务器通信 MyCat功能: 数据库读写分离(写操作在主,读操作在从数据库) 读的负载均衡(一主多从) 垂直拆分(将表分开为多个数据库) 水平拆分(对表取模拆分) MyCAT是mysql中间件，前身是阿里大名鼎鼎的Cobar，Cobar在开源了一段时间后，不了了之。于是MyCAT扛起了这面大旗，在大数据时代，其重要性愈发彰显。这篇文章主要是MyCAT的入门部署。 更多相关可以参考这里：https://www.jianshu.com/p/c6e29d724fca 下面是MyCat结合PXC的架构图 PXC简介PXC是percona公司的percona xtraDB cluster，简称PXC。它是基于Galera协议的高可用集群方案。可以实现多个节点间的数据同步复制以及读写，并且可保障数据库的服务高可用及数据强一致性。 PXC就属于一套近乎完美的MySQL高可用集群架构方案； 主要特点是： 读写强一致性(牺牲性能)PXC特性 1）同步复制，事务要么在所有节点提交或不提交。 2）多主复制，可以在任意节点进行写操作。 3）在从服务器上并行应用事件，真正意义上的并行复制。 4）节点自动配置，数据一致性，不再是异步复制。 PXC最大的优势：强一致性、无同步延迟 优点总结： 服务高可用 可以达到时时同步(并发复制)，无延迟现象发生 完全兼容MySQL 对于集群中新节点的加入(自动部署)，维护起来很简单 数据的强一致性 多个可同时读写节点，可实现写扩展，不过最好事先进行分库分表，让各个节点分别写不同的表或者库，避免让galera解决数据冲突； 不足之处总结： 只支持Innodb存储引擎 存在多节点update更新问题，也就是写放大问题 在线DDL语句，锁表问题 sst针对新节点加入的传输代价过高的问题 所有表都要有主键； 不支持LOCK TABLE等显式锁操作； 锁冲突、死锁问题相对更多； 不支持XA； 事实上，采用PXC的主要目的是解决数据的一致性问题，高可用是顺带实现的。因为PXC存在写扩大以及短板效应，并发效率会有较大损失，类似semi sync replication机制。 网络说明 基于Galere协议的高可用方案：pxc + Galera是Codership提供的多主数据同步复制机制，可以实现多个节点间的数据同步复制以及读写，并且+ 可保障数据库的服务高可用及数据一致性。 + 基于Galera的高可用方案主要有MariaDB Galera Cluster和Percona XtraDB Cluster（简称PXC），目前PXC用的会比较多一些。 + mariadb的集群原理跟PXC一样,maridb-cluster其实就是PXC，两者原理是一样的。 PXC原理Percona XtraDB Cluster（简称PXC集群）提供了MySQL高可用的一种实现方法。 1）集群是有节点组成的，推荐配置至少3个节点，但是也可以运行在2个节点上。 2）每个节点都是普通的mysql/percona服务器，可以将现有的数据库服务器组成集群，反之，也可以将集群拆分成单独的服务器。 3）每个节点都包含完整的数据副本。 PXC集群主要由两部分组成：Percona Server with XtraDB和Write Set Replication patches（使用了Galera library，一个通用的用于事务型应用的同步、多主复制插件）。 PXC会使用大概是4个端口号 3306 数据库对外服务的端口号 4444 请求SST SST: 指数据一个镜象传输 xtrabackup , rsync ,mysqldump 4567 : 组成员之间进行沟通的一个端口号 4568 : 传输IST用的。相对于SST来说的一个增量。 注：安装PXC过程中， iptables 禁掉 ，selinux 也禁掉 PXC的操作流程： 首先客户端先发起一个事务，该事务先在本地执行，执行完成之后就要发起对事务的提交操作了。 在提交之前需要将产生的复制写集广播出去，然后获取到一个全局的事务ID号，一并传送到另一个节点上面。 通过合并数据之后，发现没有冲突数据，执行apply_cd和commit_cb动作，否则就需要取消此次事务的操作。 当前server节点通过验证之后，执行提交操作，并返回OK，如果验证没通过，则执行回滚。 在生产中至少要有3个节点的集群环境，如果其中一个节点没有验证通过，出现了数据冲突，那么此时采取的方式就是讲出现不一致的节点踢出集群环境，而且它自己会执行shutdown命令，自动关机。 实战部署环境： CentOS7.X 1、执行 命令 vi /etc/selinux/configSELINUX=disabled #修改该项为disabled 2、执行命令 setenforce 03、查看防火墙是否开启 systemctl status firewalld如果防火墙是开启状态，则开放端口 3306 、4444、4567、4568 firewall-cmd --add-port=3306/tcp --permanent #开放了3306端口 开放完4个端口后，重新加载防火墙规则 firewall-cmd --reload 4、安装Persona仓库yum install http://www.percona.com/downloads/percona-release/redhat/0.1-4/percona-release-0.1-4.noarch.rpm 5、安装PXC（保证服务器没有装MySQL）卸载MySQL 参考链接：https://blog.csdn.net/tjcyjd/article/details/52189182yum install Percona-XtraDB-Cluster-57 6、开启PXC服务service mysql start 7、查看安装数据库的临时密码并记住grep &apos;temporary password&apos; /var/log/mysqld.log 8、登录MySQL数据库mysql -u root -p 输入临时密码, 登录成功后修改密码 ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;你的密码&apos;; 9、停止MySQL服务service mysql stop （某些版本使用mysqld） 10、配置节点vi /etc/percona-xtradb-cluster.conf.d/wsrep.cnf 修改配置文件 # Cluster connection URL contains IPs of nodes #If no IP is found, this implies that a new cluster needs to be created, #in order to do that you need to bootstrap this node #集群中节点的IP地址（本机填最后） wsrep_cluster_address=gcomm://ip地址,IP地址,IP地址（用,号隔开） # In order for Galera to work correctly binlog format should be ROW binlog_format=ROW # MyISAM storage engine has only experimental support default_storage_engine=InnoDB # Slave thread to use wsrep_slave_threads= 8 wsrep_log_conflicts # This changes how InnoDB autoincrement locks are managed and is a requirement for Galera innodb_autoinc_lock_mode=2 # Node IP address #当前节点IP wsrep_node_address=IP地址 # Cluster name #集群名称 wsrep_cluster_name=pxc-cluster #If wsrep_node_name is not specified, then system hostname will be used #当前节点名称 wsrep_node_name=pxc-cluster-node-1 #pxc_strict_mode allowed values: DISABLED,PERMISSIVE,ENFORCING,MASTER #不使用实验功能 pxc_strict_mode=ENFORCING # SST method #状态快照传输（sst）方法，官方建议 wsrep_sst_method=xtrabackup-v2 #Authentication for SST method #用户凭证（mysql的用户名和密码） wsrep_sst_auth=&quot;用户名:密码&quot; 剩下的节点修改当前节点名、当前节点IP、集群中的节点IP，其他相同 注：1—10步骤 每个节点都要配置一次 11、初始化集群节点其中一个节点使用 systemctl start mysql@bootstrap.service 启动 登录mysqlmysql -u root -p 开启 wsrep_causal_reads set wsrep_causal_reads =1; 12、创建配置文件中对应的用户 所有节点的IP都要创建 创建用户： CREATE USER &apos;用户名&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;密码&apos;; 刷新权限： GRANT all privileges ON *.* TO &apos;用户名&apos;@&apos;localhost&apos; ; FLUSH PRIVILEGES; 创建用户： CREATE USER &apos;用户名&apos;@&apos;当前需要访问数据库的IP地址&apos; IDENTIFIED BY &apos;密码&apos;; 刷新权限： GRANT all privileges ON *.* TO &apos;用户名&apos;@&apos;当前节点IP地址&apos; ; FLUSH PRIVILEGES; 13、其他节点使用 service mysql start 启动 ，登录mysql，配置wsrep_causal_reds，set wsrep_causal_reads =1;14、其他节点启动成功后在引导节点（使用 systemctl start mysql@bootstrap.service 命令启动的节点）验证集群： show status like &apos;wsrep%&apos;; 15、节点数据同步验证在当前节点创建一个数据库 CREATE DATABASE percona; 启动其他节点的数据库服务，进去后会发现新建的数据库，同理 其他节点创建的数据 当前节点也能看到 注意：服务的启动和停止要对应 service mysql stop ------&gt; 启动时用service mysql start 或者 systemctl stop mysql@bootstrap.service -----&gt; 启用是用 systemctl start mysql@bootstrap.service 更多相关实战配置可以参考这里：https://www.jianshu.com/p/0b7c050dfab6 推荐 带你玩转Mysql高可用方案–PXC https://blog.csdn.net/zisefeizhu/article/details/81873466 Docker搭建PXC集群 https://blog.csdn.net/weixin_41141219/article/details/82767832 MySQL高可用方案－PXC环境部署记录: 详细教程 http://www.cnblogs.com/kevingrace/p/5685371.html]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>MySQL</tag>
        <tag>PXC集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[架构篇——MySQL主从复制(Master-Slave)详解]]></title>
    <url>%2F2019%2F06%2F09%2F%E6%9E%B6%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-Master-Slave-%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[主从Mysql主从又叫Replication、AB复制(不同于PXC)。简单讲就是A与B两台机器做主从后，在A上写数据，另外一台B也会跟着写数据，实现数据实时同步 mysql主从是基于binlog，主上需开启binlog才能进行主从 主从过程大概有3个步骤 主将更改操作记录到binlog里 从将主的binlog事件（sql语句） 同步本机上并记录在relaylog里 从根据relaylog里面的sql语句按顺序执行 主从作用实时灾备，用于故障切换 读写分离，提供查询服务 备份，避免影响业务 主从形式 一主一从 主主复制 一主多从—扩展系统读取的性能，因为读是在从库读取的 多主一从—5.7版本开始支持 联级复制 MySQL数据库自身提供的主从复制功能可以方便的实现数据的多处自动备份，实现数据库的拓展。多个数据备份不仅可以加强数据的安全性，通过实现读写分离还能进一步提升数据库的负载性能。 原理： MySQL之间数据复制的基础是二进制日志文件（binary log file）。一台MySQL数据库一旦启用二进制日志后，其作为master，它的数据库中所有操作都会以“事件”的方式记录在二进制日志中，其他数据库作为slave通过一个I/O线程与主服务器保持通信，并监控master的二进制日志文件的变化，如果发现master二进制日志文件发生变化，则会把变化复制到自己的中继日志中，然后slave的一个SQL线程会把相关的“事件”执行到自己的数据库中，以此实现从数据库和主数据库的一致性，也就实现了主从复制。 主库将所有的写操作记录在binlog日志中，并生成log dump线程，将binlog日志传给从库的I/O线程 从库生成两个线程，一个是I/O线程，另一个是SQL线程 I/O线程去请求主库的binlog日志，并将binlog日志中的文件写入relay log（中继日志）中 SQL线程会读取relay loy中的内容，并解析成具体的操作，来实现主从的操作一致，达到最终数据一致的目的 配置实现MySQL主从复制需要进行的配置： 主服务器： 开启二进制日志 配置唯一的server-id 获得master二进制日志文件名及位置 创建一个用于slave和master通信的用户账号 从服务器： 配置唯一的server-id 使用master分配的用户账号读取master二进制日志 启用slave服务 具体实现过程如下：主从复制配置步骤： 确保从数据库与主数据库里的数据一致 在主数据库里创建一个同步账户授权给从数据库使用 配合主数据库（修改配置文件） 配置从数据库（修改配置文件） 一、准备工作： 主从数据库版本最好一致 主从数据库内数据保持一致 搭建两台MYSQL服务器，一台作为主服务器，一台作为从服务器，主服务器进行写操作，从服务器进行读操作 + 主数据库：192.168.0.1 /Linux-MySQL + 从数据库：192.168.0.2 /Linux-MySQL 二、主数据库master修改：1.修改mysql配置 找到主数据库的配置文件my.cnf(或者my.ini)，我的在/etc/mysql/my.cnf,在[mysqld]部分插入如下两行： [mysqld] log-bin=mysql-bin #开启二进制日志 server-id=1 #设置server-id 2.重启mysql，创建用于同步的用户账号 打开mysql会话shell mysql -hlocalhost -uname -ppassword 创建用户：用户：rel1密码：slavepass 3.授权 主服务器授权从服务器特定账号登录 mysql&gt; CREATE USER &apos;repl&apos;@&apos;192.168.0.2&apos; IDENTIFIED BY &apos;slavepass&apos;;#创建用户 mysql&gt; GRANT REPLICATION SLAVE ON *.* TO &apos;repl&apos;@&apos;192.168.0.2&apos;;#分配权限 mysql&gt;flush privileges; #刷新权限 4.查看master状态，记录二进制文件名(mysql-bin.000003)和位置(73)： mysql &gt; SHOW MASTER STATUS; +------------------+----------+--------------+------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | +------------------+----------+--------------+------------------+ | mysql-bin.000003 | 73 | test | manual,mysql | +------------------+----------+--------------+------------------+ 三、从服务器slave修改：1.修改mysql配置 同样找到my.cnf配置文件，添加server-id [mysqld] server-id=2 #设置server-id，必须唯一 2.重启mysql，打开mysql会话，执行同步SQL语句(需要主服务器主机名，登陆凭据，二进制文件的名称和位置)：复制代码 mysql&gt; CHANGE MASTER TO -&gt; MASTER_HOST=&apos;192.168.0.1&apos;, -&gt; MASTER_USER=&apos;rep1&apos;, -&gt; MASTER_PASSWORD=&apos;slavepass&apos;, -&gt; MASTER_LOG_FILE=&apos;mysql-bin.000003&apos;, -&gt; MASTER_LOG_POS=73; 3.启动slave同步进程： mysql&gt;start slave; 4.查看slave状态： mysql&gt; show slave status\G; *************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: 192.168.0.1 Master_User: rep1 Master_Port: 3306 Connect_Retry: 60 Master_Log_File: mysql-bin.000013 Read_Master_Log_Pos: 11662 Relay_Log_File: mysqld-relay-bin.000022 Relay_Log_Pos: 11765 Relay_Master_Log_File: mysql-bin.000013 Slave_IO_Running: Yes Slave_SQL_Running: Yes Replicate_Do_DB: Replicate_Ignore_DB: ... 当Slave_IO_Running和Slave_SQL_Running都为YES的时候就表示主从同步设置成功了。 接下来就可以进行一些验证了，比如在主master数据库的test数据库的一张表中插入一条数据，在slave的test库的相同数据表中查看是否有新增的数据即可验证主从复制功能是否有效，还可以关闭slave（mysql&gt;stop slave;）,然后再修改master，看slave是否也相应修改（停止slave后，master的修改不会同步到slave），就可以完成主从复制功能的验证了。 还可以用到的其他相关参数： master开启二进制日志后默认记录所有库所有表的操作，可以通过配置来指定只记录指定的数据库甚至指定的表的操作，具体在mysql配置文件的[mysqld]可添加修改如下选项： # 不同步哪些数据库 binlog-ignore-db = mysql binlog-ignore-db = test binlog-ignore-db = information_schema # 只同步哪些数据库，除此之外，其他不同步 binlog-do-db = game 如之前查看master状态时就可以看到只记录了test库，忽略了manual和mysql库。 操作流程汇总关闭防火墙以SELINUX[root@icocos ~]# systemctl stop firewalld [root@icocos ~]# systemctl disable firewalld [root@icocos ~]# sed -ri &apos;s/(SELINUX=).*/\1disabled/g&apos; /etc/selinux/config [root@icocos ~]# setenforce 0 安装mysql安装依赖包 [root@icocos ~]# yum -y install ncurses-devel openssl-devel openssl cmake mariadb-devel 创建用户和组[root@icocos ~]# groupadd -r -g 306 mysql [root@icocos ~]# useradd -M -s /sbin/nologin -g 306 -u 306 mysql 下载二进制格式的mysql软件包[root@icocos ~]# cd /usr/src/ [root@icocos src]#wget https://downloads.mysql.com/archives/get/file/mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz 解压软件至/usr/local/[root@icocos src]# ls debug kernels mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz [root@icocos src]# tar xf mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz -C /usr/local/ [root@icocos src]# ls /usr/local/ bin etc games include lib lib64 libexec mysql-5.7.22-linux-glibc2.12-x86_64 sbin share src [root@icocos src]# cd /usr/local/ [root@icocos local]# ln -sv mysql-5.7.22-linux-glibc2.12-x86_64/ mysql &quot;mysql&quot; -&gt; &quot;mysql-5.7.22-linux-glibc2.12-x86_64/&quot; [root@icocos local]# ll 总用量 0 drwxr-xr-x. 2 root root 6 11月 5 2016 bin drwxr-xr-x. 2 root root 6 11月 5 2016 etc drwxr-xr-x. 2 root root 6 11月 5 2016 games drwxr-xr-x. 2 root root 6 11月 5 2016 include drwxr-xr-x. 2 root root 6 11月 5 2016 lib drwxr-xr-x. 2 root root 6 11月 5 2016 lib64 drwxr-xr-x. 2 root root 6 11月 5 2016 libexec lrwxrwxrwx. 1 root root 36 9月 7 22:20 mysql -&gt; mysql-5.7.22-linux-glibc2.12-x86_64/ drwxr-xr-x. 9 root root 129 9月 7 22:19 mysql-5.7.22-linux-glibc2.12-x86_64 drwxr-xr-x. 2 root root 6 11月 5 2016 sbin drwxr-xr-x. 5 root root 49 9月 3 23:02 share drwxr-xr-x. 2 root root 6 11月 5 2016 src 修改目录/usr/locaal/mysql的属主属组[root@icocos local]# chown -R mysql.mysql /usr/local/mysql [root@icocos local]# ll /usr/local/mysql -d lrwxrwxrwx. 1 mysql mysql 36 9月 7 22:20 /usr/local/mysql -&gt; mysql-5.7.22-linux-glibc2.12-x86_64/ 添加环境变量[root@icocos local]# ls /usr/local/mysql bin COPYING docs include lib man README share support-files [root@icocos local]# cd [root@icocos ~]# echo &apos;export PATH=/usr/local/mysql/bin:$PATH&apos; &gt; /etc/profile.d/mysql.sh [root@icocos ~]# . /etc/profile.d/mysql.sh [root@icocos ~]# echo $PATH /usr/local/mysql/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin 建立数据存放目录[root@icocos ~]# cd /usr/local/mysql [root@icocos mysql]# mkdir /opt/data [root@icocos mysql]# chown -R mysql.mysql /opt/data/ [root@icocos mysql]# ll /opt/ 总用量 0 drwxr-xr-x. 2 mysql mysql 6 9月 7 22:25 data 初始化数据库[root@icocos mysql]# /usr/local/mysql/bin/mysqld --initialize --user=mysql --datadir=/opt/data/ //这个命令的最后会生成一个临时密码，此处密码是1EbNA-k*BtKo 配置mysql[root@icocos ~]# ln -sv /usr/local/mysql/include/ /usr/local/include/mysql &quot;/usr/local/include/mysql&quot; -&gt; &quot;/usr/local/mysql/include/&quot; [root@icocos ~]# echo &apos;/usr/local/mysql/lib&apos; &gt; /etc/ld.so.conf.d/mysql.conf [root@icocos ~]# ldconfig -v 生成配置文件[root@icocos ~]# cat &gt; /etc/my.cnf &lt;&lt;EOF &gt; [mysqld] &gt; basedir = /usr/local/mysql &gt; datadir = /opt/data &gt; socket = /tmp/mysql.sock &gt; port = 3306 &gt; pid-file = /opt/data/mysql.pid &gt; user = mysql &gt; skip-name-resolve &gt; EOF 配置服务启动脚本[root@icocos ~]# cp -a /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld [root@icocos ~]# sed -ri &apos;s#^(basedir=).*#\1/usr/local/mysql#g&apos; /etc/init.d/mysqld [root@icocos ~]# sed -ri &apos;s#^(datadir=).*#\1/opt/data#g&apos; /etc/init.d/mysqld 启动mysql[root@icocos ~]# service mysqld start Starting MySQL.Logging to &apos;/opt/data/icocos.err&apos;. .. SUCCESS! [root@icocos ~]# ps -ef|grep mysql root 4897 1 0 22:38 pts/2 00:00:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/opt/data --pid-file=/opt/data/mysql.pid mysql 5075 4897 6 22:38 pts/2 00:00:01 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/opt/data --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=icocos.err --pid-file=/opt/data/mysql.pid --socket=/tmp/mysql.sock --port=3306 root 5109 4668 0 22:38 pts/2 00:00:00 grep --color=auto mysql [root@icocos ~]# ss -antl State Recv-Q Send-Q Local Address:Port Peer Address:Port LISTEN 0 128 *:22 *:* LISTEN 0 100 127.0.0.1:25 *:* LISTEN 0 128 :::22 :::* LISTEN 0 100 ::1:25 :::* LISTEN 0 80 :::3306 :::* 修改密码使用临时密码修改 [root@icocos ~]# mysql -uroot -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \g. Your MySQL connection id is 2 Server version: 5.7.22 Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement. mysql&gt; set password = password(&apos;123456&apos;); Query OK, 0 rows affected, 1 warning (0.00 sec) mysql&gt; quit Bye mysql主从配置确保从数据库与主数据库的数据一样先在主数据库创建所需要同步的库和表 [root@icocos ~]# mysql -uroot -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \g. Your MySQL connection id is 4 Server version: 5.7.22 MySQL Community Server (GPL) Copyright (c) 2000, 2018, Oracle and/or its affiliates. Al Oracle is a registered trademark of Oracle Corporation and affiliates. Other names may be trademarks of their respect owners. Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the curr mysql&gt; create database yan; Query OK, 1 row affected (0.00 sec) mysql&gt; create database lisi; Query OK, 1 row affected (0.00 sec) mysql&gt; create database wangwu; Query OK, 1 row affected (0.00 sec) mysql&gt; use yan; Database changed mysql&gt; create table tom (id int not null,name varchar(100)not null ,age tinyint); Query OK, 0 rows affected (11.83 sec) mysql&gt; insert tom (id,name,age) values(1,&apos;zhangshan&apos;,20),(2,&apos;wangwu&apos;,7),(3,&apos;lisi&apos;,23); Query OK, 3 rows affected (0.07 sec) Records: 3 Duplicates: 0 Warnings: 0 mysql&gt; select * from tom; +----+-----------+------+ | id | name | age | +----+-----------+------+ | 1 | zhangshan | 20 | | 2 | wangwu | 7 | | 3 | lisi | 23 | +----+-----------+------+ 3 rows in set (0.00 sec) 备份主库备份主库时需要另开一个终端，给数据库上读锁，避免在备份期间有其他人在写入导致数据同步的不一致 [root@icocos ~]# mysql -uroot -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \g. Your MySQL connection id is 5 Server version: 5.7.22 MySQL Community Server (GPL) Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement. mysql&gt; flush tables with read lock; Query OK, 0 rows affected (0.76 sec) 此锁表的终端必须在备份完成以后才能退出（退出锁表失效） 备份主库并将备份文件传送到从库[root@icocos ~]# mysqldump -uroot -p123456 --all-databases &gt; /opt/all-20180907.sql mysqldump: [Warning] Using a password on the command line interface can be insecure. [root@icocos ~]# ls /opt/ all-20180907.sql data [root@icocos ~]# scp /opt/all-20180907.sql root@192.168.0.2:/opt/ The authenticity of host &apos;192.168.0.2 (192.168.0.2)&apos; can&apos;t be established. ECDSA key fingerprint is SHA256:7mLj77SFk7sPkhjpMPfdK3nZ98hOuyP4OKzjXeijSJ0. ECDSA key fingerprint is MD5:a0:1b:eb:7f:f0:b6:7b:73:97:91:4c:f3:b1:89:d8:ea. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added &apos;192.168.0.2&apos; (ECDSA) to the list of known hosts. root@192.168.0.2&apos;s password: all-20180907.sql 100% 784KB 783.3KB/s 00:01 解除主库的锁表状态，直接退出交互式界面即可mysql&gt; quit Bye 在从库上恢复主库的备份并查看是否与主库的数据保持一致[root@icocos ~]# mysql -uroot -p123456 &lt; /opt/all-20180907.sql mysql: [Warning] Using a password on the command line interface can be insecure. [root@icocos ~]# mysql -uroot -p123456 mysql: [Warning] Using a password on the command line interface can be insecure. Welcome to the MySQL monitor. Commands end with ; or \g. Your MySQL connection id is 4 Server version: 5.7.22 MySQL Community Server (GPL) Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement. mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | lisi | | mysql | | performance_schema | | sys | | wangwu | | yan | +--------------------+ 7 rows in set (0.18 sec) mysql&gt; use yan; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed mysql&gt; select * from tom; +----+-----------+------+ | id | name | age | +----+-----------+------+ | 1 | zhangshan | 20 | | 2 | wangwu | 7 | | 3 | lisi | 23 | +----+-----------+------+ 3 rows in set (0.06 sec) 在主数据库创建一个同步账户授权给从数据使用[root@icocos ~]# mysql -uroot -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \g. Your MySQL connection id is 7 Server version: 5.7.22 MySQL Community Server (GPL) Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement. mysql&gt; create user &apos;repl&apos;@&apos;192.168.0.2&apos; identified by &apos;123456&apos;; Query OK, 0 rows affected (5.50 sec) mysql&gt; grant replication slave on *.* to &apos;repl&apos;@&apos;192.168.0.2&apos;; Query OK, 0 rows affected (0.04 sec) mysql&gt; flush privileges; Query OK, 0 rows affected (0.09 sec) 配置主数据库编辑配置文件[root@icocos ~]# vim /etc/my.cnf [root@icocos ~]# cat /etc/my.cnf [mysqld] basedir = /usr/local/mysql datadir = /opt/data socket = /tmp/mysql.sock port = 3306 pid-file = /opt/data/mysql.pid user = mysql skip-name-resolve //添加以下内容 log-bin=mysql-bin //启用binlog日志 server-id=1 //主数据库服务器唯一标识符 主的必须必从大 log-error=/opt/data/mysql.log 重启mysql服务[root@icocos ~]# service mysqld restart Shutting down MySQL..... SUCCESS! Starting MySQL.Logging to &apos;/opt/data/mysql.log&apos;. ............................... SUCCESS! [root@icocos ~]# ss -antl State Recv-Q Send-Q Local Address:Port Peer Address:Port LISTEN 0 128 *:22 *:* LISTEN 0 100 127.0.0.1:25 *:* LISTEN 0 128 :::22 :::* LISTEN 0 100 ::1:25 :::* LISTEN 0 80 :::3306 :::* 查看主库的状态mysql&gt; show master status; +------------------+----------+--------------+------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+----------+--------------+------------------+-------------------+ | mysql-bin.000001 | 154 | | | | +------------------+----------+--------------+------------------+-------------------+ 1 row in set (0.00 sec) 配置从数据库编辑配置文件 [root@icocos ~]# cat /etc/my.cnf [mysqld] basedir = /usr/local/mysql datadir = /opt/data socket = /tmp/mysql.sock port = 3306 pid-file = /opt/data/mysql.pid user = mysql skip-name-resolve //添加以下内容： server-id=2 //设置从库的唯一标识符 从的必须比主小 relay-log=mysql-relay-bin //启用中继日志relay log error-log=/opt/data/mysql.log 重启从库的mysql服务[root@icocos ~]# service mysqld restart Shutting down MySQL.. SUCCESS! Starting MySQL.. SUCCESS! [root@icocos ~]# ss -antl State Recv-Q Send-Q Local Address:Port Peer Address:Port LISTEN 0 128 *:22 *:* LISTEN 0 100 127.0.0.1:25 *:* LISTEN 0 128 :::22 :::* LISTEN 0 100 ::1:25 :::* LISTEN 0 80 :::3306 :::* 配置并启动主从复制mysql&gt; change master to -&gt; master_host=&apos;192.168.0.1&apos;, -&gt; master_user=&apos;repl&apos;, -&gt; master_password=&apos;123456&apos;, -&gt; master_log_file=&apos;mysql-bin.000001&apos;, -&gt; master_log_pos=154; Query OK, 0 rows affected, 2 warnings (0.28 sec) 查看从服务器状态mysql&gt; show slave status\G; *************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: 192.168.0.1 Master_User: repl Master_Port: 3306 Connect_Retry: 60 Master_Log_File: mysql-bin.000001 Read_Master_Log_Pos: 154 Relay_Log_File: mysql-relay-bin.000003 Relay_Log_Pos: 320 Relay_Master_Log_File: mysql-bin.000001 Slave_IO_Running: Yes //此处必须是yes Slave_SQL_Running: Yes //此处必须是yes Replicate_Do_DB: Replicate_Ignore_DB: Replicate_Do_Table: Replicate_Ignore_Table: Replicate_Wild_Do_Table: Replicate_Wild_Ignore_Table: Last_Errno: 0 Last_Error: Skip_Counter: 0 Exec_Master_Log_Pos: 154 Relay_Log_Space: 527 Until_Condition: None Until_Log_File: Until_Log_Pos: 0 Master_SSL_Allowed: No Master_SSL_CA_File: Master_SSL_CA_Path: Master_SSL_Cert: Master_SSL_Cipher: Master_SSL_Key: Seconds_Behind_Master: 0 Master_SSL_Verify_Server_Cert: No Last_IO_Errno: 0 Last_IO_Error: Last_SQL_Errno: 0 Last_SQL_Error: Replicate_Ignore_Server_Ids: Master_Server_Id: 1 Master_UUID: 5abf1791-b2af-11e8-b6ad-000c2980fbb4 Master_Info_File: /opt/data/master.info SQL_Delay: 0 SQL_Remaining_Delay: NULL Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates Master_Retry_Count: 86400 Master_Bind: Last_IO_Error_Timestamp: Last_SQL_Error_Timestamp: Master_SSL_Crl: Master_SSL_Crlpath: Retrieved_Gtid_Set: Executed_Gtid_Set: Auto_Position: 0 Replicate_Rewrite_DB: Channel_Name: Master_TLS_Version: 1 row in set (0.00 sec) ERROR: No query specified 测试验证在主服务器的yan库的tom表插入数据:mysql&gt; use yan; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed mysql&gt; select * from tom; +----+-----------+------+ | id | name | age | +----+-----------+------+ | 1 | zhangshan | 20 | | 2 | wangwu | 7 | | 3 | lisi | 23 | +----+-----------+------+ 3 rows in set (0.09 sec) mysql&gt; insert tom(id,name,age) value (4,&quot;yyl&quot;,18); Query OK, 1 row affected (0.14 sec) mysql&gt; select * from tom; +----+-----------+------+ | id | name | age | +----+-----------+------+ | 1 | zhangshan | 20 | | 2 | wangwu | 7 | | 3 | lisi | 23 | | 4 | yyl | 18 | +----+-----------+------+ 4 rows in set (0.00 sec) 在从数据库查看是否数据同步mysql&gt; use yan; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed mysql&gt; select * from tom; +----+-----------+------+ | id | name | age | +----+-----------+------+ | 1 | zhangshan | 20 | | 2 | wangwu | 7 | | 3 | lisi | 23 | | 4 | yyl | 18 | +----+-----------+------+ 4 rows in set (0.00 sec)]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>MySQL</tag>
        <tag>主从复制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL锁机制和PHP锁机制]]></title>
    <url>%2F2019%2F06%2F06%2FMySQL%E9%94%81%E6%9C%BA%E5%88%B6%E5%92%8CPHP%E9%94%81%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[PHP中的文件锁 （锁的是文件，不是表）文件锁的文件与表有什么关系？：一点关系也没有，与令牌相似，谁拿到谁操作。所以表根本没锁。测试时，有个文件就行，叫什么名无所谓 bool flock ( int handle, int operation [, int &amp;wouldblock] );flock() 操作的 handle 必须是一个已经打开的文件指针。operation 可以是以下值之一： 要取得共享锁定（读取程序），将 operation 设为 LOCK_SH（PHP 4.0.1 以前的版本设置为 1） 要取得独占锁定（写入程序），将 operation 设为 LOCK_EX（PHP 4.0.1 以前的版本中设置为 2） 要释放锁定（无论共享或独占），将 operation 设为 LOCK_UN（PHP 4.0.1 以前的版本中设置为 3） 如果你不希望 flock() 在锁定时堵塞，则给 operation 加上 LOCK_NB（PHP 4.0.1 以前的版本中设置为4） 建两个文件 (1) a.php$file = &quot;temp.txt&quot;; $fp = fopen($file , &apos;w&apos;); if(flock($fp , LOCK_EX)){ fwrite($fp , &quot;abc\n&quot;); sleep(10); fwrite($fp , &quot;123\n&quot;); flock($fp , LOCK_UN); } fclose($fp); (2) b.php$file = &quot;temp.txt&quot;; $fp = fopen($file , &apos;r&apos;); echo fread($fp , 100); fclose($fp); 运行 a.php 后，马上运行 b.php ，可以看到输出： abc 等 a.php 运行完后运行 b.php ，可以看到输出： abc 123 显然，当 a.php 写文件时数据太大，导致时间比较长时，这时 b.php 读取数据不完整 修改 b.php 为： $file = &quot;temp.txt&quot;; $fp = fopen($file , &apos;r&apos;); if(flock($fp , LOCK_EX)){ echo fread($fp , 100); flock($fp , LOCK_UN); } else{ echo &quot;Lock file failed...\n&quot;; } fclose($fp); 运行 a.php 后，马上运行 b.php ，可以发现 b.php 会等到 a.php 运行完成后(即 10 秒后)才显示： abc 123 读取数据完整，但时间过长，他要等待写锁释放。 修改 b.php 为： $file = &quot;temp.txt&quot;; $fp = fopen($file , &apos;r&apos;); if(flock($fp , LOCK_SH | LOCK_NB)){ echo fread($fp , 100); flock($fp , LOCK_UN); } else{ echo &quot;Lock file failed...\n&quot;; } fclose($fp); 运行 a.php 后，马上运行 b.php ，可以看到输出： Lock file failed… 证明可以返回锁文件失败状态，而不是向上面一样要等很久。 结论： 建议作文件缓存时，选好相关的锁，不然可能导致读取数据不完整，或重复写入数据。file_get_contents 好像选择不了锁，不知道他默认用的什么锁，反正和不锁得到的输出一样，是不完整的数据。 我是要做文件缓存，所以只需要知道是否有写锁存在即可，有的话就查数据库就可以了。测试环境：Linux(Ubuntu 6) , PHP 5.1.2 , Apache 2 再转：文件锁有两种：共享锁和排他锁，也就是读锁(LOCK_SH)和写锁(LOCK_EX)文件的锁一般这么使用： $fp = fopen(&quot;filename&quot;, &quot;a&quot;); flock($fp, LOCK_SH) or die(&quot;lock error&quot;) $str = fread($fp, 1024); flock($fp, LOCK_UN); fclose($fp); 注意fwrite之后，文件立即就被更新了，而不是等fwrite然后fclose之后文件才会更新，这个可以通过在fwrite之后fclose之前读取这个文件进行检查 但是什么时候使用lock_ex什么时候使用lock_sh呢？ 读的时候：如果不想出现dirty数据，那么最好使用lock_sh共享锁。可以考虑以下三种情况： 如果读的时候没有加共享锁，那么其他程序要写的话（不管这个写是加锁还是不加锁）都会立即写成功。如果正好读了一半，然后被其他程序给写了，那么读的后一半就有可能跟前一半对不上（前一半是修改前的，后一半是修改后的） 如果读的时候加上了共享锁（因为只是读，没有必要使用排他锁），这个时候，其他程序开始写，这个写程序没有使用锁，那么写程序会直接修改这个文件，也会导致前面一样的问题 最理想的情况是，读的时候加锁(lock_sh),写的时候也进行加锁(lock_ex),这样写程序会等着读程序完成之后才进行操作，而不会出现贸然操作的情况 写的时候：如果多个写程序不加锁同时对文件进行操作，那么最后的数据有可能一部分是a程序写的，一部分是b程序写的如果写的时候加锁了，这个时候有其他的程序来读，那么他会读到什么东西呢？ 如果读程序没有申请共享锁，那么他会读到dirty的数据。比如写程序要写a,b,c三部分，写完a,这时候读读到的是a，继续写b，这时候读读到的是ab，然后写c，这时候读到的是abc. 如果读程序在之前申请了共享锁，那么读程序会等写程序将abc写完并释放锁之后才进行读。 总结：项目中应该只使用PHP中的文件锁，尽量避免锁表，因为如果表被锁定了，那么整个网站中所有和这个表相关的功能都被拖慢了（例如：前台很多用户一直下订单，商品表mysql锁表，其他与商品表相关的操作一直处于阻塞状态【读不出来商品表】，因为一个功能把整个网站速度拖慢）。 比如在一个O2O外卖项目中，中午12-2点，晚上6点都是订单高并发时，这种情况下，MySQL锁显然是不考虑的，用户体验太差。其实根据实际的需求，外卖可以不用设计库存量的，当然除了秒杀活动模块还是需要php文件锁的。 应用场景： 高并发下单时，减库存量时要加锁 高并发抢单、抢票时要使用 MySQL锁示例代码： &lt;?php /** 模拟秒杀活动-- 商品100件 CREATE TABLE a ( id int comment &apos;模拟100件活动商品的数量&apos; ); INSERT INTO a VALUES(100); 模仿：以10的并发量访问这个脚本！ 使用apache自带的ab.exe软件 */ error_reporting(0); mysql_connect(&apos;localhost&apos;,&apos;root&apos;,&apos;admin123&apos;); mysql_select_db(&apos;test&apos;); # mysql 锁 mysql_query(&apos;LOCK TABLE a WRITE&apos;);// 只有一个客户端可以锁定表，其他客户端阻塞在这 $rs = mysql_query(&apos;SELECT id FROM a&apos;); $id = mysql_result($rs, 0, 0); if($id &gt; 0) { --$id; mysql_query(&apos;UPDATE a SET id=&apos;.$id); } # mysql 解锁 mysql_query(&apos;UNLOCK TABLES&apos;); PHP文件锁示例代码： &lt;?php /** 模拟秒杀活动-- 商品100件 CREATE TABLE a ( id int comment &apos;模拟100件活动商品的数量&apos; ); INSERT INTO a VALUES(100); 模仿：以10的并发量访问这个脚本！ 使用apache自带的ab.exe软件 */ error_reporting(0); mysql_connect(&apos;localhost&apos;,&apos;root&apos;,&apos;admin123&apos;); mysql_select_db(&apos;test&apos;); # php中的文件锁 $fp = fopen(&apos;./a.lock&apos;, &apos;r&apos;); // php的文件锁和表没关系，随便一个文件即可 flock($fp, LOCK_EX);// 排他锁 $rs = mysql_query(&apos;SELECT id FROM a&apos;); $id = mysql_result($rs, 0, 0); if($id &gt; 0) { --$id; mysql_query(&apos;UPDATE a SET id=&apos;.$id); } # php的文件锁，释放锁 flock($fp, LOCK_UN); fclose($fp); MYSQL中的锁：语法 ：LOCK TABLE 表名1 READ|WRITE, 表名2 READ|WRITE ……………… 【锁表】UNLOCK TABLES 【释放表】 Read:读锁|共享锁 ： 所有的客户端只能读这个表不能写这个表 Write:写锁|排它锁： 所有当前锁定客户端可以操作这个表，其他客户端只能阻塞 注意：在锁表的过程中只能操作被锁定的表，如果要操作其他表，必须把所有要操作的表都锁定起来！ 1.表级锁定（table-level）表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并大度大打折扣。使用表级锁定的主要是MyISAM等一些非事务性存储引擎。 2.行级锁定（row-level）行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。使用行级锁定的主要是InnoDB存储引擎。 3.页级锁定（page-level）页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。 总结： 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低； 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高； 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。 适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。 二、表级锁定在mysql中，MyISAM引擎使用的锁定机制完全是mysql的表级锁定，下面将以MYISAM引擎作为示例 1.MySQL表级锁的模式 MySQL的表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。 兼容性： 对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求； 对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作； MyISAM表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。 2.加锁 MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。 3.MyISAM锁的优化 对于MyISAM存储引擎，虽然使用表级锁定在锁定实现的过程中比实现行级锁定或者页级锁所带来的附加成本都要小，锁定本身所消耗的资源也是最少。但是由于锁定的颗粒度比较到，所以造成锁定资源的争用情况也会比其他的锁定级别都要多，从而在较大程度上会降低并发处理能力。所以，在优化MyISAM存储引擎锁定问题的时候，最关键的就是如何让其提高并发度。由于锁定级别是不可能改变的了，所以我们首先需要尽可能让锁定的时间变短，然后就是让可能并发进行的操作尽可能的并发。 （1）查询表锁争用情况 1234567mysql&gt; show status like &apos;table%&apos;;+----------------------------+---------+| Variable_name | Value |+----------------------------+---------+| Table_locks_immediate | 100 || Table_locks_waited | 11 |+----------------------------+---------+ 这里有两个状态变量记录MySQL内部表级锁定的情况，两个变量说明如下： Table_locks_immediate：产生表级锁定的次数; Table_locks_waited：出现表级锁定争用而发生等待的次数； 两个状态值都是从系统启动后开始记录，出现一次对应的事件则数量加1。如果这里的Table_locks_waited状态值比较高，那么说明系统中表级锁定争用现象比较严重，就需要进一步分析为什么会有较多的锁定资源争用了 （2）缩短锁定时间 如何让锁定时间尽可能的短呢？唯一的办法就是让我们的Query执行时间尽可能的短。 + a)尽两减少大的复杂Query，将复杂Query分拆成几个小的Query分布进行； + b)尽可能的建立足够高效的索引，让数据检索更迅速； + c)尽量让MyISAM存储引擎的表只存放必要的信息，控制字段类型； + d)利用合适的机会优化MyISAM表数据文件 (3)分离并行的操作]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP-高并发和大流量的解决方案]]></title>
    <url>%2F2019%2F06%2F03%2FPHP-%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%A7%E6%B5%81%E9%87%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[一 高并发的概念在互联网时代，并发，高并发通常是指并发访问。也就是在某个时间点，有多少个访问同时到来。 二 高并发架构相关概念 1、QPS (每秒查询率) : 每秒钟请求或者查询的数量，在互联网领域，指每秒响应请求数(指HTTP请求) 2、PV（Page View）：综合浏览量，即页面浏览量或者点击量，一个访客在24小时内访问的页面数量 –注：同一个人浏览你的网站的同一页面，只记做一次pv 3、吞吐量（fetches/sec） ：单位时间内处理的请求数量 （通常由QPS和并发数决定） 4、响应时间：从请求发出到收到响应花费的时间 5、独立访客（UV）：一定时间范围内，相同访客多次访问网站，只计算为1个独立访客 6、带宽：计算带宽需关注两个指标，峰值流量和页面的平均大小 7、日网站带宽： PV/统计时间（换算到秒） 平均页面大小（kb） 8 三 需要注意点： 1、QPS不等于并发连接数（QPS是每秒HTTP请求数量，并发连接数是系统同时处理的请求数量） 2、峰值每秒请求数（QPS）= （总PV数80%）/ （六小时秒数20%）【代表80%的访问量都集中在20%的时间内】 3、压力测试： 测试能承受的最大并发数 以及测试最大承受的QPS值 4、常用的性能测试工具【ab，wrk，httpload，Web Bench，Siege，Apache JMeter】 四 优化1、当QPS小于50时​ 优化方案:为一般小型网站,不用考虑优化 2、当QPS达到100时,遇到数据查询瓶颈​ 优化方案: 数据库缓存层,数据库的负载均衡 3、当QPS达到800时, 遇到带宽瓶颈​ 优化方案:CDN加速,负载均衡 4、当QPS达到1000时​ 优化方案: 做html静态缓存 5、当QPS达到2000时​ 优化方案: 做业务分离,分布式存储 五、高并发解决方案案例:1、流量优化​ 防盗链处理(去除恶意请求) 2、前端优化 (1) 减少HTTP请求[将css,js等合并] (2) 添加异步请求(先不将所有数据都展示给用户,用户触发某个事件,才会异步请求数据) (3) 启用浏览器缓存和文件压缩 (4) CDN加速 (5) 建立独立的图片服务器(减少I/O) 3、服务端优化 (1) 页面静态化 (2) 并发处理 (3) 队列处理 4、数据库优化 (1) 数据库缓存 (2) 分库分表,分区 (3) 读写分离 (4) 负载均衡 5、web服务器优化 (1) nginx反向代理实现负载均衡 (2) lvs实现负载均衡 关于海亮数据业务场景, 每天产生百万左右的日志,总量过亿, 准即时分析 不需要使用复杂的技术栈, PHP本身即可处理, 时间也可接受 可简单使用多开CLI进程的方式,每个CLI对应一个日志源, 不需要引入多线程之类的技术, 适合日志源较固定的业务场景. 提前过滤不需要保留的日志,如:爬虫, 业务中无用的日志, 我的业务场景 中可过滤掉90%的无效 日志 事先确认分析需求, 只根据需求对日志进行分析. 此处详解 123a.我使用第三方UA解析库对 UA进行分析,结果详细,但占用CPU过高,处理时间不理想b.根据业务需求,只分析是否爬虫以及操作系统(android,iOS,其它), 这样分析速度提升一个数量级 多种PHP技术并用: 本地文件缓存, 精细设计断点续操作, 批量插入数据库, 人性化的界面输出. 对异常进行分析, 有些异常使用简单的延时重试即可处理. 最重要的, 是要相信PHP, 如果有PHP不能实现的功能 , 那只是因为你的水平不够, 而不是PHP的问题.]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP书籍汇总与推荐]]></title>
    <url>%2F2019%2F06%2F01%2FPHP%E4%B9%A6%E7%B1%8D%E6%B1%87%E6%80%BB%E4%B8%8E%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[先来推荐一波我最近在看，和准备看的书籍或者文档首先作为一个PHP开发人员，官方手册是必看的，没看过或者说不看都不算一个合格的PHP程序员 关于MySQL 关于PHP 关于实战优化 PHP底层原理 【初阶】（基础知识及入门） 《PHP与MySQL程序设计（第4版）》 http://item.jd.com/10701892.html 《深入浅出MySQL 数据库开发 优化与管理维护 第2版》 http://item.jd.com/11381295.html 《实战Nginx：取代Apache的高性能Web服务器》 http://dwz.cn/2K1ryn 《Redis 实战》 http://item.jd.com/11791607.html 《MongoDB权威指南 第2版》 http://item.jd.com/11384782.html 《Linux系统命令及Shell脚本实践指南》 http://item.jd.com/11354663.html 【中阶】（基本系统知识相关，可阅读类似书籍） 《图解HTTP》 http://item.jd.com/11449491.html 《图解TCP/IP 第5版》 http://item.jd.com/11253710.html 《大话设计模式》 http://item.jd.com/10079261.html 《大话数据结构》 http://item.jd.com/10663703.html 《编译原理（第2版）》 http://item.jd.com/10058776.html 《Linux C 编程一站式学习》 http://dwz.cn/2K1C3n 《PHP应用程序安全编程》 http://dwz.cn/2K317p 《高性能PHP应用开发》 http://dwz.cn/2K1kcy 《PHP核心技术与最佳实践》 http://item.jd.com/11123177.html 《高性能MySQL（第3版）》 http://item.jd.com/11220393.html 《深入理解MariaDB与MySQL》 http://item.jd.com/11835700.html 《构建高可用Linux服务器（第3版）》 http://item.jd.com/11557939.html 【中高阶】（深入理解系统） 《深入理解计算机系统（原书第2版）》 http://item.jd.com/10360906.html 《现代操作系统（原书第3版）》 http://item.jd.com/10058893.html 《数据库系统概念（原书第6版）》 http://item.jd.com/10954261.html 《数据库系统实现（第2版）》 http://item.jd.com/10060181.html 《UNIX环境高级编程（第3版）》 http://item.jd.com/11469694.html 《UNIX网络编程 卷1 套接字联网API（第3版）》 http://item.jd.com/11728741.html 《Linux高性能服务器编程》 http://item.jd.com/11252777.html 【高阶】（深入理解服务原理） 《深入理解PHP内核》 http://www.php-internals.com/book/ 《深入理解MySQL》 http://item.jd.com/10063042.html 《MySQL技术内幕：InnoDB存储引擎（第2版）》 http://item.jd.com/11252326.html 《深入剖析Nginx》 http://item.jd.com/11226514.html 《深入理解Nginx：模块开发与架构解析》 http://item.jd.com/11217076.html 《Redis设计与实现》 http://item.jd.com/11486101.html 【架构及升级】（Web架构、分布式、云计算、机器学习等方向） 《大规模Web服务开发技术》 http://dwz.cn/2K2o1d 《大型分布式网站架构设计与实践》 http://item.jd.com/11529266.html 《大型网站技术架构 核心原理与案例分析》 http://item.jd.com/11322972.html 《大规模分布式系统架构与设计实战》 http://item.jd.com/11417660.html 《大规模分布式存储系统：原理解析与架构实战》 http://item.jd.com/11310547.html 《分布式系统：概念与设计（原书第5版）》 http://item.jd.com/11194499.html 《Hadoop权威指南（第3版 修订版）》 http://item.jd.com/11566298.html 《Cassandra权威指南》 http://item.jd.com/10794341.html 《云计算架构技术与实践》 http://item.jd.com/11537731.html 《OpenStack开源云王者归来》 http://item.jd.com/11521443.html 《数据挖掘 概念与技术（原书第3版）》 http://item.jd.com/11056660.html 《机器学习》 http://item.jd.com/10131321.html 《图解机器学习》 http://item.jd.com/11676112.html 《机器学习实战》 http://item.jd.com/11242112.html 【番外篇】（可以参考延展学习） 《深入PHP：面向对象、模式与实践（第3版）》 http://item.jd.com/10794350.html 《Linux网络编程（第2版）》 http://item.jd.com/11397772.html 《Linux多线程服务端编程 使用muduo C++网络库》 http://item.jd.com/11163782.html 《Linux运维之道》 http://item.jd.com/11375254.html 《Linux性能优化大师》 http://item.jd.com/11734651.html 《PostgreSQL修炼之道：从小工到专家》 http://item.jd.com/11684063.html 《图解网络硬件》 http://item.jd.com/11506709.html 《网络安全基础：网络攻防、协议与安全》 http://item.jd.com/10550797.html 《密码学原理与实践（第3版）》 http://item.jd.com/10067358.html 《黑客大曝光：网络安全机密与解决方案（第7版）》 http://item.jd.com/11307435.html 《黑客攻防技术宝典 Web实战篇 第2版》 http://item.jd.com/11020022.html 《精通正则表达式（第3版）》 http://item.jd.com/11070361.html 《Go语言编程》 http://item.jd.com/11067810.html 《Python基础教程（第2版 修订版）》 http://item.jd.com/11461683.html 《快学Scala》 http://item.jd.com/11113845.html 《Erlang/OTP并发编程实战》 http://item.jd.com/11037265.html 《函数式编程思维》 http://item.jd.com/11763847.html 《Android从入门到精通》 http://item.jd.com/11078112.html 《iOS开发指南》 http://item.jd.com/11681585.html 《搜索引擎：信息检索实践》 http://item.jd.com/10059723.html 《统计自然语言处理（第2版）》 http://item.jd.com/11314362.html 《这就是搜索引擎：核心技术详解》 http://item.jd.com/10893803.html 《Elasticsearch服务器开发（第2版）》 http://item.jd.com/11615450.html 《实战Elasticsearch、Logstash、Kibana》 http://item.jd.com/11706768.html 《推荐系统实践》 http://item.jd.com/11007625.html 《机器学习实践指南：案例应用解析》 http://item.jd.com/11447036.html 《Hadoop实战（第2版）》 http://item.jd.com/11116710.html 《Hadoop大数据分析与挖掘实战》 http://item.jd.com/11837003.html 《Spark大数据处理：技术、应用与性能优化》 http://item.jd.com/11577088.html 《Spark机器学习》 http://item.jd.com/11763016.html]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHP面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP闭包（Closure）初探]]></title>
    <url>%2F2019%2F05%2F24%2FPHP%E9%97%AD%E5%8C%85%EF%BC%88Closure%EF%BC%89%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[不知不觉发现PHP已经出到了5.5版本，而自己一直在用PHP5.2，让我看起来像深山出来的小伙子一样，又土又落后。在我习惯在javascript中使用闭包之后，忽然间对PHP的闭包打起了兴趣。 于是乎在网上下了个WAMP集成开发环境，是PHP5.3版本的（PHP5.3开始引入了闭包的特性），不得不说WAMP安装使用真的很方便。简单配置了一下，开始动手。 匿名函数提到闭包就不得不想起匿名函数，也叫闭包函数（closures），貌似PHP闭包实现主要就是靠它。声明一个匿名函数是这样： $func = function() { }; //带结束符 可以看到，匿名函数因为没有名字，如果要使用它，需要将其返回给一个变量。匿名函数也像普通函数一样可以声明参数，调用方法也相同： ​ $func = function( $param ) { echo $param; }; $func( &apos;some string&apos; ); //输出： //some string 顺便提一下，PHP在引入闭包之前，也有一个可以创建匿名函数的函数：create function，但是代码逻辑只能写成字符串，这样看起来很晦涩并且不好维护，所以很少有人用。 实现闭包将匿名函数在普通函数中当做参数传入，也可以被返回。这就实现了一个简单的闭包。 下边有三个例子 例一//在函数里定义一个匿名函数，并且调用它 function printStr() { $func = function( $str ) { echo $str; }; $func( &apos;some string&apos; ); } printStr(); 例二//在函数中把匿名函数返回，并且调用它 function getPrintStrFunc() { $func = function( $str ) { echo $str; }; return $func; } $printStrFunc = getPrintStrFunc(); $printStrFunc( &apos;some string&apos; ); 例三//把匿名函数当做参数传递，并且调用它 function callFunc( $func ) { $func( &apos;some string&apos; ); } $printStrFunc = function( $str ) { echo $str; }; callFunc( $printStrFunc ); //也可以直接将匿名函数进行传递。如果你了解js，这种写法可能会很熟悉 callFunc( function( $str ) { echo $str; } ); 连接闭包和外界变量的关键字：USE 闭包可以保存所在代码块上下文的一些变量和值。PHP在默认情况下，匿名函数不能调用所在代码块的上下文变量，而需要通过使用use关键字。 function getMoney() { $rmb = 1; $dollar = 6; $func = function() use ( $rmb ) { echo $rmb; echo $dollar; }; $func(); } getMoney(); //输出： //1 //报错，找不到dorllar变量 可以看到，dollar没有在use关键字中声明，在这个匿名函数里也就不能获取到它，所以开发中要注意这个问题。 有人可能会想到，是否可以在匿名函数中改变上下文的变量，但我发现是不可以的： function getMoney() { $rmb = 1; $func = function() use ( $rmb ) { echo $rmb; //把$rmb的值加1 $rmb++; }; $func(); echo $rmb; } getMoney(); //输出： //1 //1 啊，原来use所引用的也只不过是变量的一个副本而已。但是我想要完全引用变量，而不是复制。 要达到这种效果，其实在变量前加一个 &amp; 符号就可以了： function getMoney() { $rmb = 1; $func = function() use ( &amp;$rmb ) { echo $rmb; //把$rmb的值加1 $rmb++; }; $func(); echo $rmb; } getMoney(); //输出： //1 //2 好，这样匿名函数就可以引用上下文的变量了。如果将匿名函数返回给外界，匿名函数会保存use所引用的变量，而外界则不能得到这些变量，这样形成‘闭包’这个概念可能会更清晰一些。 function getMoneyFunc() { $rmb = 1; $func = function() use ( &amp;$rmb ) { echo $rmb; //把$rmb的值加1 $rmb++; }; return $func; } $getMoney = getMoneyFunc(); $getMoney(); $getMoney(); $getMoney(); //输出： //1 //2 //3 总结 PHP闭包的特性并没有太大惊喜，其实用CLASS就可以实现类似甚至强大得多的功能，更不能和js的闭包相提并论，只能期待PHP以后对闭包支持的改进。不过匿名函数还是挺有用的，比如在使用preg_replace_callback等之类的函数可以不用在外部声明回调函数了。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL两种存储引擎- MyISAM和InnoDB 简单总结]]></title>
    <url>%2F2019%2F05%2F03%2FMySQL%E4%B8%A4%E7%A7%8D%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%20MyISAM%E5%92%8CInnoDB%20%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[MyISAM是MySQL的默认数据库引擎（5.5版之前），由早期的ISAM（Indexed Sequential Access Method：有索引的顺序访问方法）所改良。虽然性能极佳，但却有一个缺点：不支持事务处理（transaction）。不过，在这几年的发展下，MySQL也导入了InnoDB（另一种数据库引擎），以强化参考完整性与并发违规处理机制，后来就逐渐取代MyISAM。 InnoDB，是MySQL的数据库引擎之一，为MySQL AB发布binary的标准之一。InnoDB由Innobase Oy公司所开发，2006年五月时由甲骨文公司并购。与传统的ISAM与MyISAM相比，InnoDB的最大特色就是支持了ACID兼容的事务（Transaction）功能，类似于PostgreSQL。目前InnoDB采用双轨制授权，一是GPL授权，另一是专有软件授权。 MyISAM和InnoDB两者之间有着明显区别，简单梳理如下: 1) 事务支持MyISAM不支持事务，而InnoDB支持。InnoDB的AUTOCOMMIT默认是打开的，即每条SQL语句会默认被封装成一个事务，自动提交，这样会影响速度，所以最好是把多条SQL语句显示放在begin和commit之间，组成一个事务去提交。 MyISAM是非事务安全型的，而InnoDB是事务安全型的，默认开启自动提交，宜合并事务，一同提交，减小数据库多次提交导致的开销，大大提高性能。 2) 存储结构MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。 InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。 3) 存储空间MyISAM：可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。 InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。 4) 可移植性、备份及恢复MyISAM：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。 InnoDB：免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。 5) 事务支持MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。 InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。 6) AUTO_INCREMENTMyISAM：可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。 InnoDB：InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。 7) 表锁差异MyISAM：只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。 InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。 MyISAM锁的粒度是表级，而InnoDB支持行级锁定。简单来说就是, InnoDB支持数据行锁定，而MyISAM不支持行锁定，只支持锁定整个表。即MyISAM同一个表上的读锁和写锁是互斥的，MyISAM并发读写时如果等待队列中既有读请求又有写请求，默认写请求的优先级高，即使读请求先到，所以MyISAM不适合于有大量查询和修改并存的情况，那样查询进程会长时间阻塞。因为MyISAM是锁表，所以某项读操作比较耗时会使其他写进程饿死。 8) 全文索引MyISAM：支持(FULLTEXT类型的)全文索引 InnoDB：不支持(FULLTEXT类型的)全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。 全文索引是指对char、varchar和text中的每个词（停用词除外）建立倒排序索引。MyISAM的全文索引其实没啥用，因为它不支持中文分词，必须由使用者分词后加入空格再写到数据表里，而且少于4个汉字的词会和停用词一样被忽略掉。 另外，MyIsam索引和数据分离，InnoDB在一起，MyIsam天生非聚簇索引，最多有一个unique的性质，InnoDB的数据文件本身就是主键索引文件，这样的索引被称为“聚簇索引” 9) 表主键MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。 InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。InnoDB的主键范围更大，最大是MyISAM的2倍。 10) 表的具体行数MyISAM：保存有表的总行数，如果select count(*) from table;会直接取出出该值。 InnoDB：没有保存表的总行数(只能遍历)，如果使用select count(*) from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。 11) CURD操作MyISAM：如果执行大量的SELECT，MyISAM是更好的选择。 InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。 12) 外键MyISAM：不支持 InnoDB：支持 13) 查询效率没有where的count()使用MyISAM要比InnoDB快得多。因为MyISAM内置了一个计数器，count()时它直接从计数器中读，而InnoDB必须扫描全表。所以在InnoDB上执行count()时一般要伴随where，且where中要包含主键以外的索引列。为什么这里特别强调“主键以外”？因为InnoDB中primary index是和raw data存放在一起的，而secondary index则是单独存放，然后有个指针指向primary key。所以只是count()的话使用secondary index扫描更快，而primary key则主要在扫描索引同时要返回raw data时的作用较大。MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM。 通过上述的分析，基本上可以考虑使用InnoDB来替代MyISAM引擎了，原因是InnoDB自身很多良好的特点，比如事务支持、存储 过程、视图、行级锁定等等，在并发很多的情况下，相信InnoDB的表现肯定要比MyISAM强很多。另外，任何一种表都不是万能的，只用恰当的针对业务类型来选择合适的表类型，才能最大的发挥MySQL的性能优势。如果不是很复杂的Web应用，非关键应用，还是可以继续考虑MyISAM的，这个具体情况可以自己斟酌。 MyISAM和InnoDB两者的应用场景： 1) MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。 2) InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。 但是实际场景中，针对具体问题需要具体分析，一般而言可以遵循以下几个问题： 数据库是否有外键？ 是否需要事务支持？ 是否需要全文索引？ 数据库经常使用什么样的查询模式？在写多读少的应用中还是Innodb插入性能更稳定，在并发情况下也能基本，如果是对读取速度要求比较快的应用还是选MyISAM。 数据库的数据有多大？ 大尺寸倾向于innodb，因为事务日志，故障恢复。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL索引优化策略与笔记]]></title>
    <url>%2F2019%2F04%2F29%2FMySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5%E4%B8%8E%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[面试知识，数据库索引优化 什么问题？索引有什么代价？哪些场景下你需要建索引？或者有时候反过来问，哪些场景下不推荐建索引。 建好索引之后，怎么才能最高效地利用索引？或者反过来问，请说出一个无法有效利用已建索引的案例。 索引的好处？ 快速查询数据。 代价是什么？索引需要占硬盘空间，这是空间方面的代价。 一旦插入新的数据，就需要重新建索引，这是时间上的代价。 不同场景，不同对待。场景一 数据表规模不大，就几千行，即使不建索引，查询语句的返回时间也不长，这时建索引的意义就不大。当然，若就几千行，索引所占的空间也不多，所以这种情况下，顶多属于“性价比”不高。 场景二 某个商品表里有几百万条商品信息，同时每天会在一个时间点，往其中更新大概十万条左右的商品信息，现在用where语句查询特定商品时（比如where name = ‘XXX’）速度很慢。为了提升查询效率可以建索引，但当每天更新数据时，又会重建索引，这是要耗费时间的。这时就需要综合考虑，甚至可以在更新前删除索引，更新后再重建。 场景三 因为在数据表里ID值都不相同，所以索引能发挥出比较大的作用。相反，如果某个字段重复率很高，如性别字段，或者某个字段大多数值是空（null），那么不建议对该字段建索引。 建立索引原则一定是有业务需求了才会建索引。比如在一个商品表里，我们经常要根据name做查询，如果没有索引，查询速度会很慢，这时就需要建索引。但在项目开发中，如果不经常根据商品编号查询，那么就没必要对编号建索引。 最后再强调一次，建索引是要付出代价的，没事别乱建着玩，同时在一个表上也不能建太多的索引。具体的例子来看索引的正确用法 语句一：select name from 商品表。不会用到索引，因为没有where语句。 语句二：select * from 商品表 where name = ‘Java书’，会用到索引，如果项目里经常用到name来查询，且商品表的数据量很大，而name值的重复率又不高，那么建议建索引。 语句三：select * from 商品表 where name like ‘Java%’ 这是个模糊查询，会用到索引，请大家记住，用like进行模糊查询时，如果第一个就是模糊的匹配符，比如where name like ‘%java’，那么在查询时不会走索引。在其他情况下，不论用了多少个%，也不论%的位置，只要不出现在第一个位置，那么都能用到索引。 学生成绩表里有两个字段：姓名和成绩。现在对成绩这个整数类型的字段建索引。 第一种情况，当数字型字段遇到非等值操作符时，无法用到索引。比如： ​ select name from 学生成绩表 where 成绩&gt;95 , 一旦出现大于符号，就不能用到索引，为了用到索引，我们应该改一下SQL语句里的where从句：where 成绩 in (96,97,98,99,100) 第二种情况，如果对索引字段进行了某种左值操作，那么无法用到索引。 ​ 能用到索引的写法：select name from 学生成绩表 where 成绩 = 60 ​ 不能用到索引的写法：select name from 学生成绩表 where 成绩+40 = 100 第三种情况，如果对索引字段进行了函数操作，那么无法用到索引。 ​ 比如SQL语句：select * from 商品表 where substr(name) = ‘J’，我们希望查询商品名首字母是J的记录，可一旦针对name使用函数，即使name字段上有索引，也无法用到。​ 非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据。 不管以任何方式查询表， 最终都会利用主键通过聚集索引来定位到数据， 聚集索引（主键）是通往真实数据所在的唯一路径。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何处理负载、高并发问题]]></title>
    <url>%2F2019%2F04%2F27%2F%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%B4%9F%E8%BD%BD%E3%80%81%E9%AB%98%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[从低成本、高性能和高扩张性的角度来说有如下处理方案： 1、HTML静态化其实大家都知道，效率最高、消耗最小的就是纯静态化的html页面，所以我们尽可能使我们的 网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。 2、图片服务器分离​ 把图片单独存储，尽量减少图片等大流量的开销，可以放在一些相关的平台上，如骑牛等 3、数据库集群和库表散列及缓存数据库的并发连接为100，一台数据库远远不够，可以从读写分离、主从复制，数据库集群方面来着手。另外尽量减少数据库的访问，可以使用缓存数据库如memcache、redis。 4、镜像： 尽量减少下载，可以把不同的请求分发到多个镜像端。 5、负载均衡： Apache的最大并发连接为1500，只能增加服务器，可以从硬件上着手，如F5服务器。当然硬件的成本比较高，我们往往从软件方面着手。 负载均衡 （Load Balancing） 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力，同时能够提高网络的灵活性和可用性。目前使用最为广泛的负载均衡软件是Nginx、LVS、HAProxy。我分别来说下三种的优缺点: Nginx的优点是： 工作在网络的7层之上，可以针对http应用做一些分流的策略，比如针对域名、目录结构，它的正则规则比HAProxy更为强大和灵活，这也是它目前广泛流行的主要原因之一，Nginx单凭这点可利用的场合就远多于LVS了。 Nginx对网络稳定性的依赖非常小，理论上能ping通就就能进行负载功能，这个也是它的优势之一；相反LVS对网络稳定性依赖比较大，这点本人深有体会； Nginx安装和配置比较简单，测试起来比较方便，它基本能把错误用日志打印出来。LVS的配置、测试就要花比较长的时间了，LVS对网络依赖比较大。 可以承担高负载压力且稳定，在硬件不差的情况下一般能支撑几万次的并发量，负载度比LVS相对小些。 Nginx可以通过端口检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点，不过其中缺点就是不支持url来检测。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而不满。 Nginx不仅仅是一款优秀的负载均衡器/反向代理软件，它同时也是功能强大的Web应用服务器。LNMP也是近几年非常流行的web架构，在高流量的环境中稳定性也很好。 Nginx现在作为Web反向加速缓存越来越成熟了，速度比传统的Squid服务器更快，可以考虑用其作为反向代理加速器。 Nginx可作为中层反向代理使用，这一层面Nginx基本上无对手，唯一可以对比Nginx的就只有 lighttpd了，不过 lighttpd目前还没有做到Nginx完全的功能，配置也不那么清晰易读，社区资料也远远没Nginx活跃。 Nginx也可作为静态网页和图片服务器，这方面的性能也无对手。还有Nginx社区非常活跃，第三方模块也很多。 Nginx的缺点是： Nginx仅能支持http、https和Email协议，这样就在适用范围上面小些，这个是它的缺点。 对后端服务器的健康检查，只支持通过端口来检测，不支持通过url来检测。不支持Session的直接保持，但能通过ip_hash来解决。 LVS：使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability)、可靠性（Reliability)和可管理性（Manageability)。LVS的优点是： 抗负载能力强、是工作在网络4层之上仅作分发之用，没有流量的产生，这个特点也决定了它在负载均衡软件里的性能最强的，对内存和cpu资源消耗比较低。 配置性比较低，这是一个缺点也是一个优点，因为没有可太多配置的东西，所以并不需要太多接触，大大减少了人为出错的几率。 工作稳定，因为其本身抗负载能力很强，自身有完整的双机热备方案，如LVS+Keepalived，不过我们在项目实施中用得最多的还是LVS/DR+Keepalived。 无流量，LVS只分发请求，而流量并不从它本身出去，这点保证了均衡器IO的性能不会受到大流量的影响。 应用范围比较广，因为LVS工作在4层，所以它几乎可以对所有应用做负载均衡，包括http、数据库、在线聊天室等等。 LVS的缺点是： 软件本身不支持正则表达式处理，不能做动静分离；而现在许多网站在这方面都有较强的需求，这个是Nginx/HAProxy+Keepalived的优势所在。 如果是网站应用比较庞大的话，LVS/DR+Keepalived实施起来就比较复杂了，特别后面有 Windows Server的机器的话，如果实施及配置还有维护过程就比较复杂了，相对而言，Nginx/HAProxy+Keepalived就简单多了。 HAProxy的特点是： HAProxy也是支持虚拟主机的。 HAProxy的优点能够补充Nginx的一些缺点，比如支持Session的保持，Cookie的引导；同时支持通过获取指定的url来检测后端服务器的状态。 HAProxy跟LVS类似，本身就只是一款负载均衡软件；单纯从效率上来讲HAProxy会比Nginx有更出色的负载均衡速度，在并发处理上也是优于Nginx的。 HAProxy支持TCP协议的负载均衡转发，可以对MySQL读进行负载均衡，对后端的MySQL节点进行检测和负载均衡，大家可以用LVS+Keepalived对MySQL主从做负载均衡。 HAProxy负载均衡策略非常多，HAProxy的负载均衡算法现在具体有如下8种： ① roundrobin，表示简单的轮询，这个不多说，这个是负载均衡基本都具备的；② static-rr，表示根据权重，建议关注；③ leastconn，表示最少连接者先处理，建议关注；④ source，表示根据请求源IP，这个跟Nginx的IP_hash机制类似，我们用其作为解决session问题的一种方法，建议关注；⑤ ri，表示根据请求的URI；⑥ rl_param，表示根据请求的URl参数’balance url_param’ requires an URL parametername；⑦ hdr(name)，表示根据HTTP请求头来锁定每一次HTTP请求；⑧ rdp-cookie(name)，表示根据据cookie(name)来锁定并哈希每一次TCP请求。 Nginx和LVS对比的总结： Nginx工作在网络的7层，所以它可以针对http应用本身来做分流策略，比如针对域名、目录结构等，相比之下LVS并不具备这样的功能，所以Nginx单凭这点可利用的场合就远多于LVS了；但Nginx有用的这些功能使其可调整度要高于LVS，所以经常要去触碰触碰，触碰多了，人为出问题的几率也就会大。 Nginx对网络稳定性的依赖较小，理论上只要ping得通，网页访问正常，Nginx就能连得通，这是Nginx的一大优势！Nginx同时还能区分内外网，如果是同时拥有内外网的节点，就相当于单机拥有了备份线路；LVS就比较依赖于网络环境，目前来看服务器在同一网段内并且LVS使用direct方式分流，效果较能得到保证。另外注意，LVS需要向托管商至少申请多一个ip来做Visual IP，貌似是不能用本身的IP来做VIP的。要做好LVS管理员，确实得跟进学习很多有关网络通信方面的知识，就不再是一个HTTP那么简单了。 Nginx安装和配置比较简单，测试起来也很方便，因为它基本能把错误用日志打印出来。LVS的安装和配置、测试就要花比较长的时间了；LVS对网络依赖比较大，很多时候不能配置成功都是因为网络问题而不是配置问题，出了问题要解决也相应的会麻烦得多。 Nginx也同样能承受很高负载且稳定，但负载度和稳定度差LVS还有几个等级：Nginx处理所有流量所以受限于机器IO和配置；本身的bug也还是难以避免的。 Nginx可以检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点。目前LVS中 ldirectd也能支持针对服务器内部的情况来监控，但LVS的原理使其不能重发请求。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而恼火。 Nginx对请求的异步处理可以帮助节点服务器减轻负载，假如使用 apache直接对外服务，那么出现很多的窄带链接时apache服务器将会占用大量内存而不能释放，使用多一个Nginx做apache代理的话，这些窄带链接会被Nginx挡住，apache上就不会堆积过多的请求，这样就减少了相当多的资源占用。这点使用squid也有相同的作用，即使squid本身配置为不缓存，对apache还是有很大帮助的。 Nginx能支持http、https和email（email的功能比较少用），LVS所支持的应用在这点上会比Nginx更多。在使用上，一般最前端所采取的策略应是LVS，也就是DNS的指向应为LVS均衡器，LVS的优点令它非常适合做这个任务。重要的ip地址，最好交由LVS托管，比如数据库的 ip、webservice服务器的ip等等，这些ip地址随着时间推移，使用面会越来越大，如果更换ip则故障会接踵而至。所以将这些重要ip交给 LVS托管是最为稳妥的，这样做的唯一缺点是需要的VIP数量会比较多。Nginx可作为LVS节点机器使用，一是可以利用Nginx的功能，二是可以利用Nginx的性能。当然这一层面也可以直接使用squid，squid的功能方面就比Nginx弱不少了，性能上也有所逊色于Nginx。Nginx也可作为中层代理使用，这一层面Nginx基本上无对手，唯一可以撼动Nginx的就只有lighttpd了，不过lighttpd目前还没有能做到 Nginx完全的功能，配置也不那么清晰易读。另外，中层代理的IP也是重要的，所以中层代理也拥有一个VIP和LVS是最完美的方案了。具体的应用还得具体分析，如果是比较小的网站（日PV小于1000万），用Nginx就完全可以了，如果机器也不少，可以用DNS轮询，LVS所耗费的机器还是比较多的；大型网站或者重要的服务，机器不发愁的时候，要多多考虑利用LVS。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>高负载</tag>
        <tag>高并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL 事务处理常见有两种方法]]></title>
    <url>%2F2019%2F04%2F26%2FMYSQL%20%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%B8%B8%E8%A7%81%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[MYSQL在操作大量的数据或者比较重要的数据的时候，事务处理很重要，比如银行的转账，支付，等等，作为开发人员事务是必须的一步。 1、用 BEGIN, ROLLBACK, COMMIT来实现 BEGIN 开始一个事务 ROLLBACK 事务回滚 COMMIT 事务确认 2、直接用 SET 来改变 MySQL 的自动提交模式: SET AUTOCOMMIT=0 禁止自动提交 SET AUTOCOMMIT=1 开启自动提交 注意的是，在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。 MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！ 一、php事务处理概述： 事务:是若干事件的集合 事务处理:当所有事件执行成功,事务才执行;若有任何一个事件不能成功执行,事务的其它事件也不被执行。 只要你的MySQL版本支持BDB或InnoDB表类型，那么你的MySQL就具有事务处理的能力。这里面，又以InnoDB表类型用的最多，虽然后来发生了诸如Oracle收购InnoDB等令MySQL不爽的事情，但是这类商业事件与技术无关，下面就以InnoDB表类型为例简单说一下MySQL中的事务处理。 二、php事务处理代码：&lt;?php try{ $pdo=new PDO(&quot;mysql:host=localhost;dbname=psp&quot;,&quot;root&quot;,&quot;&quot;); $pdo-&gt;exec(&quot;set names utf8&quot;); $pdo-&gt;setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_EXCEPTION);//设置异常处理模式 $pdo-&gt;setAttribute(PDO::ATTR_AUTOCOMMIT,0);//关闭自动提交 }catch(PDOException $e){ echo &quot;数据库连接失败&quot;; exit; } try{ $age=10; $pdo-&gt;beginTransaction();//开始事务 $affected_rows1=$pdo-&gt;exec(&quot;update kfry set k_age=k_age+{$age} where k_name=&apos;user1&apos;&quot;); $affected_rows2=$pdo-&gt;exec(&quot;update kfry set k_age=k_age-{$age} where k_name=&apos;user2&apos;&quot;);//随意更改使之执行成功或失败 /* if($affected_rows1&amp;&amp;$affected_rows2) { $pdo-&gt;commit(); echo &quot;操作成功&quot;; }else{ $pdo-&gt;rollback(); } */ if(!$affected_rows1) throw new PDOException(&quot;加入错误&quot;); if(!$affected_rows2) throw new PDOException(&quot;减少错误&quot;); echo &quot;操作成功&quot;; $pdo-&gt;commit();//如果执行到此处前面两个更新sql语句执行成功，整个事务执行成功 }catch(PDOException $e){ echo &quot;操作失败：&quot;.$e-&gt;getMessage(); $pdo-&gt;rollback();//执行事务中的语句出了问题，整个事务全部撤销 } $pdo-&gt;setAttribute(PDO::ATTR_AUTOCOMMIT,1); //测试是否成功 echo &quot;\n操作结果为:\n&quot;; $sql=&quot;select * from kfry&quot;; $result=$pdo-&gt;query($sql); foreach($result as $v) { echo $v[&apos;k_name&apos;].&quot; &quot;.$v[&apos;k_age&apos;].&quot;\n&quot;; } ?&gt; 以上就是php 事务处理详解的详细内容，更多请关注php中文网其它相关文章！]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web安全的一次探讨]]></title>
    <url>%2F2019%2F03%2F13%2FWeb%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%80%E6%AC%A1%E6%8E%A2%E8%AE%A8%2F</url>
    <content type="text"><![CDATA[一、SQL注入攻击(SQL Injection)攻击者把sql命令插入到web表单的输入域或页面请求的字符串，欺骗服务器执行恶意的sql命令。常见的sql注入攻击类似： 登录页面中输入内容直接用来构造动态的sql语句，例如：1$query = &apos;select * from users where login = &apos;. $username. &apos;and password = &apos;. $password; 攻击者如果在用户名或者密码框输入or &#39;1&#39; =1，这样我们执行的sql语句就变成了： 1select * from users where login = &apos;&apos; or &apos;1&apos; = 1 and ... 这样就绕过了我们的登录验证。类似的还有很多，用户通过输入恶意的sql命令来绕过我们的验证，欺骗我们的系统。 防范的方法： 检查变量数据类型和格式 过滤特殊的符号 绑定变量，使用预处理语句（当我们绑定变量的时候，就算有特殊字符sql也会认为是个变量而不是sql命令） 二、跨站脚本攻击(Cross Site Scripting, XSS；因为CSS被用了所以叫XSS)攻击者将恶意代码注入到网页上，其他用户在加载网页时就会执行代码，攻击者可能会得到各种私密的信息，如cookie等。例如： 12&lt;?php echo &apos;你好！&apos;.$_GET[&apos;name&apos;]; 如果用户传入一段脚本&lt;script&gt;[code]&lt;/script&gt;，那么脚本也会执行，如果code的内容是获取到cookie并发送到某个指定的位置，获取了敏感的信息。亦或是利用用户的身份去执行一些不正当的操作。 防范的方法： 输出的时候过滤特殊的字符，转换成html编码，过滤输出的变量（PHP可以使用htmlspecialchars） 三、跨站请求伪造攻击(Cross Site Request Forgeries, CSRF)攻击者伪造目标用户的HTTP请求，然后此请求发送到有CSRF漏洞的网站，网站执行此请求后，引发跨站请求伪造攻击。攻击者利用隐蔽的HTTP连接，让目标用户在不注意的情况下单击这个链接，由于是用户自己点击的，而他又是合法用户拥有合法权限，所以目标用户能够在网站内执行特定的HTTP链接，从而达到攻击者的目的。 用户刚刚登陆了银行A网站，建立了会话，A网站可以进行转账操作http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000在没有退出的情况下去访问危险网站B网站，B网站有一个图片是这样的&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;，不小心点了B网站，用户发现账上少了1000块。 可能有人会说，修改操作并不会用get请求。那么假设银行A网站的表单如下 12345&lt;form action=&quot;Transfer.php&quot; method=&quot;POST&quot;&gt; &lt;p&gt;ToBankId: &lt;input type=&quot;text&quot; name=&quot;toBankId&quot; /&gt;&lt;/p&gt; &lt;p&gt;Money: &lt;input type=&quot;text&quot; name=&quot;money&quot; /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Transfer&quot; /&gt;&lt;/p&gt;&lt;/form&gt; 后台处理页面如下： 1234567&lt;?phpsession_start();if (isset($_REQUEST[&apos;toBankId&apos;] &amp;&amp; isset($_POST[&apos;money&apos;]))&#123; buy_stocks($_REQUEST[&apos;toBankId&apos;],$_REQUEST[&apos;money&apos;]);&#125;?&gt; B网站这时候也相应的改了代码: 1234567891011121314151617181920&lt;html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot;&gt; function steal() &#123; iframe = document.frames[&quot;steal&quot;]; iframe.document.Submit(&quot;transfer&quot;); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload=&quot;steal()&quot;&gt; &lt;iframe name=&quot;steal&quot; display=&quot;none&quot;&gt; &lt;form method=&quot;POST&quot; name=&quot;transfer&quot; action=&quot;http://www.myBank.com/Transfer.php&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;toBankId&quot; value=&quot;11&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;money&quot; value=&quot;1000&quot;&gt; &lt;/form&gt; &lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt; 用户一点到B网站，发现又少了1000块……. 防范方法： 对表单进行cookie hash校验，将一个随机值的hash写入cookie，每次提交表单，都在服务端对这个hash进行校验（建立在用户的cookie没有被盗取） 四、Session固定攻击(Session Fixation)攻击者预先设定session id，让合法用户使用这个session id来访问被攻击的应用程序，一旦用户的会话ID被成功固定，攻击者就可以通过此session id来冒充用户访问应用程序。例如： 攻击者先访问目标网站，获得了自己的session_id，如SID=123 攻击者给目标用户发送链接，并带上了自己的session_id，如http:///www.bank.com/?SID=123， 目标用户点击了http:///www.bank.com/?SID=123，输入用户名密码登录，由于session_id不会变更，那么攻击者就可以通过访问http:///www.bank.com/?SID=123来获取目标用户的身份。 防范方法： 定期更改session_id 更改session_id的名字 五、Session劫持(Session Hijacking)攻击者利用各种手段来获取目标用户的session id。一旦获取到session id，那么攻击者可以利用目标用户的身份来登录网站，获取目标用户的操作权限。 攻击者获取目标用户session id的方法: 暴力破解:尝试各种session id，直到破解为止; 计算:如果session id使用非随机的方式产生，那么就有可能计算出来; 窃取:使用网络截获，xss攻击等方法获得防范方法： 定期更改session id 更改session的名称 关闭透明化session id 设置HttpOnly。通过设置Cookie的HttpOnly为true，可以防止客户端脚本访问这个Cookie，从而有效的防止XSS攻击。 六、文件上传漏洞(File Upload Attack)攻击者利用程序缺陷绕过系统对文件的验证与处理策略将恶意代码上传到服务器并获得执行服务器端命令的能力。 常用的攻击手段有： 上传Web脚本代码，Web容器解释执行上传的恶意脚本； 上传Flash跨域策略文件crossdomain.xml，修改访问权限(其他策略文件利用方式类似)； 上传病毒、木马文件，诱骗用户和管理员下载执行； 上传包含脚本的图片，某些浏览器的低级版本会执行该脚本，用于钓鱼和欺诈。总的来说，利用的上传文件要么具备可执行能力(恶意代码)，要么具备影响服务器行为的能力(配置文件)。防范方法： 文件上传的目录设置为不可执行； 判断文件类型，设置白名单。对于图片的处理，可以使用压缩函数或者resize函数，在处理图片的同时破坏图片中可能包含的HTML代码； 使用随机数改写文件名和文件路径：一个是上传后无法访问；再来就是像shell、.php 、.rar和crossdomain.xml这种文件，都将因为重命名而无法攻击； 单独设置文件服务器的域名：由于浏览器同源策略的关系，一系列客户端攻击将失效，比如上传crossdomain.xml、上传包含Javascript的XSS利用等问题将得到解决。 MYSQL安全 使用预处理语句防止sql注入 写入数据库的数据要进行特殊字符转义 查询的错误信息不要返回给用户，将错误记录到日志 定期做数据库备份 不给查询用户root权限，合理分配权限 关闭远程访问数据库的权限]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库查询速度优化之解决技巧]]></title>
    <url>%2F2019%2F03%2F11%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%E4%B9%8B%E8%A7%A3%E5%86%B3%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[1、对查询进行优化,应尽可能避免全表扫描首先应考虑在 where 及 order by 涉及的列上建立索引。下面我们来以一个表中177条数据比较一下,全表扫描与建立索引之后性能的一个比较. 从这两种方式查询数据库结果看,建立索引之后查询速度提高了些,现在数据量还不明显,如果表中有10万条速度,差异就会很明显了. 2、写数据语句时尽可能减少表的全局扫描2.1 减少where 字段值null判断SELECT * FROM &quot;tb_real_time_car&quot; where pay_status = null 如何这样做,就会导致引擎放弃使用索引而进行全表扫描应该这样去设置(也就是在没有值时,我们在存数据库时自动默认给个o值,而不是什么都不写): SELECT * FROM &quot;tb_real_time_car&quot; where pay_status = 0 2.2 应尽量避免在 where 子句中使用!=或&lt;&gt;操作符SELECT * FROM &quot;tb_real_time_car&quot; where pay_status != null ; //或者 SELECT * FROM &quot;tb_real_time_car&quot; where pay_status &lt;&gt; null ; 这样写将导致引擎放弃使用索引而进行全表扫描。 2.3 应尽量避免在 where 子句中使用 or 来连接条件SELECT * FROM &quot;tb_real_time_car&quot; where pay_status != null or enter_time = null; 这样将导致引擎放弃使用索引而进行全表扫描 可以这样操作: SELECT * FROM &quot;tb_real_time_car&quot; where pay_status != null union all SELECT * FROM &quot;tb_real_time_car&quot; where enter_time = null; 2.4 in 和 not in 也要慎用SELECT * FROM &quot;tb_real_time_car&quot; where rowed in [1,2,3,4]; //或者 SELECT * FROM &quot;tb_real_time_car&quot; where rowed not in [1,2,3,4]; 这样操作,也会导致全表扫描 可以这样来写: SELECT * FROM &quot;tb_real_time_car&quot; where rowed between 1 and 5; 2.5 少使用模糊匹配 likeSELECT * FROM &quot;tb_real_time_car&quot; where enter_time like &apos;%2016-09-01%&apos; 2.6 应尽量避免在 where 子句中对字段进行表达式操作SELECT * FROM &quot;tb_real_time_car&quot; where rowid/4 =100; 这样写,将导致引擎放弃使用索引而进行全表扫描 应该写成: SELECT * FROM &quot;tb_real_time_car&quot; where rowid =4*100; 2.7 任何地方都不要使用*通配符去查询所有SELECT * FROM &quot;tb_real_time_car&quot; where rowid/4 =100; 以通配符*去查询所有数据,这样做也是非常耗时的,我们应该需要什么字段就查询什么字段. 应该这样做: SELECT leave_time FROM &quot;tb_real_time_car&quot; where rowid/4 =100; 3、不要在条件判断时进行 算数运算SELECT * FROM &quot;tb_real_time_car&quot; where rowid/4 =100; 所以不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算,这样系统将可能无法正确使用索引 应该这样做: SELECT * FROM &quot;tb_real_time_car&quot; where rowed =400; 4、很多时候用 exists 代替 in 是一个好的选择SELECT * FROM &quot;tb_real_time_car&quot; where rowed (select rowed from &quot;tb_real&quot;); 应该这样来写: SELECT * FROM &quot;tb_real_time_car&quot; where exists (select rowed from &quot;tb_real&quot; where rowed = tb_real.rowid); 5 论索引技巧5.1 并不是所有索引对查询都有效SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用 5.2 索引并不是越多越好索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。 5.3 应尽可能的避免更新 clustered 索引数据列因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。 5.4 尽量使用数字型字段若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 6 创建数据库时应该注意地方6.1. 尽可能的使用 varchar/nvarchar 代替 char/nchar因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 6.2 用表变量来代替临时表。 如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。 6.3 避免频繁创建和删除临时表，以减少系统表资源的消耗。6.4 尽量避免使用游标 因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。 使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。 与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。 7 数据放回时注意什么7.1 尽量避免大事务操作，提高系统并发能力。这样可以有效提高系统的并发能力 7.2 尽量避免向客户端返回大数据量若数据量过大，应该考虑相应需求是否合理。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于mysql最左前缀原则]]></title>
    <url>%2F2019%2F03%2F01%2F%E5%85%B3%E4%BA%8Emysql%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[背景知识： mysql中可以使用explain关键字来查看sql语句的执行计划。 最左前缀原则主要使用在联合索引中 数据库版本Mysql5.5.53 最左前缀原则mysql建立多列索引（联合索引）有最左前缀的原则，即最左优先，如： 如果有一个2列的索引(col1,col2),则已经对(col1)、(col1,col2)上建立了索引； 如果有一个3列索引(col1,col2,col3)，则已经对(col1)、(col1,col2)、(col1,col2,col3)上建立了索引； 1、b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+树是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道第一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。 2、比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。（这种情况无法用到联合索引） 关于最左前缀的使用，有下面两条说明： 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。 =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式 联合索引有一个最左前缀原则，所以建立联合索引的时候，这个联合索引的字段顺序非常重要 下面写了例子说明这个： CREATE TABLE `test_myisam` ( `id` int(11) NOT NULL AUTO_INCREMENT, `conference_id` varchar(200) NOT NULL, `account` varchar(100) DEFAULT NULL, `status` int(2) DEFAULT NULL COMMENT &apos;0:invite, 1:cancel_invite, 2:decline, 3:connect&apos;, `duration` bigint(20) unsigned DEFAULT NULL, `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`id`) ) ENGINE=myisam AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 以上表结构，我想通过三列进行查询 account ,status,create_time进行查询统计。 如何建立索引？因为我们有可能按照acccount单独统计，或者按照account status，或者是account，status，create_time进行统计，如何建立索引？？？ 下面是建立索引前后的对比600万数据 如何生成：执行如下脚本，account和日期不同还有status不同，分别生成一百万。 CREATE PROCEDURE `add_data_myisam_cp_27`() begin declare v_rows int(10) default 1000000; declare v_count int(10) default 0; id_loop:LOOP insert into test_myisam values(null,round(rand()*1000000000),&apos;cloudp&apos;,round(rand()*3),round(rand()*100000),&apos;2016-07-27 00:00:22&apos;); set v_count= v_count + 1; if v_count&gt;v_rows then leave id_loop; end if; end loop id_loop; end; 测试结果利用建立的索引性能提高了三倍： MariaDB [prf]&gt; select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and date(create_time)=&apos;2016-07-27&apos;; +----------+ | count(1) | +----------+ | 167400 | +----------+ 1 row in set (1.28 sec) MariaDB [prf]&gt; create index as_index on test_myisam(account,status,create_time); Query OK, 6000006 rows affected (31.60 sec) Records: 6000006 Duplicates: 0 Warnings: 0 MariaDB [prf]&gt; select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and date(create_time)=&apos;2016-07-27&apos;; +----------+ | count(1) | +----------+ | 167400 | +----------+ 1 row in set (0.42 sec) MariaDB [prf]&gt; explain select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and date(create_time)=&apos;2016-07-27&apos;; +------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+ | 1 | SIMPLE | test_myisam | ref | as_index | as_index | 308 | const,const | 520216 | Using where; Using index | +------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+ 1 row in set (0.00 sec) 从1.28秒下降到0.42秒但是这个date(create_time)会对每一列都会转换后对比，这里会比较消耗性能； 如何利用上索引？？修改为： MariaDB [prf]&gt; explain select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and date(create_time)=&apos;2016-07-27&apos;; +------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+ | 1 | SIMPLE | test_myisam | ref | as_index | as_index | 308 | const,const | 520216 | Using where; Using index | +------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+ 1 row in set (0.00 sec) MariaDB [prf]&gt; select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and create_time between &apos;2016-07-27&apos; and &apos;2016-07-28&apos;; +----------+ | count(1) | +----------+ | 167400 | +----------+ 1 row in set (0.15 sec) MariaDB [prf]&gt; explain select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and create_time between &apos;2016-07-27&apos; and &apos;2016-07-28&apos;; +------+-------------+-------------+-------+---------------+----------+---------+------+--------+--------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +------+-------------+-------------+-------+---------------+----------+---------+------+--------+--------------------------+ | 1 | SIMPLE | test_myisam | range | as_index | as_index | 312 | NULL | 174152 | Using where; Using index | +------+-------------+-------------+-------+---------------+----------+---------+------+--------+--------------------------+ 1 row in set (0.00 sec) 如上效率又提高了三倍，是因为扫描的数据行数减少了，最后一个create_time如果不用索引需要扫描52016行，如果使用了索引扫描174152行，命中的行数为：167400行，命中率非常高了。 这里有个疑问： 如果按照天进行统计，create_time作为联合索引的第一列，如何使用上这个索引呢？？？？ 至今没有想清楚，如果这一列是date类型可以直接用上索引，如果在oracle中可以date(create_time)建立函数式索引。但是mysql貌似不支持函数式索引。 一个解决方式是： create_time定义为 date类型，在每一列存入的时候，通过触发器自动把这一行修改为date类型。 如果有好的注意欢迎留言探讨，目前没有好的方式加上create_time，可以从业务上解决，就是每天的统计计算完成以后，直接把数据推到历史表中，统计结果单独存放。 最后说一下关于索引失效的问题： 如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)。注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引 对于多列索引，不是使用的第一部分，则不会使用索引（即不符合最左前缀原则） like查询是以%开头 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引 如果mysql估计使用全表扫描要比使用索引快,则不使用索引 此外，查看索引的使用情况 show status like ‘Handler_read%’; handler_read_key:这个值越高越好，越高表示使用索引查询到的次数 handler_read_rnd_next:这个值越高，说明查询低效]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>最佳左前缀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP之PHP-FPM入门]]></title>
    <url>%2F2019%2F02%2F24%2FPHP%E4%B9%8BPHP-FPM%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[PHP-FPMNginx 和 PHP 通信的主要流程为：通过浏览器访问Url后，请求到web服务器，服务器根据配置文件，确定为PHP脚本文件，转发到PHP解析器，PHP解析器会解析php.ini文件初始化执行环境，然后处理请求，再以标准的数据格式返回处理结果，最后退出进程。 通信方式nginx和php-fpm通信有tcp socket和unix socket两种方式： unix socket方式：nginx和php-fpm的进程之间通信，速度快，消耗资源少。而tcp需要经过本地回环驱动，还要申请临时端口和tcp相关资源。 unix socket相比不是那么稳定，当并发连接数爆发时，会产生大量的长时缓存，在没有面向连接协议支撑的情况下，大数据包很有可能就直接出错并不会返回异常。 虽然socket有更少的数据拷贝和上下文切换，更少的资源占用，但是如果数据都是错的，那还有什么用呢。另外使用unix socket的话，必须nginx和fpm在同一台机器上 tcp socket方式：tcp协议能保证数据的正确性，可以跨服务器，当nginx和php-fpm不在同一台机器上时，只能使用这种方式，但性能不如unix socket。 CGICGI（Common Gateway Interface）是服务器与后台语言交互的协议，有了这个协议，开发者可以使用任何语言处理服务器转发过来的请求，动态地生成内容，保证了传递过来的数据是标准格式的,规定了以什么样的格式传哪些数据（URL、查询字符串、POST数据、HTTP header等等），方便了开发者。 PHP-CGIPHP语言对应与服务器交互的CGI程序就是PHP-CGI，标准的CGI程序对每个请求都会执行：PHP解析器解析php.ini文件，初始化执行环境。 CGI程序本身只能解析请求、返回结果，不会进程管理，所以有一个致命的缺点，那就是每处理一个请求都需要fork一个全新的进程，随着Web的兴起，高并发越来越成为常态，这样低效的方式明显不能满足需求，每一次web请求都会有启动和退出进程，也就是最为人诟病的fork-and-execute模式。 FastCGIFastCGI，允许在一个进程内处理多个请求，而不是一个请求处理完毕就直接结束进程，性能上有了很大的提高。 FastCGI会先启一个master进程，解析配置文件，初始化执行环境，然后再启动多个worker进程。当请求过来时，master会传递给一个worker，然后立即可以接受下一个请求，避免了重复创建进程。当worker不够用时，master可以根据配置预先启动几个worker等着。当然空闲worker太多时，也会停掉一些，这样就提高了性能，也节约了资源。 PHP-FPMPHP-FPM（FastCGI Process Manager）是FastCGI协议的一个实现，任何实现了FastCGI协议的服务器都能够与之通信。 FPM是一个PHP进程管理器，包含master和worker两种进程。 master进程只有一个，负责监听端口，接收来自服务器的请求，而worker进程则一般有多个（具体数量根据实际需要配置），每个进程内部都嵌入了一个PHP解释器，是PHP代码真正执行的地方。 从FPM接收到请求，到处理完毕，其具体的流程如下： FPM的master进程接收到请求。 master进程根据配置指派特定的worker进程进行请求处理 如果没有可用进程，返回错误，这也是我们配合Nginx遇到502错误比较多的原因。 worker进程处理请求，如果超时，返回504错误。 请求处理结束，返回结果。 通信Nginx不仅仅是一个Web服务器，也是一个功能强大的Proxy服务器，除了进行http请求的代理，也可以进行许多其他协议请求的代理，包括与FPM相关的FastCGI协议。 为了能够使Nginx理解FastCGI协议，Nginx提供了FastCGI模块来将http请求映射为对应的FastCGI请求。 Nginx的FastCGI模块提供了fastcgi_param指令来主要处理这些映射关系，/usr/local/nginx/conf/fastcgi.conf 是Nginx的一个配置文件实例，其主要完成的工作是将Nginx中的变量翻译成PHP中能够理解的变量。 除此之外，非常重要的就是fastcgi_pass指令了，这个指令用于指定FPM进程监听的地址，Nginx会把所有的PHP请求翻译成FastCGI请求之后再发送到这个地址。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高并发大流解决量方案]]></title>
    <url>%2F2019%2F02%2F17%2F%E9%AB%98%E5%B9%B6%E5%8F%91%E5%A4%A7%E6%B5%81%E8%A7%A3%E5%86%B3%E9%87%8F%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[一、概念 QPS:每秒钟请求或者查询的数量，通常是指每秒相应请求数（http） QPS不等于并发连接数，QPS是每秒的HTTP请求数量，并发连接数是指系统同时处理的请求数量 峰值的每秒请求数（QPS）= (总PV数 80%)/(6小时秒数 20%) 峰值QPS的计算规律主要是80%的访问量集中在20%的访问时间 吞吐量：单位时间内处理请求的数量 响应时间：从请求发出到收到响应花费的时间 PV(page view)综合浏览量，即页面点击数。通常日PV在千万级就是高并发的网站 UV(unique visitor)独立访客，一定时间内相同访客访问网站，只计算为1个独立访客 带宽：计算带宽大小，我们需要关注两个指标，峰值流量和平均大小 日网站的带宽 = PV/统计时间（秒） 平均页面大小（KB） 8 压力测试 1.测试能承受的最大并发 2.测试最大承受QPS值 ab(apache benchmark)工具使用:ab会创建多个并发访问线程，模拟多个访问者同时对一个URL地址进行访问。 12345ab的基本使用ab -c 100 -n 5000 url并发请求100次，总共5000次测试时注意被测试机器的CPU、内存、网络都不超过最高限度的75% 此处介绍一些QPS的数值： 50：小型网站，一般服务器即可应付 100：假设数据库每次请求都在0.01秒内完成，单个页面只有一个sql，100QPS意味着1秒钟要完成100次请求，但是我们数据库不一定能完成100次查询。此时优化方案为：数据库缓存、数据库负载均衡 800：假设网站有百兆带宽，意味着实际出口的带宽为8M左右，如果每个页面只有10K，在这个QPS下，带宽已经吃完。此时的方案：CDN加速，负载均衡 1000： 假设使用nosql来缓存数据库查询（memcache或redis），每个页面对nosql的请求远大于直接对DB的请求 2000： 业务分离，做分布式存储 二、优化方案 流量优化： 防盗链处理 减少前端http请求（合并css、js等静态资源） 添加异步请求，减少http请求的并发量 启用浏览器的缓存和使用文件压缩 CDN加速，减轻服务器压力和带宽压力 服务端优化 页面静态化 并发处理 数据库优化 数据库缓存 分库分表，分区操作 读写分离 负载均衡 web服务器优化 负载均衡]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解PHP之：Nginx 与 FPM 的工作机制]]></title>
    <url>%2F2019%2F02%2F15%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E4%B9%8B%EF%BC%9ANginx-%E4%B8%8E-FPM-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[概述网络上有很多关于如何配置 Nginx + FPM 的文章，但它们更多从操作的角度出发，告诉我们怎么做，但却没有告诉我们为什么要这么做，本文从 Nginx 与 FPM 的工作机制出发，探讨配置背后的原理，让我们真正理解 Nginx 与 PHP 是如何协同工作的。 内容：要说 Nginx 与 PHP 是如何协同工作的，首先得说 CGI (Common Gateway Interface) 和 FastCGI 这两个协议。 CGI 是 Web Server 与后台语言交互的协议，有了这个协议，开发者可以使用任何语言处理 Web Server 发来的请求，动态的生成内容。但 CGI 有一个致命的缺点，那就是每处理一个请求都需要 fork 一个全新的进程，随着 Web 的兴起，高并发越来越成为常态，这样低效的方式明显不能满足需求。就这样，FastCGI 诞生了，CGI 很快就退出了历史的舞台。FastCGI，顾名思义为更快的 CGI，它允许在一个进程内处理多个请求，而不是一个请求处理完毕就直接结束进程，性能上有了很大的提高。 FPM (FastCGI Process Manager)，它是 FastCGI 的实现，任何实现了 FastCGI 协议的 Web Server 都能够与之通信。FPM 之于标准的 FastCGI，也提供了一些增强功能，具体可以参考官方文档：PHP: FPM Installation。 FPM 是一个 PHP 进程管理器，包含 master 进程和 worker 进程两种进程：master 进程只有一个，负责监听端口，接收来自 Web Server 的请求，而 worker 进程则一般有多个 (具体数量根据实际需要配置)，每个进程内部都嵌入了一个 PHP 解释器，是 PHP 代码真正执行的地方，下图是我本机上 fpm 的进程情况，1一个 master 进程，3个 worker 进程： 从 FPM 接收到请求，到处理完毕，其具体的流程如下： 1. FPM 的 master 进程接收到请求 2. master 进程根据配置指派特定的 worker进程进行请求处理，如果没有可用进程，返回错误，这也是我们配合 Nginx 遇到502错误比较多的原因。 3. worker 进程处理请求，如果超时，返回504错误 4. 请求处理结束，返回结果 FPM 从接收到处理请求的流程就是这样了，那么 Nginx 又是如何发送请求给 fpm 的呢？这就需要从 Nginx 层面来说明了。 Nginx 不仅仅是一个 Web 服务器，也是一个功能强大的 Proxy 服务器，除了进行 http 请求的代理，也可以进行许多其他协议请求的代理，包括本文与 fpm 相关的 fastcgi 协议。为了能够使 Nginx 理解 fastcgi 协议，Nginx 提供了 fastcgi 模块来将 http 请求映射为对应的 fastcgi 请求。 Nginx 的 fastcgi 模块提供了 fastcgi_param 指令来主要处理这些映射关系，下面 Ubuntu 下 Nginx 的一个配置文件，其主要完成的工作是将 Nginx 中的变量翻译成 PHP 中能够理解的变量。 除此之外，非常重要的就是 fastcgi_pass 指令了，这个指令用于指定 fpm 进程监听的地址，Nginx 会把所有的 php 请求翻译成 fastcgi 请求之后再发送到这个地址。下面一个简单的可以工作的 Nginx 配置文件： 在这个配置文件中，我们新建了一个虚拟主机，监听在 80 端口，Web 根目录为 /home/rf/projects/wordpress。然后我们通过 location 指令，将所有的以 .php 结尾的请求都交给 fastcgi 模块处理，从而把所有的 php 请求都交给了 fpm 处理，从而完成 Nginx 到 fpm 的闭环。 如此以来，Nginx 与 FPM 通信的整个流程应该比较清晰了吧。 nginx是web服务器，提供http服务。 php代码需要php解析器解析。所以这里要有个nginx和php解析器通信的问题。就出现了一个fastcgi的协议来解决通信问题。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Nginx</tag>
        <tag>FPM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LVS负载均衡（LVS简介、三种工作模式、十种调度算法）]]></title>
    <url>%2F2019%2F01%2F25%2FLVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%88LVS%E7%AE%80%E4%BB%8B%E3%80%81%E4%B8%89%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E3%80%81%E5%8D%81%E7%A7%8D%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、LVS简介LVS（Linux Virtual Server）即Linux虚拟服务器，是由章文嵩博士主导的开源负载均衡项目，目前LVS已经被集成到Linux内核模块中。 该项目在Linux内核中实现了基于IP的数据请求负载均衡调度方案，终端互联网用户从外部访问公司的外部负载均衡服务器，终端用户的Web请求会发送给LVS调度器，调度器根据自己预设的算法决定将该请求发送给后端的某台Web服务器，比如，轮询算法可以将外部的请求平均分发给后端的所有服务器，终端用户访问LVS调度器虽然会被转发到后端真实的服务器，但如果真实服务器连接的是相同的存储，提供的服务也是相同的服务，最终用户不管是访问哪台真实服务器，得到的服务内容都是一样的，整个集群对用户而言都是透明的。 最后根据LVS工作模式的不同，真实服务器会选择不同的方式将用户需要的数据发送到终端用户，LVS工作模式分为NAT模式、TUN模式、以及DR模式。 二、三种工作模式的解析。1、基于NAT的LVS模式负载均衡 NAT（Network Address Translation）即网络地址转换，其作用是通过数据报头的修改，使得位于企业内部的私有IP地址可以访问外网，以及外部用用户可以访问位于公司内部的私有IP主机。VS/NAT工作模式拓扑结构如图2所示，LVS负载调度器可以使用两块网卡配置不同的IP地址，eth0设置为私钥IP与内部网络通过交换设备相互连接，eth1设备为外网IP与外部网络联通。 第一步，用户通过互联网DNS服务器解析到公司负载均衡设备上面的外网地址，相对于真实服务器而言，LVS外网IP又称VIP（Virtual IP Address），用户通过访问VIP，即可连接后端的真实服务器（Real Server），而这一切对用户而言都是透明的，用户以为自己访问的就是真实服务器，但他并不知道自己访问的VIP仅仅是一个调度器，也不清楚后端的真实服务器到底在哪里、有多少真实服务器。 第二步，用户将请求发送至124.126.147.168，此时LVS将根据预设的算法选择后端的一台真实服务器（192.168.0.1~192.168.0.3），将数据请求包转发给真实服务器，并且在转发之前LVS会修改数据包中的目标地址以及目标端口，目标地址与目标端口将被修改为选出的真实服务器IP地址以及相应的端口。 第三步，真实的服务器将响应数据包返回给LVS调度器，调度器在得到响应的数据包后会将源地址和源端口修改为VIP及调度器相应的端口，修改完成后，由调度器将响应数据包发送回终端用户，另外，由于LVS调度器有一个连接Hash表，该表中会记录连接请求及转发信息，当同一个连接的下一个数据包发送给调度器时，从该Hash表中可以直接找到之前的连接记录，并根据记录信息选出相同的真实服务器及端口信息。 2、基于TUN的LVS负载均衡在LVS（NAT）模式的集群环境中，由于所有的数据请求及响应的数据包都需要经过LVS调度器转发，如果后端服务器的数量大于10台，则调度器就会成为整个集群环境的瓶颈。我们知道，数据请求包往往远小于响应数据包的大小。因为响应数据包中包含有客户需要的具体数据，所以LVS（TUN）的思路就是将请求与响应数据分离，让调度器仅处理数据请求，而让真实服务器响应数据包直接返回给客户端。 VS/TUN工作模式拓扑结构如图3所示。其中，IP隧道（IP tunning）是一种数据包封装技术，它可以将原始数据包封装并添加新的包头（内容包括新的源地址及端口、目标地址及端口），从而实现将一个目标为调度器的VIP地址的数据包封装，通过隧道转发给后端的真实服务器（Real Server），通过将客户端发往调度器的原始数据包封装，并在其基础上添加新的数据包头（修改目标地址为调度器选择出来的真实服务器的IP地址及对应端口），LVS（TUN）模式要求真实服务器可以直接与外部网络连接，真实服务器在收到请求数据包后直接给客户端主机响应数据。 3、基于DR的LVS负载均衡在LVS（TUN）模式下，由于需要在LVS调度器与真实服务器之间创建隧道连接，这同样会增加服务器的负担。与LVS（TUN）类似，DR模式也叫直接路由模式，其体系结构如图4所示，该模式中LVS依然仅承担数据的入站请求以及根据算法选出合理的真实服务器，最终由后端真实服务器负责将响应数据包发送返回给客户端。与隧道模式不同的是，直接路由模式（DR模式）要求调度器与后端服务器必须在同一个局域网内，VIP地址需要在调度器与后端所有的服务器间共享，因为最终的真实服务器给客户端回应数据包时需要设置源IP为VIP地址，目标IP为客户端IP，这样客户端访问的是调度器的VIP地址，回应的源地址也依然是该VIP地址（真实服务器上的VIP），客户端是感觉不到后端服务器存在的。由于多台计算机都设置了同样一个VIP地址，所以在直接路由模式中要求调度器的VIP地址是对外可见的，客户端需要将请求数据包发送到调度器主机，而所有的真实服务器的VIP地址必须配置在Non-ARP的网络设备上，也就是该网络设备并不会向外广播自己的MAC及对应的IP地址，真实服务器的VIP对外界是不可见的，但真实服务器却可以接受目标地址VIP的网络请求，并在回应数据包时将源地址设置为该VIP地址。调度器根据算法在选出真实服务器后，在不修改数据报文的情况下，将数据帧的MAC地址修改为选出的真实服务器的MAC地址，通过交换机将该数据帧发给真实服务器。整个过程中，真实服务器的VIP不需要对外界可见。 三、LVS负载均衡调度算法根据前面的介绍，我们了解了LVS的三种工作模式，但不管实际环境中采用的是哪种模式，调度算法进行调度的策略与算法都是LVS的核心技术，LVS在内核中主要实现了一下十种调度算法。 1.轮询调度轮询调度（Round Robin 简称’RR’）算法就是按依次循环的方式将请求调度到不同的服务器上，该算法最大的特点就是实现简单。轮询算法假设所有的服务器处理请求的能力都一样的，调度器会将所有的请求平均分配给每个真实服务器。 2.加权轮询调度加权轮询（Weight Round Robin 简称’WRR’）算法主要是对轮询算法的一种优化与补充，LVS会考虑每台服务器的性能，并给每台服务器添加一个权值，如果服务器A的权值为1，服务器B的权值为2，则调度器调度到服务器B的请求会是服务器A的两倍。权值越高的服务器，处理的请求越多。 3.最小连接调度最小连接调度（Least Connections 简称’LC’）算法是把新的连接请求分配到当前连接数最小的服务器。最小连接调度是一种动态的调度算法，它通过服务器当前活跃的连接数来估计服务器的情况。调度器需要记录各个服务器已建立连接的数目，当一个请求被调度到某台服务器，其连接数加1；当连接中断或者超时，其连接数减1。 （集群系统的真实服务器具有相近的系统性能，采用最小连接调度算法可以比较好地均衡负载。) 4.加权最小连接调度加权最少连接（Weight Least Connections 简称’WLC’）算法是最小连接调度的超集，各个服务器相应的权值表示其处理性能。服务器的缺省权值为1，系统管理员可以动态地设置服务器的权值。加权最小连接调度在调度新连接时尽可能使服务器的已建立连接数和其权值成比例。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。 5.基于局部的最少连接基于局部的最少连接调度（Locality-Based Least Connections 简称’LBLC’）算法是针对请求报文的目标IP地址的 负载均衡调度，目前主要用于Cache集群系统，因为在Cache集群客户请求报文的目标IP地址是变化的。这里假设任何后端服务器都可以处理任一请求，算法的设计目标是在服务器的负载基本平衡情况下，将相同目标IP地址的请求调度到同一台服务器，来提高各台服务器的访问局部性和Cache命中率，从而提升整个集群系统的处理能力。LBLC调度算法先根据请求的目标IP地址找出该目标IP地址最近使用的服务器，若该服务器是可用的且没有超载，将请求发送到该服务器；若服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则使用’最少连接’的原则选出一个可用的服务器，将请求发送到服务器。 6.带复制的基于局部性的最少连接带复制的基于局部性的最少连接（Locality-Based Least Connections with Replication 简称’LBLCR’）算法也是针对目标IP地址的负载均衡，目前主要用于Cache集群系统，它与LBLC算法不同之处是它要维护从一个目标IP地址到一组服务器的映射，而LBLC算法维护从一个目标IP地址到一台服务器的映射。按’最小连接’原则从该服务器组中选出一一台服务器，若服务器没有超载，将请求发送到该服务器；若服务器超载，则按’最小连接’原则从整个集群中选出一台服务器，将该服务器加入到这个服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。 7.目标地址散列调度目标地址散列调度（Destination Hashing 简称’DH’）算法先根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且并未超载，将请求发送到该服务器，否则返回空。 8.源地址散列调度U源地址散列调度（Source Hashing 简称’SH’）算法先根据请求的源IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且并未超载，将请求发送到该服务器，否则返回空。它采用的散列函数与目标地址散列调度算法的相同，它的算法流程与目标地址散列调度算法的基本相似。 9.最短的期望的延迟最短的期望的延迟调度（Shortest Expected Delay 简称’SED’）算法基于WLC算法。举个例子吧，ABC三台服务器的权重分别为1、2、3 。那么如果使用WLC算法的话一个新请求进入时它可能会分给ABC中的任意一个。使用SED算法后会进行一个运算 A：（1+1）/1=2 B：（1+2）/2=3/2 C：（1+3）/3=4/3 就把请求交给得出运算结果最小的服务器。 10.最少队列调度最少队列调度（Never Queue 简称’NQ’）算法，无需队列。如果有realserver的连接数等于0就直接分配过去，不需要在进行SED运算。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP实现跨域解决方法]]></title>
    <url>%2F2019%2F01%2F17%2FPHP%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[PHP实现跨域解决方法如果要实现跨域通过设置Access-Control-Allow-Origin来实现跨域。 例如：客户端的域名是client.runoob.com，而请求的域名是server.runoob.com。 如果直接使用ajax访问，会有以下错误： XMLHttpRequest cannot load http://server.runoob.com/server.php. No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource.Origin &apos;http://client.runoob.com&apos; is therefore not allowed access. 1、允许单个域名访问指定某域名（http://client.runoob.com）跨域访问，则只需在http://server.runoob.com/server.php文件头部添加如下代码： header(&apos;Access-Control-Allow-Origin:http://client.runoob.com&apos;); 2、允许多个域名访问指定多个域名（http://client1.runoob.com、http://client2.runoob.com等）跨域访问，则只需在http://server.runoob.com/server.php文件头部添加如下代码： $origin = isset($_SERVER[&apos;HTTP_ORIGIN&apos;])? $_SERVER[&apos;HTTP_ORIGIN&apos;] : &apos;&apos;; $allow_origin = array( &apos;http://client1.runoob.com&apos;, &apos;http://client2.runoob.com&apos; ); if(in_array($origin, $allow_origin)){ header(&apos;Access-Control-Allow-Origin:&apos;.$origin); } 3、允许所有域名访问允许所有域名访问则只需在http://server.runoob.com/server.php文件头部添加如下代码： header(&apos;Access-Control-Allow-Origin:*&apos;); 总结php解决跨域问题 //需要在使用的方法加上跨域请求 header(&apos;content-type:application:json;charset=utf8&apos;); header(&apos;Access-Control-Allow-Origin:*&apos;); header(&apos;Access-Control-Allow-Methods:POST&apos;); header(&apos;Access-Control-Allow-Headers:x-requested-with,content-type&apos;); 待处理：JSON，代理 。。。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于流量优化方案]]></title>
    <url>%2F2019%2F01%2F11%2F%E5%85%B3%E4%BA%8E%E6%B5%81%E9%87%8F%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[一、防盗链盗链 在自己的页面上展示一些并不在自己服务器上的内容。获取他人服务器上的资源地址，绕过别人的资源展示页面，直接在自己的页面上向用户输出防盗链则是防止别人通过技术手段盗取本站的资源，让不是本站展示的资源链接失效 防盗链原理：通过referer或者签名（在资源地址后面带上一串签名，每次收到请求验证签名），网站可以检测目标访问的来源网页，如果是资源文件，则可以跟踪到他显示的网页地址。一旦检测到来源不是本站则进行组织或者返回指定页面。 实现 Referer 123456789101112131415161718Nginx模块 ngx_http_referer_module 用来阻挡来源非法的域名请求Nginx指令 valid_referers 全局变量$invalid_referervalid_referers none|blocked|server_names|string....;none: referer 来源头部为空blocked: referer不为空，但是里面的值被代理或者防火墙删除了，这些值并不以http：//或者https://开头server_names: referer来源头部包含当前的server_names例如：location ~ .*\.(gif|jpeg|png|flv|swf|rar|zip)$&#123; valid_referer none blocked haobin.com *.haobin.com; if($invalid_referer) &#123; #return 403; rewrite ^/http://www.haobin.com/403.html; &#125;&#125; 如果有人伪造referer，可以通过签名的方法解决 加密签名 通过第三方模块HttpAccessKeyModule实现Nginx防盗链 1234567891011121314首先安装这个模块accesskey on|off 模块开关accesskey_hashmethod md5 | sha-1 指定签名加密方式accesskey_arg GET参数的名称accesskey_signature 加密规则例如：location ~ .*\.(gif|jpeg|png|flv|swf|zip|rar)$&#123; accesskey on; accesskey_hashmethod md5; accesskey_arg &quot;key&quot;; accesskey_signature &quot;sign$remote_addr&quot;;&#125; 二、减少HTTP请求性能黄金法则：只有10%-20%的最终用户响应时间花在接受请求的HTML文档上，剩下的80%-90%时间花在HTML文档所引用的组件（图片、css、script等）进行的http请求上 1.图片地图：允许在一个图片上关联多个url，目标的url选择取决于用户单击了图片上的哪个位置。例如有五张图片，每张图片对应一个超链接。此时就产生了五个http请求，我们将五张图片合成为一张图片，然后以图片的位置定位超链接。 1234567实现&lt;map&gt; &lt;area&gt;&lt;/area&gt; &lt;area&gt;&lt;/area&gt; &lt;area&gt;&lt;/area&gt; ........&lt;/map&gt; 2.CSS Sprites（CSS 精灵）通过使用合并图片，指定css的background-image和background-position来显示元素 12background-position属性background-position:x,y; x和y可以写正值也可以写负值，我们可以想象图片左上方(0,0)，以(0,0)坐标向右的是负数的x轴，以(0,0)坐标向下的是负数的y轴 3.合并脚本和样式表4.图片使用base64编码减少页面请求数 采用Base64编码直接将图片嵌入网页当中 三、浏览器缓存和压缩技术1.HTTP缓存分类 http缓存类型中，请求成功会有三种情况： 200 from cache：直接从本地缓存中获取相应，最快速，最省流量（network的size字段） 304 not modify： 协商缓存，浏览器在没有命中的情况下请求头中发送一定的校验数据到服务端，如果服务端没有改变，浏览器从本地缓存相应，返回304。 该方式，只返回一些基本的头信息，不发送实际的相应体 200 ok： 以上两种缓存失败，服务器返回完整的相应。 该方式没有用到缓存，是最慢的。 2.本地缓存1234567891011Pragma： HTTP1.0的属性，该字段设置为no-cache，会告知浏览器禁用本地缓存Expires: HTTP1.0的属性，用来启用本地缓存。expires的值对应为一个类似Thu, 31 Dec 2017 20:11:20 GMT的格林威治时间，告诉浏览器如果还没有到该时间，则缓存有效，无须发送请求。这个时间是服务器返回的，是以服务器的时间为基准，如果服务器和客户端的时间不一致就可能产生差错。Cache-Control: 告知浏览器缓存过期的时间间隔。no-store: 禁止浏览器缓存no-cache: 不允许直接使用本地缓存，先发起请求和服务器协商max-age=delta-seconds: 告知浏览器响应本地缓存的最长期限，以秒为单位优先级：Pragrma &gt; Cache-Control &gt; Expires 3.协商缓存 浏览器没有命中本地缓存，如果本地缓存过期或者响应不允许直接使用本地缓存，那么浏览器会发起服务端请求，服务端会验证数据是否被修改，如果没有被修改就通知浏览器使用本地缓存 相关的Header： 12345Last-Modified: 通知浏览器资源的最后修改时间（一个格林威治时间）If-Modified-Since: 得到资源最后修改时间后，会将这个If-Modified-Since（Last-Modified的值）提交到服务器做检查，如果没有修改，就返回304ETag: HTTP1.1属性，指纹标识符，如果文件发生更改，指纹会改变If-None_Match: 本地缓存失效，会携带此值（ETage 的值）去请求服务端，服务端判断资源是否改变，如果没有改变，直接使用本地缓存，返回304 4.缓存对象的选择 不变的内容适合本地缓存：图像，js，css，可下载的媒体文件等 适合协商缓存的文件：HTML文件，经常替换的图片，经常修改的js、css等文件 5.Nginx配置缓存策略1234567891011*****通过PHP模拟Last-Modified-&gt;If-Modified-Since模式******// 读取上一次修改时间$since = $_SERVER[&apos;HTTP_IF_MODIFIED-SINCE&apos;];$lifetime = 3600; // 模拟缓存一分钟// 如果没过期就返回304if(strtotime($since) + $lifetiem &gt; time())&#123; header(&apos;HTTP/1.1 304 NOT MODIFIED&apos;); exit;&#125;// 返回Last-Modified相应头header(&apos;Last-Modified: &apos;.gmdate(&apos;D, d M Y H:i:s&apos;, time())). &apos;GMT&apos;); Nginx缓存配置： 本地缓存配置指令： add_header： 添加状态码为2XX和3XX的响应头 add_header name value \[always]; 语法格式 可以通过该指令来设置Pragma/Expires/Cache-Control expires指令： 通知浏览器过期时长 expires time; 语法格式 为负值表示Cache-Control: no-cache 为正直表示Cache-Control:max-age=指定时间 123456789101112Nginx缓存配置：# 遇到图片等资源就缓存30天location ~ .*\.(gif|jpeg|png|flv|swf|zip|rar)$&#123; expires 30d;&#125;$ 遇到js/css等资源就缓存12小时location ~ .*\.(js|css)?$&#123; expires 12h;&#125;# expires max; 代表设置十年的缓存 Nginx协商缓存配置： ETage指令： 指定签名 etage: on|off; 开关，默认是on 12345location ~ .*\.(gif|jpeg|png|flv|swf|zip|rar)$&#123; # 默认是开启的 etag off;&#125; 6.前端代码和资源的压缩 JavaScript压缩：去掉多余的空格和回车，替换长变量名，简写代码等 CSS压缩： 同样是去掉空白符、注释并且优化CSS语义规则 图片压缩： 借助压缩工具压缩（tinypng、jpegMini、imageoption等） Gzip压缩 12345678Nginx配置:gizp on|off; #是否开启gzipgzip_buffers 32 4K|16 8k #缓冲（在内存中有几块 每块多大）gzip_comp_level [1-9] #压缩级别（推荐使用6） 级别越高，压缩越小，越占用CPU资源gzip_disable #正则表达式匹配UA 什么样的uri不进行gzip gzip_min_length 200 #开始压缩的最小长度gzip_http_version 1.0|1.1 #开始压缩的http版本协议gzip_types text/plain application/xml #对那些类型进行压缩，如text、css、html等 现在前端有很多工具可以对资源进行压缩，打包等。如grunt、webpack等已经很流行了。比较流行的前端框架也有相应的脚手架来帮助打包：vue-cli、angular-cli等]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>流量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP高并发下单解决方案]]></title>
    <url>%2F2019%2F01%2F06%2FPHP%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E5%8D%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[目录 1、使用文件锁 2、使用消息队列 3、如果是分布式集群服务器，就需要一个或多个队列服务器 4、使用Memcache锁 1、使用文件锁&lt;?php $fp = fopen(&quot;order.lock&quot;, &quot;r&quot;); if(flock($fp,LOCK_EX)){ //..处理订单的代码 flock($fp,LOCK_UN); } fclose($fp); ?&gt; 2、使用消息队列可以基于例如MemcacheQ等这样的消息队列。 比如有100张票可供用户抢，那么就可以把这100张票放到缓存中，读写时不要加锁。 当并发量大的时候，可能有500人左右抢票成功，这样对于500后面的请求可以直接转到活动结束的静态页面。进去的500个人中有400个人是不可能获得商品的。所以可以根据进入队列的先后顺序只能前100个人购买成功。后面400个人就直接转到活动结束页面。当然进去500个人只是举个例子，至于多少可以自己调整。而活动结束页面一定要用静态页面，不要用数据库。这样就减轻了数据库的压力。 3、如果是分布式集群服务器，就需要一个或多个队列服务器小米和淘宝的抢购还是有稍许不同的，小米重在抢的那瞬间，抢到了名额，就是你的，你就可以下单结算。而淘宝则重在付款的时候的过滤，做了多层过滤，比如要卖10件商品，他会让大于10的用户抢到，在付款的时候再进行并发过滤，一层层的减少一瞬间的并发量。 4、使用Memcache锁product_key 为票的key product_lock_key 为票锁key 当product_key存在于memcached中时，所有用户都可以进入下单流程。 当进入支付流程时，首先往memcached存放add(product_lock_key, “1″),如果返回成功，进入支付流程。如果不成，则说明已经有人进入支付流程，则线程等待N秒，递归执行add操作。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分区、分表、分库、分片入门]]></title>
    <url>%2F2018%2F12%2F23%2F%E5%88%86%E5%8C%BA%E3%80%81%E5%88%86%E8%A1%A8%E3%80%81%E5%88%86%E5%BA%93%E3%80%81%E5%88%86%E7%89%87%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[一、分区的概念数据分区是一种物理数据库的设计技术，它的目的是为了在特定的SQL操作中减少数据读写的总量以缩减响应时间。 分区并不是生成新的数据表，而是将表的数据均衡分摊到不同的硬盘，系统或是不同服务器存储介子中，实际上还是一张表。另外，分区可以做到将表的数据均衡到不同的地方，提高数据检索的效率，降低数据库的频繁IO压力值，分区的优点如下： 1、相对于单个文件系统或是硬盘，分区可以存储更多的数据； 2、数据管理比较方便，比如要清理或废弃某年的数据，就可以直接删除该日期的分区数据即可； 3、精准定位分区查询数据，不需要全表扫描查询，大大提高数据检索效率； 4、可跨多个分区磁盘查询，来提高查询的吞吐量； 5、在涉及聚合函数查询时，可以很容易进行数据的合并； 二、分类 （row 行 ，column 列） 1、水平分区 这种形式分区是对表的行进行分区，通过这样的方式不同分组里面的物理列分割的数据集得以组合，从而进行个体分割（单分区）或集体分割（1个或多个分区）。所有在表中定义的列在每个数据集中都能找到，所以表的特性依然得以保持。 举个简单例子：一个包含十年发票记录的表可以被分区为十个不同的分区，每个分区包含的是其中一年的记录。（朋奕注：这里具体使用的分区方式我们后面再说，可以先说一点，一定要通过某个属性列来分割，譬如这里使用的列就是年份） 2、垂直分区 这种分区方式一般来说是通过对表的垂直划分来减少目标表的宽度，使某些特定的列被划分到特定的分区，每个分区都包含了其中的列所对应的行。 举个简单例子：一个包含了大text和BLOB列的表，这些text和BLOB列又不经常被访问，这时候就要把这些不经常使用的text和BLOB了划分到另一个分区，在保证它们数据相关性的同时还能提高访问速度。 在数据库供应商开始在他们的数据库引擎中建立分区（主要是水平分区）时，DBA和建模者必须设计好表的物理分区结构，不要保存冗余的数据（不同表中同时都包含父表中的数据）或相互联结成一个逻辑父对象（通常是视图）。这种做法会使水平分区的大部分功能失效，有时候也会对垂直分区产生影响。 三、分片、分区、分表、分库的详细理解一、什么是分片、分区、分表、分库 分片 当数据库数据达到上亿级别时，数据库压力会很大，存不下，可以考虑使用数据库分片。 分区 就是把一张表的数据分成N个区块，在逻辑上看最终只是一张表，但底层是由N个物理区块组成的 分表 就是把一张表按一定的规则分解成N个具有独立存储空间的实体表。系统读写时需要根据定义好的规则得到对应的字表明，然后操作它。 分库 一旦分表，一个库中的表会越来越多 将整个数据库比作图书馆，一张表就是一本书。当要在一本书中查找某项内容时，如果不分章节，查找的效率将会下降。而同理，在数据库中就是分区。 常用的单机数据库的瓶颈 问题描述 单个表数据量越大，读写锁，插入操作重新建立索引效率越低。 单个库数据量太大（一个数据库数据量到1T-2T就是极限） 单个数据库服务器压力过大 读写速度遇到瓶颈（并发量几百） 二、分片不同的表放到不同的 数据库中—垂直切割。 数据量小，查询性能会提高。 不同数据库位于不同服务器上时，会减小服务器压力。 单张表数据量也很大，如用户量大产生操作量也会很大。单独查询时，压力也会很大。此时垂直分割也无济于事。可以考虑–水平分割。 一张表放到不同数据库中。用户表，放到不同数据库，每个数据库存储部分数据，单表数据量不大。 三、分区什么时候考虑使用分区？ 一张表的查询速度已经慢到影响使用的时候。 sql经过优化 数据量大 表中的数据是分段的 对数据的操作往往只涉及一部分数据，而不是所有的数据 分区解决的问题​ ​ 主要可以提升查询效率 分区的实现方式（简单）mysql5 开始支持分区功能 CREATE TABLE sales ( id INT AUTO_INCREMENT, amount DOUBLE NOT NULL, order_day DATETIME NOT NULL, PRIMARY KEY(id, order_day) ) ENGINE=Innodb PARTITION BY RANGE(YEAR(order_day)) ( PARTITION p_2010 VALUES LESS THAN (2010), PARTITION p_2011 VALUES LESS THAN (2011), PARTITION p_2012 VALUES LESS THAN (2012), PARTITION p_catchall VALUES LESS THAN MAXVALUE); MySQL5.1提供的分区(Partition)功能确实可以实现表的分区，但是这种分区是局限在单个数据库范围里的，它不能跨越服务器的限制。 如果能够保证数据量很难超过现有数据库服务器的物理承载量，那么只需利用MySQL5.1提供的分区(Partition)功能来改善数据库性能即可；否则，还是考虑应用Sharding理念吧，spider storage engine就是一个不错的选择。 Sharding与数据库分区(Partition)的区别 有的时候，Sharding 也被近似等同于水平分区(Horizontal Partitioning)，网上很多地方也用水平分区来指代 Sharding，但我个人认为二者之间实际上还是有区别的。的确，Sharding 的思想是从分区的思想而来，但数据库分区基本上是数据对象级别的处理，比如表和索引的分区，每个子数据集上能够有不同的物理存储属性，还是单个数据库范围内的操作，而 Sharding 是能够跨数据库，甚至跨越物理机器的。 四、分表什么时候考虑分表？ 一张表的查询速度已经慢到影响使用的时候。 sql经过优化 数据量大 当频繁插入或者联合查询时，速度变慢 分表解决的问题分表后，单表的并发能力提高了，磁盘I/O性能也提高了，写操作效率提高了 查询一次的时间短了 数据分布在不同的文件，磁盘I/O性能提高 读写锁影响的数据量变小 插入数据库需要重新建立索引的数据减少 分表的实现方式（复杂）​ 需要业务系统配合迁移升级，工作量较大 #####分区和分表的区别与联系 分区和分表的目的都是减少数据库的负担，提高表的增删改查效率。 分区只是一张表中的数据的存储位置发生改变，分表是将一张表分成多张表。 当访问量大，且表数据比较大时，两种方式可以互相配合使用。 当访问量不大，但表数据比较多时，可以只进行分区。 常见分区分表的规则策略（类似） Range（范围） Hash（哈希） List（链表） 按照时间拆分 Hash之后按照分表个数取模 在认证库中保存数据库配置，就是建立一个DB，这个DB单独保存user_id到DB的映射关系 五、分库什么时候考虑使用分库？ 单台DB的存储空间不够 随着查询量的增加单台数据库服务器已经没办法支撑 分库解决的问题​ 其主要目的是为突破单节点数据库服务器的 I/O 能力限制，解决数据库扩展性问题。 垂直拆分将系统中不存在关联关系或者需要join的表可以放在不同的数据库不同的服务器中。 按照业务垂直划分。比如：可以按照业务分为资金、会员、订单三个数据库。 需要解决的问题：跨数据库的事务、jion查询等问题。 水平拆分例如，大部分的站点。数据都是和用户有关，那么可以根据用户，将数据按照用户水平拆分。 按照规则划分，一般水平分库是在垂直分库之后的。比如每天处理的订单数量是海量的，可以按照一定的规则水平划分。需要解决的问题：数据路由、组装。 读写分离对于时效性不高的数据，可以通过读写分离缓解数据库压力。需要解决的问题：在业务上区分哪些业务上是允许一定时间延迟的，以及数据同步问题。 思路 垂直分库–&gt;水平分库–&gt;读写分离 六、拆分之后面临新的问题问题 事务的支持，分库分表，就变成了分布式事务 join时跨库，跨表的问题 分库分表，读写分离使用了分布式，分布式为了保证强一致性，必然带来延迟，导致性能降低，系统的复杂度变高。 常用的解决方案：对于不同的方式之间没有严格的界限，特点不同，侧重点不同。需要根据实际情况，结合每种方式的特点来进行处理。 选用第三方的数据库中间件（Atlas，Mycat，TDDL，DRDS），同时业务系统需要配合数据存储的升级。 七、数据存储的演进单库单表单库单表是最常见的数据库设计，例如，有一张用户(user)表放在数据库db中，所有的用户都可以在db库中的user表中查到。 单库多表随着用户数量的增加，user表的数据量会越来越大，当数据量达到一定程度的时候对user表的查询会渐渐的变慢，从而影响整个DB的性能。如果使用mysql, 还有一个更严重的问题是，当需要添加一列的时候，mysql会锁表，期间所有的读写操作只能等待。 可以通过某种方式将user进行水平的切分，产生两个表结构完全一样的user_0000,user_0001等表，user_0000 + user_0001 + …的数据刚好是一份完整的数据。 多库多表随着数据量增加也许单台DB的存储空间不够，随着查询量的增加单台数据库服务器已经没办法支撑。这个时候可以再对数据库进行水平拆分。 八、总结总的来说，优先考虑分区。当分区不能满足需求时，开始考虑分表，合理的分表对效率的提升会优于分区。 基础数据存储Mysql：只存储非文本的基础信息。包括：评论状态，用户，时间等基础数据。以及图片，标签，点赞等附加信息。数据组织形式（不同的数据又可选择不同的库表拆分方案）： 评论基础数据按用户ID进行拆库并拆表 图片及标签处于同一数据库下，根据商品编号分别进行拆表 其它的扩展信息数据，因数据量不大、访问量不高，处理于同一库下且不做分表即可 文本存储文本存储（评论的内容）使用了mongodb、hbase 选择nosql而非mysql 减轻了mysql存储压力，释放msyql，庞大的存储也有了可靠的保障 nosql的高性能读写大大提升了系统的吞吐量并降低了延迟]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>拓展</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP框架之Laravel&ThinkPHP对比]]></title>
    <url>%2F2018%2F12%2F16%2FPHP%E6%A1%86%E6%9E%B6%E4%B9%8BLaravel-ThinkPHP%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[TP框架：ThinkPhp简单、快速，基于MVC和面向对象，易用性较高，是一款简洁实用的轻量级框架。 Laravel框架：Lavavel一直秉承着优雅的原则，很好的支持了composer，实现了更丰富的扩展，社区文档活跃，相较于TP，Lavavel更庞大，安全性也更高，更适合开发大中型项目，被称为“巨匠型开发框架”。 区别： 1、提交数据的方式，Laravel在提交表单时需要在表单中加入csrf_field加大括号来防止跨域攻击，而TP不会。 2、路由，Laravel必须先定义，再使用，路由文件为routes.php，TP在配置文件中开启路由后，路由格式是：’路由表达式’ =&gt; ‘路由地址和参数’（使用路由的前提是URL支持phthinfo并且开启路由），路由可以使URL更符合SEO。 3、中间件，Laravel的中间件，中间件就是HTTP请求到达之前经过的层，通过中间件我们可以验证用户是否登录等一些通用操作。 4、操作数据库方式，都可以使用实例化（建立相对应的模型类）和DB:table(‘表名’)来操作数据库，使用原生查询时不太相同，Laravel使用Db::操作(‘原生sql’)，TP使用Db::query(‘原生sql’)； 5、Laravel升级十分简易，而TP大版本的升级要重构代码。 第一主要区别:(thinkPHP更适合国人的编码习惯) 渲染模版方式的不同: 在Laravel框架里,使用return view()来渲染模版; 而ThinkPHP里则使用了$this-&gt;display()的方式渲染模版; 在Laravel框架里,由于其考虑到了跨站请求伪造, 所以如果使用form表单以post方式进行传值时,如果不再form表单中加入{{ }} //里面放 csrf_field加（）则会报出TokenMethodnotfound的语法错误; 而TP框架则需要自己手动完成防止跨站攻击的代码; Laravel是一个重路由的框架(5.4),所有的功能都是由路由发起的,哪怕没有控制器方法,只要写了路由就能够访问,thinkPHP(3.2),必须要有控制器方法才能正常访问; laravel具有强大的社区化扩展，（composer扩展自动加载）; laravel具有强大的Blade模版引擎; 中间件，Laravel特点，可以实现访问前后的处理，例如请求和返回，权限认证等; 条件判断语句书写方式的差异: Laravel框架里 if else判断语句和foreach语句 书写时必须以@if开头 以@endif结尾,如果没有则报语法错误,@foreach @endforeach同理; 而TP框架则和PHP语法规则使用方式一致直接ifesle语句判断和foreach循环遍历 Laravel里内置了大量的方法供开发者使用,在实际应用中更接近于”让对象完成一切”的开发思想,比如在后台表单验证的时候,Laravel内置了大量的验证方法,例如对用户名的验证:我们使用可以validate方法里’username’=&gt;’required’(不能为空)|alpha_dash(必须数字字母下划线)|between:6,18(在多少位数之间);还内置了例如email;same:字段名;diff:字段名等大量的方法极大的提高了开发速度; 加密方式 在TP框架中 我们对用户名密码进行加密时使用md5();的方式进行加密,但md5的缺点在于其可以逆向破解,而且在同等规则下同样的密码md5加密出的字符串是有可能出现相同的,这就降低其安全性; Laravel框架中内置了”哈希”Hash加密单向加密方法,且同样的参数加密出的字符串是绝对不会出现相同的情况 这就提高了安全性; 在实际开发中我们常常遇到这样的问题,就是开发地点不固定,这就造成了我们需要频繁的更改数据库配置,给开发工作造成了麻烦,TP依然没有避免这个”灾难”;在laravel框架中,.env环境文件的出现解决了这个麻烦,我们只需要在不同的工作地点配置好.env文件就不必再进行配置,因为无论是git还是svn “ .env是不会随着文件一起提交到服务器的”;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP模板引擎之Blade简介]]></title>
    <url>%2F2018%2F12%2F16%2FPHP%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E4%B9%8BBlade%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[laravel的模版引擎采用了blade模版引擎，下面这篇文章主要给大家介绍了关于Laravel中Blade模板引擎的相关资料，文中通过示例代码介绍的非常详细，对大家的学习或者工作具有一定的参考学习价值，需要的朋友们下面随着小编来一起学习学习吧。 前言本文主要给大家介绍了关于Laravel中Blade模板引擎的相关内容，分享出来供大家参考学习，话不多说了，来一起看看详细的介绍吧。 Blade 模板引擎Blade 是 laravel 提供的一个简单强大的模板引擎，它是把 Blade 视图编译成原生的 PHP 代码并缓存起来。缓存会在 Blade 视图改变时而改变，这意味着 Blade 并没有给你的应用添加编译的负担。Blade 视图文件使用 .blade.php 后缀，一般都存储在 resources/views 目录下。 模板继承先来看个例子 ​ &lt;html&gt; &lt;head&gt; &lt;title&gt;App Name - @yield(&apos;title&apos;)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; @section(&apos;sidebar&apos;) This is the master sidebar. @show ​​ @yield(&apos;content&apos;) &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; Blade 模板文件包含了典型的 HTML 标记。你肯定看到了 @section 和 @yield 指令。@section 指令就如它的名字所暗示的那样定义了一个内容区块，而 @yield 指令是用来显示所提供的挂件区块所包含的内容。我们已经定义好了一个基本的布局，接下来我们可以使用 Blade 的 @extends 指令来明确的指定继承这个布局。然后使用 @section 指令将挂件中的内容挂载到布局中，在上面的例子中，挂件的内容将被挂载到布局中的 @yield 部分： ​ @extends(&apos;layouts.master&apos;) ​​ @section(‘title’, ‘Page Title’) ​​ @section(‘sidebar’) @parent ​​ This is appended to the master sidebar. @endsection ​​ @section(‘content’) &lt;p&gt;This is my body content.&lt;/p&gt; @endsection 在上面的例子作用 sidebar 挂件利用 @parent 指令来追加布局中的 sidebar 部分的内容，如果不使用则会覆盖掉布局中的这部分。@parent 指令会在视图被渲染时替换为布局中的内容。 Blade 视图可以像原生 PHP 视图一样使用全局帮助函数 view 来返回渲染后的内容： ​ Route::get(‘blade’, function () { return view(&apos;child&apos;); }); 显示数据你可以使用花括号 { 来在视图中显示传递到视图中的变量，例如，你定义了下面的路由： ​ Route::get(‘greeting’, function () { return view(&apos;welcome&apos;, [&apos;name&apos; =&gt; &apos;Duicode&apos;]); }) 你可以在视图中这样来输出 name 变量的内容： ​ Hello, {{ $name }} 当然，你也可以从原生 PHP 方法中返回内容。事实上，你可以在 Blade echo 声明中使用任意的 PHP 代码：(Blade {{}} 声明中的内容是自动通过 htmlentities 方法过滤的，用来防止 XSS 攻击。) ​ The current UNIX timestamp is {{ time() }} 由于很多 JavaScript 框架都使用花括号来表明所提供的表达式应该被显示在浏览器中。所以你可以使用 @ 符号来告诉 Blade 渲染引擎你需要这个表达式原样保留： ​ Hello, @{{ name }} 我们常用三目运算符来赋值 ​ {{ isset($name) ? $name : ‘Default’ }} Blade 提供了一个便捷的方式来替换这个三元声明： ​ {{ $name or ‘Default’ }} 默认Blade {{}} 声明会自动的使用 htmlentities 方法来避免 XSS 攻击。如果你不想你的数据被转义，你可以使用下面的语法，但是要注意，小心被攻击： ​ Hello, {!! $name !!} 控制结构你可以通过 @if,@elseif,@else和 @endif 指令来使用 if 控制结构 : ​ @if (count($records) === 1) I have one record! @elseif (count($records) &gt; 1) I have multiple records! @else I don&apos;t have any records! @endif 当然为了方便，Blade 也提供了替代指令 @unless 指令： ​ @unless (Auth::check()) You are not signed in. @endunless 也可以使用 @hasSection 指令来判断提供给布局的挂件是否包含了内容: ​ @hasSection(&apos;title&apos;) @yield(&apos;title&apos;) - App Name @else App Name @endif &lt;/title&gt; 说到控制少不了循环结构，类似PHP的： ​ @for ($i = 0; $i &lt; 10; $i++) The current value is `{`{ $i }`}` @endfor ​​ @foreach ($users as $user) &lt;p&gt;This is user `{`{ $user-&gt;id }`}`&lt;/p&gt; @endforeach ​​ @forelse ($users as $user) &lt;li&gt;`{`{ $user-&gt;name }`}`&lt;/li&gt; @empty &lt;p&gt;No users&lt;/p&gt; @endforelse ​​ @while (true) &lt;p&gt;I&apos;m looping forever.&lt;/p&gt; @endwhile Blade 也提供了终止迭代或取消当前迭代的指令： ​ @foreach ($users as $user) @if($user-&gt;type == 1) @continue @endif ​​ {{ $user-&gt;name }} ​​ @if($user-&gt;number == 5) @break @endif @endforeach 你也可以使用指令声明包含条件的方式来达到中断: ​ @foreach ($users as $user) @continue($user-&gt;type == 1) ​​ {{ $user-&gt;name }} ​​ @break($user-&gt;number == 5) @endforeach 包含子视图可以使用 @include 指令来包含一个视图的内容，当前视图中的变量也会被共享给子视图： ​ @include(&apos;shared.errors&apos;) ​​ &lt;!-- Form Contents --&gt; &lt;/form&gt; &lt;/p&gt; 尽管子视图会自动继承父视图中的所有数据变量，你也可以直接传递一个数组变量来添加额外的变量到子视图(在 Blade 视图中避免使用 DIR 和 FILE 常量，因为它们会解析为视图缓存所在的位置)： ​ @include(‘view.name’, [‘some’ =&gt; ‘data’]) 你可以使用 Blade 的 @each 指令来在一行中合并引入多个视图: ​ @each(‘view.name’, $jobs, ‘job’) 第一个参数是数组或集合中每个元素需要被渲染的视图名称。 第二个参数是一个数组或集合，被用来提供迭代。 第三个参数是要分配给当前视图的变量名。 你也可以传递第四个参数到 @each 指令。如果所提供的数组是空数组的话，该参数所提供的视图将会被引入。 ​ @each(‘view.name’, $jobs, ‘job’, ‘view.empty’) Blade 中的注释，这样写不会被渲染： `{`{-- This comment will not be present in the rendered HTML --}`}` Blade 允许你在已命名的堆中压入内容： ​ @push(‘scripts’) &lt;script src=&quot;/example.js&quot;&gt;&lt;/script&gt; @endpush 你可以在你需要的时候压入相同的堆任意的次数,你需要在布局中使用 @stack 来渲染堆: ​ &lt;!-- Head Contents --&gt; @stack(&apos;scripts&apos;) &lt;/head&gt; 可以使用 @inject 指令来从服务容器中取回服务： ​ @inject(‘metrics’, ‘App\Services\MetricsService’) &lt;p&gt; Monthly Revenue: `{`{ $metrice-&gt;monthlyRevenue() }`}` &lt;/p&gt; 第一个参数将作为所取回服务存放的变量名， 第二个参数是你想要在服务容器中取回的类或接口名称。 可以使用 directvie 方法来注册指令。当 Blade 编译器遇到该指令时，它会自动的调用该指令注册时提供的回调函数并传递它的参数。 下面的例子创建了 @datetime($val) 指令来格式化 $val: ​ &lt;?php namespace App\Providers; ​​ use Blade; use Illuminate\Support\ServiceProvider; ​​ class AppServiceProvider extends ServiceProvider{ /** * Perform post-registration booting of services. * * @return void */ public function boot(){ Blade::directive(&apos;datetime&apos;, function ($expression) { return &quot;&lt;?php echo with{$express}-&gt;format(&apos;m/d/Y H:i&apos;); ?&gt;&quot;; }); } ​​ /** * Register bindings in the container * * @return void */ public function register() { // } } 上面的例子中使用了 Laravel 的 with 帮助方法，它只是简单的返回一个所提供的对象或值，并提供方便的链式调用。最终该指令生成的 PHP 代码如下： ​ &lt;?php echo with($var)-&gt;format(‘m/d/Y H:i’); ?&gt; 在你更新 Blade 指令的逻辑之后，你应该删除所有已缓存的 Blade 视图，你可以使用 view:clear Artisan 命令来清除]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP模板引擎之Smarty简介]]></title>
    <url>%2F2018%2F12%2F16%2FPHP%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E4%B9%8BSmarty%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[##Smarty模板引擎技术 什么是模板引擎？ 什么是Smarty模板引擎？ 为何选择Smarty模板引擎？ 如何使用Smarty模板引擎？ 模板引擎概述1、什么是模板引擎模板引擎，是指利用某种模板语言将页面制成模板，再依据业务逻辑将该模板语言翻译成业务数据，从而生成最终展示页面。其目的就是要把页面（HTML）与业务数据(PHP)实现彻底分离。（模板引擎可以将我们php项目的前端和后端的开发分离）。 业界主流的开源cms中对模板引擎的使用是很广泛的，如业界知名cms：dedecms，discuz，phpcms,echop等。 2、感受模板引擎通过在html中使用标签的方式，就可以达到不用修改php 代码情况下，完成制作一个网站。 那么？这样的原理是怎么样的？ 3、模板引擎核心原理所有的模板引擎底层实现都是基于这个原理实现，不管他有多强大多复杂，最基本的核心实现思路都是一致的。 4、封装模板引擎为什么要封装？为了实现代码的重用，以更优雅的方式组织代码。 Smarty模板引擎1、什么是Smarty模板引擎Smarty是一个基于PHP开发的PHP模板引·擎。它提供了逻辑与外在内容的分离。（实现了php项目的前端和后台开发的分离） 一个叫名字叫做Smarty，且使用php编写的模板引擎。 2、如何获取Smarty模板引擎Smarty官网： http://www.smarty.net/ 3、lib目录详解Plugings 拓展插件目录 Sysplugins Smarty系统插件目录 AutoLoader.php 自动载入类 Debug.tpl Smarty提示信息模板 Smarty.class.php Smarty3.0入口文件（兼容2.0） SmartyBC.class.php Smarty2.0入口文件 ​ 4、为什么要选择Smarty模板引擎从技术背景角度来说：Smarty是由php官方开发团队开发和维护。 速度 相对于其他模板引擎，Smarty模板引擎的执行效率更高。 编译型 第一次访问项目，Smarty模板引擎会生成一个编译文件，第二次访问时会判断项目的模板文件是否被修改，如果没有修改，就执行编译文件。 缓存技术 当项目的缓存文件在生命周期内，那么Smarty在执行的时候会直接执行缓存文件 插件技术：当Smarty内部功能不够使用的时候，允许开发者自定义拓展插件 语句自由 if/elseif/else/endif：标签语法很简单。 编译速度 &lt; 缓存速度 &lt; 静态化 什么情况下使用Smarty模板引擎?那么什么情况下使用Smarty引擎不好？ 在数据不常更新修改，非实时更新的项目可以使用Smarty模板引擎：管理系统，内容管理系统等在数据实时更新的项目中使用不好：金融类型项目，数据时时更新类项目。 ​ 5、部署Smarty四步走 第一步：复制lib目录至虚拟主机目录 第二步：修改lib文件夹名为Smarty 第三步：创建templates文件夹 第四步：创建templates_c文件夹 6、使用Smarty模板引擎七步走 第一步：在虚拟主机目录下创建一个index.php文件 第二步：在index.php文件中引入 第三步：Smarty类并实例化 第四步：在templates文件中创建一个index.html文件 第五步：在index.php文件中使用assign方法配置变量 第六步：在index.php文件夹中使用display方法加载模板 第七步：在index.html模板文件中编写Smarty标签 7、Smarty模板引擎的执行原理我们访问了index.php，通过在index.php文件中分配的变量，在html中显示出来。 那么这中间发生了什么？ 当第一次访问index.php的时候，Smarty模板引擎会自动在templates_c文件夹中创建一个display()方法所指定的模板的缓存文件。 当第二次访问index.php的时候，会判断display()方法指定的模板文件是否被修改，如果被修改了，则重新生成这个模板文件的编译文件，如果没有被修改则直接执行这个编译文件 Smarty中常用的属性与方法常用属性 &lt;?php include &quot;Smarty/Smarty.class.php&quot;; //实例化SMarty类 $Smarty = new Smarty(); $name = &apos;我是小明&apos;; $PHP = &apos;PHP是世界上最好的语言&apos;; //修改左定界符 $Smarty-&gt;left_delimiter = &apos;&lt;{&apos;; //修改右定界符 $Smarty-&gt;right_delimiter = &apos;}&gt;&apos;; //修改模板文件路径 $Smarty-&gt;template_dir = &apos;./view&apos;; //修改的编译路径 $Smarty-&gt;compile_dir =&apos;./compile&apos;; $Smarty-&gt;assign(&apos;name&apos;,$name); $Smarty-&gt;assign(&apos;PHP&apos;,$PHP); $Smarty-&gt;display(&apos;demo.php&apos;); ​ 相关属性思考：为什么我们要设置templates和templates_c两个文件夹 答：这些目录都是由Smarty中的下面几个属性决定的。 ​​ template_dir 模板文件目录 complile_dir 编译文件目录 config_di r 配置文件目录 cache_dir 缓存文件目录 ​​示例代码： &lt;?php include &quot;Smarty/Smarty.class.php&quot;; //实例化SMarty类 $Smarty = new Smarty(); $name = &apos;我是小明&apos;; $PHP = &apos;PHP是世界上最好的语言&apos;; //修改左定界符 $Smarty-&gt;left_delimiter = &apos;&lt;{&apos;; //修改右定界符 $Smarty-&gt;right_delimiter = &apos;}&gt;&apos;; //修改模板文件路径 $Smarty-&gt;template_dir = &apos;./view&apos;; //修改的编译路径 $Smarty-&gt;compile_dir =&apos;./compile&apos;; $Smarty-&gt;assign(&apos;name&apos;,$name); $Smarty-&gt;assign(&apos;PHP&apos;,$PHP); $Smarty-&gt;display(&apos;demo.php&apos;); ​在Smarty3.0中，这四个属性都是private私有的，那么为什么可以在类外部修改私有属性？ 在PHP中有魔术方法__set 3、相关方法因为Smarty3.0是为了兼容Smarty2.0版本，允许通过属性的方式来设置相关属性。 但是为了迎合Smarty3.0开发规范，我们一般通过使用相关方法对相关属性的设置。。 setTemplateDir() 设置模板文件目录 setCompileDir() 设置编译文件目录 setConfigDir() 设置配置文件目录 setCacheDir() 配置缓存文件目录 示例代码： &lt;?php include &quot;Smarty/Smarty.class.php&quot;; //实例化SMarty类 $Smarty = new Smarty(); $name = &apos;我是小明&apos;; $PHP = &apos;PHP是世界上最好的语言&apos;; //修改左定界符 $Smarty-&gt;left_delimiter = &apos;&lt;{&apos;; //修改右定界符 $Smarty-&gt;right_delimiter = &apos;}&gt;&apos;; //修改模板的路径 $Smarty-&gt;setTemplateDir(&apos;./tmp&apos;); //修改编译文件的路径 $Smarty-&gt;setCompileDir(&apos;./c&apos;); $Smarty-&gt;assign(&apos;name&apos;,$name); $Smarty-&gt;assign(&apos;PHP&apos;,$PHP); $Smarty-&gt;display(&apos;index.tpl&apos;); 4、Smarty中常用的两个方法Assign（`模板变量名称`,`值`） Display(`模板名称`) ​ 5、注意事项一般在使用Smarty做项目的时候，如果templates_c文件不存在，那么会自动创建，但是在linux环境中因为文件权限的问题，。 Display方法指定的模板文件，不一定是.html 结尾的，使用任何文本文件都可以。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JWT（JSON Web Token]）入门简介]]></title>
    <url>%2F2018%2F12%2F16%2FJWT%EF%BC%88JSON-Web-Token-%EF%BC%89%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[JwtJWT是（JSON Web Token]）的缩写，主要用来做用户身份验证的。 随着当前分布式应用、前后端分离的技术广泛使用，早年通过session管理用户状态的成本越来越高，session共享问题以及之后出现的token认证基本都是通过如Redis之类的中间件实现的。 JWT通过将数据保存在客户端，每次请求时将token发送至服务端校验，服务端无需存储token，实现完全无状态化。 流程 客户端登录请求认证 服务端认证通过后，生成包含数据的JSON对象，并将此对象进行签名生成token 服务端将token返回客户端，客户端存储在本地，如cookie或localStorage 客户端下次请求时携带token到服务端，常用的是放在 HTTP 请求的头的Authorization字段中，Authorization: Bearer &lt;token&gt; 服务端验证token有效性 结构Token是一个使用.分割的三部分组成的长字符串，Header.Payload.Signature HeaderHeader是一个Base64URL之后的json对象，{&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;}，alg表示签名的算法（algorithm），默认是 HMAC SHA256（HS256），typ表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。 PayloadPayload 也是一个Base64URL之后的JSON对象，用来存放传递的数据。JWT 规定了7个官方字段可用： iss (issuer)：签发人 iat (Issued At)：签发时间 exp (expiration time)：过期时间 nbf (Not Before)：生效时间 jti (JWT ID)：编号 sub (subject)：主题 aud (audience)：受众 除了官方字段，还可以在这个部分定义私有字段，比如 12345&#123; "sub": "101", "name": "ruesin", "LoginToken":"abcd123"&#125; 因为默认是Base64URL编码不加密的，所以客户端是可以解码读取这些数据，不要把秘密信息放在这个部分。 Signature Signature 是对前两部分的签名，校验tonken的有效性，防止数据篡改。 签名是通过服务端指定的密钥（secret）及Header中指定的签名算法产生的。 1234HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret)]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——HTTPS接入与配置实战]]></title>
    <url>%2F2018%2F11%2F28%2FiOS%E2%80%94%E2%80%94HTTPS%E6%8E%A5%E5%85%A5%E4%B8%8E%E9%85%8D%E7%BD%AE%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[这里粗略的说一下关于HTTPShttps简单说明HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。 即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。 https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。 HTTPS和HTTP的区别主要为以下四点： 一、https协议需要到ca申请证书，一般免费证书很少，需要交费。 二、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。 三、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 四、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 关于更多HTTPS可以看看这篇文章： HTTPS原理和CA证书申请（满满的干货） 具体流程就是当客户端给服务器发送请求时, 服务器中有一对钥匙(公钥,私钥). 服务器会返回给客户端一个公钥,并把两者的传输通道变为受保护空间(安全证书). 此时 客户端拥有公钥,服务器拥有私钥. 当服务器返回数据给客户端时,数据是使用私钥加密过的. 客户端需要使用 公钥解密. 客户端发请求也是通过公钥加密. 服务器使用私钥来解密.(从某种意义上来说. 安全证书 就是公钥) 关于如下类型错误请自行百度： App Transport Security has blocked a cleartext HTTP (http://) resource load since it is insecure. Temporary exceptions can be configured via your app’s Info.plist file. 接下来就开始进行实战处理 准备iOS做https适配时对服务器是有一定要求的，服务端必须要是一个符合ATS（App Transport Security）要求的HTTPS。简单说要满足以下几个要求： 1.Transport Layer Security协议版本要求TLS1.2以上 2.服务的Ciphers配置要求支持Forward Secrecy等 3.证书签名算法符合ATS要求等 Swift关于Swif目前要么使用Alamofire，要么使用Moya，这里只接受Moya，关于Alamofire可以看这篇文章，相对Moya会复杂一点点，但是原理其实差不多是一样的 Alamofire https自签名证书验证 Moya对应版本 Moya版本号：Moya (12.0.1) Alamofire版本号：Alamofire (4.8.1) 实现方法1、默认非HTTPS实现方法：默认情况下定义Manager： 1MoyaProvider&lt;MultiTarget&gt;.defaultAlamofireManager() 该方法不需要做任何处理，Moya默认已经实现 2、HTTPS免证书实现方法（校验证书，可以抓包）： 12345let manager: Manager = MoyaProvider&lt;MultiTarget&gt;.defaultAlamofireManager()manager.delegate.sessionDidReceiveChallenge = &#123; session,challenge in return (URLSession.AuthChallengeDisposition.useCredential,URLCredential(trust:challenge.protectionSpace.serverTrust!))&#125; 注：需要导入：import Alamofire 3、HTTPS+证书实现方法（校验证书，不可以抓包）在实现本方法前，首先需要服务器端提供“*.crt”证书,然后进入证书所在的路径，控制台执行以下命令： 1openssl x509 -in *.crt -out *.cer -outform der 得到cer类型证书后，双击，导入电脑或者直接让服务器提供.cer，然后把cer文件拖动到工程中。 1234567891011let configuration = URLSessionConfiguration.defaultconfiguration.httpAdditionalHeaders = Manager.defaultHTTPHeaderslet path: String = Bundle.main.path(forResource: "xxx", ofType: "cer") ?? ""let certificationData = try? Data(contentsOf: URL(fileURLWithPath: path)) as CFData let certificate = SecCertificateCreateWithData(nil, certificationData!)let certificates: [SecCertificate] = [certificate!] let policies: [String: ServerTrustPolicy] = ["domain": ServerTrustPolicy.pinCertificates(certificates: certificates, validateCertificateChain: true, validateHost: true)] let manager = Manager(configuration: configuration, serverTrustPolicyManager: ServerTrustPolicyManager(policies: policies)) 最后把manager当参数传递给MoyaProvider 1MoyaProvider&lt;MultiTarget&gt;(endpointClosure: endpoint, requestClosure: requestEndpoint, stubClosure: stubClosure, manager: manager, plugins: plugins) Objective-C以上主要是Swift实现Https请求和验证支持下面看看OC的实现，OC的实现其实，由于现在OC几乎都是利用AFN或者AFN的衍生库实现网络请求，老项目的ASI这里就不提了，所以这里只是简单介绍AFN支持 1. 首先定义一个安全协议，和帧数相关验证支持 12345678910111213141516171819202122- (AFSecurityPolicy*)customSecurityPolicy &#123; // /先导入证书 NSString *cerPath = [[NSBundle mainBundle] pathForResource:@"jmt" ofType:@"cer"];//证书的路径 NSData *certData = [NSData dataWithContentsOfFile:cerPath]; // AFSSLPinningModeCertificate 使用证书验证模式 AFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate]; // allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO // 如果是需要验证自建证书，需要设置为YES securityPolicy.allowInvalidCertificates = YES; //validatesDomainName 是否需要验证域名，默认为YES； //假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。 //置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。 //如置为NO，建议自己添加对应域名的校验逻辑。 securityPolicy.validatesDomainName = NO; securityPolicy.pinnedCertificates = [NSSet setWithObject:certData]; return securityPolicy;&#125; 然后在网络请求，初始化Manager的时候，根据配置HTTPS支持 12345if (!isDeveloperEnvironment) &#123; //配置https manager.securityPolicy = [self customSecurityPolicy]; manager.securityPolicy.allowInvalidCertificates = YES;&#125; 总结 1）HTTPS的主要思想是在不安全的网络上创建一安全信道，并可在使用适当的加密包和服务器证书可被验证且可被信任时，对窃听和中间人攻击提供合理的保护。 2）HTTPS的信任继承基于预先安装在浏览器中的证书颁发机构（如VeriSign、Microsoft等）（意即“我信任证书颁发机构告诉我应该信任的”）。 3）因此，一个到某网站的HTTPS连接可被信任，如果服务器搭建自己的https 也就是说采用自认证的方式来建立https信道，这样一般在客户端是不被信任的。 4）所以我们一般在浏览器访问一些https站点的时候会有一个提示，问你是否继续。 到此，拜了个拜…… 推荐：关于https的简介和说明我都是参考下面的文章：(谢谢文章作者) http://my.oschina.net/vimfung/blog/494687 http://oncenote.com/2014/10/21/Security-1-HTTPS/ http://blog.csdn.net/dachao_me/article/details/48624685?ref=myread]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache配置文件(httpd.conf)详解]]></title>
    <url>%2F2018%2F11%2F16%2FApache%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-httpd-conf-%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[配置文件位置 Apache的主配置文件：/etc/httpd/conf/httpd.conf 默认站点主目录：/var/www/html/ Apache服务器的配置信息全部存储在主配置文件/etc/httpd/conf/httpd.conf中，这个文件中的内容非常多，用wc命令统计一共有1009行，其中大部分是以#开头的注释行。 [root@justin ~]# wc -l /etc/httpd/conf/httpd.conf /etc/httpd/conf/httpd.conf [root@justin ~]# 配置文件包括三部分： [root@justin ~]# grep &apos;\&lt;Section\&gt;&apos; /etc/httpd/conf/httpd.conf -n 33:### Section 1: Global Environment 245:### Section 2: &apos;Main&apos; server configuration 973:### Section 3: Virtual Hosts [root@justin ~]# 1）Global Environment—全局环境配置，决定Apache服务器的全局参数 2）Main server configuration—主服务配置，相当于是Apache中的默认Web站点，如果我们的服务器中只有一个站点，那么就只需在这里配置就可以了。 3）Virtual Hosts—虚拟主机，虚拟主机不能与Main Server主服务器共存，当启用了虚拟主机之后，Main Server就不能使用了 1）Global Environment ServerTokens OS 在出现错误页的时候是否显示服务器操作系统的名称，ServerTokens Prod为不显示 ServerRoot &quot;/etc/httpd&quot; 用于指定Apache的运行目录，服务启动之后自动将目录改变为当前目录，在后面使用到的所有相对路径都是想对这个目录下 PidFile run/httpd.pid 记录httpd守护进程的pid号码，这是系统识别一个进程的方法，系统中httpd进程可以有多个，但这个PID对应的进程是其他的父进程 Timeout 60 服务器与客户端断开的时间 KeepAlive Off 是否持续连接（因为每次连接都得三次握手，如果是访问量不大，建议打开此项，如果网站访问量比较大关闭此项比较好），修改为：KeepAlive On 表示允许程序性联机 MaxKeepAliveRequests 100 表示一个连接的最大请求数 KeepAliveTimeout 15 断开连接前的时间 &lt;IfModule prefork.c&gt; StartServers 8 MinSpareServers 5 MaxSpareServers 20 ServerLimit 256 MaxClients 256 MaxRequestsPerChild 4000 &lt;/IfModule&gt; 系统默认的模块，表示为每个访问启动一个进程（即当有多个连接公用一个进程的时候，在同一时刻只能有一个获得服务）。 StartServer开始服务时启动8个进程，最小空闲5个进程，最多空闲20个进程。 MaxClient限制同一时刻客户端的最大连接请求数量超过的要进入等候队列。 MaxRequestsPerChild每个进程生存期内允许服务的最大请求数量，0表示永不结束 StartServers 4 MaxClients 300 MinSpareThreads 25 MaxSpareThreads 75 ThreadsPerChild 25 MaxRequestsPerChild 0 为Apache配置线程访问，即每对WEB服务访问启动一个线程，这样对内存占用率比较小。 ServerLimit服务器允许配置进程数的上限。 ThreadLimit每个子进程可能配置的线程上限 StartServers启动两个httpd进程， MaxClients同时最多能发起250个访问，超过的要进入队列等待，其大小有ServerLimit和ThreadsPerChild的乘积决定 ThreadsPerChild每个子进程生存期间常驻执行线程数，子线程建立之后将不再增加 MaxRequestsPerChild每个进程启动的最大线程数，如达到限制数时进程将结束，如置为0则子线程永不结束 Listen 80 监听的端口，如有多块网卡，默认监听所有网卡 150 LoadModule auth_basic_module modules/mod_auth_basic.so ...... LoadModule version_module modules/mod_version.so 启动时加载的模块 mod_access已经更名为mod_authz_host Include conf.d/*.conf 加载的配置文件 User apache Group apache 启动服务后转换的身份，在启动服务时通常以root身份，然后转换身份，这样增加系统安全 2）Main server configuration ServerAdmin root@localhost 管理员的邮箱 #ServerName www.example.com:80 默认是不需要指定的，服务器通过名字解析过程来获得自己的名字，但如果解析有问题（如反向解析不正确），或者没有DNS名字，也可以在这里指定IP地址，当这项不正确的时候服务器不能正常启动。前面启动Apache时候提示正在启动 httpd：httpd: apr_sockaddr_info_get() failed forjustin httpd: Could not reliably determine the server’s fully qualified domain name, using 127.0.0.1forServerName，解决方法就是启动该项把www.example.com:80修改为自己的域名或者直接修改为localhost 285 UseCanonicalName Off 如果客户端提供了主机名和端口，Apache将会使用客户端提供的这些信息来构建自引用URL。这些值与用于实现基于域名的虚拟主机的值相同，并且对于同样的客户端可用。CGI变量SERVER_NAME和SERVER_PORT也会由客户端提供的值来构建 DocumentRoot &quot;/var/www/html&quot; 网页文件存放的目录 &lt;Directory /&gt; Options FollowSymLinks AllowOverride None &lt;/Directory&gt; 对根目录的一个权限的设置 &lt;Directory &quot;/var/www/html&quot;&gt; Options Indexes FollowSymLinks AllowOverride None Order allow,deny Allow from all &lt;/Directory&gt; 对/var/www/html目录的一个权限的设置，options中Indexes表示当网页不存在的时候允许索引显示目录中的文件，FollowSymLinks是否允许访问符号链接文件。有的选项有ExecCGI表是否使用CGI，如Options Includes ExecCGI FollowSymLinks表示允许服务器执行CGI及SSI，禁止列出目录。SymLinksOwnerMatch表示当符号链接的文件和目标文件为同一用户拥有时才允许访问。 AllowOverrideNone表示不允许这个目录下的访问控制文件来改变这里的配置，这也意味着不用查看这个目录下的访问控制文件，修改为：AllowOverride All 表示允许.htaccess。Order对页面的访问控制顺序后面的一项是默认选项，如allow，deny则默认是deny，Allowfromall表示允许所有的用户，通过和上一项结合可以控制对网站的访问控制 &lt;IfModule mod_userdir.c&gt; UserDir disabled &lt;/IfModule&gt; 是否允许用户访问其家目录，默认是不允许 #&lt;Directory /home/*/public_html&gt; # AllowOverride FileInfo AuthConfig Limit # Options MultiViews Indexes SymLinksIfOwnerMatch IncludesNoExec # &lt;Limit GET POST OPTIONS&gt; # Order allow,deny # Allow from all # &lt;/Limit&gt; # &lt;LimitExcept GET POST OPTIONS&gt; # Order deny,allow # Deny from all # &lt;/LimitExcept&gt; #&lt;/Directory&gt; 如果允许访问用户的家目录中的网页文件，则取消以上注释，并对其中进行修改 DirectoryIndex index.html index.html.var 指定所要访问的主页的默认主页名字，默认首页文件名为index.html AccessFileName .htaccess 定义每个目录下的访问控制文件名，缺省为.htaccess &lt;Files ~ &quot;^\.ht&quot;&gt; Order allow,deny Deny from all Satisfy All &lt;/Files&gt; 控制不让web上的用户来查看.htpasswd和.htaccess这两个文件 TypesConfig /etc/mime.types 用于设置保存有不同MIME类型数据的文件名 DefaultType text/plain 默认的网页的类型 &lt;IfModule mod_mime_magic.c&gt; # MIMEMagicFile /usr/share/magic.mime MIMEMagicFile conf/magic &lt;/IfModule&gt; 指定判断文件真实MIME类型功能的模块 HostnameLookups Off 当打开此项功能时，在记录日志的时候同时记录主机名，这需要服务器来反向解析域名，增加了服务器的负载，通常不建议开启 #EnableMMAP off 是否允许内存映射：如果httpd在传送过程中需要读取一个文件的内容，它是否可以使用内存映射。如果为on表示如果操作系统支持的话，将使用内存映射。在一些多核处理器的系统上，这可能会降低性能，如果在挂载了NFS的DocumentRoot上如果开启此项功能，可能造成因为分段而造成httpd崩溃 #EnableSendfile off 这个指令控制httpd是否可以使用操作系统内核的sendfile支持来将文件发送到客户端。默认情况下，当处理一个请求并不需要访问文件内部的数据时(比如发送一个静态的文件内容)，如果操作系统支持，Apache将使用sendfile将文件内容直接发送到客户端而并不读取文件 484 ErrorLog logs/error_log 错误日志存放的位置 LogLevel warn Apache日志的级别 LogFormat &quot;%h %l %u %t \&quot;%r\&quot; %&gt;s %b \&quot;%{Referer}i\&quot; \&quot;%{User-Agent}i\&quot;&quot; combined LogFormat &quot;%h %l %u %t \&quot;%r\&quot; %&gt;s %b&quot; common LogFormat &quot;%{Referer}i -&gt; %U&quot; referer LogFormat &quot;%{User-agent}i&quot; agent 定义了日志的格式，并用不同的代号表示 #CustomLog logs/access_log common CustomLog logs/access_log combined 说明日志记录的位置，这里面使用了相对路径，所以ServerRoot需要指出，日志位置就存放在/etc/httpd/logs ServerSignature On 定义当客户请求的网页不存在，或者错误的时候是否提示apache的版本的一些信息 Alias /icons/ &quot;/var/www/icons/&quot; 定义一些不在DocumentRoot下的文件，而可以将其映射到网页根目录中，这也是访问其他目录的一种方法，但在声明的时候切记目录后面加”/” &lt;Directory &quot;/var/www/icons&quot;&gt; Options Indexes MultiViews FollowSymLinks AllowOverride None Order allow,deny Allow from all &lt;/Directory&gt; 定义对/var/www/icons/的权限，修改为 Options MultiViews FollowSymLinks表示不在浏览器上显示树状目录结构 &lt;IfModule mod_dav_fs.c&gt; # Location of the WebDAV lock database. DAVLockDB /var/lib/dav/lockdb &lt;/IfModule&gt; 对mod_dav_fs.c模块儿的管理 ScriptAlias /cgi-bin/ &quot;/var/www/cgi-bin/&quot; 对CGI模块儿的的别名，与Alias相似。 &lt;Directory &quot;/var/www/cgi-bin&quot;&gt; AllowOverride None Options None Order allow,deny Allow from all &lt;/Directory&gt; 对/var/www/cgi-bin文件夹的管理，方法同上 # Redirect old-URI new-URL Redirect参数是用来重写URL的，当浏览器访问服务器上的一个已经不存在的资源的时候，服务器返回给浏览器新的URL，告诉浏览器从该URL中获取资源。这主要用于原来存在于服务器上的文档改变位置之后，又需要能够使用老URL能访问到原网页 IndexOptions FancyIndexing VersionSort NameWidth=* HTMLTable Charset=UTF-8 AddIconByEncoding (CMP,/icons/compressed.gif) x-compress x-gzip ... IndexIgnore .??* *~ *# HEADER* README* RCS CVS *,v *,t 当一个HTTP请求的URL为一个目录的时候，服务器返回这个目录中的索引文件，如果目录中不存在索引文件，并且服务器有许可显示目录文件列表的时候，就会显示这个目录中的文件列表，为了使得这个文件列表能具有可理解性，而不仅仅是一个简单的列表，就需要前这些参数。如果使用了IndexOptionsFancyIndexing选项，可以让服务器针对不同的文件引用不同的图标。如果没有就使用DefaultIcon定义缺省图标。同样，使用AddDescription可以为不同类型的文档介入描述 AddLanguage ca .ca ...... AddLanguage zh-TW .zh-tw 添加语言 LanguagePriority en ca cs da de el eo es et fr he hr it ja ko ltz nl nn no pl pt pt-BR ru sv zh-CN zh-TW Apache支持的语言 AddDefaultCharset UTF-8 默认支持的语言 #AddType application/x-tar .tgz 支持的应用如果想支持对php的解析添加这样一行 #AddEncoding x-compress .Z #AddEncoding x-gzip .gz .tgz 支持对以.Z和.gz.tgz结尾的文件 AddType application/x-compress .Z AddType application/x-gzip .gz .tgz 添加对上述两种文件的应用 #AddHandler cgi-script .cgi 修改为：AddHandler cgi-script .cgi .pl 表示允许扩展名为.pl的CGI脚本运行 AddType text/html .shtml AddOutputFilter INCLUDES .shtml 添加动态处理类型为server-parsed由服务器预先分析网页内的标记，将标记改为正确的HTML标识 #ErrorDocument 404 /missing.html 当服务器出现404错误的时候，返回missing.html页面 Alias /error/ &quot;/var/www/error/&quot; 赋值别名 &lt;IfModule mod_negotiation.c&gt; &lt;IfModule mod_include.c&gt; &lt;Directory &quot;/var/www/error&quot;&gt; AllowOverride None Options IncludesNoExec AddOutputFilter Includes html AddHandler type-map var Order allow,deny Allow from all LanguagePriority en es de fr ForceLanguagePriority Prefer Fallback &lt;/Directory&gt; 对/var/www/error网页的权限及操作 BrowserMatch &quot;Mozilla/2&quot; nokeepalive BrowserMatch &quot;MSIE 4\.0b2;&quot; nokeepalive downgrade-1.0 force-response-1.0 BrowserMatch &quot;RealPlayer 4\.0&quot; force-response-1.0 BrowserMatch &quot;Java/1\.0&quot; force-response-1.0 BrowserMatch &quot;JDK/1\.0&quot; force-response-1.0 ..... 设置特殊的参数，以保证对老版本浏览器的兼容，并支持新浏览器的特性 3）Virtual Hosts#NameVirtualHost *:80 如果启用虚拟主机的话，必须将前面的注释去掉，而且，第二部分的内容都可以出现在每个虚拟主机部分。 # VirtualHost example: #&lt;VirtualHost *:80&gt; # ServerAdmin webmaster@www.linuxidc.com # DocumentRoot /www/docs/www.linuxidc.com # ServerName www.linuxidc.com # ErrorLog logs/www.linuxidc.com-error_log # CustomLog logs/www.linuxidc.com-access_log common #&lt;/VirtualHost&gt; 常用配置指令说明]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>配置文件</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx配置文件(nginx.conf)详解]]></title>
    <url>%2F2018%2F11%2F16%2FNginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-nginx-conf-%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Nginx 总的 配置文件 位置 /usr/local/nginx/conf/nginx.confnginx 正则匹配 一．正则表达式匹配，其中： ~ 为区分大小写匹配 ~* 为不区分大小写匹配 !~和!~*分别为区分大小写不匹配及不区分大小写不匹配 二．文件及目录匹配，其中： -f和!-f用来判断是否存在文件 -d和!-d用来判断是否存在目录 -e和!-e用来判断是否存在文件或目录 -x和!-x用来判断文件是否可执行 三．rewrite指令的最后一项参数为flag标记，flag标记有： last 相当于apache里面的[L]标记，表示rewrite。 break本条规则匹配完成后，终止匹配，不再匹配后面的规则。 redirect 返回302临时重定向，浏览器地址会显示跳转后的URL地址。 permanent 返回301永久重定向，浏览器地址会显示跳转后的URL地址。 12345使用last和break实现URI重写，浏览器地址栏不变。使用alias指令必须用last标记;使用proxy_pass指令时，需要使用break标记。Last标记在本条rewrite规则执行完毕后，会对其所在server&#123;......&#125;标签重新发起请求break标记则在本条规则匹配完成后，终止匹配。 四．NginxRewrite 规则相关指令1. break指令 使用环境：server,location,if; 该指令的作用是完成当前的规则集，不再处理rewrite指令。 2.if指令 使用环境：server,location 该指令用于检查一个条件是否符合，如果条件符合，则执行大括号内的语句。If指令不支持嵌套，不支持多个条件&amp;&amp;和||处理。 3.return指令 语法：return code ; 使用环境：server,location,if; 该指令用于结束规则的执行并返回状态码给客户端。示例：如果访问的URL以”.sh”或”.bash”结尾，则返回403状态码 location ~ .*\.(sh|bash)?$ { return 403; } 4.rewrite 指令 语法：rewriteregex replacement flag 使用环境：server,location,if 该指令根据表达式来重定向URI，或者修改字符串。指令根据配置文件中的顺序来执行。注意重写表达式只对相对路径有效。如果你想配对主机名，你应该使用if语句，示例如下： if ( $host ~* www\.(.*) ) { set $host_without_www $1; rewrite ^(.*)$ http://$host_without_www$1 permanent; } 5.Set指令 语法：setvariable value ; 默认值:none; 使用环境：server,location,if; 该指令用于定义一个变量，并给变量赋值。变量的值可以为文本、变量以及文本变量的联合。 示例：set $varname “hello world”; 6.Uninitialized_variable_warn指令 语法：uninitialized_variable_warnon|off 使用环境：http,server,location,if 该指令用于开启和关闭未初始化变量的警告信息，默认值为开启。 五．Nginx的Rewrite规则编写实例1.当访问的文件和目录不存在时，重定向到某个php文件if ( !-e $request_filename ) { Rewrite ^/(.*)$ index.php last; } 2.目录对换 /123456/xxxx ====&gt; /xxxx?id=123456rewrite ^/(\d+)/(.+)/ /$2?id=$1 last; 3.如果客户端使用的是IE浏览器，则重定向到/ie目录下if( $http_user_agent ~ MSIE) { Rewrite ^(.*)$ /ie/$1 break; } 4.禁止访问多个目录location ~ ^/(cron|templates)/ { deny all; break; } 5.禁止访问以/data开头的文件location ~ ^/data { deny all; } 6.禁止访问以.sh,.flv,.mp3为文件后缀名的文件location ~ .*\.(sh|flv|mp3)$ { return 403; } 7.设置某些类型文件的浏览器缓存时间location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$ { expires 30d; } location ~ .*\.(js|css)$ { expires 1h; } 8.给favicon.ico和robots.txt设置过期时间;这里为favicon.ico为99天,robots.txt为7天并不记录404错误日志 location ~(favicon.ico) { log_not_found off; expires 99d; break; } location ~(robots.txt) { log_not_found off; expires 7d; break; } 9.设定某个文件的过期时间;这里为600秒，并不记录访问日志location ^~ /html/scripts/loadhead_1.js { access_log off; root /opt/lampp/htdocs/web; expires 600; break; } 10.文件反盗链并设置过期时间 这里的return412 为自定义的http状态码，默认为403，方便找出正确的盗链的请求 “rewrite ^/ http://img.linuxidc.net/leech.gif;” 显示一张防盗链图片 “access_log off;” 不记录访问日志，减轻压力 “expires 3d” 所有文件3天的浏览器缓存 location ~*^.+\.(jpg|jpeg|gif|png|swf|rar|zip|css|js)$ { valid_referers none blocked *.linuxidc.com*.linuxidc.net localhost 208.97.167.194; if ($invalid_referer) { rewrite ^/ http://img.linuxidc.net/leech.gif; return 412; break; } access_log off; root /opt/lampp/htdocs/web; expires 3d; break; } 11.只允许固定ip访问网站，并加上密码root /opt/htdocs/www; allow 208.97.167.194; allow 222.33.1.2; allow 231.152.49.4; deny all; auth_basic “C1G_ADMIN”; auth_basic_user_file htpasswd; 12将多级目录下的文件转成一个文件，增强seo效果/job-123-456-789.html 指向/job/123/456/789.html rewrite ^/job-([0-9]+)-([0-9]+)-([0-9]+)\.html$ /job/$1/$2/jobshow_$3.html last; 13.文件和目录不存在的时候重定向：if (!-e $request_filename) { proxy_pass http://127.0.0.1; } 14.将根目录下某个文件夹指向2级目录如/shanghaijob/ 指向 /area/shanghai/如果你将last改成permanent，那么浏览器地址栏显是/location/shanghai/ rewrite ^/([0-9a-z]+)job/(.*)$ /area/$1/$2last; 面例子有个问题是访问/shanghai时将不会匹配 rewrite ^/([0-9a-z]+)job$ /area/$1/ last; Rewrite ^/([0-9a-z]+)job/(.*)$ /area/$1/$2last; 这样/shanghai 也可以访问了，但页面中的相对链接无法使用， 如./list_1.html真实地址是/area/shanghia/list_1.html会变成/list_1.html,导至无法访问。那我加上自动跳转也是不行咯 (-d $request_filename)它有个条件是必需为真实目录，而我的rewrite不是的，所以没有效果 if (-d $request_filename) { rewrite ^/(.*)([^/])$ http://$host/$1$2/permanent; } 知道原因后就好办了，让我手动跳转吧 rewrite ^/([0-9a-z]+)job$ /$1job/permanent; rewrite ^/([0-9a-z]+)job/(.*)$ /area/$1/$2last; 15.域名跳转server { listen 80; server_name jump.linuxidc.com; index index.html index.htm index.php; root /opt/lampp/htdocs/www; rewrite ^/ http://www.linuxidc.com/; access_log off; } 16.多域名转向server_name www.linuxidc.com www.linuxidc.net; index index.html index.htm index.php; root /opt/lampp/htdocs; if ($host ~ &quot;linuxidc\.net&quot;) { rewrite ^(.*) http://www.linuxidc.com$1permanent; } 六．nginx全局变量​arg_PARAMETER #这个变量包含GET请求中，如果有变量PARAMETER时的值。 args #这个变量等于请求行中(GET请求)的参数，如：foo=123&amp;bar=blahblah; binary_remote_addr #二进制的客户地址。 body_bytes_sent #响应时送出的body字节数数量。即使连接中断，这个数据也是精确的。 content_length #请求头中的Content-length字段。 content_type #请求头中的Content-Type字段。 cookie_COOKIE #cookie COOKIE变量的值 document_root #当前请求在root指令中指定的值。 document_uri #与uri相同。 host #请求主机头字段，否则为服务器名称。 hostname #Set to themachine’s hostname as returned by gethostname http_HEADER is_args #如果有args参数，这个变量等于”?”，否则等于”&quot;，空值。 http_user_agent #客户端agent信息 http_cookie #客户端cookie信息 limit_rate #这个变量可以限制连接速率。 query_string #与args相同。 request_body_file #客户端请求主体信息的临时文件名。 request_method #客户端请求的动作，通常为GET或POST。 remote_addr #客户端的IP地址。 remote_port #客户端的端口。 remote_user #已经经过Auth Basic Module验证的用户名。 request_completion #如果请求结束，设置为OK. 当请求未结束或如果该请求不是请求链串的最后一个时，为空(Empty)。 request_method #GET或POST request_filename #当前请求的文件路径，由root或alias指令与URI请求生成。 request_uri #包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。不能修改。 scheme #HTTP方法（如http，https）。 server_protocol #请求使用的协议，通常是HTTP/1.0或HTTP/1.1。 server_addr #服务器地址，在完成一次系统调用后可以确定这个值。 server_name #服务器名称。 server_port #请求到达服务器的端口号。 七．Apache和Nginx规则的对应关系Apache的RewriteCond对应Nginx的if Apache的RewriteRule对应Nginx的rewrite Apache的[R]对应Nginx的redirect Apache的[P]对应Nginx的last Apache的[R,L]对应Nginx的redirect Apache的[P,L]对应Nginx的last Apache的[PT,L]对应Nginx的last 例如：允许指定的域名访问本站，其他的域名一律转向www.linuxidc.net Apache:RewriteCond %{HTTP_HOST} !^(.*?)\.aaa\.com$[NC] RewriteCond %{HTTP_HOST} !^localhost$ RewriteCond %{HTTP_HOST}!^192\.168\.0\.(.*?)$ RewriteRule ^/(.*)$ http://www.linuxidc.net[R,L] Nginx:if( $host ~* ^(.*)\.aaa\.com$ ) { set $allowHost &apos;1&apos;; } if( $host ~* ^localhost ) { set $allowHost &apos;1&apos;; } if( $host ~* ^192\.168\.1\.(.*?)$ ) { set $allowHost &apos;1&apos;; } if( $allowHost !~ &apos;1&apos; ) { Rewrite ^/(.*)$ http://www.linuxidc.netredirect ; } nginx conf 配置文件nginx进程数，建议设置为等于CPU总核心数. worker_processes 8; 全局错误日志定义类型，[ debug | info | notice | warn | error | crit ] error_log /var/log/nginx/error.log info; 进程文件 pid /var/run/nginx.pid; 一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。 worker_rlimit_nofile 65535; 工作模式与连接数上限 events { #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。 use epoll; #单个进程最大连接数（最大连接数=连接数*进程数） worker_connections 65535; } 设定http服务器 http { ​ include mime.types; #文件扩展名与文件类型映射表 default_type application/octet-stream; #默认文件类型 #charset utf-8; #默认编码 server_names_hash_bucket_size 128; #服务器名字的hash表大小 client_header_buffer_size 32k; #上传文件大小限制 large_client_header_buffers 4 64k; #设定请求缓 client_max_body_size 8m; #设定请求缓 sendfile on; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。 autoindex on; #开启目录列表访问，合适下载服务器，默认关闭。 tcp_nopush on; #防止网络阻塞 tcp_nodelay on; #防止网络阻塞 keepalive_timeout 120; #长连接超时时间，单位是秒 ​ #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。 fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; ​ #gzip模块设置 gzip on; #开启gzip压缩输出 gzip_min_length 1k; #最小压缩文件大小 gzip_buffers 4 16k; #压缩缓冲区 gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0） gzip_comp_level 2; #压缩等级 gzip_types text/plain application/x-javascript text/css application/xml; #压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。 gzip_vary on; #limit_zone crawler $binary_remote_addr 10m; #开启限制IP连接数的时候需要使用 ​ upstream blog.ha97.com { #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。 server 192.168.80.121:80 weight=3; server 192.168.80.122:80 weight=2; server 192.168.80.123:80 weight=3; } 虚拟主机的配置 server { ​ listen 80; #监听端口 server_name aa.cn www.aa.cn ; #server_name end #域名可以有多个，用空格隔开 ​ index index.html index.htm index.php; # 设置访问主页 set $subdomain &apos;&apos;; # 绑定目录为二级域名 bbb.aa.com 根目录 /bbb 文件夹 if ( $host ~* &quot;(?:(\w+\.){0,})(\b(?!www\b)\w+)\.\b(?!(com|org|gov|net|cn)\b)\w+\.[a-zA-Z]+&quot; ) { set $subdomain &quot;/$2&quot;; } root /home/wwwroot/aa.cn/web$subdomain;# 访问域名跟目录 include rewrite/dedecms.conf; #rewrite end #载入其他配置文件 ​ location ~ .*.(php|php5)?$ { fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi.conf; } #图片缓存时间设置 location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$ { expires 10d; } #JS和CSS缓存时间设置 location ~ .*.(js|css)?$ { expires 1h; } } ​ 日志格式设定 ​ log_format access &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; $http_x_forwarded_for&apos;; #定义本虚拟主机的访问日志 access_log /var/log/nginx/ha97access.log access; ​ #对 &quot;/&quot; 启用反向代理 location / { ​ proxy_pass http://127.0.0.1:88; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #以下是一些反向代理的配置，可选。 proxy_set_header Host $host; client_max_body_size 10m; #允许客户端请求的最大单文件字节数 client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数， proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时) proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时) proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时) proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的设置 proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2） proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传 ​ } ​ 设定查看Nginx状态的地址 ​ location /NginxStatus { ​ stub_status on; access_log on; auth_basic &quot;NginxStatus&quot;; auth_basic_user_file conf/htpasswd; #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。 ​ } ​ #本地动静分离反向代理配置 #所有jsp的页面均交由tomcat或resin处理 location ~ .(jsp|jspx|do)?$ { ​ proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080; ​ } ​ #所有静态文件由nginx直接读取不经过tomcat或resin location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$ { expires 15d; } location ~ .*.(js|css)?$ { expires 1h; } } nginx 在thinkphp 的url 重写在/usr/local/nginx/conf/vhost/你的域名配置文件 中添加 location / { if (!-e $request_filename) { rewrite ^/(.*)/(.*)/(.*)/*$ /index.php?m=$1&amp;c=$2&amp;a=$3 last; # thinkphp 的配置文件中 &apos;URL_MODEL&apos; =&gt; 1 PATHINFO模式 ​ #或者 rewrite ^(.*)$ /index.php?s=$1 last; # thinkphp 的配置文件中 &apos;URL_MODEL&apos; =&gt;3 兼容模式 ​ #或者 rewrite /(.*)$ /index.php/$1 last; # thinkphp 的配置文件中 &apos;URL_MODEL&apos; =&gt; 2 REWRITE模式 break; } } 路径 pathinfo 模式[ thinkphp ] 添加location ~ \.php(.*)$ { fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_split_path_info ^((?U).+\.php)(/?.+)$; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_param PATH_TRANSLATED $document_root$fastcgi_path_info; include fastcgi_params; } 重写 url +省略index.phplocation / { try_files $uri /index.php?$uri; } nginx -s reload 或者 /usr/local/nginx/sbin/nginx -s reload 重新加载Nginx配置文件]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Nginx</tag>
        <tag>配置文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP面试值知识点复习]]></title>
    <url>%2F2018%2F11%2F16%2FPHP%E9%9D%A2%E8%AF%95%E5%80%BC%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[=====================1.基础===================== 1.1 PHP的引用传递值类型默认存放在栈中，但当值类型是在引用类型中声明的时候，则存放在其所在的引用类型的堆中。 引用类型存放在堆中。其在堆中的内存地址存放在栈中。 1.2 PHP定义字符串的几种方式单引号、双引号、heredoc(&lt;&lt;&lt;EOT)和newdoc(&lt;&lt;&lt;’EOT’) 区别：双引号可以解析变量，转义字符而单引号不可以；单引号和双引号都可以使用.进行连接；单引号比双引号的执行效率更好；heredoc和newdoc主要用于比较长的字符串； 注意：双引号中的单引号不 $a = &apos;newStr&apos;; $str = &quot;abcdef{&amp;&amp;$a&amp;&amp;}g&quot;; var_dump($str); echo PHP_EOL; $str = &lt;&lt;&lt;&apos;EOL&apos; SELECTFROM `dvb_user` WHERE `userName` = &apos;panda&apos; AND `sex` = &apos;1&apos; AND `money` &gt; 280 LEFT JOIN `dvb_hotel` ON `dvb_user`.id = `dvb_hotel`.user_id; EOL; 1.3 PHP的数据类型PHP的数据类型有8种(整形、字符型、浮点型、数组、对象、null、资源、布尔型) 可以分为三类(标量 符合 特殊)注意：浮点类型不能用于准确的相等判断中；布尔类型包括（0、’’、’0’，[],false,null,0.0） var_dump($str); $a = 0.1; $b = 0.4; if((float)$a + (double)$b === (float)0.5){ echo &apos;true&apos;; }else{ echo &apos;false&apos;; } 1.4 PHP中的超全局数组$_GLOBALS,$_GET,$_POST,$_REQUEST,$_SERVER,$_SESSION,$_COOKIE,$_FILES,$_ENV 注意：$_GLOBALS包含其他所有的全局数组 主要记住 $_SERVER[‘SERVER_ADDR’] $_SERVER[‘REMOTE_ADDR’] $_SERVER[‘HTTP_USER_AGENT’] var_dump($_SERVER); 1.5 NULL的三种情况直接对变量赋值为NULL 、变量未定义、变量被销毁 var_dump($a); $a = &apos;a&apos;; unset($a); var_dump($a); 1.6 比较常量 const和define (常量一经定义不能进行修改和删除)PHP预定义常量 FILE、LINE、DIR、FUNCTION、CLASS、TRAIT、METHOD、NAMESPACE class IndexClass{ //定义常量，const可以定义在类内，而define不可以 const A = &apos;a&apos;; const B = &apos;b&apos;; } define(&apos;AAA&apos;,5); define(&apos;BBB&apos;,6); //测试修改define常量 define(&apos;AAA&apos;,4); //这种用法不会真正的修改到常量的值 var_dump(AAA); var_dump(BBB); $indexClass = new IndexClass(); var_dump($indexClass::A); var_dump(__FILE__); //当前文件的路径和文件名 var_dump(__LINE__); //返回当前的行号 var_dump(__DIR__); //返回当前文件所在的目录路径 class TestClass{ // //初始化 public function __construct() { // var_dump(__CLASS__); //返回当前的类名 var_dump(__FUNCTION__); //返回当前的方法名 } public function test() { var_dump(__FUNCTION__); //__METHOD__和__FUNCTION__位于类外，没有区别；位于类内，__METHOD__会多一个类名 string(15) &quot;TestClass::test&quot; var_dump(__METHOD__); } } $obj = new TestClass(); $obj-&gt;test(); trait TraitTest{ // public function test() { echo 1; } } class Index{ use TraitTest; public function __construct() { $this-&gt;test(); } public function testTrait() { // var_dump(__TRAIT__); } } $a = new Index(); $a-&gt;testTrait(); var_dump(__NAMESPACE__); //返回当前文件的命名空间 =====================2.变量与作用域===================== 2.1 变量的作用域和静态变量变量的作用域：变量生效的范围，这个范围的跨度包括require和include引入的文件函数外面的变量（全局变量）一般情况不可以直接在函数内部进行使用，如果要在函数内部使用外部的定义的变量可以使用global或者其他超全局数组关键字； 静态变量 static 静态变量只会存在于函数内部，函数外部的变量不受其影响，但当程序离开此程序作用域，其值不会随着函数的执行完毕而消失 静态变量的特点： ①仅初始化一次； ②初始化的时候需要赋值； ③每次执行完函数该值保留 ④static修饰的变量是局部的，仅在函数内部有效 ⑤可以用来记录函数调用的次数 2.2 函数的参数默认情况下，函数的参数传递是通过值传递的，如果想在函数的内部修改参数的值，需要进行引用传递，即在参数的前面加上&amp; $a = 1; //1 function test_function_params(&amp;$a){ $a++; echo $a; echo PHP_EOL; } $a++; //2 echo test_function_params($a); //3 echo $a; //3 2.3 函数的返回值 使用return进行返回，函数中一旦执行到return则马上进行返回 可以返回数组，对象等php基本数据类型 原则上不允许返回多个值，可以通过数组来保存多个值 引用返回：需要在函数声明和值返回的时候加上引用符号 function &amp;my_func(){ static $a = 3; return $a; } echo my_func(); //10 $a = &amp;my_func();//将外部的$a和内部的$a的变量指向相同的内存空间 $a = 100; //修改内存空间的值 echo my_func(); //100 2.4 外部引用 外部引用文件需要指明引用文件的具体路径，如果没有指定则会去系统的include_path文件下查找,如果include_path也没有，则会从当前目录进行查找 如果在以上三个地方都没有找到，那么加载文件就会报错，include会产生警告，require会产生致命的错误 include_once和require_once include &apos;index1.php&apos;; require &apos;index1.php&apos;; 2.5 常用的PHP内置函数时间日期函数 Ip处理函数 打印处理函数 序列化函数 字符串处理函数 数组处理函数 https://php.net/ var_dump(date(&apos;Y-m-d H:i:s&apos;,1494221221)); //将时间戳格式化成日期时间类型 var_dump(time()); //time() 打印当前的时间戳 var_dump(strtotime(&apos;2018-12-7 12:30&apos;)); //将英文的日期时间转化为时间戳 var_dump(mktime(12,45,11,3,23,2019)); //输出一个指定日期时间的时间戳 var_dump(microtime()); //返回当前的Unix时间戳和微秒数 date_default_timezone_set(&apos;Asia/Shanghai&apos;); //设定用于一个脚本中所有日期时间函数的默认时区 ip相关 var_dump(ip2long(&apos;192.168.1.1&apos;)); //将 IPV4 的字符串互联网协议转换成长整型数字 var_dump(long2ip(3232235778)); //将 长整型数字 转化成 IPV4 的字符串互联网协议转 打印相关 print() echo() printf() sprintf() printf_r()只能针对数组和对象 var_dump() var_export() 字符串处理函数 implode(); //将多个数组,用指定的字符连接起来 join()===implode() explode(); //将字符串分割成数组 $a = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;]; var_dump(implode(&apos;-&apos;,$a)); $str = &apos;192.168.1.1&apos;; var_dump(explode(&apos;.&apos;,$str)); $str = &apos;192.168.1.1&apos;; var_dump(strrev($str)); //翻转字符串 $str = &apos; 123 455\t &apos;; var_dump($str); var_dump(trim($str)); //过滤字符串首部和尾部的空白字符（或者其他字符） ltrim() rtrim() left right $str = &apos;192.168.1.1&apos;; var_dump(strstr($str,&apos;.&apos;)); //strstr(); //查找字符串的首次出现 echo number_format(125,&apos;3&apos;); //以千位分隔符方式格式化一个数字 =====================3.正则表达式===================== 3.1 正则表达式正则表达式的作用：分割、查找、匹配、替换 常用的分隔符：正斜线（/） hash符号（#）以及取反符号（~） 通用原子： \d [0-9] \D ![0-9] \w [数字、字母、下划线] \W ![数字、字母、下划线] \s 空白符 \S !空白符 元字符：.![换行符]匹配前面的内容0 1 多次 ? ^ $ + {n} {n,} {n,m} [] () [^] | [-] 模式修正符 i m e s U x A D u 涉及到的函数 preg_match() preg_match_all() preg_replace() preg_split() 3.2 正则表达式后向引用需要匹配的用括号括起来 $str = &apos;&lt;b&gt;abc&lt;/b&gt;&apos;; //将其中的b替换成其他 $pattern = &apos;/&lt;b&gt;(.*)&lt;\/b&gt;/&apos;; //$result = preg_match($pattern,$str); //匹配是都在&lt;b&gt;&lt;/b&gt;中 $result = preg_replace($pattern,&apos;\\1&apos;,$str); //去掉b标签 var_dump($result); 3.3 正则表达式的贪婪模式如果含有多个标签，正则表达式的贪婪模式会匹配第一个和最后一个解决方法在 .* 后面加个? 取消贪婪模式 $str = &apos;&lt;b&gt;abc&lt;/b&gt;&lt;b&gt;bcd&lt;/b&gt;&apos;; //将其中的b替换成其他 $pattern = &apos;/&lt;b&gt;(.*?)&lt;\/b&gt;/&apos;; $result = preg_replace($pattern,&apos;\\1&apos;,$str); //去掉b标签 var_dump($result); 3.4 PHP正则表达式匹配中文 中文字符在utf-8模式下的 0x4e00-0X9fa5 gbk需要加chr() 函数 注意：中文字符匹配需要加+ $str = &apos;我爱我家&apos;; $pattern = &apos;/[\x4e00-\x9fa5]+/&apos;; preg_match($pattern,$str,$match); var_dump($match); 3.5 练习 写一个139开头的手机号$str = &apos;13968547896&apos;; $pattern = &apos;/139[0-9]{8}/&apos;; preg_match($pattern,$str,$match); var_dump($match); $str = &apos;https://www.baidu.com&apos;; $pattern = &apos;/^(http|https):\/\/(.*)+/&apos;; preg_match($pattern,$str,$match); var_dump($match); 请写出一个正则表达式，取出页面中的所有的img标签的src值 $str = &apos;&lt;img class=&quot;index-top&quot; src=&quot;http://www.baidu.com/1&quot; id=&quot;index&quot; /&gt;&lt;p&gt;&lt;video src=&quot;aaa&quot;&gt;&lt;/video&gt;&lt;/p&gt;&lt;img class=&quot;index-top-2&quot; src=&quot;http://www.baidu.com/2&quot; width=&quot;100%&quot; /&gt;&apos;; $pattern = &apos;/&lt;img.*?src=&quot;(.*?)&quot;.*? \/?&gt;/i&apos;; $result = preg_replace($pattern,&apos;\\1&apos;,$str); var_dump($result); =====================4. PHP常用的文件系统 ===================== 真题：向一个已知的文件中的头部插入 Hello World 1.打开文件 $file = &apos;./test.txt&apos;; $content = &apos;&apos;; //2.以只读的方式，读取文件中的内容 if (file_exists($file)){ $handle = fopen($file,&apos;r&apos;); $content = fread($handle,filesize($file)); //3.关闭文件 fclose($handle); } //4.以只写的方式打开文件 $handle = fopen($file,&apos;w&apos;); //5.拼接新的字符串进行写入 $content = &quot;Hello World \t&quot; . $content; fwrite($handle,$content); //6.关闭文件 fclose($handle); 4.1 PHP常用的文件函数复习$file = &apos;./test.txt&apos;; var_dump(basename($file)); //basename()返回文件名 var_dump(copy($file,&apos;./test1.txt&apos;)); //copy() 拷贝文件，如果目标文件已经存在，则会进行覆盖 overwrite var_dump(unlink(&apos;./test1.txt&apos;)); //unlink() 删除文件，如果文件不存在，返回fasle，并且产生一个警告，所以在删除前需要先判断文件是否真的存在 if (file_exists(&apos;./test1.txt&apos;)){ unlink(&apos;./test1.txt&apos;); } var_dump(dirname(__FILE__)); //dirname()返回当前文件的文件目录，只会返回目录。如果文件使用的是相对路径，则只会返回相对路径的地址 fopen() //没什么好说的，在读取和写入文件之前首先要打开文件，打开的几种方式 r只读 r+读写，指针在文件的头部，如果直接使用则会将后面的字符替换掉 w只写w+读写指针在文件的头部 a只写，相当于在文件的尾部进行追加 a+读写文件尾部进行追加 append的简写 x创建并以写入方式打开，指针在文件的头部 x+类似x=，读写方式打开 b打开一个二进制文件 注意：当写入一个文本文件并想插入一个新行时，需要使用符合操作系统的行结束符号。基于 Unix 的系统使用 \n 作为行结束字符，基于 Windows 的系统使用 \r\n 作为行结束字符，基于 Macintosh 的系统使用 \r 作为行结束字符。 fread() //没什么还说的，读取文件的内容。需要两个参数，第一个为打开的文件资源，第二个为要读取的内容的大小 var_dump(filesize($file)); //文件的大小 fwrite(); //三个参数 第一个已经打开的文件资源 第二个为要插入的文件的内容 第三个要插入的文件的大小 和fputs()用法一致 fclose(); //没什么好说的，打开文件操作完之后要关闭文件,需要传递已经打开的文件的资源 fclose(fopen($file,&apos;r&apos;)); var_dump(fileatime($file)); //返回上次访问 文件的时间戳 filectime(); //上次修改的时间戳 var_dump(flock($file)); //为文件加锁，比如对临界资源的等待 fgetc() //从文件中读取字符 fgets() //从文件中读取一行 unlink($file); //删除文件 4.2 对目录的操作通过PHP函数的方式对目录进行遍历涉及到的函数 opendir() mkdir() rmdir() readdir()只会删除空的文件夹 使用递归的方法 $dir = &apos;./test&apos;; 递归要使用函数 function loopDir($dir){ //1.判断传递进去的是不是文件夹 if (!is_dir($dir)){ return false; } //2.打开文件夹 $handle = opendir($dir); //3.循环读取文件夹中的每一个文件 while(false !== ($file = readdir($handle))){ //4.过滤当前目录和上级目录 if ($file != &apos;.&apos; &amp;&amp; $file != &apos;..&apos;){ //5.判断当前文件是不是DIR类型 if (filetype($dir . &apos;/&apos; .$file) == &apos;dir&apos;){ loopDir($dir . &apos;/&apos; . $file); }else{ //6.打印 echo $file . PHP_EOL; } } } } loopDir($dir); 4.3 注意事项 在删除文件的时候，注意要过滤..文件夹，有可能无限向上删除 在操作文件的时候，必须先要打开文件 =====================5. PHP 会话控制技术===================== 5.1 为什么要使用会话技术由于http协议是无状态的，同一个用户连续两次请求不同的页面会认为不是同一个用户进行的访问。这就有问题了 比如用户已经登录了，然后再跳转到订单页面发现自己还是未登录的状态，因此需要使用会话技术来记录用户的状态，以便知道用户是否进行了页面的跳转 5.2 cookie涉及到 cookie的函数 setcookie($name,$value,$expire,$path,$domain,$secure) //键 值 过期时间 路径 域名 安全 $_COOKIE() 读取cookie 优点：将用户的信息储存在用户的客户端不会占用服务端的资源 缺点：不安全，用户可以禁用cookie 5.3 sessionsession信息存储在服务端，客户端存的是sessionId session是基于cookie session相关的函数 session_start() //开启session $_SESSION() 获取session的值 session_destroy(); session.auto_start =; //自动开启session session.cookie_domain =; //存取的sessionId的cookie的有效域名 session.cookie_lifetime =; //cookie的过期时间i session.cookie_path =; //cookie的路径 session.session_save_path =; // session的垃圾回收机制 session.gc.probability = 1; session.gc.divisor = 100; session.gc.maxlifetime = 1440; //当前的时间-最后的修改时间 &gt; 1440 每清除一百次会有一次清除成功的机会 session.save_handle = &apos;redis&apos;; 5.4 session存储，如果有多台服务器，可以将session存储到数据库 memcache redis中session_set_save_handler(); //将session储存到redis等 =====================6. PHP面向对象===================== 6.1 PHP类的权限控制符public protected private 6.2 继承6.3 多态抽象类 有抽象方法一定是抽象类 6.4 常用的设计模式 工厂模式 单例模式 注册树模式 适配器模式 观察者模式 策略模式 =====================7.Tcp/IP协议===================== 7.1 HTTP 协议状态码1XX 2XX 成功，响应成功 200 204 206 3XX 重定向 301 302 4XX 客户端请求错误 400请求错误 401 认证信息 403 拒绝 404 not found 5XX 服务器错误 503 服务器无法处理 7.2 OSI 七层模型物理层 数据链路层 网络层 传输层 会话层 表示层 应用层 1.物理层 //建立 维护 断开物理连接 2.数据链路层 //建立逻辑连接 进行硬件物理寻址 差错校验等 3.网络层 //进行逻辑地址寻址，实现不同网络之间的选择 4.传输层 //定义传输数据协议的端口号 以及流控和差错校验 TCP UDP 5.会话层 //建立 管理 终止会话 6.表示层 //数据的表示 安全 压缩 7.应用层 //网络协议与用户的最终接口 HTTP FTP SMTP DNS HTTPS 7.3 HTTP协议工作原理1.客户端发送请求给服务端，创建一个tcp连接，指定端口号 默认为80 2.连接到服务器后，服务器会监听浏览请求，分析请求类型，返回数据和内容 Content-Type Accept Origin Cookie Cache-Control user-Agent Referrer Access-control-Allow-origin //跨域使用 7.4 HTTP的请求方法get(查看 幂等) post(非幂等 创建) put(幂等 修改) delete(幂等) (head options trace 查看服务器性能) 幂等 非幂等 get和post有什么区别 1.get后退操作不会造成影响，post后退会重新提交 2.post不能被缓存 3.get url参数有限制 4.get不安全 post比较安全 7.5 常见的网络协议和端口FTP 文件传输协议 21 TELNET 远程登录 23 SMTP 邮件发送协议 25 POP3 邮件接收协议 110 HTTP 超文本传输协议 80 DNS 域名解析 53 =====================8.PHP开发环境 （nginx + php-fpm）===================== 8.1 cgi协议 为了实现语言解析器和webserver之间的通信8.2 fastcgi是cgi的改良cgi的效率很低，webserver每收到一个请求就会fork一个cgi进程，请求处理完再kill掉这个进程，这样很浪费fastcgi 每次处理请求之后不会kill掉这个进程，保留这个进程，一个进程可以处理多个请求，不需要每次都fork 8.3 php-fpm php：fastcgi process manager fastcgi的进程管理器master进程 work进程（多个）一个进程嵌套PHP解析器 端口9000 通过nginx的反向代理，代理9000端口 8.4 PHP常见的配置项register_globals 注册全局变量,不建议打开 allow_url_fopen 打开远程文件 allow_url_include 是否远程包含文件 date_timezone 时间 display_errors error_reporting 错误级别 safe_mode 安全模式 upload_max_filesize 允许上传的文件大小 max_file_uploads 允许同时上传的数量 post_max_size 允许post上传的大小 真题：请简述cgi fastcgi 和 php-fpm的区别 cgi是一种协议，是为了实现webServer和语言解析器之间通信的协议。每当浏览器用请求出现时，webServer就会fork一个cgi进程，在这个请求处理完之后就会kill掉这个进程fastcgi是cgi协议的改良版。当webServer收到请求并且处理完之后，不会kill掉这个进程而是用来处理其他进程 php-fpm是fastcgi的进程管理器。包括master进程和work进程。通常master进程负责和网络进行通信，而且work进程负责语言解析，每一个work进程包含一语言解析器 =====================9.PHP 使用js jq vue.js等===================== 9.1 ajax技术运用了什么原理async -javascript - and - xml xMLHttpRequest()是实现ajax的基础 =====================10.PHP linux基础知识点===================== 10.1 系统安全性//sudo //su //chmod //setfacl 10.2 进程管理//w //top //ps //kill //pkill //pstree //killall 10.3 用户管理10.4 文件系统10.5 网络10.6 文件查看tail less head more 10.7 目录操作crontab**分 时 日 月 周 =====================11.Mysql相关操作点===================== 11.1 mysql数据类型tinyint smallint bigint 整数类型 int(11) 这个11只是显示的宽度，并不会影响取值范围，最小宽度 整形括号里面的数据对于大多数应用是没有意义的 实数类型 float double decimal decimal是比bigint还大的整数，但是会被当做字符串来处理varchar(可变长度，超出长度会被截断） char(固定长度，会根据需要补充空格，适合比较短的字符串，或者长度都差不多的，比如密码 唯一标识等，超出长度会被截断) text blob 对于经常变更的数据，char比varchar更好，插入不容易产生碎片，对于比较短的字符，char比varchar更有效率 进行不使用text和blob，会先查询临时表，造成不必要的开销 枚举类型 日期和时间类型 尽量使用timestamp 比 datetime 的 空间效率要高 ，如果要储存微秒，需要使用bigint 11.2 列属性auto_increment 自增 default 默认值 not null 非空 zerofill 0填充 11.3 mysql的基本操作mysql -u -h -p _P //u username h host p password P port mysql连接 \G //垂直显示 \c 取消mysql命令 \q 退出mysql \s 服务器状态 \h 帮助信息 \d 改变符号 11.4 mysql数据表引擎 InnoDb 默认事务型引擎，数据存在共享表空间可以通过配置分开 对主键查询的性能要高于其他引擎 从磁盘读取数据时自动在内存构建hash索引 插入数据自动构建缓冲区 支持行级锁 支持外键 MyISAM 5.1版本前默认的存储引擎 拥有全文检索 压缩和空间函数 不支持事务和行级锁 不支持热备份和安全 11.5 mysql的锁机制当多个查询同一时刻进行数据修改的时候，就会产生并发控制的问题，这个时候mysql会进行锁表。包括共享锁（读锁）和排它锁（互斥锁，写锁）写锁是临界资源，互斥的。同一个时候只能有一个进行写入事务处理 InnoDB 11.6 mysql触发器可以通过数据表中的中间表（外键）进行级联修改，不建议使用 11.7 mysql索引基础和类型 mysql先去索引中找到对应的值，然后根据匹配的索引找到对应的数据行大大减少服务器需要扫描的数据量，帮助服务器避免排序和临时表 将随机IO变成顺序IO 大大提升查询速度 （影响：减低写的速度 占用磁更多的磁盘空间） 对于数据量比较小的表，不要使用索引，性能会更高。对于中大型表需要使用索引。特大型的表使用索引的代价也会变大，可以使用分区技术解决 索引的类型 普通索引 唯一索引（唯一约束） 主键索引 一个表只能有一个主键索引，可以有多个唯一索引；主键索引一定是唯一索引，但是唯一索引不一定是主键索引 主键可以和外键参照建立约束，防止数据的不统一 联合索引 将多个列组合在一起构成索引，涉及到多个列，为了减低索引的范围 外键索引 全文索引（只能对英文进行全文索引，没啥意思） 11.8 mysql索引创建的规则 ！！！ 最适合做索引的列是出现在where字句里面的列，而不是select关键字后面的列 索引列的基数越大，索引的效果越好 对于字符串的索引，应该指定一个前缀长度，可以节省大量的索引空间 根据情况创建符合索引，符合索引可以大大提高查询的效率 避免创建过多的索引，索引会额外的占用磁盘空间，降低写操作的效率 主键尽可能选择较短的数据类型，可以有效减少索引占用磁盘空间，提高查询效率 注意： 符合索引遵循前缀原则 like查询，%不能在前，可以使用全文检索解决问题 where name like “wang%” column is null 可以使用索引 如果mysql估计使用索引比全表扫描更慢，会放弃使用索引 如果or前的条件有索引 后面没有，那么索引不会被用到 列类型是字符串类型，查询的时候一定要给值加引号，不然用不到索引 11.9 mysql语句的编写//关联更新 $sql = &lt;&lt;&lt;EOL UPDATE A,B SET A.c1 = B.c1,A.c2 = B.c2 WHERE A.id = B.id AND B.age &gt; 50; UPDATE A AS t1 INNER JOIN B AS t2 ON ti.id = t2.id SET t1.c1 = t2.c1,t1.c2 = t2.c2 WHERE t2.age &gt; 50; EOL; //关联查询 //六种关联查询 cross join（笛卡尔积，没有意义）、inner join、left（right） join、union（union all）、full join //内连接 等值连接 不等值连接 自连接 inner join = join inner可以省略不写 $sqlInner = &lt;&lt;&lt;EOL SELECTFROM A,B WHERE A.id = B.id AND B.id &gt; 50; SELECTFROM A t1 INNER JOIN B t2 ON t1.id = t2.id WHERE t2.age &gt; 50; SELECTFROM A t1 JOIN A t2 ON t1.id = t2.pid WHERE t1.age &gt; 50; EOL; //外连接 left join 以左表为主 和right join 以右表为主 如果匹配不到用null填充 //联合查询union 把多条结果集集中在一起，以union前的结果为准，需要注意的是联合查询的列数要相等，相同的记录行会合并 union all $sqlUnion = &lt;&lt;&lt;EOL SELECTFROM A UNION SELECTFROM B.... EOL; //全连接 mysql不支持全连接，可以使用left join 和 union 和 right join 联合使用 $sqlFull = &lt;&lt;&lt;EOL SELECTFROM A LEFT JOIN B ON A.id = B.id union SELECTFROM A RIGHT join B ON A.id = B.id; EOL; //嵌套查询 子查询 $sqlInclude = &lt;&lt;&lt;EOL SELECTFROM A WHERE (SELECT id FROM B WHERE B.age &gt; 50); EOL; //example $sqlExample = &lt;&lt;&lt;EOF SELECT t1.teamName,m.matchResult,t2.teamName,m.matchTime FROM `match` as m LEFT JOIN `team` as t1 ON t1.teamId = m.hostTeamId,left join `team` as t2 ON t2.teamId = m.guestTeamId WHERE m.matchTime between &quot;2016-6-1&quot; AND &quot;2016-9-1&quot;; EOF;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx lua 热更新原理与实战]]></title>
    <url>%2F2018%2F10%2F30%2Fcocos2dx-lua-%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[首先，如果有过cocos2dx lua开发经验的朋友都知道，为什么使用Lua而不是C++,最重要的原因就是因为下面这三个原因 热更新(在线更新代码和资源) 比C++简单很多,入门和实战 轻量级，最小最轻的脚本语言 今天就从Lua热更新，捣鼓一下其中的原理，并具体实战一下！ 什么是热更新？热更新也叫不停机更新，是在游戏服务器运行期间对游戏进行更新。实现不停机修正bug、修改游戏数据等操作。也可以这样讲：一辆车以时速150km跑着，突然爆胎了，然后司机告诉你，我不停车，你去把轮胎换了，小心点。 热更新的作用Lua模块热更新原理，能很好的支持代码热更新机制，是大部分选择要嵌入脚本语言的原因之一。好处很简单，脚本代码可以热更新的话，调试和线上解决问题都可以不用重启程序了，对开发效率有很大的帮助。 热更新原理Lua内部提供了一个require函数，来实现模块的加载，它做的事情主要是以下几个： 在registry[“_LOADED”]表中判断该模块是否已经加载过了，如果是则返回，避免重复加载某个模块代码。 依次调用注册的loader来加载模块,将加载过的模块赋值给registry[“_LOADED”]表。 而如果要实现Lua的代码热更新，其实也就是需要重新加载某个模块，因此就要想办法让Lua认为它之前没有加载过。查看Lua代码发现，registry[“_LOADED”]表，实际上对应的是package.loaded表，这在以下函数中有体现： (loadlib.c) 627 LUALIB_API int luaopen_package (lua_State *L) { 655 /* set field `loaded&apos; */ 656 luaL_findtable(L, LUA_REGISTRYINDEX, &quot;_LOADED&quot;, 2); 657 lua_setfield(L, -2, &quot;loaded&quot;); 因此事情就很简单了，需要提供一个require_ex函数，可以理解为require的增强版，使用这个函数可以动态更新某个模块的代码: function require_ex( _mname ) print( string.format(&quot;require_ex = %s&quot;, _mname) ) if package.loaded[_mname] then print( string.format(&quot;require_ex module[%s] reload&quot;, _mname)) end package.loaded[_mname] = nil require( _mname ) end 这个函数做的事情一目了然。首先判断是否曾经加载过这个模块，如果有则打印一条日志表示需要重新加载某个模块，然后将该模块原来在表中注册的值赋空，然后再次调用require进行模块的加载和注册。 热更新实现细节以上了解了Lua代码热更新的原理，但是还有一些细节需要提醒一下。 如何组织你的项目中的Lua代码？ 我在qnode中使用的方式是，单独使用一个叫main.lua的文件调用require_ex函数来加载需要用到的lua模块，而Lua虚拟机创建之后执行的是这个文件，这样的话，当你需要热更新项目中的Lua代码时，只需要重新执行这个main.lua就行了。 如何通知热更新代码呢？ 我在qnode中使用的信号机制，当服务器收到USR1信号时，通知所有工作进程，由工作进程来重新对main.lua进行重新加载，这样就完成了lua代码的热更新，为此我写了一个简单的脚本reload.sh，就是根据当前qnode的服务器进程ID来对其发送USR1信号量的。 一般热更新的都是函数的实现，所以需要对全局变量做一些保护。 比如当前某全局变量为100，表示某个操作已经进行了100次，它不能因为热更新重新置0，所以要对这些不能改变的全局变量做一个保护，最简单的方式就是这样: 1a = a or 0 很简单的原理，只有当前a这个变量没有初始值的时候才会赋值为0，而后面不管这个Lua文件被加载多少次，a都不会因为重新加载了Lua代码发生改变了。 热更新实战其实我们平时开发中，可以用简单易懂的方式来理解热更新 客户端向服务器发送请求，服务器告诉客户端，没更新，你是最新的啦，那就直接跳过喽 如果是告诉你有更新，那就要告诉我哪些需要更新对吧，你可能需要更新的东西，放在一个文件里，一并发送给客户端 客户端拿到这个文件，就一个一个去向服务器要，最后把要更新的内容都下载到本地了 cocos2dx-lua中有assetmanagerex的c++实现类，也有绑定到lua。 3.10之前有缺陷，问题是当有文件下载失败时会陷入死循环，导致业务链断裂。不过网上有解决办法，可简单修改源码解决。建议把高于3.10版本以后的assetmanagerex代码移植到旧的3.x版本，也可以选择新项目使用3.10以后版本。 网上有提到两种热更新的方法 1.只存在一套资源，用一个文件记录所有文件的信息（文件名，路径，大小，MD5）。游戏启动时下载这个文件与本地文件MD5进行对比，不同的和新增的下载下来，没有的删掉。（最好再做个简要信息文件，因为资源多了记录文件信息的文件会有上百KB大小） 2.第二种存在多套资源，客户端每更新一个版本都会有一个内部版本号。更新服务端会有多套压缩包，如1.0-1.5， 1.1-1.5 ，1.2-1.5 ，1.3-1.5，1.4-1.5。此方法需要保留每个版本的文件资源，依次生成每一个版本到最新版本的增量压缩包（依据是文件名和MD5） 但是结合实战第一种和优点是方便管理，从始到终只有一套资源。缺点是玩家下载时流量多一点，因为没有压缩。第二种优点是玩家下载流量小，但每次升级需要保留历史版本为升级依据，版本越多越不好管理。 具体代码实战local AutoUpdateScene = class(&quot;AutoUpdateScene&quot;, cc.load(&quot;mvc&quot;).ViewBase) local manifestPath = &quot;project.manifest&quot; local storagePath = &quot;update&quot; function AutoUpdateScene:onCreate() self._update_failed_count = 0 local layer = cc.Layer:create() local am = nil local function onEnter() local ttfConfig = {} ttfConfig.fontFilePath = &quot;fonts/arial.ttf&quot; ttfConfig.fontSize = 80 local progress = cc.Label:createWithTTF(ttfConfig, &quot;0%&quot;, cc.VERTICAL_TEXT_ALIGNMENT_CENTER) progress:setPosition(cc.p(display.center.x, display.center.y + 50)) layer:addChild(progress) am = cc.AssetsManagerEx:create(manifestPath, cc.FileUtils:getInstance():getWritablePath() .. storagePath) am:retain() if not am:getLocalManifest():isLoaded() then print(&quot;Fail to update assets, step skipped.&quot;) self:onFail(&quot;本地资源错误，请重新下载游戏。&quot;) else local function onUpdateEvent(event) local eventCode = event:getEventCode() print(&quot;====== assetsmanagerex error code:&quot;, eventCode) --[[ cc.EventAssetsManagerEx.EventCode = { ERROR_NO_LOCAL_MANIFEST = 0, ERROR_DOWNLOAD_MANIFEST = 1, ERROR_PARSE_MANIFEST = 2, NEW_VERSION_FOUND = 3, ALREADY_UP_TO_DATE = 4, UPDATE_PROGRESSION = 5, ASSET_UPDATED = 6, ERROR_UPDATING = 7, UPDATE_FINISHED = 8, UPDATE_FAILED = 9, ERROR_DECOMPRESS = 10 } ]] if eventCode == cc.EventAssetsManagerEx.EventCode.ERROR_NO_LOCAL_MANIFEST then print(&quot;No local manifest file found, skip assets update.&quot;) self:onFail(string.format(&quot;本地资源错误，请重新下载游戏。(错误码:%d)&quot;, eventCode)) elseif eventCode == cc.EventAssetsManagerEx.EventCode.UPDATE_PROGRESSION then local assetId = event:getAssetId() local percent = event:getPercent() local strInfo = &quot;&quot; if assetId == cc.AssetsManagerExStatic.VERSION_ID then strInfo = string.format(&quot;Version file: %d%%&quot;, percent) elseif assetId == cc.AssetsManagerExStatic.MANIFEST_ID then strInfo = string.format(&quot;Manifest file: %d%%&quot;, percent) else strInfo = string.format(&quot;%d%%&quot;, percent) end progress:setString(strInfo) self:setLoadingProgress(event:getPercentByFile()) elseif eventCode == cc.EventAssetsManagerEx.EventCode.ERROR_DOWNLOAD_MANIFEST or eventCode == cc.EventAssetsManagerEx.EventCode.ERROR_PARSE_MANIFEST then print(&quot;Fail to download manifest file, update skipped.&quot;) self:onFail(string.format(&quot;更新失败，请检查网络配置。(错误码:%d)&quot;, eventCode)) elseif eventCode == cc.EventAssetsManagerEx.EventCode.ALREADY_UP_TO_DATE or eventCode == cc.EventAssetsManagerEx.EventCode.UPDATE_FINISHED then print(&quot;Update finished.&quot;) self:onSuccess() elseif eventCode == cc.EventAssetsManagerEx.EventCode.ERROR_UPDATING then print(&quot;Asset &quot;, event:getAssetId(), &quot;, &quot;, event:getMessage()) -- self:onFail(string.format(&quot;更新资源失败，请检查网络后重试。(%d)&quot;, eventCode)) elseif eventCode == cc.EventAssetsManagerEx.EventCode.UPDATE_FAILED then print(&quot;Fail to download resource files.&quot;) self._update_failed_count = self._update_failed_count + 1 if self._update_failed_count &lt;= 3 then print(&quot;try again&quot;) am:downloadFailedAssets() else self:onFail(string.format(&quot;更新失败，请检查网络配置。(错误码:%d)&quot;, eventCode)) end elseif eventCode == cc.EventAssetsManagerEx.EventCode.NEW_VERSION_FOUND then print(&quot;new version found.&quot;) --am:update() elseif eventCode == cc.EventAssetsManagerEx.EventCode.ASSET_UPDATED then print(&quot;assets updated.&quot;) elseif eventCode == cc.EventAssetsManagerEx.EventCode.ERROR_DECOMPRESS then print(&quot;decompress error.&quot;) end end local listener = cc.EventListenerAssetsManagerEx:create(am, onUpdateEvent) cc.Director:getInstance():getEventDispatcher():addEventListenerWithFixedPriority(listener, 1) am:update() --am:checkUpdate() end end local function onExit() am:release() end local function onNodeEvent(event) if &quot;enter&quot; == event then onEnter() elseif &quot;exit&quot; == event then onExit() end end layer:registerScriptHandler(onNodeEvent) self:addChild(layer) end function AutoUpdateScene:onFail(msg) print(&quot;====== update fail ======&quot;, msg) -- 热更新失败处理 end function AutoUpdateScene:onSuccess() print(&quot;====== update success ======&quot;) local writablePath = cc.FileUtils:getInstance():getWritablePath() package.path = writablePath .. &quot;update/src/?.lua;./?.lua;&quot; -- 启动热更新后的场景 end return AutoUpdateScene 推荐 https://blog.csdn.net/weixin_37730482/article/details/73299286 https://blog.csdn.net/qq_32319583/article/details/53223452 https://blog.csdn.net/q277055799/article/details/8463835?utm_source=blogxgwz3**]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>事件</tag>
        <tag>cocos2dx lua 热更新原理与实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx lua 多线程之协成理解与实战]]></title>
    <url>%2F2018%2F10%2F29%2Fcocos2dx-lua-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%8D%8F%E6%88%90%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[lua是不支持多线程的，一般都是协同来调用的。但是lua却可以调用c函数。于是，我们通过lua调用C接口起一个线程，实现lua多线程的使用。子线程再调用lua中的function。就可以通过子线程获取一些数据。单纯的人儿，以为一切都是美好的。 问题就出现C调用lua中的function, 将数据传给lua。 lua的运行首先我们需要知道，lua是解释性语言。是在执行的时候才分配堆栈空间。通过查看lua的源码，我们可以知道，在main函数的开端，lua就创建了一个全局的L（状态机），这个状态机可以说是lua的核心所在。它保存了栈的地址。 当执行lua脚本时，lua会将全局的变量和function记录在堆中，当执行代码段是，就会将一些局部变量和参数压到栈中进行处理。这一切和c语言的解析是一样的。 我们知道C也是可以调用lua的function的，一般的操作是： 在lua中调用C函数，将需要注册的function，作为参数传给C函数 C将获取到的function和L（状态机）进行保存。 C通过向L压栈，将function和一些参数压入。通过lua_call函数进行调用。 根据上述的解释，我们可以知道。其中C和lua通过通信的是L（状态机）。压入栈之后，通过lua_call,就会进入lua的状态中。lua会处理栈中的内容。 问题所在核心问题就是C调用lua的L和lua的L是同一个L。这样就出现一个问题，当主线程的lua脚本才进行压栈操作，而子线程中也进行压栈操作，那岂不是乱了套？在一开始就不应该成功的，为什么会这样呢？通过查看代码，发现lua对进行堆操作的函数中，都加上了线程锁。当主线程进行栈操作时，子线程是不可以对栈进行操作的。 也就是说，子线程理论上是不会运行的，会卡在栈操作的函数那里。 但是为什么我们在运行的时候并没有出现这个现象呢？通过代码的查询，发现是主线程中有sleep函数，并且子线程中有阻塞，所以能够在几个线程中切换。 如果主线程的while循环中没有sleep，那么就会很快的出现问题。因此，lua从底层就是不支持多线程的。 为什么使用协同如果你搜索lua多线程，大多数都会写搜索到协同程序。 每一个协程有自己的堆栈，自己的局部变量，可以通过yield-resume实现在协程间的切换。不同之处是：Lua协程是非抢占式的多线程，必须手动在不同的协程间切换，且同一时刻只能有一个协程在运行。并且Lua中的协程无法在外部将其停止，而且有可能导致程序阻塞。 正如上诉，协同拥有自己的堆栈，那是用来避免和其他堆栈冲突的。但是两者之间想要通信，就不能通过栈了。因为栈的不同，压入的数据在另一端是无法接收到的。 但是，我们可以通过一个全局变量进行通信。比如，子线程通过协同的堆栈进行调用lua里面的function。在function中获取传入的值，将它赋值给一个全局变量。那么主线程也能够调用了。 线程与协同协同程序与线程thread差不多，也就是一条执行序列，拥有自己独立的栈、局部变量和命令指针，同时又与其他协同程序共享全局变量和其他大部分东西。可以通过yield-resume实现在协程间的切换。 从概念上讲线程与协同程序的主要区别在于，一个具有多个线程的程序可以同时运行几个线程，而协同程序却需要彼此协作的运行。也就是说多个协同程序在任意时刻只能运行一个协同程序，只有当正在运行的协同程序显式的要求挂起时，它的执行才会暂停。 总结区别： 不同之处是：Lua协程是非抢占式的多线程，必须手动在不同的协程间切换，且同一时刻只能有一个协程在运行。并且Lua中的协程无法在外部将其停止，而且有可能导致程序阻塞。 关于更多区别和介绍，可以查看这里 https://www.cnblogs.com/work115/p/5620272.html https://www.cnblogs.com/lxmhhy/p/6041001.html 协同程序coroutineLua将所有关于协同程序的函数放置在一个名为“coroutine”的table中。 1、coroutine.create创建一个thread类型的值表示新的协同程序，返回一个协同程序。 2、coroutine.status检查协同程序的状态（挂起suspended、运行running、死亡dead、正常normal）。 3、coroutine.resume启动或再次启动一个协同程序，并将其状态由挂起改为运行。 4、coroutine.yield让一个协同程序挂起。 5、coroutine.wrap同样创建一个新的协同程序，返回一个函数。 注意coroutine的三个状态：suspended（挂起，协同刚创建完成时或者yield之后）、running（运行）、dead（函数走完后的状态，这时候不能再重新resume）。 创建协同程序：create函数，接受一个函数值作为协同程序的执行内容，并返回一个协同程序。 function func( ... ) print(&quot;iCocos&quot;) -- thread: 0x79f721d4 -- [Finished in 0.0s] end local cor = coroutine.create(func) print(cor) 启动或再次启动一个协同程序：resume函数，接受一个协同程序及一个或多个参数用于值传递给协同程序。 function funcA( _cor, ... ) print(&quot;A: status_1&quot;,coroutine.status(_cor), ...) -- A: status_1 running 1 2 3 end local corA = coroutine.create(funcA) coroutine.resume(corA, corA, 1,2,3) print(&quot;A: status_2&quot;, coroutine.status(corA)) -- A: status_2 dead resume-yield数据交换Lua中协同的强大能力，还在于通过resume-yield来交换数据： （1）resume把参数传给程序（相当于函数的参数调用）； （2）数据由yield传递给resume; （3）resume的参数传递给yield； （4）协同代码结束时的返回值，也会传给resume 协同中的参数传递形势很灵活，一定要注意区分，在启动coroutine的时候，resume的参数是传给主程序的；在唤醒yield的时候，参数是传递给yield的。 挂起协同程序：yield函数，让一个协同程序挂起，并等待下次恢复它的运行。它可以接受resume函数传递进来的所有参数。 -- resume yield 参数传递 function funcB( _cor ) print(&quot;A: status_1&quot;, coroutine.status(_cor)) ptint(&quot;A: status_2&quot;, coroutine.yield()) -- 挂起 end local funcB = coroutine.create(funcB) -- wrap: wrap函数比create函数更易使用。它提供了一个对于协同程序编程实际所需的功能，即一个可以唤醒协同程序的函数。但也缺乏灵活性。无法检查wrap所创建的协同程序的状态，此外，也无法检测出运行时的错误。 coroutine.resume(funcB, funcB) -- 启动，没有yield，参数属于主函数 print(&quot;A: status_3&quot;, coroutine.status(funcB)) coroutine.resume(funcB, 1,2,3) -- 从挂起出启动，并给yield传递参数 print(&quot;A: status_4&quot;, coroutine.status(funcB)) Lua提供的是一种：”非对称的协同程序“。也就是说，Lua提供了两个函数来控制协同程序的执行，一个用于挂起执行，另一个用于恢复执行。而一些其他的语言则提供了”对称的协同程序“，其中只有一个函数用于转让协同程序之间的执行权。 管道与过滤器filter关于协同程序的示例就是”生产者–消费者“的问题。其中涉及到两个函数，一个函数不断的产生值，另一个函数不断的消费这些值。 当消费者需要一个新的值时，它唤醒生产者。生产者返回一个新值后停止运行，等待消费者的再次唤醒。这种设计称为”消费者驱动“。通过resume—yield 函数之间的值交换可以轻易的实现程序。 过滤器filter，是一种位于生产者与消费者之间的处理功能，可以进行数据转换。它既是消费者又是生产者，它唤醒生产者促使其生产新值，然后又将变换后的值传递给消费者。 --管道与过滤器filter --生产者与消费者通过过滤器进行值传递 --这种模式通过消费者驱动生产者进行产生。 --计数器函数 function getCount( x ) return function() x=x+1 return x end end --创建闭合计数器 local count = getCount(0) --发送新值 function send(x) coroutine.yield(x) end --启动一个协同程序 function receive( pro ) local status,value = coroutine.resume( pro ) return value end --生产者 function producter() while true do send( count() ) end end --过滤器，接受一个生产者 function filter( pro ) local x = 0 return function() while true do x = receive( pro ) send(x) end end end --消费者，接受一个生产者协同程序及控制条件，控制条件防止死循环 --假设有100个消费者，驱动生产者来生产 function consumer( pro,num ) local x = 0 while x &lt; num do x = receive( pro ) print( x ) end end local pro = coroutine.create( producter ) local fil = coroutine.create( filter( pro ) ) consumer( fil,100 ) print( &quot;消费者协同程序状态：&quot;,coroutine.status(pro) ) print( &quot;生产者协同程序状态：&quot;,coroutine.status(fil) ) 打印结果 1 2 3 ... -- 消费者协同程序状态： suspended -- 生产者协同程序状态： suspended 推荐 https://github.com/lichuang/Lua-Source-Internal/blob/master/doc/ch09-%E5%8D%8F%E7%A8%8B.md]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>事件</tag>
        <tag>cocos2dx lua 多线程之协成理解与实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx lua 安全之加密与解密实现]]></title>
    <url>%2F2018%2F10%2F27%2Fcocos2dx-lua-%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[非常多使用cocos2dx+lua做游戏的同学。都会想到一个问题，我的游戏一旦公布，如何才干保证的我脚本代码不被破解。不泄露代码。尽管这和开源、共享的原则不合。可是代码也是coder的劳动成果，理应得到保护。 特别是商业游戏更是如此，不希望被别人破解掉源代码而且进行改动。 今天的话题就是怎样实现lua脚本文件的加密和解密。 我在网络上查过，都没有成熟的解决方式。然后我经过考虑之后，总结出两种解决方式，供大家參考。 1、轻量级的解决方式。APK打包之前，用工具把全部的lua文件加密，详细是将lua文件读到内存，然后使用zip等压缩加密库进行压缩加密，然后将压缩加密之后的数据保存为和源文件同名的文件。 打包之后执行lua文件的时候。则先读出lua数据。然后进行解密。将解密后的流数据传给lua虚拟机。 2、重量级的解决方式，此方案是上一种方案的扩展。也是商用游戏的方案，实现一个游戏文件包，打包前将资源和脚本都使用工具打包到一个文件。能够在打包的时候加密压缩，也能够不加密压缩。 然后在执行的时候直接从包内读出对应文件的数据。然后解密解压缩。然后提供给游戏引擎使用。这也是端游普遍使用的技术，手游眼下大部分也開始使用此技术。 本文主要简要解说第一种方案，另外一种方案则有时间再写一篇博客。好了。我们開始进入正题吧。 首先是压缩lua文件。代码例如以下： int write_file_content(const char* folder) { //获得文件数据，并压缩文件 FILE* fpin = fopen(folder, &quot;wb+&quot;); if (fpin == NULL) { printf(&quot;无法读取文件: %s\n&quot;, folder); return 0; } //得到文件大小 fseek(fpin, 0, SEEK_END); unsigned int size = ftell(fpin); //读出文件内容 fseek(fpin, 0, SEEK_SET); void* con = malloc(size); int r = fread(con, size, 1, fpin); //进行加密操作 unsigned long zip_con_size = size * 2; void* zip_con = malloc(zip_con_size); if (Z_OK != compress((Bytef*)zip_con, &amp;zip_con_size, (Bytef*)con, size)) { printf(&quot;压缩 %s 时错误发生\n&quot;,folder); } printf(&quot;%s 压缩前大小：%ld 压缩后大小：%ld\n&quot;, folder, size, zip_con_size); //写文件内容 fseek(fpin, 0, SEEK_SET); int len = fwrite(zip_con, zip_con_size, 1, fpin); //释放资源 fclose(fpin); free(zip_con); free(con); return 0; } 然后是解密操作。代码例如以下： void* read_file_content(const char* folder, int&amp; bufflen) { FILE* file = fopen(folder, &quot;wb+&quot;); if (file) { { printf(&quot;无法读取文件: %s\n&quot;, folder); return 0; } //获取文件大小 fseek(file, 0, SEEK_END); unsigned int size = ftell(file); //读出文件内容 void* con = malloc(size); fseek(file, 0, SEEK_SET); int len = fread(con, size, 1, file); //解压缩操作 unsigned long zip_size = size * 4; void* zip_con = malloc(zip_size); int code = uncompress((Bytef*)zip_con, &amp;zip_size, (Bytef*)con, size); if (Z_OK != code) { printf(&quot;解压 %s 时错误发生 :%d\n&quot;, folder, code); return 0; } //释放资源 fclose(file); free(con); //zip_con由外部释放 bufflen = zip_size; return zip_con。 } 最后就把此流文件塞给lua的虚拟机就可以，即以流方式执行lua代码。 当然更高级一点的方法是直接改写lua的文件载入策略]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>事件</tag>
        <tag>cocos2dx lua 安全之加密与解密实现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx lua (伪)面向对象理解与实战应用]]></title>
    <url>%2F2018%2F10%2F24%2Fcocos2dx-lua-%E4%BC%AA-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[面向对象 &gt;&gt; 把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class） &gt;&gt; 通过类的封装（encapsulation）隐藏内部细节 &gt;&gt; 通过继承（inheritance）实现类的特化（specialization）／泛化（generalization） &gt;&gt; 通过多态（polymorphism）实现基于对象类型的动态分派（dynamic dispatch） 1.lua中的类lua中其实是没有类的，有的只是表(table)，而类之间的继承也就是将父类的表连到了一起，派生类中没有找到的属性和方法就通过元表查找父类 2.lua中类的属性classA = {width =10, height=10} classA={} classA.width=10 classA.height=10 两种方法都可以，通过点self.width统一调用 3.类方法[cpp] view plaincopy function Box:collsion() -- 默认第一个参数隐藏传递self，可以通过self.xxx 调用属性和方法 end function Box.create(self) --必须手动传递参数self,否则无法用self.xxx调用属性和方法 end 4.类与元表的用法 lua查找一个表元素时的规则，其实就是如下3个步骤: 4.1.在表中查找，如果找到，返回该元素，找不到则继续 4.2.判断该表是否有元表，如果没有元表，返回nil，有元表则继续 4.3.判断元表有没有index方法，如果index方法为nil，则返回nil；如果index方法是一个表，则重复1、2、3；如果index方法是一个函数，则返回该函数的返回值 在Lua中，函数的声明和调用可以用”:”和”.”，属性调用全部用点”.” 我们知道，对象由属性和方法组成。LUA中最基本的结构是table，所以需要用table来描述对象的属性。 lua中的function可以用来表示方法。那么LUA中的类可以通过table + function模拟出来。 至于继承，可以通过metetable模拟出来（不推荐用，只模拟最基本的对象大部分时间够用了）。 Lua中的表不仅在某种意义上是一种对象。像对象一样，表也有状态（成员变量）；也有与对象的值独立的本性，特别是拥有两个不同值的对象（table）代表两个不同的对象；一个对象在不同的时候也可以有不同的值，但他始终是一个对象；与对象类似，表的生命周期与其由什么创建、在哪创建没有关系。 1. 初步面向对象ObjectData = {balance = 0} function ObjectData.count( v ) -- body print(&quot;value is :&quot;, v) end a = ObjectData a.count(&quot;iCocos&quot;) -- value is : iCocos 2. 面向对象模拟ObjectData = {balance = 100} function ObjectData.count( self, v ) self.balance = self.balance + v print(&quot;value is :&quot;, v, self.balance) end a = ObjectData a.count(a, 99) -- 传递self -- value is : 99 199 a:count(99) -- 不传self，直接把a作为self传递进入， -- value is : 99 298 Lua中的继承先来定义一个基类，使用前面讲的setmetatable来实现基本的元表 local _M = {} function _M:new(name) return setmetatable({ name = name}, { __index = _M }) end function _M:show() print(self.name .. &quot;: show in parent:&quot;) end function _M:hello(arg) print(self.name .. &quot;: hello in parent:&quot; .. tostring(arg)) end return _M 子类的实现local parent = require(&quot;parent&quot;) local _M = {} function _M:new() local obj = parent:new(&quot;the child&quot;) local super_mt = getmetatable(obj) -- 当方法在子类中查询不到时，再去父类中去查找。 setmetatable(_M, super_mt) -- 这样设置后，可以通过self.super.method(self, ...) 调用父类的已被覆盖的方法。 obj.super = setmetatable({}, super_mt) return setmetatable(obj, { __index = _M }) end -- 覆盖父类的方法。 function _M:hello() -- 只能使用这种方法调用基类的方法。 self.super.hello(self, &quot;call from child&quot;) print(tostring(self.name) .. &quot;: hello in child&quot;) end return _M test.lua (使用) -- local parent = require(&quot;parent&quot;) local child = require(&quot;child&quot;) local c = child:new() -- 从parent继承的show方法 c:show() -- child自己的方法。 c:hello() 执行lua test.lua 后 输出： the child: show in parent: the child: hello in parent:call from child the child: hello in child 可以看到： show是继承了父类的方法。 hello是由子类覆盖了，并且在hello中调用了父类的hello方法。]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>cocos2dx lua (伪)面向对象理解与实战应用</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx lua cc & ccs & ccui区别和使用]]></title>
    <url>%2F2018%2F10%2F22%2Fcocos2dx-lua-cc-ccs-ccui%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[最近遇到一个问题，网上一些教程，或者官方的一些教程，在对应使用cc，ccs ,ccui的时候，导致我这边没有提示，开始以为是编辑器的问题，然后硬写上去之后，在调试的时候直接报错，经过多次查看Api文档发现，我使用的Api中，并没有这个方法，那么问题来了！ 我应该怎么去调用这个对应的Api呢？ 如何验证使用cocos2dx lua调用Api是正常的呢？ 遇到一个功能或者一个需求，应该如何查找对应的Api呢？ 网上有个朋友说了这么一段原话： 同一个框架里Api名字大小不统一我也就忍了（setBackGround…和setBackground…），可是同一个类名却表达两个不同的东西这个实在让我非常气愤，刚才瞎研究半天ScrollView才发现我程序里用的是ccui.ScrollView对象，而我盯着cc.ScrollView看了半天，我说怎么Api对不上号！ 其实大概的意思就是cocos2dx lua对应Api版本号的问题,因为以前cocos用cocos2d-lua写，后来带领大家往quick转，现在合并之后，又带领大家回到cocos2d-lua，所以必定会产生一些规范和版本号的区别。 尤其在2.x和3.x之间的变化比较大，或者是quick版本和整合版的多种调整。 这里主要介绍关于cc，ccs ,ccui的区别，使用和注意点，如果要了解更多2.x和3.x版本之前的问题和区别，可以参考这里： cocos2d-x v3.0 Release Notes cc &amp; ccs &amp; ccui经过可靠资料和官方提供的信息我们可以得出一个大概的结论： cc代表Cocos核心: Cocos2DConstants.lua 储存 ccs代表CocoStudio: StudioConstants.lua 储存 ccui代表CocoStudio的UI控件: GuiConstants.lua 储存 cc和ccui倒是很好理解，那么ccs这么理解呢？ 其实应该说相当于C++的命名空间，ccs是cocostudio的缩写，代表在CocoStudio的命名空间（只是类似）。 比如我们发现 之前的cc.ui.xxx是quick自己封装过的控件， 而ccs里面的对象是c++里面的原生控件 若使用cc.ui.xxx将出现在ccs里面有交互的时候无法响应touch事件的问题 必须用ccui.xxx，这个是c++里面的控件，touchEvent也是同一体系的。 并且ccui.ScrollView 对应 cocos2d::ui::ScrollView，cc.ScrollView 对应 cocos2d::extension::ScrollView 我们来看看，最简单而且最常用的Button按钮的创建：这是老版的(quick)cc.ui.UIPushButton.new({ normal = &quot;comm_btnGreenBackBack.png&quot;, pressed = &quot;comm_btnGreenBackBack_sel.png&quot; }) :onButtonClicked(function() print(&quot;start&quot;) end) :pos( display.cx / 2, display.cy ) :addTo(self) 在Quick中有三种不同的Button控件，分别是：UIPushButton (按钮控件)、UICheckBoxButton ( CheckButton 控件)和 UICheckBoxButtonGroup ( CheckButton 组控件)。 其中 UIPushButton 是最常用的按钮控件，它继承自UIButton，我们可以通过 cc.ui.UIPushButton.new(images, options) 方法来创建 UIPushButton。 参数 images 是 table 类型，它代表各个按钮状态（正常、按下、禁用）下的图片；options 为可选参数，也是 tabl e类型，包含了是否scale9缩放，偏移flipX、flipY值等设置。 onButtonClicked 方法用于监听按钮的点击事件，当点击按钮时，将调用该方法中的代码。如上例中，当我们点击按钮时，会在控制台窗口中打印“start”的字段。同 onButtonClicked 方法类似的还有： onButtonPressed(callback)：用于监听按钮的按下事件 onButtonRelease(callback)：用于监听按钮的释放事件 onButtonStateChanged(callback)：用于监听按钮的状态改变事件 新版本Button --这是一个按钮 local btn = ccui.Button:create(&quot;button/btnDog_N.png&quot;, &quot;button/btnDog_P.png&quot;, &quot;button/btnDog_D.png&quot;, 0) :pos(display.cx, 100) :addTo(self) --按钮文字 btn:setTitleText(&quot;按钮&quot;) --字体大小 btn:setTitleFontSize(25) --偏移 btn:setTitleOffset(20, 100) --字体颜色 btn:setTitleColor(cc.c3b(255, 255, 255)) --按钮的回调函数 btn:addTouchEventListener(function(sender, eventType) if (0 == eventType) then print(&quot;pressed&quot;) elseif (1 == eventType) then print(&quot;move&quot;) elseif (2== eventType) then print(&quot;up&quot;) elseif (3== eventType) then print(&quot;cancel&quot;) end end) --按钮无效 --btn:setEnabled(false) 以上就是基本按钮的创建，所以平时在开发中要注意一下API的问题，不然很多错误都不知道问题出在哪里！ 在我们平时使用控件的时候，也同样会遇到一些问题，比如 quick中的cc.ui.UIPushButton和ccui.Layout是不能共存的，在layout存在的情况下UIPushButton是不能被监听到的 如果在quick中使用ccui.Button，那么ccui.Button是不能被屏蔽的，也就是说，无论quick中怎么处理不让ccui.Button被点击都无效，只要他存在，就会被点击。 同时cc.ui.UIScrollView也存在问题，其不能被缩放，但是其父节点可以缩放。 cc.ui.UIListView也存在不能缩放的问题。 也就是说，以上API中，一旦按设计的分辨率来设计，就不能再被缩放。 Api官方文档验证为了验证这个问题我们查看官方文档发现这样的内容： Misc Api changes Use cc、ccs、ccui gl and sp as module name Now classes are bound into different modules instead of using global module. This will avoid conflicts with other codes. classes in cocos2d、cocos2d::extension、CocosDenshion and cocosbuilder were bound to cc module classes in cocos2d::ui were bound to ccui module classes in spine were bound to sp module classes in cocostudio were bound to ccs module global variables are bound to corresponding modules all funcionts and constants about openGl were bound to gl module Examples: | v2.1 | v3.0 | | CCDirector | cc.Director | | CCArmature | ccs.Armature | | kCCTextAlignmentLeft | cc.kCCTextAlignmentLeft | 最终所表达的意思其实就是 现在，类被绑定到不同的模块中，而不是使用全局模块。这将避免与其他代码发生冲突。 CCOS2D、COCOS2D:：扩展、COCOSDENSHION和COCOSUBIDER绑定到CC模块 CCOS2D:：UI绑定到CCUI模块 脊柱类与SP模块结合 COStudio中的类绑定到CCS模块 全局变量绑定到相应模块。 OpenGL的所有函数和常数都绑定到GL模块。 OpenGL和SP可以忽略 实战与代码验证最后，我们为了cc，ccs，ccui专门去寻找了一些关于Api所提供的支持和规律。 cc在Cocos2dConstants.lua中,用来存储cc 模块的常量cc = cc or {} 并且每个可调用的文件对应的最前面也有同样的定义,比如有 Action.lua Animation.lua Director.lua EventDispatcher.lua GLView.lua Hide.lua Image.lua Node.lua Scene.lua Scheduler.lua SpriteFrame.lua SpriteFrameCache.lua TextureCache.lua Timer.lua Touch.lua UserDefault.lua src/cocos/cocos2d/Cocos2d.lua src/cocos/cocos2d/Cocos2dConstants.lua src/cocos/controller/ControllerConstants.lua …… ccs在StudioConstants.lua中,用来存储ccs模块的常量ccs = ccs or {} 并且每个可调用的文件对应的最前面也有同样的定义,比如有 ActionFrame.lua ActionObject.lua Armature.lua Bone.lua ColorFrame.lua ComAttribute.lua ComController.lua Frame.lua Skin.lua TextureFrame.lua Timeline.lua VisibleFrame.lua …… ccui在GuiConstants.lua中,用来存储ccui模块的常量ccui = ccui or {} 并且每个可调用的文件对应的最前面也有同样的定义,比如有 Button.lua CheckBox.lua EditBox.lua Helper.lua ImageView.lua Layout.lua ListView.lua LoadingBar.lua PageView.lua ScrollView.lua Slider.lua Text.lua TextField.lua …… 推荐 https://blog.csdn.net/blackzhangwei/article/details/80088314?utm_source=blogxgwz0 cocos2d-x_v3.0_release_notes.md C++11 新特性]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>游戏</tag>
        <tag>cocos2dx lua cc &amp; ccs &amp; ccui区别和使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx lua 常见错误汇总与解决方案]]></title>
    <url>%2F2018%2F10%2F21%2Fcocos2dx-lua-%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E6%B1%87%E6%80%BB%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[cocos2dx lua开比较苦恼的是，没办法断点或者直接一步一步调试处理，但是幸好官方有点良心，给了一个打印的调试Log，我们可以使用它调试和查找对应的错误。 这里就记录一些，个人学习和实战中遇到的一些错误和问题的总结 not found view “ApiTest” in search paths “app.views” ApiTest不在Views里面或者名字写错了，或者没有初始化 attempt to index upvalue ‘HttpSingleton’ (a boolean value) 末尾没有返回HttpSingleton attempt to index local ‘self’ (a nil value) 参数传错了或者将逗号(.)与冒号(:)搞混了 attempt to call method ‘schedulerScriptFunc’ (a nil value) 方法写错了 attempt to call global ‘getScheduler’ (a nil value) 代码或者语法错误 syntax error during pre-compilation 严重的语法错误 invalid ‘cobj’ in function ‘lua_cocos2dx_Node_getLocalZOrder’ 这个报错是lua的变量还在，但是他底层对应的C++对象已被销毁。 InterpolationMissingOptionError: Bad value substitution: 在执行genbindings.py脚本文件时，不要在该文件的外部路径执行，需要CD到该文件目录下执行./genbindings.py TranslationUnitLoadError: Error parsing translation unit. 基本都是.ini文件没有配置正确，仔细检查一下 .ini文件里的 “headers = ”指向的路径是否正确 Xcode编译错误，header error 再此外，把.hpp和.cpp加进cocos2d_lua_bindings.xcodeproj时，target需要勾选ios。在设置 UserHeaderSearchPaths 时，注意选择该proj的Ios target进行设置 ，不要选择了mac target 选项，否则ios环境编译不过 mportError: No module named yaml 安装了yaml模块，如果还是报错找不到这个模块，这个就是是路径问题，因为我从新安装了python，然而：这里使用的python是系统默认的#!/usr/bin/python，处理好python版本和当前匹配的版本 网上说还有其他方式解决(待验证) import sys sys.path.append(‘/xxx/xxxxx/‘) 加进去也行。 attempt to perform arithmetic on local ‘x’ (a nil value) 忘了记录….. 这里专门说需要关于cocos2dx lua开发中的错误，其实cocos2dx lua中也和iOS中一样，分为两种错误：编译时错误和运行时错误 编译错误，一般是语法上存在问题，编译过不去; 运行错误，是指程序在运行过程中出现错误，只能说是程序存在一定的边界bug; 编译时错误和运行时错误编译错误，比如上面一条 error:syntax error during pre-compliation 就属于编译语法错误，这里报错其实还会有一些提示信息，如果我们可以通过提示信息，找到LuaStack，在LuaStack中有个LuaStack::luaLoadBuffer(…)，然后查看源码如下： switch (r) { case LUA_ERRSYNTAX: // 编译出错 CCLOG(&quot;[LUA ERROR] load \&quot;%s\&quot;, error: syntax error during pre-compilation.&quot;, chunkName); break; case LUA_ERRMEM: // 内存分配错误 CCLOG(&quot;[LUA ERROR] load \&quot;%s\&quot;, error: memory allocation error.&quot;, chunkName); break; case LUA_ERRRUN: // 运行错误 CCLOG(&quot;[LUA ERROR] load \&quot;%s\&quot;, error: run error.&quot;, chunkName); break; case LUA_YIELD: // 线程被挂起 CCLOG(&quot;[LUA ERROR] load \&quot;%s\&quot;, error: thread has suspended.&quot;, chunkName); break; case LUA_ERRFILE: CCLOG(&quot;[LUA ERROR] load \&quot;%s\&quot;, error: cannot open/read file.&quot;, chunkName); break; case LUA_ERRERR: // 运行错误处理函数时发生错误 CCLOG(&quot;[LUA ERROR] load \&quot;%s\&quot;, while running the error handler function.&quot;, chunkName); break; default: CCLOG(&quot;[LUA ERROR] load \&quot;%s\&quot;, error: unknown.&quot;, chunkName); } 所以，无论怎样，出现错误时，都能将错误信息返回到堆栈的最顶层 如果遇到编译错误是，可以通过如下的代码来打印错误信息：在以上{}之外的后面加const char* error = lua_tostring(L, -1); CCLOG(&quot;[LUA ERROR] error result: %s&quot;,error); lua_pop(L, 1); 运行错误而针对于运行错误，一般情况下，你可以参考如下代码(此代码在main.lua中)： -- lua提供，调用其他函数，可以捕捉到错误，第一个参数为要调用的函数， 第二个参数为捕捉到错误时所调用的函数 -- 返回的参数status为错误状态， msg为错误信息 local status, msg = xpcall(main, __G__TRACKBACK__) if not status then print(msg) end 推荐 http://www.cocoachina.com/bbs/read.php?tid=200145 https://blog.csdn.net/msdb198901/article/details/52128175]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>事件</tag>
        <tag>cocos2dx lua 常见错误汇总与解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx lua TableView(ScrollView, ListView)介绍与使用实战]]></title>
    <url>%2F2018%2F10%2F19%2Fcocos2dx-lua-TableView-ScrollView-ListView-%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[在众多移动应用中，能看到各式各样的列表/表格数据 不管是iOS中的UITableView/UICollectionView/UIScrollView,还是Android中的ListView/CircleView，都是实际项目开发中使用最平凡，也是最重要的功能。 为了用户考虑，也为了性能考虑， 我们一般都会重复利用所创建的列表项，这样就避免了界面卡顿。cocos2dx lua 3.x中有一个TabeView，效果和上面列举的那些做列表的一样，尤其与iOS中UITableView方法属性，使用方式都有很多相似的地方。 游戏开发中，虽然没有和普通应用那么多列表，但是也会有些消息列表，用户，排行榜等，所以，这篇我们就来看看如何用TableView以及解决在实际开发中的一些问题。 TableView使用直接上代码，这里我们使用cocos2dx lua提供TableView实现水平和垂直的列表，基本满足常见功能，具体细节，可以根据注释或者代码逻辑，结合实际需求进行调整和优化 local TableScene = class(&quot;TableScene&quot;) TableScene.__index = TableScene --这里是为了让layer能调用TableViewTestLayer的方法 function TableScene.extend(target) local t = tolua.getpeer(target) if not t then t = {} tolua.setpeer(target, t) end setmetatable(t, TableScene) return target end --滚动事件 function TableScene.scrollViewDidScroll(view) --print(&quot;滚动事件&quot;) end function TableScene.scrollViewDidZoom(view) print(&quot;scrollViewDidZoom&quot;) end --cell点击事件 function TableScene.tableCellTouched(table,cell) print(&quot;点击了cell：&quot; .. cell:getIdx()) end --cell的大小，注册事件就能直接影响界面，不需要主动调用 function TableScene.cellSizeForTable(table,idx) return 150,150 end --显示出可视部分的界面，出了裁剪区域的cell就会被复用 function TableScene.tableCellAtIndex(table, idx) local strValue = string.format(&quot;%d&quot;,idx) print(&quot;数据加载&quot;..strValue) local cell = table:dequeueCell() local label = nil if nil == cell then print(&quot;创建了新的cell&quot;) cell = cc.TableViewCell:new() --添加cell内容 local sprite = display.newSprite(&quot;res/apple.png&quot;) sprite:setAnchorPoint(cc.p(0,0)) sprite:setPosition(cc.p(0, 0)) cell:addChild(sprite) label = cc.Label:createWithSystemFont(strValue, &quot;Helvetica&quot;, 40) label:setPosition(cc.p(0,0)) label:setAnchorPoint(cc.p(0,0)) label:setColor(cc.c3b(255,0,0)) label:setTag(123) cell:addChild(label) else print(&quot;使用已经创建过的cell&quot;) label = cell:getChildByTag(123) if nil ~= label then label:setString(strValue) end end return cell end --设置cell个数，注册就能生效，不用主动调用 function TableScene.numberOfCellsInTableView(table) return 100 end function TableScene:init() local visiableSize = cc.Director:getInstance():getVisibleSize() local origin = cc.Director:getInstance():getVisibleOrigin() local winSize = cc.Director:getInstance():getWinSize() local isVERTICAL = false if isVERTICAL then ----------------------------------------------------------- --创建TableView local tableView = cc.TableView:create(cc.size(winSize.width - 20,150)) --设置滚动方向 水平滚动 tableView:setDirection(cc.SCROLLVIEW_DIRECTION_HORIZONTAL) tableView:setPosition(cc.p(10, winSize.height / 2)) tableView:setDelegate() self:addChild(tableView) --registerScriptHandler functions must be before the reloadData funtion --注册脚本编写器函数必须在reloadData函数之前（有道自动翻译） --cell个数 tableView:registerScriptHandler(TableScene.numberOfCellsInTableView,cc.NUMBER_OF_CELLS_IN_TABLEVIEW) --滚动事件 tableView:registerScriptHandler(TableScene.scrollViewDidScroll,cc.SCROLLVIEW_SCRIPT_SCROLL) tableView:registerScriptHandler(TableScene.scrollViewDidZoom,cc.SCROLLVIEW_SCRIPT_ZOOM) --cell点击事件 tableView:registerScriptHandler(TableScene.tableCellTouched,cc.TABLECELL_TOUCHED) --cell尺寸、大小 tableView:registerScriptHandler(TableScene.cellSizeForTable,cc.TABLECELL_SIZE_FOR_INDEX) --显示出可视部分的cell tableView:registerScriptHandler(TableScene.tableCellAtIndex,cc.TABLECELL_SIZE_AT_INDEX) --调用这个才会显示界面 tableView:reloadData() ----------------------------------------------------------- else ----------------------------------------------------------- --跟上面差不多，这里是创建一个“垂直滚动”的TableView tableView = cc.TableView:create(cc.size(200, winSize.height - 20)) tableView:setDirection(cc.SCROLLVIEW_DIRECTION_VERTICAL) tableView:setPosition(cc.p(winSize.width / 2, 10)) tableView:setDelegate() tableView:setVerticalFillOrder(cc.TABLEVIEW_FILL_TOPDOWN) self:addChild(tableView) --registerScriptHandler functions must be before the reloadData funtion --注册脚本编写器函数必须在reloadData函数之前（有道自动翻译） --cell个数 tableView:registerScriptHandler(TableScene.numberOfCellsInTableView,cc.NUMBER_OF_CELLS_IN_TABLEVIEW) --滚动事件 tableView:registerScriptHandler(TableScene.scrollViewDidScroll,cc.SCROLLVIEW_SCRIPT_SCROLL) tableView:registerScriptHandler(TableScene.scrollViewDidZoom,cc.SCROLLVIEW_SCRIPT_ZOOM) --cell点击事件 tableView:registerScriptHandler(TableScene.tableCellTouched,cc.TABLECELL_TOUCHED) --cell尺寸、大小 tableView:registerScriptHandler(TableScene.cellSizeForTable,cc.TABLECELL_SIZE_FOR_INDEX) --显示出可视部分的cell tableView:registerScriptHandler(TableScene.tableCellAtIndex,cc.TABLECELL_SIZE_AT_INDEX) --调用这个才会显示界面 tableView:reloadData() ----------------------------------------------------------- end return true end --这里是为了让layer能调用TableViewTestLayer的方法 function TableScene.create() local layer = TableScene.extend(cc.Layer:create()) if nil ~= layer then layer:init() end return layer end return TableScene 测试验证--[LUA-print] 数据加载0 --[LUA-print] 创建了新的cell --[LUA-print] 数据加载1 --[LUA-print] 创建了新的cell --[LUA-print] 数据加载2 --[LUA-print] 创建了新的cell --[LUA-print] 数据加载3 --[LUA-print] 创建了新的cell --[LUA-print] 数据加载4 --[LUA-print] 创建了新的cell --[LUA-print] 数据加载5 --[LUA-print] 创建了新的cell --[LUA-print] 数据加载6 --[LUA-print] 创建了新的cell --[LUA-print] 数据加载7 --[LUA-print] 创建了新的cell --[LUA-print] 数据加载8 --[LUA-print] 创建了新的cell --[LUA-print] 数据加载9 --[LUA-print] 使用已经创建过的cell --[LUA-print] 数据加载10 --[LUA-print] 使用已经创建过的cell --[LUA-print] 数据加载11 --[LUA-print] 使用已经创建过的cell --[LUA-print] 数据加载12 --[LUA-print] 使用已经创建过的cell --[LUA-print] 数据加载13 --[LUA-print] 使用已经创建过的cell --[LUA-print] 数据加载14 --[LUA-print] 使用已经创建过的cell --[LUA-print] 数据加载15 --[LUA-print] 使用已经创建过的cell --[LUA-print] 数据加载16 --[LUA-print] 使用已经创建过的cell --[LUA-print] 数据加载17 --[LUA-print] 使用已经创建过的cell --[LUA-print] 数据加载18 --[LUA-print] 使用已经创建过的cell --[LUA-print] 数据加载19 --[LUA-print] 使用已经创建过的cell --[LUA-print] 数据加载20 基本上重用了iOS中的UITableView机制，并且非常流畅的滑动显示一个完整的列表 注意点：reloadData()的调用和上面图层之前的关系 美中不足的是cocos创建的这个tableView也是有bug的，如果你的这个tableView有点击事件，不妨你上下滑动几下item，然后在隐藏的上下方点击，是不是仍然有点击事件呢。简单一招，添加Panel遮挡，勾上交互性轻松搞定。 cocos2dx lua中老版的listView也可以实现统一的功能，但是只能加载少量的item,多了就会很卡，所以推荐以后直接使用TableView。 其他拓展网上有其他相关的一些教程，可以省去UI的搭建 先用CocosStudio或CocosCreator制作UI界面 看这篇文章：http://blog.csdn.net/fjdmy001/article/details/52982515 然后修改config.json, 窗口的配置文件，想设置模拟器的大小就在这里设置 竖屏：”isLandscape” = false 尺寸：”width” = 540, “height” = 960 修改config.lua 游戏的配置文件 开启全局变量：CC_DISABLE_GLOBAL = false 设计尺寸：width = 1080，height = 1920，autoscale = “FIXED_HEIGHT” 使用cocos2dx的相关方法加载对应的文件，然后类似的方法去加载对应的内容(和iOS中定义tableview与cell类似) 具体可参考这里： 排行榜之ScrollView：https://blog.csdn.net/fjdmy001/article/details/52997012 排行榜之TableView：https://blog.csdn.net/fjdmy001/article/details/52998376]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>事件</tag>
        <tag>cocos2dx lua TableView(ScrollView, ListView)介绍与使用实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx lua 绑定详解与实战]]></title>
    <url>%2F2018%2F10%2F18%2Fcocos2dx-lua-%E7%BB%91%E5%AE%9A%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[我们平时在开发cocos2dx lua游戏的时候的，会遇到这样的情况： 在c++层定义了一些类，我们需要将这些类导出给Lua来使用，从而完成在c++层实现起来容易的需求，这个时候就需要将整个类作为模块导出。 而Cocos2d-x正是采用的这种思想，将Cocos中的类导出供用户使用，而不是再写一套Lua代码，用户使用Cocos导出的这套接口，在Lua脚本层写游戏代码。 为了更好的理解这部分的内容，可以先了解c++中调用Lua的机制。 推荐 手动绑定自定义类中的函数 自动绑定自定义类中的函数 前面文章中，我们说到了，Lua的本质是C，不是C++，Lua提供给C用的API也都是基于面向过程的C函数来用的，要把C++类注册进Lua形成一个一个的table环境是不太容易一下子办到的事。 为了实现我们的需求，同样也是官方的需求，在Cocos 2.x版本的时候，使用的是tolua++这个工具，但是这个工具用起来相当的麻烦，耗费体力，所以现在使用的是bindings-generator工具（官方用Python写的一个工具），这个东西底层使用的也应该是tolua++。 这里只针对iOS平台，Android和其他平台在tolua中README.mdown中有具体介绍，其他步骤基本上一样！ 在项目跟目录framework/cocos2d-x/cocos中创建mybinding文件夹，里面创建一个MyBinding.h文件(mybinding, MyBinding自定义)，输入如下测试代码 #include &quot;cocos2d.h&quot; namespace cocos2d { class MyBinding: public Ref { public: virtual bool init() { return true; } void sayBinding() { log(&quot;Hello Binding Lua&quot;); } MyBinding(); ~MyBinding(); } } 在framework/cocos2d-x/tools/tolua，新建一个配置文件，这里命名cocos2dx_binding.ini 输入下面代码：（处理标记修改处其他所有都一样） [cocos2dx_binding] # 标记修改 # the prefix to be added to the generated functions. You might or might not use this in your own # templates prefix = cocos2dx_binding # 标记修改 # create a target namespace (in javascript, this would create some code like the equiv. to `ns = ns || {}`) # all classes will be embedded in that namespace target_namespace = cc # 标记修改 # --------- ? #android_headers = -I%(androidndkdir)s/platforms/android-19/arch-arm/usr/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.7/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.7/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.8/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.8/include android_headers = -I%(androidndkdir)s/platforms/android-19/arch-arm/usr/lib -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/include # --------- ? android_flags = -D_SIZE_T_DEFINED_ #clang_headers = -I%(clangllvmdir)s/lib/clang/%(clang_version)s/include clang_headers = -I%(clangllvmdir)s/lib64/clang/5.0/include clang_flags = -nostdinc -x c++ -std=c++11 -U __SSE__ # --------- ? # -I%(cocosdir)s/jsext -I%(cocosdir)s/jsext/system -I%(cocosdir)s/jsext/alipay -I%(cocosdir)s/jsext/video -I%(cocosdir)s/jsext/webview -I%(cocosdir)s/jsext/umeng cocos_headers = -I%(cocosdir)s -I%(cocosdir)s/cocos -I%(cocosdir)s/cocos/base -I%(cocosdir)s/cocos/platform/android -I%(cocosdir)s/extensions -I%(cocosdir)s/external -I%(cocosdir)s/cocos/editor-support -I%(cocosdir)s/cocos/network -I%(cocosdir)s/cocos/ui/UIEditBox -I%(cocosdir)s/cocos/ui #cocos_headers = -I%(cocosdir)s -I%(cocosdir)s/cocos -I%(cocosdir)s/cocos/platform/android cocos_flags = -DANDROID cxxgenerator_headers = # extra arguments for clang extra_arguments = %(android_headers)s %(clang_headers)s %(cxxgenerator_headers)s %(cocos_headers)s %(android_flags)s %(clang_flags)s %(cocos_flags)s %(extra_flags)s # what headers to parse 头文件路径 headers = %(cocosdir)s/cocos/mybinding/MyBinding.h # 标记修改 # what classes to produce code for. You can use regular expressions here. When testing the regular # expression, it will be enclosed in &quot;^$&quot;, like this: &quot;^Menu*$&quot;. #包含的类，新添加文件需要修改 classes = MyBinding.* # 标记修改 #需要在js里面派生的类 #classes_need_extend = MyBinding # 标记修改 # what should we skip? in the format ClassName::[function function] # ClassName is a regular expression, but will be used like this: &quot;^ClassName$&quot; functions are also # regular expressions, they will not be surrounded by &quot;^$&quot;. If you want to skip a whole class, just # add a single &quot;*&quot; as functions. See bellow for several examples. A special class name is &quot;*&quot;, which # will apply to all class names. This is a convenience wildcard to be able to skip similar named # functions from all classes. skip = rename_functions = rename_classes = # for all class names, should we remove something when registering in the target VM? remove_prefix = # classes for which there will be no &quot;parent&quot; lookup classes_have_no_parents = # base classes which will be skipped when their sub-classes found them. base_classes_to_skip = Ref # classes that create no constructor # Set is special and we will use a hand-written constructor abstract_classes = # Determining whether to use script object(js object) to control the lifecycle of native(cpp) object or the other way around. Supported values are &apos;yes&apos; or &apos;no&apos;. script_control_cpp = no 注意检查一下三个头文件对应的路径及文件问题 android_headers clang_headers cocos_headers 说明内容：+ •[title]：要配置将被使用的工具/ tolua的/ gengindings.py脚本的称号。一般来说，标题可以是文件名。 + •prefix：要配置一个函数名的前缀，通常，我们还可以使用文件名作为前缀。 + •target_namespace：要配置在脚本层模块的名字。在这里，我们使用cc作为模块名，当你想在脚本层REF的名称，您必须将一个名为前缀，CC在名称的前面。例如，CustomClass可以参考作为cc.CustomClass。 + •headers：要配置所有需要解析的头文件和％（cocosdir）s是的Cocos2d-x的引擎的根路径。 + •classes：要配置所有绑定所需的类。在这里，它支持正则表达式。因此，我们可以设置MyCustomClass。*在这里，用于查找多个特定的用法，你可以对照到tools/tolua/cocos2dx.ini。 + •skip：要配置需要被忽略的功能。现在绑定发电机无法解析的void *类型，并委托类型，所以这些类型的需要进行手动绑定。而在这种情况下，你应该忽略所有这些类型，然后再手动将它们绑定。你可以对照到配置文件路径下的cocos/scripting/lua-bindings/auto 。 + •rename_functions：要配置的功能需要在脚本层进行重命名。由于某些原因，开发者希望更多的脚本友好的API，所以配置选项就是为了这个目的。 + •rename_classes：不在使用。 + •remove_prefix：不在使用。 + •classes_have_no_parents：要配置是过滤器所需要的父类。这个选项是很少修改。 + •abstract_classes：要配置的公共构造并不需要导出的类。 + •script_control_cpp：是的。要配置脚本层是否管理对象的生命周期。如果没有，那么C++层关心他们的生命周期。现在，它是不完善的，以控制原生对象的续航时间在脚本层。所以，你可以简单地把它设置为no 修改framework/cocos2d-x/tools/tolua里面的genbindings.py。有个cmd_args键值对的配置，增加下面代码，作为自定义绑定配置 &apos;cocos2dx_binding.ini&apos; : (&apos;cocos2dx_binding&apos;, &apos;lua_cocos2dx_binding_auto&apos;), \ 注：python注释为#，这里将cmd_args其他的元素注释掉是因为这些文件都是生成过得，没必要再生成浪费时间这行代码表示在cocos2dx_custom中找到cocos2dx_custom的模块，然后生成lua_cocos2dx_custom_auto文件 这里要确保NDK_ROOT，和PYTHON_BIN安装切配置好了,然后在framework/cocos2d-x/tools/tolua执行 ./genbindings.py 之前./genbindings.py之前，请先查看官方tolua中README文件，按照对应的流程，安装好需要的依赖，和相应的库，下面是我这边3.17最新的README * The OSX 10.1&lt;!--0 has a built-in python2.7 and if your os don&apos;t have python2.7 then use [Homebrew](http://brew.sh/) to install the python and use pip install the python dependencies. &lt;pre&gt; brew install python &lt;/pre&gt; * Install python dependices by pip. &lt;pre&gt; sudo easy_install pip sudo pip install PyYAML sudo pip install Cheetah &lt;/pre&gt; * Download NDK 64bit r10c or later from [Android Ndk](https://developer.android.com/ndk/downloads/index.html) * Run &lt;pre&gt; export NDK_ROOT=/path/to/android-ndk-10c ./genbindings.py &lt;/pre&gt;--&gt; 大概意思就是下载r10c之后版的NDK本，然后安装python(这一步一般Mac都有，但是最好安装到2.x)。 大概意思就是安装，pip， PyYAML， Cheetah ……. 执行./genbindings.py之后生成在 工程目录\frameworks\cocos2d-x\cocos\scripting\lua-bindings\auto 下便有了两个生成的文件 lua_cocos2dx_custom_auto.cpp lua_cocos2dx_custom_auto.hpp 进入到文件夹 C:\Users\user\Documents\Cocos\Link\frameworks\cocos2d-x\cocos\scripting\lua-bindings\manual 打开CCLuaStack.cpp，添加 #include &quot;lua_cocos2dx_custom_auto.hpp&quot; register_all_cocos2dx_custom(_state); 期间遇到的错误错误一Traceback (most recent call last): File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1799, in &lt;module&gt; main() File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1772, in main &apos;clang_args&apos;: (config.get(s, &apos;extra_arguments&apos;, 0, dict(userconfig.items(&apos;DEFAULT&apos;))) or &quot;&quot;).split(&quot; &quot;), File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/ConfigParser.py&quot;, line 623, in get return self._interpolate(section, option, value, d) File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/ConfigParser.py&quot;, line 691, in _interpolate self._interpolate_some(option, L, rawval, section, vars, 1) File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/ConfigParser.py&quot;, line 726, in _interpolate_some section, map, depth + 1) File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/ConfigParser.py&quot;, line 723, in _interpolate_some option, section, rest, var) InterpolationMissingOptionError: Bad value substitution: section: [cocos2dx_custom] option : extra_arguments key : clang_version rawval : /include 路径错误 #clang_headers = -I%(clangllvmdir)s/lib/clang/%(clang_version)s/include clang_headers = -I%(clangllvmdir)s/lib64/clang/5.0/include # --------- ? 错误二Traceback (most recent call last): File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1799, in &lt;module&gt; main() File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1795, in main generator.generate_code() File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1444, in generate_code self._parse_headers() File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1487, in _parse_headers raise Exception(&quot;Fatal error in parsing headers&quot;) Exception: Fatal error in parsing headers --------------------------------- Generating lua bindings fails. --------------------------------- C++语法错误 错误三Generating bindings for cocos2dx_custom... Using userconfig [(&apos;androidndkdir&apos;, &apos;/Users/iCocos/tools/android-ndk-r16b&apos;), (&apos;clangllvmdir&apos;, &apos;/Users/iCocos/tools/android-ndk-r16b/toolchains/llvm/prebuilt/darwin-x86_64&apos;), (&apos;gcc_toolchain_dir&apos;, &apos;/Users/iCocos/tools/android-ndk-r16b/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64&apos;), (&apos;cocosdir&apos;, &apos;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x&apos;), (&apos;cxxgeneratordir&apos;, &apos;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator&apos;), (&apos;extra_flags&apos;, &apos;&apos;)] .... Generating bindings for target lua .... .... Processing section cocos2dx_custom Traceback (most recent call last): File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1799, in &lt;module&gt; main() File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1795, in main generator.generate_code() File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1444, in generate_code self._parse_headers() File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1478, in _parse_headers tu = self.index.parse(header, self.clang_args) File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/clang/cindex.py&quot;, line 2602, in parse self) File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/clang/cindex.py&quot;, line 2714, in from_source raise TranslationUnitLoadError(&quot;Error parsing translation unit.&quot;) TranslationUnitLoadError: Error parsing translation unit. --------------------------------- Generating lua bindings fails. --------------------------------- 路径错误 #android_headers = -I%(androidndkdir)s/platforms/android-19/arch-arm/usr/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.7/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.7/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.8/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.8/include android_headers = -I%(androidndkdir)s/platforms/android-19/arch-arm/usr/lib -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/include 错误四==== Errors in parsing headers: 1. &lt;severity = Fatal, location = &lt;SourceLocation file &apos;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/cocos/platform/android/CCPlatformDefine-android.h&apos;, line 33, column 10&gt;, details = &quot;&apos;android/log.h&apos; file not found&quot;&gt; ==== ….. 提示成功--------------------------------- Generating lua bindings succeeds. --------------------------------- 拓展推荐 lua： http://www.lua.org/ lua是个脚本语言，脚本语言！！就是脚本文件加解释器。之后你就可以看效果了。可是呢，lua如果正是靠自己独立完成点事情，那就是大材小用，需要和其他东西结合起来，比如C/C++.貌似主要也就是C/C++。 tolua++： http://www.codenix.com/~tolua/#news tolua++：首先看名字“到、lua、++”，就是把其他语言（C/C++函数对象转化为lua能调用形式，++这里理解为增强版），有了这个工具，我们就可以快速的将我们现成的C/C++代码封装成Lua接口形式。 luajit： http://luajit.org/luajit.html LuaJIT：LuaJIT is a Just-In-Time Compiler (JIT) for the Lua programming language. 。。。。。。说了半天就一个lua的高效率版本。 lua for windows： http://luaforge.net/projects/luaforwindows/ lua for windows：lua在windows下的打包版本，除了最基本的lua解释器，还包括了可用于和C/C++集成开发的【动态链接库、静态链接库、头文件】、文本编辑器、常用的lua module，帮助说明文档。 致谢： https://blog.csdn.net/never_QH/article/details/45148835 http://geekgaoyang.herokuapp.com/blog/2015/02/11/cocos2d-x-tutorial-of-binding-c-plus-plus-class-to-lua-usage/ https://www.cnblogs.com/ZhYQ-Note/p/5939783.html http://www.bubuko.com/infodetail-1210197.html https://www.jianshu.com/p/9bd4d5518d53]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>事件</tag>
        <tag>cocos2dx lua 绑定详解与实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令--查找与统计（grep、awk、sort、uniq、wc）]]></title>
    <url>%2F2018%2F10%2F16%2Flinux%E5%91%BD%E4%BB%A4--%E6%9F%A5%E6%89%BE%E4%B8%8E%E7%BB%9F%E8%AE%A1%EF%BC%88grep%E3%80%81awk%E3%80%81sort%E3%80%81uniq%E3%80%81wc%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在做日志分析时或者配置分析时，通常会遇到查找出符合某一条件的行，并统计，主要应用的就是grep、awk、sort、uniq、wc五个命令 1. grep命令grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。 语法格式为： grep [option] pattern file //pattern 通常可以为正则表达式 常见的参数为： 选项 -a ：将 binary 文件以 text 文件的方式搜寻数据 -c ：计算找到 &apos;搜寻字符串&apos; 的次数 -i ：忽略大小写的不同，所以大小写视为相同 -n ：顺便输出行号 -v ：反向选择，亦即显示出没有 &apos;搜寻字符串&apos; 内容的那一行！ --color=auto ：可以将找到的关键词部分加上颜色的显示喔！ 2.awk命令 awk命令通常是将所列出的行，根据条件打印出某一列或几列 常用形式为：awk -F ‘:’ ‘BEGIN {print “name,shell”} {if($1=”root”) print $1”,”$7} END {print “blue,/bin/nosh”}’ 3.sort命令sort排序原则：sort将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。 sort [optional] filename 常用参数： -u：去除重复行 -r：默认是升序排序，-r是改为降序 -o：将排序结果写入到源文件 -n：默认是通过ASCII码值排序，但是这时会出现10比2小的情况，-n就是说要以数值进行排序 -k和-t：-k是指定以哪一列进行排序，-t是指定分隔符 举例： （1）sort -n -t “ “ -k 2 -k 3 facebook.txt //人数相同的按照员工平均工资升序排序 （2） sort -n -t ‘ ‘ -k 3r -k 2 facebook.txt //按照员工工资降序排序，如果员工人数相同的，则按照公司人数升序排序 （3）sort -t ‘ ‘ -k 1.2 facebook.txt //从公司英文名称的第二个字母开始进行排序 （4）sort -t ‘ ‘ -k 1.2,1.2 -k 3,3nr facebook.txt //只针对公司英文名称的第二个字母进行排序，如果相同的按照员工工资进行降序排序 4.uniq命令uniq命令可以去除排序过的文件中的重复行，因此uniq经常和sort合用。也就是说，为了使uniq起作用，所有的重复行必须是相邻的。 -i ：忽略大小写字符的不同； -c ：进行计数,即统计该行的重复次数 -u ：显示不存在的行 -d：显示存在重复的行 5.wc 命令统计指定文件中的字节数、字数、行数，并将统计结果显示输出。该命令统计指定文件中的字节数、字数、行数。如果没有给出文件名，则从标准输入读取。wc同时也给出所指定文件的总统计数。 -c 统计字节数。 -l 统计行数。 -m 统计字符数。这个标志不能与 -c 标志一起使用。 -w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。 -L 打印最长行的长度。 -help 显示帮助信息 –version 显示版本信息 12[root@localhost test]# wc test.txt7 8 70 test.txt 7 表示行数 8 表示单词数 70 字节数]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP中9大缓存技术总结]]></title>
    <url>%2F2018%2F10%2F16%2FPHP%E4%B8%AD9%E5%A4%A7%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1、全页面静态化缓存也就是将页面全部生成html静态页面，用户访问时直接访问的静态页面，而不会去走php服务器解析的流程。此种方式，在CMS系统中比较常见，比如dedecms； 一种比较常用的实现方式是用输出缓存： Ob_start() ******要运行的代码******* $content = Ob_get_contents(); ****将缓存内容写入html文件***** Ob_end_clean(); 2、页面部分缓存该种方式，是将一个页面中不经常变的部分进行静态缓存，而经常变化的块不缓存，最后组装在一起显示；可以使用类似于ob_get_contents 的方式实现，也可以利用类似ESI之类的页面片段缓存策略，使其用来做动态页面中相对静态的片段部分的缓存 任何一个Web网站的内容都是在不断更新和变化，但这并不意味这这个网站的内容就是动态内容，事实上，动态的内容是指用户每次点击 相同的链接时取的的内容是由Web服务器应用程序生成的，如常见得ASP，JSP等，与此相对应，静态内容一般就是指由文本、图像和多媒体组成，在用户每 次单击相应链接时基本保持不变。现在解决动态内容缓存的最新技术就是通过ESI技术来设计网站的内容。 推荐ESI技术，该种方式可以用于如商城中的商品页； 3、数据缓存顾名思义，就是缓存数据的一种方式；比如，商城中的某个商品信息，当用商品id去请求时，就会得出包括店铺信息、商品信息等数据，此时就可以将这些 数据缓存到一个php文件中，文件名包含商品id来建一个唯一标示；下一次有人想查看这个商品时，首先就直接调这个文件里面的信息，而不用再去数据库查 询；其实缓存文件中缓存的就是一个php数组之类； Ecmall商城系统里面就用了这种方式； 4、查询缓存其实这跟数据缓存是一个思路，就是根据查询语句来缓存；将查询得到的数据缓存在一个文件中，下次遇到相同的查询时，就直接先从这个文件里面调数据，不会再去查数据库；但此处的缓存文件名可能就需要以查询语句为基点来建立唯一标示； 按时间变更进行缓存 其实，这一条不是真正的缓存方式；上面的2、3、4的缓存技术一般都用到了时间变更判断；就是对于缓存文件您需要设一个有效时间，在这个有效时间 内，相同的访问才会先取缓存文件的内容，但是超过设定的缓存时间，就需要重新从数据库中获取数据，并生产最新的缓存文件；比如，我将我们商城的首页就是设 置2个小时更新一次； 5、按内容变更进行缓存这个也并非独立的缓存技术，需结合着用；就是当数据库内容被修改时，即刻更新缓存文件； 比如，一个人流量很大的商城，商品很多，商品表必然比较大，这表的压力也比较重；我们就可以对商品显示页进行页面缓存； 当商家在后台修改这个商品的信息时，点击保存，我们同时就更新缓存文件；那么，买家访问这个商品信息时，实际上访问的是一个静态页面，而不需要再去访问数据库； 试想，如果对商品页不缓存，那么每次访问一个商品就要去数据库查一次，如果有10万人在线浏览商品，那服务器压力就大了； 6、内存式缓存提到这个，可能大家想到的首先就是Memcached；memcached是高性能的分布式内存缓存服务器。 一般的使用目的是，通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度、 提高可扩展性。 它就是将需要缓存的信息，缓存到系统内存中，需要获取信息时，直接到内存中取；比较常用的方式就是 key–&gt;value方式； &lt;?php $memcachehost = &apos;192.168.6.191&apos;; $memcacheport = 11211; $memcachelife = 60; $memcache = new Memcache; $memcache-&gt;connect($memcachehost,$memcacheport) or die (&quot;Could not connect&quot;); $memcache-&gt;set(&apos;key&apos;,&apos;缓存的内容&apos;); $get = $memcache-&gt;get($key); //获取信息 ?&gt; 7、apache缓存模块apache安装完以后，是不允许被cache的。如果外接了cache或squid服务器要求进行web加速的话，就需要在htttpd.conf里进行设置，当然前提是在安装apache的时候要激活mod_cache的模块。 安装apache时：./configure –enable-cache –enable-disk-cache –enable-mem-cache 8、php APC缓存扩展Php有一个APC缓存扩展，windows下面为php_apc.dll，需要先加载这个模块，然后是在php.ini里面进行配置： [apc] extension=php_apc.dll apc.rfc1867 = on upload_max_filesize = 100M post_max_size = 100M apc.max_file_size = 200M upload_max_filesize = 1000M post_max_size = 1000M max_execution_time = 600 ; 每个PHP页面运行的最大时间值(秒)，默认30秒 max_input_time = 600 ; 每个PHP页面接收数据所需的最大时间，默认60 memory_limit = 128M ; 每个PHP页面所吃掉的最大内存，默认8M 9、Opcode缓存我们知道，php的执行流程可以用下图来展示： 首先php代码被解析为Tokens，然后再编译为Opcode码，最后执行Opcode码，返回结果；所以，对于相同的php文件，第一次运行时 可以缓存其Opcode码，下次再执行这个页面时，直接会去找到缓存下的opcode码，直接执行最后一步，而不再需要中间的步骤了。 比较知名的是XCache、Turck MM Cache、PHP Accelerator等。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP自动加载机制(__autoload&spl_autoload_register)]]></title>
    <url>%2F2018%2F10%2F16%2FPHP%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-autoload-spl-autoload-register%2F</url>
    <content type="text"><![CDATA[PHP在魔术函数__autoload()方法出现以前，如果你要在一个程序文件中实例化100个对象，那么你必须用include或者require包含进来100个类文件，或者你把这100个类定义在同一个类文件中——相信这个文件一定会非常大。 但是__autoload()方法出来了，以后就不必为此大伤脑筋了，这个类会在你实例化对象之前自动加载制定的文件。 1. autoload 机制概述在使用PHP的OO模式开发系统时，通常大家习惯上将每个类的实现都存放在一个单独的文件里，这样会很容易实现对类进行复用，同时将来维护时也很便利。这也是OO设计的基本思想之一。在PHP5之前，如果需要使用一个类，只需要直接使用include/require将其包含进来即可。下面是一个实际的例子： /* Person.class.php */ &lt;?php class Person { var $name, $age; function __construct ($name, $age) { $this-&gt;name = $name; $this-&gt;age = $age; } } ?&gt; /* no_autoload.php */ &lt;?php require_once (”Person.class.php”); $person = new Person(”Altair”, 6); var_dump ($person); ?&gt; 在这个例子中，no-autoload.php文件需要使用Person类，它使用了require_once将其包含，然后就可以直接使用Person类来实例化一个对象。 但随着项目规模的不断扩大，使用这种方式会带来一些隐含的问题：如果一个PHP文件需要使用很多其它类，那么就需要很多的require/include语句，这样有可能会造成遗漏或者包含进不必要的类文件。如果大量的文件都需要使用其它的类，那么要保证每个文件都包含正确的类文件肯定是一个噩梦。 PHP5为这个问题提供了一个解决方案，这就是类的自动装载(autoload)机制。autoload机制可以使得PHP程序有可能在使用类时才自动包含类文件，而不是一开始就将所有的类文件include进来，这种机制也称为lazy loading。 下面是使用autoload机制加载Person类的例子： /* autoload.php */ &lt;?php function __autoload($classname) { $classpath=&quot;./&quot;.$classname.&apos;.class.php&apos;; if(file_exists($classpath)) { require_once($classpath); } else { echo &apos;class file&apos;.$classpath.&apos;not found!&apos;; } } $person = new Person(”Altair”, 6); var_dump ($person); ?&gt; 通常PHP5在使用一个类时，如果发现这个类没有加载，就会自动运行__autoload()函数，在这个函数中我们可以加载需要使用的类。在我们这个简单的例子中，我们直接将类名加上扩展名”.class.php”构成了类文件名，然后使用require_once将其加载。从这个例子中，我们可以看出autoload至少要做三件事情，第一件事是根据类名确定类文件名，第二件事是确定类文件所在的磁盘路径(在我们的例子是最简单的情况，类与调用它们的PHP程序文件在同一个文件夹下)，第三件事是将类从磁盘文件中加载到系统中。第三步最简单，只需要使用include/require即可。 要实现第一步，第二步的功能，必须在开发时约定类名与磁盘文件的映射方法，只有这样我们才能根据类名找到它对应的磁盘文件。 因此，当有大量的类文件要包含的时候，我们只要确定相应的规则，然后在autoload()函数中，将类名与实际的磁盘文件对应起来，就可以实现lazy loading的效果。从这里我们也可以看出autoload()函数的实现中最重要的是类名与实际的磁盘文件映射规则的实现。 但现在问题来了，如果在一个系统的实现中，如果需要使用很多其它的类库，这些类库可能是由不同的开发人员编写的，其类名与实际的磁盘文件的映射规则不尽相同。这时如果要实现类库文件的自动加载，就必须在autoload()函数中将所有的映射规则全部实现，这样的话autoload()函数有可能会非常复杂，甚至无法实现。最后可能会导致__autoload()函数十分臃肿，这时即便能够实现，也会给将来的维护和系统效率带来很大的负面影响。在这种情况下，难道就没有更简单清晰的解决办法了吧？答案当然是：NO! 在看进一步的解决方法之前，我们先来看一下PHP中的autoload机制是如何实现的。 2. PHP 的 autoload 机制的实现我们知道，PHP文件的执行分为两个独立的过程，第一步是将PHP文件编译成普通称之为OPCODE的字节码序列（实际上是编译成一个叫做zend_op_array的字节数组），第二步是由一个虚拟机来执行这些OPCODE。PHP的所有行为都是由这些OPCODE来实现的。因此，为了研究PHP中autoload的实现机制，我们将autoload.php文件编译成opcode，然后根据这些OPCODE来研究PHP在这过程中都做了些什么: /* autoload.php 编译后的OPCODE列表，是使用作者开发的OPDUMP工具 * 生成的结果，可以到网站 http://www.phpinternals.com/ 下载该软件。 */ 1: &lt;?php 2: // require_once (”Person.php”); 3: 4: function __autoload ($classname) { 0 NOP 0 RECV 1 5: if (!class_exists($classname)) { 1 SEND_VAR !0 2 DO_FCALL ‘class_exists’ [extval:1] 3 BOOL_NOT $0 =&gt;RES[~1] 4 JMPZ ~1, -&gt;8 6: require_once ($classname. “.class.php”); 5 CONCAT !0, ‘.class.php’ =&gt;RES[~2] 6 INCLUDE_OR_EVAL ~2, REQUIRE_ONCE 7: } 7 JMP -&gt;8 8: } 8 RETURN null 9: 10: $p = new Person(’Fred’, 35); 1 FETCH_CLASS ‘Person’ =&gt;RES[:0] 2 NEW :0 =&gt;RES[$1] 3 SEND_VAL ‘Fred’ 4 SEND_VAL 35 5 DO_FCALL_BY_NAME [extval:2] 6 ASSIGN !0, $1 11: 12: var_dump ($p); 7 SEND_VAR !0 8 DO_FCALL ‘var_dump’ [extval:1] 13: ?&gt; 在autoload.php的第10行代码中我们需要为类Person实例化一个对象。因此autoload机制一定会在该行编译后的opcode中有所体现。从上面的第10行代码生成的OPCODE中我们知道，在实例化对象Person时，首先要执行FETCH_CLASS指令。我们就从PHP对FETCH_CLASS指令的处理过程开始我们的探索之旅。 通过查阅PHP的源代码(我使用的是PHP 5.3alpha2版本)可以发现如下的调用序列： ZEND_VM_HANDLER(109, ZEND_FETCH_CLASS, …) (zend_vm_def.h 1864行) =&gt; zend_fetch_class (zend_execute_API.c 1434行) =&gt;zend_lookup_class_ex (zend_execute_API.c 964行) =&gt; zend_call_function(&amp;fcall_info, &amp;fcall_cache) (zend_execute_API.c 1040行) 在最后一步的调用之前，我们先看一下调用时的关键参数： /* 设置autoload_function变量值为”__autoload” */ fcall_info.function_name = &amp;autoload_function; // Ooops, 终于发现”__autoload”了 … fcall_cache.function_handler = EG(autoload_func); // autoload_func ! zend_call_function是Zend Engine中最重要的函数之一，其主要功能是执行用户在PHP程序中自定义的函数或者PHP本身的库函数。zend_call_function有两个重要的指针形参数fcall_info, fcall_cache，它们分别指向两个重要的结构，一个是zend_fcall_info, 另一个是zend_fcall_info_cache。zend_call_function主要工作流程如下：如果fcall_cache.function_handler指针为NULL，则尝试查找函数名为fcall_info.function_name的函数，如果存在的话，则执行之；如果fcall_cache.function_handler不为NULL，则直接执行fcall_cache.function_handler指向的函数。 现在我们清楚了，PHP在实例化一个对象时（实际上在实现接口，使用类常数或类中的静态变量，调用类中的静态方法时都会如此），首先会在系统中查找该类（或接口）是否存在，如果不存在的话就尝试使用autoload机制来加载该类。而autoload机制的主要执行过程为： 检查执行器全局变量函数指针autoload_func是否为NULL。 如果autoload_func==NULL, 则查找系统中是否定义有__autoload()函数，如果没有，则报告错误并退出。 如果定义了__autoload()函数，则执行__autoload()尝试加载类，并返回加载结果。 如果autoload_func不为NULL，则直接执行autoload_func指针指向的函数用来加载类。注意此时并不检查__autoload()函数是否定义。 真相终于大白，PHP提供了两种方法来实现自动装载机制，一种我们前面已经提到过，是使用用户定义的autoload()函数，这通常在PHP源程序中来实现；另外一种就是设计一个函数，将autoload_func指针指向它，这通常使用C语言在PHP扩展中实现。如果既实现了autoload()函数，又实现了autoload_func(将autoload_func指向某一PHP函数)，那么只执行autoload_func函数。 3. SPL autoload 机制的实现SPL是Standard PHP Library(标准PHP库)的缩写。它是PHP5引入的一个扩展库，其主要功能包括autoload机制的实现及包括各种Iterator接口或类。SPL autoload机制的实现是通过将函数指针autoload_func指向自己实现的具有自动装载功能的函数来实现的。SPL有两个不同的函数spl_autoload, spl_autoload_call，通过将autoload_func指向这两个不同的函数地址来实现不同的自动加载机制。 spl_autoload是SPL实现的默认的自动加载函数，它的功能比较简单。它可以接收两个参数，第一个参数是$class_name，表示类名，第二个参数$file_extensions是可选的，表示类文件的扩展名，可以在$file_extensions中指定多个扩展名，护展名之间用分号隔开即可；如果不指定的话，它将使用默认的扩展名.inc或.php。spl_autoload首先将$class_name变为小写，然后在所有的include path中搜索$class_name.inc或$class_name.php文件(如果不指定$file_extensions参数的话)，如果找到，就加载该类文件。你可以手动使用spl_autoload(”Person”, “.class.php”)来加载Person类。实际上，它跟require/include差不多，不同的它可以指定多个扩展名。 怎样让spl_autoload自动起作用呢，也就是将autoload_func指向spl_autoload？答案是使用spl_autoload_register函数。在PHP脚本中第一次调用spl_autoload_register()时不使用任何参数，就可以将autoload_func指向spl_autoload。 通过上面的说明我们知道，spl_autoload的功能比较简单，而且它是在SPL扩展中实现的，我们无法扩充它的功能。如果想实现自己的更灵活的自动加载机制怎么办呢？这时，spl_autoload_call函数闪亮登场了。 我们先看一下spl_autoload_call的实现有何奇妙之处。在SPL模块内部，有一个全局变量autoload_functions，它本质上是一个HashTable，不过我们可以将其简单的看作一个链表，链表中的每一个元素都是一个函数指针,指向一个具有自动加载类功能的函数。spl_autoload_call本身的实现很简单，只是简单的按顺序执行这个链表中每个函数，在每个函数执行完成后都判断一次需要的类是否已经加载，如果加载成功就直接返回，不再继续执行链表中的其它函数。如果这个链表中所有的函数都执行完成后类还没有加载，spl_autoload_call就直接退出，并不向用户报告错误。因此，使用了autoload机制，并不能保证类就一定能正确的自动加载，关键还是要看你的自动加载函数如何实现。 那么自动加载函数链表autoload_functions是谁来维护呢？就是前面提到的spl_autoload_register函数。它可以将用户定义的自动加载函数注册到这个链表中，并将autoload_func函数指针指向spl_autoload_call函数（注意有一种情况例外，具体是哪种情况留给大家思考）。我们也可以通过spl_autoload_unregister函数将已经注册的函数从autoload_functions链表中删除。 上节说过，当autoload_func指针非空时，就不会自动执行autoload()函数了，现在autoload_func已经指向了spl_autoload_call，如果我们还想让autoload()函数起作用应该怎么办呢？当然还是使用spl_autoload_register(__autoload)调用将它注册到autoload_functions链表中。 现在回到第一节最后的问题，我们有了解决方案：根据每个类库不同的命名机制实现各自的自动加载函数，然后使用spl_autoload_register分别将其注册到SPL自动加载函数队列中就可了。这样我们就不用维护一个非常复杂的__autoload函数了。 4. autoload 效率问题及对策使用autoload机制时，很多人的第一反应就是使用autoload会降低系统效率，甚至有人干脆提议为了效率不要使用autoload。在我们了解了autoload实现的原理后，我们知道autoload机制本身并不是影响系统效率的原因，甚至它还有可能提高系统效率，因为它不会将不需要的类加载到系统中。 那么为什么很多人都有一个使用autoload会降低系统效率的印象呢？实际上，影响autoload机制效率本身恰恰是用户设计的自动加载函数。如果它不能高效的将类名与实际的磁盘文件(注意，这里指实际的磁盘文件，而不仅仅是文件名)对应起来，系统将不得不做大量的文件是否存在(需要在每个include path中包含的路径中去寻找)的判断，而判断文件是否存在需要做磁盘I/O操作，众所周知磁盘I/O操作的效率很低，因此这才是使得autoload机制效率降低的罪魁祸首! 因此，我们在系统设计时，需要定义一套清晰的将类名与实际磁盘文件映射的机制。这个规则越简单越明确，autoload机制的效率就越高。 结论：autoload机制并不是天然的效率低下，只有滥用autoload，设计不好的自动装载函数才会导致其效率的降低。 总结__autoload($className) 尝试加载未定义的类 我们可以理解为： 在new一个对象的时候，如果没有找到这个类的定义，会调用__autoload 会自动向autoload魔术方法传递类名$className 要找到目标的文件并加载则需要经历： 根据类名，确定文件名（在autoload里面实现） 确认类文件的路径 将所需要的类文件加载进来 下面代码实现了在找不到类定义时，会尝试到当前文件夹下寻找类名为文件名的文件加载进来123456function __autoload($className) &#123; $file = __DIR__.&apos;/&apos;.$className. &apos;.php&apos;; if (file_exists($file)) &#123; require $file; &#125;&#125; 但是我们只实现了加载当前目录下的文件，如果与autoload文件在不同层级的文件，则需要修改一下我们之前的代码,使之能加载其他层级的文件：12345678910111213function __autoload($className) &#123; $dirs = array( __DIR__, __DIR__ . &apos;/Config/&apos;, ); foreach($dirs as $dir) &#123; $file = $dir.&apos;/&apos;.$className. &apos;.php&apos;; if (file_exists($file)) &#123; require $file; &#125; &#125;&#125; spl_autoload_register() 提供了一种更加灵活的方式来实现类的自动加载。因此，不再建议使用 __autoload() 函数，在以后的版本中它可能被弃用。 我们再次修改上面的autoload代码：1234567891011121314151617181920function autoload($class) &#123; static $map = array(); $dirs = array( __DIR__, __DIR__.&apos;/Demo/&apos;, ); if(!isset($map[$class])) &#123; foreach ($dirs as $dir) &#123; $file = $dir.&apos;/&apos;.str_replace(&apos;\\&apos;, &apos;/&apos;, $class). &apos;.php&apos;; if (file_exists($file)) &#123; require $file; $map[$class] = true; &#125; &#125; &#125;&#125;//注册spl_autoload_register(&apos;autoload&apos;); spl_autoload_register会将函数注册到SPL__autoload函数队列中，当new一个类的时候，会从这个队列中找到想要的类]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx lua 与 C/C++ 交互入门]]></title>
    <url>%2F2018%2F10%2F16%2Fcocos2dx-lua-%E4%B8%8E-C-C-%E4%BA%A4%E4%BA%92%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[目录 中间栈 1.中间件栈 C/C++访问Lua数据和函数 Lua访问C/C++数据和函数 集成Lua 集成Lua环境到C_Cpp项目中 C/C++ 调用Lua C/C++调用Lua之标准Lua读取类 C/C++调用Lua中的变量 C/C++调用Lua中的函数 C/C++调用Lua之遍历和获取Table的值 Lua 调用 C/C++ 1.Lua调用C/C++函数 深入理解编写C函数上 深入理解编写C函数下 2.Lua调用C/C++之标准C模块 待续 中间栈 lua(https://www.lua.org/)作为一种轻量级的脚本语言, 以其简单的语法结构, 方便的c++集成能力, 高效的执行效率收到广大游戏开发者的热爱, 也是cocos2d-x官方首次引入的脚本语言. 作为一种脚本语言, lua是在一个运行时环境(State)里执行的, 这个运行时环境保存了脚本运行所需的内存空间, 创建的全局变量, 加载的库文件等. 在这个运行时环境里还有一个栈空间(Stack), 其作用就是在lua和c语言进行数据传递和函数调用. lua原生实现了很多c api对栈空间进行操作, 让开发者能够方便地实现lua脚本代码与c编译代码的双向通信. 推荐：Lua中的栈概念 Lua的栈是一个线性数组，栈中的每一项元素的类型都是TValue，它是Lua表示内部数据的数据结构。栈的最大空间在luaconf.h中给出：#define LUAI_MAXSTACK 1000000。 栈包括：基指针、栈顶指针、栈大小。图中的stack-&gt;top表示栈顶指针。其实在Lua中栈的很多空间都留作它用，如call info也使用一部分的栈。 1.中间件栈 背后其实是lua和c api的互相调用, 所有c++的功能都要通过一层c函数的包装, 这点是要牢记在心的, 这也正是lua-binding的核心. cocos2d-x提供的lua-bingding工具使用libclang分析c++源码, 提取语法树, 将c++的类成员函数封装为c函数, 然后根据参数类型自动调用lua c api, 实现对栈空间的操作, 将c++的数据传递给lua. lua脚本加载编译好的c++库, 就可以自由调用c++里面的类对象和成员函数了; c++的代码则可以直接使用lua c api, 执行一段lua脚本, 并通过栈空间获取返回结果. 执行过程如下： 1）C程序读取Lua脚本 2）lualib库解析脚本，并保存解析结果。 3）通过Lua API，将解析结果中的某一个值放入栈中。 4）C程序通过Lua提供的API到栈中取得数据。 经过上面的过程C语言程序和Lua脚本就能相互传值了。开始撸代码 ——————————- 华丽的分割线 ——————————- 创建一个Lua管理类，用利用栈的原理，使用C++简单访问Lua .h文件#ifndef LuaInterface01_h #define LuaInterface01_h #include &lt;stdio.h&gt; #include &quot;lua.hpp&quot; class LuaInterface01 { public: static LuaInterface01 *shareInterface(); private: static LuaInterface01 *i; void init(); }; #endif /* LuaInterface01_hpp */ .cpp文件#include &quot;LuaInterface01.h&quot; #include &quot;cocos2d.h&quot; #include &lt;string&gt; USING_NS_CC; using namespace std; LuaInterface01 *LuaInterface01::i = NULL; LuaInterface01 *LuaInterface01::shareInterface() { if (!i) { i = new LuaInterface01; i -&gt; init(); } return i; } void LuaInterface01::init() { // 创建一个Lua状态指针 lua_State *luaState = luaL_newstate(); luaL_openlibs(luaState); string path = CCFileUtils::sharedFileUtils()-&gt;fullPathForFilename(&quot;Interface01.lua&quot;); luaL_dofile(luaState, path.c_str()); lua_pcall(luaState, 0, 0, 0); // Hello iCocos LuaInterface01! } 新建一个.lua的访问类文件，并且输入print(&quot;Hello iCocos LuaInterface01!&quot;) 控制答应结果：Hello iCocos LuaInterface01! 下面用简单的Lua与C/C++互调，验证中间件栈， 如果想了解更多或者更详细的实现Lua与C/C++，请略过本小结，滑到第三部分，或者通过目录寻找需要的内容！ C/C++访问Lua数据和函数创建一个Lua管理类，.h文件#ifndef LuaInterface02_h #define LuaInterface02_h #include &lt;stdio.h&gt; #include &quot;lua.hpp&quot; #include &quot;cocos2d.h&quot; USING_NS_CC; class LuaInterface02 { public: LuaInterface02(); ~LuaInterface02(); static LuaInterface02 *shareInterface(); void init(); void readVariable(); void loadFunstion(); private: static LuaInterface02 *i; lua_State *m_pLuaState; }; #endif /* LuaInterface02_h */ .cpp文件#include &quot;LuaInterface02.h&quot; #include &lt;string&gt; using namespace std; LuaInterface02 *LuaInterface02::i = NULL; LuaInterface02::LuaInterface02() { } LuaInterface02::~LuaInterface02() { if (m_pLuaState) { lua_close(m_pLuaState); m_pLuaState = NULL; } } LuaInterface02 *LuaInterface02::shareInterface() { if (!i) { i = new LuaInterface02; i -&gt; init(); } return i; } void LuaInterface02::init() { m_pLuaState = luaL_newstate(); luaL_openlibs(m_pLuaState); } void LuaInterface02::readVariable() { string path = CCFileUtils::sharedFileUtils()-&gt;fullPathForFilename(&quot;Interface02.lua&quot;); luaL_dofile(m_pLuaState, path.c_str()); int err_relt = lua_pcall(m_pLuaState, 0, 0, 0); CCAssert(err_relt, &quot;读取Lua文件错误&quot;); lua_getglobal(m_pLuaState, &quot;username&quot;); char *rlt = (char*)lua_tostring(m_pLuaState, -1); //lua_tonumber,lua_toboolean CCLOG(&quot;rlt is : %s&quot;, rlt); lua_pop(m_pLuaState, 1); } void LuaInterface02::loadFunstion() { string path = CCFileUtils::sharedFileUtils()-&gt;fullPathForFilename(&quot;Interface02.lua&quot;); luaL_dofile(m_pLuaState, path.c_str()); int err_relt = lua_pcall(m_pLuaState, 0, 0, -1); CCAssert(err_relt != -1, &quot;读取Lua文件错误&quot;); lua_getglobal(m_pLuaState, &quot;getResult&quot;); lua_pushnumber(m_pLuaState, 12); err_relt = lua_pcall(m_pLuaState, 1, 2, -1); // 1： 一个参数， 2：两个参数 ， -1：当出错的时候的返回值 CCAssert(err_relt != -1, &quot;访问函数报错&quot;); char *rlt = (char*)lua_tostring(m_pLuaState, -1); //lua_tonumber,lua_toboolean CCLOG(&quot;rlt is : %s&quot;, rlt); char *rlt2 = (char*)lua_tostring(m_pLuaState, -2); //lua_tonumber,lua_toboolean CCLOG(&quot;rlt2 is : %s&quot;, rlt2); } 新建一个.lua的访问类文件，并且输入username = &quot;iCocos&quot; function getResult(x) print(&quot;Enter Result&quot;) print(&quot;x:&quot;..x) return &quot;OK&quot;,&quot;Function&quot; end 控制答应结果：rlt is : iCocos Enter Result x:12 rlt is : Function rlt2 is : OK Lua访问C/C++数据和函数LuaInterface02.h中增加函数// 调用C++ static int l_show(lua_State * L) { lua_pushstring(L, &quot;String from C/C++&quot;); return 1; } 然后在init()中输入执行方法// 调用C++ lua_pushcfunction(m_pLuaState, l_show); lua_setglobal(m_pLuaState, &quot;show&quot;); 然后在.lua的访问类文件，并且输入print(show()) 控制答应结果：String from C/C++ 总结 简单点讲就是维护了一个堆栈，需要交互的数据通过入栈，出栈操作来传递数据。而具体脚本语言的实现机制，一般来说都会有一个编译模块、一个虚拟机（执行）模块、一套类型实现及数据管理模块，通常还会有一个供外部操作的接口，如lua c api，这个接口让嵌入方得以操作脚本状态（如访问变量、调用函数、管理内存），实现交互。 最后，总结一下，所有程序最终都是以机器码的形式被硬件CPU执行，从这个角度去看，不同语言的代码并没有本质区别，最终都是被编译器编译从二进制机器码，而所谓交互，就是在处理共享数据而已。 注意 Lua与C/C++或C/C++语言之前那通信过程中，实际上更多的时候是对栈顶的元素进行操作 从栈顶往下看索引是-1-2-3… 从栈底往上看索引是1，2，3… 无论从Lua调C/C++，还是C/C++调Lua，参数值都是最先被压入到栈顶的，最后结果值才会被压入到栈顶 集成Lua集成Lua环境到C/C++项目中 下载并获取到Lua源代码(src文件夹就是lua源码)https://www.lua.org/ 在lua中文件类型有三种 .c c文件 .h 头文件 .o 可执行文件 开始接入 接入Lua到C/C++的时候需要删除 lua.c luac.c MakeFile 新建一个Xcode项目，拷贝src文件夹到项目中就可以了 最后 在llex.c中trydecpoint, 修改里面decpoint=“getlocaldecpoint” decpoint=’.’ 如果不改会导致编译报错 验证 新建一个C++文件，在头文件中输入 #include &lt;stdio.h&gt; #include &quot;lua.hpp&quot; #include &quot;cocos2d.h&quot; USING_NS_CC; class TestInportLua { public: void test() { lua_State *state = luaL_newstate(); luaL_openlibs(state); luaL_dofile(state, &quot;res/test.lua&quot;); } } #endif /* TestInportLua_h */ C/C++ 调用LuaC/C++调用Lua之标准Lua读取类创建一个Lua管理类，.h文件#ifndef LuaInterface03_hpp #define LuaInterface03_hpp #include &quot;cocos2d.h&quot; #include &quot;lua.hpp&quot; #include &lt;string&gt; USING_NS_CC; using namespace std; class LuaInterface03 { public: LuaInterface03(); ~LuaInterface03(); static LuaInterface03 *shareInterface(); void readVailable(); void loadFunciton(); private: static LuaInterface03 *i; lua_State *m_pLuaState; void init(); }; #endif /* LuaInterface03_hpp */ .cpp文件#include &quot;LuaInterface03.h&quot; LuaInterface03 *LuaInterface03::i = NULL; LuaInterface03::LuaInterface03(){} LuaInterface03::~LuaInterface03(){ lua_close(m_pLuaState); m_pLuaState = NULL; } void LuaInterface03::init() { // 创建一个新的状态 m_pLuaState = luaL_newstate(); // 打开所有系统提供的库 luaL_openlibs(m_pLuaState); // 完整路径 string path = CCFileUtils::sharedFileUtils()-&gt;fullPathForFilename(&quot;LuaInterface03.lua&quot;); // 读取文件 luaL_dofile(m_pLuaState, path.c_str()); // 启动调用文件 lua_pcall(m_pLuaState, 0, 0, -1); } LuaInterface03 *LuaInterface03::shareInterface() { if (!i) { i = new LuaInterface03; i -&gt; init(); } return i; } 新建一个.lua的访问类文件，并且输入print(&quot;=======&gt; I am Lua Config&quot;) 控制答应结果：=======&gt; I am Lua Config C/C++调用Lua中的变量增加方法和对应的实现，用来获取变量void configWindowContentSize(); void LuaInterface03::configWindowContentSize() { lua_getglobal(m_pLuaState, &quot;width&quot;); // 是否能转换成number if (lua_isnumber(m_pLuaState, -1)) { int width = (int)lua_tonumber(m_pLuaState, -1); CCLOG(&quot;width: %i&quot;, width); } lua_getglobal(m_pLuaState, &quot;height&quot;); if (lua_isnumber(m_pLuaState, -1)) { int height = (int)lua_tonumber(m_pLuaState, -1); CCLOG(&quot;height: %i&quot;, height); } } Lua中增加变量width = 320 height = 640 控制答应结果：width: 320 height: 640 C/C++调用Lua中的函数增加方法和对应的实现，用来获取变量void callLuaFunctionContent(); void LuaInterface03::callLuaFunctionContent() { lua_getglobal(m_pLuaState, &quot;test1&quot;); int err_relt = lua_pcall(m_pLuaState, 0, 0, -1); CCAssert(err_relt != -1, &quot;访问函数报错&quot;); lua_getglobal(m_pLuaState, &quot;test2&quot;); lua_pushstring(m_pLuaState, &quot;test2 调用&quot;); err_relt = lua_pcall(m_pLuaState, 1, 0, -1); // 1： 一个参数， 2：两个参数 ， -1：当出错的时候的返回值 CCAssert(err_relt != -1, &quot;访问函数报错&quot;); lua_getglobal(m_pLuaState, &quot;test3&quot;); err_relt = lua_pcall(m_pLuaState, 0, 0, -1); CCAssert(err_relt != -1, &quot;访问函数报错&quot;); char* rlt = (char*)lua_tostring(m_pLuaState, -1); CCLOG(&quot;rlt is %s&quot;,rlt); lua_getglobal(m_pLuaState, &quot;test4&quot;); lua_pushnumber(m_pLuaState, 10); err_relt = lua_pcall(m_pLuaState, 1, 2, -1); // 1： 一个参数， 2：两个参数 ， -1：当出错的时候的返回值 CCAssert(err_relt != -1, &quot;访问函数报错&quot;); int rlt2 = (int)lua_tonumber(m_pLuaState, -1); CCLOG(&quot;rlt is %i&quot;,rlt2); lua_getglobal(m_pLuaState, &quot;test5&quot;); lua_pushnumber(m_pLuaState, 100); err_relt = lua_pcall(m_pLuaState, 1, 2, -1); // 1： 一个参数， 2：两个参数 ， -1：当出错的时候的返回值 CCAssert(err_relt != -1, &quot;访问函数报错&quot;); int rlt3 = (int)lua_tonumber(m_pLuaState, -1); int rlt4 = (int)lua_tonumber(m_pLuaState, -1); CCLOG(&quot;rlt is %i&quot;,rlt3); CCLOG(&quot;rlt is %i&quot;,rlt4); } Lua中增加变量function test1() print(&quot;call lua function&quot;) end function test2(var) print(&quot;call lua function&quot;, var) end function test3() return &quot;I am Lua test3&quot; end function test4(var) var = var + 10 return var end function test5(var) t = 10 var = var + 10 return t, var end 控制答应结果：call lua function call lua function test1 调用 C/C++调用Lua之遍历和获取Table的值增加方法char* getField(lua_State *L, const char* key); char* getField(lua_State *L, const char* key) { char *rlt = NULL; lua_pushstring(L, key); lua_gettable(L, -2); if (lua_isstring(L, -1)) { rlt = (char*)lua_tostring(L, -1); lua_pop(L, 1); return rlt; } return &quot;error&quot;; } 初始化方法(void LuaInterface03::init())中增加如下代码lua_getglobal(m_pLuaState, &quot;application&quot;); if (lua_isnumber(m_pLuaState, -1)) { char *width = getField(m_pLuaState, &quot;width&quot;); char *height = getField(m_pLuaState, &quot;height&quot;); CCLOG(&quot;width:%s&quot;, width); CCLOG(&quot;height:%s&quot;, height); int nWidth = atoi(width); int nHeight = atoi(height); } Lua中增加Tableapplication = { width = 320, height = 640, } Lua 调用 C/C++1.Lua调用C/C++函数创建一个Lua管理类，.h文件#ifndef LuaInterface04_hpp #define LuaInterface04_hpp #include &lt;stdio.h&gt; #include &quot;cocos2d.h&quot; #include &quot;lua.hpp&quot; #include &lt;string&gt; USING_NS_CC; using namespace std; class LuaInterface04 { public: LuaInterface04(); ~LuaInterface04(); static LuaInterface04 *shareInterface(); static int l_getMyName(lua_State * L) private: static LuaInterface04 *i; lua_State *m_pLuaState; void init(); }; #endif /* LuaInterface04_hpp */ .cpp文件#include &quot;LuaInterface04.h&quot; LuaInterface04 *LuaInterface04::i = NULL; LuaInterface04::LuaInterface04(){} LuaInterface04::LuaInterface04(){ if (m_pLuaState) { lua_close(m_pLuaState); m_pLuaState = NULL; } } // 调用C++ static int l_getMyName(lua_State * L) { lua_pushstring(L, &quot;String from C/C++&quot;); return 1; } void LuaInterface04::init() { // 创建一个新的状态 m_pLuaState = luaL_newstate(); // 打开所有系统提供的库 luaL_openlibs(m_pLuaState); // 调用C++ lua_pushcfunction(m_pLuaState, l_getMyName); lua_setglobal(m_pLuaState, &quot;getMyName&quot;); string path = CCFileUtils::sharedFileUtils()-&gt;fullPathForFilename(&quot;Interface04.lua&quot;); luaL_dofile(m_pLuaState, path.c_str()); lua_pcall(m_pLuaState, 0, 0, -1); } LuaInterface04 *LuaInterface04::shareInterface() { if (!i) { i = new LuaInterface04; i -&gt; init(); } return i; } 新建一个.lua的访问类文件，并且输入print(&quot;Begin&quot;) print(getMyName()) print(&quot;End&quot;) 控制答应结果：Begin String from C/C++ End 深入理解编写C函数上增加register_my_function方法.hstatic int l_showName(lua_State *L); static int l_showYoueName(lua_State *L); static void register_my_function(lua_State *L); .cppstatic int l_showName(lua_State *L) { const char * value1 = luaL_checkstring(L, -1); const char * value2 = luaL_checkstring(L, -2); const char * value3 = luaL_checkstring(L, -3); CCLOG(&quot;value1 is :%s&quot;, value1); CCLOG(&quot;value2 is :%s&quot;, value2); CCLOG(&quot;value3 is :%s&quot;, value3); //lua_pushstring(L, value1); return 1; } static int l_showYoueName(lua_State *L) { const char * value = luaL_checkstring(L, -1); lua_pushstring(L, value); return 1; } static void register_my_function(lua_State *L) { lua_pushcfunction(L, LuaInterface04::l_getMyName); lua_setglobal(L, &quot;getMyName&quot;); lua_pushcfunction(L, LuaInterface04::l_getMyName); lua_setglobal(L, &quot;showName&quot;); lua_pushcfunction(L, LuaInterface04::l_getMyName); lua_setglobal(L, &quot;show&quot;); } 在init中输入如下替换原始的调用方法// 调用C++ //lua_pushcfunction(m_pLuaState, l_getMyName); //lua_setglobal(m_pLuaState, &quot;getMyName&quot;); register_my_function(m_pLuaState); 新建一个.lua的访问类文件，并且输入showName(&quot;Hello iCocos&quot;) show(&quot;Hello iCocos&quot;， &quot;Hello Lua&quot;) 深入理解编写C函数下增加register_my_function方法.hstatic int lua_showreturn1(lua_State * L); static int lua_showreturn2(lua_State * L); static int lua_showreturn3(lua_State * L); static int lua_showtable(lua_State * L); static int lua_showtable2(lua_State * L); .cpp//print(lua_showreturn1()) static int lua_showreturn1(lua_State * L) { CCLOG(&quot;I am no return&quot;); return 0; } //print(lua_showreturn2()) static int lua_showreturn2(lua_State * L) { CCLOG(&quot;I am one values&quot;); lua_pushstring(L, &quot;I am one values&quot;); return 1; } //print(lua_showreturn3()) static int lua_showreturn3(lua_State * L) { CCLOG(&quot;I am two values&quot;); lua_pushstring(L, &quot;I am value one&quot;); lua_pushstring(L, &quot;I am value two&quot;); return 1; } //print(lua_showtable()) static int lua_showtable(lua_State * L) { CCLOG(&quot;I am a table&quot;); lua_newtable(L); char str[20] = {0}; for (int i = 1; i &lt;= 10; i++) { lua_pushnumber(L, i); // 压入key sprintf(str, &quot;numert is : %i&quot;, i); lua_pushstring(L, str); // 压入value lua_settable(L, -3); // 将前面的key和value保存到table中 } return 1; } //print(lua_showtable2()) static int lua_showtable2(lua_State * L) { CCLOG(&quot;I am a table2&quot;); lua_newtable(L); char str[20] = {0}; int looper = 1; while (looper &lt;= 10) { sprintf(str, &quot;key%i&quot;, looper); lua_pushstring(L, str); // 压入value looper++; lua_settable(L, -3); // 将前面的key和value保存到table中 } return 1; } 在init中输入如下替换原始的调用方法// 调用C++ //lua_pushcfunction(m_pLuaState, l_getMyName); //lua_setglobal(m_pLuaState, &quot;getMyName&quot;); lua_pushcfunction(L, LuaInterface04::lua_showreturn1); lua_setglobal(L, &quot;showreturn1&quot;); lua_pushcfunction(L, LuaInterface04::lua_showreturn2); lua_setglobal(L, &quot;showreturn2&quot;); lua_pushcfunction(L, LuaInterface04::lua_showreturn3); lua_setglobal(L, &quot;showreturn3&quot;); lua_pushcfunction(L, LuaInterface04::lua_showtable); lua_setglobal(L, &quot;getMyTable&quot;); lua_pushcfunction(L, LuaInterface04::lua_showtable2); lua_setglobal(L, &quot;getMyTable2&quot;); 新建一个.lua的访问类文件，并且输入print(showreturn1()) print(showreturn2()) print(showreturn3()) local t = getMyTable() for k, v in pairs(t) do print(k, v) end local t2 = getMyTable2() for k, v in pairs(t2) do print(k, v) end 2.Lua调用C/C++之标准C模块在lua中init.cstatic int showResult1(lua_State * L) { lua_pushstring(L, &quot;I am showResult1&quot;); return 1; } static int showResult2(lua_State * L) { const char *value = luaL_checkstring(L, -1); //string rel = strcat(&quot;iCocos&quot;, value); lua_pushstring(L, value); return 1; } static const luaL_Reg myLibs[] = { {&quot;result1&quot;, showResult1}, {&quot;result2&quot;, showResult2}, {NULL, NULL}, }; int luaopen_my_lib(lua_State * L) { //luaL_newLib(L, myLibs); luaL_register(L, &quot;my_lib&quot;, myLibs); return 1; } 在static const luaL_Reg loadedlibs[] 里面增加{&quot;my_lib&quot;, luaopen_my_lib}, 在lua中引入并调用方法--- 已入包 local my_lib = require &quot;my_lib&quot; --- 调用方法 print(my_lib.result1()) print(my_lib.result2(&quot;I am showResult2&quot;)) 待续 后续的学习和开发，会相继介绍和分析一下totua，luajit，手动和自动绑定，第三个引入(支付，分析，分析，统计)，插件引入(sqlite，json,zlib) 推荐 https://blog.csdn.net/wu554513392/article/details/60594724 https://blog.csdn.net/wyl1987527/article/details/77340896 https://www.cnblogs.com/zisou/p/cocos2dx-lua2.html]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>游戏</tag>
        <tag>cocos2dx lua 与 C/C++ 交互入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx lua —— Http请求总结与实战(封装)]]></title>
    <url>%2F2018%2F10%2F13%2Fcocos2dx-lua-%E2%80%94%E2%80%94-Http%E8%AF%B7%E6%B1%82%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AE%9E%E6%88%98-%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[今天的主题是关于cocos2dx lua实现短链接网络请求，使用Http实现基本的服务器网络数据获取，关于长链接（socket后续文件或者遇到需要的时候回特别实现与处理） 关于Http这里就不多做介绍了，不过，作为一个程序员，网络请求是开发中最多也是最重要的一环节，这里比较建议，搞懂http的整个请求流程！ 推荐：一次完整的HTTP请求过程 在有了基本的Lua知识和cocos2dx lua基本的了解和学习之后，我有了一个初步的cocos2dx lua开发常识，然后就开始在上面实现基本的界面，并根据界面操作请求和响应数据！ 入口场景在main中初始化场景中必要的UI. 创建一个背景图片和一个按钮，实现点击按钮跳转到另外一个场景，进行网络请求和数据获取 --- @class MainScene local MainScene = class(&quot;MainScene&quot;,cc.load(&quot;mvc&quot;).ViewBase) ---onEnter function MainScene:onEnter() print(&quot;onEnter&quot;) end ---createStaticButton 通用创建按钮方法 ---@param node table ---@param imageName table ---@param x table ---@param y table ---@param callBack table local function createStaticButton(node, imageName, x, y, callBack) local btn = ccui.Button:create(imageName, imageName) btn:move(x, y) btn:addClickEventListener(callBack) btn:addTo(node) end -- -----onCreate function MainScene:onCreate() -- 初始化背景 display.newSprite(&quot;HelloWorld.png&quot;) :move(display.center) :addTo(self) -- 初始化按钮 createStaticButton(self, &quot;button_start.png&quot;, display.cx, display.cy-150, function () self:getApp():enterScene(&quot;ApiRequest&quot;) end) end return MainScene 网络应用场景(ApiRequest)然后开始处理跳转之后的ApiRequest，和相关请求逻辑，这里主要是使用我们封装好的CocosRequest实现基本上的请求逻辑，然后拿到数据之后我们就可以根据实际UI和具体业务逻辑做处理 注意 测试的时候，将local url = “https://xxxx?cmd=501001&amp;uid=628941&amp;novelid=3782&quot;中的值换成自己的地址就可以 require &quot;json&quot; local CocosRequest = require &quot;app.CocosRequest&quot; --- @class ApiRequest local ApiRequest = class(&quot;ApiRequest&quot;, cc.load(&quot;mvc&quot;).ViewBase) ----local MainScene = class(&quot;MainScene&quot;, function() return display.newScene(&quot;MainScene&quot;) end) ---onEnter function ApiRequest:onEnter() print(&quot;onEnter&quot;) end -----onCreate function ApiRequest:onCreate() ----------------------- 创建自定义事件 start local function eventCustomListener1(event) local str = &quot;response: &quot;..event._usedata --labelStatusCode:setString(str) -- 如果返回的是 json 数据，这里解析 local data = json.decode(event._usedata) table.foreach(data, function(key, var) print(&quot;-----&quot;..key) table.foreach(var, function(a, b) print(a..&quot;-&quot;..b) end) end) end local listener1 = cc.EventListenerCustom:create(&quot;customEvent1&quot;,eventCustomListener1) cc.Director:getInstance():setNotificationNode(cc.Node:create()) local eventDispatcher = cc.Director:getInstance():getNotificationNode():getEventDispatcher() eventDispatcher:addEventListenerWithFixedPriority(listener1, 6) -- 将事件分配器赋值到CocosRequest.eventDispatcher -- 用来在http请求返回的回调函数中使用，因为回调函数是在异步线程中执行，必须用自定义事件更新ui线程数据 local tmpHttp = CocosRequest:getInstance() tmpHttp.eventDispatcher = eventDispatcher ----------------------- 创建自定义事件 end local tmp = CocosRequest:getInstance() local function callback(xhr) local event = cc.EventCustom:new(&quot;customEvent1&quot;) event._usedata = xhr.response eventDispatcher:dispatchEvent(event) print(&quot;post callback code = &quot;..xhr.statusText) end local type = tmp.POST local url = &quot;https://xxxx?cmd=501001&amp;uid=628941&amp;novelid=3782&quot; local dataPost = {} dataPost.data = &quot;hello&quot; dataPost.aaa = &quot;world&quot; dataPost.bbb = &quot;yang&quot; tmp:send(type, url, dataPost, callback) end return ApiRequest 网络请求封装(CocosRequest)最后才是我们的重头戏，CocosRequest是直接使用cocos2dx lua提供的XMLHttpRequest实现，其实就是做了一套逻辑，具体细节可以根据项目调整(此处已经测试通过，可直接拷贝使用) require &quot;json&quot; CocosRequest = {} CocosRequest.__index = CocosRequest CocosRequest.instance = nil CocosRequest.callback = nil CocosRequest.POST = &quot;POST&quot; CocosRequest.GET = &quot;GET&quot; function CocosRequest:new() local self = {} setmetatable(self,CocosRequest) return self end function CocosRequest:getInstance() if nil == self.instance then self.instance = self:new() end return self.instance end -- 数据转换，将请求数据由 table 型转换成 string，参数：table function CocosRequest:dataParse(data) if &quot;table&quot; ~= type(data) then print(&quot;data is not a table&quot;) return nil end local tmp = {} for key, value in pairs(data) do table.insert(tmp,key..&quot;=&quot;..value) end local newData = &quot;&quot; for i=1,#tmp do newData = newData..tostring(tmp[i]) if i&lt;#tmp then newData = newData..&quot;&amp;&amp;&quot; end end print(&quot;------- name is &quot;..newData) return newData end -- 发送数据，参数：string，string，table function CocosRequest:send(type, url, data, callback) local xhr = cc.XMLHttpRequest:new() --new 一个http request 实例 self.callback = callback --设置需要执行的函数 local newData = self:dataParse(data) if nil == newData or &quot;&quot; == newData then return end -- response回调函数 local function responseCallback() print(&quot;CocosRequest - &quot;..xhr.response) if nil ~= self.callback then self.callback(xhr) else print(&quot;callback is nil&quot;) end end -- 设置返回值类型及回调函数 xhr.responseType = cc.XMLHTTPREQUEST_RESPONSE_STRING xhr:registerScriptHandler(responseCallback) -- 请求方式判断 if self.POST == type then xhr:open(self.POST, url) xhr:registerScriptHandler(responseCallback) xhr:send(newData) elseif self.GET == type then xhr:open(self.GET, url..&quot;?&quot;..newData) xhr:send() else print(&quot;ERROR : type only can be \&quot;Post\&quot; or \&quot;GET\&quot;&quot;) end end --------------------- return CocosRequest 由于在Web中使用XMLHTTPRequest对象发出HTTP请求很普遍,Cocos2dx Lua对其进行了移植,可以在 Cocos2 d-x LumP中使用 XMLHTTPRequest对象 XMLHTTPRequest对象中几个常用的函数和属性如下 (1)open(),与服务器连接,创建新的请求 (2)send(),向服务器发送请求 (3)abort(),退出当前请求 (4)readyState属性,提供当前请求的就绪状态,其中4表示准备就绪 (5)tatus属性,提供当前HTTP请求状态码,其中200表示成功请求 (6)respomseText属性,服务器返回的请求响应 (7) onreadystatechange属性。设置回调函数,当服务器处理完请求后就会自动调用该函数。 其中open和send函数,以及onreadystatechange属性是HTTP请求的关键。open函数有以下5个参数可以使用 (1) request-type:发送请求的类型。典型的值是GET或POST,也可以发送HEAD请求 (2) url:要请求连接的URL (3) asynch:如果希望使用异步连接则为true,否则为 false。该参数是可选的,默认为 (4) username:如果需要身份验证,则可以在此指定用户名。该可选参数没有默认值 (5) password:如果需要身份验证,则可以在此指定口令。该可选参数没有默认值。 服务器响应下面是我们验证返回后的服务器数据(未做处理) [ { &quot;code&quot;:1, &quot;msg&quot;:&quot;操作成功&quot;, &quot;data&quot;:[ { &quot;novelid&quot;:&quot;3782&quot;, &quot;uid&quot;:&quot;628875&quot;, &quot;cid&quot;:&quot;5&quot;, &quot;title&quot;:&quot;零下记忆&quot;, &quot;cover&quot;:&quot;http://xxxx/img/cb/2f/f1/cb2ff155bbda8387f4b8efe917c46cd3.jpg&quot;, &quot;scover&quot;:&quot;http://xxxx/img/cb/2f/f1/cb2ff155bbda8387f4b8efe917c46cd3.jpg&quot;, &quot;shareimg&quot;:&quot;http://xxxx/img/ed/68/e6/ed68e67f77841ac76be189f0a04aa030.jpg&quot;, &quot;intro&quot;:&quot;&quot;, &quot;tags&quot;:&quot;悬疑&quot;, &quot;reason&quot;:&quot;&quot;, &quot;issingle&quot;:&quot;1&quot;, &quot;sort&quot;:&quot;0&quot;, &quot;hits&quot;:&quot;0&quot;, &quot;reads&quot;:&quot;18753&quot;, &quot;clues&quot;:20, &quot;likes&quot;:&quot;1&quot;, &quot;unlikes&quot;:&quot;0&quot;, &quot;cmts&quot;:&quot;0&quot;, &quot;favs&quot;:&quot;2&quot;, &quot;words&quot;:&quot;18420&quot;, &quot;chapters&quot;:&quot;35&quot;, &quot;pub_chapters&quot;:&quot;35&quot;, &quot;chapter_index&quot;:&quot;1&quot;, &quot;pubtime&quot;:&quot;0&quot;, &quot;updatetime&quot;:&quot;1539337440&quot;, &quot;addtime&quot;:&quot;1534222233&quot;, &quot;resversion&quot;:&quot;30&quot;, &quot;isuser&quot;:&quot;0&quot;, &quot;status&quot;:&quot;1&quot;, &quot;wstatus&quot;:&quot;1&quot;, &quot;offsale&quot;:&quot;0&quot;, &quot;chapterstatus&quot;:&quot;-1&quot;, &quot;leadrole&quot;:{ &quot;roleid&quot;:&quot;8478&quot;, &quot;rolename&quot;:&quot;炽念&quot; }, &quot;cname&quot;:&quot;推理&quot;, &quot;isnew&quot;:0, &quot;fatime&quot;:&quot;8月14日&quot;, &quot;isreading&quot;:1, &quot;iscomplete&quot;:1, &quot;isfav&quot;:0, &quot;liketype&quot;:0, &quot;shareinfo&quot;:{ &quot;type&quot;:1, &quot;title&quot;:&quot;零下记忆&quot;, &quot;intro&quot;:&quot;&quot;, &quot;img&quot;:&quot;http://xxxx/img/ed/68/e6/ed68e67f77841ac76be189f0a04aa030.jpg&quot;, &quot;url&quot;:&quot;http://xxxx/novel/startReading?novelid=3782&amp;chl=jmt&quot; }, &quot;userinfo&quot;:{ &quot;uid&quot;:&quot;628875&quot;, &quot;username&quot;:&quot;writer10&quot;, &quot;nickname&quot;:&quot;离经易道&quot;, &quot;headurl&quot;:&quot;http://xxxx/headimg/bb/d3/b6/628875_1_bbd3b631717ad615f38a6670573a375c_300x300.jpg?v=1526708983&quot;, &quot;sex&quot;:&quot;1&quot;, &quot;vtype&quot;:&quot;0&quot;, &quot;regtype&quot;:&quot;2&quot;, &quot;vname&quot;:&quot;&quot;, &quot;vicon&quot;:&quot;&quot;, &quot;isfollow&quot;:0 } } ], &quot;cmd&quot;:501001, &quot;time&quot;:1539677040 } ]]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>游戏</tag>
        <tag>cocos2dx lua —— Http请求总结与实战(封装)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS游戏——渠道越狱打包流程]]></title>
    <url>%2F2018%2F10%2F09%2FiOS%E6%B8%B8%E6%88%8F%E2%80%94%E2%80%94%E6%B8%A0%E9%81%93%E8%B6%8A%E7%8B%B1%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[关于iOS普通ipa打包这里就不说了，只要注意苹果的一些协议条款，基本上步骤都是傻瓜式的，如果不知道如何打包iOS普通ipa包，请出门左转，度娘在哪里等你！ 那么，如何将app打包成越狱包，越狱iphone在cydia源上下载安装，这样的需求在互联网游戏行业是非常普遍的，尤其是各种马甲包横行的时代！ 关于越狱相关内容，请看这里 iOS越狱解除工具 ios越狱原理详解 常见deb包打包方式1、第一种方式：自定义目录下 如desktop创建文件夹，起名test，test内新建文件夹Payload把xcode Build好的.app（Products目录中）拷到Payload目录中打开终端，cd指令 到test文件目录下，执行 zip -r “xxx.ipa” * 注意里面的空格：(zip -r “xxx.ipa”[空格]* ) ipa包就打好了，可以安装到越狱手机上试试看 注意事项：Debug或Release的Any iOS SDK都设置为正式发布证书，经测试该越狱包可正常接收推送。 2、第二种方式：在xcode中点击Product-&gt;Archive,完成后会弹出Organizer，点右边的Distribute，弹出一个向导对话框，点击“Export as Xcode Archive”，选择位置，会在那个位置生成后缀名是.xcarchive的文件右键“显示包内容”-&gt;”Products”-&gt;”applications” 然后找到那个应用程序， 将其拖到iTunes里面，在itunes的【应用程序】里找到这个文件，然后右键“在Finder 中显示”，便可找到ipa文件了…. ipa包就打好了，可以安装到越狱手机上试试看 最近发现了一种更好的方式致谢： 胖梁的技术笔记 1.修改编译选项重新打包在工程的Build Settings -&gt; Code Signing -&gt; Code Signing Identity选项, 将 Debug 和 Release 下的 Any iOS SDK都设置为 Don’t Code Sign然后在重新Archive 2.准备目录创建一个目录用来打包,如tmp,tmp下建DEBIAN和Applications两个目录, DEBIAN下建一个文本文件control tmp目录结构如下: -DEBIAN ---control -Applications control文件就是打包时的配置文件,它也会作为deb包的配置被打包到包中, 文件例子: Package: com.sharedream.game Name: 游戏测试 Version: 0.1-1 Description: 游戏测试游戏,开发中... Section: 游戏 Depends: firmware (&gt;= 4.3) Priority: optional Architecture: iphoneos-arm Author: liangwei &lt;http://weibo.com/iamliangwei&gt; Homepage: http://weibo.com/iamliangwei Icon: file:///Applications/game.app/Icon.png Maintainer: liangwei &lt;http://weibo.com/iamliangwei&gt; 然后将xcode打包出来的.app文件整个拷贝到Applications目录下, 结构如下: -DEBIAN ---control -Applications ---game.app 3.打包退出至tmp的上层目录 dpkg-deb -b tmp game.deb 看到如下几行就是打包完成了 warning, `com.sull.sample/DEBIAN/control&apos; contains user-defined field `Name&apos; warning, `com.sull.sample/DEBIAN/control&apos; contains user-defined field `Author&apos; warning, `com.sull.sample/DEBIAN/control&apos; contains user-defined field `Sponsor&apos; dpkg-deb: ignoring 3 warnings about the control file(s) 拷贝到cydia源中, 重新扫描包生成Packages列表文件, 并压缩成Packages.bz2就可以啦 dpkg-scanpackages -m debs &gt;Packages bzip2 -zkf Packages contains ununderstood data member data.tar.xz” 的安装错误 是因为自从1.17.0版本的dpkg-deb开始, 默认使用xz格式来压缩data.tar文件但是,cydia在ios提供的dpkg是1.14版本, 还没有支持xz这种压缩格式所以我们需要设置”-Zgzip”参数给dpkg-deb 进行打包, 类似命令: dpkg-deb -Zgzip -b tmp game.deb 关于iOS普通包打包可以参考这里： https://blog.csdn.net/zhanghow/article/details/60603461?utm_source=blogxgwz8]]></content>
      <categories>
        <category>Games</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>iOS游戏——渠道越狱打包流程</tag>
        <tag>越狱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx lua注册事件详解]]></title>
    <url>%2F2018%2F10%2F05%2Fcocos2dx-lua%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[最近在学习cocos2dx lua的时候，遇到了一些关于事件注册的逻辑！ 结合用户实际操作和游戏的真实需求，关于事件在游戏中还是使用非常多的，所以特此记录一下 事件(源自网络) 事件是可以被控件识别的操作。如按下确定按钮，选择某个单选按钮或者复选框。每一种控件有自己可以识别的事件，如窗体的加载、单击、双击等事件，编辑框（文本框）的文本改变事件，等等。 事件是用户对窗口上各种组件的操作。 事件有系统事件和用户事件。 1.系统事件由系统激发，如时间间隔24小时，银行储蓄的存款日期增加一天。 2.用户事件由用户激发，如用户点击按钮，在文本框中显示特定的文本。事件驱动控件执行某项功能。 触发事件的对象称为事件发送者；接收事件的对象称为事件接受者； 注: 这里只针对用户事件！ cocos2dx中事件的类型 registerScriptTouchHandler 注册触屏事件 registerScriptTapHandler 注册点击事件 registerScriptHandler 注册基本事件 包括 触屏 层的进入 退出 事件 registerScriptKeypadHandler 注册键盘事件 registerScriptAccelerateHandler 注册加速事件 在3.x之前事件的注册可以直接使用这些方式来注册， 事件监听器主要有： 触摸事件 : EventListenerTouchOneByOne、EventListenerTouchAllAtOnce 鼠标响应事件 : EventListenerMouse 键盘响应事件 : EventListenerKeyboard 加速计事件 : EventListenerAcceleration 自定义事件 : EventListenerCustom 物理碰撞事件 : EventListenerPhysicsContact 游戏手柄事件 : EventListenerController 而在3.x中由于加入了C++11的特性，而对事件的分发机制通过事件分发器EventDispatcher 来进行统一的管理。 官方说明：触摸事件，键盘事件，加速器事件和自定义事件等所有事件都由 EventDispatcher 分发。 TouchDispatcher, KeypadDispatcher, KeyboardDispatcher, AccelerometerDispatcher 已经被移除。 【事件分发器】事件分发器EventDispatcher，用于统一管理事件监听器的所有事件的分发。 EventDispatcher 的特性主要有: 事件的分发基于渲染顺序 所有的事件都由 EventDispatcher 分发 可以使用 EventDispatcher 来分发自定义事件 可以注册一个 lambda 表达式作为回调函数 1、_eventDispatcher_eventDispatcher是Node的属性，通过Director::getInstance()-&gt;getEventDispatcher() 获得。 _eventDispatcher的工作由三部分组成： （1）事件分发器 ：EventDispatcher。 （2）事件类型 ：EventTouch, EventKeyboard 等。 （3）事件监听器 ：EventListenerTouch, EventListenerKeyboard 等。 监听器实现了各种触发后的逻辑，在适当时候由事件分发器分发事件类型，然后调用相应类型的监听器。 2、添加/删除监听器 添加监听器： addEventListenerWithSceneGraphPriority ， addEventListenerWithFixedPriority 。 删除监听器： removeEventListener ， removeAllEventListeners 。 3、主要函数包含监听器的添加、删除、暂停、恢复，优先级的设置，手动分发事件等。 class EventDispatcher : public Ref { /** * 添加监听器 * - addEventListenerWithSceneGraphPriority * - addEventListenerWithFixedPriority * - addCustomEventListener */ //使用 场景图的优先级 为指定事件添加一个监听. //listener : 指定要监听的事件. //node : 这个节点的绘制顺序是基于监听优先级. //优先级 : 0 void addEventListenerWithSceneGraphPriority(EventListener* listener, Node* node); //使用 一定的优先级 为指定事件添加一个监听. //listener : 指定要监听的事件. //fixedPriority : 这个监听器的固定优先级. //优先级 : fixedPriority。(但是不能为0，因为他是场景图的基本优先级) void addEventListenerWithFixedPriority(EventListener* listener, int fixedPriority); //用户自定义监听器 EventListenerCustom* addCustomEventListener(const std::string &amp;eventName, const std::function&lt;void(EventCustom*)&gt;&amp; callback); /** * 删除监听器 * - removeEventListener * - removeEventListenersForType * - removeEventListenersForTarget * - removeCustomEventListeners * - removeAllEventListeners */ //删除指定监听器 void removeEventListener(EventListener* listener); //删除某类型对应的所有监听器 //EventListener::Type:: // 单点触摸 : TOUCH_ONE_BY_ONE // 多点触摸 : TOUCH_ALL_AT_ONCE // 键盘 : KEYBOARD // 鼠标 : MOUSE // 加速计 : ACCELERATION // 自定义 : CUSTOM void removeEventListenersForType(EventListener::Type listenerType); //删除绑定在节点target上的所有监听器 void removeEventListenersForTarget(Node* target, bool recursive = false); //删除名字为customEventName的所有自定义监听器 void removeCustomEventListeners(const std::string&amp; customEventName); //移除所有监听器 void removeAllEventListeners(); /** * 暂停、恢复在节点target上的所有监听器 * - pauseEventListenersForTarget * - resumeEventListenersForTarget */ void pauseEventListenersForTarget(Node* target, bool recursive = false); void resumeEventListenersForTarget(Node* target, bool recursive = false); /** * 其他 * - setPriority * - setEnabled * - dispatchEvent * - dispatchCustomEvent */ //设置某监听器的优先级 void setPriority(EventListener* listener, int fixedPriority); //启用事件分发器 void setEnabled(bool isEnabled); bool isEnabled() const; //手动派发自定义事件 void dispatchEvent(Event* event); //给名字为eventName的自定义监听器, 绑定用户数据 void dispatchCustomEvent(const std::string &amp;eventName, void *optionalUserData = nullptr); } 4、关于事件监听器的优先权通过 addEventListenerWithSceneGraphPriority 添加的监听器，优先权为0。通过 addEventListenerWithFixedPriority 添加的监听器，可以自定义优先权，但不能为0。 优先级越低，越先响应事件。 如果优先级相同，则上层的（z轴）先接收触摸事件。 5、使用步骤 （1）获取事件分发器： dispatcher = Director::getInstance()-&gt;getEventDispatcher(); （2）创建监听器： auto listener = EventListenerTouchOneByOne::create(); （3）绑定响应事件函数： listener-&gt;onTouchBegan = CC_CALLBACK_2(callback, this); （4）将监听器添加到事件分发器dispatcher中： dispatcher-&gt;addEventListenerWithSceneGraphPriority(Listener, this); （5）编写回调响应函数： bool callback(Touch touch, Event event) { … } 实战案例先来看看项目用用到的一些简单时间的操作， 两种方式创建使用 触摸事件根据用户手机在屏幕触摸的位置，对场景或者场景中的精灵，控件的做一些处理，这种类型偏向于触摸屏的设备。 local function onTouchBegan(touch, event) local location = touch:getLocation() local visiableSize = cc.Director:getInstance():getVisibleSize() local origin = cc.Director:getInstance():getVisibleOrigin() local finalX = location.x - (origin.x + visiableSize.width/2) local finalY = location.y - (origin.y + visiableSize.height/2) finalX, finalY 根据实际屏幕计算触摸点 end local listener = cc.EventListenerTouchOneByOne:create() listener:registerScriptHandler(onTouchBegan, cc.Handler.EVENT_TOUCH_BEGAN) local eventDiapatcher = self:getEventDispatcher() eventDiapatcher:addEventListenerWithSceneGraphPriority(listener, self) 键盘事件这里是coco2dx 定义的一套键盘字节码，每一个键盘上的键都对应一个数字，我们可以根据用户按键对精灵和界面做控制，这种偏向于桌面版的游戏！ 方法一-- 键盘监听器 local listener = cc.EventListenerKeyboard:create() listener:registerScriptHandler(function(keyCode, event) if self.tank ~= nil then -- w if keyCode == 146 then self.tank:MoveBegin(&quot;up&quot;) -- s elseif keyCode == 142 then self.tank:MoveBegin(&quot;down&quot;) -- a elseif keyCode == 124 then self.tank:MoveBegin(&quot;left&quot;) -- d elseif keyCode == 127 then self.tank:MoveBegin(&quot;right&quot;) end end end, cc.Handler.EVENT_KEYBOARD_PRESSED) --- cc.Handler.EVENT_KEYBOARD_RELEASED) local eventDiapatcher = self:getEventDispatcher() eventDiapatcher:addEventListenerWithSceneGraphPriority(listener, self) 方法二local function keyboardPressed(keyCode, event) -- up if keyCode == 28 then self:MoveCursor(0, 1) -- down elseif keyCode == 29 then self:MoveCursor(0, -1) -- left elseif keyCode == 26 then self:MoveCursor(-1, 0) -- right elseif keyCode == 27 then self:MoveCursor(1, 0) -- page up elseif keyCode == 38 then self:SwitchCursor(-1) -- page down elseif keyCode == 44 then self:SwitchCursor(1) -- enter elseif keyCode == 38 then self:Place() -- delete elseif keyCode == 44 then self:Delete() -- F3 elseif keyCode == 49 then self:Load() -- F4 elseif keyCode == 50 then self:Save() end print(&quot;key board ???????? keyCode&quot;, keyCode) end -- 键盘监听器 local listener = cc.EventListenerKeyboard:create() listener:registerScriptHandler(keyboardPressed, cc.Handler.EVENT_KEYBOARD_PRESSED) local eventDiapatcher = self:getEventDispatcher() eventDiapatcher:addEventListenerWithSceneGraphPriority(listener, self) 这里主要说一下codeKey，codeKey是cocos2dx定义的一套键盘的代码，每个平台几乎是通用的 【触摸事件】1、单点触摸：EventListenerTouchOneByOne单点触摸监听器相关： static EventListenerTouchOneByOne* create(); std::function&lt;bool(Touch*, Event*)&gt; onTouchBegan; //只有这个返回值为 bool std::function&lt;void(Touch*, Event*)&gt; onTouchMoved; std::function&lt;void(Touch*, Event*)&gt; onTouchEnded; std::function&lt;void(Touch*, Event*)&gt; onTouchCancelled; 使用举例： //获取事件分发器 auto dispatcher = Director::getInstance()-&gt;getEventDispatcher(); //创建单点触摸监听器 EventListenerTouchOneByOne auto touchListener = EventListenerTouchOneByOne::create(); //单点触摸响应事件绑定 touchListener-&gt;onTouchBegan = CC_CALLBACK_2(HelloWorld::onTouchBegan, this); touchListener-&gt;onTouchMoved = CC_CALLBACK_2(HelloWorld::onTouchMoved, this); touchListener-&gt;onTouchEnded = CC_CALLBACK_2(HelloWorld::onTouchEnded, this); touchListener-&gt;onTouchCancelled = CC_CALLBACK_2(HelloWorld::onTouchCancelled, this); //在事件分发器中，添加触摸监听器，事件响应委托给 this 处理 dispatcher-&gt;addEventListenerWithSceneGraphPriority(touchListener, this); //单点触摸事件响应函数 bool onTouchBegan(Touch *touch, Event *unused_event) { CCLOG(&quot;began&quot;); return true; } void onTouchMoved(Touch *touch, Event *unused_event) { CCLOG(&quot;moved&quot;); } void onTouchEnded(Touch *touch, Event *unused_event) { CCLOG(&quot;ended&quot;); } void onTouchCancelled(Touch *touch, Event *unused_event) { CCLOG(&quot;cancelled&quot;); } 2、多点触摸：EventListenerTouchAllAtOnce多点触摸监听器相关： static EventListenerTouchAllAtOnce* create(); std::function&lt;void(const std::vector&lt;Touch*&gt;&amp;, Event*)&gt; onTouchesBegan; std::function&lt;void(const std::vector&lt;Touch*&gt;&amp;, Event*)&gt; onTouchesMoved; std::function&lt;void(const std::vector&lt;Touch*&gt;&amp;, Event*)&gt; onTouchesEnded; std::function&lt;void(const std::vector&lt;Touch*&gt;&amp;, Event*)&gt; onTouchesCancelled; 使用举例： //获取事件分发器 auto dispatcher = Director::getInstance()-&gt;getEventDispatcher(); //创建多点触摸监听器 EventListenerTouchAllAtOnce auto touchesListener = EventListenerTouchAllAtOnce::create(); //多点触摸响应事件绑定 touchesListener-&gt;onTouchesBegan = CC_CALLBACK_2(HelloWorld::onTouchesBegan, this); touchesListener-&gt;onTouchesMoved = CC_CALLBACK_2(HelloWorld::onTouchesMoved, this); touchesListener-&gt;onTouchesEnded = CC_CALLBACK_2(HelloWorld::onTouchesEnded, this); touchesListener-&gt;onTouchesCancelled = CC_CALLBACK_2(HelloWorld::onTouchesCancelled, this); //在事件分发器中，添加触摸监听器，事件响应委托给 this 处理 dispatcher-&gt;addEventListenerWithSceneGraphPriority(touchesListener, this); //多点触摸事件响应函数 void onTouchesBegan(const std::vector&lt;Touch*&gt;&amp; touches, Event *unused_event) { CCLOG(&quot;began&quot;); } void onTouchesMoved(const std::vector&lt;Touch*&gt;&amp; touches, Event *unused_event) { CCLOG(&quot;moved&quot;); } void onTouchesEnded(const std::vector&lt;Touch*&gt;&amp; touches, Event *unused_event) { CCLOG(&quot;ended&quot;); } void onTouchesCancelled(const std::vector&lt;Touch*&gt;&amp;touches, Event *unused_event) { CCLOG(&quot;cancelled&quot;); } 【鼠标事件】EventListenerMouse，主要用于监听鼠标的点击、松开、移动、滚轮的事件。 鼠标事件监听器相关： static EventListenerMouse* create(); std::function&lt;void(Event* event)&gt; onMouseDown; //按下鼠标, 单击鼠标 std::function&lt;void(Event* event)&gt; onMouseUp; //松开鼠标, 按下的状态下松开 std::function&lt;void(Event* event)&gt; onMouseMove; //移动鼠标, 在屏幕中移动 std::function&lt;void(Event* event)&gt; onMouseScroll;//滚动鼠标, 滚动鼠标的滚轮 使用举例： //获取事件分发器 auto dispatcher = Director::getInstance()-&gt;getEventDispatcher(); //创建鼠标事件监听器 EventListenerMouse EventListenerMouse* mouseListenter = EventListenerMouse::create(); //鼠标事件响应函数 mouseListenter-&gt;onMouseDown = CC_CALLBACK_1(HelloWorld::onMouseDown, this); mouseListenter-&gt;onMouseUp = CC_CALLBACK_1(HelloWorld::onMouseUp, this); mouseListenter-&gt;onMouseMove = CC_CALLBACK_1(HelloWorld::onMouseMove, this); mouseListenter-&gt;onMouseScroll = CC_CALLBACK_1(HelloWorld::onMouseScroll, this); //添加鼠标事件监听器，事件响应处理委托给this dispatcher-&gt;addEventListenerWithSceneGraphPriority(mouseListenter, this); //事件响应函数 void onMouseDown(Event* event) { CCLOG(&quot;Down&quot;); } void onMouseUp(Event* event) { CCLOG(&quot;UP&quot;); } void onMouseMove(Event* event) { CCLOG(&quot;MOVE&quot;); } void onMouseScroll(Event* event) { CCLOG(&quot;Scroll&quot;); } 【键盘事件】EventListenerKeyboard，主要用于监听键盘某个键的按下、松开的事件。 键盘事件监听器相关： static EventListenerKeyboard* create(); std::function&lt;void(EventKeyboard::KeyCode, Event*)&gt; onKeyPressed; //按下某键 std::function&lt;void(EventKeyboard::KeyCode, Event*)&gt; onKeyReleased; //松开某键 //键盘按键枚举类型 EventKeyboard::KeyCode //KeyCode的值对应的不是键盘的键值、也不是ASCII码，只是纯粹的枚举类型 //如: // EventKeyboard::KeyCode::KEY_A // EventKeyboard::KeyCode::KEY_1 // EventKeyboard::KeyCode::KEY_F1 // EventKeyboard::KeyCode::KEY_SPACE // EventKeyboard::KeyCode::KEY_ALT // EventKeyboard::KeyCode::KEY_SHIFT 使用举例： // //获取事件分发器 auto dispatcher = Director::getInstance()-&gt;getEventDispatcher(); //创建键盘按键事件监听器 EventListenerKeyboard* keyboardListener = EventListenerKeyboard::create(); //绑定事件响应函数 keyboardListener-&gt;onKeyPressed = CC_CALLBACK_2(HelloWorld::onKeyPressed, this); keyboardListener-&gt;onKeyReleased = CC_CALLBACK_2(HelloWorld::onKeyReleased, this); //添加监听器 dispatcher-&gt;addEventListenerWithSceneGraphPriority(keyboardListener, this); //事件响应函数 void onKeyPressed(EventKeyboard::KeyCode keyCode, Event* event) { if (EventKeyboard::KeyCode::KEY_J == keyCode) { CCLOG(&quot;Pressed: J&quot;); } } void onKeyReleased(EventKeyboard::KeyCode keyCode, Event* event) { if (EventKeyboard::KeyCode::KEY_SPACE == keyCode) { CCLOG(&quot;Released: SPACE&quot;); } } 【加速计事件】EventListenerAcceleration，主要用于监听移动设备的所受重力方向感应事件。 重力感应来自移动设备的加速计，通常支持 (X, Y, Z) 三个方向的加速度感应，所以又称为三向加速计。在实际应用中，可以根据3个方向的力度大小来计算手机倾斜的角度或方向。 1、加速计信息类Acceleration该类中每个方向的加速度，大小都为一个重力加速度大小。 //加速计信息 class Acceleration { double x; double y; double z; }; 2、开启加速计感应在使用加速计事件监听器之前，需要先启用此硬件设备： Device::setAccelerometerEnabled(true); 3、加速计监听器相关static EventListenerAcceleration* create(const std::function&lt;void(Acceleration*, Event*)&gt;&amp; callback); std::function&lt;void(Acceleration*, Event*)&gt; onAccelerationEvent; 4、使用举例//标签: 显示加速计信息 label = Label::createWithTTF(&quot;no used&quot;, &quot;Marker Felt.ttf&quot;, 12); label-&gt;setPosition(visibleSize / 2); this-&gt;addChild(label); //小球: 可视化加速计 ball = Sprite::create(&quot;ball.png&quot;); ball-&gt;setPosition(visibleSize / 2); this-&gt;addChild(ball); //获取事件分发器 auto dispatcher = Director::getInstance()-&gt;getEventDispatcher(); //需要开启移动设备的加速计 Device::setAccelerometerEnabled(true); //创建加速计事件监听器 auto accelerationListener = EventListenerAcceleration::create(CC_CALLBACK_2(HelloWorld::onAccelerationEvent, this)); //添加加速计监听器 dispatcher-&gt;addEventListenerWithSceneGraphPriority(accelerationListener, this); //事件响应函数 void HelloWorld::onAccelerationEvent(Acceleration* acceleration, Event* event) { char s[100]; sprintf(s, &quot;X: %f; Y: %f; Z:%f; &quot;, acceleration-&gt;x, acceleration-&gt;y, acceleration-&gt;z); label-&gt;setString(s); //改变小球ball的位置 float x = ball-&gt;getPositionX() + acceleration-&gt;x * 10; float y = ball-&gt;getPositionY() + acceleration-&gt;y * 10; Vec2 pos = Vec2(x, y); pos.clamp(ball-&gt;getContentSize() / 2, Vec2(288, 512) - ball-&gt;getContentSize() / 2); ball-&gt;setPosition(pos); //设置位置 } 【自定义事件】以上是系统自带的事件类型，事件由系统内部自动触发，如 触摸屏幕，键盘响应等。 EventListenerCustom 自定义事件，它不是由系统自动触发，而是人为的干涉。 它的出现，使得2.x中的 观察者模式 NotificationCenter（订阅发布消息） 被无情的遗弃了。 在 3.x 中，使用EventListenerCustom来实现消息的订阅与发布。 学习它之前，最好了解一下 NotificationCenter 这个类的用法。 NotificationCenter 的用法参见：http://shahdza.blog.51cto.com/2410787/1611575 1、创建自定义监听器该监听器，就相当于是订阅消息。即与NotificationCenter的 addObserver 类似。 //eventName : 监听器名字，即消息的名称 //callback : 监听器函数，即消息的回调函数 static EventListenerCustom* create(const std::string&amp; eventName, const std::function&lt;void(EventCustom*)&gt;&amp; callback); 2、分发自定义事件自定义的事件监听器，需要通过手动的方式，将事件分发出去。 通过 EventCustom(string eventName); 来设置需要发布消息的数据信息，eventName为消息名称。 其中EventCustom可以通过setUserData来绑定想要传递的消息数据。 通过 dispatcher-&gt;dispatchEvent(&amp;event); 来手动将事件分发出去。即发布消息。 这与NotificationCenter的 postNotification 类似。 EventCustom event(&quot;custom_event&quot;); event-&gt;setUserData((void*)123); // 绑定消息传递的数据，可以为任意类型void。 dispatcher-&gt;dispatchEvent(&amp;event); // 发布名称为&quot;custom_event&quot;的消息。 3、使用举例//获取事件分发器 auto dispatcher = Director::getInstance()-&gt;getEventDispatcher(); //创建自定义事件监听器 //监听器名字 : &quot;custom_event&quot; //事件响应函数: HelloWorld::onCustomEvent auto customListener = EventListenerCustom::create(&quot;custom_event&quot;, CC_CALLBACK_1(HelloWorld::onCustomEvent, this)); //添加自定义事件监听器，优先权为1 dispatcher-&gt;addEventListenerWithFixedPriority(customListener, 1); //手动分发监听器的事件，通过dispatchEvent发布名称为custom_event的消息。 EventCustom event = EventCustom(&quot;custom_event&quot;); event-&gt;setUserData((void*)123); // 绑定消息传递的数据，可以为任意类型void。 dispatcher-&gt;dispatchEvent(&amp;event); //消息事件回调函数 void HelloWorld::onCustomEvent(EventCustom* event) { // 获取消息传递的数据 int* data = (int*)event-&gt;getUserData() CCLOG(&quot;onCustomEvent data = %d&quot;, data); } 4、说明 每个自定义的事件监听器，都有一个监听器名字eventName。即为订阅的消息名称。 需要通过 dispatcher-&gt;dispatchEvent(&amp;event); 来手动将事件分发出去。即为发布消息。 可以通过 dispatcher-&gt;dispatchCustomEvent(,); 来给自定义事件监听器绑定一个用户数据。]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>事件</tag>
        <tag>cocos2dx lua注册事件详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx lua 闭包(匿名函数)入门实战]]></title>
    <url>%2F2018%2F09%2F28%2Fcocos2dx-lua-%E9%97%AD%E5%8C%85-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0-%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[本文首先通过具体的例子讲解了Lua中闭包的概念，然后总结了闭包的应用场合，最后探讨了Lua中闭包的实现原理。 闭包的概念 在Lua中，闭包（closure）是由一个函数和该函数会访问到的非局部变量（或者是upvalue）组成的，其中非局部变量（non-local variable）是指不是在局部作用范围内定义的一个变量，但同时又不是一个全局变量，主要应用在嵌套函数和匿名函数里，因此若一个闭包没有会访问的非局部变量，那么它就是通常说的函数。也就是说，在Lua中，函数是闭包一种特殊情况。 不知道c++的lambda和lua的闭包是谁先谁后，不过就我来说，是先学了c++，最近才接触到现代lua。因此把一切向c++看齐，会不自觉地把一切和c++做对比。 就闭包来说，不就是c++的lambda嘛！ 前面所说的upvalue，也就是一开始按引用捕获，在变量退出生命期时，拷贝到Functor的成员变量里来，变成了按值捕获。这算是解释性语言特有的灵活性吧，变量可以在运行时按解释器的便利来移动位置，而不必像苦哈哈的编译性语言，一旦决定好位置，就无法移动了。 在Lua的C API中，所有关于Lua中的函数的核心API都是以closure来命名的，也可视为这一观点的延续。在Lua中，函数是一种第一类型值（First-Class Value），它们具有特定的词法域（Lexical Scoping）。 Lua使用结构体upvalue来实现闭包。外面的局部变量可以直接通过upvalue进行访问。 upvalue最开始的时候指向栈中的一个变量，此时这个变量还在它的生存周期内。 当变量离开作用域（译者注：就是函数返回后，变量的生存周期结束时），这个变量就从栈转移到了upvalue中。 虽然这个变量存储在upvalue中，但是访问这个变量还是间接通过upvalue中的一个指针进行的（译者注：和在栈中时候的访问方式一样）。 因此，变量位置的转移对任何试图读写这个变量的代码都是透明的。 有别于这个变量在一个函数内部时候的行为，函数声明、访问这个变量，就是直接对栈的操作。 看下具体例子： function f1(n) --函数参数n也是局部变量 local function f2() print(n) --引用外部函数的局部变量 end return f2 end g1 = f1(2015) g1() -- 打印出2015 g2 = f1(2016) g2() -- 打印出2016 这里的n就是upvalue。upvalue实际指的是变量而不是值，这些变量可以在内部函数之间共享，即upvalue提供一种闭包之间共享数据的方法， 再看个例子： function Create(n) local function foo1() print(n) end local function foo2() n = n + 10 end return foo1,foo2 end f1,f2 = Create(2015) f1() -- 打印2015 f2() f1() -- 打印2025 f2() f1() -- 打印2035 上面的例子中，闭包f1和f2共享同一个upvalue了，这是因为当Lua发现两个闭包的upvalue指向的是当前堆栈上的相同变量时，会聪明地只生成一个拷贝，然后让这两个闭包共享该拷贝，这样任一个闭包对该upvalue进行修改都会被另一个探知。 为什么会这样，我们看下面的解释： 通过为每个变量最多创建一个upvalue并按需要重复利用这个upvalue，保证了未决状态（未超过生命周期）的局部变量（pending vars）能够在闭包之间正确地共享。 为了保证这种唯一性，Lua维护这一条链表，该链表中每个节点对应一个打开的upvalue（opend upvalue）结构，打开的upvalue是指当前正指向栈局部变量的upvalue，如上图的未决状态的局部变量链表（the pending vars list）。 当Lua创建一个新的闭包时，Lua会遍历当前函数所有的外部的局部变量，对于每一个外部的局部变量，若在上面的链表中能找到该变量，则重复使用该打开的upvalue，否则，Lua会创建一个新的打开的upvalue，并把它插入链表中。 当局部变量离开作用域时（即超过变量生命周期），这个打开的upvalue就会变成关闭的upvalue（closed upvalue），并把它从链表中删除，一旦某个关闭的upvalue不再被任何闭包所引用，那么它的存储空间就会被回收。 最后看下闭包的应用。 闭包最常用的一个应用就是实现迭代器。所谓迭代器就是一种可以遍历一种集合中所谓元素的机制。每个迭代器都需要在每次成功调用之间保持一些状态，这样才能知道它所在的位置及如何进到下一个位置。闭包刚好适合这种场景。比如下面的代码： function values(t) local i = 0 return function () i = i + 1 return t[i] end end t = {10, 20, 30} iter = values(t) while true do local element = iter() if element == nil then break end print(element) end 总结下lua闭包，关键点是upvalue，然后注意下如何申明一个背包，函数（A）里面返回的是函数（B），B引用了A的局部变量。]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>事件</tag>
        <tag>ocos2dx lua 闭包(匿名函数)入门实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2d-x lua —— 元表metatable]]></title>
    <url>%2F2018%2F09%2F22%2Fcocos2d-x-lua-%E2%80%94%E2%80%94-%E5%85%83%E8%A1%A8metatable%2F</url>
    <content type="text"><![CDATA[Lua表关于Lua表的介绍，这里有一段出自网络的介绍： Lua的表本质其实是个类似HashMap的东西，其元素是很多的Key-Value对.如果尝试访问了一个表中并不存在的元素时，就会触发Lua的一套查找机制，也是凭借这个机制，才能够实现“面向对象”的。 那么有时候我们可能会遇到这样的一段代码： myTable = {} print(myTable.A) --这里试图打印myTable并不存在的成员A 执行结果：nil 输出为nil的原因很简单，myTable中并没有A这个成员，这符合我们平时对HashMap的认知。但对于Lua表，如果myTable有元表，情况就不同了。 Lua元表 元表像是一个备用查找表，说白了假设表A的元表是B，那么如果在A中找不到的东西就会尝试在B中去找。 在Lua中，metatable是被译作元表，Lua 中的每个值都可以用一个 metatable。这个 metatable 就是一个原始的 Lua table ，它用来定义原始值在特定操作下的行为。 一个 metatable 可以控制一个对象做数学运算操作、比较操作、连接操作、取长度操作、取下标操作时的行为，metatable 中还可以定义一个函数，让 userdata 作垃圾收集时调用它。对于这些操作，Lua 都将其关联上一个被称作事件的指定健。 当 Lua 需要对一个值发起这些操作中的一个时，它会去检查值中 metatable 中是否有对应事件。如果有的话，键名对应的值（元方法）将控制 Lua 怎样做这个操作。 #####metatable通过其包含的函数来给所挂接的table定义一些特殊的操作，包括: __add: 定义所挂接table的加法操作 __mul: 定义乘法操作 __div: 定义除法操作 __sub: 定义减法操作 __unm: 定义负操作, 即: -table的含义 __tostring: 定义当table作为tostring()函式之参数被呼叫时的行为(例如: print(table)时将呼叫tostring(table)作为输出结果) __concat: 定义连接操作(“..”运算符) __index: 定义当table中不存在的key值被试图获取时的行为 __newindex: 定义在table中产生新key值时的行为 这里主要说一下_index__index：如果A的元表是B，那么如果访问了一个A中不存在的成员，就会访问查找B中有没有这个成员。 这个过程大体是这样，但却不完全是这样，实际上，即使将A的元表设置为B，而且B中也确实有这个成员，返回结果仍然会是nil 原因就是 B的index元方法没有赋值。按照我的理解，index方法是用来确定一个表在被作为元表时的查找方法 father = { house=1 } son = { car=1 } setmetatable(son, father) --把son的metatable设置为father print(son.house) 输出的结果是nil，但如果把代码改为 father = { house=1 } father.__index = father -- 把father的__index方法指向自己 son = { car=1 } setmetatable(son, father) print(son.house) 输出的结果为1，符合预期。 在上述例子中，访问son.house时，son中没有house这个成员，但Lua接着发现son有元表father，于是此时father被当做元表来查找. 此时，Lua并不是直接在father中找名为house的成员，而是调用father的index方法，如果index方法为nil，则返回nil，如果是一个表（上例中father的index方法等于自己，就是这种情况），那么就到index方法所指的这个表中查找名为house的成员，于是，最终找到了house成员。 注：index方法除了可以是一个表，还可以是一个函数，如果是一个函数，index方法被调用时将返回该函数的返回值。 相信到这里，应该已经很好理解了。 总结一句就是：index是:当我们访问一个表中的元素不存在时，则会触发去寻找index元方法，如果不存在，则返回nil，如果存在，则返回结果。补充 _newindex：当给你的表中不存在的值进行赋值时，lua解释器则会寻找__newindex元方法，发现存在该方法，则执行该方法进行赋值，注意，是使用rawset来进行赋值，至于原因，后面会讲到。 rawget是为了绕过index而出现的，直接点，就是让index方法的重写无效。 Lua查找一个表元素时的规则（出自网络） 1.在表中查找，如果找到，返回该元素，找不到则继续 2.判断该表是否有元表，如果没有元表，返回nil，有元表则继续 3.判断元表有没有index方法，如果index方法为nil，则返回nil；如果index方法是一个表，则重复1、2、3；如果index方法是一个函数，则返回该函数的返回值 参考链接：https://blog.csdn.net/wangbin_jxust/article/details/12108189]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2d-x lua —— 元表metatable</tag>
        <tag>cocos2dx</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx lua 语法糖之冒号(:)与点号(.)区别与使用]]></title>
    <url>%2F2018%2F09%2F16%2Fcocos2dx-lua-%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B9%8B%E5%86%92%E5%8F%B7-%E4%B8%8E%E7%82%B9%E5%8F%B7-%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[相信接触Lua或者做过cocos2dx lua的朋友，都遇到过这样的迷惑，关于Lua中冒号(:)与点号(.)语法糖，有时候会混乱，或者说一开始不太能适应和理解这里的区别和使用。 今天，就主要围绕着两个点，实际对比一下，并结合案例进行实战，并进行一些相关的拓展！ 先来看看下面这段代码： ObjectData = {} function ObjectData.count1( self ) print(&quot;ObjectData.count1&quot;, self) end function ObjectData:count2() print(&quot;ObjectData:count2&quot;, self) end a = ObjectData a.count1() -- nil a:count1() a.count1(a) a:count1(a) a.count2() -- nil a:count2() a.count2(a) a:count2(a) 我们通过打印，得到下面的结果，是不是有点蒙圈了！ -- ObjectData.count1 nil -- ObjectData.count1 table: 0x7c06d880 -- ObjectData.count1 table: 0x7c06d880 -- ObjectData.count1 table: 0x7c06d880 -- ObjectData:count2 nil -- ObjectData:count2 table: 0x7c06d880 -- ObjectData:count2 table: 0x7c06d880 -- ObjectData:count2 table: 0x7c06d880 有了上面的实例，我就可以通过简单的区分来实际应用和对比一下。 方法的点号定义和点号调用。money = {count = 888} function money.getCount(money ,somecount) money.count = money.count - somecount end money.getCount(money ,666) print(money.count) 冒号定义和冒号调用。money = {count = 888} function money:getCount(somecount) self.count = self.count - somecount end money:getCount(666) print(money.count) 以上的打印结果都是666。 可以看出，冒号定义和冒号调用其实跟上面的效果一样，只是把第一个隐藏参数省略了，而该参数self指向调用者自身当然了，我们也可以点号定义冒号调用，或者冒号定义点号调用 money = {count = 888} function money.getCount(self ,somecount) self.count = self.count - somecount end money:getCount(666) print(money.count) 冒号只是起了省略第一个参数self的作用，该self指向调用者本身，并没有其他特殊的地方。 也有网友提出：用lua进行面向对象的编程,声明方法和调用方法统一用冒号,对于属性的调用全部用点号 由此总结就是： 定义的时候冒号默认接收self参数 调用的时候冒号默认传递调用者自己为参数 而句号要显示传递或接收self参数 冒号会提供一个内置table供function之间通信。 一个点用来定义和取得一个变量，这个变量可能是个函数 两个点用来定义和调用一个函数，两个点会自动传入“调用者”这个table自身 如果是使用Cocos2d-x lua来开发的话，大部分情况下都是使用冒号的。 原因很简单，因为大部分情况下我们都要使用到self参数，就像C++的this关键字一样。 推荐： https://blog.csdn.net/stormbjm/article/details/38532413 https://www.cnblogs.com/youxilua/archive/2011/07/28/2119059.html]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>游戏</tag>
        <tag>cocos2dx lua 语法糖之冒号(:)与点号(.)区别与使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx lua 常见命令行(编译&调试&运行&打包)]]></title>
    <url>%2F2018%2F09%2F15%2Fcocos2dx-lua-%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E8%A1%8C-%E7%BC%96%E8%AF%91-%E8%B0%83%E8%AF%95-%E8%BF%90%E8%A1%8C-%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[cocos 命令 Cocos2d-x 带有一个命令行工具：cocos 这是一个跨平台的工具，你可以用它创建项目、运行项目、发布项目。 命令行工具适用于所有 Cocos2d-x 支持的平台，包括：iOS、Android、Mac、Linux、Windows、Web。不用 IDE，只用命令行，你就能完成所有的工作！ 本文选自cocos2dx官方文档，只做记录！ 项目创建使用 cocos new 命令创建新项目，命令格式如下： cocos new &lt;game name&gt; -p &lt;package identifier&gt; -l &lt;language&gt; -d &lt;location&gt; 示例： cocos new MyGame -p com.MyCompany.MyGame -l cpp -d ~/MyCompany cocos new MyGame -p com.MyCompany.MyGame -l lua -d ~/MyCompany cocos new MyGame -p com.MyCompany.MyGame -l js -d ~/MyCompany 使用命令 cocos new –help 可以查看到更多关于项目创建的帮助信息。 项目编译我们都知道，程序从源码到二进制程序，有一个编译环节。我们来看下 Cocos2d-x 是如何编译项目的，命令格式如下： cocos compile -s &lt;path to your project&gt; -p &lt;platform&gt; -m &lt;mode&gt; -o &lt;output directory&gt; 示例： cocos compile -s ~/MyCompany/MyGame -p ios -m release -o ~/MyCompany/MyGame/bin cocos compile -s ~/MyCompany/MyGame -p android -m release -o ~/MyCompany/MyGame/bin cocos compile -s c:\MyCompany\MyGame -p win32 -m release -o c:\MyCompany\MyGame\bin 这里的参数有点多，让我们来一个一个说，-p 是编译的平台，-m 是模式：debug 或者 release。如果没指定模式，默认 debug。此外 -s 和 -o 参数是可选的，如果操作命令的当前路径就是工程的路径，那这两个参数都可以省掉。比如已经在 ~/MyCompany/MyGame 目录，那编译命令可以简化为： cocos compile . -p ios -m release 你也可以增加一个可选的参数 -q，这样执行静默操作，控制台的输出信息会比较少。示例： cocos compile -q -s ~/MyCompany/MyGame -p ios -m release -o ~/MyCompany/MyGame/bin 由于命令行工具支持很多平台，因此还有一些特定平台的参数，使用它们可以进行更多的控制，比如指定 SDK 版本，确定签名信息，添加一些 Lua 相关或专用于 Web 的选项。 使用命令 cocos compile –help 可以查看更多关于项目编译的帮助信息。 Android 项目编译注意事项 命令行工具是很灵活的，对于编译 Android 项目允许开发者使用特定版本的 API。比如你的系统上安装了 Android-22，你想使用它来编译，就在命令行的最后增加参数 –ap android-api-version。示例： cocos compile -p android –ap android-22 你可以在项目的配置中，查看到目标 API 是什么版本。 项目运行创建完项目后，你可以直接从命令行执行运行命令。cocos 会启动你指定平台的程序。命令行格式如下： cocos run -s &lt;path to your project&gt; -p &lt;platform&gt; 示例: cocos run -s ~/MyCompany/MyGame -p ios cocos run -s ~/MyCompany/MyGame -p android cocos run -s c:\MyCompany\MyGame -p win32 当然，你也可以指定程序以 debug 还是 release 方式运行，默认的方式是 debug。示例： cocos run -s ~/MyCompany/MyGame -p ios -m release 就好像 cocos compile 命令那样，如果你已经在项目目录了，-s 和 -o 参数就不是必须的，这对 cocos run 命令也一样。就以上面的为例，如果已经在工程目录，命令可以简化成： cocos run . -p ios -m release 在运行 Web 程序时，还有可选的参数，允许你指定浏览器，例如指定 Google Chrome： cocos run -s ~/MyCompany/MyGame -p web -b /Applications/Google\ Chrome.app cocos run -s ~/MyCompany/MyGame -p web -b C:\Program Files\Google\Chrome\Application\chrome.exe cocos run -s ~/MyCompany/MyGame -p web -b /usr/local/bin/chrome 你还可以指定 IP 地址和端口，更多关于项目运行的使用帮助，请运行 cocos run –help 命令。 项目发布cocos 通过提供一系列项目发布的命令实现了简单的发布机制。这些命令，就像上面介绍的命令一样，通过一些参数指定需要的操作。命令格式如下： cocos deploy -s &lt;path to your project&gt; -p &lt;platform&gt; -m &lt;mode&gt; 示例： cocos deploy -s ~/MyCompany/MyGame -p ios -m release cocos deploy -s ~/MyCompany/MyGame -p android -m release cocos deploy -s c:\MyCompany\MyGame -p win32 -m release 你可以增加参数 -q，执行静默操作，这样控制台的输出信息会比较少。示例： cocos deploy -q -s ~/MyCompany/MyGame -p ios -m release 运行 cocos deploy –help，可以查看更多关于项目发布的帮助信息。]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>事件</tag>
        <tag>cocos2dx lua 常见命令行(编译&amp;调试&amp;运行&amp;打包)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx——项目启动流程与跨平台原理]]></title>
    <url>%2F2018%2F09%2F14%2Fcocos2dx%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[最近大部分空余时间都在开始学习cocos2d游戏开发相关技术，作为一个游戏行业菜鸟级别的选手，我觉得基础很重要，所以我决定从cocos2dx启动流程和快平台原理开始！ 注:这里只针对Lua做相关介绍，为什么是Lua，有过cocos2dx经验的朋友应该都知道Lua小，快，简单，而且比较大众化，而C++就不多多说了，大部分程序员都有畏惧心理，当然也有一些C++比较好，或者有独特爱好和专研朋友！ 关于其他平台基本上的流程和原理其实是一样的，可以直接参考！ 什么是Lua 百科: Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。 Lua由标准C编写而成，几乎在所有操作系统和平台上都可以编译，运行。Lua并没有提供强大的库，这是由它的定位决定的。所以Lua不适合作为开发独立应用程序的语言。 Lua 有一个同时进行的JIT项目，提供在特定平台上的即时编译功能。 很多应用程序、游戏使用LUA作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。这其中包括魔兽世界、博德之门、愤怒的小鸟、QQ三国、VOCALOID3、太阳神三国杀、游戏王ygocore等。 Cocos2d-lua，其实只是Cocos2d引擎添加了Lua绑定的版本。Cocos2d这里就不解释了，懒得拷贝，只是关于cocos创建和使用的时候需要注意的是 cocos new TestProj -d Desktop/ -l lua，这里的引擎其实是同一套，只是创建工程时提供了不同语言的桥接层 使用C++语言和Cocos2d-x引擎进行开发时，我们写的代码是直接调用引擎的API的，因为引擎也是用C++语言编写，不需要进行语言转换 使用Lua语言和Cocos2d-x引擎进行开发时，我们写的代码通过LuaEngine执行，而LuaEngine封装了Cocos2d-x引擎的API，所以就相当于使用Lua脚本在调用Cocos2d-x的API了 各个平台的入口iOS#import &lt;UIKit/UIKit.h&gt; int main(int argc, char *argv[]) { NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init]; int retVal = UIApplicationMain(argc, argv, nil, @&quot;AppController&quot;); [pool release]; return retVal; } Mac OS#import &lt;Cocoa/Cocoa.h&gt; int main(int argc, char *argv[]) { return NSApplicationMain(argc, (const char **)argv); } Linuxint main(int argc,char *argv) { AppDelegate app; return Application::getInstance()-&gt;run(); } Androidvoid cocos_android_app_init(JNIENV* env) { appDelegate.reset(new AppDelegate()); //新版本 : AppDelegate *pAppDelegate = new AppDelegate(); } Android启动流程概述 配置文件Manifest AppActivity onCreate super.onCreate onLoadNativeLibraries System.loadLibrary(libName); 触发cocos_android_app_init（在main.cpp）中 再由库执行调用对应的Lua代码 …… 由于笔者一直着力于iOS平台，所以这里以iOS为例，其他平台可参考：1. main函数入口iOSApp中打开程序，加载完动态库，和一些必备的初始化和准备(rebase, bind,SetUp)之后,会回到main函数开始执行真正的程序代码 int main(int argc, char *argv[]) { @autoreleasepool { return UIApplicationMain(argc, argv, nil, @&quot;AppController&quot;); } } Main函数里面会调用UIApplicationMain， UIApplicationMain会一路走完这些流程 + 根据principalClassName传递的类名创建UIApplication对象 + 创建UIApplication代理对象，给UIApplication对象设置代理 + 开启主运行时间循环，处理事件，保持程序一直运行 + 加载info.plist，判断下是否指定了main，如果指定了，就会去加载 我们可以看到这里设置的代理是AppController，然后看看AppController 2. 代理对象AppControllerAppController里面有个 didFinishLaunchingWithOptions，这个是程序加载完毕的监听方法 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { cocos2d::Application *app = cocos2d::Application::getInstance(); // Initialize the GLView attributes app-&gt;initGLContextAttrs(); cocos2d::GLViewImpl::convertAttrs(); // Override point for customization after application launch. // Add the view controller&apos;s view to the window and display. window = [[UIWindow alloc] initWithFrame: [[UIScreen mainScreen] bounds]]; // Use RootViewController to manage CCEAGLView _viewController = [[RootViewController alloc]init]; _viewController.wantsFullScreenLayout = YES; // Set RootViewController to window if ( [[UIDevice currentDevice].systemVersion floatValue] &lt; 6.0) { // warning: addSubView doesn&apos;t work on iOS6 [window addSubview: _viewController.view]; } else { // use this method on ios6 [window setRootViewController:_viewController]; } [window makeKeyAndVisible]; [[UIApplication sharedApplication] setStatusBarHidden:true]; // IMPORTANT: Setting the GLView should be done after creating the RootViewController cocos2d::GLView *glview = cocos2d::GLViewImpl::createWithEAGLView((__bridge void *)_viewController.view); cocos2d::Director::getInstance()-&gt;setOpenGLView(glview); //run the cocos2d-x game scene app-&gt;run(); return YES; } 前面分别：获取Director，GLView设置GLView，最后执行run 3. run cocos2d delegate我们看看run方法里面，这里的run方法很关键， int Application::run() { if (applicationDidFinishLaunching()) { [[CCDirectorCaller sharedDirectorCaller] startMainLoop]; } return 0; } 有个applicationDidFinishLaunching，其实这里cocos2d默认的代理，在class中 4. cocos2d配置，lua加载这里在coco2d的代理中，可以看到一堆的初始化配置和加载，然后就开始获取并执行脚本lua(通过lua脚本显示并处理Scene逻辑) bool AppDelegate::applicationDidFinishLaunching() { // set default FPS Director::getInstance()-&gt;setAnimationInterval(1.0 / 60.0f); // register lua module auto engine = LuaEngine::getInstance(); ScriptEngineManager::getInstance()-&gt;setScriptEngine(engine); lua_State* L = engine-&gt;getLuaStack()-&gt;getLuaState(); lua_module_register(L); register_all_packages(); LuaStack* stack = engine-&gt;getLuaStack(); stack-&gt;setXXTEAKeyAndSign(&quot;2dxLua&quot;, strlen(&quot;2dxLua&quot;), &quot;XXTEA&quot;, strlen(&quot;XXTEA&quot;)); //register custom function //LuaStack* stack = engine-&gt;getLuaStack(); //register_custom_function(stack-&gt;getLuaState()); #if CC_64BITS FileUtils::getInstance()-&gt;addSearchPath(&quot;src/64bit&quot;); #endif FileUtils::getInstance()-&gt;addSearchPath(&quot;src&quot;); FileUtils::getInstance()-&gt;addSearchPath(&quot;res&quot;); if (engine-&gt;executeScriptFile(&quot;main.lua&quot;)) { return false; } return true; } 原生集成补充如果你是直接在原生嵌入而不是夸平台会看到这里其实是创建并返回Scene bool AppDelegate::applicationDidFinishLaunching() { // initialize director auto director = Director::getInstance(); auto glview = director-&gt;getOpenGLView(); if(!glview) { glview = GLViewImpl::create(&quot;Fiction_Single&quot;); director-&gt;setOpenGLView(glview); } // turn on display FPS // director-&gt;setDisplayStats(true); // set FPS. the default value is 1.0/60 if you don&apos;t call this director-&gt;setAnimationInterval(1.0f / 60); register_all_packages(); //SpriteFrameCache::getInstance()-&gt;removeSpriteFrames(); //SpriteFrameCache::getInstance()-&gt;removeUnusedSpriteFrames(); // create a scene. it&apos;s an autorelease object // 初始化与运行主场景 auto scene = GameMainLayer::MainScene(); // 初始化与运行主场景 director-&gt;runWithScene(scene); return true; } 游戏逻辑就可以从这个Scene中的init函数开始，添加UI层，添加事件监听器，添加游戏层等等…如果我们有一些统计、资源管理器等，也可以在AppDelegate的applicationDidFinishLaunching函数中来进行。 5. Lua脚本初始化在这之前，我们先先看看，项目的配置文件config.json { &quot;init_cfg&quot;:{ &quot;isLandscape&quot;: true, &quot;isWindowTop&quot;: false, &quot;name&quot;: &quot;MyDemo&quot;, &quot;width&quot;: 960, &quot;height&quot;: 640, &quot;entry&quot;: &quot;src/main.lua&quot;, &quot;consolePort&quot;: 6050, &quot;uploadPort&quot;: 6060 }, &quot;simulator_screen_size&quot;: [ { &quot;title&quot;: &quot;iPhone 3Gs (480x320)&quot;, &quot;width&quot;: 480, &quot;height&quot;: 320 }, ...... ] } 可以看到”entry”: “src/main.lua”,也就是说入口文件是main.lua，由此可以得知，即使我们不从iOS的启动流程来看，整个启动也会从这里开始，进入。 再来看”main.lua”，这个时候我们就开始开发查看main.lua文件从MyApp开始，初始化，然后执行run运行程序 cc.FileUtils:getInstance():setPopupNotify(false) require &quot;config&quot; require &quot;cocos.init&quot; local function main() require(&quot;app.MyApp&quot;):create():run() end local status, msg = xpcall(main, __G__TRACKBACK__) if not status then print(msg) end 这里很重要的一个方法是run(),run()方法是设置启动View，执行main函数，main函数里加载MyApp创建并运行，进而打开MyApp.lua： 6. MyApp.lua我们看到MyApp仅仅是继承自AppBase，onCreate函数只是初始化了下随机数种子，也就意味着更多的操作在AppBase中，我们打开分析： local AppBase = class(&quot;AppBase&quot;) function AppBase:ctor(configs) self.configs_ = { viewsRoot = &quot;app.views&quot;, modelsRoot = &quot;app.models&quot;, defaultSceneName = &quot;TitleScene&quot;, } for k, v in pairs(configs or {}) do self.configs_[k] = v end if type(self.configs_.viewsRoot) ~= &quot;table&quot; then self.configs_.viewsRoot = {self.configs_.viewsRoot} end if type(self.configs_.modelsRoot) ~= &quot;table&quot; then self.configs_.modelsRoot = {self.configs_.modelsRoot} end if DEBUG &gt; 1 then dump(self.configs_, &quot;AppBase configs&quot;) end if CC_SHOW_FPS then cc.Director:getInstance():setDisplayStats(true) end -- event self:onCreate() end function AppBase:run(initSceneName) initSceneName = initSceneName or self.configs_.defaultSceneName self:enterScene(initSceneName) end function AppBase:enterScene(sceneName, transition, time, more) local view = self:createView(sceneName) view:showWithScene(transition, time, more) return view end function AppBase:createView(name) for _, root in ipairs(self.configs_.viewsRoot) do local packageName = string.format(&quot;%s.%s&quot;, root, name) local status, view = xpcall(function() return require(packageName) end, function(msg) if not string.find(msg, string.format(&quot;&apos;%s&apos; not found:&quot;, packageName)) then print(&quot;load view error: &quot;, msg) end end) local t = type(view) if status and (t == &quot;table&quot; or t == &quot;userdata&quot;) then return view:create(self, name) end end error(string.format(&quot;AppBase:createView() - not found view \&quot;%s\&quot; in search paths \&quot;%s\&quot;&quot;, name, table.concat(self.configs_.viewsRoot, &quot;,&quot;)), 0) end function AppBase:onCreate() end return AppBase 在前面的分析中知道main.lua是执行的是App的run函数，作为基类的AppBase，当然也要被调用run函数，因此直接看run函数：主要是创建并进入场景initSceneName，如果run的参数没有指定开始的场景则使用默认场景defaultSceneName，默认场景在构造函数的时候被初始化为MainScene，也就是说场景默认将从MainScene开始。 7. 指定Scene如果想指定启动，而不是使用默认的Scene，那么项目启动后会直接进入该场景，这点有个好处是如果要调试设计某场景可以直接从这个场景进入，不必从其他场景进入了。 local function main() require(&quot;app.MyApp&quot;):create():run(&quot;StartScene&quot;) end 默认不设置会选择MainScene，如果仔细再AppBase里面会看到这样一行代码 function AppBase:ctor(configs) self.configs_ = { viewsRoot = &quot;app.views&quot;, modelsRoot = &quot;app.models&quot;, defaultSceneName = &quot;MainScene&quot;, } ..... 那么项目启动后会直接进入StartScene场景，而不再是默认的MainScene场景。 8. 根据脚本指定Scene，上面说了，如果没有设置就会试着用默认的Scene，run里面的逻辑就是去真正指定Scene， -- 创建完对象之后，就到了这一步 function AppBase:run(initSceneName) initSceneName = initSceneName or self.configs_.defaultSceneName self:enterScene(initSceneName) -- 如果没有指定第一个Scene，则第一个Scene为MainScene end -- 生成并进入第一个Scene function AppBase:enterScene(sceneName, transition, time, more) local view = self:createView(sceneName) -- 前去生成View view:showWithScene(transition, time, more) -- 因为MainScene继承自ViewBase类，这里就吊用ViewBase的方法了 return view end 建议仔细读一下AppBase，ViewBase！ 9. 自定义Scene(StartScene)这个时候就会首先从StartScene开始， local StartScene = class(&quot;StartScene&quot;, cc.load(&quot;mvc&quot;).ViewBase) function StartScene:onCreate() display.newSprite(&quot;HelloWorld.png&quot;) :move(display.center) :addTo(self) cc.Label:createWithSystemFont(&quot;cocos2dx Run StartScene&quot;, &quot;Arial&quot;, 60) :move(display.cx, display.cy + 200) :addTo(self) end return StartScene 然后后面步骤就是从StartScene开始，写脚本代码，处理UI，网络和逻辑等，到这里就基本上完成cocos2dx Lua启动流程，其他C++,JS原理和流程其实都差不多, 只是执行的方法或者代码不一样而已 总结其实关于coocs2dx之前的版本我不了解，就我目前了解到的，其实就是由通用程序入口到跨平台程序入口 基本的流程如下 初始化Director 新建GLView，然后进行一些设置 新建Scene 使用Director运行这个场景 bool AppDelegate::applicationDidFinishLaunching()//程序入口 -&gt; 跨平台程序入口 { auto director = Director::getInstance(); auto glview = director-&gt;getOpenGLView(); if(!glview) { glview = GLViewImpl::create(&quot;my test&quot;); director-&gt;setOpenGLView(glview); } //初始化、资源适配、屏幕适配、运行第一个场景... glview-&gt;setDesignResolutionSize(); auto scene = Hellow::scene(); director-&gt;runWithScene(scene); return scene; } 通过上面我们其实可以知道，cocos2d_lua_bindings库提供了Lua对Cocos2d引擎的绑定，相当于通过注册Module的方式对Cocos2d引擎提供的（相关的）API进行了一次封装（把常用的功能封装成一个函数newScene）。 相对于Cocos2d-x C++工程来说，Cocos2d-x生成的Lua语言工程提供了对Cocos2d引擎的Lua语言封装。将Cocos2d引擎API绑定到对应的Lua语言函数，在调用到这些函数时，会执行对应的Cocos2d引擎API, 其实最终还是调用的C++代码和对应的引擎代码。 跨平台原理 AppDelegate 作为跨平台程序入口，在这之上做了另一层的封装，封装了不同平台的不同实现。比如我们通常认为一个程序是由 main 函数开始运行，那我们就去找寻，我们看到了在 proj.linux 目录下存在 main.cpp 文件。 在main.cpp 中 CCApplication::sharedApplication()–&gt;run(); 这一句看起，这一句标志着， cocos2d-x 程序正式开始运行. 定位到 sharedApplication() 方法的实现，在CCAplication类中我们可以看到从 sharedApplication() 方法，在调用 run() 方法，在这之前，我们需要调用到它的构造函数，否则不能运行，这就是为什么在 CCApplication::sharedApplication()–&gt;run(); 之前，我们首先有语句 AppDelegate app; 创建 AppDelegate 变量的原因是 AppDelegate 是 CCApplication 的子类，在创建子类对象的时候，调用其构造函数的同时，父类构造函数也会执行，然后就将 AppDelegate 的对象赋给了 CCApplication 的静态变量，而在 AppDelegate 之中我们实现了 applicationDidFinishLaunching方法，所以在 CCApplication 中 run 方法的开始处调用的就是 AppDelegate 之中的实现。 我们在此方法中我们初始化了一些变量，创建了第一个 CCScene 场景等，之后的控制权，便全权交给了CCDirector::sharedDirector()–&gt;mainLoop(); 方法了。 在cocos2d-x的文件夹下，有一个platform文件夹，里面存放了跨平台的封装接口。 当前目录下有CCApplicationProtocol.h头文件，子目录有win32,Android,IOS三个文件夹，里面分别存放跨平台需要的函数，其中包括CCApplication。 而AppDelegate 类则是继承自CCApplication。CCApplication又继承自CCApplicationProtocol。 在CCApplicationProtocol中定义了applicationDidFinishLaunching虚方法,由CCApplication 继承， AppDelegate 实现的。以此实现了跨平台。 为了充分发挥硬件性能，手机游戏通常使用Native App开发模式，这就造成开发商要为iOS 和Android平台用户开发不同的应用，无论是产品迭代还是运行维护都非常麻烦。 Cocos2d-x在iOS，Android等移动平台之上，封装了一层C++接口，从而屏蔽了平台的差异性，通过平台宏来控制使用哪个平台的代码，向开发者提供C++接口调用。这些接口主要包括UI、事件和网络，封装UI主要是使用OpenGL ES的接口来写UI，封装事件和网络，均是使用C++接口对原生接口进行一层封装。 其实对应cocos2dx跨平台在说，我们这么理解就可以了 Lua底层是通过C编写实现的 Android通过JNI技术调用C iOS也是完全兼容C语言 我们打开对应的工程可以看到 Java项目中，有些关于Lua的文件， luajava.jar是Java代码封装包， libluajava-1.1.so在底层封装了.C 文件，实现了lua相关底层功能。 但是在iOS项目中，我们发现 iOS允许开发者使用C语言文件和objective-c文件混合编程。但是，如果你在Objective-C的代码中调用C文件中的函数，你不能直接将.c文件import到你的OC文件中，这样是不起作用的。你需要先创建一个.h 头文件 里面包含你的函数申明，同时将这个.h 头文件import到.c文件中，.c文件负责实现要调用的函数。最后将你新创建的.h头文件import到OC文件中，这样你就可以在OC的文件中调用C的方法了 具体更多启动相关细节，可以参考这里 https://www.jianshu.com/p/781d835c88c9 http://www.cocos2d-x.org/docs/cocos2d-x/zh/about/learn.html]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>游戏</tag>
        <tag>cocos2dx——项目启动流程与跨平台原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS(OC+cocos2dx)游戏APP磁盘空间爆增(文稿与数据)]]></title>
    <url>%2F2018%2F08%2F16%2FiOS-OC-cocos2dx-%E6%B8%B8%E6%88%8FAPP%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E7%88%86%E5%A2%9E-%E6%96%87%E7%A8%BF%E4%B8%8E%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[这段时间在开发公司的新产品二次元游戏(零下记忆)，由于接触coco2dx不久，很多东西还在摸索，也没少加班，所以都没有时间整理和发文了。 但是最近(从周一开始),发现了一个特别其他的Bug，App磁盘数据报增，幸好我手机是64G的，不然估计会爆炸！ 先来张爆图！ 这个产品是在Objective-C原生架构的基础上接入cocos2dx(C++)，所以导致部分文件或者类需要使用MRC模式。 我曾尝试过 使用模拟器针对不同时段操作，计算沙盒文件大小。 借助部门同事的越狱机导包寻找导致爆增的具体文件。 多次删除App，关闭可能存在问题原因的代码。 借助内存泄漏框架自动记录，内存变化与位置。 借助Xcode自带Instrument定点查找具体位置和代码。 通过Stack Overflow查询更多可能导致的原因。 经过一次次排查，和一个个问题的处理，最终通过多次杀进程，和运行测试，终于处理完成，不过还有待优化！ 下面是具体原因和流程。清理缓存：清理cocos2dx缓存：123456789CCAnimationCache::purgeSharedAnimationCache();CCSpriteFrameCache::purgeSharedSpriteFrameCache();CCTextureCache::purgeSharedTextureCache(); CCSpriteFrameCache::sharedSpriteFrameCache()-&gt;removeUnusedSpriteFrames();CCTextureCache::sharedTextureCache()-&gt;removeUnusedTextures();CCTextureCache::sharedTextureCache()-&gt;removeAllTextures();Director::getInstance()-&gt;getTextureCache()-&gt;removeAllTextures(); 清理运行磁盘，内存或者缓存123456789101112131415161718192021222324252627282930313233343536+ (void)clearAllCache &#123; [[SDImageCache sharedImageCache] clearMemory]; [[SDImageCache sharedImageCache] clearDiskOnCompletion:nil]; // 拿到cachePath路径的下一级目录的子文件夹 // contentsOfDirectoryAtPath:error:递归 // subpathsAtPath:不递归 NSArray *subpathArray = [fileManager contentsOfDirectoryAtPath:cachePath error:nil]; // 如果数组为空，说明没有缓存或者用户已经清理过，此时直接return if (subpathArray.count == 0) &#123;#ifdef DEBUG NSLog(@"cachePath缓存清理完成");#else #endif &#125; NSError *error = nil; NSString *filePath = nil; BOOL flag = NO; for (NSString *subpath in subpathArray) &#123; filePath = [cachePath stringByAppendingPathComponent:subpath]; if ([fileManager fileExistsAtPath:cachePath]) &#123; // 删除子文件夹 BOOL isRemoveSuccessed = [fileManager removeItemAtPath:filePath error:&amp;error]; if (isRemoveSuccessed) &#123; // 删除成功 flag = YES; &#125; &#125; &#125; if (NO == flag) &#123;#ifdef DEBUG NSLog(@"已经清理了所有可以访问的文件,不可访问的文件无法删除"); // 调试阶段才打印#else #endif &#125;&#125; 记忆中此处大概处理了1-3G 内存管理通过Stack Overflow和相应代码调试最后发现： 原来是把sprite和控件都retain了，需要手动release，才能释放图片。 所以我得找到对应的cocos2dx项目代码，对创建和操作的对象进行release操作，这里比较蛋疼，得一个个找！ 处理中遇到个问题： removeTexture执行release后，不管有没有被gl释放掉，都从列表里删除。 但是如果load进来的node被addChild到场景中，应该是不需要retain的，addChild会自动retain，这里不清楚，cocos2dx引擎设计者在load里加retain是为了什么， 这里所导致的问题，几乎是使用过程中内存暴涨 环境与配置(主要原因):通过多次测试发现沙盒文件中的temp中有一堆文件stack-logs.xxxxx.index 同时控制台也打印了一大堆看不懂也搜不到的内容 结合以上几点才初步猜测可能是因为配置环境的问题，查阅资料后发现这与Xcode设置有关,具体配置原因我也不记得了，印象中是当时配置接入cocos2dx的时候，遇到了一些问题，点过了一次，但是现在想想好像当时的操作并没有什么卵用！ Edit Scheme中Diagnostics有个logging分类，下面有个Malloc Stack选项，将勾选取消。 处理完后立刻验证了一下,重装App,多次执行杀进程和实际测试用，在tmp下并没有产生那个文件stack-logs.xxxxx.index,磁盘占用也处于稳定状态,再打开手机设置查看存储空间，也很正常。 以上文稿与数据的15.7中有13M多属于App下载的资源文件。 That’s all for today.]]></content>
      <categories>
        <category>iOS游戏</category>
      </categories>
      <tags>
        <tag>iOS(OC+cocos2dx)游戏APP磁盘空间爆增(文稿与数据)</tag>
        <tag>iOS游戏</tag>
        <tag>磁盘管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏引擎——cocos2dx入门]]></title>
    <url>%2F2018%2F08%2F09%2F%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94cocos2dx%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[简介Cocos2d-x是一个开源的移动2D游戏框架，MIT许可证下发布的。这是一个C++ Cocos2d-iPhone项目的版本。Cocos2d-X发展的重点是围绕Cocos2d跨平台，Cocos2d-x提供的框架。 手机游戏，可以写在C++或者Lua中，使用API是Cocos2d-iPhone完全兼容。Cocos2d-x项目可以很容易地建立和运行在iOS，Android，黑莓Blackberry等操作系统中。 Cocos2d-x还支持Windows、Mac和Linux等桌面操作系统，因此，开发者编写的源代码很容易在桌面操作系统中编辑和调试。 cocos2dx 与 UNITY3D 一、区别: 1、COCOS2D开源,有文档支持,论坛资料庞杂博大；UNITY3D闭源,有强大的文档支持,论坛资料一样的庞杂博大。 2、COCOS2D免费；UNITY3D收费。 3、COCOS2D的跨平台,需要大量重写代码；UNITY3D的跨平台,程序员只需要选选按钮就淡定许多的搞定了。 二、拓展: 1、不同: COCOS2D拥有令人发指的可定制性；UNITY3D有一个专门为订制而写的类库。 2、相同: UNITY3D和 COCOS2D-X都是跨平台的游戏开发引擎。 特性 现代化的 C++ API 立足于 C++ 同时支持 JavaScript/Lua 作为开发语言 可以跨平台部署, 支持 iOS、Android、Windows、macOS 和 Linux 可以在 PC 端完成游戏的测试，最终发布到移动端 完善的游戏功能支持，包含精灵、动作、动画、粒子特效、场景转换、事件、文件 IO、数据持久化、骨骼动画、3D 家族成员 cocos2d是一个基于MIT协议的开源框架，用于构建游戏、应用程序和其他图形界面交互应用。可以让你在创建自己的多平台游戏时节省很多的时间。 Cocos2d-html5 ： Cocos2d-HTML5 是基于 HTML5 规范集的 Cocos2d引擎分支，具有跨平台的能力和强大的性能，是 Cocos2d 系列引擎随着互联网技术演进而产生的一个分支，该分支基于 HTML5 规范集，目标是可对游戏进行跨平台部署，Cocos2d-HTML5 采用 MIT 开源协议，设计上保持Cocos2d家族的传统架构，并可联合 Cocos2d-x JavaScript-binding 接口，最大程度地实现游戏代码在不同平台上的复用。 JSB ： Cocos2d-x JavaScript-binding 是使用 SpiderMonkey 引擎实现 C++ 接口到 JavaSciprt 的绑定方案，它可以使用 Js 快速开发游戏，以更简单的语法实现功能，并且能与 Cocos2D-HTML5 相互兼容，使同一套代码，运行两个平台，这是相比使用 Lua 实现的一个明显优势。 Cocos Studio ： Cocos Studio 是一套基于 Cocos2d-x 引擎的工具集，包括 UI编辑器，动画编辑器，场景编辑器和数据编辑器。 UI 编辑器和动画编辑器主要面向美术，而场景编辑器和数据编辑器则面向游戏策划，这四个工具合在一起构成了一套完整的游戏开发体系，帮助开发者进一步降低开发难度，提高开发效率，减少开发成本。 Cocos2d也拥有几个主要版本，包括Cocos2d-iPhone、Cocos2d-X，以及被社区普遍看好的Cocos2d-HTML5和JavaScript bindings for Cocos2d-X。 关于lua，c++，JS允许开发人员使用 C++、Javascript 及 Lua 三种语言来进行游戏开发。 支持所有常见平台，包括 iOS、Android、Windows、macOS、Linux。 运行效率： Lua 的性能在各种测试里都比 JavaScript 快不少。而移动设备上存在不支持 JIT 的情况（未越狱的 iOS 设备），Lua 对比 JavaScript 的性能优势就更明显。 安全性： 现在 cocos2d-x 使用 LuaJIT 来执行 Lua，所以可以把 Lua 代码编译为字节码再打包到游戏里。由于 LuaJIT 的字节码是高度优化过的，所以目前还没有反编译工具。而 JS 虽然也可以用字节码，但从目前的情况看还达不到 LuaJIT 的安全性。 与 C/C++ 的交互： Lua 原本就是作为嵌入式语言来设计的，所以天然和 C/C++ 很容易交互。JS 这方面是个劣势。 与 Java/Objective-C 的交互： 不管是 quick-cocos2d-x 里提供的 luaoc/luaj 模块，还是 wax, luajava 这些开源项目，都让我们可以绕过 C/C++ 层实现 Lua 和 Java/Objc 的交互。这个优势在游戏发行阶段，集成各种第三方 SDK 时绝对会节约巨量时间！！！ 游戏是非常消耗资源的每时每刻都要大量的计算， 假如有个方法 让 C语言来实现 并且把它完成的时间定义为 1个单位 的时间 那么同样的数据结构的方法在其他语言中 java 需要 8个单位 lua需要30个单位 python需要200个单位 php需要462个单位 javascript需要621个单位 所以在需要大量计算的环节，代码的结构时间复杂度比较高的 情况下用 C++（肯没直接用C快，但一定比java快）来写， 现在的CPU计算能力都还是蛮高的，所以没必要完全用C++ ，用一些其他的语言开发速度可以大大加快。 个人总结 项目不需要热更新的时候用c++ lua，c++都可以用的时候c++更熟悉的用c++ c++效率比lua高 lua项目的底层框架还是要c++搭比较好 c++老司机转其他语言比较轻松。 最终使用那种方式还是需要结合个人，语言，需求，性能综合考虑 当然，cocos2d-x 目前明显是在主推 JS 的解决方案，因为 JS 可以跨越移动设备、桌面的界限，实现一套程序跑任意平台。不过我个人认为以当前 HTML5 的发展情况，对于要强调体验的游戏来说，HTML5 还要一些时间。 网友评价：前面提到 JS 更容易面向对象，我想可能是因为大家对 Lua 还不够了解造成的错觉。实际上，Lua 和 JS 实现面向对象的机制几乎是一样的。JS 基于 prototype，Lua 基于 metatable，在我看来仅仅是名字不同而已。 从目前的市场情况来说，Lua 明显是更理性的选择：成熟、安全性高、众多大作采用。 推荐 官方文档：http://www.cocos2d-x.org/docs/cocos2d-x/zh/about/learn.html OC/Swift - C++交互与混编:http://edu.51cto.com/center/course/lesson/index?id=57316 入门实战-飞机大战游戏：http://www.maiziedu.com/course/662-9914/]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>游戏</tag>
        <tag>游戏引擎——cocos2dx入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP高级——MySQL性优化实战总结一]]></title>
    <url>%2F2018%2F08%2F04%2FPHP%E9%AB%98%E7%BA%A7%E2%80%94%E2%80%94MySQL%E6%80%A7%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[MySQL对于很多Linux从业者而言，是一个非常棘手的问题，多数情况都是因为对数据库出现问题的情况和处理思路不清晰。在进行MySQL的优化之前必须要了解的就是MySQL的查询过程，很多的查询优化工作实际上就是遵循一些原则让MySQL的优化器能够按照预想的合理方式运行而已。 今天我们特别邀请了资深的Linux运维老司机惨绿少年Linux来给大家体验MySQL的优化实战，助你高薪之路顺畅。 源自慕课网视频教程整理：https://www.imooc.com/learn/194 性能优化范围 存储、主机和操作系统方面: 主机架构稳定性 I/O规划及配置 Swap交换分区 OS内核参数和网络问题 应用程序方面: 应用程序稳定性 SQL语句性能 串行访问资源 性能欠佳会话管理 这个应用适不适合用MySQL 数据库优化方面: 内存 数据库结构(物理&amp;逻辑) 实例配置 说明：不管是在，设计系统，定位问题还是优化，都可以按照这个顺序执行。 MySQL优化简介一、为什么需要优化mysql数据库 1、避免出现页面访问错误 由于数据库连接超时产生的5xx错误 由于慢查询造成页面无法加载 由于阻塞造成数据无法提交 2、增加数据库的稳定性 很多数据库问题是由于低效的查询引起的 数据库优化维度有四个: 硬件、系统配置、数据库表结构、SQL及索引 优化选择 优化成本:硬件&gt;系统配置&gt;数据库表结构&gt;SQL及索引 优化效果:硬件&lt;系统配置&lt;数据库表结构&lt;SQL及索引 SQL语句优化数据准备演示数据库准备 https://dev.mysql.com/doc/index-other.html sakila数据库的表结构信息可以通过以下网站查看 https://dev.mysql.com/doc/sakila/en/sakila-installation.html sakila-db示例数据库的安装导入MySQL慢查日志的开启方式和存储格式如何发现有问题的 SQL？答案是使用 MySQL 慢查询日志对有效率问题的 SQL 进行监控，执行命令如下： # 查看慢查询日志的设置 show variables like &quot;%log%&quot; # 查看是否开启慢查询日志 show variables like &quot;slow_query_log&quot;; # 查看是否设置了没有索引的记录到慢查询日志 show variables like &quot;log_queries_not_using_indexes&quot;; # 查看是否设置慢查询的 SQL 执行时间 show variables like &quot;long_query_time&quot;; # 查看慢查询日志记录位置 show variables like &quot;slow_query_log_file&quot;; # 开启慢查询日志 set global slow_query_log=on # 设置没有索引的记录到慢查询日志 set global log_queries_not_using_indexes=on # 设置到慢查询日志的 SQL 执行时间 (s) set global long_query_time=0.01 # 查看慢查询日志（在 Linux 终端下执行） tail -50 /usr/local/mysql/data/stsdeMacBook-Pro-slow.log; 慢查询日志所包含的内容 SQL 的执行时间：# Time: 2016-10-13T10:01:45.914267Z SQL 的执行主机：# User@Host: root[root] @ localhost [] Id: 949 SQL 的执行信息：# Query_time: 0.000227 Lock_time: 0.000099 Rows_sent: 2 Rows_examined: 2 SQL 的执行时间：SET timestamp=1476352905; SQL 的执行内容：select from store;* MySQL慢查日志分析工具之mysqldumpslow慢查询日志分析工具 mysqldumpslow安装：MySQL 数据库自带使用：mysqldumpslow /usr/local/var/mysql/luyiyuandeMacBook-Pro-slow.log; MySQL慢查日志分析工具之pt-query-digest pt-query-digest安装：brew install brew install percona-toolkit使用：pt-query-digest /usr/local/var/mysql/luyiyuandeMacBook-Pro-slow.log | more; 如何通过慢查日志发现有问题的SQL 查询次数多且每次查询占用时间长的 SQL IO 大的 SQL 未命中索引的 SQL 通过explain查询和分析SQL的执行计划使用 EXPLAIN 分析 SQL 的执行计划的例子如下： EXPLAIN SELECT * FROM staff; 使用 EXPLAIN 分析 SQL 的各列参数含义如下： id：SQL 语句执行顺序编号 select_type：SQL 语句执行的类型，主要区别普通查询、联合查询和子查询之类的复杂查询 table：SQL 语句执行所引用的数据表 type：显示连接使用的类型,从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL possible_keys：指出 MySQL 能在该数据表中使用哪些索引有助于查询 key：SQL 语句执行时所使用的索引 key_len：SQL 语句执行时所使用的索引的长度。在不损失精确性的情况下，长度越短越好 ref：显示索引的哪一列被使用了，如果可以的话，是一个常数 rows：表扫面的行数 Extra：提供 MySQL 优化器一系列额外信息，Using filesort：看到这个的时候，查询需要优化，mysql需要进行额外的步骤来发现如何对返回的行排序，它根据连接类型以及存储排序键值和匹配条件的全部行的行指针排序全部行Using temporary：看到这个的时候，查询需要优化，这里，mysql需要创建一个临时表来存储结果，这通常发生在对不同的列集进行order by上，而不是group by上 MAX() 和 COUNT() 的优化 MAX()分析 SQL 语句：使用 MAX() 方法查询最后一笔交易的时间 EXPLAIN SELECT MAX(payment_date) FROM payment_date 执行计划如下： *************************** 1. row *************************** id: 1 select_type: SIMPLE table: payment partitions: NULL type: ALL possible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 16086 filtered: 100.00 Extra: NULL 1 row in set, 1 warning (0.00 sec) 如果数据表的数据非常大，查询频率又非常高，那么服务器的 IO 消耗也会非常高，所以这条 SQL 语句需要优化。可以通过建立索引进行优化。执行代码如下： CREATE INDEX idx_paydate ON payment(payment_date); 然后再分析 SQL 语句，执行计划如下： *************************** 1. row *************************** id: 1 select_type: SIMPLE table: NULL partitions: NULL type: NULL possible_keys: NULL key: NULL key_len: NULL ref: NULL rows: NULL filtered: NULL Extra: Select tables optimized away 1 row in set, 1 warning (0.01 sec) 经过优化之后，由于索引是按顺序排列的，MySQL 不需要查询表中的数据，而是通过查询索引最后的一个数据，就可以得知执行结果了。而且这个时候，不管表的数据量多大，查询 MAX() 所需要的时间都是基本固定的，这样就尽可能地减少了 IO 操作。 COUNT()分析 SQL 语句：使用 COUNT() 函数在一条 SQL 中同时查出 2006 年和 2007 年电影的数量 SELECT count(release_year = &apos;2006&apos; OR NULL) AS &apos;2006 年电影数量&apos; , count(release_year = &apos;2007&apos; OR NULL) AS &apos;2007 年电影数量&apos; FROM film; count(*) 包含空值，count(id) 不包含空值。上述语句就是优化 Count() 函数取值 子查询的优化分析 SQL 语句：查询 sandra 出演的所有影片 SELECT title , release_year , LENGTH FROM film WHERE film_id IN( SELECT film_id FROM film_actor WHERE actor_id IN( SELECT actor_id FROM actor WHERE first_name = &apos;sandra&apos; ) ) 通常情况下，需要把子查询优化为 join 查询，但在优化时要注意关联键是否有一对多的关系，要注意重复数据。 group by的优化group by 可能会出现临时表、文件排序等，影响效率。可以通过关联的子查询，来避免产生临时表和文件排序，可以节省 IO。group by 查询优化前： EXPLAIN SELECT actor.first_name, actor.last_name, Count(*) FROM sakila.film_actor INNER JOIN sakila.actor USING (actor_id) GROUP BY film_actor.actor_id; 执行结果如下： *************************** 1. row *************************** id: 1 select_type: SIMPLE table: actor partitions: NULL type: ALL possible_keys: PRIMARY key: NULL key_len: NULL ref: NULL rows: 200 filtered: 100.00 Extra: Using temporary; Using filesort *************************** 2. row *************************** id: 1 select_type: SIMPLE table: film_actor partitions: NULL type: ref possible_keys: PRIMARY,idx_fk_film_id key: PRIMARY key_len: 2 ref: sakila.actor.actor_id rows: 27 filtered: 100.00 Extra: Using index 2 rows in set, 1 warning (0.01 sec) group by 查询优化后： EXPLAIN SELECT actor.first_name, actor.last_name, c.cnt FROM sakila.actor INNER JOIN ( SELECT actor_id, count(*) AS cnt FROM sakila.film_actor GROUP BY actor_id ) AS c USING (actor_id); Limit查询的优化LIMIT 常用于分页处理，时常会伴随 ORDER BY 从句使用，因此大多时候会使用 Filesorts ，这样会造成大量的 IO 问题 优化前： EXPLAIN SELECT film_id, description FROM sakila.film ORDER BY title LIMIT 50, 5 执行计划： *************************** 1. row *************************** id: 1 select_type: SIMPLE table: film type: ALL possible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 1000 Extra: Using filesort 1 row in set (0.00 sec) 优化步骤1：使用有索引的列或主键进行 Order By 操作 EXPLAIN SELECT film_id, description FROM sakila.film ORDER BY film_id LIMIT 50, 5 \G 执行计划： *************************** 1. row *************************** id: 1 select_type: SIMPLE table: film type: index possible_keys: NULL key: PRIMARY key_len: 2 ref: NULL rows: 55 Extra: NULL 1 row in set (0.00 sec) 优化步骤2：记录上次返回的主键，在下次查询时使用主键过滤（保证主键是自增且连续的） EXPLAIN SELECT film_id, description FROM sakila.film WHERE film_id &gt; 600 AND film_id &lt;= 605 ORDER BY film_id LIMIT 1, 5 执行计划： *************************** 1. row *************************** id: 1 select_type: SIMPLE table: film type: range possible_keys: PRIMARY key: PRIMARY key_len: 2 ref: NULL rows: 5 Extra: Using where 1 row in set (0.00 sec) 索引优化如何选择合适的列建立索引1.为合适的列建立索引 在 where 从句，group by 从句，order by 从句，on 从句中出现的列 索引字段越小越好 离散度的列放到联合索引的前面例如： SELECT * FROM payment WHERE staff_id = 2 AND customer_id = 584; 上述 SQL 语句，是 index(staff_id,customer_id) 合理，还是 index(customer_id,staff_id) 合理。执行语句如下： SELECT count(DISTINCT customer_id) , count(DISTINCT staff_id) FROM payment; # 结果是 599 2 由于 customer_id 的离散度更大，所以应该使用 index(customer_id,staff_id) 2. 找到重复和冗余的索引之所以要找到重复和冗余的索引，是因为过多的索引不但影响写入，而且影响查询，索引越多，分析越慢。那么为何重复索引、冗余索引？概念如下： 重复索引是指相同的列以相同的顺序建立的同类型的索引，如下表中 primary key 和 ID 列上的索引就是重复索引，例子如下： CREATE TABLE test ( id INT NOT NULL PRIMARY KEY, NAME VARCHAR (10) NOT NULL, title VARCHAR (50) NOT NULL, UNIQUE (id) ) ENGINE = INNODB; UNIQUE(ID) 和 PRIMARY KEY 重复了。冗余索引是指多个索引的前缀列相同，或是在联合索引中包含了主键的索引，例子如下： CREATE TABLE test ( id INT NOT NULL PRIMARY KEY, NAME VARCHAR (10) NOT NULL, title VARCHAR (50) NOT NULL, KEY (NAME, id) ) ENGINE = INNODB; 查找重复及冗余索引的 SQL 语句如下： USE information_schema; SELECT a.TABLE_SCHEMA AS &apos;数据名&apos;, a.table_name AS &apos;表名&apos;, a.index_name AS &apos;索引1&apos;, b.INDEX_NAME AS &apos;索引2&apos;, a.COLUMN_NAME AS &apos;重复列名&apos; FROM STATISTICS a JOIN STATISTICS b ON a.TABLE_SCHEMA = b.TABLE_SCHEMA AND a.TABLE_NAME = b.table_name AND a.SEQ_IN_INDEX = b.SEQ_IN_INDEX AND a.COLUMN_NAME = b.COLUMN_NAME WHERE a.SEQ_IN_INDEX = 1 AND a.INDEX_NAME &lt;&gt; b.INDEX_NAME 也可以使用工具 pt-duplicate-key-checker 检查重复索引和冗余索引,使用例如： pt-duplicate-key-checker -uroot -p &apos;123456&apos; -h 127.0.0.1 -d sakila 执行结果如下： # ######################################################################## # Summary of indexes # ######################################################################## # Size Duplicate Indexes 118425374 # Total Duplicate Indexes 24 # Total Indexes 1439 删除不用的索引目前 MySQL 中还没有记录索引的使用情况，但是在 PerconMySQL 和 MariaDB 中可以通过 INDEX_STATISTICS 表来查看哪些索引未使用，但在 MySQL 中目前只能通过慢查询日志配合共组 pt-index-usage 来进行索引使用情况的分析。 pt-index-usage -uroot -p ‘123456’ /usr/local/var/mysql/luyiyuandeMacBook-Pro-slow.log; 数据库结构优化选择合适的数据类型 使用可以存下你的数据的最小的数据类型 使用简单的数据类型。Int 要比 varchar 类型在 MySQL 中处理更高效 尽可能使用 not null 定义字段 尽量少用 text 类型，非用不可时最好考虑分表 数据库表的范式化优化​ 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。 优化方法：对表进行拆分 数据库表的反范式化优化反范式化是利用空间换取时间的操作 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。但是有些时候一昧的追求范式减少冗余，反而会降低数据读写的效率，这个时候就要反范式，利用空间来换时间。 目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。一般说来，数据库只需满足第三范式(3NF）就行了。 数据库表的垂直拆分垂直拆分，就是把原来一个有很多列的表拆分成多个表，这解决了表的宽度问题。通常垂直拆分就可以按以下原则进行： 把不太常用的字段单独存放到一个表中 把大字段独立存放到一个表中 把经常一起使用的字段放到一起 表film垂直拆分长表film和表file_text 数据库表的水平拆分当单表的数据量过大，导致增删查改等操作过慢，这时候需要对表进行水平拆分。水平拆分的表，每一张表的结构都是完全一致的。 常用的水平拆分方法为： 对 customer_id 进行 hash 运算，如果要拆分成 5 个表则使用 mod(customer_id,5) 取出 0-4 个值 针对不同的 hashID 把数据存到不同的表中 挑战： 跨分区表进行数据查询 统计及后台报表操作 系统配置优化数据库系统配置优化数据库是基于操作系统的，目前大多数 MySQL 都是安装在Linux 系统之上，所以对于操作系统的一些参数配置也会影响到 MySQL 的性能，下面列举一些常用到的系统配置。 网络方面的配置，要修改文件 /etc/sysctl.conf # 增加 tcp 支持的队列数 net.ipv4.tcp_max_syn_backlog = 65535 # 减少断开连接时，资源回收 net.ipv4.tcp_max_tw_buckets = 8000 net.ipv4.tcp_tw_reuse = 1 net.ipv4.tcp_tw_recycle = 1 net.ipv4.tcp_fin_timeout = 10 打开文件数的限制，可以使用 ulimit -a 查看目录的各项限制，可以修改文件 /etc/security/limits.conf ，增加以下内容以修改打开文件数量的限制 soft nofile 65535 hard nofile 65535 除此之外最好在 MySQL 服务器上关闭 iptables，selinux 等防火墙软件。 MySQL配置文件优化MySQL 可以通过启动时指定配置参数和使用配置文件两种方法进行配置，在一般情况下，配置文件位于 /etc/my.cnf 或是 /etc/mysql/my.cnf 常用参数说明 innodb_buffer_pool_size：用于配置 Innodb 的缓冲池大小如果数据库中只有 Innodb 表，则推荐配置量为总内存的 75% Innodb_buffer_pool_size &gt;= Total MB SELECT ENGINE, round( sum(data_length + index_length) / 1024 / 1024, 1 ) AS &apos;Total MB&apos; FROM information_schema. TABLES WHERE table_schema NOT IN ( &quot;information_schema&quot;, &quot;performance_schema&quot; ) GROUP BY ENGINE; innodb_buffer_pool_instances：MySQL 5.5 中新增参数，可以控制缓冲池的个数，默认情况下只有一个缓冲池。 innodb_log_buffer_size：Innodb 日志缓冲的大小，由于日志最长，每秒钟就会刷新，所以一般不用太大。 innodb_flush_log_at_trx_commit：对 Innodb 的 IO 效率影响很大。 innodb_file_per_table：控制 Innodb 每一个表都使用独立的表空间，默认为 OFF，也就是所有表都会建立在共享表空间中。 innodb_stats_on_metadata：决定 MySQL 在什么情况下会刷新 innodb 表的统计信息。 第三方配置工具使用percona工具网址：https://tools.percona.com/ 服务器硬件优化 如何选择 CPU MySQL 有一些工作只能使用到单核 CPU，选择高频 MySQL 对 CPU 核数的支持并不是越多越快，MySQL 5.5 版本不要超过 32 个核 硬盘 IO 优化 RAID 级别简介 RAID 0：也称为条带，就是把多个磁盘链接成一个硬盘使用，这个级别 IO 最好 RAID 1：也成为镜像，要求至少两个磁盘，每组磁盘存储的数据相同 RAID 1 + 0：就是 RAID 1 和 RAID 0的结合。同时具备两个级别的优缺点。一般建议数据库使用这个级别。 RAID 5：把多个（最少 3 个）硬盘合并成 1 个逻辑盘使用，数据读写时会建立奇偶校验信息，并且奇偶校验信息和相对应的数据分别存储在不同的磁盘上。当 RAID 5 的一个磁盘数据发生损坏后，利用剩下的数据和相应的奇偶校验信息去恢复被损坏的数据。 推荐：https://www.cnblogs.com/lykbk/p/retertrwerwerwer23454324534534.html]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP高级——PHP性优化实战总结]]></title>
    <url>%2F2018%2F08%2F01%2FPHP%E9%AB%98%E7%BA%A7%E2%80%94%E2%80%94PHP%E6%80%A7%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[PHP性能问题，占整个项目性能问题一般占30%，不会超过50%。要从全局去考虑全局的性能问题 源自慕课网视频教程整理：https://www.imooc.com/learn/205 什么情况下遇到PHP性能问题 1 ：PHP语法使用不恰当 2 ：使用了PHP语言他不擅长做的事情 3 ：用PHP语言连接的服务不给力 4 ：PHP自身的短板 5 ：未知的问题 PHP性能问题解决方向 （从1~3的顺序，操作简单，见效快排序） A . PHP语言级的性能优化 ：日常语法方法的优化 特点：简单高效很快见到效果 B . PHP周边问题的性能优化 ：网络环境，前面webserver，后面mysql C . PHP语言自身的分析和优化 ：PHP底层C语言逻辑的优化 压力测试作为一个PHP程序员必须要知道并且会使用常用的压力测试工具，对接口做压力测试 Apache Benchmark 简称ab ab是由Apache提供的压力测试软件。安装apache服务器时会自带压测软件 使用 ./ab -n1000 -c100 http://www.baidu.com + -n请求数 -c并发数 url目标 ab 返回结果的参数 1&gt; Requests per second 每秒请求数 （优化目标 每秒的请求数尽可能多） 2&gt; Time per request 响应一个请求耗时 （优化目标 响应一个请求尽可能少） webbench webbench -c 50 -t 30 http://127.0.0.1:6969/shenghuojiaofei/test https://www.jianshu.com/p/efdaa2064513 siege siege -c 并发数 -t 运行测试时间 URL 这里要注意的是-t后面的时间要带单位，s表示秒，如果不带，就是分钟。 http://download.joedog.org/siege/siege-latest.tar.gz Opcode我们知道，拿到一段代码后，经过词法解析、语法解析等阶段后，源程序会被翻译成一个个指令(opcodes)，然后ZEND虚拟机顺次执行这些指令完成操作。PHP本身是用C实现的，因此最终调用的也都是C的函数，实际上，我们可以把PHP看做是一个C开发的软件。 PHP的执行的核心是翻译出来的一条一条指令，也即opcode，我们平时所说的缓存，一般也是缓存Opcode(APC,mecache,yac)。 Opcode是PHP程序执行的最基本单位。一个opcode由两个参数(op1,op2)、返回值和处理函数组成。PHP程序最终被翻译为一组opcode处理函数的顺序执行。 所以我们可以通过vld查看和分析Opcode，具体问题具体分析 https://segmentfault.com/a/1190000005937076 PHP语言级性能优化 优化点：少些php代码，多用PHP自身能力，多用PHP自身的 性能问题：自写代码冗余较多，可读性不佳，并且性能低 php代码写的越长长执行效果就会越差，多用php自身的函数等 为什么性能低? : PHP 代码需要编译为C语言，C语言又会编译成汇编语言（机器语言），这里每一个过程都会请求一遍，开销很大。尤其是访问量大的时候，每次都会编译一遍。所以要尽量减少代码 好的方法：多使用PHP内置的变量、常量、函数 原生PHP 和 自己写一段实现一个同样的功能，性能差异。有的可能会提高好几倍。 为什么自己实现的会慢呢? PHP代码如何再linux上执行？ *.php 通过zend引擎逐行扫描分析(Scanner)， 保存成zend引擎自己能识别的语法(Exprs), 这些zend引擎能识别的语法，再解析(Parser)成Opcodes。 Opcodes是最终要拿去执行的机器代码 。执行，然后输出。 逐行扫描，转码，解析成Opcodes，然后输出, 扫描时间少了，zend转码时间会更快，解析Opcodes也会更快。 缓存服务都是缓存的Opcodes，就不用扫描和解析了，当然就更更快了。 ###【PHP内置函数的性能优劣】 情况描述: PHP内置函数，之间依然存在快慢差异。使用快的函数。 数组，文件，日期的操作 多了解注释时间复杂度，大部分性能问题，都会涉及时间和控件的转换 ###【尽量少用魔法函数】 为什么魔法函数性能低： 为了给程序员省事，php语言为你做了很多 + linux time函数 可以直接测试程序的耗时情况 魔法函数举例：__get(); + 可以不用尽量不用，如果必须要用的时候再用。 ###【不使用@ 错误抑制符】 @ 错误抑制符原理：在代码开始前、结束后，增加Opcode前面提到了vld工具，我们这里可以在代码开始前、结束后，增加Opcode。查看一下Opcode执行码。 工具： vld PHP扩展 主要作用就是把opcode 演示出来。 1php -dvld.active=1 -dvld.execute=0 at.php 回打印出opcode，结果用@ 会多2行代码，多操作逻辑，有多些开销。 可以用 try throw 这种。 ###【合理使用内存】 情况描述：php有内存回收机制保底，但也要小心使用内存 建议：利用unset()及时释放不使用的内存（注：unset出现注销不掉的情况，自己查资料） ###【尽量少的使用正则表达式】 情况描述：正则表达式性能低，因为正则表达式回溯开销较大 好的建议：利用字符串处理函数，实现相同的逻辑 ###【避免循环内做运算】 情况描述：循环内的计算式会被重复计算 例如1for($i=0;$i&lt;strlen($str);$i++) 每一次for循环都会进行计算strlen ###【减少计算密集型业务】 情况描述：PHP不适合密集型运算场景,在处理大数据量的时候性能比较差 为什么：+ 比如不适合大批量日志分析，或者大批量数据处理。 + php语言特性决定了PHP不适合做大数据运算 + php所有处理都需要转换成C语言，与C相比，C更好。 + php还有环境问题，还有语言特性。额外开销比C大很多。变量寄存等。。 PHP适合什么？ 以下是PHP官方手册提供的PHP支持 PHP 脚本主要用于以下三个领域： 12345678910111213服务端脚本。 这是 PHP 最传统，也是最主要的目标领域。 开展这项工作需要具备以下三点：PHP 解析器（CGI 或者服务器模块）、web 服务器和 web 浏览器。需要在运行 web 服务器时，安装并配置 PHP，然后，可以用 web 浏览器来访问 PHP 程序的输出，即浏览服务端的 PHP 页面。 如果只是实验 PHP 编程，所有的这些都可以运行在自己家里的电脑中。命令行脚本。 可以编写一段 PHP 脚本，并且不需要任何服务器或者浏览器来运行它。通过这种方式，仅仅只需要 PHP 解析器来执行。 这种用法对于依赖 cron（Unix 或者 Linux 环境）或者 Task Scheduler（Windows 环境）的日常运行的脚本来说是理想的选择。这些脚本也可以用来处理简单的文本。编写桌面应用程序。 对于有着图形界面的桌面应用程序来说，PHP 或许不是一种最好的语言，但是如果用户非常精通 PHP，并且希望在客户端应用程序中使用 PHP 的一些高级特性，可以利用 PHP-GTK 来编写这些程序。 用这种方法，还可以编写跨平台的应用程序。PHP-GTK 是 PHP 的一个扩展，在通常发布的 PHP 包中并不包含它。 所以总结来说：PHP适合衔接webserver与后端服务、UI呈现。（就是接口，简单数据处理，和套页面）###【务必使用带引号字符串做键值】 情况描述：php会将没有引号的键值检查一遍是不是常量，产生查询常量的开销 产生多余的查找工作，所以尽量带引号(双、单)书写，作为键值对 PHP周边问题的性能优化 PHP周边都有什么 1.linux环境 2.硬盘，文件存储，php读写 3.数据库，表设计 4.缓存 缓存是基于内存的 5.网络，带宽 抓大头去优化，就是先从大的方向去做优化 ###【减少文件类操作】 常见PHP场景的开销次序： 读写磁盘、 读写数据库、 读写内存、 读写网络数据 读写内存 &lt;&lt;&lt; 读写数据库 &lt; 读写磁盘 &lt; 读写网络数据: socket操作文件句柄 ###【减少php发起网络请求】 优化网络请求 网络请求的坑：1. 对方接口的不确定因素 2. 网络稳定性 如何优化网络请求 ######1设置超时时间 ： 建议值 a）连接超时 200ms 这是上限，最多也不能超过这个时间 b）读超时 800ms 这个看具体情况 c）写超时 500ms 建议不要超过500ms ######2、将串行请求并行化 a）使用curl_multi_*（） 返回时间是看用时最长的那个请求 b）使用swoole扩展 通过C来进行并行化。推荐使用 ###【压缩PHP接口输出】 如果用php做接口如何更高效的输出 如何压缩 ： 使用Gzip 压缩输出的利弊： 利：利于数据输出，client能更快获取数据 弊：额外的CPU开销。如果请求大，肯能会有问题 gzip如果数据量小于几十K的时候效果并不理想。如果大于100k，压缩就有效果。 ###【缓存重复计算内容】 什么情况下做输出内容缓存 ： 固定重复请求的数据做缓存。 ###【重叠时间窗口思想】 串行变并行 如果后一个请求不强依赖于前一个返回值。就可以变成并行，降低总体时间消耗 条件：后一个任务不强依赖于前一个任务 ###【旁路方案】 也是重叠时间窗口思想 条件：后一个任务不强依赖于前一个任务 其他高级优化 读写分离 分布式 集群 CDN 服务器架构 后期会有相应的文章具体学习与实战 PHP性能问题的具体分析 工具： XHPorf（源自fackbook的PHP性能分析工具） 实践：通过分析wordpress程序，做优化。 php –ri 扩展名 查看php是否支持某个扩展 linux 下搜索文件中具体代码在哪个文件 grep ‘xxx’ ./ -r 其他工具 ab,webbench,siege - 压力测试 vld - opcode代码分析 PHP性能瓶颈解决方法 Opcode Cache ：PHP扩展APC就是做Opcode缓存用的 Apc 可能不常用了，可以再pecl点caching。查看php缓存的扩展 pecl 是官方经过验证的PHP扩展 扩展实现：通过PHP扩展代替原PHP代码中高频的逻辑,开销比较大的 Runtime优化：HHVM （phpng也许更优于HHVM） 实战总结整理 1、 用单引号代替双引号来包含字符串，这样做会更快一些。因为 PHP 会在双引号包围的 字符串中搜寻变量，单引号则不会， 注意：只有 echo 能这么做，它是一种可以把多个字符 串当作参数的“函数”(译注：PHP 手册中说 echo 是语言结构，不是真正的函数，故把函数 加上了双引号)。 2、如果能将类的方法定义成 static，就尽量定义成 static，它的速度会提升将近 4 倍。 3、$row[‘id’] 的速度是$row[id]的 7 倍。 4、echo 比 print 快，并且使用 echo 的多重参数(译注：指用逗号而不是句点)代替字符串 连接，比如 echo $str1,$str2。 5、在执行 for 循环之前确定最大循环数，不要每循环一次都计算最大值，最好运用 foreach 代替。 6、注销那些不用的变量尤其是大数组，以便释放内存。 7、尽量避免使用get，set，__autoload。 8、require_once()代价昂贵。 9、include 文件时尽量使用绝对路径，因为它避免了 PHP 去 include_path 里查找文件的速 度，解析操作系统路径所需的时间会更少。 10、如果你想知道脚本开始执行(译注：即服务器端收到客户端请求)的时刻，使用 $_SERVER[‘REQUEST_TIME’] 要好于 time() 11、函数代替正则表达式完成相同功能。 12、str_replace 函数比 preg_replace 函数快，但 strtr 函数的效率是 str_replace 函数的四倍。 13、如果一个字符串替换函数，可接受数组或字符作为参数，并且参数长度不太长，那么 可以考虑额外写一段替换代码， 使得每次传递参数是一个字符， 而不是只写一行代码接受数 组作为查询和替换的参数。 14、使用选择分支语句(译注：即 switch case)好于使用多个 if，else if 语句。 15、用@屏蔽错误消息的做法非常低效，极其低效。 16、打开 apache 的 mod_deflate 模块，可以提高网页的浏览速度。 17、数据库连接当使用完毕时应关掉，不要用长连接。 18、错误消息代价昂贵。 19、在方法中递增局部变量，速度是最快的。几乎与在函数中调用局部变量的速度相当。 20、递增一个全局变量要比递增一个局部变量慢 2 倍。 21、递增一个对象属性(如：$this-&gt;prop++)要比递增一个局部变量慢 3 倍。 22、递增一个未预定义的局部变量要比递增一个预定义的局部变量慢 9 至 10 倍。 23、仅定义一个局部变量而没在函数中调用它，同样会减慢速度(其程度相当于递增一个局 部变量)。PHP 大概会检查看是否存在全局变量。 24、方法调用看来与类中定义的方法的数量无关，因为我(在测试方法之前和之后都)添加了 10 个方法，但性能上没有变化。 25、派生类中的方法运行起来要快于在基类中定义的同样的方法。 26、调用带有一个参数的空函数，其花费的时间相当于执行 7 至 8 次的局部变量递增操作。 类似的方法调用所花费的时间接近于 15 次的局部变量递增操作。 27、Apache 解析一个 PHP 脚本的时间要比解析一个静态 HTML 页面慢 2 至 10 倍。尽量 多用静态 HTML 页面，少用脚本。 28、除非脚本可以缓存，否则每次调用时都会重新编译一次。引入一套 PHP 缓存机制通常 可以提升 25%至 100%的性能，以免除编译开销。 29、尽量做缓存，可使用 memcached。memcached 是一款高性能的内存对象缓存系统， 可用来加速动态 Web 应用程序，减轻数据库负载。对运算码 (OP code)的缓存很有用，使 得脚本不必为每个请求做重新编译。 30、 当操作字符串并需要检验其长度是否满足某种要求时， 你想当然地会使用 strlen()函数。 此函数执行起来相当快，因为它不做任何计算，只返回在 zval 结构(C 的内置数据结构，用 于存储 PHP 变量)中存储的已知字符串长度。 但是，由于 strlen()是函数，多多少少会有些 慢，因为函数调用会经过诸多步骤，如字母小写化(译注：指函数名小写化，PHP 不区分函 数名大小写)、哈希查找，会跟随被调用的函数一起执行。 在某些情况下，你可以使用 isset() 技巧加速执行你的代码。 (举例如下) 123if (strlen($foo) &lt; 5) &#123; echo “Foo is too short”$$ &#125; (与下面的技巧做比较) 123if (!isset($foo&#123;5&#125;)) &#123; echo “Foo is too short”$$ &#125; 调用 isset()恰巧比 strlen()快，因为与后者不同的是，isset()作为一种语言结构，意味着它 的执行不需要函数查找和字母小写化。 &gt; 也就是说， 实际上在检验字符串长度的顶层代码中你 没有花太多开销。 31、当执行变量$i 的递增或递减时，$i++会比++$i 慢一些。这种差异是 PHP 特有的，并不 适用于其他语言， 所以请不要修改你的 C 或 Java 代码并指望它们能立即变快， 没用的。 ++$i 更快是因为它只需要 3 条指令(opcodes)，$i++则需要 4 条指令。 后置递增实际上会产生一 个临时变量，这个临时变量随后被递增。 而前置递增直接在原值上递增。这是最优化处理的 一种，正如 Zend 的 PHP 优化器所作的那样。 牢记这个优化处理不失为一个好主意，因为 并不是所有的指令优化器都会做同样的优化处理， 并且存在大量没有装配指令优化器的互联 网服务提供商(ISPs)和服务器。 32、并不是事必面向对象(OOP)，面向对象往往开销很大，每个方法和对象调用都会消耗很 多内存。 33、并非要用类实现所有的数据结构，数组也很有用。 34、不要把方法细分得过多，仔细想想你真正打算重用的是哪些代码? 35、当你需要时，你总能把代码分解成方法。 36、尽量采用大量的 PHP 内置函数。 37、如果在代码中存在大量耗时的函数，你可以考虑用 C 扩展的方式实现它们。 38、 评估检验(profile)你的代码。 检验器会告诉你， 代码的哪些部分消耗了多少时间。 Xdebug 调试器包含了检验程序，评估检验总体上可以显示出代码的瓶颈。 39、mod_zip 可作为 Apache 模块，用来即时压缩你的数据，并可让数据传输量降低 80%。 40、在可以用 file_get_contents 替代 file、fopen、feof、fgets 等系列方法的情况下，尽量 用 file_get_contents，因为他的效率高得多!但是要注意 file_get_contents 在打开一个 URL 文件时候的 PHP 版本问题; 41、尽量的少进行文件操作，虽然 PHP 的文件操作效率也不低的; 42、优化 Select SQL 语句，在可能的情况下尽量少的进行 Insert、Update 操作(在 update 上，我被恶批过); 43、尽可能的使用 PHP 内部函数(但是我却为了找个 PHP 里面不存在的函数，浪费了本可 以写出一个自定义函数的时间，经验问题啊!); 44、 循环内部不要声明变量， 尤其是大变量： 对象(这好像不只是 PHP 里面要注意的问题吧?); 45、多维数组尽量不要循环嵌套赋值; 46、在可以用 PHP 内部字符串操作函数的情况下，不要用正则表达式; 47、foreach 效率更高，尽量用 foreach 代替 while 和 for 循环; 48、用单引号替代双引号引用字符串; 49、“用 i+=1 代替 i=i+1。符合 c/c++的习惯，效率还高” 50、对 global 变量，应该用完就 unset()掉; 推荐：http://baijiahao.baidu.com/s?id=1600263247562743733&amp;wfr=spider&amp;for=pc]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL拓展(extend)]]></title>
    <url>%2F2018%2F07%2F28%2FMySQL%E6%8B%93%E5%B1%95(extend)%2F</url>
    <content type="text"><![CDATA[一、分区表的原理 对用户来说，分区表是一个独立的逻辑表，但是底层mysql将其分成了多个物理的子表，这对用户来说是透明的，每一个分区表都会使用一个独立的表文件。 原理： 创建表的时候通过partition by子句定义每个分区存放的数据，执行查询的时候，优化器会根据分区定义过滤那些没有我们需要数据的分区，这样查询只查询所需的数据所在分区 分区的主要目的是将数据按照一个比较粗的粒度分在不同的表中，这样可以将相关的数据存放在一起，而且要一次删除整个分区也十分方便 适用场景 表非常大，无法全部存在内存，或者只在表的最后有热点数据，其他都是历史数据 分区表的数据更易维护，可以对独立的分区进行独立的操作 分区表的数据可以分布在不同的机器上，从而高效的使用资源 二、分库分表的原理 通过一些HASH算法或者工具将一张数据表垂直或者水平的进行物理切分 适用场景 单表数据达到百万甚至千万的级别 解决表锁的问题 水平分割此时表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询效率 适用场景： 表中的数据有独立性，例如表中记录各个地区或各个时间段的数据，有些数据常用，有些数据不常用 需要把数据存放在多个介质上 缺点： 给应用增加复杂度，通常查询需要多个表名，查询所有的数据都需要union操作 垂直分表将主键和一些列放在一张表，然后把主键和其他列放在另外一张表 使用场景： 表中一些列常用，一些列不常用 可以使数据行变小，一个数据页能存储更多的数据，减少查询I/O次数 缺点： 管理冗余列，查询所有的数据都需要join操作]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx负载均衡入门]]></title>
    <url>%2F2018%2F07%2F24%2FNginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[负载均衡负载均衡（Load Balance）其意思就是分摊到多个操作单元上进行执行，从而共同完成工作任务。通过核心调度者，保证所有后端服务器都将性能充分发挥，从而保持服务器集群的整体性能最优。 算法 [加权]随机算法 通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。可以按后端机器的配置设置随机概率的权重。调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。 [加权]轮询算法 将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。可以按后端机器的配置为轮询中的服务器附加一定权重的算法。比如服务器1权重1，服务器2权重2，服务器3权重3，则顺序为1-2-2-3-3-3-1-2-2-3-3-3- …… 当服务器群中各服务器的处理能力相同时，且每笔业务处理量差异不大时，最适合使用这种算法。 [加权]最小连接算法 在多个服务器中，与处理连接数(会话数)最少的服务器进行通信的算法。由于后端服务器的配置不尽相同，对于请求的处理有快有慢，最小连接数法根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。 可以事先为每台服务器分配处理连接的数量，并将客户端请求转至连接数最少的服务器上。 源地址哈希法 根据获取客户端的IP地址，通过哈希函数计算得到一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，相同的IP客户端，如果服务器列表不变，将映射到同一个后台服务器进行访问。 当客户端有一系列业务需要处理而必须和一个服务器反复通信时，该算法能够以流(会话)为单位，保证来自相同客户端的通信能够一直在同一服务器中进行处理。 配置简单配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546# server1server &#123; listen 8080; server_name local.load.com; index index.html; root /home/www;&#125;# Load Balanceupstream load.com.conf &#123; server 192.168.1.101:80; server 192.168.1.102:80; server 127.0.0.1:8080;&#125; # web serverserver &#123; listen 80; server_name local.load.com; location / &#123; proxy_pass http://load.com.conf; #proxy_set_header Host $host; #proxy_set_header X-Real-IP $remotr_addr; #proxy_set_header X-Forwarde-For $proxy_add_x_forwarded_for; &#125;&#125;# server2 192.168.1.101server &#123; listen 80; server_name local.load.com; root /home/www; location / &#123; index index.html; &#125;&#125;# server3 192.168.1.102server &#123; listen 80; server_name local.load.com; root /home/www; location / &#123; index index.html; &#125;&#125; 详细配置轮询模式： 1234upstream load.com.conf &#123; server 192.168.0.1; server 192.168.0.2;&#125; 加权轮询模式： 1234upstream load.com.conf &#123; server 192.168.0.1 weight=3; server 192.168.0.2 weight=2;&#125; 源地址哈希法： 12345upstream load.com.conf &#123; ip_hash; server 192.168.0.1 weight=3; server 192.168.0.2 weight=2;&#125; fair（第三方）：按后端服务器的响应时间来分配请求，响应时间短的优先分配。 12345upstream load.com.conf &#123; server server1; server server2; fair; &#125; url_hash（第三方）：按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法。 123456upstream load.com.conf &#123; server squid1:3128; server squid2:3128; hash $request_uri; hash_method crc32; &#125; 提示： 1234567upstream bakend &#123; ip_hash; server 127.0.0.1:9090 down; server 127.0.0.1:8080 weight=2; server 127.0.0.1:6060; server 127.0.0.1:7070 backup; &#125; 在需要使用负载均衡的server中增加 1proxy_pass http://bakend/; 每个设备的状态设置为： down 表示单前的server暂时不参与负载 weight 默认为1.weight越大，负载的权重就越大。 max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误 fail_timeout:max_fails次失败后，暂停的时间。 backup： 其它所有的非backup机器down或者忙的时候，请求backup]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Nginx</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL索引与优化(explain)]]></title>
    <url>%2F2018%2F07%2F17%2FMySQL%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BC%98%E5%8C%96(explain)%2F</url>
    <content type="text"><![CDATA[一、 创建索引1.普通索引(最基本的索引，无任何限制)(1)创建索引1CREATE INDEX index_name ON table(column(length)) (2)删除索引1DROP INDEX index_name ON table 2.唯一索引（索引列的值必须唯一，但允许有空值）创建索引：1CREATE UNIQUE INDEX indexName ON table(column(length)) 3.主键索引（一个表的主键）12345CREATE TABLE `table` ( `id` int(11) NOT NULL AUTO_INCREMENT , `title` char(255) NOT NULL , PRIMARY KEY (`id`)); 4.组合索引（将多个列组合在一起创建索引）mysql执行查询中，只会使用到一个索引 最左前缀：意思是使用组合索引的时候，从左到右依次匹配，否则不会使用组合索引。 例如ALTER TABLE people ADD INDEX lname_fname_age (lame,fname,age);其实我们是建立了三个索引，分别是：单列索引lame，组合索引（lame，fname），组合索引（lame，fname，age），mysql索引的时候只会使用其中一个索引。 所以创建组合索引的时候，尽量把使用频繁的放在左边 二、索引创建的原则和注意事项 1.最适合创建索引的是出现在where子句中的列或是出现在连接子句中的列 2.对字符串类型进行索引的时候，应该指定一个前缀长度，比如索引前多少个字符 3.根据业务情况创建组合索引（比如某个业务需要查询两个列） 4.组合索引遵循前缀原则（最左前缀原则）TODO 5.like查询，%不能在前，可以使用全文检索引擎 例如： where name like ‘%wang%’，查询姓名中有wang的，此时索引不会生效，还是会全表扫描，因为前面有个%，如果是like ‘wang%’这样会使用到索引，但是没有前缀匹配了，如果想达到索引的效果，可以使用全文检索引擎，例如es（Elasticsearch） 6.如果mysql觉得全表扫描比索引扫描快，他会自动放弃使用索引 7.mysql查询只使用一个索引，如果where子句中使用了索引，那么order by中的列是不会使用索引的 8.列中包含null值是不会使用索引的，如果column_name is null还是会使用索引，但是建表的时候尽量设置一个非null的默认值。 explain分析sql语句现有如下的sql语句EXPLAIN SELECT * FROM inventory WHERE item_id = 16102176;打印结果如下： 12345678910id: 1 select_type: SIMPLE table: inventory type: ref possible_keys: item_id key: item_id key_len: 4 ref: const rows: 1 Extra: Using where 1.key: 指出优化器使用的索引。 2.rows: mysql认为他查询必须要检查的行数，优化器估计值。 3.possible_keys: 支出优化器为查询选定的索引 4.key_len: sql语句的连接条件的键的长度 5.select_type: select使用的类型。 + simple（简单的select不含union或子查询）、 + primary（最外面的select）、 + union（union中第二个或后面的select）、 + dependent union（union中第二个或后面的select，取决于外面的查询）、 + union result（union的结果）、 + subquery（子查询中第一个select） 6.type： 连接类型。system（表仅有一行）、const（表最多有一个匹配行）、eq_ref(对于每个前面的表的行组合，从该表中读取一行)、ref（对于每个来自于前面表的行组合，所有匹配索引值将从这张表中读取）、index_merge(使用了索引合并优化方法)、all（完整的表扫描） 7.ref： 显示使用哪个列或常数与key一起从表中选择行]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL慢查询机制]]></title>
    <url>%2F2018%2F07%2F02%2FMySQL%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一、简介开启慢查询日志，可以让MySQL记录下查询超过指定时间的语句，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。 二、参数说明 slow_query_log 慢查询开启状态 slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录） long_query_time 查询超过多少秒才记录 ###三、设置步骤 1. 查询慢查询相关的参数1234567891011121314mysql&gt; show variables like &apos;slow_query%&apos;;+---------------------------+----------------------------------+| Variable_name | Value |+---------------------------+----------------------------------+| slow_query_log | OFF || slow_query_log_file | /mysql/data/localhost-slow.log |+---------------------------+----------------------------------+mysql&gt; show variables like &apos;long_query_time&apos;;+-----------------+-----------+| Variable_name | Value |+-----------------+-----------+| long_query_time | 10.000000 |+-----------------+-----------+ 2. 设置方法(1)全局变量设置： 123456设置slow_query_log为onmysql&gt; set global slow_query_log=&apos;ON&apos;; 设置慢查询日志存放位置mysql&gt; set global slow_query_log_file=&apos;/var/logs/mysql/data/slow.log&apos;;设置查询时间超过一秒就记录mysql&gt; set global long_query_time=1; (2)修改配置文件： 1234[mysqld]slow_query_log = ONslow_query_log_file = /usr/local/mysql/data/slow.loglong_query_time = 1 四、pt-query-digest分析慢查询日志1. 简介pt-query-digest是用于分析mysql慢查询的一个工具，它可以分析binlog、General log、slowlog，也可以通过SHOWPROCESSLIST或者通过tcpdump抓取的MySQL协议数据来进行分析。可以把分析结果输出到文件中，分析过程是先对查询语句的条件进行参数化，然后对参数化以后的查询进行分组统计，统计出各查询的执行时间、次数、占比等，可以借助分析结果找出问题进行优化。 2. 安装 官网(1)安装perl的模块 yum install -y perl-CPAN perl-Time-HiRes (2)安装步骤 123456789101112rpm安装：cd /usr/local/srcwget percona.com/get/percona-toolkit.rpmyum install -y percona-toolkit.rpm源码安装：cd /usr/local/srcwget percona.com/get/percona-toolkit.tar.gztar zxf percona-toolkit.tar.gzcd percona-toolkit-2.2.19perl Makefile.PL PREFIX=/usr/local/percona-toolkitmake &amp;&amp; make install (3) 用法简介 123456781.慢查询日志分析pt-query-digest /var/logs/mysql/data/slow.log2.服务器摘要pt-summary3.服务器磁盘监测pt-diskstats4.mysql服务状态摘要pt-mysql-summary -- --user=root --password=root123 3. pt-query-digest语法及重要选项12345678910111213pt-query-digest [OPTIONS] [FILES] [DSN]--create-review-table 当使用--review参数把分析结果输出到表中时，如果没有表就自动创建。--create-history-table 当使用--history参数把分析结果输出到表中时，如果没有表就自动创建。--filter 对输入的慢查询按指定的字符串进行匹配过滤后再进行分析--limit 限制输出结果百分比或数量，默认值是20,即将最慢的20条语句输出，如果是50%则按总响应时间占比从大到小排序，输出到总和达到50%位置截止。--host mysql服务器地址--user mysql用户名--password mysql用户密码--history 将分析结果保存到表中，分析结果比较详细，下次再使用--history时，如果存在相同的语句，且查询所在的时间区间和历史表中的不同，则会记录到数据表中，可以通过查询同一CHECKSUM来比较某类型查询的历史变化。--review 将分析结果保存到表中，这个分析只是对查询条件进行参数化，一个类型的查询一条记录，比较简单。当下次使用--review时，如果存在相同的语句分析，就不会记录到数据表中。--output 分析结果输出类型，值可以是report(标准分析报告)、slowlog(Mysql slow log)、json、json-anon，一般使用report，以便于阅读。--since 从什么时间开始分析，值为字符串，可以是指定的某个”yyyy-mm-dd [hh:mm:ss]”格式的时间点，也可以是简单的一个时间值：s(秒)、h(小时)、m(分钟)、d(天)，如12h就表示从12小时前开始统计。--until 截止时间，配合—since可以分析一段时间内的慢查询。 4. 分析pt-query-digest输出结果 第一部分：总体统计结果 Overall：总共有多少条查询 Time range：查询执行的时间范围 unique：唯一查询数量，即对查询条件进行参数化以后，总共有多少个不同的查询 total：总计 min：最小 max：最大 avg：平均 95%：把所有值从小到大排列，位置位于95%的那个数，这个数一般最具有参考价值 median：中位数，把所有值从小到大排列，位置位于中间那个数 12345678910111213141516171819202122232425# 该工具执行日志分析的用户时间，系统时间，物理内存占用大小，虚拟内存占用大小# 340ms user time, 140ms system time, 23.99M rss, 203.11M vsz# 工具执行时间# Current date: Fri Nov 25 02:37:18 2016# 运行分析工具的主机名# Hostname: localhost.localdomain# 被分析的文件名# Files: slow.log# 语句总数量，唯一的语句数量，QPS，并发数# Overall: 2 total, 2 unique, 0.01 QPS, 0.01x concurrency ________________# 日志记录的时间范围# Time range: 2016-11-22 06:06:18 to 06:11:40# 属性 总计 最小 最大 平均 95% 标准 中等# Attribute total min max avg 95% stddev median# ============ ======= ======= ======= ======= ======= ======= =======# 语句执行时间# Exec time 3s 640ms 2s 1s 2s 999ms 1s# 锁占用时间# Lock time 1ms 0 1ms 723us 1ms 1ms 723us# 发送到客户端的行数# Rows sent 5 1 4 2.50 4 2.12 2.50# select语句扫描行数# Rows examine 186.17k 0 186.17k 93.09k 186.17k 131.64k 93.09k# 查询的字符数# Query size 455 15 440 227.50 440 300.52 227.50 第二部分：查询分组统计结果 Rank：所有语句的排名，默认按查询时间降序排列，通过–order-by指定 Query ID：语句的ID，（去掉多余空格和文本字符，计算hash值） Response：总的响应时间 time：该查询在本次分析中总的时间占比 calls：执行次数，即本次分析总共有多少条这种类型的查询语句 R/Call：平均每次执行的响应时间 V/M：响应时间Variance-to-mean的比率 Item：查询对象 12345# Profile# Rank Query ID Response time Calls R/Call V/M Item# ==== ================== ============= ===== ====== ===== ===============# 1 0xF9A57DD5A41825CA 2.0529 76.2% 1 2.0529 0.00 SELECT# 2 0x4194D8F83F4F9365 0.6401 23.8% 1 0.6401 0.00 SELECT wx_member_base 第三部分：每一种查询的详细统计结果 由下面查询的详细统计结果，最上面的表格列出了执行次数、最大、最小、平均、95%等各项目的统计。 ID：查询的ID号，和上图的Query ID对应 Databases：数据库名 Users：各个用户执行的次数（占比） Query_time distribution ：查询时间分布, 长短体现区间占比，本例中1s-10s之间查询数量是10s以上的两倍。 Tables：查询中涉及到的表 Explain：SQL语句 123456789101112131415161718192021222324252627# Query 1: 0 QPS, 0x concurrency, ID 0xF9A57DD5A41825CA at byte 802 ______# This item is included in the report because it matches --limit.# Scores: V/M = 0.00# Time range: all events occurred at 2016-11-22 06:11:40# Attribute pct total min max avg 95% stddev median# ============ === ======= ======= ======= ======= ======= ======= =======# Count 50 1# Exec time 76 2s 2s 2s 2s 2s 0 2s# Lock time 0 0 0 0 0 0 0 0# Rows sent 20 1 1 1 1 1 0 1# Rows examine 0 0 0 0 0 0 0 0# Query size 3 15 15 15 15 15 0 15# String:# Databases test# Hosts 192.168.8.1# Users mysql# Query_time distribution# 1us# 10us# 100us# 1ms# 10ms# 100ms# 1s ################################################################# 10s+# EXPLAIN /*!50100 PARTITIONS*/select sleep(2)\G 五、用法1.直接分析慢查询文件1pt-query-digest slow.log &gt; slow_report.log 2.分析最近十二小时内的查询1pt-query-digest --since=12h slow.log &gt; slow_report2.log 3.分析指定时间范围内的查询**1pt-query-digest slow.log --since &apos;2017-01-07 09:30:00&apos; --until &apos;2017-01-07 10:00:00&apos;&gt; &gt; slow_report3.log 4.分析含有select语句的慢查询1pt-query-digest --filter &apos;$event-&gt;&#123;fingerprint&#125; =~ m/^select/i&apos; slow.log&gt; slow_report4.log 5.针对某个用户的查询1pt-query-digest --filter &apos;($event-&gt;&#123;user&#125; || &quot;&quot;) =~ m/^root/i&apos; slow.log&gt; slow_report5.log 6.查询所有 所有的全表扫描或full join的慢查询1pt-query-digest --filter &apos;(($event-&gt;&#123;Full_scan&#125; || &quot;&quot;) eq &quot;yes&quot;) ||(($event-&gt;&#123;Full_join&#125; || &quot;&quot;) eq &quot;yes&quot;)&apos; slow.log&gt; slow_report6.log 7.把查询保存到query_review表1pt-query-digest --user=root –password=abc123 --review h=localhost,D=test,t=query_review--create-review-table slow.log 8.把查询结果保存到query_history表12pt-query-digest --user=root –password=abc123 --review h=localhost,D=test,t=query_history--create-review-table slow.log_0001pt-query-digest --user=root –password=abc123 --review h=localhost,D=test,t=query_history--create-review-table slow.log_0002 9.通过tcpdump抓取mysql的tcp协议数据，然后分析12tcpdump -s 65535 -x -nn -q -tttt -i any -c 1000 port 3306 &gt; mysql.tcp.txtpt-query-digest --type tcpdump mysql.tcp.txt&gt; slow_report9.log]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php+redis实现消息队列]]></title>
    <url>%2F2018%2F06%2F29%2Fphp%2Bredis%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[队列的概念 1、是队列结构的中间件 2、消息放入后不需要立即处理 3、由订阅者/消费者按顺序处理 队列原理 也是解耦的原理：业务系统和队列处理系统没有关系 一个写（业务系统），一个读（队列管理系统）。写的只管往队列里写，别的不用操心，读的能不能读完和写的也没有关系 同样，读的只管从队列里往外读，来活儿就干，没活儿歇着 实现介质 1、使用mysql：可靠性高，易实现，速度慢 2、使用redis：速度快，单条大消息包时效率低 3、使用更专业的第三方类库：专业性强，可靠，学习成本高。 消息队列是在消息的传输过程中保存消息的容器。消息队列管理器在将消息从它的源中继到它的目标时充当中间人。队列的主要目的是提供路由并保证消息的传递；如果发送消息时接收者不可用，消息队列会保留消息，直到可以成功地传递它 应用场景：异步处理，应用解耦，流量削锋和消息通讯四个场景 1、异步处理场景说明：用户注册后，需要发注册邮件和注册短信。 注解：自行考虑ajax中的异步。 2、应用解耦一般订单系统和库存系统是一体的，但是如果一方出现问题，那么这个订单就失败了。 订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功。 库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作。 假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦。 注解：感觉特别像行为驱动，消息队列中存储的就是每个行为 3、流量消锋（一般在秒杀或团抢活动中使用广泛） 注解：一般秒杀时订单会特别的多，但是数据库无法一次性的处理这么多，所以可以先存在消息队列中，无论我进的速度多快，出的速度都是一定的。不知道算不算属于漏斗模型的一部分 php的redis扩展：https://github.com/phpredis/phpredis 1）redis函数rpush,lpop 2）.Linux的crontab 创建demo.php和index.php &lt;?php $redis = new Redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;,6379); $password = &apos;123456&apos;; $redis-&gt;auth($password); $arr = array(&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;,&apos;w&apos;,&apos;o&apos;,&apos;r&apos;,&apos;l&apos;,&apos;d&apos;); foreach($arr as $k=&gt;$v){ $redis-&gt;rpush(&quot;mylist&quot;,$v); } &lt;?php $redis = new Redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;,6379); $password = &apos;123456&apos;; $redis-&gt;auth($password); //list类型出队操作 $value = $redis-&gt;lpop(&apos;mylist&apos;); if($value){ echo &quot;出队的值&quot;.$value; }else{ echo &quot;出队完成&quot;; } ?&gt; 建立定时任务 */1 * * * * root php /wwwroot/workplace/redis/index.php */3 * * * * root php /wwwroot/workplace/redis/demo.php 关于秒杀秒杀是我们常见的一个应用场景，主要需要解决的两个问题，一个是高并发对数据库产生的压力，另一个是正确的减少库存的问题，即超卖问题。 下面是我总结的几种方案： 优化方案一：将库存字段number字段设为unsigned，当库存为0时，因为字段不能为负数，将会返回false。 优化方案二：使用mysql的事物锁，锁住要操作的行。 优化方案三：使用非堵塞的文件排它锁 优化方案四：使用redis队列，因为POP操作是原子的即使有很多用户同时到达，也是依次执行。 当然真实的秒杀场景没有说的这么简单，比这复杂的多，有很多需要注意的地方，比如抢购页面做成静态页，通过ajax调用接口。 还有一种场景，可能会出现一个用户抢多个秒杀商品的结果，这时候我们就需要一个排队队列，一个抢购结果队列，以及一个库存队列，循环处理从排队队列中取出一个用户，判断用户是否已经在抢购结构队列里面，相当于一个过滤，如果已经在结果队列里面，则表示已抢购，反之，表示未抢购，库存减1。 建议： 1.秒杀这种活动不会经常出现，可以使用一台专门的服务器只做秒杀。 2.Mysql事物在高并发下，性能下降很厉害，文件锁的方式也是如此，推荐使用redis队列来实现。 推荐 php+redis实现消息队列 参考：http://www.cnblogs.com/lisqiong/p/6039460.html 参考：http://blog.csdn.net/shaobingj126/article/details/50585035]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务端数据（php代码+mysql数据库）迁移]]></title>
    <url>%2F2018%2F06%2F19%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%95%B0%E6%8D%AE%EF%BC%88php%E4%BB%A3%E7%A0%81%2Bmysql%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%89%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[有时候难免会有服务器代码和数据的迁移。 数据的迁移建议删除不必要的日志等文件压缩，数据库的迁移就简单一些。 如果有中转服务器，可以考虑，不然就要下载到本地又上传。 打包: http://www.cnblogs.com/52linux/archive/2012/03/04/2379738.html //压缩 tar -czvf ***.tar.gz tar -cjvf ***.tar.bz2 //解压 tar -xzvf ***.tar.gz tar -xjvf ***.tar.bz2 mysql数据库导出和导入http://www.cnblogs.com/feichexia/p/MysqlDataBackup.html //导出 mysqldump -uroot -pPassword [database name] &gt; [dump file],如 mysqldump -uroot -p123 test &gt; /tmp/test.2017081801.sql //导入 mysql -uroot -p //进入mysql create database dbname; //创建数据库 //use dbname 使用数据库 source /tmp/test.2017081801.sql //导入数据 SCP远程操作（类似通过FTP等下载到本地又上传的过程）http://www.cnblogs.com/daizhuacai/archive/2013/02/01/2889544.html 如果有备份服务器，可以使用将代码和数据打包后放到远程服务器中转scp /etc/mysql/my.cnf necok@192.168.1.136:/etc/mysql将mysql配置文件上传到136服务器相应文件夹内 scp necok@192.168.1.136:/etc/mysql/my.cnf /etc/mysql将136服务器上的mysql配置文件下载到本地的相应文件夹下面 Tp5数据迁移： https://www.jianshu.com/p/5a37846c85ea]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聚簇索引与非聚簇索引的区别]]></title>
    <url>%2F2018%2F06%2F17%2F%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[通常情况下，建立索引是加快查询速度的有效手段。但索引不是万能的，靠索 引并不能实现对所有数据的快速存取。事实上，如果索引策略和数据检索需求严重不符的话，建立索引反而会降低查询性能。因此在实际使用当中，应该充分考虑到 索引的开销，包括磁盘空间的开销及处理开销（如资源竞争和加锁）。例如，如果数据频繁的更新或删加，就不宜建立索引。 本文简要讨论一下聚簇索引的特点及其与非聚簇索引的区别。 聚簇索引数据库表的索引从数据存储方式上可以分为聚簇索引和非聚簇索引（又叫二级索引）两种。Innodb的聚簇索引在同一个B-Tree中保存了索引列和具体的数据，在聚簇索引中，实际的数据保存在叶子页中，中间的节点页保存指向下一层页面的指针。“聚簇”的意思是数据行被按照一定顺序一个个紧密地排列在一起存储。一个表只能有一个聚簇索引，因为在一个表中数据的存放方式只有一种。 一般来说，将通过主键作为聚簇索引的索引列，也就是通过主键聚集数据。 非聚簇索引非聚簇索引，又叫二级索引。二级索引的叶子节点中保存的不是指向行的物理指针，而是行的主键值。当通过二级索引查找行，存储引擎需要在二级索引中找到相应的叶子节点，获得行的主键值，然后使用主键去聚簇索引中查找数据行，这需要两次B-Tree查找。 建立索引：在SQL语言中，建立聚簇索引使用CREATE INDEX语句，格式为：CREATE CLUSTER INDEX index_name ON table_name(column_name1,column_name2,…); 存储特点： 聚集索引。表数据按照索引的顺序来存储的，也就是说索引项的顺序与表中记录的物理顺序一致。对于聚集索引，叶子结点即存储了真实的数据行，不再有另外单独的数据页。 在一张表上最多只能创建一个聚集索引，因为真实数据的物理顺序只能有一种。 非聚集索引。表数据存储顺序与索引顺序无关。对于非聚集索引，叶结点包含索引字段值及指向数据页数据行的逻辑指针，其行数量与数据表行数据量一致。 总结一下：聚集索引是一种稀疏索引，数据页上一级的索引页存储的是页指针，而不是行指针。而对于非聚集索引，则是密集索引，在数据页的上一级索引页它为每一个数据行存储一条索引记录。 更新表数据 1、向表中插入新数据行 ​ 如果一张表没有聚集索引，那么它被称为“堆集”（Heap）。这样的表中的数据行没有特定的顺序，所有的新行将被添加到表的末尾位置。而建立了聚簇索引的数据表则不同：最简单的情况下，插入操作根据索引找到对应的数据页，然后通过挪动已有的记录为新数据腾出空间，最后插入数据。如果数据页已满，则需要拆分数据页，调整索引指针（且如果表还有非聚集索引，还需要更新这些索引指向新的数据页）。而类似于自增列为聚集索引的，数据库系统可能并不拆分数据页，而只是简单的新添数据页。 2、从表中删除数据行 对删除数据行来说：删除行将导致其下方的数据行向上移动以填充删除记录造成的空白。如果删除的行是该数据页中的最后一行，那么该数据页将被回收，相应的索 引页中的记录将被删除。对于数据的删除操作，可能导致索引页中仅有一条记录，这时，该记录可能会被移至邻近的索引页中，原索引页将被回收，即所谓的“索引 合并”。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识游戏——cocos2dx初探]]></title>
    <url>%2F2018%2F06%2F15%2F%E5%88%9D%E8%AF%86%E6%B8%B8%E6%88%8F%E2%80%94%E2%80%94cocos2dx%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[前端时间一直在忙项目，也提到了关于是一个AVG游戏项目，近期由于最新需求，需要开发iOS 游戏，之前做了这么久一直没有感觉到真正游戏或者游戏开发的存在，这一次，好像真的要步入游戏开发了。 所以整理了一下。 具体概念和基本使用就不做介绍了，因为那些都太枯燥了，这里先说说整个环境搭建（以Mac为例），然后根据实际开发整理一些有意义的东西 先来看看官方http://docs.cocos.com/cocos2d-x/manual/zh/ 搭建开发环境 - iOS工具准备Cocos2d-x v3.17，下载后解压，下载参见：Cocos官网页面:http://www.cocos.com/download Xcode 9 下载后安装，下载参见：Apple官网页面;https://developer.apple.com/download/more/或者前往App Store下载 配置步骤： 打开 cocos2d-x-3.17/build/cocos2d_tests.xcodeproj 在 Xcode 顶部工具栏选择 cpp-tests iOS，iPhone 7 Plus，点击运行，项目将自动编译运行，效果如图： 如何调试(Debug) 点击代码行左侧的空白，设置断点 运行 cpp-tests 操作 App 触发断点，IDE 将卡在断点处，视图会自动变化，左侧导航栏可以查看运行堆栈，底部窗口可以查看变量的值： 这里严格来说，其实不算是环境搭建，而是下载引擎，运行官方demo而已，那么下面我们开始简单的搭建一个实际项目，并后续从零开始做一个真正的游戏 实际开发配置步骤：登录Cocos2d-x 的官网 http://www.cocos2d-x.org 点击download 下载最新的版本 点击超链接，将会下载得到一个Cocos2d-x-3.17.zip 压缩包 将下载的压缩包进行解压，打开得到的文件夹，其结构目录如下 build :多平台下的架构文件存放的目录 cocos 框架核心目录 里面存放了Cocos2d-x的核心代码。 docs：文档目录 可以使用该目录下的doxygen.config 文件创建离线文档 extensions:扩展目录 存放了一些官方的扩展 包括更多图形用户界面的控制功能 网络访问 CocosBuilder 等 external：存放扩展需要用到的物理引擎 包括box2d和chipmunk licenses: cocos2d依赖很多开源项目，所有的授权许可文件都在这个目录 plugin:plugin-x 项目目录，plugin -x 是一个可以快速接入第三方idk的框架 templates：该目录包括在不同集成环境及不同平台中创建Cocos2d-x 新项目的模板 test：测试项目 这是我们最开始用到的文件 在 cpp-tests 项目中包含所有类的用法 lua 和js 样本也在这个目录 tools： 需要用到的工具 Cocos2d-console 目录中包含了创建Cocos2d-x项目的脚本 可以针对不同的平台进行开发环境的搭建 同时 还包括将c++绑定至lua 及JavaScript 的脚本文件 Cocos2d-x的安装和配置Cocos2d-x 从2.1.4 版 之后已经不再支持使用模板来生成项目 而是使用官方提供的python 直接创建项目 也就是说Cocos2d-x 不能安装到Xcode上面，不能使用Xcode的Cocos2d-x模板一步一步的生成项目，只能使用Xcode来打开已经创建好的项目 创建项目的步骤如下： 打开终端 进入Cocos2d-x3.14 目录执行./setup.py 运行该文件用来 配置系统的一些环境变量 打开终端 执行Cocos new HelloCpp -p org.cocos2dx -l cpp -d codes 如果一切正常 则项目创建成功 关闭终端 再次进入Cocos2d-3.14目录这时候 会发现新建的codes目录 进入该目录发现新建的HelloCpp项目 进入proj.ios_mac 双击HelloCPP.xcodeproj 文件 使用快捷键（command+run）运行程序 就可以在iOS模拟器上看到经典的hello world 画面]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS游戏——关于马甲包与审核]]></title>
    <url>%2F2018%2F05%2F26%2FiOS%E6%B8%B8%E6%88%8F%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8E%E9%A9%AC%E7%94%B2%E5%8C%85%E4%B8%8E%E5%AE%A1%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[最近因为工作的原因，博客与公众号停了近一个月，网站也没有及时更新，实在抱歉！当初也不知道哪里来的冲动，脑子一热就离开了多年的城市@广州，去了一个鸟都不拉屎的地方@东莞（有点夸张了，老铁！）。 本以为是一个新的开始，本以为可以进入一个新的台阶，没料想，半年之久就遍体鳞伤的回到的这个梦想最开始的地方，其中的心酸就不便多说了，当然也让我学到了不少东西，认识了不少朋友和牛人……今天我们来聊的话题是：甲包与审核…… 引言：离开东莞之后，来到广州的一家新公司（创业公司），开始从事小说类游戏开发，说来也惭愧，以前不怎么玩游戏，最多偶尔玩一下近期比较火的游戏，也没有从事过任何游戏开发的工作，有几次有朋友看到我的英文名@iCocos都会问我，你之前事做游戏开发吗？当时我也只能无奈的解释一下： iCocos的含义是 i+ Coco + s = 苹果 + Cocoa Touch + s 取这个名字的原因是，一直以来都是从事iOS开发，而且对这一块比较喜欢，也很喜欢苹果的产品！ 接触iOS行业也有近四年多，第一次有幸进入游戏这个行业，以前很多同行（非游戏行业）朋友，包括我，一听到游戏行业和游戏开发就觉得很可怕。工资高，加班多——这是是很多人对游戏的行业的最初认识。 背景 项目启动不久，就接到公司内部关于游戏马甲包的整个对接与提审任务，后续也会一直负责这个任务，因为之前是由总部的一个多年Android开发并且有过一些iOS开发经验的同事负责，后面我进来之后iOS这一块也就有我对接处理了，当然其实有很多，我处理的只是其中一两个！ 因为之前上架过不少次，当时还是挺有自信的，但是经过了解和沟通之后发现其实并不是相信中的那么简单。 我还专门花时间在网上，群里，各大论坛和学习网站寻找相关的资料，希望能有一点帮忙！ 其中提到最多的就是关于审核的问题，而且这边同事也说了关于马甲包的审核，通过与否基本上靠运气，而且概率非常低！ 关于马甲包那么说了这么多，什么是马甲包呢？ 马甲APP指的是为了让认识你的人猜不到,在常用的用户名外再注册的其他名字的APP。 马甲APP与真实APP的区别是什么?相同的地方是什么? 应用名称不一样。 关键词不一样。 应用图标。不一样。 应用截图。可以一样,也可以不一样,不做要求。 开屏图片。最好不一样。 其余的,比如主APP的一些品牌因素,最好去掉。因为马甲是要用来做坏事的,当然不能让人察觉咯。 以上出自网络：关于为什么要做马甲APP? 马甲APP怎么做? 马甲APP需要事项? 可以查看下面网络来源说明: 什么是马甲APP？怎么用马甲APP导流 对接事项一直以来我们做的APP一般都是这几种情况： 从零开始发一个完整的项目，然后提审上线。 接手一个已经开发到一部分或者已经上线的迭代项目，然后提审上线。 接手一个审核被拒，根据苹果给出的条款修改内容，然后提审上线 有一些外包或者项目和公司比较特殊的情况 但是正因为是马甲包，所以比较例外，例外在哪里呢？ 我拿不到源码，改不了App内部的任何界面与效果 我只要修改提审内容信息，然后向渠道回到进度 审核几率非常低，而且经常要切换Apple账户处理 …… 操作流程所以在处理之前我这边其实大概根据之前的上线经验整理了一下具体的对接事项和具体步骤： 使用（或新）apple账号 apple developer生成并下载证书（开发与发布） apple developer创建一个Bundle ID apple developer添加设备ID apple developer创建并下载描述文件（开发与发布） itnues connect 创建一个对应ID的app 将证书导入到电脑钥匙串，右健对应证书到处P12 修改IAP支付信息（这种一般都是根据ID，不然会很麻烦） 提交或者修改App Icon，宣传图，应用名称,关键词,应用图标,文件等App和公司信息 将证书，描述文件，P12（+密码）和ID对应版本号ipa提供商 让他们根据重新出包，并提供新的ipa包 确认测试通过，并确认提审信息后，重新上传ipa 提交审核（使用手动发布模式）…… 跟渠道那边及时反馈进度 审核没通过则重新以上步骤（不用换账号还好，换账号是最虐心的！！！） 审核通过则先完成以下两个步骤再点击：发布： 1、通知CP切换到正式区服 2、通知我这边让后端把支付方式切换到第三方支付 最后注意一点： 有时候可能会涉及到SDK的处理，这个就要母包提前就准备好，并且根据实际需求替换对应的参数就可以由于这里已经涉及到SDK开发与集成的基础，已经不属于马甲包的范围 提审信息以下是我提供的数据证书与App提审信息证书与ipa信息 App提审信息 其实整个流程差不多就这么写，这里就不每一步网上都有对应的教程，而且很简单（傻瓜式），当然在整个过程也有可能遇到不少问题，这个就要根据个人经验和学习能力临时应变处理了，所以我就不一一介绍了。 补充：Android流程与注意事项以下是Android同事整理的流程与步骤，可能比较简洁，但是实际并没有这么简单，毕竟Android不像苹果那么多限制，仅供参考，具体流程还是要根据实际执行 反编译 母包 并且 集成了渠道sdk的demo 打开两者 反编译之后的目录进行资源替换 lib里面的so文件 smali源码 res的图片、value里面的资源 manifest的activity、权限等等，包名后面添加对应渠道的名字 注意：(除了3011,其他的渠道包还要修改appId、clientKey、clientId) 在eclipse新建一个同包名的项目， 拷贝修改后母包的res覆盖进去， 修改冲突ids(游戏母包也要修改)， 编译得到apk， 再反编译这个apk， 拿到包名对应下面的R$xxxx.smail覆盖到母包里面 后面就是提交apk或者发包的内容了 最后 那么说了这么多，好像里面学不到什么东西，我为什么还要写这篇文章呢？ 其实一开始不太想写，也确实没有太多有用的东西，但是我觉得写了还是会有一些用的！ 太久没有写博客和公众号了，有点手痒（哈哈！！！） 个人习惯，几乎接触第一次的领域，项目，技术都会简单记录一下 方便后面打算或者会负责此类任务的人，了解整个流程，也欢迎交流学习 最后一点其实也是最重要的，拒审多次，需求有经验的前辈，指点迷津！]]></content>
      <categories>
        <category>Games</category>
      </categories>
      <tags>
        <tag>iOS游戏——关于马甲包与审核</tag>
        <tag>Games</tag>
        <tag>关于马甲包与审核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解PHP之——LANMP原理详解]]></title>
    <url>%2F2018%2F05%2F19%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E4%B9%8B%E2%80%94%E2%80%94LANMP%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[LNMP的工作原理浏览器发送http request请求到服务器（Nginx）,服务器响应并处理web请求。如果是静态文本直接返回，否则将脚本（PHP）通过接口传输协议（网关协议）PHP-FCGI（fast-cgi）传输给PHP-FPM（进程管理程序）,然后PHP-FPM调用PHP解析器的其中一个进程PHP-CGI来解析php脚本信息。【PHP-FPM在启动时启动了多个PHP-CGI子进程，并发执行。】然后将解析后的脚本返回到PHP-FPM，PHP-FPM再通过fast-cgi的形式将脚本信息传送给Nginx。服务器再通过Http response的形式传送给浏览器。浏览器再进行解析与渲染然后进行呈现。 LAMP的工作原理浏览器向服务器发送http请求，服务器 (Apache) 接受请求,由于php作为Apache的组件模块也会一起启动，它们具有相同的生命周期。Apache会将一些静态资源保存，然后调用php去处理模块进行php脚本的处理。脚本处理完后，Apache将处理完的信息通过http response的方式发送给浏览器，浏览器解析，渲染等一系列操作后呈现整个网页。 LAMP LNMP差别 1、在LNMP中，Nginx本身对脚本不做任何的处理，而是把请求发fast-cgi管理进程处理，fast-cgi管理进程选择cgi子进程处理结果并返回，二者是相互独立的，通过管道进程通信。 2、在LAMP中，PHP是Apache的一个模块，具有相同的生命周期。两者通过共享内存的方式通信。 两者的PHP环境不相互适用相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率 nginx的的优势 作为web服务器处理静态文件，索引文件，自动索引的效率非常高 作为代理服务器，可以实现无缓存的反向代理，提高网站运行速度 作为负载均衡服务器，可以在内部直接支持rails和php等 性能方面，采用epoll模型，可以支持多并发并且占用低内存 稳定方面，采取分段资源分配技术，CPU和内存占用率非常低,少量的dos攻击对nginx基本无作用， 高可用方面,支持热部署，启动迅速，可以在不间断服务的情况下，直接升级7x24小时不间容灾 nginx的模块和工作原理 nginx由内核和模块组成，模块结构分为核心模块，基础模块，第三方模块 核心模块: http模块，event模块，mail模块 基础模块: http fastCGI模块，http proxy模块，http rewrite模块 第三方模块: http upstream request hash 模块，notice模块，htttp access key 模块 Fast-CGI 介绍cgi是通用网关接口，是外部应用程序与Web服务器之间的接口标准，cgi是为了保证web server传递过来的数据是标准格式的，方便cgi程序的编写者。 Fast-CGI是语言无关的、可伸缩架构的CGI开放扩展，其主要行为是将CGI解释器进程保持在内存中并因此获得较高的性能。众所周知，CGI解释器的反复加载是CGI性能低下的主要原因，如果CGI解释器保持在内存中并接受FastCGI进程管理器调度，则可以提供良好的性能、伸缩性、Fail- Over特性等等。 Fast-cgi像是一个常驻(long-live)型的cgi，是用来提高cgi程序性能的。 fast-CGI是nginx和php之间的一个通信接口，该接口实际处理过程通过启动php-fpm进程来解析php脚本，即php-fpm相当于一个动态应用服务器，从而实现nginx动态解析php。因此，如果nginx服务器需要支持php解析，需要在nginx.conf中增加php的配置；将php脚本转发到fastCGI进程监听的IP地址和端口（php-fpm.conf中指定）。同时，php安装的时候，需要开启支持fastCGI选项，并且编译安装php-fpm补丁/扩展，同时，需要启动php-fpm进程，才可以解析nginx通过fastCGI转发过来的php脚本。 Fast-CGI的工作原理 Web Server启动时载入Fast-CGI进程管理器（IIS ISAPI或Apache Module) FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可见多个php-cgi)并等待来自Web Server的连接。 当客户端请求到达Web Server时，Fast-CGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到Fast-CGI子进程php-cgi。 Fast-CGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当Fast-CGI子进程关闭连接时，请求便告处理完成。Fast-CGI子进程接着等待并处理来自Fast-CGI进程管理器(运行在Web Server中)的下一个连接。 在CGI模式中，php-cgi在此便退出了。 在上述情况中，你可以想象CGI通常有多慢。每一个Web请求PHP都必须重新解析php.ini、重新载入全部扩展并重初始化全部数据结构。使用Fast-CGI，所有这些都只在进程启动时发生一次。一个额外的好处是，持续数据库连接(Persistent database connection)可以工作。 Fast-CGI的不足因为是多进程，所以比CGI多线程消耗更多的服务器内存，PHP-CGI解释器每进程消耗7至25兆内存，将这个数字乘以50或100就是很大的内存数。 Nginx 0.8.46+PHP 5.2.14(FastCGI)服务器在3万并发连接下，开启的10个Nginx进程消耗150M内存（15M10=150M），开启的64个php-cgi进程消耗1280M内存（20M64=1280M），加上系统自身消耗的内存，总共消耗不到2GB内存。如果服务器内存较小，完全可以只开启25个php-cgi进程，这样php-cgi消耗的总内存数才500M。 上面的数据摘自Nginx 0.8.x + PHP 5.2.13(FastCGI)搭建胜过Apache十倍的Web服务器(第6版) PHP-FPMPHP-FPM是一个实现了Fastcgi的程序，PHP-FPM的管理对象是php-cgi。被PHP官方收了。 后来PHP内核集成了PHP-FPM之后就方便多了，使用–enalbe-fpm这个编译参数即可。 123456789101、php-fpm是一个完全独立的程序,不依赖php-cgi,也不依赖php。因为php-fpm是一个内置了php解释器的FastCGI服务,启动时能够自行读取php.ini配置和php-fpm.conf配置.2、一个master进程,支持多个pool,每个pool由master进程监听不同的端口,pool中有多个worker进程.3、每个worker进程都内置PHP解释器,并且进程常驻后台,支持prefork动态增加.4、每个worker进程支持在运行时编译脚本并在内存中缓存生成的opcode来提升性能.5、每个worker进程支持配置响应指定请求数后自动重启,master进程会重启挂掉的worker进程.6、每个worker进程能保持一个到MySQL/Memcached/Redis的持久连接,实现&quot;连接池&quot;,避免重复建立连接,对程序透明.7、master进程采用epoll模型异步接收和分发请求,listen监听端口,epoll_wait等待连接,8、然后分发给对应pool里的worker进程,worker进程accpet请求后poll处理连接,9、如果worker进程不够用,master进程会prefork更多进程,A、如果prefork达到了pm.max_children上限,worker进程又全都繁忙,这时master进程会把请求挂起到连接队列backlog里(默认值是511).12345678910 PHP-CGIphp-cgi 是解释PHP脚本的程序，只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理 Nginx+FastCGI运行原理 nginx不支持对外部程序的直接调用或者解析，所有的外部程序（包括PHP）必须通过FastCGI接口来调用。FastCGI接口在Linux下是socket（这个socket可以是文件socket，也可以是ip socket）。 wrapper： 为了调用CGI程序，还需要一个FastCGI的wrapper（wrapper可以理解为用于启动另一个程序的程序），这个wrapper绑定在某个固定socket上，如端口或者文件socket。当Nginx将CGI请求发送给这个socket的时候，通过FastCGI接口，wrapper接收到请求，然后Fork(派生）出一个新的线程，这个线程调用解释器或者外部程序处理脚本并读取返回数据；接着，wrapper再将返回的数据通过FastCGI接口，沿着固定的socket传递给Nginx；最后，Nginx将返回的数据（html页面或者图片）发送给客户端。这就是Nginx+FastCGI的整个运作过程， 所以，我们首先需要一个wrapper，这个wrapper需要完成的工作： 1、通过调用fastcgi（库）的函数通过socket和ningx通信（读写socket是fastcgi内部实现的功能，对wrapper是非透明的） 2、调度thread，进行fork和kill 3、和application（php）进行通信]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>LNMP</tag>
        <tag>LAMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解PHP之——HTTP请求全过程]]></title>
    <url>%2F2018%2F05%2F13%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E4%B9%8B%E2%80%94%E2%80%94HTTP%E8%AF%B7%E6%B1%82%E5%85%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一个完整的HTTP请求流程 域名解析 —&gt; 与服务器建立连接 —&gt; 发起HTTP请求 —&gt; 服务器响应HTTP请求，浏览器得到html代码 —&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片） —&gt; 浏览器对页面进行渲染呈现给用户 1. 域名解析以Chrome浏览器为例： ① Chrome浏览器 会首先搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否有https://www.cnblogs.com 对应的条目，而且没有过期，如果有且没有过期则解析到此结束。 注：我们怎么查看Chrome自身的缓存？可以使用 chrome://net-internals/#dns 来进行查看 ② 如果浏览器自身的缓存里面没有找到对应的条目，那么Chrome会搜索操作系统自身的DNS缓存,如果找到且没有过期则停止搜索解析到此结束. 注：怎么查看操作系统自身的DNS缓存，以Windows系统为例，可以在命令行下使用 ipconfig /displaydns 来进行查看 ③ 如果在Windows系统的DNS缓存也没有找到，那么尝试读取hosts文件（位于C:\Windows\System32\drivers\etc），看看这里面有没有该域名对应的IP地址，如果有则解析成功。 ④ 如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），找打根域的DNS地址，就会向其发起请求（请问www.cnblogs.com这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.cnblogs.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.cnblogs.com这个域名的IP地址，但是我知道cnblogs.com这个域的DNS地址，你去找它去，于是运营商的DNS又向cnblogs.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.cnblogs.com这个域名的IP地址是多少？），这个时候cnblogs.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.cnblogs.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.cnblogs.com 对应的IP地址，该进行一步的动作了。 注：一般情况下是不会进行以下步骤的 如果经过以上的4个步骤，还没有解析成功，那么会进行如下步骤（以下是针对Windows操作系统）： ⑤ 操作系统就会查找NetBIOS name Cache（NetBIOS名称缓存，就存在客户端电脑中的），那这个缓存有什么东西呢？凡是最近一段时间内和我成功通讯的计算机的计算机名和Ip地址，就都会存在这个缓存里面。什么情况下该步能解析成功呢？就是该名称正好是几分钟前和我成功通信过，那么这一步就可以成功解析。 ⑥ 如果第⑤步也没有成功，那会查询WINS 服务器（是NETBIOS名称和IP地址对应的服务器） ⑦ 如果第⑥步也没有查询成功，那么客户端就要进行广播查找 ⑧ 如果第⑦步也没有成功，那么客户端就读取LMHOSTS文件（和HOSTS文件同一个目录下，写法也一样） 如果第八步还没有解析成功，那么就宣告这次解析失败，那就无法跟目标计算机进行通信。只要这八步中有一步可以解析成功，那就可以成功和目标计算机进行通信。 2. 与服务器建立连接2.1 TCP连接的建立客户端的请求到达服务器，首先就是建立TCP连接 Client首先发送一个连接试探，ACK=0 表示确认号无效，SYN = 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，seq = x 表示Client自己的初始序号（seq = 0 就代表这是第0号包），这时候Client进入syn_sent状态，表示客户端等待服务器的回复 Server监听到连接请求报文后，如同意建立连接，则向Client发送确认。TCP报文首部中的SYN 和 ACK都置1 ，ack = x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到（ack=1其实是ack=0+1,也就是期望客户端的第1个包），seq = y 表示Server 自己的初始序号（seq=0就代表这是服务器这边发出的第0号包）。这时服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待client的确认。 Client收到确认后还需再次发送确认，同时携带要发送给Server的数据。ACK 置1 表示确认号ack= y + 1 有效（代表期望收到服务器的第1个包），Client自己的序号seq= x + 1（表示这就是我的第1个包，相对于第0个包来说的），一旦收到Client的确认之后，这个TCP连接就进入Established状态，就可以发起http请求了。 问题1：TCP 为什么需要3次握手？2个计算机通信是靠协议（目前流行的TCP/IP协议）来实现,如果2个计算机使用的协议不一样，那是不能进行通信的，所以这个3次握手就相当于试探一下对方是否遵循TCP/IP协议，协商完成后就可以进行通信了，当然这样理解不是那么准确。 问题2：为什么HTTP协议要基于TCP来实现？目前在Internet中所有的传输都是通过TCP/IP进行的，HTTP协议作为TCP/IP模型中应用层的协议也不例外，TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。 2.2 常见TCP连接限制 2.2.1 修改用户进程可打开文件数限制 在Linux平台上，无论编写客户端程序还是服务端程序，在进行高并发TCP连接处理时，最高的并发数量都要受到系统对用户单一进程同时可打开文件数量的限制(这是因为系统为每个TCP连接都要创建一个socket句柄，每个socket句柄同时也是一个文件句柄)。可使用ulimit命令查看系统允许当前用户进程打开的文件数限制，windows上是256，linux是1024，这个博客的服务器是65535 2.2.2 修改网络内核对TCP连接的有关限制 在Linux上编写支持高并发TCP连接的客户端通讯处理程序时，有时会发现尽管已经解除了系统对用户同时打开文件数的限制，但仍会出现并发TCP连接数增加到一定数量时，再也无法成功建立新的TCP连接的现象。出现这种现在的原因有多种。第一种原因可能是因为Linux网络内核对本地端口号范围有限制。此时，进一步分析为什么无法建立TCP连接，会发现问题出在connect()调用返回失败，查看系统错误提示消息是“Can’t assign requestedaddress”。同时，如果在此时用tcpdump工具监视网络，会发现根本没有TCP连接时客户端发SYN包的网络流量。这些情况说明问题在于本地Linux系统内核中有限制。 其实，问题的根本原因在于Linux内核的TCP/IP协议实现模块对系统中所有的客户端TCP连接对应的本地端口号的范围进行了限制(例如，内核限制本地端口号的范围为1024~32768之间)。当系统中某一时刻同时存在太多的TCP客户端连接时，由于每个TCP客户端连接都要占用一个唯一的本地端口号(此端口号在系统的本地端口号范围限制中)，如果现有的TCP客户端连接已将所有的本地端口号占满，则此时就无法为新的TCP客户端连接分配一个本地端口号了，因此系统会在这种情况下在connect()调用中返回失败，并将错误提示消息设为“Can’t assignrequested address”。 2.3 TCP四次挥手当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。 第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了； 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求； 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态； 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。 问题1：为什么要四次分手？ TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。 3. 发起HTTP请求3.1 HTTP协议HTTP是一个客户端和服务器端请求和应答的标准（TCP）。客户端是终端用户，服务器端是网站。通过使用Web浏览器、网络爬虫或者其它的工具，客户端发起一个到服务器上指定端口（默认端口为80）的HTTP请求。 通俗来讲，他就是计算机通过网络进行通信的规则，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据。目前任何终端（手机，笔记本电脑。。）之间进行任何一种通信都必须按照Http协议进行，否则无法连接。 3.1.1 四个基于 1234请求与响应：客户端发送请求，服务器端响应数据无状态的：协议对于事务处理没有记忆能力，客户端第一次与服务器建立连接发送请求时需要进行一系列的安全认证匹配等，因此增加页面等待时间，当客户端向服务器端发送请求，服务器端响应完毕后，两者断开连接，也不保存连接状态，一刀两断！恩断义绝！从此路人！下一次客户端向同样的服务器发送请求时，由于他们之前已经遗忘了彼此，所以需要重新建立连接。应用层： Http是属于应用层的协议，配合TCP/IP使用。TCP/IP： Http使用TCP作为它的支撑运输协议。HTTP客户机发起一个与服务器的TCP连接，一旦连接建立，浏览器（客户机）和服务器进程就可以通过套接字接口访问TCP。 3.2 HTTP请求报文一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成. 3.2.1 请求行 请求行分为三个部分：请求方法、请求地址和协议版本 请求方法HTTP/1.1 定义的请求方法有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。 最常的两种GET和POST，如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT。 请求地址 URL:统一资源定位符，是一种自愿位置的抽象唯一识别方法。 组成：&lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt; 注：端口和路径有时可以省略（HTTP默认端口号是80） https://localhost:8080/index.html?key1=value1&amp;keys2=value2 协议版本协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1 3.2.2 请求头部 请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。 请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。 3.2.3 请求数据 可选部分，比如GET请求就没有请求数据。 下面是一个POST方法的请求报文： POST /index.php HTTP/1.1 请求行 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2 请求头 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8 Accept-Language: zh-cn,zh;q=0.5 Accept-Encoding: gzip, deflate Connection: keep-alive Referer: http://localhost/ Content-Length：25 Content-Type：application/x-www-form-urlencoded 空行 username=aa&amp;password=1234 请求数据 4. 服务器响应HTTP请求，浏览器得到html代码4.1 负载均衡接收到HTTP请求之后，就轮到负载均衡登场了，它位于网站的最前端，把短时间内较高的访问量分摊到不同机器上处理。负载均衡方案有软件、硬件两种 4.1.1 负载均衡硬件方案 F5 BIG-IP是著名的硬件方案，但这里不作讨论 4.1.2 负载均衡软件方案 有LVS HAProxy Nginx等，留作以后补充 在典型的Rails应用部署方案中，Nginx的作用有两个 处理静态文件请求 转发请求给后端的Rails应用 这是一个简单的Nginx配置文件 后端的Rails服务器通过unix socket与Nginx通信，Nginx伺服public文件夹里的静态文件给用户 4.2 Rails(应用服务器)4.3 数据库（数据库服务器）4.4 Redis、Memercache（缓存服务器）4.5 消息队列4.6 搜索4.7 HTTP响应报文HTTP响应报文主要由状态行、响应头部、空行以及响应数据组成。 4.7.1 状态行 由3部分组成，分别为：协议版本，状态码，状态码描述。 其中协议版本与请求报文一致，状态码描述是对状态码的简单描述，所以这里就只介绍状态码。 4.7.2 状态码 状态代码为3位数字。 1xx：指示信息–表示请求已接收，继续处理。 2xx：成功–表示请求已被成功接收、理解、接受。 3xx：重定向–要完成请求必须进行更进一步的操作。 4xx：客户端错误–请求有语法错误或请求无法实现。 5xx：服务器端错误–服务器未能实现合法的请求。 4.7.3 响应头部 与请求头部类似，为响应报文添加了一些附加信息 4.7.4 响应数据 用于存放需要返回给客户端的数据信息。 下面是一个响应报文的实例： HTTP/1.1 200 OK 状态行 Date: Sun, 17 Mar 2013 08:12:54 GMT 响应头部 Server: Apache/2.2.8 (Win32) PHP/5.2.5 X-Powered-By: PHP/5.2.5 Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/ Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0 Pragma: no-cache Content-Length: 4393 Keep-Alive: timeout=5, max=100 Connection: Keep-Alive Content-Type: text/html; charset=utf-8 空行 响应数据]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>HTTP</tag>
        <tag>请求流程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日志组件(Monolog)]]></title>
    <url>%2F2018%2F05%2F05%2F%E6%97%A5%E5%BF%97%E7%BB%84%E4%BB%B6(Monolog)%2F</url>
    <content type="text"><![CDATA[Monolog是php下比较全又容易扩展的记录日志组件。目前有包括Symfony 、Laravel、 CakePHP等诸多知名php框架都内置了Monolog。 Monolog可以把你的日志发送到文件，sockets，收件箱，数据库和各种web服务器上。一些特殊的组件可以给你带来特殊的日志策略。 &lt;?php use Monolog\Logger; use Monolog\Handler\StreamHandler; // create a log channel $log = new Logger(&apos;name&apos;); $log-&gt;pushHandler(new StreamHandler(&apos;path/to/your.log&apos;, Logger::WARNING)); // add records to the log $log-&gt;addWarning(&apos;Foo&apos;); $log-&gt;addError(&apos;Bar&apos;); ​ &lt;?php use Monolog\Logger; use Monolog\Handler\StreamHandler; // create a log channel $log = new Logger(&apos;name&apos;); $log-&gt;pushHandler(new StreamHandler(&apos;path/to/your.log&apos;, Logger::WARNING)); // add records to the log $log-&gt;addWarning(&apos;Foo&apos;); $log-&gt;addError(&apos;Bar&apos;); 核心概念每个Logger实例都有一个通道和日志处理器栈。每当你添加一条日志记录，它会被发送到日志处理器栈。 你可以创建很多Logger，每个Logger定义一个通道（db，请求，路由），每个Logger有很多日志处理器。这些通道会过滤日志。 每个日志处理器都有一个Formatter（内置的日志显示格式处理器）。你还可以设定日志级别。 日志级别 DEBUG：详细的debug信息 INFO：感兴趣的事件。像用户登录，SQL日志 NOTICE：正常但有重大意义的事件。 WARNING：发生异常，使用了已经过时的API。 ERROR：运行时发生了错误，错误需要记录下来并监视，但错误不需要立即处理。 CRITICAL：关键错误，像应用中的组件不可用。 ALETR：需要立即采取措施的错误，像整个网站挂掉了，数据库不可用。这个时候触发器会通过SMS通知你，]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器配置——内网CentOS7/PHP/Apache/Nginx/SVN/Git/GitLab服务器实战]]></title>
    <url>%2F2018%2F04%2F18%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E5%86%85%E7%BD%91CentOS7%3APHP%3AApache%3ANginx%3ASVN%3AGit%3AGitLab%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[完整实战，验证通过，可用….. 此文章看着好长，或者逼格好高的样子。其实很简单，只是因为这些是后端开发或者公司负责项目和内部服务器搭建人员必会的！ 适合人群： PHP后端开发 小团队或部门组负责人 服务器或相关运营负责人 想要学习PHP或者转型后端开发 业务学习，纯属搞着玩 这里就不对每一个模块和内容做解释了，只用实战记录，方便后期查阅也希望能得到更多前辈的点评和指点！ 首先分享一份教程，这是慕课网实战阿里云主机(ECS)与CentOS7教程！ 阿里云主机(ECS)与CentOS7实战 提取码：389j 注：本文部分外部操作基于Mac系统 1.U盘制作Centos系统盘准备 U盘或者硬盘一个，需要大于8G iso系统:(本文基础1708) https://pan.baidu.com/s/1sC8JSuCzPk6BGbfof7vouQ 提取码: 4df8 HFSExplorer：方面Windows系统访问Mac盘(U/硬盘) UltraISO：光盘映像文件制作 具体制作安装U盘的步骤由于过于简单，这里就过多说明，不知道的请出门左转找度娘。 2.Centos安装只要U盘正确制作，关于网上教程非常多，也是非常简单的！ 这里推荐被参考的比较多的教程： https://www.osyunwei.com/archives/7829.html 有些地方需要注意的： 可以的话，最好在安装信息摘要的时候连上网，方便一些相关的更新和下载。 出入学习推荐使用桌面版，当然如果比较喜欢专业或者非入门级的那就使用最小安装，最小安装是基本上很多东西都没有，连网络和相关需求都不支持。 关于分区可以使用自动分区，或者根据教程做相应的分配，建议不要自己随意配，不然后面难免出现问题。 期间遇到了一个问题 /dev/root does not exist, could not boot 网上都说直接修改 vmlinuz initrd=initrd.imginst.stage2=hd:LABEL=CentOS\x207\x20x86_64 rd.live.check quiet 改为： vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sda4 quite 试了好几次都不行,最后发现是空格的问题，因为我格式化U盘之后直接命名为了Centos 7，导致产生了空格，而无法读取到U盘 解决方法： 到windows里面修改U盘名称（例如 ‘Centos7’） 进入U盘目录 进入 EFI/boot 修改grub.cfg文件，CENTOS\x207 全部修改为U盘名称（CENTOS7） 重启安装 正常安装并显示交互界面 总结：名称强烈不建议出现中文空格,容易出bug 安装完成之后，进入Centos命令行查看IP地址，然后在ssh连接工具上尝试连接，并且进行一些操作 CentOS7查看ip地址的方式为： ip addr 这里有一点需要知道的是，阿里云或腾讯云或者其他说明鬼云，都是提供的最新的相关Linux系统，所以一般系统安装是不需要我们来做的，除非有一些特殊的情况。 Ip地址也是直接对外提供，不需要我们去查的，所以就XXX云来说，我们做的事情就是从这里往后操作的流程。甚至有些会给你一些更完整或者更多的功能支持。 如果有需要需要额外配置其他相关功能和服务，推荐看这里： centos7 装机后的基本配置 3.Centos系统配置PHP服务器 注意：以下安装，我都是用的root权限。 一、关闭防火墙查了资料，说法是，CentOS7用的是Firewall-cmd，CentOS7之前用的是iptables防火墙；要想让外网能访问到apache主目录，就需要做以下的操作： 12345678910111213停止firewall systemctl stop firewalld.service禁止firewall开机启动 systemctl disable firewalld.service /** Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service. Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service. */查看默认防火墙的状态 firewall-cmd --state /** not running */ 或者可以这么做： 123firewall-cmd --permanent --zone=public --add-service=httpfirewall-cmd --permanent --zone=public --add-service=httpsfirewall-cmd --reload 二、安装Apache123456789101112131415安装Apache yum install httpd -y--- 一下httpd可以直接使用httpd.service --- 启动Apache systemctl start httpd停止Apache systemctl stop httpd重启Apache systemctl restart httpdApache开机自启 systemctl enable httpd /** Created symlink from /etc/systemd/system/multi-user.target.wants/httpd.service to /usr/lib/systemd/system/httpd.service. */ 在本机浏览器中前面ip addr查到的ip地址，如果看到apache默认的页面–有Testing 123…字样，便是成功安装了apache服务 三、安装php123456安装php yum install php php-devel或者yum -y install php安装Php扩展 yum install php-mysql php-gd php-imap php-ldap php-odbc php-pear php-xml php-xmlrpc重启Apache: systemctl restart httpd或者systemctl restart httpd.service 然后，你可以写一个php文件在浏览器中运行一下了; 12vi /var/www/html/info.php&lt;?php phpinfo(); ?&gt; 然后，在自己电脑浏览器输入 http://172.20.10.2/info.php运行，会出现php的一些信息,如果出现如下界面，说明已经成功了 四、安装mysql1234567891011121314安装MySQL yum install mariadb mariadb-server -y启动MariaDB systemctl start mariadb 停止MariaDB systemctl stop mariadb 重启MariaDB systemctl restart mariadb设置开机启动 systemctl enable mariadb/**Created symlink from /etc/systemd/system/multi-user.target.wants/mariadb.service to /usr/lib/systemd/system/mariadb.service.*/ 设置root帐户的密码 1mysql_secure_installation 然后会出现一串东西，可以仔细读一下，如果你懒得读，就在提示出来的时候，按Enter就好了，让你设置密码的时候，你就输入你想要的密码就行，然后继续在让你选择y/n是，Enter就好了；当一切结束的时候，你可以输入1mysql -u root 验证一下,输入密码，正常连接并可进行mysql操作 有时候由于安装命令的问题，会出现下面的报错，建议重现使用上面的操作一遍 12ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/var/run/mysqld/mysqld.sock' (2) 五、配置Mysql，设置MySQL密码1.连接MySQL1mysql -u root 2.设置密码12mysql&gt; set password for 'root'@'localhost' = password('root');mysql&gt; exit 3.远程授权连接mysql12mysql&gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION;配置生效：FLUSH PRIVILEGES; 再次连接线使用：1mysql -u root -p 然后输入上面的root密码 六、将PHP和MySQL关联起来1yum search php 选择你需要的安装： 1yum -y install php-mysql 七、安装常用的PHP模块例如，GD库，curl，mbstring,… 1.安装：1yum -y install php-gd php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-snmp php-soap curl curl-devel 2.重启apache服务1systemctl restart httpd.service 然后，再次在浏览器中运行info.php，你会看到安装的模块的信息； 至此，LAMP环境就搭建好了…… 4. nginx安装与配置 Nginx从安装到入门，基础篇 Nginx有三种安装方式 安装包编译安装(相对麻烦) yum源安装 使用docker安装 需确认80端口是否开放，如果是阿里云，得在控制台那边设置端口组开放 #确保防火墙是否开放80端口 如果没有 firewall-cmd --permanent --zone=public --add-port=80/tcp #重新加载 firewall-cmd --reload #查看列表 firewall-cmd --list-all 这里推荐直接使用yum源安装，因为比较快捷，方便 #yum安装nginx sudo yum install -y nginx #启动nginx sudo systemctl start nginx.service #设置开机自启动 sudo systemctl enable nginx.service #yum安装的nginx配置文件默认存放在 /etc/nginx/nginx.conf 查看 vi /etc/nginx/nginx.conf #卸载 yum remove nginx 如果可以你也可以直接使用安装包编译安装 # 下载源码 $ wget http://nginx.org/download/nginx-1.13.0.tar.gz # 解压源码 $ tar xvf nginx-1.13.0.tar.gz # 进入源码目录 $ cd nginx-1.13.0 # 配置、编译、安装 $ ./configure $ make $ make install 有时候回遇到，输入网址之后不是官方默认界面，可能是因为 有epel源的时候并且用yum install nginx 安装就会显示Welcome to nginx on Fedora!，因为epel源就是Fedora维护的 5.Centos配置Git服务器1、安装Git首先需要安装Git，可以使用yum源在线安装： 1yum install -y git 2、用户操作创建一个git用户，用来运行git服务 123adduser gitpasswd git/*输入git用户密码*/ 3、git初始化初始化git仓库：这里我们选择/git/icocos.git来作为我们的git仓库 123mkdir /git -pcd /gitgit init --bare icocos.git #初始化仓库 执行以上命令，会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。 4、然后，把owner改为git1chown git:git icocos.git -R 5、clone远程仓库在这里，Git服务器就已经搭得差不多了。下面我们在客户端clone一下远程仓库。 Mysql可以直接使用命令行，或者使用Tower 1234567git clone git@172.20.10.2:/git/icocos.gitCloning into 'icocos'...git@172.20.10.2's password: remote: Counting objects: 6, done.remote: Compressing objects: 100% (6/6), done.remote: Total 6 (delta 0), reused 0 (delta 0)Receiving objects: 100% (6/6), 2.63 MiB | 1.63 MiB/s, done. 输入git账户对应的密码 然后就可以根据公司或者具体项目做相应拓展和配置 Git实战记录总结配置与初始化实战流程1234567891011121314151617181920212223[root@centos /]# yum install -y git 已加载插件：fastestmirror, langpacks Loading mirror speeds from cached hostfile * base: mirror.jdcloud.com * extras: mirrors.163.com * updates: mirrors.163.com 软件包 git-1.8.3.1-20.el7.x86_64 已安装并且是最新版本 无须任何处理 [root@centos /]# adduser git [root@centos /]# passwd git 更改用户 git 的密码 。 新的 密码： 重新输入新的 密码： passwd：所有的身份验证令牌已经成功更新。 [root@centos /]# mkdir git [root@centos /]# cd git [root@centos git]# ls [root@centos git]# mkdir SwiftProject [root@centos git]# cd SwiftProject/ [root@centos SwiftProject]# ls [root@centos SwiftProject]# git init --bare SwiftProject.git #初始化仓库 初始化空的 Git 版本库于 /git/SwiftProject/SwiftProject.git/ [root@centos SwiftProject]# chown git:git SwiftProject.git -R 内外网访问和Clone1git@172.20.10.2:/git/SwiftProject/SwiftProject.git 然后就是根据需求创建项目提交或拉去代码 6.Centos配置SVN服务器1、subversion安装1[root@centos /]# yum install subversion 2、新建一个目录用于存储SVN目录1[root@centos /]mkdir /svn 3、SVN方式创建SVN项目目录1[root@centos svn]# svnadmin create /svn/SwiftProject/ 4、SVN项目目录查看内容12345678[root@centos svn]# ll SwiftProject总用量 8drwxr-xr-x. 2 root root 54 1月 12 01:09 confdrwxr-sr-x. 6 root root 233 1月 12 01:09 db-r--r--r--. 1 root root 2 1月 12 01:09 formatdrwxr-xr-x. 2 root root 231 1月 12 01:09 hooksdrwxr-xr-x. 2 root root 41 1月 12 01:09 locks-rw-r--r--. 1 root root 229 1月 12 01:09 README.txt 以下关于目录的说明： hooks目录：放置hook脚步文件的目录 locks目录：用来放置subversion的db锁文件和db_logs锁文件的目录，用来追踪存取文件库的客户端 format目录：是一个文本文件，里边只放了一个整数，表示当前文件库配置的版本号 conf目录：是这个仓库配置文件（仓库用户访问账户，权限） 5、SVN配置文件cd conf/进入conf目录（该svn版本库配置文件），一共有三个文件 authz文件是权限控制文件 passwd是帐号密码文件 svnserve.conf SVN服务配置文件 a、编辑用户文件passwd，新增两个用户：svn。 vim conf/passwd 12[users]svn = svn b、编辑权限文件authz，用户admin设置可读写权限，guest设置只读权限。 vim conf/authz 12[/]svn = rw c,进入所建立仓库的配置目录/svn/project/conf修改文件svnserve.conf vim conf/svnserve.conf 1234anon-access = none //匿名访问权限auth-access = write //认证用户权限password-db = passwd //密码配置文件路径，默认为同目录的passwd文件realm = My First Repository //认证标记而已 6、启动SVN服务器1svnserve -d -r /svn --listen-host 172.20.10.2 -d表示在后台运行，-r指定了服务器的根目录，这样在SVN客户端就可以用svn://172.20.10.2/SwiftProject来访问SVN服务器 1234svn co svn://172.20.10.2/SwiftProjectChecked out revision 0.lsSwiftProject 注意 使用以下命令可以查看正在运行的SVN进程ps -ef | grep svn使用命令 killall svnserve 来停止SVN服务器。 SVN实战记录总结配置与初始化实战流程12345678910111213141516171819202122[root@centos /]# yum install subversion 已加载插件：fastestmirror, langpacks Loading mirror speeds from cached hostfile * base: mirror.jdcloud.com * extras: mirrors.163.com * updates: mirrors.163.com 软件包 subversion-1.7.14-14.el7.x86_64 已安装并且是最新版本 无须任何处理 [root@centos /]# svnadmin create /svn/project[root@centos /]# cd /svn/SwiftProject [root@centos SwiftProject]# pwd /svn/SwiftProject [root@centos SwiftProject]# ls conf db format hooks locks README.txt [root@centos SwiftProject]# cd conf/ [root@centos conf]# ls authz passwd svnserve.conf [root@centos conf]# vi svnserve.conf [root@centos conf]# vim authz [root@centos conf]# vim passwd [root@centos conf]# cd / [root@centos /]# svnserve -d -r /svn --listen-host 172.20.10.2 内外网访问和Co1svn co svn://172.20.10.2/SwiftProject 然后就是根据需求创建项目提交或拉去代码 7.Centos配置GitLab服务器 安装依赖软件 1yum -y install policycoreutils openssh-server openssh-clients postfix 2.设置postfix开机自启，并启动，postfix支持gitlab发信功能 1systemctl enable postfix &amp;&amp; systemctl start postfix 3.下载gitlab安装包，然后安装 centos 6系统的下载地址 centos 7系统的下载地址 我的是centos7,所以我在https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7中找了个gitlab8.0.0版本,建议下载一个比较新的版本,我这里选了一个比较旧的版本仅仅是实验 123下载rpm包并安装:wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/gitlab-ce-8.0.0-ce.0.el7.x86_64.rpmrpm -i gitlab-ce-8.0.0-ce.0.el7.x86_64.rpm 4.修改gitlab配置文件指定服务器ip和自定义端口： vim /etc/gitlab/gitlab.rb 12345## Url on which GitLab will be reachable. ## For more details on configuring external_url see: ## https://gitlab.com/gitlab-org/omnibus-gitlab/blob/629def0a7a26e7c2326566f0758d4a27857b52a3/README.md#configuring-the-external-url-for-gitlab external_url 'http://172.20.10.2:8081' 最后，退出并保存 注: 这里设置的端口不能被占用，默认是8080端口，如果8080已经使用，请自定义其它端口，并在防火墙设置开放相对应得端口 5.重置并启动GitLab 12gitlab-ctl reconfiguregitlab-ctl restart 提示“ok: run:”表示启动成功 1234567ok: run: gitlab-git-http-server: (pid 3922) 1sok: run: logrotate: (pid 3929) 0sok: run: nginx: (pid 3936) 1sok: run: postgresql: (pid 3941) 0sok: run: redis: (pid 3950) 0sok: run: sidekiq: (pid 3955) 0sok: run: unicorn: (pid 3961) 1s 6.访问 GitLab页面 如果没有域名，直接输入服务器ip和指定端口进行访问,会出现如下页面并提示：You need to sign in before continuing. 初始账户: root 密码: 5iveL!fe注意，第一次登录最好修改密码 修改完成之后，就可以创建项目或者根据具体需求创建分组 7.设置gitlab发信功能，需要注意一点： 发信系统用的默认的postfix，smtp是默认开启的，两个都启用了，两个都不会工作。 我这里设置关闭smtp，开启postfix 12关闭smtp方法：vim /etc/gitlab/gitlab.rb找到#gitlab_rails['smtp_enable'] = true 改为 gitlab_rails['smtp_enable'] = false 修改后执行gitlab-ctl reconfigure另一种是关闭postfix，设置开启smtp + 相关教程请参考[官网](https://doc.gitlab.cc/omnibus/settings/smtp.html) 测试是否可以邮件通知：登录并添加一个用户，我这里使用qq邮箱添加一个用户 创建成功后，就可以去对应的邮箱查看邮件并设置密码 登录qq邮箱，可以收到邮件通知（如果收不到，请查看垃圾邮箱或者检查邮件是否被拦截并删除，如果有请添加到白名单并删除用户再重新添加用户就可以收到了，否则请检查邮件日志并做好相关设置） 到此，GitLab就基本配置完毕，如果有需要和可以结合GitLab，Jenkins，Fastlane实现CI和CD，当然这些一般的小公司不太会用到…… 错误一：报错502 gitlab报502 Whoops, GitLab is taking too much time to respond 配置启动后，访问gitlab，出现：502 ，Whoops, GitLab is taking too much time to respond. 出现这个问题，一般都是你本机的8080端口已经被其他的应用程序占用。 方法一： GitLab在使用的过程中，会开启8080端口，但是如果8080端口被其他的应用程序占用，则GitLab的该项服务不能使用，所以访问GitLab会失败。 方法二： 一般是权限问题，解决方法：chmod -R 755 /var/log/gitlab 如果还不行，请检查你的内存，安装使用GitLab需要至少4GB可用内存(RAM + Swap)! 由于操作系统和其他正在运行的应用也会使用内存, 所以安装GitLab前一定要注意当前服务器至少有4GB的可用内存. 少于4GB内存会出现各种诡异的问题, 而且在使用过程中也经常会出现500错误. 错误二：gitlab-ctl reconfigure 报错n itdb: could not obtain information about current user: Permission denied 1Error executing action `run` on resource 'execute[/opt/gitlab/embedded/bin/initdb -D /var/opt/gitlab/postgresql/data -E UTF8]' 根据报错信息大概锁定用户的权限问题,安装gitlab-ce会自动添加用户四个用户: 1234gitlab-www:x:497:498::/var/opt/gitlab/nginx:/bin/falsegit:x:496:497::/var/opt/gitlab:/bin/shgitlab-redis:x:495:496::/var/opt/gitlab/redis:/bin/nologingitlab-psql:x:494:495::/var/opt/gitlab/postgresql:/bin/sh google和百度都搜索不到解决方法,既然出错提示到权限问题，那么按照这个方向去查就不会有问题，后来查了文件/etc/passwd的权限是600,给予644权限后,成功解决报错问题 改成808112345# gitlab-ctl stop # vi /etc/gitlab/gitlab.rb (取消注释并修改端口) unicorn['port'] = 8801 # gitlab-ctl reconfigure (重新生成配置) # gitlab-ctl restart # lsof -i:8081(check whether unicorn has started properly) 8.Centos配置PHP各种拓展: Composer推荐composer官方更多教程与配置：https://www.phpcomposer.com/ 需要使用到curl，如果没有的话需要 1yum -y install curl ###安装 下载composer.phar1curl -sS https://getcomposer.org/installer | php 把composer.phar移动到环境下让其变成可执行1mv composer.phar /usr/local/bin/composer 测试composer12composer -V /** 输出：Composer version 1.0-dev (e64470c987fdd6bff03b85eed823eb4b865a4152) 2015-05-28 14:52:12 */ 实战操作1234567891011[root@centos /]# curl -sS https://getcomposer.org/installer | phpAll settings correct for using Composer Downloading...Composer (version 1.8.0) successfully installed to: //composer.pharUse it: php composer.phar[root@centos /]# mv composer.phar /usr/local/bin/composer[root@centos ~]# composer -V Do not run Composer as root/super user! See https://getcomposer.org/root for detailsComposer version 1.8.0 2018-12-03 10:31:16 推荐 实战Nginx与PHP（FastCGI）的安装、配置与优化 Nginx站点目录及文件URL访问控制]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器配置——实战验证与补充]]></title>
    <url>%2F2018%2F03%2F09%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81%E4%B8%8E%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[下面关于之前一些流程（Ngnix，Php，Go，Mysql）安装配置与使用的一些总结，和遇到的一个坑，其中也有关于服务器配置与部署，代码上传与发布相关内容，主要是为了熟悉整个流程…… 这里补充一下前面没有提到，但是实际操作会用到或者能提升效率的东西 安装ftp大家看到了，所有的文件操作在ssh中可以通过vim方法来实现，但是，你知道在windows中用惯了，还是喜欢看图形界面，所以在这里我安装了ftp可以远程来上传修改文件 软件：winscp（百度下载就好了） 安装vsftpdyum install vsftpd 启动/重启/关闭vsftpd服务器[root@localhost ftp]# /sbin/service vsftpd restart Shutting down vsftpd: [ OK ] Starting vsftpd for vsftpd: [ OK ] OK表示重启成功了. 这里现在就可以直接使用root及你的密码来查看了，当然这样的是超级用户，留给自己用的，要配置指定要文件夹的用户，我就在不在这里写了，大家继续百度下吧 安装Gitsudo apt-get update sudo apt-get install git]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Server</tag>
        <tag>服务器配置——实战验证与补充</tag>
        <tag>实战验证与补充</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器配置——Redis安装，配置，简单使用]]></title>
    <url>%2F2018%2F03%2F02%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94Redis%E5%AE%89%E8%A3%85%EF%BC%8C%E9%85%8D%E7%BD%AE%EF%BC%8C%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文是因为在做API接口开发的时候，要数据每次都需要从数据读取而写，那样太耗性能了，其实类型iOS中的Cache或者NSUserDefault，用法都和NSUserDefault类似…. Redis安装下载安装包 redis-3.2.8.tar.gz 官网地址：http://redis.io/download 解压： tar -zvxf redis-3.2.8.tar.gz 将解压后的文件夹放到 /Users/local目录下 编译测试:接下来在终端中切换到/Users/local/redis目录下,输入：sudo make test 编译安装：在终端中输入命令：sudo make install 启动Redis,输入命令redis-server redis-server 78407:C 18 Apr 21:32:31.361 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf 78407:M 18 Apr 21:32:31.362 * Increased maximum number of open files to 10032 (it was originally set to 256). _._ _.-``__ &apos;&apos;-._ _.-`` `. `_. &apos;&apos;-._ Redis 3.2.8 (00000000/0) 64 bit .-`` .-```. ```\/ _.,_ &apos;&apos;-._ ( &apos; , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|&apos;` _.-&apos;| Port: 6379 | `-._ `._ / _.-&apos; | PID: 78407 `-._ `-._ `-./ _.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | http://redis.io `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; `-._ `-.__.-&apos; _.-&apos; `-._ _.-&apos; `-.__.-&apos; 78407:M 18 Apr 21:32:31.363 # Server started, Redis version 3.2.8 78407:M 18 Apr 21:32:31.364 * DB loaded from disk: 0.001 seconds 78407:M 18 Apr 21:32:31.364 * The server is now ready to accept connections on port 6379 看到这个界面表示我们已经成功的安装Redis。 二配置1、在 /Users/local/redis目录下建立bin，etc，db三个目录2、把/Users/local/redis/src目录下的mkreleasehdr.sh，redis-benchmark， redis-cli， redis-server拷贝到bin目录3、在etc下，参考原/Users/local/redis目录下的redis.conf，新建一个redis.conf修改redis.conf，具体如下： #修改为守护模式 daemonize yes #设置进程锁文件 pidfile /Users/local/redis/redis.pid #端口 port 6379 #客户端超时时间 timeout 300 #日志级别 loglevel debug #日志文件位置 logfile /Users/local/redis/log-redis.log #设置数据库的数量，默认数据库为16，可以使用SELECT 命令在连接上指定数据库id databases 16 ##指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 #save #Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 #指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间， #可以关闭该#选项，但会导致数据库文件变的巨大 rdbcompression yes #指定本地数据库文件名 dbfilename dump.rdb #指定本地数据库路径 dir /Users/local/redis/db/ #指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能 #会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有 #的数据会在一段时间内只存在于内存中 appendonly no #指定更新日志条件，共有3个可选值： #no：表示等操作系统进行数据缓存同步到磁盘（快） #always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） #everysec：表示每秒同步一次（折衷，默认值） appendfsync everysec 其实只需要拷贝，然后修改对应的值就可以 4、保存后，启动redis：./bin/redis-server etc/redis.conf注意这里log-redis.log文件需要我自己创建 iCocosdeMacBook-Pro:redis icocos$ redis-server etc/redis.conf回车之后没有输出说明成功了 5、查看日志文件：tail -f log-redis.log| `-._`-._ _.-&apos;_.-&apos; | `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; `-._ `-.__.-&apos; _.-&apos; `-._ _.-&apos; `-.__.-&apos; 78584:M 18 Apr 21:48:02.777 # Server started, Redis version 3.2.8 78584:M 18 Apr 21:48:02.777 * The server is now ready to accept connections on port 6379 78584:M 18 Apr 21:48:02.779 - 0 clients connected (0 slaves), 957072 bytes in use 到这里，我们已经完成redis安装和配置。 三使用1、检查是否启动：redis-cli ping2、redis-cli3、ping4、redis-cli 跟上命令会将参数发送到本地redis 6379 的端口，下面来看看基本操作：使用方式 iCocosdeMacBook-Pro:redis icocos$ redis-cli 127.0.0.1:6379&gt; ping PONG 127.0.0.1:6379&gt; set key1 name OK 127.0.0.1:6379&gt; get key1 &quot;name&quot; 5、关闭命令：redis-cli shutdown上面我们演示了redis安装与配置，接下来后面的工作在真实上线之前只需要熟练redis的使用就差不多了，注意细节，并应用到实战，没错就这么简单！ 四.服务器配置上面只是基本的安装，如果要用到生产环境，得配置一些文件 1.首先把redis-cli 移动到/Users/local/bin 目录，方便执行，和JAVA_HOME 类似默认install 的时候已经有了 2.创建你存放配置文件和数据文件的目录sudomkdir /etc/redissudo mkdir /var/redis 3.复制初始化脚本到/etc/init.d 目录,建议默认只有这个端口,作开机启动$ sudocp utils/redis_init_script /etc/init.d/redis_6379 4.进入脚本,确保你的REDISPORT 是你正在使用的sudovi /etc/init.d/redis_6379 5.复制redis.conf ,和脚本保持一致sudocp redis.conf /etc/redis/6379.conf 6.创建一个存放工作数据的目录sudomkdir /var/redis/6379 同时可以对redis.conf配置其他属性 # 来源：http://www.cnblogs.com/shanyou/archive/2012/01/28/2330451.htmldaemonize：是否以后台daemon方式运行pidfile：pid文件位置port：监听的端口号timeout：请求超时时间loglevel：log信息级别logfile：log文件位置databases：开启数据库的数量save **：保存快照的频率，第一个*表示多长时间，第三个*表示执行多少次写操作。在一定时间内执行一定数量的写操作时，自动保存快照。可设置多个条件。rdbcompression：是否使用压缩dbfilename：数据快照文件名（只是文件名，不包括目录）dir：数据快照的保存目录（这个是目录）appendonly：是否开启appendonlylog，开启的话每次写操作会记一条log，这会提高数据抗风险能力，但影响效率。appendfsync：appendonlylog如何同步到磁盘（三个选项，分别是每次写都强制调用fsync、每秒启用一次fsync、不调用fsync等待系统自己同步） 7.最后将脚本设置默认启动sudoupdate-rc.d redis_6379 defaults 8.现在可以执行脚本了/etc/init.d/redis_6379start 五.MAC 版本差异一个不幸的事实是：mac 上是没有init.d 目录的，mac启动脚本是 以.plist 结尾了， 好吧，我在 ~/Library/LaunchAgents 目录下自己建立一个 redis.plist 参考：http://www.js2node.com/redis-io/install-redis-io-2-4-17-on-mac-osx-as-service $ sudovi redis.plist 然后输入以下内容 Labelio.redis.redis-serverProgramArguments/Users/local/bin/redis-server/Users/local/etc/redis.confRunAtLoad 执行命令 $ sudo launchctlload/Library/LaunchDaemons/io.redis.redis-server.plist 打开关闭： $ sudo launchctlstartio.redis.redis-server$ sudo launchctl stop io.redis.redis-server 六.brew 进行安装下面我用brew来操作，关于brew 的安装我看的：http://my.oschina.net/liygheart/blog/284668 安装好了，然后 参考：https://gist.github.com/tonypujals/9631143 $brew info redis 会有提示，然后输入 $ln -nfs /Users/local/opt/redis/*.plist ~/Library/LaunchAgents 和 $load ~/Library/LaunchAgents/homebrew.mxcl.redis.plist 网上还找到一种方式，貌似可以成功1.获取github中的redis-php扩展代码： git clone https://github.com/phpredis/phpredis.git 2.cd phpredis/ 3.phpize mac os 如果这里有 Cannot find autoconf. Please check your autoconf installation and the $PHP_AUTOCONF environment variable. Then, rerun this script.的问题，那么： 执行：brew install autoconf 4.之后执行phpize 5../configure 6.make &amp;&amp; sudo make install 输入密码就会提示成功 Password: Installing shared extensions: /usr/lib/php/extensions/no-debug-non-zts-20131226/ 7.之后在php.ini中加一句 extension=redis.so 就ok了 路径：/etc/php.ini 然后重启 apache/nginx 和 php-fpm ，输入命令：php -m |grep redis 或者通过 phpinfo() 输出php信息查看redis是否安装成功。 期间我在执行install的时候出现这样的问题装不了PHP的扩展，make install失败 RudonMacBook:igbinary-master rudon$ make install Installing shared extensions: /usr/lib/php/extensions/no-debug-non-zts-20131226/ cp: /usr/lib/php/extensions/no-debug-non-zts-20131226/#INST@12567#: Operation not permitted make: *** [install-modules] Error 1 cp: /usr/lib/php/extensions/no-debug-non-zts-20121212/#INST@17000#: Operation not permitted 原因是 原来是OSX 10.11 El Capitan（或更高）新添加了一个新的安全机制叫系统完整性保护System Integrity Protection (SIP)，所以对于目录 /System /sbin /usr 不包含(/usr/local/) 仅仅供系统使用，其它用户或者程序无法直接使用，而我们的/usr/lib/php/extensions/刚好在受保护范围内 所以解决方法就是禁掉SIP保护机制，步骤是： 重启系统 按住Command + R （重新亮屏之后就开始按，象征地按几秒再松开，出现苹果标志，ok） 菜单“实用工具” ==&gt;&gt; “终端” ==&gt;&gt; 输入csrutil disable；执行后会输出：Successfully disabled System Integrity Protection. Please restart the machine for the changes to take effect. 再次重启系统 禁止掉SIP后，就可以顺利的安装了，当然装完了以后你可以重新打开SIP，方法同上，只是命令是csrutil enable 平时使用iCocosdeMacBook-Pro:redis icocos$ cd /Users/local/redis iCocosdeMacBook-Pro:redis icocos$ redis-server 78728:C 18 Apr 22:00:25.105 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf 78728:M 18 Apr 22:00:25.107 * Increased maximum number of open files to 10032 (it was originally set to 256). _._ _.-``__ &apos;&apos;-._ _.-`` `. `_. &apos;&apos;-._ Redis 3.2.8 (00000000/0) 64 bit .-`` .-```. ```\/ _.,_ &apos;&apos;-._ ( &apos; , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|&apos;` _.-&apos;| Port: 6379 | `-._ `._ / _.-&apos; | PID: 78728 `-._ `-._ `-./ _.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | http://redis.io `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; `-._ `-.__.-&apos; _.-&apos; `-._ _.-&apos; `-.__.-&apos; 78728:M 18 Apr 22:00:25.108 # Server started, Redis version 3.2.8 78728:M 18 Apr 22:00:25.108 * DB loaded from disk: 0.000 seconds 78728:M 18 Apr 22:00:25.108 * The server is now ready to accept connections on port 6379 ^C78728:signal-handler (1492524027) Received SIGINT scheduling shutdown... 78728:M 18 Apr 22:00:27.286 # User requested shutdown... 78728:M 18 Apr 22:00:27.286 * Saving the final RDB snapshot before exiting. 78728:M 18 Apr 22:00:27.288 * DB saved on disk 78728:M 18 Apr 22:00:27.288 # Redis is now ready to exit, bye bye... iCocosdeMacBook-Pro:redis icocos$ redis-cli 127.0.0.1:6379&gt; ping PONG 127.0.0.1:6379&gt; set key1 name OK 127.0.0.1:6379&gt; get key1 &quot;name&quot; 127.0.0.1:6379&gt; PHP中使用的话&lt;?php $redis = new Redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); $redis-&gt;set(&apos;iCocos&apos;,1234); $redis-&gt;get(&apos;iCocos&apos;); 执行PHP文件，可以直接网页执行，也可以直接命令执行，方法基本上类似. Redis基本命令Redis数据类型及操作: String: 指令:{ set setnx :如果key已经存在, 返回0 setex :指定键值对的有效期, setex [key] [expire] [value] /类似于:set [key] [value] [EX expire] setrange :设置key-value值的子字符串,下标从0开始到第i位置,不包含i mset msetnx get getset getrange mget incr incrby decr decrby append strlen } Hash:是一个string类型的field-value的映射表,它的添加删除平均都是O(1)的效率 指令:{ hset hsetnx hmset hget hmget hincrby hexists hlen hdel hkeys hvals hgetall } List:是一个链表结构, 主要功能是pop,push,获取一个范围的所有值等,key理解为链表的名字list类型其实就是每一个子元素都是string类型的双向链表. 指令:{ lpush rpush linsert : linsert key [BEFORE|AFTER] [pivot] [value] 在list的特定的值的位置之前或之后添加字符串元素 lset : lset key [index] [value] 设置list中指定下标的元素值 lrem : lrem key [count] [value] 从list中删除count个和value相同的元素 count&gt;0,从头删除; count=0,全部删除; count&lt;0,从尾删除; ltrim : ltrim key [start] [stop] 保留key的值中指定范围内的数据 lpop : 从list的头部删除元素 rpop : 从list的尾部删除元素 rpoplpush : rpoplpush [source] [destination], 整个操作是原子的 从source的尾部移除元素,并添加到destination的头部,返回被移除的元素值 lindex : lindex key [index] 取list中index位置的元素 llen : 返回key对应list的长度 } Set: 指令:{} 键值指令: [ keys :返回给定pattern的所有key exists: 确认一个key是否存在 del : 删除一个key expire : 设置一个key的过期时间(秒为单位) ttl : 用于获取key的有效时长 persist : 移除给定key的过期时间 move : 把当前数据库中的key移动到其它库中 rename : 重命名key ] 服务指令: [ select :选择数据库存取, redis数据库编号从 0~15 默认16个库 dbsize :获取当前数据库的key info : 获取服务器的信息和统计,用于说明服务器的基础信息,包括版本启动时间等; config get: 获取服务器配置信息 flushdb : 删除当前选择数据库中的所有key flushall : 删除所有库中的所有key ] 主从复制基本配置: Redis主从复制中一个主服务可以有多个服务, 一个从服务可以有多个从服务; 对应配置,只需要修改redis.conf中的slaveof参数 #slaveof &lt;masterip&gt; &lt;masterport&gt; slaveof 127.0.0.1 6379 启动master #redis-server /usr/local/redis/conf/redis_6379.conf #redis-cli 启动slave(假设端口3689) #redis-server /usr/local/redis/conf/slave.conf #redis-cli -p 6389 如果master服务设置有密码,则需要配置masterauth参数 masterauth &lt;master-password&gt; 查看redis连接数 redis-cli info | grep connected 如果客户端的idle空闲时间太长,连接池维持了太多的连接,则需要把不用的连接及时释放掉; redis 127.0.0.1:6379&gt; client list redis 127.0.0.1:6379&gt; CONFIG SET timeout 30 Cluster集群配置 cluster-enabled yes 开启 每一个集群节点有一个集群配置文件;它不是手工创建的,是redis节点创建和更新的; 确保同一系统上运行的redis集群节点的配置文件名不重叠 redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件, 并且在此基础上实现了master-slave(主从)同步 pipeline 压缩请求数量 pipeline机制将多个命令汇聚到一个请求中,可以有效减少请求数量,减少网络延时。 script 压缩复杂请求 script核心思想是在redis命令里嵌入Lua脚本,来实现一些复杂操作。 cluster Redis 集群不像单机版本的 Redis 那样支持多个数据库，集群只有数据库 0，而且也不支持 SELECT 命令。 学习Redis命令请参考 http://www.redis.cn/http://www.cnblogs.com/woshimrf/p/5198361.html]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器配置——Php安装与配置]]></title>
    <url>%2F2018%2F02%2F19%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94Php%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[由于之前学过一段时间的Php，偶尔看到一个不错的东西也会尝试一下，虽然可能最终结果和意义并不大，但是此次我还是觉决定让服务器支持Php，同时也会适当的更新一些Php的内容（能力有限，都是比较基础的内容）…… 说了服务器第一步Ngnix安装与配置之后，就要开始说说关于PHP和Go的安装与配置 配置php-fpm部分要让 nginx 能够执行 php 文件，需要去安装一下 php-fpm，它直接包含在了 CentOS 资源库里，所以直接使用 yum 命令可以安装它： yum install php-fpm 完成以后，可以检查一下 php-fpm 的运行状态，使用 service 命令： service php-fpm status 返回： php-fpm is stopped（php-fpm 已停止） 启动 php-fpm 同样可以使用 service 命令： service php-fpm start 让 nginx 可以执行 php现在我们应该就可以让 nginx 去执行 php 了。不过你需要修改一下 nginx 的配置文件，之前我们在配置虚拟主机的时候，创建了一个 nginx.ninghao.net.conf 的配置文件，需要去修改下 nginx 的这个配置文件，才能去执行 php 。使用 vim 命令去编辑它： vim /etc/nginx/conf.d/nginx.ninghao.net.conf 注意你的配置文件不一定叫 nginx.ninghao.net.conf，应该是你自己命名的配置文件。打开以后，找到下面这段字样的代码： # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} 这是 nginx 默认给我们的用来执行 php 的配置，从 location 开始取消注释，会让这个配置生效，然后我们还得简单去修改一下： # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # location ~ \.php$ { # root html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } 注意 root 那里仍然是被注释掉的，还有 SCRIPT_FILENAME 后面修改了一下，把 /scripts 换成了 $document_root 。保存并退出。然后重新启动 nginx： service nginx restart 测试是否可以执行 php现在，我们已经安装了 php-fpm，并修改了 nginx 的配置文件让它可以去执行 php，下面，我们得去测试一下，可以使用 php 的 phpinfo(); 函数，方法是在你的虚拟主机根目录下面，创建一个 php 文件，命名为 phpinfo.php，然后在这个文件里输入： &lt;?php phpinfo(); ?&gt; 保存文件并退出。在浏览器里打开刚才创建的这个 php 文件。我这里应该是 http://nginx.ninghao.net/phpinfo.php。打开以后，你应该能看到像下面这样的界面，如果能，说明 nginx 已经可以执行 php 了。 配置扩展 现在，我们有了可以提供 web 服务的 nginx ，并且安装了 php-fpm ，配置了 nginx 可以让它去执行 php ，也安装了数据库管理系统。 不过在运行真正的网站的时候，我们还需要为 php 安装一些额外的扩展，比如 处理 mysql 数据库的 mysql 扩展，缓存功能的 apc 扩展，处理图像的 gd 扩展等等。安装它们同样可以使用 yum 命令。 yum install php-pecl-apc php-mysql php-gd php-mcrypt php-pear php-mbstring php-xmlrpc php-dom 上面安装了一些 php 的扩展，如果你发现在安装网站的时候提示需要安装其它的扩展，同样可以使用 yum 命令去安装。安装完成以后，需要重启一下 php-fpm ： service php-fpm restart]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Server</tag>
        <tag>服务器配置——Php安装与配置</tag>
        <tag>Php安装与配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器配置——MySql安装与配置]]></title>
    <url>%2F2018%2F02%2F05%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94MySql%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[服务器好了之后，首先我们应该从数据库入手，因为一切没有数据交互与存储的服务器和客户端都只是娱乐，这里我们选择大部分人都熟知而且与PHP成为天和之作的Mysql，当然他和Go也一样兼容…… 安装mysqlmysql 可以管理网站用到的数据库，WordPress 和 Drupal 也都支持 mysql 数据库。所以我们的 Web 运行环境里，需要安装一个 mysql 。之前我们已经添加了资源库，所以可以直接使用 yum 命令去安装 mysql ： yum install mysql-server 安装完成后，使用 service 命令启动 mysql 服务： service mysqld start 然后我们需要简单配置一下 mysql ，默认安装以后 mysql 的 root 用户是没有密码的，对于生产环境来说，这肯定是不行的. 另外还有一些安全相关的设置，可以使用下面这行命令去配置一下，它是一个向导，问你一些问题，你要给出答案，比如是否要设置 root 用户的密码， 密码是什么等等。 mysql_secure_installation 然后根据实际情况进行配置，也可以看看下面比较常用的配置方案 Enter current password for root (enter for none): 解释：输入当前 root 用户密码，默认为空，直接回车。 Set root password? [Y/n] y 解释：要设置 root 密码吗？输入 y 表示愿意。 Remove anonymous users? [Y/n] y 解释：要移除掉匿名用户吗？输入 y 表示愿意。 Disallow root login remotely? [Y/n] n 解释：不想让 root 远程登陆吗？输入 y 表示愿意。 Remove test database and access to it? [Y/n] y 解释：要去掉 test 数据库吗？输入 y 表示愿意。 Reload privilege tables now? [Y/n] y 解释：想要重新加载权限吗？输入 y 表示愿意。]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Server</tag>
        <tag>服务器配置——MySql安装与配置</tag>
        <tag>MySql安装与配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器配置——Nginx安装与配置]]></title>
    <url>%2F2018%2F01%2F23%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94Nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[配置完阿里控制台之后，首先我们开始配置服务器，我的服务器各种配置都需要自己重新配，这里我现在Ngnix，不要问我为什么选择他，可能是之前用过Apache，对他印象不好吧…… 前面说了关于阿里云主机操作，这里打算开始一步一步搭建和配置服务器，并且开始Go语言和后台学习，并且徐后续更新，直到后面的后台实战开发 关于域名解析，实例，和安全组相关请自行参考阿里官方教程 如何连接服务器执行环境配置 我使用的是centos6.8 64位版本，如果您不是第一次接触linux那一定知道，linux不是一个可视化界面的系统，所以要摒弃windows的操作习惯，我使用的xshell这个软件链接的服务器，连接语句是 ssh root@ip地址 地址处就是写入你的ip地址，然后回车鞋面就会自动连接，弹框提示输入密码 输入服务器的密码，点击确定即链接上了 ok，下面就可以开始配置环境了，第一步我们先配置nginx nginx安装部分想在 CentOS 系统上安装 Nginx ，你得先去添加一个资源库，像这样： vim /etc/yum.repos.d/nginx.repo 使用 vim 命令去打开 /etc/yum.repos.d/nginx.repo ，如果 nginx.repo 不存在，就会去创建一个这样的文件，打开以后按一下小 i 键，进入编辑模式，然后复制粘贴下面这几行代码，完成以后按 esc 键退出，再输入 :wq （保存并退出） [nginx] name=nginx repo baseurl=http://nginx.org/packages/centos/$releasever/$basearch/ gpgcheck=0 enabled=1 完成以后，我们就可以使用 yum 命令去安装 nginx 了，像这样： yum install nginx 安装好以后测试一下 nginx 服务： service nginx status 应该会返回： nginx is stopped （nginx 已停止） 再测试一下 nginx 的配置文件： nginx -t 应该会返回： nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful … syntax is ok，… test is successful，说明配置文件没问题，同时这个结果里你可以找到 nginx 的配置文件 nginx.conf 所在的位置。 操纵 nginx 服务操纵服务，可以使用使用 service 命令，它可以启动（start），重启（restart），或停止服务（stop），比如要启动 nginx 服务： service nginx start 服务启动以后，你就可以在浏览器上使用服务器的 IP 地址，或者指向这个地址的域名访问服务器指定的目录了。你会看到类似下面的这些文字。 Welcome to nginx! If you see this page, the nginx web server is successfully installed and working. Further configuration is required. For online documentation and support please refer to nginx.org. Commercial support is available at nginx.com. Thank you for using nginx. nginx配置部分下面来看一下为 nginx 配置虚拟主机。先进入到 nginx 配置文件目录： cd /etc/nginx/conf.d 复制这个目录里的 default.conf ，复制以后的名字可以使用你的虚拟主机名字。比如创建一个 nginx.ninghao.net 的虚拟主机。复制文件可以使用 cp 命令，像这样： cp default.conf nginx.ninghao.net.conf 再去编辑一下这个复制以后的配置文件，可以使用 vim 命令： vim nginx.ninghao.net.conf 你会看到像这样的代码： server { listen 80; server_name localhost; #charset koi8-r; #access_log /var/log/nginx/log/host.access.log main; location / { root /usr/share/nginx/html; index index.html index.htm; } ... } server_name 就是主机名，也就是跟这个虚拟主机绑定在一块儿的域名，我事先把 nginx.ninghao.net 指向了服务器，这个虚拟主机就是为它准备的，所以，server_name 后面的东西就是 nginx.ninghao.net 。 紧接着 server_name 下面可以是一个root，就是这个虚拟主机的根目录，也就是网站所在的目录。比如我们要把 nginx.ninghao.net 这个网站的文件放在/home/www/nginx.ninghao.net 下面，那么这个 root 就是这个路径。 然后去掉 location / 里面的 root 这行代码。再在 index 后面加上一种索引文件名，也就是默认打开的文件，这里要加上一个 index.php ，这样访问 nginx.ninghao.net 就可以直接打开 root 目录下面的 index.php 了。稍后我们再去安装 php 。修改之后，看起来像这样： server { listen 80; server_name nginx.ninghao.net; root /home/www/nginx.ninghao.net; #charset koi8-r; #access_log /var/log/nginx/log/host.access.log main; location / { index index.php index.html index.htm; } ... } 这个配置文件先修改到这，稍后，我们再回来继续修改一下它。保存一下，按 esc ，输入 :wp（保存并退出）。现在虚拟主机应该就可以使用了。主机的域名是 nginx.ninghao.net，访问它的时候，打开的是 /home/www/nginx.ninghao.net 这个目录里面的东西，你可以在这个目录下放点东西。 重启 nginx 或者重新加载 nginx 可以让配置文件生效。 service nginx reload 现在，打开浏览器，输入你为虚拟主机设置的域名，看看是否能打开你指定的目录里的东西。]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>服务器配置——Nginx安装与配置</tag>
        <tag>Server</tag>
        <tag>Nginx安装与配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php 数据处理--合并，拆分，追加，去重]]></title>
    <url>%2F2018%2F01%2F16%2Fphp%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86--%E5%90%88%E5%B9%B6%EF%BC%8C%E6%8B%86%E5%88%86%EF%BC%8C%E8%BF%BD%E5%8A%A0%EF%BC%8C%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[1. 合并数组array_merge()函数将数组合并到一起，返回一个联合的数组。所得到的数组以第一个输入数组参数开始，按后面数组参数出现的顺序依次迫加。 &lt;?php $arr = array(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;); $brr = array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;); $crr = array_merge($arr, $brr); print_r($crr); /*====================打印结果===========================*/ Array ( [0] =&gt; A [1] =&gt; B [2] =&gt; C [3] =&gt; 1 [4] =&gt; 2 [5] =&gt; 3 ) ?&gt; 2. 追加数组array_merge_recursive()函数与array_merge()相同，可以将两个或多个数组合并在一起，形成一个联合的数组．两者之间的区别在于，当某个输入数组中的某个键己经存在于结果数组中时该函数会采取不同的处理方式．array_merge()会覆盖前面存在的键/值对，替换为当前输入数组中的键/值对，而array_merge_recursive()将把两个值合并在一起，形成一个新的数组，并以原有的键作为数组名。还有一个数组合并的形式，就是递归追加数组。 &lt;?php $arr = array(&quot;A&quot;=&gt;1,&quot;B&quot;=&gt;2,&quot;C&quot;=&gt;3); $brr = array(&quot;A&quot;=&gt;4,&quot;B&quot;=&gt;5,&quot;C&quot;=&gt;6); $crr = array_merge_recursive($arr, $brr); print_r($crr); /*====================打印结果===========================*/ Array ( [A] =&gt; Array([0]=&gt;1,[1]=&gt;4), [B] =&gt; Array([0]=&gt;2,[1]=&gt;5), [C] =&gt; Array([0]=&gt;3,[1]=&gt;6), ) ?&gt; 3. 连接数组array_combine()函数会得到一个新数组，它由一组提交的键和对应的值组成。 &lt;?php $arr = array(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;); $brr = array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;); $crr = array_combine($arr, $brr); print_r($crr); /*====================打印结果===========================*/ Array ( &apos;A&apos; =&gt; 1, &apos;B =&gt; 2,&apos;C&apos;=&gt;3 ) ?&gt; 4. 拆分数组 array_slice()array_slice()函数将返回数组中的一部分，从键offset开始，到offset+length位置结束。 &lt;?php $Arr = array(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;L&quot;); $Brr = array_slice($Arr, 3); print_r($Brr); /*====================打印结果===========================*/ Array ( [0] =&gt;&apos; D&apos;,[1] =&gt; &apos;E&apos;,[2] =&gt;&apos; F&apos;,[3] =&gt; &apos;L&apos;) ?&gt; 5. 数组的差集 array_diff()函数array_diff()返回出现在第一个数组中但其他输入数组中没有的值。这个功能与array_intersect()相反。 &lt;?php $arr = array(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;); $brr = array(&quot;A&quot;,&quot;2&quot;,&quot;C&quot;); $crr = array_diff($arr, $brr); print_r($crr); /*====================打印结果===========================*/ Array ([0]=&gt; &apos;B&apos; ) ?&gt;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器配置——阿里云主机配置与操作]]></title>
    <url>%2F2018%2F01%2F11%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%BB%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[前几年在阿里买了一个属于自己的个性域名(笔者英文)：www.icocos.cn，虽然是CN，但是这都不是重点，重点是为了更全面的接触后台，更好的学习与实战后台开发与PHP，前天又在阿里买了个主机，打算开发玩弄一番，毕竟第一次，期间可能会遇到不少坑和不对的地方，望谅解与指出一起交流，谢谢...... 阿里云（先声明我不是来给阿里大广告的，😂😂😂😂😂😂） 阿里云主机 域名：www.icocos.cn 这里关于阿里云主机和域名的购买很简单，准备钱，一路点下去就可以了,具体操作强查看阿里文档…… 备案关于备案确实是不少人蛋疼的事情，说麻烦也没有多麻烦，说不麻烦但是搞起来又不是点几下就可以的，所以也有不少人选择了不需要备案的或者国外的主机，我当时也有这种想法，但是后来放弃了，投资嘛，自己都不舍得投资还怎么学东西，怎么提升呢！ 本案分个人备案和企业备案，具体详情阿里也有教程，或者网上也有相关教程 初始化配置在链接之前可能需要做一些配置，但是有些事必须的有些可以后面备案成功之后再做，我就是第一次弄所以一直不懂，以为需要备案以后才能操作的。 添加安全组织，允许22端口访问这里其实就是进入阿里控制台的云服务ECS，找到安全组，添加安全组，配置规则就可以. 这里只要注意 端口:22/22 授权对象：0.0.0.0/0 初步的这样就可以了，我是为了方便链接访问 然后就可以链接了 连接，并操作连接的话当然首选ssh，不要问我为什么，我也不知道，大家都用它，哈哈！ 关于SSHSSH是每一台Linux电脑的标准配置。 简单说，SSH是一种网络协议，用于计算机之间的加密登录。 如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。 最基本的用法SSH主要用于远程登录。假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。 $ ssh user@host 如果本地用户名与远程用户名一致，登录时可以省略用户名。 $ ssh host SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。 $ ssh -p 2222 user@host 上面这条命令表示，ssh直接连接远程主机的2222端口。 这里我使用的是SSH shell这个工具，Windows用什么不知道，网上应该一大堆命令行步骤 输入 ssh root@ip地址 输入yes 输入密码 就可以看到显示 [root@iZwz92qgus0ln1nx5dftjd2rZ ~]# SSH工具使用也很简单，进后点击Add Server输入ip，端口是默认22，输入root用户名，输入后台配置的密码，对了这里的密码是需要在控制台配置的 一切顺利的话可以看到一个和terminal一样的终端界面，并且已经连接成功的显示 [root@iZwz92qgus0ln1nx5dftjd2rZ ~]# 然后就可以使用命令操作主机文件了。 密码登录：Mac 客户端进入.ssh 文件夹，如果没有就创建一个.ssh文件夹mkdir ~/.ssh cd ~/.ssh/ 生成rsa秘钥：这个相信大部分人都弄过，github就需要ssh-keygen -t rsa 在该文件夹下就会产生三个文件夹：id_rsa,id_rsa.pub,know_hosts。id_rsa：存储私钥，记得只能自己看哦。别人那到这个文件就完蛋蛋咯。 id_rsa.pub:存储公钥，用来通信加密使用，有了这个人家才能确定这是你。 公钥拷贝到云主机scp id_rsa.pub root@78.129.23.45:/root/.ssh/id_rsa.pub Note:云主机上没有.ssh/文件时，你要自己建立一个。终端连接后输入ls只能看到default.pass文件，ls -a发现也是没有.ssh文件夹的，所以需要输入下面命令创建.ssh文件夹 mkdir .ssh #回车没有提示就成功再次ls -a就可以看到一个蓝色的隐藏文件夹 登录到云主机进入.ssh/文件夹cd /root/.ssh/ 将客户端公钥放入云主机识别keys文件夹中cat id_rsa.pub &gt;&gt; authorized_keys 销毁公钥rm id_rsa.pub 再次输入ssh root@ip地址就可以直接连接了，当然如果你使用工具的话就不用这么麻烦。 到这里就基本上初步，而且是很简单的实现的主机的查看与操作，具体更多操作和命令请查看相关资料，后期也会有一些配置，操作与实战，请期待]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Server</tag>
        <tag>服务器配置——阿里云主机配置与操作</tag>
        <tag>阿里云主机配置与操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swoole由浅入深指南]]></title>
    <url>%2F2017%2F12%2F26%2FSwoole%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[PHP语言的高性能网络通信框架，提供了PHP语言的异步多线程服务器，异步TCP/UDP网络客户端，异步MySQL，数据库连接池，AsyncTask，消息队列，毫秒定时器，异步文件读写，异步DNS查询。Swoole可以广泛应用于互联网、移动通信、企业软件、云计算、网络游戏、物联网、车联网、智能家居等领域。 使用PHP+Swoole作为网络通信框架，可以使企业IT研发团队的效率大大提升，更加专注于开发创新产品。 以上的定义是 Swoole 作者给出的。 Swoole 是以 PHP 扩展的形式工作的。就像诸如 mysql、memcache等扩展一样。安装了此扩展，你就能使用该扩展提供的所有功能。那么 Swoole 到底可以用来干啥呢？ Swoole功能特性： 实现 Socket 通信机制的服务器层。用它封装之后可以用于 HTTP WEB开发、游戏开发等工作。 实现 Socket 通信机制的客户端层。用它可以模拟 socket请求，以及模板HTTP客户端请求。 实现了一个比PHP进程管理更先进易用的模块。 异步IO。就是指：类crontab定时器、事件循环、异步文件读取。 内存操作。内存锁、数据共享、数据缓存。实现高并发。 HTTPS Server。通过对 socket 封装实现 http协议的server。无须web server即可以运行。性能出众。 Web Socket。 一、环境依赖 仅支持Linux，FreeBSD，MacOS，3类操作系统 Linux内核版本2.3.32以上 PHP5.3.10以上版本 gcc4.4以上版本或者clang cmake2.4+，编译为libswoole.so作为C/C++库时需要使用cmake 二、安装 Swoole 扩展swoole扩展安装非常简单。最常见的方式是通过到 http://pecl.php.net/ 网站下载。但是，由于swoole社区非常活跃，导致版本迭代非常之快。所以，推荐去swoole官方的github上下载。下载地址：https://github.com/swoole/swoole-src swoole有很多个版本，推荐下载 tags 中版本号最大的那个且是stable的版本。 12345$ wget https://github.com/swoole/swoole-src/archive/swoole-1.7.14-stable.zip$ unzip swoole-1.7.14-stable.zip$ phpize$ make$ make install 修改php.ini。在文件末尾增加以下配置 12[swoole]extension=swoole.so 更多扩展编译参数说明文档：http://wiki.swoole.com/wiki/page/6.html 三、Linux内核调整要想swoole稳定且高性能运行，需要对Linux内核进行调整。 关于内核的调整文档，官方网站说得非常详细：http://wiki.swoole.com/wiki/page/11.html 四、基于swoole的周边项目swoole是一个偏底层的网络框架。基于它可以开发出更多的高级应用框架。 基于swoole的项目：我去 五、示例展示swoole提供了非常完整的示例。需要配合其文档来进行学习理解。 官方示例地址：https://github.com/swoole/swoole-src/tree/swoole-1.7.14-stable/examples 方官文档地址：http://wiki.swoole.com/ 非常官方文档：https://github.com/LinkedDestiny/swoole-doc 注意：建议所有示例在Linux系统下运行。不推荐在windows或Mac系统下运行。 六、swoole 其它 IDE自动提示工具：必须看看 WEB IM :必须看看 swoole成员提示的视频：http://www.tudou.com/home/shenzhe/]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHP面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发符合composer的包]]></title>
    <url>%2F2017%2F12%2F16%2F%E5%BC%80%E5%8F%91%E7%AC%A6%E5%90%88composer%E7%9A%84%E5%8C%85%2F</url>
    <content type="text"><![CDATA[composer工具帮我们很好地管理了PHP依赖包的问题。但是，作为一名PHPer，我们总不能永远只使用别人的开发包。我们骄傲是程序员必须自己动手开发一个包给别人用或自用。 以下我将以github结合composer工具来进行示例讲解。 一、创建一个github项目首先，你得有一个github账号。然后，创建一个github 项目。 1）登录github。点击顶部导航栏的“+”，选择“New repository”。跳转到创建页页。 2）Repository name 我填写的是”utils”。可以填写你想要的名字。Description 是可选的。这是对这个项目的描述。接着下面的选项是让我们填写该项目是“public”还是”private”。选择”public”。接着“Initialize this repository with a README”建议勾选，给我们创建初始化一个项目文档首页。其他选项保持默认即可。根据提示选择即可。 public：所有人都能访问您创建的项目。这也是github推荐的方式。免费。 private：收费。只有指定的人才能访问这个项目。 3）点击“Create Repository”按钮，即可创建成功。 其次，我们要将这个github项目clone到本地。 1）在本地电脑创建一个目录localgit（名字随意）且保证系统中已经安装了git命令。 2）已创建的github项目右下角有一个”HTTPS clone URL”，点击那里的复制按钮把 url 地址复制出来。我的是： https://github.com/winerQin/utils.git 3）在localgit父目录下。执行如下命令： 1$ git clone https://github.com/winerQin/utils.git localgit 此命令会输出如下内容，代表执行成功： 123456Cloning into 'utils'...remote: Counting objects: 4, done.remote: Compressing objects: 100% (4/4), done.remote: Total 4 (delta 0), reused 0 (delta 0), pack-reused 0Unpacking objects: 100% (4/4), done.Checking connectivity... done. 二、创建composer.json用过composer命令安装第三方开发包的人一定对composer.json不陌生。composer.json文件定义了包名、包的描述、作者、授权协议等信息。总之，一个项目要调用这个开发包，通过composer.json可以知道该怎样去加载文件。 因为，我们在本地已经有了一个github项目localgit。进入这个目录。使用composer命令智能化生成composer.json。 1$ composer init 此时，会提示我们输入包名： 1Package name (&lt;vendor&gt;/&lt;name&gt;) [root/localgit]: 输入：winerqin/localgit 并回车确认。注意：不能用大写字母和特殊字符。 因为，我们使用的是github。那么，推荐vendor为小写的用户名。name为仓库名称。 回车之后会提示输入包描述： 1Description []: 这个你自己看着办。我比较懒。直接回车。 这个时候，会提示你输入作者和邮箱。默认是你初始安装git命令时配置的作者和邮箱。 1Author [winerQin &lt;753814253@qq.com&gt;]: 因为，我的就是这个，所以，我直接就回车了。接着会填写最低稳定版本: 1Minimum Stability []: 我直接填写了dev。如果你乱填写，则会提示如下： 1Invalid minimum stability &quot;sdfsd&quot;. Must be empty or one of: stable, RC, beta, alpha, dev 接着： 1License []: 直接回车。 接着: 1Would you like to define your dependencies (require) interactively [yes]? 输入No。 接着： 1Would you like to define your dev dependencies (require-dev) interactively [yes]? 输入No。 接着后面都输入Yes即可。其实，根据英文提示，都知道要干嘛了。 此时，在localgit目录下会生成一个composer.json文件。内容如下： 123456789101112&#123; &quot;name&quot;: &quot;winerqin/localgit&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;authors&quot;: [ &#123; &quot;name&quot;: &quot;winerQin&quot;, &quot;email&quot;: &quot;753814253@qq.com&quot; &#125; ], &quot;minimum-stability&quot;: &quot;dev&quot;, &quot;require&quot;: &#123;&#125;&#125; 其实，这个文件完全可以手工创建，按照这个格式。 三、创建项目内容创建项目内容很简单，按照既定目录结构去创建目录和文件即可。然后，再到composer.json里面修改一下让其知道即可。 一般情况下一个完整的开发包结构如下： – src 源码目录。这个名称按照所有程序员的约定不会更改名称。必不可少的。虽然，可以改为其他名称。但是不推荐。– tests 单元测试目录。此目录不是必须的。一些超高规格的开发者会提供这个目录让便让其他程序员测试协作。 在 src 目录我们创建一个类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338/** * 全局数据验证类。 * @author winerQin */namespace winer;class Validator &#123; /** * 判断是否为合法的用户名。 * @param string $username * @param int $min_len 最小长度。包含。 * @param int $max_len 最大长度。包含。 * @param string $mode 用户名模式：digit、alpha、digit_alpha、chinese、digit_alpha_chinese、mix * digit：数字 * aplha：字母 * digit_alpha：数字和字母 * chinese：中文 * digit_alpha_chinese：数字字母中文 * mix：混合型：数字字母中文下划线破折号 * @return bool */ public static function is_username($username, $min_len, $max_len, $mode = 'mix') &#123; switch ($mode) &#123; case 'digit': return preg_match("/^\d&#123;&#123;$min_len&#125;,&#123;$max_len&#125;&#125;$/", $username) ? true : false; break; case 'alpha': return preg_match("/^([a-zA-Z])&#123;&#123;$min_len&#125;,&#123;$max_len&#125;&#125;$/", $username) ? true : false; break; case 'digit_alpha': return preg_match("/^([a-z0-9_-])&#123;&#123;$min_len&#125;,&#123;$max_len&#125;&#125;$/", $username) ? true : false; break; case 'chinese': return (preg_match("/^[\x7f-\xff]&#123;&#123;$min_len&#125;,&#123;$max_len&#125;&#125;$/", $username)) ? true : false; break; case 'digit_alpha_chinese': return (preg_match("/^[\x7f-\xff|0-9a-zA-Z]&#123;&#123;$min_len&#125;,&#123;$max_len&#125;&#125;$/", $username)) ? true : false; break; case 'mix': default: return (preg_match("/^[\x7f-\xff|0-9a-zA-Z-_]&#123;&#123;$min_len&#125;,&#123;$max_len&#125;&#125;$/", $username)) ? true : false; break; &#125; &#125; /** * 判断是否为合法的密码。 * @param string $password * @param int $min_len 最小长度。包含。 * @param int $max_len 最大长度。包含。 * @param string $mode 用户名模式：digit_alpha、mix * digit_alpha：数字和字母 * mix：混合型：数字字母下划线破折号 * @return bool */ public static function is_password($password, $min_len, $max_len, $mode = 'mix') &#123; switch ($mode) &#123; case 'digit_alpha': return preg_match("/^([a-z0-9])&#123;&#123;$min_len&#125;,&#123;$max_len&#125;&#125;$/", $password) ? true : false; break; case 'mix': default: return (preg_match("/^[0-9a-zA-Z-_]&#123;&#123;$min_len&#125;,&#123;$max_len&#125;&#125;$/", $password)) ? true : false; break; &#125; &#125; /** * 判断是否为QQ号码。 * @param string $qq * @return boolean */ public static function is_qq($qq) &#123; return preg_match('/^[1-9]\d&#123;4,12&#125;$/', $qq) ? true : false; &#125; /** * 判断是否为手机号码。 * @param string $mobilephone * @return boolean */ public static function is_mobilephone($mobilephone) &#123; return preg_match('/^13[\d]&#123;9&#125;$|14^[0-9]\d&#123;8&#125;|^15[0-9]\d&#123;8&#125;$|^18[0-9]\d&#123;8&#125;$/', $mobilephone) ? true : false; &#125; /** * 判断是否为座机号码。 * @param string $telphone * @return boolean */ public static function is_telphone($telphone) &#123; return preg_match('/^((\(\d&#123;2,3&#125;\))|(\d&#123;3&#125;\-))?(\(0\d&#123;2,3&#125;\)|0\d&#123;2,3&#125;-)?[1-9]\d&#123;6,7&#125;(\-\d&#123;1,4&#125;)?$/', $telphone) ? true : false; &#125; /** * 判断是否为邮政编码。 * @param string $zipcode * @return boolean */ public static function is_zipcode($zipcode) &#123; return preg_match('/^[1-9]\d&#123;5&#125;$/', $zipcode) ? true : false; &#125; /** * 判断字母是否在某个区域内。用于判断某个字符只能介于[a-h](包含)之间的类似情况。 * @param string $alpha 原值。 * @param string $start_alpha 起始值。 * @param string $end_alpha 截止值。 * @return boolean */ public static function alpha_between($alpha, $start_alpha, $end_alpha) &#123; if (Validator::is_alpha($alpha) === false) &#123; return false; &#125; if (Validator::is_alpha($start_alpha) === false) &#123; return false; &#125; if (Validator::is_alpha($end_alpha) === false) &#123; return false; &#125; if ($start_alpha &gt;= $end_alpha) &#123; return false; &#125; if ($alpha &lt; $start_alpha) &#123; return false; &#125; if ($alpha &gt; $end_alpha) &#123; return false; &#125; return true; &#125; /** * 判断数字是否在某个区域之间。[2, 10],包含边界值。 * @param int $value 原值。 * @param int $start_value 起始值。 * @param int $end_value 截止值。 * @return boolean */ public static function number_between($value, $start_value, $end_value) &#123; if (is_numeric($value) === false || is_numeric($start_value) === false || is_numeric($end_value) === false) &#123; return false; &#125; if ($start_value &gt;= $end_value) &#123; return false; &#125; if ($value &lt; $start_value) &#123; return false; &#125; if ($value &gt; $end_value) &#123; return false; &#125; return true; &#125; /** * 验证是否为中文。 * @param string $char * @return bool */ public static function is_chinese($char) &#123; if (strlen($char) === 0) &#123; return false; &#125; return (preg_match("/^[\x7f-\xff]+$/", $char)) ? true : false; &#125; /** * 判断是否为字母、数字、下划线（_）、破折号（-）。 * @param string $str * @return boolean */ public static function is_alpha_dash($str) &#123; return preg_match('/^([a-z0-9_-])+$/i', $str) ? true : false; &#125; /** * 验证身份证号码是否合法。 * @param string $vStr * @return bool */ public static function is_idcard($vStr) &#123; $vCity = array( '11','12','13','14','15','21','22', '23','31','32','33','34','35','36', '37','41','42','43','44','45','46', '50','51','52','53','54','61','62', '63','64','65','71','81','82','91' ); if (!preg_match('/^([\d]&#123;17&#125;[xX\d]|[\d]&#123;15&#125;)$/', $vStr)) &#123; return false; &#125; if (!in_array(substr($vStr, 0, 2), $vCity)) &#123; return false; &#125; $vStr = preg_replace('/[xX]$/i', 'a', $vStr); $vLength = strlen($vStr); if ($vLength == 18) &#123; $vBirthday = substr($vStr, 6, 4) . '-' . substr($vStr, 10, 2) . '-' . substr($vStr, 12, 2); &#125; else &#123; $vBirthday = '19' . substr($vStr, 6, 2) . '-' . substr($vStr, 8, 2) . '-' . substr($vStr, 10, 2); &#125; if (date('Y-m-d', strtotime($vBirthday)) != $vBirthday) &#123; return false; &#125; if ($vLength == 18) &#123; $vSum = 0; for ($i = 17 ; $i &gt;= 0 ; $i--) &#123; $vSubStr = substr($vStr, 17 - $i, 1); $vSum += (pow(2, $i) % 11) * (($vSubStr == 'a') ? 10 : intval($vSubStr, 11)); &#125; if($vSum % 11 != 1) &#123; return false; &#125; &#125; return true; &#125; /** * 验证日期时间格式。 * -- 1、验证$value是否为$format格式。 * -- 2、只能验证格式，不能验证时间是否正确。比如：2014-22-22 * @param string $format 格式。格式如：Y-m-d 或H:i:s * @param string $value 日期。 * @return boolean */ public static function is_date_format($format, $value) &#123; return date_create_from_format($format, $value) !== false; &#125; /** * 判断是否为整数。 * @param string $str * @return boolean */ public static function is_integer($str) &#123; return filter_var($str, FILTER_VALIDATE_INT) !== false; &#125; /** * 判断是否为字母数字。 * @param string $str * @return boolean */ public static function is_alpha_number($str) &#123; return preg_match('/^([a-z0-9])+$/i', $str) ? true : false; &#125; /** * 判断是否为字母。 * @param string $str * @return boolean */ public static function is_alpha($str) &#123; return preg_match('/^([a-z])+$/i', $str) ? true : false; &#125; /** * 验证IP是否合法。 * @param string $ip * @return bool */ public static function is_ip($ip) &#123; return filter_var($ip, FILTER_VALIDATE_IP) !== false; &#125; /** * 验证URL是否合法。 * -- 合法的URL：http://www.baidu.com * @param string $url * @return bool */ public static function is_url($url) &#123; return filter_var($url, FILTER_VALIDATE_URL) !== false; &#125; /** * 判断email格式是否正确。 * @param string $email * @return bool */ function is_email($email) &#123; return filter_var($email, FILTER_VALIDATE_EMAIL) !== false; &#125; /** * 是否必需。 * @param string $str * @return bool */ public static function is_require($str) &#123; return strlen($str) ? true : false; &#125; /** * 判断字符串是否为utf8编码，英文和半角字符返回ture。 * @param string $string * @return bool */ public static function is_utf8($string) &#123; return preg_match('%^(?: [\x09\x0A\x0D\x20-\x7E] # ASCII | [\xC2-\xDF][\x80-\xBF] # non-overlong 2-byte | \xE0[\xA0-\xBF][\x80-\xBF] # excluding overlongs | [\xE1-\xEC\xEE\xEF][\x80-\xBF]&#123;2&#125; # straight 3-byte | \xED[\x80-\x9F][\x80-\xBF] # excluding surrogates | \xF0[\x90-\xBF][\x80-\xBF]&#123;2&#125; # planes 1-3 | [\xF1-\xF3][\x80-\xBF]&#123;3&#125; # planes 4-15 | \xF4[\x80-\x8F][\x80-\xBF]&#123;2&#125; # plane 16 )*$%xs', $string) ? true : false; &#125; /** * 检查字符串长度。 * @param string $str 字符串。 * @param int $min 最小长度。 * @param int $max 最大长度。 * @param bool $is_utf8 是否UTF-8字符。 * @return boolean */ public static function len($str, $min = 0, $max = 255, $is_utf8 = false) &#123; $len = $is_utf8 ? mb_strlen($str) : strlen($str); if (($len &gt;= $min) &amp;&amp; ($len &lt;= $max)) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125; 修改composer.json。修改后的内容如下：12345678910111213141516171819&#123; &quot;name&quot;: &quot;winerqin/utils&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;authors&quot;: [ &#123; &quot;name&quot;: &quot;winerQin&quot;, &quot;email&quot;: &quot;753814253@qq.com&quot; &#125; ], &quot;minimum-stability&quot;: &quot;dev&quot;, &quot;require&quot;: &#123; &quot;php&quot;: &quot;&gt;=5.3.0&quot; &#125;, &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;winer\\&quot;: &quot;src/&quot;, &#125; &#125;&#125; 关于 PSR-4规范，请看文档：我去 关于composer.json说明请看此博文：我去 到此，我们的开发包已经搞定。接下来我们测试测试这个包是否可用。 四、测试开发包在localgit目录下，通过composer来安装测试。 123456$ composer installLoading composer repositories with package informationInstalling dependencies (including require-dev)Nothing to install or updateWriting lock fileGenerating autoload files 输出以上信息说明安装成功咯。 在目录下会有一个vendor文件夹。 此时会在vendor/composer/autoload_psr4.php中生成命名空间和目录的映射关系，被包在一个数组中： 12345678910&lt;?php// autoload_psr4.php @generated by Composer$vendorDir = dirname(dirname(__FILE__));$baseDir = dirname($vendorDir);return array( 'winer\\' =&gt; array($baseDir . '/src'),); 如果发布成packagist包然后进行安装的话，到时候这里就不是$baseDir了而是$vendorDir。稍后我们再发布到packagist。 在tests目录创建 ValidatorTest.php，内容如下： 123456789101112&lt;?phprequire '../vendor/autoload.php';use \winer;$mobilephone = '18665027895';$ok = winer\Validator::is_mobilephone($mobilephone);if ($ok) &#123; echo '是手机号码';&#125; else &#123; echo '不是手机号码';&#125; 通过php命令来运行： 1php ValidatorTest.php 输入：1是手机号码 五、发布到packagistpackagist指的是packagist.org。这个网站是composer默认下载开发包的资源引用网站。所以，我们得在此网站注册一个账号。然后添加我们开发包的github项目。 1）将本地代码提交到github。在发布之前，我们要把localgit的代码提交到github上去。 123$ git add .$ git commit -m "composer.json教程代码"$ git push 此时，访问github的utils仓库，发现我们的刚刚提交的代码都已经安静地在里面了。 2）发布g到packagist 请确认已经登录。在packagist.org首页的右上角有一个”Submit Package”按钮。点击即可进入开发包提交的界面。在页面最下方有一个输入框，输入我们github的utils项目地址： https://github.com/winerQin/utils 再点击”Check -&gt;”，经过几秒钟的等待会显示验证成功，并显示出提交的按钮。点击提交即完成了开发包的提交了。 那么，接下来这个开发包就可以在任何支持composer的PHP框架中使用了。恭喜您！！！ 3）让我们的github代码更新能让packagist.org自动更新 登录github。选择代码仓库。我的是utils。然后，右边选择”settings” -&gt; “Webhooks &amp; Services” -&gt; “Add Service” -&gt; 下拉列表中选择 “packagist” -&gt; 根据提示填写packagist账号，以及packagist提供的token。域名填写：http://packagist.org。 就这样，以后更新就会自动更新packagist.org上了。是不是好开心？是的。 超级提示：我们可以模仿已有的第三方包进行开发。 关于git中文文档请看：我去]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHP面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Composer实战指南]]></title>
    <url>%2F2017%2F12%2F15%2FComposer%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[Composer 是 PHP 用来管理依赖（dependency）关系的工具。你可以在自己的项目中声明所依赖的外部工具库（libraries），Composer 会帮你安装这些依赖的库文件。 PHP 开发过程中，难免会使用第三方包或自己的功能吧。那么，很容易出来第三方包之间的包名一样的情况。以及，同一包的不版本与其他包之间的依赖混乱的情况。 其它的语言也有类似的包依赖管理工具：Java有Maven，Python有pip，Ruby有gem，Nodejs有npm。 PHP的则是PEAR，不过PEAR坑不少： 依赖处理容易出问题 配置非常复杂 难用的命令行接口 既然有问题，那一定会有人跳出来解决。于是，Composer就出来了。 运行 Composer 需要 PHP 5.3.2+ 以上版本。一些敏感的 PHP 设置和编译标志也是必须的，但对于任何不兼容项安装程序都会抛出警告。 一、Composer在各平台的安装事实上只要你使用的系统中已经开启或支持Curl命令或将php可执行文件添加到了系统PATH中。那么，安装composer是相当的简单的。 在你的客户端运行如下命令安装 composer。默认安装最新版。 1curl -sS https://getcomposer.org/installer | php 如果你的系统没有curl,则： 1php -r "readfile('https://getcomposer.org/installer');" | php 官方英文安装文档：https://getcomposer.org/download/ 二、一些常用的 Composer 命令假定你已经有一个新项目对应的文件夹名称是 test 。那么，在 test 项目下你要创建一个composer.json。这样，在之后使用composer.json命令才能成功。 1）安装扩展包以安装 monolog 扩展为例。这个包可以在 packagist.org 搜索得到。可以看到每个包的引入条件。 在composer.json里面增加引入配置，增加之后composer.json文件内容如下： 12345&#123; &quot;require&quot;: &#123; &quot;monolog/monolog&quot;: &quot;1.2.*&quot; &#125;&#125; 这个时候，我们可以在命令行的 test 项目目录下执行如下命令安装它： 1composer install 这个时候在项目根目录下会生成一个 composer.lock 文件，以及一个 vendor 文件夹。在vendor文件夹下有一个 monolog 文件夹，说明我们已经安装成功。 2）更新扩展包更新扩展包，可以一起更新，也可以单独更新某一个包。 1composer update 以上命令会将当前扩展包整体更新。 1composer update monolog/monolog 以上命令只会更新monolog/monolog扩展包。 当修改了 composer.json 文件且已经存在composer.lock文件的时候，使用如下命令并不会更新： 1composer install 必须使用： 1composer update 3）移除扩展包扩展包移动命令会将扩展包在vendor文件夹中彻底删除。命令如下： 1composer remove monolog/monolog 4）包版本号介绍在前面的例子中，我们引入的 monolog 版本指定为 1.0.*。这表示任何从 1.0 开始的开发分支，它将会匹配 1.0.0、1.0.2 或者 1.0.20。 版本约束可以用几个不同的方法来指定。 名称 实例 描述 确切的版本号 1.0.2 你可以指定包的确切版本。 范围 &gt;=1.0 &gt;=1.0,&lt;2.0 &gt;=1.0 通过使用比较操作符可以指定有效的版本范围。 有效的运算符： &gt;、&gt;=、&lt;、&lt;=、!=。 你可以定义多个范围，用逗号隔开，这将被视为一个逻辑AND处理。 AND 的优先级高于 OR。 通配符 1.0.* 你可以使用通配符来指定一种模式。1.0.与&gt;=1.0,&lt;1.1是等效的。 赋值运算符 ~1.2 这对于遵循语义化版本号的项目非常有用。~1.2相当于&gt;=1.2,&lt;2.0。想要了解更多，请阅读下一小节。 下一个重要版本（波浪号运算符）最好用例子来解释： ~1.2 相当于 &gt;=1.2,&lt;2.0，而 ~1.2.3 相当于 &gt;=1.2.3,&lt;1.3。正如你所看到的这对于遵循 语义化版本号 的项目最有用。一个常见的用法是标记你所依赖的最低版本，像 ~1.2 （允许1.2以上的任何版本，但不包括2.0）。由于理论上直到2.0应该都没有向后兼容性问题，所以效果很好。你还会看到它的另一种用法，使用 ~ 指定最低版本，但允许版本号的最后一位数字上升。 注意： 虽然 2.0-beta.1 严格地说是早于 2.0，但是，根据版本约束条件， 例如 ~1.2 却不会安装这个版本。就像前面所讲的 ~1.2 只意味着 .2 部分可以改变，但是 1. 部分是固定的。 5）稳定性默认情况下只有稳定的发行版才会被考虑在内。如果你也想获得 RC、beta、alpha 或 dev 版本，你可以使用 稳定标志。你可以对所有的包做 最小稳定性 设置，而不是每个依赖逐一设置。 稳定性对应 composer.json文件中的 “minimum-stability”: “dev”。 6）composer.lock - 锁文件在安装依赖后，Composer 将把安装时确切的版本号列表写入 composer.lock 文件。这将锁定改项目的特定版本。 请提交你应用程序的 composer.lock （包括 composer.json）到你的版本库中。 这是非常重要的，因为 install 命令将会检查锁文件是否存在，如果存在，它将下载指定的版本（忽略 composer.json 文件中的定义）。 这意味着，任何人建立项目都将下载与指定版本完全相同的依赖。你的持续集成服务器、生产环境、你团队中的其他开发人员、每件事、每个人都使用相同的依赖，从而减轻潜在的错误对部署的影响。即使你独自开发项目，在六个月内重新安装项目时，你也可以放心的继续工作，即使从那时起你的依赖已经发布了许多新的版本。 如果不存在 composer.lock 文件，Composer 将读取 composer.json 并创建锁文件。 这意味着如果你的依赖更新了新的版本，你将不会获得任何更新。此时要更新你的依赖版本请使用 update 命令。这将获取最新匹配的版本（根据你的 composer.json 文件）并将新版本更新进锁文件。 1php composer.phar update 如果只想安装或更新一个依赖，你可以白名单它们： 1php composer.phar update monolog/monolog [...] 注意： 对于库，并不一定建议提交锁文件 请参考：库的锁文件. 更新文档，请参考：http://www.phpcomposer.com/]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHP面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓展篇——Zephir快速入门]]></title>
    <url>%2F2017%2F12%2F07%2F%E6%8B%93%E5%B1%95%E7%AF%87%E2%80%94%E2%80%94Zephir%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[如果你想自己编写PHP扩展，意味着你需要掌握C语言，因为PHP的扩展是通过C编写的，而且你还需要掌握PHP的Zend API，了解它的核心原理 但是最近了解到一个新的技术：Zephir 它可以帮助你使用类PHP的语法，来生成C语言代码，并帮助你编译成PHP扩展。是不是很酷？很酷，有没有？ 根据 Zephir 的作者（出是phalcon的核心成员）的描述：Zephir是一门能使用语法与PHP相同且纯面向对象的编译型语言。它将代码编译为C语言，再生成PHP扩展。 Zephir 有几个特性： 类型可静可动。即支持PHP类似的动态类型、也可以支持类似C语言的静态类型。 减少程序执行时间提升运行性能。毕竟是把代码编译为静态类型的C语言。 采用面向对象OOP编译。 内存安全。即不需要操心内存的管理问题。 预编译器(AOT)提供可预测的性能。 Zephir是开放源代码的项目。代码托管在github：https://github.com/phalcon/zephir 任何语言都有数据类型。Zephir与PHP和C的数据类型高度相关。 类型Zephir 支持动态和静态两种类型。在这一章里,我们强调支持的类型和它的行为: 动态类型与PHP动态变量是完全一样的,它们可以被分配和重新分配不同类型且没有限制。一个动态变量必须用关键字“var”声明,和PHP中的行为几乎是一样的: 12345678910var a, b, c;// Initialize variableslet a = "hello", b = false;// Change their valueslet a = 10, b = "140";// Perform operations between themlet c = a + b; 他们总共有八个数据类型： 类型 描述 boolean 布尔值。 true or false. integer 整数的数字。整数的大小是与平台相关的。 float/double 浮点数。浮动的大小是与平台相关的。 string 一串字符组成的字符串。每个字符一个字节。 array 数组是有序的。 object 对象。与PHP对象一致。 resource 与PHP一致 null 与PHP一致 本节要点： 代码文件组织结构。 命名空间。 语法习惯。 其他概念。 代码文件组织结构与命名空间在PHP中，我们可以将代码放到任何文件中。且代码不局限于特定的形式。在Zephir中，每个文件必须包含一个类且只能有一个类。每个类必须有一个命名空间和目录结构相同。 例如，以下就是一个标准的Zephir组织结构： 1234mylibrary/ router/ exception.zep # MyLibrary\Router\Exception router.zep # MyLibrary\Router MyLibrary\Router 类对应的代码如下： 123456namespace MyLibrary;class Router&#123;&#125; 类MyLibrary/Router/Exception代码如下: 123456namespace MyLibrary\Router;class Exception extends \Exception&#123;&#125; 语句分隔不同语句表达式之间使用分号进行分隔。跟PHP、C/C++、Java一样。例： 1myObject-&gt;myMethod(1, 2, 3); echo "world"; 注释Zephir 支持 C/C++ 风格的注释。如： 12345// this is one line comment/** * multi-line comment */ 在大多数语言中，注释会被编译器/解释器忽略。在 Zephir 中，注释会当作文档并输出到生成的代码中去。所以，它是代码的一部分。 变量声明Zephir,所有的变量在使用前都必须进行声明。编译器会根据提供的重要信息进行优化和验证。变量必须是惟一的标识符,他们不能是保留字。 1234567// 在同一行代码中定义多个变量。var a, b, c;// 在不同行中定义变量。var a;var b;var c; 定义变量的时候，可以给变量一个默认值。您可以为变量设置一个您想要的值。 123//Declaring variables with default valuesvar a = "hello", b = 0, c = 1.0;int d = 50; bool some = true; 变量名是区分大小写的,下面的变量是不同的: 12// Different variablesvar somevalue, someValue, SomeValue; 变量作用域在方法中定义的变量的作用域都是局部的。例： 123456789101112131415161718namespace Test;class MyClass&#123; public function someMethod1() &#123; int a = 1, b = 2; return a + b; &#125; public function someMethod2() &#123; int a = 3, b = 4; return a + b; &#125;&#125; 超全局变量Zephir 不支持全局变量, 访问PHP中的全局变量是不允许的。然而,您可以访问PHP的超全局变量如下: 12345// 从 PHP 的 $_POST 中读取一个值。let price = _POST["price"];// 从 PHP 的 $_SERVER 中读取一个值。let requestMethod = _SERVER["REQUEST_METHOD"]; 译注：在 Zephie的变量是没有PHP的$符号的。所以，就算要调用$_POST或$_SERVER等变量的时候，也不允许有$符号。 本地符号表(Local Symbol Table)在PHP中，每个变量都当前的上下文中都有一个对应的符号表。所以，可以动态地调用或向里面写入值。（对应的PHP术语叫：可变变量）。 12345&lt;?php$b = 100;$a = "b";echo $$a; // prints 100 Zephir没有实现这一功能,因为所有变量都被编译到低级变量，没有办法知道哪些变量存在于一个特定的上下文。如果你想创建一个变量在当前的PHP符号表,您可以使用下面的语法: 123456//Set variable $name in PHPlet &#123;"name"&#125; = "hello";//Set variable $price in PHPlet name = "price";let &#123;name&#125; = 10.2; Zephir 依赖以下库： json-c：C语言JSON库。github地址：https://github.com/phalcon/json-c re2c : PHP语法解析器。官网地址：http://re2c.org/ 环境要求： g++ &gt;= 4.4/clang++ &gt;= 3.x/vc++ 9 gnu make 3.81 or later php development headers and tools 一、安装1）安装依赖re2c：因为，我的是Mac系统，所以。我使用的是如下命令安装： 1brew install re2c 如果你的是centos，那么应该使用如下命令安装： 1yum install re2c 2）安装Zephir创建一个文件夹 zephir_test(名字随意)，然后，我们使用composer安装： 123456$ composer require phalcon/zephir$ cd ./zephir_test/vendor/phalcon/zephir$ git clone https://github.com/json-c/json-c.git$ ./install-json$ ./install -c$ ./zephir_test/vendor/phalcon/zephir/bin/zephir compile 通过以上步骤就算安装好了。测试安装是否成功： 12$ cd ./zephir_test/vendor/phalcon/zephir/bin$ ./zephir 如果没有报错，说明就安装成功了。 3）将 zephir 命令添加到 PATH中1$ vim /etc/profile 在文件末尾增加如下代码： 1export PATH=$PATH:/Users/qlj/codespace/phpcode/zephir_test/vendor/phalcon/zephir/bin 激活使其生效： 1$ source /etc/profile 二、创建第一个Zephir扩展通过 Zephir 命令创建： 123$ zephir init wlib$ cd wlib/wlib$ vim greeting.zep 增加如下代码： 123456789namespace Wlib;class Greeting&#123; public static function say() &#123; echo "hello world!"; &#125;&#125; greeting.zep路径为wlib/wlib/greeting.zep。 则需要在greeting.zep上一级目录下执行如下命令编译： 1$ zephir build 输入如下内容则编译成功： 12345Compiling...Installing...Password:Extension installed!Don&apos;t forget to restart your web server 这个时候，就已经生成了so文件。则只需要在php.ini末尾增加如下内容： 12[wlib]extension=wlib.so 测试代码： 1$ vim test.php 增加如下代码： 12&lt;?phpecho Wlib\Greeting::say(), "\n"; 执行输出如下内容： 1$ php test.php 输出： 1hello world!]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHP面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yaf框架学习指南]]></title>
    <url>%2F2017%2F12%2F03%2FYaf%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[说起PHP框架，很多人的印象都停留在一个由PHP实现的基于MVC的各种功能组合的代码包。极少有人知道C语言也能写PHP框架，并且速度比PHP写的框架快上10倍以上。 Yaf是一款以C语言写的PHP框架。它以PHP扩展的方式运行框架。只实现了MVC最核心部分的功能：路由、MVC。 Yaf框架的最大用户当属新浪和百度。大家经常上的微博每一个页面基本上都是经过Yaf框架的手到达你的眼前。 我们用过很多PHP扩展。比如非常热门且实用的memcache扩展、PDO扩展等。所以，对于像Yaf这样的扩展也不会显得特别陌生。 Yaf可以说是国内非常著名PHP的C语言扩展。对么国外有没有这种同类似的扩展呢？答案是：有！它的名字叫：phalcon。它有一个被程序员戏谑的称呼：尔康。 那么，关于Yaf与Phalcon谁更优秀呢？我们现在就来一起对比一下吧。 1）Yaf的优点： 用C语言开发的PHP框架, 相比原生的PHP, 几乎不会带来额外的性能开销. 所有的框架类, 不需要编译, 在PHP启动的时候加载, 并常驻内存. 更短的内存周转周期, 提高内存利用率, 降低内存占用率. 灵巧的自动加载. 支持全局和局部两种加载规则, 方便类库共享. 高性能的视图引擎. 高度灵活可扩展的框架, 支持自定义视图引擎, 支持插件, 支持自定义路由等等. 内建多种路由, 可以兼容目前常见的各种路由协议. 强大而又高度灵活的配置文件支持. 并支持缓存配置文件, 避免复杂的配置结构带来的性能损失. 在框架本身,对危险的操作习惯做了禁止. 更快的执行速度, 更少的内存占用. 除了以上框架本身的优点。Yaf还具备稳定、用户基数大等特点。 2）phalcon的优点： 用户C语言开发的PHP框架。性能与Yaf接近，相差5%左右。 内存使用较低。与Yaf相当。 维护团队强大。Yaf目前只有惠新宸一个人在维护。而Phalcon有几十人在维护。 全栈式。Phalcon实现了DB、Cookie、Session、安全、日志等WEB 2.0功能的封装。 文档齐全。 这两款框架各有各的优势。 Yaf内核够精简稳定，所以，几乎不会遇到运行上的问题。风险可控，性能优异。当然，因为简单，所以，你需要实现DB的封闭、Session的扩展等操作。 Phalcon框架由于走的是用C语言实现全栈式的框架。所以，一旦某个模块不稳定或者有BUG。将给调度和维护带来极大的挑战。但是，由于它封装的功能非常完善，所以，我们基本上可以做到开包即用。不用再重复去制造轮子。 Yaf 框架中文文档：http://www.laruence.com/manual/ Phalcon框架中文文档：http://docs.phalconphp.com/zh/ OK！咱们现在开始安装Yaf框架吧！ 一、安装Yaf框架。Yaf扩展主页:http://pecl.php.net/package/yaf 123456$ wget http://pecl.php.net/get/yaf-2.2.9.tgz$ tar -zxvf yaf-2.2.9.tgz$ cd yaf-2.2.9$ phpize$ make $ make install 编译生成扩展之后，修改php.ini。在php.ini文件末尾增加如下配置： 123456[yaf]yaf.use_namespace = 1yaf.environ = 'product'yaf.cache_config = 0yaf.name_suffix = 1yaf.lowcase_path = 1 配置说明： yaf.user_namespace 为1是开启命名空间模式。0关闭。 yaf.environ 是默认情况下Yaf读取的环境配置是什么。 yaf.cache_config 是否缓存项目配置。 yaf.name_suffix 开启后缀。即为1之后，类名将以XxxModel.php、XxxController.php模式加载。 yaf.lowcase_path 路径信息中的目录部分都会被转换成小写。 二、创建第一个Yaf项目有两种方式创建Yaf项目。 手工创建目录。 使用Yaf提供的命令生成项目目录。 因为 Yaf 提供的命令工具没有随 Yaf 源码一起。所以，要单独下载。下载地址：https://github.com/laruence/php-yaf 在该项目下面有一个tools文件夹，里面就是命令行工具。当然，由于 Yaf项目结构本身非常之简单。所以，我也懒得去这样整。特麻烦。话说程序员都是懒鬼？ 一个经典的Yaf项目目录结构如下：123456789101112131415161718+ public |- index.php //入口文件 |- .htaccess //重写规则 |+ css |+ img |+ js+ conf |- application.ini //配置文件 + application |+ controllers |- Index.php //默认控制器 |+ views |+ index //控制器 |- index.phtml //默认视图 |+ modules //其他模块 |+ library //本地类库 |+ models //model目录 |+ plugins //插件目录 入口文件代码如下：1234&lt;?phpdefine("APP_PATH", realpath(dirname(__FILE__) . '/../')); /* 指向public的上一级 */$app = new Yaf_Application(APP_PATH . "/conf/application.ini");$app-&gt;run(); Apache之.htaccess1234#.htaccess, 当然也可以写在httpd.confRewriteEngine OnRewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteRule .* index.php Nginx之Rewrite12345678910server &#123; listen ****; server_name domain.com; root document_root; index index.php index.html index.htm; if (!-e $request_filename) &#123; rewrite ^/(.*) /index.php/$1 last; &#125;&#125; 配置文件在Yaf中, 配置文件支持继承, 支持分节. 并对PHP的常量进行支持. 你不用担心配置文件太大造成解析性能问题, 因为Yaf会在第一个运行的时候载入配置文件, 把格式化后的内容保持在内存中. 直到配置文件有了修改, 才会再次载入. 一个简单的配置文件application/conf/application.ini 123[product];支持直接写PHP中的已定义常量application.directory=APP_PATH &quot;/application/&quot; 控制器 在Yaf中, 默认的模块/控制器/动作, 都是以Index命名的, 当然,这是可通过配置文件修改的.对于默认模块, 控制器的目录是在application目录下的controllers目录下, Action的命名规则是”名字+Action” 默认控制器application/controllers/Index.php 1234567&lt;?phpclass IndexController extends Yaf_Controller_Abstract &#123; public function indexAction() &#123;//默认Action $this-&gt;getView()-&gt;assign("content", "Hello World"); &#125;&#125;?&gt; 视图文件 Yaf支持简单的视图引擎, 并且支持用户自定义自己的视图引擎, 比如Smarty.对于默认模块, 视图文件的路径是在application目录下的views目录中以小写的action名的目录中. 一个默认Action的视图application/views/index/index.phtml 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php echo $content;?&gt; &lt;/body&gt;&lt;/html&gt; 运行在浏览器输入 1http://www.yourhostname.com/application/index.php 不出意外应该可以看到：Heoole World。 三、其他看文档吧。文档还是蛮完整的。http://www.laruence.com/manual/]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHP面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Phalcon框架学习记录]]></title>
    <url>%2F2017%2F12%2F01%2FPhalcon%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Phalcon是一个用C扩展写的PHP WEB框架。具备高性能和低资源消耗的特点。 一、安装 Phalcon 框架官方提供的安装文档地址：http://phalconphp.com/en/download 以下为Mac系统安装流程（其实安装都差不多）： 123git clone git://github.com/phalcon/cphalcon.gitcd cphalcon/buildsudo ./install 在php.ini文件末尾中增加以下内容： 1extension=phalcon.so 重启webserver服务器，通过phpinfo()可以看到phalcon扩展已经成功加载。 二、Phalcon 辅助工具我们接下来使用 composer 工具安装辅助工具。请确保您已经在系统中安装了composer。 创建一个目录，在目录下创建一个composer.json文件： 12345&#123; &quot;require&quot;: &#123; &quot;phalcon/devtools&quot;: &quot;dev-master&quot; &#125;&#125; 运行 composer 安装器： 1composer install 给phalcon.php创建symbolic link: 12ln -s ~/devtools/phalcon.php /usr/bin/phalconchmod ugo+x /usr/bin/phalcon 三、创建第一个Phalcon框架在你想要创建项目的目录下，执行如下命令： 1$ phalcon create-project first_phalcon 将会生成如下目录结构： 1234567891011121314151617181920212223├── app│ ├── cache│ ├── config│ │ ├── config.php│ │ ├── loader.php│ │ └── services.php│ ├── controllers│ │ ├── ControllerBase.php│ │ └── IndexController.php│ ├── models│ └── views│ ├── index│ │ └── index.volt│ ├── index.volt│ └── layouts├── index.html└── public ├── css ├── files ├── img ├── index.php ├── js └── temp 将public指向为允许访问的入口文件夹并访问即可。 推荐 Phalcon 源码托管地址：https://github.com/phalcon/cphalcon 中文文档地址：http://docs.phalconphp.com/zh/latest/index.html API文档地址：http://docs.phalconphp.com/zh/latest/api/ windows DLL : http://phalconphp.com/en/download/windows]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHP面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——Swift 4.0 适配实战总结（Xcode9）]]></title>
    <url>%2F2017%2F11%2F27%2FiOS%E2%80%94%E2%80%94Swift-4-0-%E9%80%82%E9%85%8D%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93%EF%BC%88Xcode9%EF%BC%89%2F</url>
    <content type="text"><![CDATA[iOS的小伙伴有没有觉得今年特别与众不同，是因为iPhone X出来了吗？是的，但是不仅仅是因为iPhone X的面世。 还有 Xcode 9无线调试，Swift 4升级适配，iPhone X适配，前面介绍了iPhone X适配总结，这里整理一下Swift 4.0升级与适配处理….. 前言ios开发中，适配越来越多了： Xcode适配 Swift升级适配 iPhone适配 其中Xcode没有太多东西可说，最重要的是iPhone适配，尤其是最新的iPhone X的适配。 iPhone X的适配之前有整理过一篇文章根据实际进行总结iPhone X适配实战总结， 这里主要介绍一下最新版Swift 4适配，并简单的说一下关于Xcode9特性与适配的问题 关于Swift新特性可以参考这里：http://www.jianshu.com/p/f35514ae9c1a Xcode 9 中同时集成了 Swift 3.2 和 Swift 4。 Swift 3.2 完全兼容 Swift 3.1，并会在过时的语法或函数上报告警告。 Swift 3.2 具有 Swift 4 的一些写法，但是性能不如 Swift 4。 Swift 3.2 和 Swift 4 可以混合编译，可以指定一部分模块用 Swift 3.2 编译，一部分用 Swift 4 编译。 迁移到 Swift 4 后能获得 Swift 4 所有的新特性，并且性能比 Swift 3.2 好。 当 Xcode 正式版发布后，现有的 Swift 代码可以直接升级到 Swift 3.2 而不用做任何改动，也可以后续再迁移到 Swift 4。或者直接迁移到 Swift 4 也可以，Swift 4 相比 Swift 3 的 API 变化还是不大的，很多第三方库都可以直接用 Swift 4 编译。Swift 1 到 2 和 Swift 2 到 3 的迁移的痛苦在 3 到 4 的迁移上已经大大改善了。 适配关于Swift 4适配中OC与Swift混编的坑比较多 查看当前版本 当前环境 Mac OS 10.12.6 XCode 9.1 当前Swift版本 3.2 一键升级这一特性非常6，印象中是swift2的时候出来的，具体时间也忘了。 然后勾选需要转换的 target （pod 引用不用勾选），Next 然后选择转换选项，Next 这两个选项是关于 swift 的 @objc 推断特性的，如果使用了 swift4.0 显式的 @objc 属性，能减少整体代码的大小。此时我们选 Minimize Inference（recommend） Minimize Inference（recommend） 根据静态推断，仅在需要的地方添加@objc属性。使用此选项后，需要按照Completing a Swift 4 minimize inference migration来完成转换。 Match Swift 3 Behavior 在编译器隐式推断的任何地方向代码添加一个@objc属性。这个选项不会改变你的二进制文件的大小，因为被Swift 3隐式推断在所有的地方都添加了显式的@objc属性。 修改错误+细节 完成上面之后，不会发现当前版本确实编程的Swift 4，但是好像跑步起来，到处报错。 对，毕竟是工具，不可能那么人性化，有些地方还是需要人工进行专门的适配 问题一：编译不通过如果项目中之前有class和extension，有些也给OC调用。在OC的代码中，我们通过#import “ModuleName-Swift.h”导入了Swift文件。如果是Swift3.2，一切都能正常工作，但是在Swift4.0上，编译通不过了。 如果你看了Swift 4特性的话应该知道 swift4.0 最大的特性之一就是 @objc 修饰符的变化了，它主要处理 OC 和 swift 混编时一些方法的调用以及属性获取问题，swift4.0 将在 swift3.x 中一些隐式类型推断的特性去除以后，需要我们来手动管理 @objc 修饰符。 具体解决方案： 一：在OC中调用一个Swift4.0类的方法（包括实例方法、static方法、class方法），你需要： 在该Swift4.0类前加上修饰符@objc 该Swift4.0类必须继承NSObject(否则，无法在前面加上修饰符@objc。当然，这里指的是普通类，@objc也是可以修饰UI开头的一系列UIKit框架下的UI类，只是修饰了这些类，不会产生什么影响) 在需要调用的方法前加上修饰符@objc 二：在OC中调用一个Swift4.0扩展的属性（包括实例属性、static属性、class属性）、方法（包括实例方法、static方法、class法），你有如下两种选择方式： 在该Swift4.0扩展前加上修饰符@objc(这样的话，该扩展下的所有的属性、方法，都可被OC调用)。 在需要的属性、方法前直接加上@objc修饰，也可达到目的。 注意一点：swift3 使用 #selector 指定的方法，只有当方法权限为 private 时需要加 @objc 修饰符，swift4.0 都要加 @objc 修饰符swift4.0 不再允许重载 extension 中的方法(包括instance、static、class方法) 问题二：运行时找不到属性如果你有一个Swift类继承自UIViewController，OC中调用或者操作这个类[viewController valueForKey:@”userName”]这一KVC方法去获取这个自定义UIViewController中的iconURL这一属性的属性值。 这种方式，编译时是无法检查出问题的。但是在运行时，问题就来了，找不到这个属性。因为这个属性没有暴露给OC来进行调用。 解决方案： 仅需要在自定义的UIViewController类中给需要暴露给OC调用的属性前加上@objc修饰符便可。如此一来，在OC代码中就能访问到这个属性。 (注意：这里可不像上面提到的extension一样，在这个已定义的UIViewController类前面加上@objc修饰符没有任何意义)。 编译警告 swift 中编译的警告 “#selector” 参数指定的实例方法必须使用 @objc 修饰，因为swift4中弃用了 @objc属性推断。 Objective-C 编译时警告 在 OC 中调用的 swift 方法，在 swift 中需要追加 @objc 修饰，swift4 废弃了该类型推断。 关于编译时也是直接增加@objc即可运行时警告运行时警告会打印在控制台： ***Swift runtime: ClassName.swift:lineInFile:columnInLine: entrypoint -[ClassName methodName] generated by implicit @objc inference is deprecated and will be removed in Swift 4; add explicit @objc to the declaration to emit the Objective-C entrypoint in Swift 4 and suppress this message 同样：想要修复运行时警告，需要添加 @objc 修饰符到对应的方法或者符号。 运行时警告的常见原因: 在 OC 中使用 SEL 在 swift 中使用了 perform methods 在 OC 中使用了 performSelector methods 使用了 @IBOutlet 或者 @IBAction NSAttributedStringKeyswift3.x public init(string str: String, attributes attrs: [AnyHashable : Any]? = nil) swift4.0 public init(string str: String, attributes attrs: [NSAttributedStringKey : Any]? = nil) String废弃charactersswift 3 var count = string.characters.count error &apos;characters&apos; is deprecated: Please use String or Substring directly swift 4 count = string.count 废弃addingPercentEscapesswift 3 var url = @&quot;http://www.example.com?username=姓名&quot; url = url.addingPercentEscapes(using: String.Encoding.utf8)! error &apos;addingPercentEscapes(using:)&apos; is unavailable: Use addingPercentEncoding(withAllowedCharacters:) instead, which always uses the recommended UTF-8 encoding, and which encodes for a specific URL component or subcomponent since each URL component or subcomponent has different rules for what characters are valid. swift 4 uri = uri.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlQueryAllowed)! 废弃substring(to:)swift 3 let index = tagText.index(tagText.startIndex, offsetBy: MPMultipleStyleListItemTagMaxLength) // 警告：&apos;substring(to:)&apos; is deprecated: Please use String slicing subscript with a &apos;partial range upto&apos; operator. let b = tagText.substring(to: index) Swift 4 let a = tagText.prefix(upTo: index) //a 的类型是 Substring，不是 String pod 引用添加以下内容到 Podfile。 post_install do |installer| installer.pods_project.targets.each do |target| if [&apos;WTCarouselFlowLayout&apos;, &apos;XSLRevenue&apos;, &apos;OHHTTPStubs/Swift&apos;].include? target.name target.build_configurations.each do |config| config.build_settings[&apos;SWIFT_VERSION&apos;] = &apos;3.2&apos; end end end end 系统方法UITableViewDelegate 协议方法名变更，没有错误提示： // swift3.x func tableView(_ tableView: UITableView, heightForRowAtIndexPath indexPath: IndexPath) -&gt; CGFloat // swift4.0 func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat Xcode 9关于Xcode 9适配其实并没有太多可说的地方，具体可参考苹果官方Session,但是我相信有一点是很多开发都非常喜欢的特性：无线调试 好处： 不用经常买线，不用担心接口或者插口坏了 不用担心忘记带线，无法调试 不用每次都插着才能调试（嘿，测试的MM，我给你装个最新的包，你接好了） … 要求 必须是Xcode9-beta以上 iPhone系统需iOS11以上 操作 在Xcode9-beta菜单的Window选项中选择Devices and Simulators 通过连接线让你的Mac识别到你的iPhone 在Devices and Simulators面板的左侧Connected菜单中选择连接的设备 在顶部的Devices和Simulators选项中选择Devices(这里其实默认就是选择了Devices)， 勾选Connect via network选项。 关于Xcode无线调试可参考下面地址 WWDC17惊喜——Xcode9无线调试https://icocos.github.io/2017/06/13/WWDC17%E6%83%8A%E5%96%9C%E2%80%94%E2%80%94Xcode9%E6%97%A0%E7%BA%BF%E8%B0%83%E8%AF%95/ 总结Swift3.2到Swift4.0的改变(只是我项目中遇到的)： Swift4.0中对于扩展的属性(包括实例属性、static属性、class属性)，都只能使用get方法，不可使用set方法 Swift4.0中不再允许复写扩展中的方法(包括实例方法、static方法、class方法) 编译期与运行时警告处理，添加 @objc 修饰符到对应的方法或者符号。 swift3使用#selector指定的方法，只有当方法权限为private时需要加@objc修饰符，现在全都要加@objc修饰符 字体方面的一些重命名 NSFontAttributeName重命名为NSAttributedStringKey.font、 NSForegroundColorAttributeName重命名为NSAttributedStringKey.foregroundColor、 NSStrikethroughStyleAttributeName重命名为NSAttributedStringKey.strikethroughStyle、 size(withAttributes:)方法重命名为size(withAttributes:)) … 官方参考资料 《Swift Language Programming (Swift 4.0)》 WWDC 2017 Session 402 《What’s New in Swift》 WWDC 2017 Session 212 《What’s New in Foundation》 WWDC 2017 Session 102 《Platforms State of the Union》]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS——Swift 4.0 适配实战总结（Xcode9）</tag>
        <tag>Swift 4.0 适配实战总结（Xcode9）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——iPhone X适配实战总结]]></title>
    <url>%2F2017%2F11%2F18%2FiOS%E2%80%94%E2%80%94iPhone-X%E9%80%82%E9%85%8D%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近公司项目需要开始适配iPhone X了，之前在网上看到过很多讲解iPhone X适配的文章，也刷过几篇文章看了一遍，但是看完之后实在受不了各种假帖。甚至讲的都是一些理论和差异上的东西，真正讲解实际开发中适配iPhone的并没有多少，有些看完正片文章之后都不知道怎么开始。 于是自己去根据官方提供的资料和指南写一篇只针对iPhone X适配的贴子…… 前言： 本文从实际开发着手iPhone X适配，关于相关理论与常识内容不会过多解释。 本文会分析iPhone X适配的几个不同方向和相关的处理方案 本文会分析并总结适配和测试过程中遇到的Bug，最终给出实际的适配方案或者代码 本文会尽量多的从实际项目与实际适配步骤会代码进行介绍 官方资料HIG-Human Interface Guideline官方Session 首先我们要明确一点：iPhone X适配的宗旨：我们要做的是让那些不能被遮挡的内容和控件在安全区域范围内显示,一.iPhone X的规则| | | iPhone X是真正的3x标准，印象中7p是2.88x iPhone X宽度和4.7的6，7，8一致（375），高度多出145pt（+20%） iPhone X的比例是9：19.5，而4.7的6，7，8比例是9：16， iPhone X（375812-&gt;11252436-&gt;5.8英寸）Super Retina 状态栏20-&gt;44(留海H=30，W=209,耳朵W=83)，底脚0-&gt;34 实际上可有效利用的高度为：145 – 24 (Status Bar) – 34 (Home Indicator) = 87pt 键盘高度由 216pt 增长为 291pt，设计文字区域时要小心 Home Indicator，Tab Bar 高度由 49pt 增长为 83pt 横屏时Home Indicator的高度为21pt，需要格外注意 | | | iPhone X竖屏时占满整个屏幕的控制器的view的safeAreaInsets是（44，0，34，0），横屏是（0，44，21，44），inset后的区域正好是safeAreaLayoutGuide区域 如果你的 UI「顶部」有 Navigation Bar 或其它类似的UI控件，那么一般来说，在设计稿将 Navigation Bar 的背景色往上延伸 44pt，「垫在 Status Bar 后方」作为背景色即可如果你的 UI「底部」有 Tab Bar、Toolbar 或其它类似的UI控件，在设计稿时将背景色往下延伸 34pt，「垫在 Home Indicator 后方」作为背景色即可。 二： iOS11相关 如果只是设置了titleView，没有设置barbutton，把titleview的宽度设置为屏幕宽度，则titleview距离屏幕的边距，iOS11之前，在iPhone6p上是20p，在iPhone6p之前是16p；iOS11之后，在iPhone6p上是12p，在iPhone6p之前是8p。 如果只是设置了barbutton，没有设置titleview，则在iOS11里，barButton距离屏幕的边距是20p和16p；在iOS11之前，barButton距离屏幕的边距也是20p和16p。 如果同时设置了titleView和barButton，则在iOS11之前，titleview和barbutton之间的间距是6p，在iOS11上titleview和barbutton之间无间距 estimatedRowHeight是一个预估高度，iOS11之前是为0，在iOS11下，这个值默认为44。 iOS11以前,我们布局时, 视图的 top 和 bottom 一般参照的是 Top Layout Guide 和 Bottom Layout Guide iOS11为UIViewController和UIView增加了两个新的属性safeAreaInsets和safeAreaLayoutGuide, 通过这两个属性我们可以获得安全区域的范围 safeAreaInsets 适用于手动计算. safeAreaLayoutGuide 适用于自动布局. 三. iPhone环境判断 通过分辨率判断：#define kDevice_Is_iPhoneX ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(1125, 2436), [[UIScreen mainScreen] currentMode].size) : NO) 通过设备名称判断：@&quot;iPhone10,1&quot; : @&quot;iPhone 8&quot;, @&quot;iPhone10,4&quot; : @&quot;iPhone 8&quot;, @&quot;iPhone10,2&quot; : @&quot;iPhone 8 Plus&quot;, @&quot;iPhone10,5&quot; : @&quot;iPhone 8 Plus&quot;, @&quot;iPhone10,3&quot; : @&quot;iPhone X&quot;, @&quot;iPhone10,6&quot; : @&quot;iPhone X&quot;, 判断状态栏的高度（如果状态栏没有隐藏，且竖屏的情况） 判断屏幕的高度或者宽度（横屏的时候） 根据是否可执行或者获取对应API的值（safeAreaInseret） 根据系统框架 常用宏定义#define IS_IPHONE_X_HEIGHT ([[UIScreen mainScreen] bounds].size.height &gt;= 812.0f ? 812.0f : 667.0f) #define ScaleWidth(width) width/ 375.0*KSCREEN_WIDTH #define ScaleHeigth(height) height/IS_IPHONE_X_HEIGHT*KSCREEN_HEIGHT #define WKSW(width) width/375.0*KSCREEN_WIDTH #define WKSH(height) height/IS_IPHONE_X_HEIGHT*KSCREEN_HEIGHT #define SafeAreaTopHeight (kWJScreenHeight == 812.0 ? 88 : 64) #define VIEWSAFEAREAINSETS(view) ({UIEdgeInsets i; if(@available(iOS 11.0, *)) {i = view.safeAreaInsets;} else {i = UIEdgeInsetsZero;} i;}) VIEWSAFEAREAINSETS(view).left VIEWSAFEAREAINSETS(self.view).right 四.启动页的适配启动页的启动方式 LaunchScreen(这里直接设置图片就可以) LaunchImage 使用对应的设计图片：1125 * 2436 如果使用的是Assets中的LaunchImage, 在增加了iPhone X尺寸的图片配置.准备一张尺寸:1125 * 2436的启动图片, 移动到LaunchImage的Finder目录中, 并在LaunchImage中的Contents.json文件中增加 (注意Json格式): { &quot;extent&quot; : &quot;full-screen&quot;, &quot;idiom&quot; : &quot;iphone&quot;, &quot;subtype&quot; : &quot;2436h&quot;, &quot;filename&quot; : &quot;图片名.png&quot;, &quot;minimum-system-version&quot; : &quot;11.0&quot;, &quot;orientation&quot; : &quot;portrait&quot;, &quot;scale&quot; : &quot;3x&quot; } 五.刷新框架的适配iOS11这里拿最有名的刷新框架,如果使用的类似的刷新框架并且隐藏导航那么你或许会遇到：刷新控件和留海重合且被挡住 具体原因：iOS 11上面废除了automaticallyAdjustsScrollViewInsets，使用contentInsetAdjustmentBehavior代替 适配具体代码： if (@available(iOS 11.0, *)) { self.home_collectionView.contentInsetAdjustmentBehavior = UIApplicationBackgroundFetchIntervalNever; } else { self.automaticallyAdjustsScrollViewInsets = false; // Fallback on earlier versions } 宏定义：/// 第一个参数是当下的控制器适配iOS11 一下的，第二个参数表示scrollview或子类 #define AdjustsScrollViewInsetNever(controller,view) if(@available(iOS 11.0, *)) { view.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever; } else if([controller isKindOfClass:[UIViewController class]]) { controller.automaticallyAdjustsScrollViewInsets = false; } 六：导航栏在iOS11导航栏多了一个LargeTitleView，专门显示大字标题用的，整个导航栏的高度达到了96p，这不包括状态栏的高度，也就是说，整个app顶部高度达到了116p，其中statusbar=20，title=44，largetitle=52，不过默认是64p； 当然，iPhoneX的高度会更高点，如果不显示大字标题，顶部的高度也达到了88，statusbar=44，title=44，如果显示大字标题，则高度变成了140，statusbar=44，title=44，largetitle=52，也就是说，iPhoneX的刘海高度为24p， 七：导航栏按钮间距变化(UIBarButtonItem) (iPhoneX &amp; iOS 11)iOS11以后，导航栏的层级发生了变化，也无法时使导航栏左右按钮边距为0了 iOS11之前导航栏的title是添加在UINavigationItemView上面，而navigationBarButton则直接添加在UINavigationBar上面，如果设置了titleView，则titleView也是直接添加在UINavigationBar上面。iOS11之后，大概因为largeTitle的原因，视图层级发生了变化，如果没有给titleView赋值，则titleView会直接添加在_UINavigationBarContentView上面，如果赋值了titleView，则会把titleView添加在_UITAMICAdaptorView上，而navigationBarButton被加在了_UIButtonBarStackView上，然后他们都被加在了_UINavigationBarContentView上 所以如果你的项目是自定义的navigationBar，那么在iOS11上运行就可能出现布局错乱的bug，解决办法是重写UINavigationBar的layoutSubviews方法，调整布局，上代码： - (void)layoutSubviews { [super layoutSubviews]; //注意导航栏及状态栏高度适配 self.frame = CGRectMake(0, 0, CGRectGetWidth(self.frame), naviBarHeight); for (UIView *view in self.subviews) { if([NSStringFromClass([view class]) containsString:@&quot;Background&quot;]) { view.frame = self.bounds; } else if ([NSStringFromClass([view class]) containsString:@&quot;ContentView&quot;]) { CGRect frame = view.frame; frame.origin.y = statusBarHeight; frame.size.height = self.bounds.size.height - frame.origin.y; view.frame = frame; } } } 看了简书App适配iOS11发现titleView支持autolayout，这要求titleView必须是能够自撑开的或实现了- intrinsicContentSize方法 - (CGSize)intrinsicContentSize { return UILayoutFittingExpandedSize; } 导航栏新增了一种大标题样式，默认设置是不开启，所以不需要修改。 titleView支持autolayout，这要求titleView必须是能够自撑开的或实现了- intrinsicContentSize， App需要实现导航栏左右按钮边距为0 八：继承自UIScrollView的视图偏移问题在iOS11设备上运行出现最多问题应该就是tableview莫名奇妙的偏移20pt或者64pt了。。原因是iOS11弃用了automaticallyAdjustsScrollViewInsets属性（前面有提到），取而代之的是UIScrollView新增了contentInsetAdjustmentBehavior属性，这一切的罪魁祸首都是新引入的safeArea， 原因分析 原因是iOS 11中Controller的automaticallyAdjustsScrollViewInsets属性被废弃了，所以当tableView超出安全区域时系统自动调整了SafeAreaInsets值，进而影响adjustedContentInset值，在iOS 11中决定tableView的内容与边缘距离的是adjustedContentInset属性，而不是contentInset。adjustedContentInset的计算方式见本文第二部分内容。因为系统对adjustedContentInset值进行了调整，所以导致tableView的内容到边缘的距离发生了变化，导致tableView下移了20pt（statusbar高度）或64pt（navigationbar高度）。 如果你的APP中使用的是自定义的navigationbar，隐藏掉系统的navigationbar，并且tableView的frame为(0,0,SCREEN_WIDTH, SCREEN_HEIGHT)开始，那么系统会自动调整SafeAreaInsets值为(20,0,0,0)，如果使用了系统的navigationbar，那么SafeAreaInsets值为(64,0,0,0)，如果也使用了系统的tabbar，那么SafeAreaInsets值为(64,0,49,0) if (@available(iOS 11.0, *)) { self.tableView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever; } else { self.automaticallyAdjustsScrollViewInsets = NO; } 这个问题的解决方法有哪些？ 重新设置tableView的contentInset值，来抵消掉SafeAreaInset值，因为内容下移偏移量 = contentInset + SafeAreaInset； 如果之前自己设置了contentInset值为(64,0,0,0),现在系统又设置了SafeAreaInsets值为(64,0,0,0)，那么tableView内容下移了64pt，这种情况下，可以设置contentInset值为(0,0,0,0)，也就是遵从系统的设置了。 设置tableView的contentInsetAdjustmentBehavior属性 如果不需要系统为你设置边缘距离，可以做以下设置： //如果iOS的系统是11.0，会有这样一个宏定义“#define __IPHONE_11_0 110000”；如果系统版本低于11.0则没有这个宏定义 #ifdef __IPHONE_11_0 if ([tableView respondsToSelector:@selector(setContentInsetAdjustmentBehavior:)]) { tableView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever; } #endif contentInsetAdjustmentBehavior属性也是用来取代automaticallyAdjustsScrollViewInsets属性的，推荐使用这种方式。 通过设置iOS 11新增的属性addtionalSafeAreaInset； iOS 11之前，大家是通过将Controller的automaticallyAdjustsScrollViewInsets属性设置为NO，来禁止系统对tableView调整contentInsets的。如果还是想从Controller级别解决问题，那么可以通过设置Controller的additionalSafeAreaInsets属性，如果SafeAreaInset值为(20,0,0,0)，那么设置additionalSafeAreaInsets属性值为(-20,0,0,0)，则SafeAreaInsets不会对adjustedContentInset值产生影响，tableView内容不会显示异常。 这里需要注意的是addtionalSafeAreaInset是Controller的属性，要知道SafeAreaInset的值是由哪个Controller引起的，可能是由自己的Controller调整的，可能是navigationController调整的。是由哪个Controller调整的，则设置哪个Controller的addtionalSafeAreaInset值来抵消掉SafeAreaInset值。 九：UITableView，cell，header，footer高度异常,tableView顶部有留白在iOS 11中默认启用Self-Sizing，，Headers, footers, and cells都默认开启了Self-Sizing，所有estimated 高度默认值从iOS11之前的 0 改变为UITableViewAutomaticDimension要解决此类异常的话，可通过以下代码解决 _tableView.estimatedRowHeight = 0; _tableView.estimatedSectionHeaderHeight = 0; _tableView.estimatedSectionFooterHeight = 0; 这个配合estimatedRowHeight、estimatedSectionFooterHeight、estimatedSectionHeaderHeight使用，可以预估高度。之前，设置header或者footer高度为0时，需要设置height=0.1，才会起作用，如果直接设置为0，则会使用默认高度。iOS11由于自动使用预估高度，所以，忽略了设置的高度，使原来的高度增大了。只要把这几个属性设置为0就可以解决 在iOS11里面有时候在tableView的头部和尾部留白，因为苹果给滚动试图加进去了self-sizeing，开始计算逐步计算contentSize，默认如果不去实现viewForHeaderInSection就不会调用heightForHeaderInSection,尾部试图一样。func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -&gt; UIView? { } func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -&gt; CGFloat { return 0.001 } 如果你不想实现viewForHeaderInSection也不想留白，那么只需要使用上面的三段代码把self-sizeing自动估高关闭即可 如果你使用了Masonry，某些界面需要适配需要适配safeArea，可以试试下面这段代码 if (@available(iOS 11.0, *)) { make.edges.equalTo()(self.view.safeAreaInsets) } else { make.edges.equalTo()(self.view) } 十：适配iOS 11 列表的册数删除在iOS8之后，苹果官方增加了UITableVIew的右滑操作接口，即新增了一个代理方法(tableView: editActionsForRowAtIndexPath:)和一个类(UITableViewRowAction)，代理方法返回的是一个数组，我们可以在这个代理方法中定义所需要的操作按钮(删除、置顶等)，这些按钮的类就是UITableViewRowAction。 这个类只能定义按钮的显示文字、背景色、和按钮事件。并且返回数组的第一个元素在UITableViewCell的最右侧显示，最后一个元素在最左侧显示。从iOS 11开始有了一些改变，首先是可以给这些按钮添加图片了，然后是如果实现了以下两个iOS 11新增的代理方法，将会取代(tableView: editActionsForRowAtIndexPath:)代理方法： 注意：看的有的文章如果在iOS11上面调用老的删除，会崩溃， - (nullable UISwipeActionsConfiguration *)tableView:(UITableView *)tableView leadingSwipeActionsConfigurationForRowAtIndexPath:(NSIndexPath *)indexPath func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? { let action = UIContextualAction(style: .destructive, title: &quot;Delete&quot;) { (action, view, handler) in handler(true) } let configuration = UISwipeActionsConfiguration(actions: [action]) return configuration } func tableView(_ tableView: UITableView, leadingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? { let action = UIContextualAction(style: .normal, title: &quot;Mark&quot;) { (action, view, handler) in handler(true) } action.backgroundColor = UIColor.init(red: 254/255.0, green: 175/255.0, blue: 254/255.0, alpha: 1); let configuration = UISwipeActionsConfiguration(actions: [action]) return configuration } 十一：到底用viewSafeAreaInsetsDidChange还是viewWillLayoutSubviews先来看看下面一段代码，相信做过iPhone X适配的同学应该都不陌生， var safeArea: CGFloat = 0 if #available(iOS 11.0, *) { safeArea += self.view.safeAreaInsets.bottom || UIApplication.shared.keyWindow.rootViewController.view.safeAreaInsets.bottom } coding ... constant || originY || frame || height 有时候，我们会发现这样的一段适配的代码，如果根据苹果的特性，和我们所了解情况，我们一般都会把他放到viewSafeAreaInsetsDidChange，但是，并没有什么卵用，但是根据UI刷新的特性，我试着把他放在viewWillLayoutSubviews，却又正常了，很多人对此很是不解。 首先我们要知道： viewSafeAreaInsetsDidChange调用时机很早，在viewWillAppear后 viewSafeAreaInsetsDidChange后面会调用两次viewDidLayoutSubviews，所以我们应该把改变高度或布局的代码都写在viewDidLayoutSubviews里，这样就不会有多余的动画效果了 注意: viewDidLayoutSubviews可能会由别的操作频繁触发，所以如果调整safeArea布局的代码比较耗时，可以考虑加上一个状态标记，只在didChange后执行一次布局调整 - (void)viewDidLayoutSubviews { [super viewDidLayoutSubviews]; UIEdgeInsets safeAreaInsets = sgm_safeAreaInset(self.view); CGFloat height = 44.0; // 导航栏原本的高度，通常是44.0 height += safeAreaInsets.top &gt; 0 ? safeAreaInsets.top : 20.0; // 20.0是statusbar的高度，这里假设statusbar不消失 if (_navigationbar &amp;&amp; _navigationbar.height != height) { _navigationbar.height = height; } } 十二：纯代码的宽高比适配/// 高度系数 812.0 是iPhoneX的高度尺寸，667.0表示是iPhone 8 的高度，如果你觉的它会变化，那我也很无奈 #define kWJHeightCoefficient (kWJScreenHeight == 812.0 ? 667.0/667.0 : kWJScreenHeight/667.0) | | | 十三：纯代码适配iPhone X脚底首先需要知道一点的是，底部脚底高度是34（tabBar之下所拓张的区域）适配规则： 列表页面不去适配，底部有按钮的界面要适配 viewSafeAreaInsetsDidChange方法里面打印NSLog(@”%@”,NSStringFromUIEdgeInsets(self.view.safeAreaInsets)); 注意： 1.介绍viewSafeAreaInsetsDidChange方法系统调用或者你设置控制器的additionalSafeAreaInsets安全区域边界2.顺序viewSafeAreaInsetsDidChange调用顺序实在viewWillAppear之后，在viewWillLayoutSubvies之前调用 /// 底部宏，吃一见长一智吧，别写数字了 #define SafeAreaBottomHeight (kWJScreenHeight == 812.0 ? 34 : 0) 十四：xib和SB适配安全区域：整个屏幕–导航栏–状态栏–tabbar（自己设定的安全区域除外 xib的适配齐刘海和圆角，如果你们项目要求适配iOS 9一下的，就该一个一个好好拖，如果你们不要求适配iOS 9一下的，只需要给view打开安全区域。 十五：App Store评论跳转问题在iOS11 之后，会跳的Today里面说无法连接到App Store 先来看看我们之前的写法 NSString *appstoreUrlString = [NSString stringWithFormat: @&quot;itms-apps://itunes.apple.com/WebObjects/MZStore.woa/wa/viewContentsUserReviews?type=Purple+Software&amp;id=%@&quot;,AppStoreAppId ]; NSURL * url = [NSURL URLWithString:appstoreUrlString]; if ([[UIApplication sharedApplication] canOpenURL:url]){ [[UIApplication sharedApplication]openURL:url]; }else{ WKLog(@&quot;can not open&quot;); } 到iOS 11后，那样已经没有效果了，要改成: NSString *appstoreUrlString = [NSString stringWithFormat:@&quot;itms-apps://itunes.apple.com/cn/app/idXXXXXX?mt=8&amp;action=write-review&quot;, AppStoreAppId ]; NSURL * url = [NSURL URLWithString:appstoreUrlString]; if ([[UIApplication sharedApplication] canOpenURL:url]){ [[UIApplication sharedApplication]openURL:url]; }else{ WKLog(@&quot;can not open&quot;); } 十六：导航栏设置透明问题本来导航栏设置为不透明，如今却变成了透明(磨砂)模式，要知道导航栏透明与不透明的区别除了视觉差异外还有对屏幕左上角坐标点（0,0）的基准是不一样的。 当导航栏设置为透明模式时—&gt;基准点为手机屏幕最左上角，也就是说如果你在（0,0）点放一个有色label时，你就会发现导航栏是挡住了你的方块的，因为是半透明，你能隐约间看到有色块如果你需要设置导航栏透明度，切记把 self.navigationController.navigationBar.translucent = NO; 写到ViewWillAppear里！ 十七：twitter今天刚发现的一个坑，那就是iOS11设置里并没有集成twitter等第三方应用了 一些系统的关于这些APP的API也申明被废弃了，并推荐使用官网SDK iOS 11 no longer supports using Twitter through the built-in social framework. ]Instead,you can use Twitter Kit 3 to Tweet, log in users, and use the Twitter API. 所以APP里集成twitter分享同学要注意了，一定要检查下twitter分享功能。其它APP分享如Facebook，微博分享功能等应该是完好的。 十八：AppIcon在iOS11上发现了一个奇怪的现象，APP在启动时图标会出现黑边， 原因是iOS11修改了App启动动画，如果你的App图标有圆角那么就会变成这个鸟样了…所有图标都换成直角就好了 十九：相册访问权限iOS11上系统默认打开了用户相册的访问权限，但是当你保存图片时APP就会crash， 原因是需要在info.plist再申明一个NSPhotoLibraryAddUsageDescription的key，同时为了兼容iOS11以前的机型，保留以前NSPhotoLibraryUsageDescription的key 总结：1. 属性总结： self.additionalSafeAreaInsets self.view.safeAreaInsets self.additionalSafeAreaInsets 改变safeAreaInsets的值 self.viewSafeAreaInsetsDidChange() self.view.safeAreaInsetsDidChange()- (void)viewSafeAreaInsetsDidChange在UIViewController中第一次调用的时间是在- (void)viewWillAppear:(BOOL)animated调用之后, 在- (void)viewWillLayoutSubviews调用之前. 当你的viewController改变了它的safeAreaInsets值时，有两种方式获取到回调 self.viewSafeAreaInsetsDidChange()self.view.safeAreaInsetsDidChange() self.view.safeAreaLayoutGuide self.view.safeAreaLayoutGuide UIView的一个只读属性，作为参照物，让view可以相对某个view的safeAreaLayoutGuide做布局，从而保证view能正常、安全地显示（相对的那个view不一定要是父view） 把safeAreaLayoutGuide看成是一个“view”，这个“view”系统自动帮我们调整它的bounds，让它不会被各种奇奇怪怪的东西挡住，包括iPhone X的刘海区域和底部的一道杠区域，可以认为在这个“view”上一定能完整显示所有内容,safeAreaInsets来调整自己的bounds的 self.view.insetsLayoutMarginsFromSafeArea 如果你不想让safeAreaInsets影响你的视图布局，则可以将insetsLayoutMarginsFromSafeArea设置为NO，所有的视图布局将会忽略safeAreaInsets这个属性了。 要注意的是，insetsLayoutMarginsFromSafeArea仅用于AutoLayout，即使该属性为NO，视图的safeAreaInsets还是一样有值，而且安全区域变更方法safeAreaInsetsDidChange一样被调用。 contentInsetAdjustmentBehavior 在iOS11 中, UIViewController的automaticallyAdjustsScrollViewInsets属性已经不再使用,我们需要使用UIScrollView的 contentInsetAdjustmentBehavior 属性来替代它. UIScrollViewContentInsetAdjustmentBehavior 是一个枚举类型,值有以下几种: automatic 和scrollableAxes一样,scrollView会自动计算和适应顶部和底部的内边距并且在scrollView 不可滚动时,也会设置内边距.scrollableAxes 自动计算内边距.never不计算内边距always 根据safeAreaInsets 计算内边距 2. Safe Area 与 Layout Margins一般在做 UI 设计，背景色或较不重要的內容可完整地延伸至屏幕边缘；主要的内容呈现区域 (例如 Table View) 会往内缩 (indent) 一层，称为「Safe Area」；而通常文字或是按钮等更加关键的物件，考虑到美观及操作性，會再内缩一层，称之为「Layout Margins 竖屏时的 Safe Area 可延伸至屏幕左右两侧，上部留 44pt 給 Status Bar；Layout Margins 通常左右再内缩 16pt。 横屏时的 Safe Area 左右两侧皆内缩 44pt；Layout Margins 通常左右再内缩 16pt。 Home IndicatorHome Indicator 为 iPhone X 屏幕下方的一个操控區域，外观是一条粗线 (手把)，由屏幕底部往上滑动可返回主界面 (Home Screen)，或进入多任务管理界面 (App Switcher)。 注意：该“粗线”不可自定义外观，系统会自动判断背景颜色，深色背景时显示浅色 Bar，浅色背景时则显示深色 Bar。 3. Edge Protection如果你的 UI 带有由屏幕底部往上滑动 (Swipe) 的手势，可能会与系统的手势冲突，这时可告诉开发者该 UI界面需要启用「Edge Protection」。启用时，Home Indicator 将会变得较为透明，并下降位置 (但还在)，让全屏体验更为完整。当使用者第一次由下往上滑动时，此手势将保留给你的 App 使用，而不会触发 Home Indicator；当使用者在这时进行第二次滑动，才会触发。 注意：此选项将造成使用者不便，因此当真的有需要时再考虑启用 4. Auto-HideUI 中若是有影片播放等需要降低干扰的情况，需要完全隐藏 Home Indicator，可启用「Auto-Hide」选项，启用时，若是使用者数秒内沒有操纵行为，Home Indicator 将自动隐藏，直到使用者触碰界面才会再度出现。 注意：此选项将造成使用者困惑，因此當真的有需要时再考虑启用。 推荐： 你可能需要为你的 APP 适配 iOS 11 iOS 11 适配集锦 iOS 11新特性与适配 iOS 11更新的内容(开发) APP适配iOS11 WWDC:Updating Your App for iOS 11 PDF版：Updating Your App For iOS 11 iPhoneX人机交互指南(开发&amp;设计师) 官方iPhoneX人机交互指南 中文版iPhoneX人际交互指南 强烈推荐UI 設計師需要知道的 iPhone X 細節]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS——iPhone X适配实战总结</tag>
        <tag>iPhone X适配实战总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL查询优化简介]]></title>
    <url>%2F2017%2F10%2F29%2FSQL%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[在了解MySQL查询优化之前，先来看看关于MySQL的执行流程，因为关于数据层优化来说，归根结底还是关于IO的优化，只有知道了关于MySQL的执行流程，我们才能把优化做的更好 MySQL的流程分析1.连接1. 客户端发起一条Query请求，监听客户端的‘连接管理模块’接收请求 2. 将请求转发到‘连接进/线程模块’ 3. 调用‘用户模块’来进行授权检查 4. 通过检查后，‘连接进/线程模块’从‘线程连接池’中取出空闲的被缓存的连接线程和客户端请求对接，如果失败则创建一个新的连接请求 2.处理1. 先查询缓存，检查Query语句是否完全匹配，接着再检查是否具有权限，都成功则直接取数据返回 2. 上一步有失败则转交给‘命令解析器’，经过词法分析，语法分析后生成解析树 3. 接下来是预处理阶段，处理解析器无法解决的语义，检查权限等，生成新的解析树 4. 再转交给对应的模块处理 5. 如果是SELECT查询还会经由‘查询优化器’做大量的优化，生成执行计划 6. 模块收到请求后，通过‘访问控制模块’检查所连接的用户是否有访问目标表和目标字段的权限 7. 有则调用‘表管理模块’，先是查看table cache中是否存在，有则直接对应的表和获取锁，否则重新打开表文件 8. 根据表的meta数据，获取表的存储引擎类型等信息，通过接口调用对应的存储引擎处理 9. 上述过程中产生数据变化的时候，若打开日志功能，则会记录到相应二进制日志文件中 3.结果1. Query请求完成后，将结果集返回给‘连接进/线程模块’ 2. 返回的也可以是相应的状态标识，如成功或失败等 3. ‘连接进/线程模块’进行后续的清理工作，并继续等待请求或断开与客户端的连接 4:小结 用户模块校验用户,然后去线程连接池拿线程(连接足够的话),找命令分发器,到查询缓存模块查SQL语句,如果没有,走命令解析器,然后访问控制模块,设定用户的权限,设定好后走表管理模块,获取锁和缓存,然后获取各种信息,存储的方式:存储引擎,从存储引擎获取数据,然后返回 一、优化的入手点 查找分析查询慢的原因 1.记录慢查询日志（慢查询日志的使用以及分析见本章slow_query.md) 2.show profile: set profiling = 1;开启，服务器上执行的所有语句会检测消耗的时间，存到临时表 show profiles 查看语句执行消耗的时间 show profile for query 临时表ID 查看某个查询的详细消耗 3.分析单条语句使用explain（explain.md查看explain用法） 优化查询中的数据访问 1.访问数据太多导致查询性能下降，尽量不要使用select * 2.确定应用程序逻辑需要的数据量，使用limit返回一部分即可 3.确定MySQL是否检索了索引，避免全表扫描 4.重复查询相同的数据，可以缓存数据，下次直接读缓存 5.是否存在扫描额外的记录（使用explain分析发现需要扫描大量的数据，却只返回少数行）： 使用索引覆盖扫描，把所用到的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果 优化长难语句 一个复杂的查询和多个简单的查询相比较，mysql每秒可以查询上百万的数据，响应给客户端的速度就要慢得多，所以使用尽可能少的查询是好的，但是有时候把一个大查询分解为多个小的查询也是必要的。因为长时间的sql会产生临时表、锁表、占用数据连接等情况，影响其他的查询。 解决方案： 1.切分查询，将一条大的查询切分成多个小的查询，分批次执行 2.分解关联查询， 将一个关联语句分解成多个sql来执行，减少锁的竞争，并且在应用层进行关联，以后更容易拆分数据库 优化特定类型的查询语句 1.优化关联查询，确定on的子句有没有索引，避免全表扫描 2.确保group by和order by中只有一个表中的列，这样才会使用到索引 3.优化子查询，尽量使用关联查询来替代子查询(因为mysql对关联查询会有一些优化器，但是高性能mysql上说了，在mysql5.6以上版本或者MariaDB中，子查询和关联查询的效率是差不多的) 4.优化limit分页，当limit偏移量大的时候，查询效率就会很低。此时我们可以记录上次查询的最大id，下次查询时直接根据该id来查询 比如每页需要显示10条数据，到limit 10000,10的时候，其实是查出了10010条结果集，返回了10条。如果我们记住上一次查询的最大id，10000.我们可以使用 where id &gt; 10000 limit 10，这样还是只在10条数据中返回，极大的提升了运行效率]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[负载均衡和请求转发笔记总结]]></title>
    <url>%2F2017%2F10%2F18%2F%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[负载均衡，请求转发七层负载均衡的实现 基于URL等应用层信息的负载均衡 用Nginx的proxy实现七层负载均衡，具有如下特点： 功能强大，运行稳定 配置简单灵活 能够自动剔除工作不正常的后端服务器 上传文件使用异步模式 支持多种分配策略(内置策略，扩展策略)，可以分配权重 内置策略：IP Hash 、 加权轮询 扩展策略： fair策略、通用hash、一致性hash 加权轮询策略： 首先将请求都分给权重高的机器，知道机器权重降低到了比其他机器低，在将请求分配给下一个权重高的机器。当所有机器都down掉时，Nginx会将所有机器标志位清成初始状态，以避免所有机器都处在timeout状态 IP Hash策略： 与轮询很类似，只是算法做了一些修改，相当于变向的轮询策略 fair策略： 根据后端的响应时间来判断负载的情况，从中选出负载最轻的机器，进行分流 通用hash、一致性hash策略： 通用hash使用Nginx内置的变量key进行hash，一致性hash采用了Nginx内置的一致性hash环，支持memcache 12345678910111213141516Nginx配置：http &#123; upstream cluster &#123; # ip hash; 指定策略为ip hash server svr1; # 配置权重 weight = 10； server svr2; server svr3; &#125; server &#123; listen 80; location / &#123; proxy_pass http://cluster; &#125; &#125;&#125; 四层负载均衡的实现 四层负载均衡是通过报文中目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。 软件(LVS)实现，LVS有三种方式：NAT、DR、TUN]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP——PDO入门与实战]]></title>
    <url>%2F2017%2F10%2F16%2FPHP%E2%80%94%E2%80%94PDO%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[PHP-PDOPDO操作数据库 1. 连接 $dbh = new PDO($dsn, $user, $pass, array(PDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION)); 解释：连接是通过创建PDO基类的实例而建立的。与MysqlI不同的是，它可以访问多种数据库 $dsn 必需。数据源，包括 $dbms（数据库管理系统）、$host、$post、$dbName $user 必需。数据库用户名称 $pass 必需。数据库用户密码 PDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION 此处为设置错误报告为主动抛出异常，还可以传递其他参数进行初始化设置，例如长连接等设置。此处的属性设置也可以再之后设置（部分属性之后设置将会无效，例如长连接） return 返回值。连接数据成功后，返回一个PDO类的实例 $dbh 给脚本使用，此连接在 $dbh 的生存周期中保持活动。若想关闭连接，需要销毁 $dbh 以确保它的所有引用都被删除（销毁方法，赋 NULL 值给 $dbh）。若没有明确进行这种处理，则PHP会在脚本结束时自动关闭连接 如果连接过程中出现任何错误，都将抛出一个 PDOException异常对象。如果我们不进行捕获异常处理，zend引擎将默认结束脚本并显示一个回溯跟踪，此回溯跟踪可能泄露完整的数据库连接细节，例如用户名、密码等信息。所以我们必需进行捕获处理，使用 catch语句 或 set_exception_handler() 函数捕获处理异常* 示例： 1234567891011121314151617$dbms = &apos;mysql&apos;; //数据库类型$host = &apos;localhost&apos;; //数据库主机名$post = &apos;3306&apos;; //数据库主机名$dbName = &apos;demo&apos;; //使用的数据库$user = &apos;root&apos;; //数据库连接用户名$pass = &apos;123456&apos;; //对应的密码$dsn = &quot;$dbms: host=$host;port=$post;dbname=$dbName&quot;;try &#123;// 初始化一个PDO实例$dbh$dbh = new PDO($dsn, $user, $pass);echo &quot;连接成功&lt;br/&gt;&quot;;// 运行完成，需要销毁实例$dbh，关闭连接$dbh = null;&#125; catch (PDOException $e) &#123; // 抛出PDOException异常对象$e// 异常处理die($e);&#125; 2. 事务解释： 事务的四大特性（ACID）：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）以及持久性（Durability） 在一个事务中执行的任何操作，即使是分阶段执行的，也能保证安全地应用于数据库，并在提交时不会受到来自其他连接的干扰。事务操作也可以根据请求自动撤销（前提是还未提交事务） 事务通常是通过把一批查询操作“积蓄”起来然后使之同时生效而实现的，大大地提高了效率 如果需要一个事务，则必须用 PDO::beginTransaction() 方法来启动。如果底层驱动不支持事务，则抛出一个 PDOException异常。一旦开始了事务，可用 PDO::commit()（提交操作）或 PDO::rollBack()（回滚操作）来完成此次事务 PDO仅在驱动层检查是否具有事务处理能力，如果某些运行时条件意味着事务不可用，且数据库服务接受请求去启动一个事务，PDO::beginTransaction() 将仍然返回 TRUE 而且没有错误（例如：在MySQL数据库的MyISAM数据表中使用事务，MyISAM数据表不支持事务，但是MySQL具有事务处理能力）* 示例： 12345678910111213141516171819try &#123;$dbh = new PDO($dsn, $user, $pass);&#125; catch (PDOException $e) &#123;die($e);&#125;try &#123;// 设置错误报告模式为ERRMODE_EXCEPTION，主动抛出Exception异常$dbh-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);// 开启事务$dbh-&gt;beginTransaction();$dbh-&gt;exec(&quot;insert into users (`name`, `gender`) values (&apos;Alice&apos;, &apos;0&apos;)&quot;);$dbh-&gt;exec(&quot;insert into users (`name`, `gender`) values (&apos;Joe&apos;, &apos;1&apos;)&quot;);// 提交事务$dbh-&gt;commit();&#125; catch (Exception $e) &#123;// 出错后进行回滚$dbh-&gt;rollBack();die($e);&#125; 3. 预处理 bool PDOStatement::execute ([ array $input_parameters ] ) 解释：通过在查询语句中使用占位符（? / :），提高效率，确保不会发生SQL注入 执行预处理语句。如果预处理语句含有参数标记，执行时必须选择以下其中一种做法： 调用PDOStatement::bindParam()绑定 PHP 变量到参数标记，此处不多做介绍 传递一个只作为输入参数值的数组 $input_parameters 可选。不能绑定多个值到一个预处理语句参数。元素个数和预处理语句参数一样多 使用?占位符：array(0)* 使用:占位符：array(‘:name’ =&gt; ‘name’)* 当元素个数超过预处理语句参数时，执行将会失败并抛出一个错误* return 返回值。成功时返回TRUE，或者在失败时返回FALSE 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354try &#123;$dbh = new PDO($dsn, $user, $pass);&#125; catch (PDOException $e) &#123;die($e);&#125;try &#123;$dbh-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);// 使用:占位符$gender = 0;$birthday = &apos;2018-11-11&apos;;$stmt = $dbh-&gt;prepare(&quot;SELECT * FROM `users` WHERE `gender` = :gender AND `birthday` = :birthday&quot;);if ($stmt-&gt;execute(array(&apos;:gender&apos; =&gt; $gender, &apos;:birthday&apos; =&gt; $birthday))) &#123;while ($row = $stmt-&gt;fetch()) &#123;print_r($row);&#125;&#125;// 使用:占位符（bindParam()）$gender = 0;$birthday = &apos;2018-11-11&apos;;$stmt = $dbh-&gt;prepare(&quot;SELECT * FROM `users` WHERE `gender` = :gender AND `birthday` = :birthday&quot;);$stmt-&gt;bindParam(&apos;:gender&apos;, $gender);$stmt-&gt;bindParam(&apos;:birthday&apos;, $birthday);if ($stmt-&gt;execute()) &#123;while ($row = $stmt-&gt;fetch()) &#123;print_r($row);&#125;&#125;// 使用?占位符$gender = 0;$birthday = &apos;2018-11-11&apos;;$stmt = $dbh-&gt;prepare(&quot;SELECT * FROM `users` WHERE `gender` = ? AND `birthday` = ?&quot;);if ($stmt-&gt;execute(array($gender,$birthday))) &#123;while ($row = $stmt-&gt;fetch()) &#123;print_r($row);&#125;&#125;// 使用?占位符（bindParam()）$gender = 0;$birthday = &apos;2018-11-11&apos;;$stmt = $dbh-&gt;prepare(&quot;SELECT * FROM `users` WHERE `gender` = ? AND `birthday` = ?&quot;);// 从1开始，此处后面还可以补充两个参数（类型与长度）$stmt-&gt;bindParam(1, $gender);$stmt-&gt;bindParam(2, $birthday);if ($stmt-&gt;execute()) &#123;while ($row = $stmt-&gt;fetch()) &#123;print_r($row);&#125;&#125;&#125; catch (Exception $e) &#123;die($e);&#125; 4. 其他常用方法 public PDOStatement PDO::prepare ( string $statement [, array $driver_options = array() ] ) 解释：为预处理准备待执行的SQL语句。SQL 语句可以包含零个或多个参数占位标记，格式是:name或?，当它执行时将用真实数据取代。在同一个 SQL 语句里，命名形式和问号形式不能同时使用，只能选择其中一种参数形式。用参数形式绑定用户输入的数据，不要直接字符串拼接到查询里 $statement 必需。SQL语句 $driver_options 可选。为返回的PDOStatement对象设置属性 return 返回值。返回PDOStatement对象，或者返回FALSE或抛出PDOException（取决于PDO::ATTR_ERRMODE） mixed PDOStatement::fetch ([ int $fetch_style [, int $cursor_orientation = PDO::FETCH_ORI_NEXT [, int $cursor_offset = 0 ]]] ) 解释：从PDO::prepare返回的PDOStatement对象相关的结果集中获取下一行 $fetch_style 可选。控制下一行返回的格式，默认PDO::FETCH_BOTH，返回一个索引为结果集列名和以0开始的列号的数组 $cursor_orientation 可选。对于PDOStatement对象表示的可滚动游标，该值决定了哪一行将被返回给调用者。此值默认为PDO::FETCH_ORI_NEXT。要使用，必须在PDO::prepare() 预处理SQL语句时，设置PDO::ATTR_CURSOR属性为PDO::CURSOR_SCROLL $cursor_offset 可选。若cursor_orientation参数设置为PDO::FETCH_ORI_ABS，此值指定结果集中想要获取行的绝对行号。若cursor_orientation参数设置为PDO::FETCH_ORI_REL，此值指定想要获取行相对于调用PDOStatement::fetch()前游标的位置 return 返回值。成功时返回的值依赖于提取类型，失败返回FALSE bool PDOStatement::bindParam ( mixed $parameter , mixed &amp;$variable [, int $data_type = PDO::PARAM_STR [, int $length [, mixed $driver_options ]]] ) 解释：绑定一个PHP变量到用作预处理SQL语句中对应占位符的位置。只能在PDOStatement::execute()调用时才能取其值 $parameter 必需。需替换的参数名，例如:name或? &amp;$variable 必需。绑定到SQL语句参数的PHP变量名 $data_type 可选。指定参数的类型 $length 可选。指定参数的长度 $driver_options 可选。 return 返回值。成功时返回TRUE，失败时返回FALSE 参数以只读的方式用来建立查询（区别于部分驱动能修改）]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用负载均衡调度算法实现]]></title>
    <url>%2F2017%2F10%2F07%2F%E5%B8%B8%E7%94%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[介绍用 PHP 实现几种负载均衡调度算法，详细见 在分布式系统中，为了实现负载均衡，必然会涉及到负载调度算法，如 Nginx 和 RPC 服务发现等场景。常见的负载均衡算法有 轮询、源地址 Hash、最少连接数，而 轮询 是最简单且应用最广的算法。 调度算法3种常见的轮询调度算法，分别为 简单轮询、加权轮询、平滑加权轮询 普通轮询（general Round Robin)namespace Robin; class Robin implements RobinInterface { private $services = array(); private $total; private $currentPos = -1; public function init(array $services) { $this-&gt;services = $services; $this-&gt;total = count($services); } public function next() { // 已调度完一圈,重置currentPos值为第一个实例位置 $this-&gt;currentPos = ($this-&gt;currentPos + 1) % $this-&gt;total; return $this-&gt;services[$this-&gt;currentPos]; } } 加权轮询（Weighted Round Robin)namespace Robin; class WeightedRobin implements RobinInterface { private $services = array(); private $total; private $currentPos = -1; private $currentWeight; public function init(array $services) { foreach ($services as $ip =&gt; $weight) { $this-&gt;services[] = [ &apos;ip&apos; =&gt; $ip, &apos;weight&apos; =&gt; $weight, ]; } $this-&gt;total = count($this-&gt;services); } public function next() { $i = $this-&gt;currentPos; while (true) { $i = ($i + 1) % $this-&gt;total; // 已全部被遍历完一次 if (0 === $i) { // 减currentWeight $this-&gt;currentWeight -= $this-&gt;getGcd(); // 赋值currentWeight为0,回归到初始状态 if ($this-&gt;currentWeight &lt;= 0) { $this-&gt;currentWeight = $this-&gt;getMaxWeight(); } } // 直到当前遍历实例的weight大于或等于currentWeight if ($this-&gt;services[$i][&apos;weight&apos;] &gt;= $this-&gt;currentWeight) { $this-&gt;currentPos = $i; return $this-&gt;services[$this-&gt;currentPos][&apos;ip&apos;]; } } } /** * 求两数的最大公约数(基于欧几里德算法,可使用gmp_gcd()) * * @param integer $a * @param integer $b * * @return integer */ private function gcd($a, $b) { $rem = 0; while ($b) { $rem = $a % $b; $a = $b; $b = $rem; } return $a; } /** * 获取最大公约数 * * @return integer */ private function getGcd() { $gcd = $this-&gt;services[0][&apos;weight&apos;]; for ($i = 0; $i &lt; $this-&gt;total; $i++) { $gcd = $this-&gt;gcd($gcd, $this-&gt;services[$i][&apos;weight&apos;]); } return $gcd; } /** * 获取最大权重值 * * @return integer */ private function getMaxWeight() { $maxWeight = 0; foreach ($this-&gt;services as $node) { if ($node[&apos;weight&apos;] &gt;= $maxWeight) { $maxWeight = $node[&apos;weight&apos;]; } } return $maxWeight; } } 平滑加权轮询（Smooth Weighted Round Robin)namespace Robin; class SmoothWeightedRobin implements RobinInterface { /** * 服务群组 * @var array */ private $services = array(); /** * 同时累加所有peer的effective_weight，保存为total * @var */ private $total; /** * 后端目前的权重 * @var int */ private $currentPos = -1; /** * 初始化 * @param array $services */ public function init(array $services) { foreach ($services as $ip =&gt; $weight) { $this-&gt;services[] = [ &apos;ip&apos; =&gt; $ip, &apos;weight&apos; =&gt; $weight, &apos;current_weight&apos; =&gt; $weight, ]; } $this-&gt;total = count($this-&gt;services); } public function next() { // 获取最大当前有效权重的实例位置 $this-&gt;currentPos = $this-&gt;getMaxCurrentWeightPos(); // 当前权重减去权重和 $currentWeight = intval($this-&gt;getCurrentWeight($this-&gt;currentPos)) - intval($this-&gt;getSumWeight()); $this-&gt;setCurrentWeight($this-&gt;currentPos, $currentWeight); // 每个实例的当前有效权重加上配置权重 $this-&gt;recoverCurrentWeight(); return $this-&gt;services[$this-&gt;currentPos][&apos;ip&apos;]; } /** * 获取最大当前有效权重实例位置 * @return int */ public function getMaxCurrentWeightPos() { $currentWeight = $pos = 0; foreach ($this-&gt;services as $index =&gt; $service) { if ($service[&apos;current_weight&apos;] &gt; $currentWeight) { $currentWeight = $service[&apos;current_weight&apos;]; $pos = $index; } } return $pos; } /** * 配置权重和，累加所有后端的effective_weight * * @return integer */ public function getSumWeight() { $sum = 0; foreach ($this-&gt;services as $service) { $sum += intval($service[&apos;weight&apos;]); } return $sum; } /** * 设置当前有效权重 * @param integer $pos * @param integer $weight */ public function setCurrentWeight($pos, $weight) { $this-&gt;services[$pos][&apos;current_weight&apos;] = $weight; } /** * 获取当前有效权重 * * @param integer $pos * @return integer */ public function getCurrentWeight($pos) { return $this-&gt;services[$pos][&apos;current_weight&apos;]; } /** * 用配置权重调整当前有效权重 */ public function recoverCurrentWeight() { foreach ($this-&gt;services as $index =&gt; &amp;$service) { $service[&apos;current_weight&apos;] += intval($service[&apos;weight&apos;]); } } } 调度算法接口服务namespace Robin; interface RobinInterface { /** * 初始化服务权重 * * @param array $services */ public function init(array $services); /** * 获取一个服务 * * @return string */ public function next(); } 加权轮询 算法虽然通过配置实例权重，解决了 简单轮询 的资源利用问题，但是它还是存在一个比较明显的 缺陷。为了解决加权轮询调度不均匀的缺陷，一些人提出了 平滑加权轮询 调度算法，它会生成的更均匀的调度序列 {a, a, b, a, c, a, a}。对于神秘的平滑加权轮询算法，我将在后续文章中详细介绍它的原理和实现。 Installationlog1composer require tinywan/load-balancing Basic Usage12345678910111213141516171819202122232425262728293031323334353637383940414243// 服务器数$services = [ '192.168.10.1' =&gt; 6, '192.168.10.2' =&gt; 2, '192.168.10.3' =&gt; 1, '192.168.10.4' =&gt; 1,]; ------------- 1.简单轮询 ------------- $robin = new \Robin\Robin();$robin-&gt;init($services);$nodes = [];for ($i = 1; $i &lt;= count($services); $i++) &#123; $node = $robin-&gt;next(); $nodes[$i] = $node;&#125;var_export($nodes); ------------- 2.加权轮询 ------------- $robin = new \Robin\WeightedRobin();$robin-&gt;init($services);$nodes = [];for ($i = 1; $i &lt;= 10; $i++) &#123; $node = $robin-&gt;next(); $nodes[$i] = $node;&#125;var_export($nodes); ------------- 3.平滑加权轮询 ------------- $robin = new \Robin\SmoothWeightedRobin();$robin-&gt;init($services);$nodes = [];$sumWeight = $robin-&gt;getSumWeight();for ($i = 1; $i &lt;= $sumWeight; $i++) &#123; $node = $robin-&gt;next(); $nodes[$i] = $node;&#125;var_export($nodes); Composer管理安装提示错误： Could not find package tinywan/load-polling in a version matching 1.0 尝试改成Packagist的地址 https://packagist.org log123456&quot;repositories&quot;: &#123; &quot;packagist&quot;: &#123; &quot;type&quot;: &quot;composer&quot;, &quot;url&quot;: &quot;https://packagist.org&quot; &#125;&#125; 要使你发布的最新包可以使用，请使用以上的镜像源，为了学习 参考 负载均衡算法 负载均衡算法 — 轮询 负载均衡算法 — 平滑加权轮询 Nginx的负载均衡 - 加权轮询 (Weighted Round Robin) 上篇 Nginx的负载均衡 - 加权轮询 (Weighted Round Robin) 下篇 Composer/Packagist包]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP——错误(Error)处理机制]]></title>
    <url>%2F2017%2F09%2F16%2FPHP%E2%80%94%E2%80%94%E9%94%99%E8%AF%AF-Error-%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1. 常见的错误报告级别| 值 | 常量 | 描述 | | - | - | - | | 1 | E_ERROR | 致命的运行时错误。这类错误一般是不可恢复的情况，导致脚本终止不再继续运行 | | 2 | E_WARNING | 运行时警告 (非致命错误)。仅给出提示信息，但是脚本不会终止运行 | | 4 | E_PARSE | 编译时语法解析错误。解析错误仅仅由分析器产生 | | 8 | E_NOTICE | 运行时通知。表示脚本遇到可能会表现为错误的情况，但是在可以正常运行的脚本里面也可能会有类似的通知 | | 256 | E_USER_ERROR | 用户产生的错误信息。类似 E_ERROR, 但是是由用户自己在代码中使用PHP函数 trigger_error() 来产生的 | | 512 | E_USER_WARNING | 用户产生的警告信息。类似 E_WARNING, 但是是由用户自己在代码中使用PHP函数 trigger_error() 来产生的 | | 1024 | E_USER_NOTICE | 用户产生的通知信息。类似 E_NOTICE, 但是是由用户自己在代码中使用PHP函数 trigger_error() 来产生的 | | 2048 | E_STRICT | 启用 PHP 对代码的修改建议，以确保代码具有最佳的互操作性和向前兼容性 | | 8191 | E_ALL（在 PHP 6.0，E_STRICT 是 E_ALL 的一部分） | E_STRICT出外的所有错误和警告信息（PHP 6.0+，E_STRICT 也是 E_ALL 的一部分） | 2. 设置错误报告的级别 int error_reporting ( [ int $level ] ) $level 可选。错误报告的级别。未设置 $level 时，默认当前的错误报告级别 return 返回值。返回旧的错误报告级别。当未设置 $level 时，返回当前的错误报告级别 示例: 12345678910111213141516171819202122// 关闭所有PHP错误报告error_reporting(0);// echo $a;// 报告所有PHP错误error_reporting(-1);// echo $a;// 报告所有PHP错误error_reporting(E_ALL);// echo $a;// 报告除 E_NOTICE 外的其他所有错误error_reporting(E_ALL ^ E_NOTICE);// echo $a;// 报告除 E_NOTICE 外的其他所有错误error_reporting(E_ALL &amp; ~ E_NOTICE);// echo $a;// 报告除 E_NOTICE 和 E_USER_WARNING 外的其他所有错误error_reporting(E_ALL &amp; ~ (E_NOTICE | E_USER_WARNING);// echo $a;// trigger_error(&apos;E_USER_WARNING&apos;,E_USER_WARNING);// 报告属于其中的错误error_reporting(E_ERROR | E_WARNING | E_PARSE | E_NOTICE);// echo $a; 3. 产生用户级别的错误 bool trigger_error ( string $error_msg [, int $error_type = E_USER_NOTICE ] ) 别名：user_error(); $error_msg 必需。指定错误的信息。长度限制在1024个字节，超出截断 $error_type 可选。指定产生的错误的级别。仅对E_USER系列（如E_USER_NOTICE、E_USER_WARNING、E_USER_ERROR等）错误级别有效，默认是E_USER_NOTICE return 返回值。如果指定了错误的 error_type 会返回 FALSE ，正确则返回 TRUE 示例： 1234// 触发用户级别的警告trigger_error(&apos;E_USER_WARNING&apos;,E_USER_WARNING);// 触发用户级别的注意trigger_error(&apos;E_USER_NOTICE&apos;,E_USER_NOTICE); 4. 基本的错误处理（少用） die(status) / exit(status) status 必需。规定在退出脚本之前写入的消息或状态号。如果 status 是字符串，则该函数会在退出前输出字符串。如果 status 是整数，这个值会被用作退出状态。退出状态的值在 0 至 254 之间。退出状态 255 由 PHP 保留，不会被使用。状态 0 用于成功地终止程序 5. 创建自定义错误处理器 bool error_function ( int $error_level, string $error_message [, string $error_file [, int $error_line [, array $error_context ] ] ] ) {} $error_level 必需。包含错误的级别。 $error_message 必需。包含错误的消息。 $error_file 可选。包含发生错误的文件名。 $error_line 可选。包含错误发生的行号。 $error_context 可选。包含错误触发处作用域内所有变量的数组。PHP 7.2.0+弃用 return 返回值。若返回 FALSE，还会执行PHP标准错误处理程序 6. 内建的错误处理程序 mixed set_error_handler ( callback $error_handler [, int $error_types = E_ALL | E_STRICT ] ); 1.$error_handler 必需。自定义的错误处理器，见2。此外，它还可以接受类的方法，但必须以数组的形式传递，数组的第一项为“类名”，第二个项为“方法名” 示例： 1234567891011121314// 使用自定义的错误处理器名function customError()&#123;echo &apos;customError&apos;;&#125;set_error_handler(&apos;customError&apos;);echo $test;// 使用类的方法class App&#123;public static function customError() &#123;echo &apos;customError&apos;;&#125;&#125;set_error_handler(array(&quot;App&quot;,&quot;customError&quot;)); 2.$error_types 可选。用于屏蔽 $error_handler 的触发，如果没有设置，则默认是 E_ALL | E_STRICT，即$error_handler 会在每个错误发生时调用。$error_types 中指定的级别会绕过PHP标准错误处理程序，其中，会导致 error_reporting() 失效(除非 $error_handler 返回 FALSE)。 示例： 123456789101112error_reporting(E_ALL); // 设置显示所有级别的错误function customError()&#123;echo &apos;customError&apos;;// return false; &#125;set_error_handler(&apos;customError&apos;,E_NOTICE);echo $test; // 触发E_NOTICE级别错误// 分析：产生的E_NOTICE级别错误经由set_error_handler()处理，绕过了PHP//标准错误处理程序，所以只会打印“customError”。若在$error_handler中返回//FALSE，则还可以继续执行PHP标准错误处理程序 3.return 返回值。如果之前有定义过错误处理程序，则返回该程序名称的 string；如果是内置的错误处理程序，则返回 NULL。 如果你指定了一个无效的回调函数，同样会返回 NULL。 如果之前的错误处理程序是一个类的方法，此函数会返回一个带类和方法名的索引数组(indexed array)。 在需要时使用 die()结束脚本。因为如果错误处理程序返回了，脚本将会继续执行发生错误的后程序* 存在缺点，以下级别的错误不能由用户定义的函数来处理： E_ERROR、 E_PARSE、 E_CORE_ERROR、 E_CORE_WARNING、 E_COMPILE_ERROR、 E_COMPILE_WARNING，和在调用 set_error_handler()函数所在文件中产生的大多数 E_STRICT。说简单点，就是只能捕获WARNING、NOTICE级别的错误* 如果错误发生在脚本执行之前（比如文件上传、编译时），将不会调用自定义的错误处理程序因为错误尚未在那时注册，下面介绍的register_shutdown_function()也将如此。当遇到这种情况时如何处理，参照现如今PHP框架的做法，函数处理集中放置在一个主文件中，其他需要编译的文件通过INCLUDE的方式引入* 7. 获取程序最后的错误 array error_get_last() return 返回值。返回了一个关联数组，描述了最后错误的信息，以该错误的 “type”、 “message”、”file” 和 “line” 为数组的键。 如果错误由PHP内置函数导致的，”message”会以该函数名开头。 如果没有错误则返回 NULL 示例： 12345var_dump(error_get_last()); // 若程序没有错误，返回NULL echo $a;echo $b; var_dump(error_get_last()); // error_get_last()返回这行的信息 8. PHP结束时执行的函数 void register_shutdown_function ( callable $callback [, mixed $parameter [, mixed $… ]] ) $callback 必需。中止回调的函数，它会在脚本执行完成或者 exit() 后被调用 $parameter 可选。设置传入中止回调函数的参数 此函数无返回值 此函数可以多次调用，按顺序执行。但如果其中有一个中止函数存在exit()，那就真的是程序所有处理完全结束了，不会再调其他的中止回调函数 示例 1234567891011function shutdown0()&#123;echo &quot;success0&lt;/br&gt;&quot;;exit(); // 若加入此函数，不会再显示success1&#125;function shutdown1()&#123;echo &quot;success1&lt;/br&gt;&quot;;&#125;register_shutdown_function(&apos;shutdown0&apos;);register_shutdown_function(&apos;shutdown1&apos;); 9. 整合 捕获所有的错误并进行处理：set_error_handler() 与 register_shutdown_function() 结合使用 示例： 1234567891011121314151617181920212223242526error_reporting(0); // 设置错误报告级别为所有function customError1()&#123;if ($error = error_get_last()) &#123;echo &apos;customError1&apos;;&#125;&#125;function customError0()&#123;echo &apos;customError0&apos;;// return false;&#125;set_error_handler(&apos;customError0&apos;);register_shutdown_function(&apos;customError1&apos;);require &apos;error.php&apos;;// error.php 文件内容echo $test;// var_dump($test+-+);// 分析：首先，如果是 E_NOTICE 或 E_WARNING 级别的错误由 set_error_handler() 处理就好了//，调用 customError0() ，随后因为 customError0() 函数没有返回 FALSE ，所以不再执行PHP//标准错误处理程序，程序结束。接着，如果 E_NOTICE 或 E_WARNING 级别之上的错误，则因为//会导致程序中止，执行 register_shutdown_function() 函数，调用 customError1()，//随后程序真正结束。通过这样子的设计，就可以捕获并处理所有的错误级别了 10. 总结在实际开发过程中，需要通过参数的错误级别，不同错误级别进行不同处理，例如部分错误级别需输出成日志文件 一、日志 日志保存时间要合理，重要的日志建议长期保存，其他日志建议短期保存，定期删除，周期大概为15天 日志的记录要合理，有选择的、合理的记录重要信息。过度记录日志信息很不利于提高系统性能，仅在必要处记录日志信息即可，以达到快速定位错误和异常的目的 二、异常 捕获了异常一定要处理，否则将毫无意义。如果不对异常立即进行处理则必须将其向上抛出 不对大量的、长篇幅的代码进行 try { … } catch (Exception $e) { … } 处理 书写接口时，对系统内部输出异常详情，对系统外部输出异常代码 正确使用 try { … } catch(Exception $e) { … } finally { … }]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>错误</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP中四种常用排序算法及性能对比]]></title>
    <url>%2F2017%2F09%2F16%2FPHP%E4%B8%AD%E5%9B%9B%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[使用PHP实现四大排序算法/** * @name php四种基础排序算法的运行时间比较 * @author layjoy(layjoy@163.com) * @date 2016-08-11 08:12:14 */ 冒泡排序法function bubbleSort($array){ $temp = 0; for($i = 0;$i &lt; count($array) -1;$i++){ for($j = 0;$j &lt; count($array) - 1 -$i;$j++){ if($array[$j] &gt; $array[$j+1]){ //从小到大排列 $temp = $array[$j]; $array[$j] = $array[$j+1]; $array[$j+1] = $temp; } } } } 选择排序法function selectSort($array){ $temp = 0; for($i = 0;$i &lt; count($array) - 1;$i++){ $minVal = $array[$i]; //假设$i就是最小值 $minValIndex = $i; for($j = $i+1;$j &lt; count($array);$j++){ if($minVal &gt; $array[$j]){ //从小到大排列 $minVal = $array[$j]; //找最小值 $minValIndex = $j; } } $temp = $array[$i]; $array[$i] = $array[$minValIndex]; $array[$minValIndex] = $temp; } } 插入排序法function insertSort($array){ //从小到大排列 //先默认$array[0]，已经有序，是有序表 for($i = 1;$i &lt; count($array);$i++){ $insertVal = $array[$i]; //$insertVal是准备插入的数 $insertIndex = $i - 1; //有序表中准备比较的数的下标 while($insertIndex &gt;= 0 &amp;&amp; $insertVal &lt; $array[$insertIndex]){ $array[$insertIndex + 1] = $array[$insertIndex]; //将数组往后挪 $insertIndex--; //将下标往前挪，准备与前一个进行比较 } if($insertIndex + 1 !== $i){ $array[$insertIndex + 1] = $insertVal; } } } 快速排序法function quickSort($array){ if(!isset($array[1])) return $array; $mid = $array[0]; //获取一个用于分割的关键字，一般是首个元素 $leftArray = array(); $rightArray = array(); foreach($array as $v){ if($v &gt; $mid) $rightArray[] = $v; //把比$mid大的数放到一个数组里 if($v &lt; $mid) $leftArray[] = $v; //把比$mid小的数放到另一个数组里 } $leftArray = quickSort($leftArray); //把比较小的数组再一次进行分割 $leftArray[] = $mid; //把分割的元素加到小的数组后面，不能忘了它哦 $rightArray = quickSort($rightArray); //把比较大的数组再一次进行分割 return array_merge($leftArray,$rightArray); //组合两个结果 } 调用与打印时间$a = array_rand(range(1,3000), 1600); //生成1600个元素的随机数组 shuffle($a); //打乱数组的顺序 $t1 = microtime(true); bubbleSort($a); //冒泡排序 $t2 = microtime(true); echo &quot;冒泡排序用时：&quot;.(($t2-$t1)*1000).&apos;ms&apos;.&quot;\n&quot;; $t3 = microtime(true); selectSort($a); //选择排序 $t4 = microtime(true); echo &quot;选择排序用时：&quot;.(($t4-$t3)*1000).&apos;ms&apos;.&quot;\n&quot;; $t5 = microtime(true); insertSort($a); //插入排序 $t6 = microtime(true); echo &quot;插入排序用时：&quot;.(($t6-$t5)*1000).&apos;ms&apos;.&quot;\n&quot;; $t7 = microtime(true); quickSort($a); //快速排序 $t8 = microtime(true); echo &quot;快速排序用时：&quot;.(($t8-$t7)*1000).&apos;ms&apos;; 输出性能对比输出结果： 冒泡排序用时：95.726013183594ms 选择排序用时：35.946130752563ms 插入排序用时：33.261060714722ms 快速排序用时：1.3978481292725ms]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP技能书汇总(超全面)]]></title>
    <url>%2F2017%2F09%2F16%2FPHP%E6%8A%80%E8%83%BD%E4%B9%A6%E6%B1%87%E6%80%BB-%E8%B6%85%E5%85%A8%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[该仓库主要真是国内 PHP 面试经常被问到的知识点做汇总。仅是针对性指出知识点，相应还需自己查找相关资料系统学习。我希望各位能不仅仅了解是什么，还要了解为什么，以及背后的原理。 如果您有对相应知识点非常系统的资料，欢迎 PR 增加链接。不建议您使用 fork，资料会随时更新。 如果你现在处于以下几种状态，本资料非常适合你： 准备换工作，不知道从哪开始准备 技术遇到瓶颈，不知道该学什么 准备学 PHP，但不知道领域有多深 基础篇 了解大部分数组处理函数 字符串处理函数 区别 mb_ 系列函数 &amp; 引用，结合案例分析 == 与 === 区别 isset 与 empty 区别 全部魔术函数理解 static、$this、self 区别 private、protected、public、final 区别 OOP 思想 抽象类、接口 分别使用场景 Trait 是什么东西 echo、print、print_r 区别(区分出表达式与语句的区别) construct 与 destruct 区别 static 作用（区分类与函数内）手册 、SOF __toString() 作用 单引号&#39;与双引号&quot;区别 常见 HTTP 状态码，分别代表什么含义 301 什么意思 404 呢? 进阶篇 Autoload、Composer 原理 PSR-4 、原理 Session 共享、存活时间 异常处理 如何 foreach 迭代对象 如何数组化操作对象 $obj[key]; 如何函数化对象 $obj(123); yield 是什么，说个使用场景 yield PSR 是什么，PSR-1, 2, 4, 7 如何获取客户端 IP 和服务端 IP 地址 客户端 IP 服务端 IP 了解代理透传 实际IP 的概念 如何开启 PHP 异常提示 php.ini 开启 display_errors 设置 error_reporting 等级 运行时，使用 ini_set(k, v); 动态设置 如何返回一个301重定向 [WARNING] 一定当心设置 301 后脚本会继续执行，不要认为下面不会执行，必要时使用 die or exit 如何获取扩展安装路径 phpinfo(); 页面查找 extension_dir 命令行 php -i |grep extension_dir 运行时 echo ini_get(&#39;extension_dir&#39;); 字符串、数字比较大小的原理，注意 0 开头的8进制、0x 开头16进制 字符串比较大小，从左(高位)至右，逐个字符 ASCII 比较 BOM 头是什么，怎么除去 0xEF,0xBB,0xBF 检测、去除 什么是 MVC 依赖注入实现原理 如何异步执行命令 模板引擎是什么，解决什么问题、实现原理（Smarty、Twig、Blade） 如何实现链式操作 $obj-&gt;w()-&gt;m()-&gt;d(); Xhprof 、Xdebug 性能调试工具使用 索引数组 [1, 2] 与关联数组 [&#39;k1&#39;=&gt;1, &#39;k2&#39;=&gt;2] 有什么区别 缓存的使用方式、场景 实践篇 给定二维数组，根据某个字段排序 如何判断上传文件类型，如：仅允许 jpg 上传 不使用临时变量交换两个变量的值 $a=1; $b=2; =&gt; $a=2; $b=1; strtoupper 在转换中文时存在乱码，你如何解决？php echo strtoupper(&#39;ab你好c&#39;); Websocket、Long-Polling、Server-Sent Events(SSE) 区别 “Headers already sent” 错误是什么意思，如何避免 算法篇 快速排序（手写） 冒泡排序（手写） 二分查找（了解） 查找算法 KMP（了解） 深度、广度优先搜索（了解） LRU 缓存淘汰算法（了解，Memcached 采用该算法） 数据结构篇（了解） 堆、栈特性 队列 哈希表 链表 对比篇 Cookie 与 Session 区别 GET 与 POST 区别 include 与 require 区别 include_once 与 require_once 区别 Memcached 与 Redis 区别 MySQL 各个存储引擎、及区别（一定会问 MyISAM 与 Innodb 区别） HTTP 与 HTTPS 区别 Apache 与 Nginx 区别 define() 与 const 区别 traits 与 interfaces 区别 及 traits 解决了什么痛点？ Git 与 SVN 区别 数据库篇 MySQL CRUD JOIN、LEFT JOIN 、RIGHT JOIN、INNER JOIN UNION GROUP BY + COUNT + WHERE 组合案例 常用 MySQL 函数，如：now()、md5()、concat()、uuid()等 1:1、1:n、n:n 各自适用场景 了解触发器是什么，说个使用场景 数据库优化手段 索引、联合索引（命中条件） 分库分表（水平分表、垂直分表） 分区 会使用 explain 分析 SQL 性能问题，了解各参数含义 重点理解 type、rows、key Slow Log（有什么用，什么时候需要） MSSQL(了解) 查询最新5条数据 NOSQL Redis、Memcached、MongoDB 对比、适用场景（可从以下维度进行对比） 持久化 支持多钟数据类型 可利用 CPU 多核心 内存淘汰机制 集群 Cluster 支持 SQL 性能对比 支持事务 应用场景 你之前为了解决什么问题使用的什么，为什么选它？ 服务器篇 查看 CPU、内存、时间、系统版本等信息 find 、grep 查找文件 awk 处理文本 查看命令所在目录 自己编译过 PHP 吗？如何打开 readline 功能 如何查看 PHP 进程的内存、CPU 占用 如何给 PHP 增加一个扩展 修改 PHP Session 存储位置、修改 INI 配置参数 负载均衡有哪几种，挑一种你熟悉的说明其原理 数据库主从复制 M-S 是怎么同步的？是推还是拉？会不会不同步？怎么办 如何保障数据的可用性，即使被删库了也能恢复到分钟级别。你会怎么做。 数据库连接过多，超过最大值，如何优化架构。从哪些方便处理？ 502 大概什么什么原因？ 如何排查 504呢？ 架构篇 偏运维（了解）： 负载均衡（Nginx、HAProxy、DNS） 主从复制（MySQL、Redis） 数据冗余、备份（MySQL增量、全量 原理） 监控检查（分存活、服务可用两个维度） MySQL、Redis、Memcached Proxy 、Cluster 目的、原理 分片 高可用集群 RAID 源代码编译、内存调优 缓存 工作中遇到哪里需要缓存，分别简述为什么 搜索解决方案 性能调优 各维度监控方案 日志收集集中处理方案 国际化 数据库设计 静态化方案 画出常见 PHP 应用架构图 框架篇 ThinkPHP（TP）、CodeIgniter（CI）、Zend（非 OOP 系列） Yaf、Phalcon（C 扩展系） Yii、Laravel、Symfony（纯 OOP 系列） Swoole、Workerman （网络编程框架） 对比框架区别几个方向点 是否纯 OOP 类库加载方式（自己写 autoload 对比 composer 标准） 易用性方向（CI 基础框架，Laravel 这种就是高开发效率框架以及基础组件多少） 黑盒（相比 C 扩展系） 运行速度（如：Laravel 加载一大堆东西） 内存占用 设计模式 单例模式（重点） 工厂模式（重点） 观察者模式（重点） 依赖注入（重点） 装饰器模式 代理模式 组合模式 安全篇 SQL 注入 XSS 与 CSRF 输入过滤 Cookie 安全 禁用 mysql_ 系函数 数据库存储用户密码时，应该是怎么做才安全 验证码 Session 问题 安全的 Session ID （让即使拦截后，也无法模拟使用） 目录权限安全 包含本地与远程文件 文件上传 PHP 脚本 eval 函数执行脚本 disable_functions 关闭高危函数 FPM 独立用户与组，给每个目录特定权限 了解 Hash 与 Encrypt 区别 高阶篇 PHP 数组底层实现 （HashTable + Linked list） Copy on write 原理，何时 GC PHP 进程模型，进程通讯方式，进程线程区别 yield 核心原理是什么 PDO prepare 原理 PHP 7 与 PHP 5 有什么区别 Swoole 适用场景，协程实现方式 前端篇 原生获取 DOM 节点，属性 盒子模型 CSS 文件、style 标签、行内 style 属性优先级 HTML 与 JS 运行顺序（页面 JS 从上到下） JS 数组操作 类型判断 this 作用域 .map() 与 this 具体使用场景分析 Cookie 读写 JQuery 操作 Ajax 请求（同步、异步区别）随机数禁止缓存 Bootstrap 有什么好处 跨域请求 N 种解决方案 新技术（了解） ES6 模块化 打包 构建工具 vue、react、webpack、 前端 mvc 优化 浏览器单域名并发数限制 静态资源缓存 304 （If-Modified-Since 以及 Etag 原理） 多个小图标合并使用 position 定位技术 减少请求 静态资源合为单次请求 并压缩 CDN 静态资源延迟加载技术、预加载技术 keep-alive CSS 在头部，JS 在尾部的优化（原理） 网络篇 IP 地址转 INT 192.168.0.1/16 是什么意思 DNS 主要作用是什么？ IPv4 与 v6 区别 网络编程篇 TCP 三次握手流程 TCP、UDP 区别，分别适用场景 有什么办法能保证 UDP 高可用性(了解) TCP 粘包如何解决？ 为什么需要心跳？ 什么是长连接？ HTTPS 是怎么保证安全的？ 流与数据报的区别 进程间通信几种方式，最快的是哪种？ fork() 会发生什么？ API 篇 RESTful 是什么 如何在不支持 DELETE 请求的浏览器上兼容 DELETE 请求 常见 API 的 APP_ID APP_SECRET 主要作用是什么？阐述下流程 API 请求如何保证数据不被篡改？ JSON 和 JSONP 的区别 数据加密和验签的区别 RSA 是什么 API 版本兼容怎么处理 限流（木桶、令牌桶） OAuth 2 主要用在哪些场景下 JWT PHP 中 json_encode([&#39;key&#39;=&gt;123]); 与 return json_encode([]); 区别，会产生什么问题？如何解决 加分项 了解常用语言特性，及不同场景适用性。 PHP VS Golang PHP VS Python PHP VS JAVA 了解 PHP 扩展开发 熟练掌握 C PHP常用技能消息队列 应用场景 秒杀 抢购 发送消息 发送卡券 Redis List RabbitMQ 生成二维码 QR Code 即时通信 应用场景 客服 聊天 监控实时监控数据 群发 MeepoPS workerman 抽象画图 应用场景 数据统计 性能统计 JpGraph 安装扩展mcrypt扩展yum install libmcrypt libmcrypt-devel php-mcrypt mhash php性能优化PHP语言级性能优化 避免使用魔法函数如__get() 尽量使用自带函数完成 自带函数功能一致的情况下性能不同 禁用错误抑制符@ 合理使用内存,及时unset()释放不使用的内存(unset有释放不掉的内存) 合理使用正则 避免在循环内做运算(循环内的计算式将会被重复计算) 减少密集型业务(PHP不适合密集型运算的场景),适合衔接webserver与后端服务、UI呈现 务必使用带引号的字符串做键值(PHP会将没有引号的键值作为常量,产生查找常量的开销) PHP周边问题的优化 减少文件类的操作(内存&gt;&gt;数据库&gt;磁盘&gt;网络) 减少PHP发起的网络请求(设置超时时间,将串行请求并行化”使用curl_multi,使用swoole扩展”) 压缩PHP输出,利:利于我们的数据输出,client端能更快的获取到数据;弊:产生额外的CPU开销(Gzip即可) PHP缓存复用(多次请求,内容不变的情况) Smarty调优和重叠时间窗口]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单点登录实现方案与流程]]></title>
    <url>%2F2017%2F08%2F25%2F%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E4%B8%8E%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[单点登录再次之前要记录一下另一种形式，单个账号同时只能有一个用户登录，之前在乐望做开发的时候，每个账号的后台登录都只能一个人： 首先是把session存到redis而非服务器文件，登录后把session_id存到mysql某个字段 验证用户名密码登录后，取出mysql的session_id字段，然后删除redis下该session_id的key-value。这样就做到上一个登录的人，无法找到对应的session，也就是退出。然后把新的session_id更新到mysql相应的字段 单点登录（single sign on 简称SSO） 单点登录是指在多系统应用群中的一个登录系统，只要在系统应用群中登录一个，便可以在其他系统中得到授权而无需登录 相比于单系统登录，单点登录需要一个独立的认证中心，只有认证中心能接受用户的用户名、密码等信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，sso认证中心验证用户名密码没问题，创建授权令牌，然后把令牌作为参数发给各个子系统，子系统拿到了令牌即得到了授权，可以借此创建局部会话，局部会话就与单系统登录相同。这个过程，也就是单点登录的原理。 一、登录 上图中的流程： 用户访问系统1的受保护资源，系统1发现用户未登录，跳转到sso认证中心，并带上自己的地址作为参数 sso认证发现用户未登录，将用户引导至登录页面 用户输入用户名、密码提交申请登录 sso认证中心校验用户信息，创建用户与sso之间的会话，并创建令牌 sso认证中心带着令牌跳转到最初的请求地址（系统1） 系统1拿到令牌，去sso认证中心校验令牌是否有效 sso认证中心校验令牌，返回有效，注册系统1 系统1使用令牌创建与用户的会话，称为局部会话，返回用户请求的受保护资源 用户访问系统2的受保护资源，系统2发现用户未登录（第一种猜想通过ip来识别这个用户是否登录，假如发现已经存了这个ip代表已经登录，并返回这个ip对应的令牌；第二种猜想，第一次登录时，sso返回系统1并在客户端存一个cookie，比如tokenid，客户端第二次请求的时候，就会带上这个tokenid，sso就可以识别到底是哪个用户了），跳转至sso认证中心，并附带自己的地址， sso认证中心发现用户已经登录，返回系统2，并带上令牌。 系统2拿到令牌，去sso验证令牌是否有效 sso认证令牌，返回有效，并注册系统2 系统2使用该令牌创建与用户的局部会话，返回用户请求的受保护资源 二、注销 用户向系统1发起注销请求 系统1根据用户与系统1建立的会话拿到令牌，向sso认证中心发起注销请求 sso认证令牌有效，销毁全局会话，同时取出所有此令牌注册的系统 sso向所有注册系统发起注销请求 各注册系统受到sso的注销请求，销毁局部会话]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>单点登录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP安全——AES&RAS加密方案与实战]]></title>
    <url>%2F2017%2F08%2F16%2FPHP%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94AES-RAS%E5%8A%A0%E5%AF%86%E6%96%B9%E6%A1%88%E4%B8%8E%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[具体过程是先由接收方创建RSA密钥对，接收方通过Internet发送RSA公钥到发送方，同时保存RSA私钥。而发送方创建AES密钥，并用该 AES密钥加密待传送的明文数据，同时用接受的RSA公钥加密AES密钥，最后把用RSA公钥加密后的AES密钥同密文一起通过Internet传输发送 到接收方。当接收方收到这个被加密的AES密钥和密文后，首先调用接收方保存的RSA私钥，并用该私钥解密加密的AES密钥，得到AES密钥。最后用该 AES密钥解密密文得到明文。 服务器端进行请求响应时将上面流程反过来即可,具体实现流程可做优化，例如：client将encryptkey传输给服务器端的方式可以通过HttpHeader来实现。 RSA非对称加密，公钥加密，私钥解密，反之亦然。由于需要大数的乘幂求模等算法，运行速度慢，不易于硬件实现。 通常私钥长度有512bit，1024bit，2048bit，4096bit，长度越长，越安全，但是生成密钥越慢，加解密也越耗时。 既然是加密，那肯定是不希望别人知道我的消息，所以只有我才能解密，所以可得出公钥负责加密，私钥负责解密； 同理，既然是签名，那肯定是不希望有人冒充我发消息，只有我才能发布这个签名，所以可得出私钥负责签名，公钥负责验证。 1. 加密SecretKey使用RSA 公钥(publicKey)加密AES SecretKey，将得到的加密数据经过Base64编码得到一个UTF-8字符串。将此结果字符串作为HTTP POST方法请求头的requestId字段值 2. 解密SecretKey使用RSA 私钥(privateKey)加密请求头中的requestIdBase64字符串，得到AES SecretKey的原始字节数据，并重新构建成SecretKey。请求响应流程 1. 发起请求客户端准备请求头(appId、requestId)、请求体信息(requestBody)，通过HTTP POST方法向服务端发起请求。 2. 服务端验证服务端接收到客户端请求，首先获取appId，判断appId是否有效；如果appId无效或requestId为空，立即响应未授权信息(HttpStatus:401)。服务端对requestId做Base64解码，通过appId对应的RSA 私钥(privateKey)解密Base64解密结果，得到AES SecretKey。服务端读取请求体重的Base64字符串，并进行Base64解码，通过AES SecretKey解密Base64解密结果，得到原始请求的JSON的UTF-8字符串。在解密过程中因为requestId的不合法情况，服务端立即响应拒绝请求信息(HttpStatus:403)。 3. 服务端响应服务端成功处理业务后，将响应结果转换成JSON的UTF-8字符串，通过AES SecretKey加密得到Base64字符串，将此字符串作为请求响应结果。 4. 响应客户端客户端接收到服务端成功响应(HttpStatus:200)，获取响应结果(加密后的Base64字符串)。经过Base64解码，通过AES SecretKey解密，将解密后的数据转换为UTF-8格式的字符串，得到服务端响应的原始JSON字符串。 AES对称加密，密钥最长只有256个bit，执行速度快，易于硬件实现。由于是对称加密，密钥需要在传输前通讯双方获知。 基于以上特点，通常使用RSA来首先传输AES的密钥给对方，然后再使用AES来进行加密通讯。 1. 加密请求信息为每个请求生成一个独立的AES SecretKey，使用AES算法，通过SecretKey加密请求数据的JSON字符串，将得到的加密数据经过Base64编码得到一个UTF-8字符串。将此结果字符串作为HTTP POST方法的请求主体(RequestBody)。 2. 解密响应结果使用AES SecretKey解密服务端成功响应的Base64字符串，解密后得到服务端响应的JSON字符串。 请求流程： 服务器端(server)和客户端(client)分别生成自己的密钥对 server和client分别交换自己的公钥 client生成AES密钥(aesKey) client使用自己的RSA私钥(privateKey)对请求明文数据(params)进行数字签名 将签名加入到请求参数中，然后转换为json格式 client使用aesKey对json数据进行加密得到密文(data) client使用sever的RSA公钥对aesKey进行加密(encryptkey) 分别将data和encryptkey作为参数传输给服务器端 AES:&lt;?php header(&apos;Content-Type: text/plain;charset=utf-8&apos;); $data = &apos;phpbest&apos;; $key = &apos;oScGU3fj8m/tDCyvsbEhwI91M1FcwvQqWuFpPoDHlFk=&apos;; //echo base64_encode(openssl_random_pseudo_bytes(32)); $iv = &apos;w2wJCnctEG09danPPI7SxQ==&apos;; //echo base64_encode(openssl_random_pseudo_bytes(16)); echo &apos;内容: &apos;.$data.&quot;\n&quot;; $encrypted = openssl_encrypt($data, &apos;aes-256-cbc&apos;, base64_decode($key), OPENSSL_RAW_DATA, base64_decode($iv)); echo &apos;加密: &apos;.base64_encode($encrypted).&quot;\n&quot;; $encrypted = base64_decode(&apos;To3QFfvGJNm84KbKG1PLzA==&apos;); $decrypted = openssl_decrypt($encrypted, &apos;aes-256-cbc&apos;, base64_decode($key), OPENSSL_RAW_DATA, base64_decode($iv)); echo &apos;解密: &apos;.$decrypted.&quot;\n&quot;; ?&gt; 用openssl生成rsa密钥对(私钥/公钥): openssl genrsa -out rsa_private_key.pem 2048 openssl rsa -pubout -in rsa_private_key.pem -out rsa_public_key.pem RSA:&lt;?php header(&apos;Content-Type: text/plain;charset=utf-8&apos;); $data = &apos;phpbest&apos;; echo &apos;原始内容: &apos;.$data.&quot;\n&quot;; openssl_public_encrypt($data, $encrypted, file_get_contents(dirname(__FILE__).&apos;/rsa_public_key.pem&apos;)); echo &apos;公钥加密: &apos;.base64_encode($encrypted).&quot;\n&quot;; $encrypted = base64_decode(&apos;nMD7Yrx37U5AZRpXukingESUNYiSUHWThekrmRA0oD0=&apos;); openssl_private_decrypt($encrypted, $decrypted, file_get_contents(dirname(__FILE__).&apos;/rsa_private_key.pem&apos;)); echo &apos;私钥解密: &apos;.$decrypted.&quot;\n&quot;; ?&gt; 通用协议通讯协议 HTTP 请求方法 POST 请求URL http://host:port/sdk 授权验证 appId: 请求头，客户端唯一标识(无需加密) requestId: 请求头，请求唯一标识(使用RSA加密) 请求数据 请求数据在HTTP请求主体中传递(使用AES加密) 加密算法 RSA 与 AES 结合 (AES/ECB/PKCS5Padding) 字符编码 Base64、UTF-8 请求实例证书信息appId: test publicKey: MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDEBflTi1uIdpSLZdpTpwjtPu+xMKi6OlzdcZqzRaR0NnCNYI1NlkNi5sMIm7CRSVymvfifFpd1Y9GHnqLmW9r4dfiHzQpn75KDnsMODNNKuHiHTNt+JFOxwmn2eJ1bJJhUaPs/vSbe+2L113nZ/PK9PnwLlzv09prJICv4LjfMwwIDAQAB privateKey: MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAMQF+VOLW4h2lItl2lOnCO0+77EwqLo6XN1xmrNFpHQ2cI1gjU2WQ2LmwwibsJFJXKa9+J8Wl3Vj0YeeouZb2vh1+IfNCmfvkoOeww4M00q4eIdM234kU7HCafZ4nVskmFRo+z+9Jt77YvXXedn88r0+fAuXO/T2mskgK/guN8zDAgMBAAECgYAWBqXRYWNTnh9q2nMB208BeYTtYA5VfqFYsJ81bang9Q0IlcTK5wuDXXKk0PmyGZAznD0Hgz5ZjnHIz2Z2g/PCrMVt+ygGNi/Ic7dOcEBUCU8lNgBQ9Rb0rDy4FAyei0moIBuX5mm5l7664B4ctKGaD/ZTnT1lpBiI1m6NkpT0AQJBAPfKc/ovQZcJs4CwizasEBHKFU20BOanF0Q2KXXQMEfUVeJwMmRIAfaNg5X/R+Y+p3vIRdbzCvlzzu9b8yGPyUMCQQDKhHlQNr1IVbAm+u+Xwq60ee8bMK/6yreVYEmTz7glNMnDLk1htq0iBinZJz+IpfJi4UIUy4aDQ7qttHyY3/aBAkEAvpXZ5FkKgsg0Z0vil5d5+KTNA+ntRxbHf3CFLReGuwinUjXnnFgCIoev6OPjgkU4fq2Igg6Hp1wakuHPPEYijwJAdxpH+nvnADac3Z/w7tDpTGz1yYjtxlIYe/pf61VbmE4eZvLBQblcw0jarcKeY/AsyChwY6h62JIppOUj7gixgQJBAIK4zPkJhiiFZYrjkHp8JXjprLbyTFL/FpwQTB4l53qXdLZXroymFZFhN3eWXMdcwGwC+vNFva1OC2bPDf2RA44= 发送请求AES SecretKey对应的Base64字符串： cbkV1CTPzgC7K8u1485GNg== 原始请求体JSON字符串： {“val1”:1,”val2”:5} 请求信息{ Headers: { appId: &quot;test&quot;, requestId: &quot;KUct+A/Ukkssnz4zBXI7TG+fMIJeLGsudtbz96s3BIk5fPAFxIkbGIwNmc5UcmUXk5lJ+6jk1gT7pPiYoE7ksafKFuxO8eZF7sWII/dPkxOIfgMOC2ZEp84IoGwEYJiWkUQsnHcMNiFixQySZo7bNGre5rzTD7mjLkjMRQLqetA=&quot; }, requestBody: &quot;Bsa3B8/HtY2KGdQu6P5Itt8ZIAOzwtVA24VW21oIUaA=&quot; } 服务端响应原始JSON字符串： {“code”:200,”result”:6} 客户端实际接收到的结果(Base64字符串)： h5nN/sAshI7iQ0ES5AMT+vRcEmysGBeV+WAyuw0B1lk= PHP加密验证代码/** * 获取honor私钥资源id */ if(!function_exists(&apos;pi_key&apos;)){ function pi_key($from = &quot;honor&quot;) { return openssl_pkey_get_private(file_get_contents( &apos;../cert/&apos;.$from.&apos;/cert_private.pem&apos;)); } } /** * 获取partner公钥资源id */ if(!function_exists(&apos;pu_key&apos;)){ function pu_key($to = &quot;partner&quot;) { return openssl_pkey_get_public(file_get_contents( &apos;../cert/&apos;.$to.&apos;/cert_public.key&apos;)); } } /** * rsa私钥加密 */ if(!function_exists(&apos;pi_encrypt&apos;)){ /** * @param $data * @param string $use * @return string */ function pi_encrypt($data,$use = &apos;honor&apos;) { openssl_private_encrypt($data,$encrypt,pi_key($use)); return base64_encode($encrypt); } } /** * rsa私钥解密 */ if(!function_exists(&apos;pi_decrypt&apos;)){ /** * @param $data * @param string $use * @return mixed */ function pi_decrypt($data,$use = &apos;partner&apos;){ openssl_private_decrypt(base64_decode($data),$decrypt,pi_key($use)); return $decrypt; } } /** * rsa公钥解密 */ if(!function_exists(&apos;pu_decrypt&apos;)){ /** * @param $data * @param string $use * @return mixed */ function pu_decrypt($data,$use = &quot;honor&quot;) { openssl_public_decrypt(base64_decode($data),$decrypt,pu_key($use)); return $decrypt; } } /** * rsa 公钥加密 */ if(!function_exists(&apos;pu_encrypt&apos;)){ /** * @param $data $data 要加密的数据 * @param string $use 用哪个公钥 * @return string */ function pu_encrypt($data,$use = &quot;partner&quot;) { openssl_public_encrypt($data,$encrypt,pu_key($use)); return base64_encode($encrypt); } } /** * aes 加密 */ if(!function_exists(&apos;aes_encrypt&apos;)){ /** * @param $key 私钥 * @param $input 要加密的数据 * @return string */ function aes_encrypt($key,$input) { $data = is_array($input)? json_encode($input,JSON_UNESCAPED_UNICODE):$input; return openssl_encrypt($data,&apos;aes-128-ecb&apos;,$key); } } /** * aes 解密 */ if(!function_exists(&apos;aes_decrypt&apos;)){ /** * @param $key 私钥 * @param $data 要解密的数据 * @return bool|string */ function aes_decrypt($key,$data) { return json_decode(openssl_decrypt($data,&apos;aes-128-ecb&apos;,$key),true)?:json_decode($data,true); } } /** * 连接半半 */ if(!function_exists(&apos;connect_partner&apos;)){ /** * @param $raw_data post 过去的数据 * @param string $action 接口名 * @return mixed */ function connect_partner($raw_data,$action = &quot;addition&quot;) { //aes 随机私钥（16位重要） $aes_key = str_random(16); //rsa 公钥加密 $requestId = pu_encrypt($aes_key); //aes 加密后数据 $aes_data = aes_encrypt($aes_key,$raw_data); //请求地址 $url = &quot;192.168.0.131:8088/sdk/&quot;.$action; //请求头 $header = [&quot;appId:test&quot;,&quot;requestId:$requestId&quot;,&quot;Content-Type:application/json&quot;]; //curl $ch = curl_init($url); curl_setopt($ch, CURLOPT_HTTPHEADER,$header); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_TIMEOUT,1); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_POST, 1); curl_setopt($ch, CURLOPT_POSTFIELDS,$aes_data); $out_put = curl_exec($ch) or die(&apos;远程主机连接失败!&apos;); return aes_decrypt($aes_key,$out_put); } } PS：关于加密解密感兴趣的朋友还可以参考本站在线工具： 在线RSA加密/解密工具： http://tools.jb51.net/password/rsa_encode 文字在线加密解密工具（包含AES、DES、RC4等）： http://tools.jb51.net/password/txt_encode 在线散列/哈希算法加密工具: http://tools.jb51.net/password/hash_encrypt 在线MD5/hash/SHA-1/SHA-2/SHA-256/SHA-512/SHA-3/RIPEMD-160加密工具： http://tools.jb51.net/password/hash_md5_sha 在线sha1/sha224/sha256/sha384/sha512加密工具： http://tools.jb51.net/password/sha_encode]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解PHP——内存管理垃圾回收]]></title>
    <url>%2F2017%2F07%2F16%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[一、内存管理机制概述 1） 操作系统直接管理着内存，所以操作系统也需要进行内存管理，计算机中通常都有内存管理单元(MMU) 用于处理CPU对内存的访问。 2） 应用程序无法直接调用物理内存， 只能向系统申请内存。 向操作系统申请内存空间会引发系统调用。 系统调用会将CPU从用户态切换到内核。 为了减少系统调用开销。通常在用户态进行内存管理。 申请大块内存备用。使用完的内存不马上释放，将内存复用，避免多次内存申请和释放所带来性能消耗。 3） PHP不需要显示内存管理，由Zend引擎进行管理。 PHP内存限制 1）php.ini中的默认32MB memory_limit = 32M 2）动态修改内存 ini_set (“memory_limit”, “128M”) 3）获取目前内存占用 memory_get_usage() : 获取PHP脚本所用的内存大小 memory_get_peak_usage() ：返回当前脚本到目前位置所占用的内存峰值。 先看一段代码： &lt;?php //内存管理机制 var_dump(memory_get_usage());//获取内存方法，加上true返回实际内存，不加则返回表现内存 $a = &quot;laruence&quot;; var_dump(memory_get_usage()); unset($a); var_dump(memory_get_usage()); //输出(在我的个人电脑上, 可能会因为系统,PHP版本,载入的扩展不同而不同): //int 240552 //int 240720 //int 240552 定义变量之后，内存增加，清除变量之后，内存恢复（有些可能不会恢复和以前一样），好像定义变量时申请了一次内存，其实不是这样的，php会预先申请一块内存，不会每次定义变量就申请内存。 首先我们要打破一个思维: PHP不像C语言那样, 只有你显示的调用内存分配相关API才会有内存的分配. 也就是说, 在PHP中, 有很多我们看不到的内存分配过程. 比如对于: $a = &quot;laruence&quot;; 隐式的内存分配点就有: 1.1. 为变量名分配内存, 存入符号表 2.2. 为变量值分配内存 所以, PHP的unset确实会释放内存, 但这个释放不是C编程意义上的释放, 不是交回给OS.对于PHP来说, 它自身提供了一套和C语言对内存分配相似的内存管理API: emalloc(size_t size); efree(void *ptr); ecalloc(size_t nmemb, size_t size); erealloc(void *ptr, size_t size); estrdup(const char *s); estrndup(const char *s, unsigned int length); 这些API和C的API意义对应, 在PHP内部都是通过这些API来管理内存的. 当我们调用emalloc申请内存的时候, PHP并不是简单的向OS要内存, 而是会像OS要一个大块的内存, 然后把其中的一块分配给申请者, 这样当再有逻辑来申请内存的时候, 就不再需要向OS申请内存了, 避免了频繁的系统调用. 比如如下的例子: var_dump(memory_get_usage(true));//注意获取的是real_size $a = &quot;laruence&quot;; var_dump(memory_get_usage(true)); unset($a); var_dump(memory_get_usage(true)); //输出 //int 262144 //int 262144 //int 262144 也就是我们在定义变量$a的时候, PHP并没有向系统申请新内存.同样的, 在我们调用efree释放内存的时候, PHP也不会把内存还给OS, 而会把这块内存, 归入自己维护的空闲内存列表. 对于小块内存来说, 更可能的是, 把它放到内存缓存列表中去(后记, 某些版本的PHP, 比如我验证过的PHP5.2.4, 5.2.6, 5.2.8, 在调用get_memory_usage()的时候, 不会减去内存缓存列表中的可用内存块大小, 导致看起来, unset以后内存不变). $a = “hello”; 定义变量时，存储两个方面： 变量名，存储在符号表 变量值存储在内存空间 在删除变量的时候，会将变量值存储的空间释放，而变量名所在的符号表不会减小（只增不减） 只增不减的数组Hashtable是PHP的核心结构, 数组也是用她来表示的, 而符号表也是一种关联数组, 对于如下代码: var_dump(memory_get_usage()); for($i=0;$i&lt;100;$i++) { $a = &quot;test&quot;.$i; $$a = &quot;hello&quot;; } var_dump(memory_get_usage()); for($i=0;$i&lt;100;$i++) { $a = &quot;test&quot;.$i; unset($$a); } var_dump(memory_get_usage()); 我们定义了100个变量, 然后又按个Unset了他们, 来看看输出: //int 242104 //int 259768 //int 242920 Wow, 怎么少了这么多内存?这是因为对于Hashtable来说, 定义它的时候, 不可能一次性分配足够多的内存块, 来保存未知个数的元素, 所以PHP会在初始化的时候, 只是分配一小部分内存块给HashTable, 当不够用的时候再RESIZE扩容。 Hashtable, 只能扩容, 不会减少, 对于上面的例子, 当我们存入100个变量的时候, 符号表不够用了, 做了一次扩容, 而当我们依次unset掉这100个变量以后, 变量占用的内存是释放了(118848 – 104448), 但是符号表并没有缩小, 所以这些少的内存是被符号表本身占去了… 二、垃圾回收机制PHP变量存储在一个zval容器里面的 变量类型 变量值 is_ref 代表是否有地址引用 refcount 指向该值的变量数量 变量赋值的时候：is_ref为false， refcount为1 $a = 1; xdebug_debug_zval(&apos;a&apos;); echo PHP_EOL;//换行符，提高代码的源代码级可移植性 输出： a: (refcount=1, is_ref=0), int 1 将变量a的值赋给变量b，变量b不会立刻去在内存中存储值，而是先指向变量a的值，一直到变量a有任何操作的时候 $b = $a; xdebug_debug_zval(&apos;a&apos;); echo PHP_EOL; 输出： a: (refcount=2, is_ref=0), int 1 再来看一个$c = &amp;$a; xdebug_debug_zval(&apos;a&apos;); echo PHP_EOL; xdebug_debug_zval(&apos;b&apos;); echo PHP_EOL; 输出： a: (refcount=2, is_ref=1), int 1 b: (refcount=1, is_ref=0), int 1 因为程序又操作了变量a，所以变量b会自己申请一块内存将值放进去。所以变量a的zval容器中refcount会减1变为1，变量c指向a，所以refcount会加1变为2，is_ref变为true 垃圾回收 在5.2版本或之前版本，PHP会根据refcount值来判断是不是垃圾 如果refcount值为0，PHP会当做垃圾释放掉 这种回收机制有缺陷，对于环状引用的变量无法回收 环状引用：$attr = array(&quot;hello&quot;); $attr[]= &amp;$attr; xdebug_debug_zval(&apos;attr&apos;); echo PHP_EOL; 输出： attr: (refcount=2, is_ref=1), array (size=2) 0 =&gt; (refcount=1, is_ref=0), string &apos;hello&apos; (length=5) 1 =&gt; (refcount=2, is_ref=1), &amp;array 2.在5.3之后版本改进了垃圾回收机制 如果发现一个zval容器中的refcount在增加，说明不是垃圾 如果发现一个zval容器中的refcount在减少，如果减到了0，直接当做垃圾回收 如果发现一个zval容器中的refcount在减少，并没有减到0，PHP会把该值放到缓冲区，当做有可能是垃圾的怀疑对象 当缓冲区达到临界值，PHP会自动调用一个方法取遍历每一个值，如果发现是垃圾就清理]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>内存管理</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库缓存技术入门]]></title>
    <url>%2F2017%2F07%2F12%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[为了减少数据库服务器的压力，提升响应速度，我们将采取数据库缓存。常用的缓存方式有内存缓存和文件缓存。我们通过访问缓存数据让客户端很少访问数据库服务器甚至不访问数据库服务器，在高并发下能最大程度的降低对数据库服务器的压力 MySQL的查询缓存 该方式用的不太多，mysql自带。 查询缓存可以看成sql文本和查询结果的映射，如果第二次查询的sql和第一次sql完全相同，则会使用缓存我们可以使用 show status like &#39;Qcache_hits&#39;;查看命中次数 如果表的结构或数据发生改变，那么查询缓存则不再生效 通过 Flush QUERY CACHE 来清理查询缓存碎片 通过 RESET QUERY CAHCE从查询缓存中移除所有查询 通过 FLUSH TABLES关闭所有打开的表，并清空查询缓存 123456789101112query_cache_type查询缓存类型，0表示不使用查询缓存，1表示始终使用查询缓存，2表示按需使用查询缓存1.当query_cache_type=1时，也可以不使用查询缓存：select sql_no_cache * from table where condition;2.当query_cache_type=2时，表示按需使用查询缓存：select sql_cache * from table where condition;******************************************query_cache_size默认情况下为0，表示为查询缓存预留内存为0，无法使用查询缓存set GLOBAL query_cache_size = 134217728; //设置查询缓存大小为128M Memcache缓存查询数据 对于大型站点，如果没有中间缓存层，当流量打入数据库层时，即便有之前的几层优化（CDN，WEB负载均衡）为我们挡住一部分流量，但是在大并发的情况下还是会有大量的请求涌入数据库，这样对数据库服务器的压力也很大，响应速度会下降，因此添加中间缓存层很有必要Memcache是一套分布式的高速缓存系统，对于需要频繁访问数据库的网站的访问速度提升有显著效果 ####工作原理: Memcache通过在内存里维护一个统一的巨大的hash表，它能通过存储各种格式的数据，包括图像、视频、文件以及数据的检索结果等。将数据调用到内存，然后从内存中读取，大大的提升读取速度 ####工作流程： 先检查客户端的请求是否在memcache中，如果有，直接返回请求数据，不再对数据库进行操作；如果没有，就去查数据库，把从数据库中得到的结果返回，并缓存一份到memcache当中 ####常用方法 PHP的memcache扩展 12345获取: get(key)设置：set(key, value, expire)删除：delete(key)通常使用方法：用查询的方法名+参数作为查询的key，value对应key的值 用Redis缓存查询数据 Redis与Memcache的区别 Redis与Memcache的性能相差不大 Redis依赖客户端来实现分布式读写（不是特别明白） memcache本身没有数据冗余机制 Redis支持快照、AOF，依赖快照进行持久化，aof增强了可靠性的同时，对性能有一定影响 memcache不支持持久化，通常只用于做缓存 memcache在并发场景下，用cas保证一致性，redis事务支持比较弱，只能保证事务中的每个操作连续执行 Redis支持多种数据类型 总结： Redis用于数据量较小的高性能操作和运算上 memcache用于在动态系统中减少数据库负载，提升性能，适合做缓存 MYSQL数据库层的优化 数据表数据类型的优化 索引优化 SQL语句的优化 存储引擎的优化 数据表结构设计的优化 数据库服务器架构的优化]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel底层原理分析]]></title>
    <url>%2F2017%2F06%2F13%2FLaravel%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Laravel作为在国内国外都颇为流行的PHP框架，风格优雅，其拥有自己的一些特点，且也发布长期支持版(LTS)。 一. 请求周期Laravel 采用了单一入口模式，应用的所有请求入口都是 public/index.php 文件。 注册类文件自动加载器：Laravel通过composer进行依赖管理，并在bootstrap/autoload.php中注册了Composer Auto Loader (PSR-)，应用中类的命名空间将被映射到类文件实际路径，不再需要开发者手动导入各种类文件，而由自动加载器自行导入。 因此，Laravel允许你在应用中定义的类可以自由放置在Composer Auto Loader能自动加载的任何目录下，但大多数时候还是建议放置在app目录下或app的某个子目录下。 创建服务容器：从 bootstrap/app.php 文件中取得 Laravel 应用实例 $app(服务容器)。创建 HTTP / Console 内核：传入的请求在HTTP / Console 内核中进行预处理。 HTTP 内核继承自 Illuminate\Foundation\Http\Kernel 类，其中注入了 $app 和 $router 两个实例，内核是完成应用引导、请求处理(包括通过Router转发请求等)的场所。 HTTP Kernel 定义了一个 bootstrappers 数组，配置了环境变量加载、应用配置加载、错误处理，以及其他在请求被处理前需要完成的工作。 载入服务提供者至容器：在内核引导启动的过程中最重要的动作之一就是载入服务提供者到你的 $app (即所有的服务提供者都要挂载到服务容器下去执行)，服务提供者负责引导启动框架的全部各种组件，例如数据库、队列、验证器以及路由组件。因为这些组件引导和配置了框架的各种功能，所以服务提供者是整个 Laravel 启动过程中最为重要的部分，所有的服务提供者都配置在 config/app.php 文件中的 providers 数组中。首先，所有提供者的 register 方法会被调用；一旦所有提供者注册完成，接下来，boot 方法将会被调用。 分发请求：一旦应用完成引导和所有服务提供者都注册完成，Request 将会移交给Router进行分发。在通过Router转发请求时，所有请求都必须先经过全局HTTP中间件栈的处理，再调度到Router并获得其回调，然后执行该回调。 关于中间件： ()中间件好比一个过滤层，多个中间件就是多个过滤层，且它们有先后顺序。 ()全局中间件可分发前执行，也可分发后执行；中间件组使用组key(如’web’、’api’)来调用middleware(key)执行，中间件组仅仅是为了使一次将多个中间件指定给路由变得更加方便；路由中间件在(自定义)路由分发中或分发后执行，也是通过key(如’auth’)来调用middleware(key)执行的。 ()你也可以自定义前置或后置中间件，它们的差别在于在请求执行前还是执行后执行自定义动作。 关键代码 namespace App\Http\Middleware; use Closure; class AfterMiddleware { public function handle($request, Closure $next) { $response = $next($request); // Perform action return $response; } } ()如果你想在内核 handle 和 内核 terminate 时使用同一个中间件实例，可使用容器的 singleton 方法向容器注册中间件。 发送响应并结束：由Response发送响应，然后由内核发出terminate，包括调用可终止的中间件(定义了terminate方法的全局HTTP中间件和路由中间件)、 $app 服务容器终止。 二. 服务容器和服务提供者服务容器是 Laravel 管理类依赖和运行依赖注入的有力工具，在类中可通过 $this-&gt;app 来访问容器，在类之外通过 $app 来访问容器； 服务提供者是 Laravel 应用程序引导启动的中心，关系到服务提供者自身、事件监听器、路由的启动运行。 因为应用程序中注册的路由通过RouteServiceProvider实例来加载，而事件监听器在EventServiceProvider类中进行注册。 在新创建的应用中，AppServiceProvider 文件中方法实现都是空的，这个提供者是你添加应用专属的引导和服务的最佳位置，当然，对于大型应用你可能希望创建几个服务提供者，每个都具有粒度更精细的引导。 服务提供者在 config/app.php 配置文件中的providers数组中进行注册 &lt;?php namespace App\Providers; use Riak\Connection; use Illuminate\Support\ServiceProvider; class RiakServiceProvider extends ServiceProvider { /** * 在容器中注册绑定 * * @return void */ public function register() { $this-&gt;app-&gt;singleton(Connection::class, function ($app) { return new Connection(config(&apos;riak&apos;)); }); } } 三. 依赖注入 Laravel 实现依赖注入方式有两种：自动注入和主动注册。自动注入通过参数类型提示由服务容器自动注入实现；主动注册则需开发人员通过绑定机制来实现，即绑定服务提供者或类（参考： http://d.laravel-china.org/docs/./container ）。 绑定服务提供者或类：这种方式对依赖注入的实现可以非常灵活多样 use Illuminate\Support\Facades\Storage; use App\Http\Controllers\PhotoController; use App\Http\Controllers\VideoController; use Illuminate\Contracts\Filesystem\Filesystem; $this-&gt;app-&gt;when(PhotoController::class) -&gt;needs(Filesystem::class) -&gt;give(function () { return Storage::disk(&apos;local&apos;); }); $this-&gt;app-&gt;when(VideoController::class) -&gt;needs(Filesystem::class) -&gt;give(function () { return Storage::disk(&apos;s&apos;); }); 参数类型声明：通过对类的构造器参数类型、类的方法参数类型、闭包的参数类型给出提示来实现 &lt;?php namespace App\Http\Controllers; use App\Users\Repository as UserRepository; class UserController extends Controller { /** * user repository 实例。 */ protected $users; /** * 控制器构造方法。 * * @param UserRepository $users * @return void */ public function __construct(UserRepository $users) { $this-&gt;users = $users; } /** * 储存一个新用户。 * * @param Request $request * @return Response */ public function store(Request $request) { $name = $request-&gt;input(&apos;name&apos;); // } } 路由参数依赖：下边的示例使用 Illuminate\Http\Request 类型提示的同时还获取到路由参数id 你的路由可能是这样定义的： Route::put(&apos;user/{id}&apos;, &apos;UserController@update&apos;); 而控制器对路由参数id的依赖却可能是这样实现的： &lt;?php namespace App\Http\Controllers; use Illuminate\Http\Request; class UserController extends Controller { /** * 更新指定的用户。 * * @param Request $request * @param string $id * @return Response */ public function update(Request $request, $id) { // } } 四. Artisan Console Laravel利用PHP的CLI构建了强大的Console工具artisan，artisan几乎能够创建任何你想要的模板类以及管理配置你的应用，在开发和运维管理中扮演着极其重要的角色，artisan是Laravel开发不可或缺的工具。 在Laravel根目录下运行：PHP artisan list可查看所有命令列表。用好artisan能极大地简化开发工作，并减少错误发生；另外，还可以编写自己的命令。下面列举部分比较常用的命令： 启用维护模式：php artisan down --message=&apos;Upgrading Database&apos; --retry=0 关闭维护模式：php artisan up 生成路由缓存：php artisan route:cache 清除路由缓存：php artisan route:clear 数据库迁移 Migrations：php artisan make:migration create_users_table --create=users 创建资源控制器：php artisan make:controller PhotoController --resource --model=Photo 创建模型及迁移：php artisan make:model User -m 五. 表单验证机制表单验证在web开发中是不可或缺的，其重要性也不言而喻，也算是每个web框架的标配部件了。Laravel表单验证拥有标准且庞大的规则集，通过规则调用来完成数据验证，多个规则组合调用须以“|”符号连接，一旦验证失败将自动回退并可自动绑定视图。 下例中，附加bail规则至title属性，在第一次验证required失败后将立即停止验证；“.”语法符号在Laravel中通常表示嵌套包含关系，这个在其他语言或框架语法中也比较常见 $this-&gt;validate($request, [ &apos;title&apos; =&gt; &apos;bail|required|unique:posts|max:&apos;, &apos;author.name&apos; =&gt; &apos;required&apos;, &apos;author.description&apos; =&gt; &apos;required&apos;, ]); Laravel验证规则参考 http://d.laravel-china.org/docs/./validation#可用的验证规则 ；另外，在Laravel开发中还可采用如下扩展规则： 自定义FormRequest (须继承自 Illuminate\Foundation\Http\FormRequest ) Validator::make()手动创建validator实例 创建validator实例验证后钩子 按条件增加规则 数组验证 自定义验证规则 六. 事件机制 Laravel事件机制是一种很好的应用解耦方式，因为一个事件可以拥有多个互不依赖的监听器。事件类 (Event) 类通常保存在 app/Events 目录下，而它们的监听类 (Listener) 类被保存在 app/Listeners 目录下，使用 Artisan 命令来生成事件和监听器时他们会被自动创建。 注册事件和监听器：EventServiceProvider的 listen 属性数组用于事件（键）到对应的监听器（值）的注册，然后运行 php artisan event:generate将自动生成EventServiceProvider中所注册的事件(类)模板和监听器模板，然后在此基础之上进行修改来实现完整事件和监听器定义； 另外，你也可以在 EventServiceProvider 类的 boot 方法中通过注册闭包事件来实现 定义事件(类)：事件(类)就是一个包含与事件相关信息数据的容器，不包含其它逻辑 &lt;?php namespace App\Events; use App\Order; use Illuminate\Queue\SerializesModels; class OrderShipped { use SerializesModels; public $order; /** * 创建一个事件实例。 * * @param Order $order * @return void */ public function __construct(Order $order) { $this-&gt;order = $order; } } 定义监听器：事件监听器在 handle 方法中接受了事件实例作为参数 &lt;?php namespace App\Listeners; use App\Events\OrderShipped; class SendShipmentNotification { /** * 创建事件监听器。 * * @return void */ public function __construct() { // } /** * 处理事件 * * @param OrderShipped $event * @return void */ public function handle(OrderShipped $event) { // 使用 $event-&gt;order 来访问 order ... } } 停止事件传播：在监听器的 handle 方法中返回 false 来停止事件传播到其他的监听器触发事件：调用 event 辅助函数可触发事件，事件将被分发到它所有已经注册的监听器上 &lt;?php namespace App\Http\Controllers; use App\Order; use App\Events\OrderShipped; use App\Http\Controllers\Controller; class OrderController extends Controller { /** * 将传递过来的订单发货。 * * @param int $orderId * @return Response */ public function ship($orderId) { $order = Order::findOrFail($orderId); // 订单的发货逻辑... event(new OrderShipped($order)); } } 队列化事件监听器：如果监听器中需要实现一些耗时的任务，比如发送邮件或者进行 HTTP 请求，那把它放到队列中处理是非常有用的。在使用队列化监听器，须在服务器或者本地环境中配置队列并开启一个队列监听器，还要增加 ShouldQueue 接口到你的监听器类；如果你想要自定义队列的连接和名称，你可以在监听器类中定义 $connection 和 $queue 属性；如果队列监听器任务执行次数超过在工作队列中定义的最大尝试次数，监听器的 failed 方法将会被自动调用 &lt;?php namespace App\Listeners; use App\Events\OrderShipped; use Illuminate\Contracts\Queue\ShouldQueue; class SendShipmentNotification implements ShouldQueue { /** * 队列化任务使用的连接名称。 * * @var string|null */ public $connection = &apos;sqs&apos;; /** * 队列化任务使用的队列名称。 * * @var string|null */ public $queue = &apos;listeners&apos;; public function failed(OrderShipped $event, $exception) { // } } 事件订阅者：事件订阅者允许在单个类中定义多个事件处理器，还应该定义一个 subscribe 方法，这个方法接受一个事件分发器的实例，通过调用事件分发器的 listen 方法来注册事件监听器，然后在 EventServiceProvider 类的 $subscribe 属性中注册订阅者 &lt;?php namespace App\Listeners; class UserEventSubscriber { /** * 处理用户登录事件。 */ public function onUserLogin($event) {} /** * 处理用户注销事件。 */ public function onUserLogout($event) {} /** * 为订阅者注册监听器。 * * @param Illuminate\Events\Dispatcher $events */ public function subscribe($events) { $events-&gt;listen( &apos;Illuminate\Auth\Events\Login&apos;, &apos;App\Listeners\UserEventSubscriber@onUserLogin&apos; ); $events-&gt;listen( &apos;Illuminate\Auth\Events\Logout&apos;, &apos;App\Listeners\UserEventSubscriber@onUserLogout&apos; ); } } 七. Eloquent 模型 Eloquent ORM 以ActiveRecord形式来和数据库进行交互，拥有全部的数据表操作定义，单个模型实例对应数据表中的一行 $flights = App\Flight::where(&apos;active&apos;,) -&gt;orderBy(&apos;name&apos;, &apos;desc&apos;) -&gt;take() -&gt;get(); config/database.php中包含了模型的相关配置项。Eloquent 模型约定： 数据表名：模型以单数形式命名(CamelCase)，对应的数据表为蛇形复数名(snake_cases)，模型的$table属性也可用来指定自定义的数据表名称主键：模型默认以id为主键且假定id是一个递增的整数值，也可以通过primaryKey来自定义；如果主键非递增数字值，应设置 incrementing = false 时间戳：模型会默认在你的数据库表有 created_at 和 updated_at 字段，设置timestamps=false可关闭模型自动维护这两个字段；dateFormat 属性用于在模型中设置自己的时间戳格式 数据库连接：模型默认会使用应用程序中配置的数据库连接，如果你想为模型指定不同的连接，可以使用 $connection 属性自定义 批量赋值：当用户通过 HTTP 请求传入了非预期的参数，并借助这些参数 create 方法更改了数据库中你并不打算要更改的字段，这时就会出现批量赋值（Mass-Assignment）漏洞，所以你需要先在模型上定义一个 fillable(白名单，允许批量赋值字段名数组)或guarded(黑名单，禁止批量赋值字段名数组) // 用属性取回航班，当结果不存在时创建它... $flight = App\Flight::firstOrCreate([&apos;name&apos; =&gt; &apos;Flight0&apos;]); // 用属性取回航班，当结果不存在时实例化一个新实例... $flight = App\Flight::firstOrNew([&apos;name&apos; =&gt; &apos;Flight0&apos;]); 模型软删除：如果模型有一个非空值 deleted_at，代表模型已经被软删除了。要在模型上启动软删除，则必须在模型上使用Illuminate\Database\Eloquent\SoftDeletes trait 并添加 deleted_at 字段到你的模型 $dates 属性上和数据表中，通过调用trashed方法可查询模型是否被软删除 &lt;?php namespace App; use Illuminate\Database\Eloquent\Model; use Illuminate\Database\Eloquent\SoftDeletes; class Flight extends Model { use SoftDeletes; /** * 需要被转换成日期的属性。 * * @var array */ protected $dates = [&apos;deleted_at&apos;]; } 查询作用域：Laravel允许对模型设定全局作用域和本地作用域(包括动态范围)，全局作用域允许我们为模型的所有查询添加条件约束(定义一个实现 Illuminate\Database\Eloquent\Scope 接口的类)，而本地作用域允许我们在模型中定义通用的约束集合(模型方法前加上一个 scope 前缀)。作用域总是返回查询构建器 全局作用域定义： &lt;?php namespace App\Scopes; use Illuminate\Database\Eloquent\Scope; use Illuminate\Database\Eloquent\Model; use Illuminate\Database\Eloquent\Builder; class AgeScope implements Scope { /** * 应用作用域 * * @param \Illuminate\Database\Eloquent\Builder $builder * @param \Illuminate\Database\Eloquent\Model $model * @return void */ public function apply(Builder $builder, Model $model) { return $builder-&gt;where(&apos;age&apos;, &apos;&gt;&apos;,00); } } 本地作用域： &lt;?php namespace App; 0 use Illuminate\Database\Eloquent\Model; class User extends Model { /** * 限制查询只包括受欢迎的用户。 * * @return \Illuminate\Database\Eloquent\Builder */ public function scopePopular($query) 0 { return $query-&gt;where(&apos;votes&apos;, &apos;&gt;&apos;,00); } /** * 限制查询只包括活跃的用户。 * * @return \Illuminate\Database\Eloquent\Builder */ public function scopeActive($query) 0 { return $query-&gt;where(&apos;active&apos;,); } } 动态范围： &lt;?php namespace App; 0 use Illuminate\Database\Eloquent\Model; class User extends Model { /** * 限制查询只包括指定类型的用户。 * * @return \Illuminate\Database\Eloquent\Builder */ public function scopeOfType($query, $type) 0 { return $query-&gt;where(&apos;type&apos;, $type); } } 隐藏和显示属性：模型 hidden属性用于隐藏属性和关联的输出， visible 属性用于显示属性和关联的输出，另外makeVisible()还可用来临时修改可见性。当你要对关联进行隐藏时，需使用关联的方法名称，而不是它的动态属性名称 &lt;?php namespace App; use Illuminate\Database\Eloquent\Model; class User extends Model { /** * 在数组中可见的属性。 * * @var array */ protected $visible = [&apos;first_name&apos;, &apos;last_name&apos;]; } ?&gt; //makeVisible()用来临时修改可见性 return $user-&gt;makeVisible(&apos;attribute&apos;)-&gt;toArray(); 访问器和修改器：访问器(getFooAttribute)和修改器(setFooAttribute)可以让你修改 Eloquent 模型中的属性或者设置它们的值，比如你想要使用 Laravel 加密器来加密一个被保存在数据库中的值，当你从 Eloquent 模型访问该属性时该值将被自动解密。访问器和修改器要遵循cameCase命名规范，修改器会设置值到 Eloquent 模型内部的 $attributes 属性上 &lt;?php namespace App; use Illuminate\Database\Eloquent\Model; class User extends Model { /** * 获取用户的名字。 * * @param string $value * @return string */ public function getFirstNameAttribute($value) { return ucfirst($value); } 0 /** * 设定用户的名字。 * * @param string $value * @return void */ public function setFirstNameAttribute($value) { $this-&gt;attributes[&apos;first_name&apos;] = strtolower($value); } 0 } 而对于访问器与修改器的调用将是模型对象自动进行的 $user = App\User::find(); $user-&gt;first_name = &apos;Sally&apos;;//将自动调用相应的修改器 $firstName = $user-&gt;first_name;//将自动调用相应的访问器 追加属性：在转换模型到数组或JSON时，你希望添加一个在数据库中没有对应字段的属性，首先你需要为这个值定义一个 访问器，然后添加该属性到改模型的 appends 属性中 &lt;?php namespace App; use Illuminate\Database\Eloquent\Model; class User extends Model { /** * 访问器被附加到模型数组的形式。 * * @var array */ protected $appends = [&apos;is_admin&apos;]; /** * 为用户获取管理者的标记。 * * @return bool 0 */ public function getIsAdminAttribute() { return $this-&gt;attributes[&apos;admin&apos;] == &apos;yes&apos;; } } 属性类型转换：$casts 属性数组在模型中提供了将属性转换为常见的数据类型的方法，且键是那些需要被转换的属性名称，值则是代表字段要转换的类型。支持的转换的类型有：integer、real、float、double、string、boolean、object、array、collection、date、datetime、timestamp &lt;?php namespace App; use Illuminate\Database\Eloquent\Model; class User extends Model { /** * 应该被转换成原生类型的属性。 * * @var array */ protected $casts = [ &apos;is_admin&apos; =&gt; &apos;boolean&apos;,//is_admin 属性以整数（0 或）被保存在我们的数据库中，把它转换为布尔值 ]; } 序列化：Laravel模型及关联可递归序列化成数组或JSON //单个模型实例序列化成数组 $user = App\User::with(&apos;roles&apos;)-&gt;first(); return $user-&gt;toArray(); //集合序列化成数组 $users = App\User::all(); return $users-&gt;toArray(); //单个模型实例序列化成JSON $user = App\User::find(); return $user-&gt;toJson(); //直接进行string转换会将模型或集合序列化成JSON $user = App\User::find(); return (string) $user; //因此你可以直接从应用程序的路由或者控制器中返回 Eloquent 对象 Route::get(&apos;users&apos;, function () { return App\User::all(); }); 关联(方法)与动态属性：在 Eloquent 模型中，关联被定义成方法（methods），也可以作为强大的查询语句构造器 $user-&gt;posts()-&gt;where(&apos;active&apos;,)-&gt;get(); Eloquent 模型支持多种类型的关联：一对一、一对多、多对多、远层一对多、多态关联、多态多对多关联举个例子，一个 User 模型会关联一个 Phone 模型，一对一关联(hasOne) &lt;?php namespace App; use Illuminate\Database\Eloquent\Model; class User extends Model { /** * 获取与用户关联的电话号码 */ public function phone() { return $this-&gt;hasOne(&apos;App\Phone&apos;); } } 动态属性允许你访问关联方法，使用 Eloquent 的动态属性来获取关联记录，如同他们是定义在模型中的属性 $phone = User::find()-&gt;phone; Eloquent 会假设对应关联的外键名称是基于模型名称的。在这个例子里，它会自动假设 Phone 模型拥有 user_id 外键。如果你想要重写这个约定，则可以传入第二个参数到 hasOne 方法里 return $this-&gt;hasOne(&apos;App\Phone&apos;, &apos;foreign_key&apos;); 如果你想让关联使用 id 以外的值，则可以传递第三个参数至 hasOne 方法来指定你自定义的键 return $this-&gt;hasOne(&apos;App\Phone&apos;, &apos;foreign_key&apos;, &apos;local_key&apos;); 如果我们要在 Phone 模型上定义一个反向关联，此关联能够让我们访问拥有此电话的 User 模型。我们可以定义与 hasOne 关联相对应的 belongsTo 方法 &lt;?php namespace App; use Illuminate\Database\Eloquent\Model; class Phone extends Model { /** * 获取拥有该电话的用户模型。 */ public function user() { return $this-&gt;belongsTo(&apos;App\User&apos;); } } 模型事件：Laravel为模型定义的事件包括creating, created, updating, updated, saving, saved, deleting, deleted, restoring, restored。 模型上定义一个 $events 属性 &lt;?php namespace App; use App\Events\UserSaved; use App\Events\UserDeleted; use Illuminate\Notifications\Notifiable; use Illuminate\Foundation\Auth\User as Authenticatable; class User extends Authenticatable { use Notifiable; /** * 模型的时间映射。 * * @var array */ protected $events = [ 0 &apos;saved&apos; =&gt; UserSaved::class, &apos;deleted&apos; =&gt; UserDeleted::class, ]; } 如果你在一个给定的模型中监听许多事件，也可使用观察者将所有监听器变成一个类，类的一个方法就是一个事件监听器 定义观察者： &lt;?php namespace App\Observers; use App\User; class UserObserver { /** * 监听用户创建的事件。 * * @param User $user * @return void */ public function created(User $user) { // } 0 /** * 监听用户删除事件。 * * @param User $user * @return void */ public function deleting(User $user) { // 0 } } 注册观察者： &lt;?php namespace App\Providers; use App\User; use App\Observers\UserObserver; 0 use Illuminate\Support\ServiceProvider; class AppServiceProvider extends ServiceProvider { /** * 运行所有应用. * * @return void */ public function boot() 0 { User::observe(UserObserver::class); } /** * 注册服务提供. * * @return void */ public function register() 0 { // } } 八. Laravel的Restful风格 一般认为Restful风格的资源定义不包含操作，但是在Laravel中操作(动词)也可作为一种资源来定义。下图是对Laravel中资源控制器操作原理的描述，可以看到，create、edit就直接出现在了URI中，它们是一种合法的资源。 对于create和edit这两种资源的访问都采用GET方法来实现，第一眼看到顿感奇怪，后来尝试通过artisan console生成资源控制器，并注意到其对create、edit给出注释“ Show the form for ”字样，方知它们只是用来展现表单而非提交表单的。 关于POST与PUT方法的差异的讨论，多认为它们都可用于创建和修改数据，主要在于POST是非幂等操作而PUT是幂等操作。 九. 扩展开发 我们知道，Laravel本身是基于Composer管理的一个包，遵循Composer的相关规范，可以通过Composer来添加所依赖的其他Composer包，因此在做应用的扩展开发时，可以开发Composer包然后引入项目中即可；另外也可开发基于Laravel的专属扩展包。下面所讲的就是Laravel的专属扩展开发，最好的方式是使用 contracts ，而不是 facades，因为你开发的包并不能访问所有 Laravel 提供的测试辅助函数，模拟 contracts 要比模拟 facade 简单很多。 服务提供者：服务提供者是你的扩展包与 Laravel 连接的重点，须定义自己的服务提供者并继承自 Illuminate\Support\ServiceProvider 基类 路由：若要为你的扩展包定义路由，只需在包的服务提供者的 boot 方法中传递 routes 文件路径到 loadRoutesFrom 方法即可 /** * 在注册后进行服务的启动。 * * @return void */ public function boot() { $this-&gt;loadRoutesFrom(__DIR__.&apos;/path/to/routes.php&apos;); } 配置文件：你可以选择性地将扩展包的配置文件发布(publishes)到应用程序本身的config目录上或者合并(mergeConfigFrom)到应用程序里的副本配置文件中，但不应在配置文件中定义闭包函数，当执行 config:cache Artisan命令时，它们将不能正确地序列化 /** * 在注册后进行服务的启动。 * * 用户使用 vendor:publish 命令可将扩展包的文件将会被复制到指定的位置上。 * * @return void */ public function boot() { $this-&gt;publishes([ __DIR__.&apos;/path/to/config/courier.php&apos; =&gt; config_path(&apos;courier.php&apos;), ]); } $value = config(&apos;courier.option&apos;);//只要你的配置文件被发布，就可以如其它配置文件一样被访问 /** * 或者选择性在容器中注册绑定。 * 0 * 此方法仅合并配置数组的第一级。如果您的用户部分定义了多维配置数组，则不会合并缺失的选项 * * @return void */ public function register() { $this-&gt;mergeConfigFrom( __DIR__.&apos;/path/to/config/courier.php&apos;, &apos;courier&apos; ); } 数据库迁移：如果你的扩展包包含数据库迁移，需要使用 loadMigrationsFrom 方法告知 Laravel 如何去加载它们。在运行 php artisan migrate 命令时，它们就会自动被执行，不需要把它们导出到应用程序的 database/migrations 目录 /** * 在注册后进行服务的启动。 * * @return void */ public function boot() { $this-&gt;loadMigrationsFrom(__DIR__.&apos;/path/to/migrations&apos;); } 语言包：如果你的扩展包里面包含了本地化，则可以使用 loadTranslationsFrom 方法来告知 Laravel 该如何加载它们。下例假设你的包名称为courier /** * 在注册后进行服务的启动。 * * @return void */ public function boot() { $this-&gt;loadTranslationsFrom(__DIR__.&apos;/path/to/translations&apos;, &apos;courier&apos;); //如果不想发布语言包至应用程序的 resources/lang/vendor 目录，请注销对$this-&gt;publishes()调用。运行 Laravel 的 vendor:publish Artisan 命令可将扩展包的语言包复制到指定的位置上 $this-&gt;publishes([ __DIR__.&apos;/path/to/translations&apos; =&gt; resource_path(&apos;lang/vendor/courier&apos;), ]); } echo trans(&apos;courier::messages.welcome&apos;);//扩展包翻译参照使用了双分号 package::file.line 语法 视图：若要在 Laravel 中注册扩展包 视图，则必须告诉 Laravel 你的视图位置，loadViewsFrom 方法允许传递视图模板路径与扩展包名称两个参数。需要特别指出的是，当你使用 loadViewsFrom 方法时，Laravel 实际上为你的视图注册了两个位置：一个是应用程序的 resources/views/vendor 目录，另一个是你所指定的目录。Laravel会先检查 resources/views/vendor 目录是否存在待加载视图，如果不存在，才会从指定的目录去加载，这个方法可以让用户很方便的自定义或重写扩展包视图。 /** * 在注册后进行服务的启动。 * * @return void */ public function boot() { $this-&gt;loadViewsFrom(__DIR__.&apos;/path/to/views&apos;, &apos;courier&apos;); //若要发布扩展包的视图至 resources/views/vendor 目录，则必须使用服务提供者的 publishes 方法。运行 Laravel 的 vendor:publish Artisan 命令时，扩展包的视图将会被复制到指定的位置上 $this-&gt;publishes([ __DIR__.&apos;/path/to/views&apos; =&gt; resource_path(&apos;views/vendor/courier&apos;), ]); } //扩展包视图参照使用了双分号 package::view 语法 Route::get(&apos;admin&apos;, function () { return view(&apos;courier::admin&apos;); }); 命令：使用 commands 方法给扩展包注册 Artisan 命令，命令的定义要遵循Laravel Artisan 命令规范 /** * 在注册后进行服务的启动。 * * @return void */ public function boot() { if ($this-&gt;app-&gt;runningInConsole()) { $this-&gt;commands([ FooCommand::class, BarCommand::class, ]); } } 公用 Assets：你可以发布像 JavaScript、CSS 和图片这些资源文件到应用程序的 public 目录上。当用户执行 vendor:publish 命令时，您的 Assets 将被复制到指定的发布位置。由于每次更新包时通常都需要覆盖资源，因此您可以使用 –force 标志：php artisan vendor:publish –tag=public –force /** * 在注册后进行服务的启动。 * * @return void */ public function boot() { $this-&gt;publishes([ __DIR__.&apos;/path/to/assets&apos; =&gt; public_path(&apos;vendor/courier&apos;), ], &apos;public&apos;); } 发布群组文件：你可能想让用户不用发布扩展包的所有资源文件，只需要单独发布扩展包的配置文件即可，通过在调用 publishes 方法时使用标签来实现 /** * 在注册后进行服务的启动。 * * @return void */ public function boot() { $this-&gt;publishes([ __DIR__.&apos;/../config/package.php&apos; =&gt; config_path(&apos;package.php&apos;) ], &apos;config&apos;); $this-&gt;publishes([ __DIR__.&apos;/../database/migrations/&apos; =&gt; database_path(&apos;migrations&apos;) ], &apos;migrations&apos;); } 对于上例运行命令 php artisan vendor:publish –tag=config 时将忽略掉migrations部分]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin——和Swift像得一塌糊涂]]></title>
    <url>%2F2017%2F05%2F18%2Fkotlin%E2%80%94%E2%80%94%E5%92%8CSwift%E5%83%8F%E5%BE%97%E4%B8%80%E5%A1%8C%E7%B3%8A%E6%B6%82%2F</url>
    <content type="text"><![CDATA[今天大概看了一下网上关于Google I/O的详细内容，当然主要还是关于kotlin，随便找打之前的的小demo，突然又想到上周深圳的Swift大会，顿时感觉以后Swift和kotlin与占有很大一部分市场，就寻找了一份关于kotlin和Swift代码的异同之处，也好方便kotlin和Swift程序员区分与学习….. | | | 下面是一些关于Swift和Kotlin语法和细节上的区别，出自网络！ Hello WorldSwiftprint(&quot;Hello, world!&quot;) kotlinprintln(&quot;Hello, world!&quot;) Variables And ConstantsSwiftvar myVariable = 42 myVariable = 50 let myConstant = 42 kotlinvar myVariable = 42 myVariable = 50 val myConstant = 42 Explicit TypesSwiftlet explicitDouble: Double = 70 kotlinval explicitDouble: Double = 70.0 Type CoercionSwiftlet label = &quot;The width is &quot; let width = 94 let widthLabel = label + String(width) kotlinval label = &quot;The width is &quot; val width = 94 val widthLabel = label + width String InterpolationSwiftlet apples = 3 let oranges = 5 let fruitSummary = &quot;I have \(apples + oranges) &quot; + &quot;pieces of fruit.&quot; kotlinval apples = 3 val oranges = 5 val fruitSummary = &quot;I have ${apples + oranges} &quot; + &quot;pieces of fruit.&quot; Range OperatorSwiftlet names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;] let count = names.count for i in 0..&lt;count { print(&quot;Person \(i + 1) is called \(names[i])&quot;) } // Person 1 is called Anna // Person 2 is called Alex // Person 3 is called Brian // Person 4 is called Jack kotlinval names = arrayOf(&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;) val count = names.count() for (i in 0..count - 1) { println(&quot;Person ${i + 1} is called ${names[i]}&quot;) } // Person 1 is called Anna // Person 2 is called Alex // Person 3 is called Brian // Person 4 is called Jack Inclusive Range OperatorSwiftfor index in 1...5 { print(&quot;\(index) times 5 is \(index * 5)&quot;) } // 1 times 5 is 5 // 2 times 5 is 10 // 3 times 5 is 15 // 4 times 5 is 20 // 5 times 5 is 25 kotlinfor (index in 1..5) { println(&quot;$index times 5 is ${index * 5}&quot;) } // 1 times 5 is 5 // 2 times 5 is 10 // 3 times 5 is 15 // 4 times 5 is 20 // 5 times 5 is 25 ArraysSwiftvar shoppingList = [&quot;catfish&quot;, &quot;water&quot;, &quot;tulips&quot;, &quot;blue paint&quot;] shoppingList[1] = &quot;bottle of water&quot; ### kotlin val shoppingList = arrayOf(&quot;catfish&quot;, &quot;water&quot;, &quot;tulips&quot;, &quot;blue paint&quot;) shoppingList[1] = &quot;bottle of water&quot; MapsSwiftvar occupations = [ &quot;Malcolm&quot;: &quot;Captain&quot;, &quot;Kaylee&quot;: &quot;Mechanic&quot;, ] occupations[&quot;Jayne&quot;] = &quot;Public Relations&quot; kotlinval occupations = mutableMapOf( &quot;Malcolm&quot; to &quot;Captain&quot;, &quot;Kaylee&quot; to &quot;Mechanic&quot; ) occupations[&quot;Jayne&quot;] = &quot;Public Relations&quot; Empty CollectionsSwiftlet emptyArray = [String]() let emptyDictionary = [String: Float]() kotlinval emptyArray = arrayOf&lt;String&gt;() val emptyMap = mapOf&lt;String, Float&gt;() FunctionsSwiftfunc greet(_ name: String,_ day: String) -&gt; String { return &quot;Hello \(name), today is \(day).&quot; } greet(&quot;Bob&quot;, &quot;Tuesday&quot;) kotlinfun greet(name: String, day: String): String { return &quot;Hello $name, today is $day.&quot; } greet(&quot;Bob&quot;, &quot;Tuesday&quot;) Tuple ReturnSwiftfunc getGasPrices() -&gt; (Double, Double, Double) { return (3.59, 3.69, 3.79) } kotlindata class GasPrices(val a: Double, val b: Double, val c: Double) fun getGasPrices() = GasPrices(3.59, 3.69, 3.79) Variable Number Of ArgumentsSwiftfunc sumOf(_ numbers: Int...) -&gt; Int { var sum = 0 for number in numbers { sum += number } return sum } sumOf(42, 597, 12) kotlinfun sumOf(vararg numbers: Int): Int { var sum = 0 for (number in numbers) { sum += number } return sum } sumOf(42, 597, 12) // sumOf() can also be written in a shorter way: fun sumOf(vararg numbers: Int) = numbers.sum() Function TypeSwiftfunc makeIncrementer() -&gt; (Int -&gt; Int) { func addOne(number: Int) -&gt; Int { return 1 + number } return addOne } let increment = makeIncrementer() increment(7) kotlinfun makeIncrementer(): (Int) -&gt; Int { val addOne = fun(number: Int): Int { return 1 + number } return addOne } val increment = makeIncrementer() increment(7) // makeIncrementer can also be written in a shorter way: fun makeIncrementer() = fun(number: Int) = 1 + number MapSwiftlet numbers = [20, 19, 7, 12] numbers.map { 3 * $0 } kotlinval numbers = listOf(20, 19, 7, 12) numbers.map { 3 * it } Sort Swiftvar mutableArray = [1, 5, 3, 12, 2] mutableArray.sort() kotlinlistOf(1, 5, 3, 12, 2).sorted() Named ArgumentsSwiftfunc area(width: Int, height: Int) -&gt; Int { return width * height } area(width: 2, height: 3) kotlinfun area(width: Int, height: Int) = width * height area(width = 2, height = 3) // This is also possible with named arguments area(2, height = 2) area(height = 3, width = 2) DeclarationSwiftclass Shape { var numberOfSides = 0 func simpleDescription() -&gt; String { return &quot;A shape with \(numberOfSides) sides.&quot; } } kotlinclass Shape { var numberOfSides = 0 fun simpleDescription() = &quot;A shape with $numberOfSides sides.&quot; } UsageSwiftvar shape = Shape() shape.numberOfSides = 7 var shapeDescription = shape.simpleDescription() kotlinvar shape = Shape() shape.numberOfSides = 7 var shapeDescription = shape.simpleDescription() SubclassSwiftclass NamedShape { var numberOfSides: Int = 0 let name: String init(name: String) { self.name = name } func simpleDescription() -&gt; String { return &quot;A shape with \(numberOfSides) sides.&quot; } } class Square: NamedShape { var sideLength: Double init(sideLength: Double, name: String) { self.sideLength = sideLength super.init(name: name) self.numberOfSides = 4 } func area() -&gt; Double { return sideLength * sideLength } override func simpleDescription() -&gt; String { return &quot;A square with sides of length &quot; + sideLength + &quot;.&quot; } } let test = Square(sideLength: 5.2, name: &quot;square&quot;) test.area() test.simpleDescription() kotlinopen class NamedShape(val name: String) { var numberOfSides = 0 open fun simpleDescription() = &quot;A shape with $numberOfSides sides.&quot; } class Square(var sideLength: BigDecimal, name: String) : NamedShape(name) { init { numberOfSides = 4 } fun area() = sideLength.pow(2) override fun simpleDescription() = &quot;A square with sides of length $sideLength.&quot; } val test = Square(BigDecimal(&quot;5.2&quot;), &quot;square&quot;) test.area() test.simpleDescription() Checking TypeSwiftvar movieCount = 0 var songCount = 0 for item in library { if item is Movie { movieCount += 1 } else if item is Song { songCount += 1 } } kotlinvar movieCount = 0 var songCount = 0 for (item in library) { if (item is Movie) { ++movieCount } else if (item is Song) { ++songCount } } Pattern MatchingSwiftlet nb = 42 switch nb { case 0...7, 8, 9: print(&quot;single digit&quot;) case 10: print(&quot;double digits&quot;) case 11...99: print(&quot;double digits&quot;) case 100...999: print(&quot;triple digits&quot;) default: print(&quot;four or more digits&quot;) } kotlinval nb = 42 when (nb) { in 0..7, 8, 9 -&gt; println(&quot;single digit&quot;) 10 -&gt; println(&quot;double digits&quot;) in 11..99 -&gt; println(&quot;double digits&quot;) in 100..999 -&gt; println(&quot;triple digits&quot;) else -&gt; println(&quot;four or more digits&quot;) } DowncastingSwiftfor current in someObjects { if let movie = current as? Movie { print(&quot;Movie: &apos;\(movie.name)&apos;, &quot; + &quot;dir. \(movie.director)&quot;) } } kotlinfor (current in someObjects) { if (current is Movie) { println(&quot;Movie: &apos;${current.name}&apos;, &quot; + &quot;dir. ${current.director}&quot;) } } ProtocolSwiftprotocol Nameable { func name() -&gt; String } func f&lt;T: Nameable&gt;(x: T) { print(&quot;Name is &quot; + x.name()) } kotlininterface Nameable { fun name(): String } fun f&lt;T: Nameable&gt;(x: T) { println(&quot;Name is &quot; + x.name()) } Extensions### Swiftextension Double { var km: Double { return self * 1_000.0 } var m: Double { return self } var cm: Double { return self / 100.0 } var mm: Double { return self / 1_000.0 } var ft: Double { return self / 3.28084 } } let oneInch = 25.4.mm print(&quot;One inch is \(oneInch) meters&quot;) // prints &quot;One inch is 0.0254 meters&quot; let threeFeet = 3.ft print(&quot;Three feet is \(threeFeet) meters&quot;) // prints &quot;Three feet is 0.914399970739201 meters&quot; kotlinval Double.km: Double get() = this * 1000 val Double.m: Double get() = this val Double.cm: Double get() = this / 100 val Double.mm: Double get() = this / 1000 val Double.ft: Double get() = this / 3.28084 val oneInch = 25.4.mm println(&quot;One inch is $oneInch meters&quot;) // prints &quot;One inch is 0.0254 meters&quot; val threeFeet = 3.0.ft println(&quot;Three feet is $threeFeet meters&quot;) // prints &quot;Three feet is 0.914399970739201 meters&quot;]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>kotlin——和Swift像得一塌糊涂</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin——要火了❤️，你还在等什么？]]></title>
    <url>%2F2017%2F05%2F18%2Fkotlin%E2%80%94%E2%80%94%E8%A6%81%E7%81%AB%E4%BA%86%E2%9D%A4%EF%B8%8F%EF%BC%8C%E4%BD%A0%E8%BF%98%E5%9C%A8%E7%AD%89%E4%BB%80%E4%B9%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[其实在去年我就开发在了解Kotlin，只是由于项目的原因，还有一些人根本不知道他的存在，然后推荐给了不少人，都被否决了！ 百度发音：kotlin——科特林 前言： 今早睡一醒来打开手机一看，发现朋友圈被刷屏了！ 其实在去年我就开发在了解Kotlin，只是由于项目的原因，还有一些人根本不知道他的存在，然后推荐给了不少人，都被否决了！ kotlin要火了，昨晚的Google I/O大会，Google宣布正式其实kotlin。 这个小时对几乎所有Android的猿类来说，应该是最震惊的，为什么呢？ 因为你又有一门新的语言可以学习了，就像Swift对iOS程序员的意义意义！ 当然这个消息不仅对Android程序员比较震惊，对几乎所有做iOS开发的程序也是一个值得关注的消息？为什么呢？ 那你的问问Swift为什么和他长得这么像！ 先来看看昨晚Google I/O 2017有哪些亮点？TPU（用于深度学习的处理器） Google Lens （新API，摄像头直接支持图像识别） Google Assistan新功能 Google Home新功能 Google Photos新功能 Android支持分屏 Android支持Kotlin开发 Tango（AR）进展 Daydream（VR）进展 Google工作搜索 想了解更多请看官方发布视频与相关总结！ 有人用一句话总结AI已经无处不在了 这里是主要阐述kotlin的，上面两点中“Android支持Kotlin开发”也是我非常关注和值得开心的一件！ 所以，Let`s Go首先有任何想了解kotlin的，建议最好先看官方教程：http://kotlinlang.org/ Kotlin是什么Kotlin 是一个基于 JVM 的新的编程语言，由 JetBrains 开发。 Kotlin可以编译成Java字节码，也可以编译成JavaScript，方便在没有JVM的设备上运行。 JetBrains，作为目前广受欢迎的Java IDE IntelliJ 的提供商，在 Apache 许可下已经开源其Kotlin 编程语言。 众所周知Android程序是运行在Java虚拟机之上的，因此从技术上来说，可以运行在JVM之上的一切都可用于开发Android应用。现在已经有很多可以生成JVM能够执行的字节码的语言，其中一些语言开始崭露头角并逐步流行起来。现存的计算机编程语言有好几千种，JVM上的语言也有十几种(比如NBJL/Clojure/Groovy/Scala/Fantom)，所以大可不必为没听说过的编程语言感到惊奇,我也就听过Groovy/Scala/Kotlin，scala比较和C语言接近，而Groovy和java很相似你肯定对gradle不陌生吧，但是Kotlin就是其中的佼佼者。 近日召开的 Google IO 2017 ， Google 将 Kotlin 列为 Android 官方开发语言了，Android Studio 3.0 也默认集成了 Kotlin plugin kotlin的历史历史2011 年 7 月，JetBrains 推出 Kotlin 项目，这是一个面向 JVM 的新语言，它已被开发一年之久。JetBrains 负责人Dmitry Jemerov 说，大多数语言没有他们正在寻找的特性，Scala 除外，他指出了 Scala 的编译时间慢这一明显缺陷。Kotlin 的既定目标之一是像 Java 一样快速编译。 2012 年 2 月，JetBrains 以 Apache 2 许可证开源此项目，Jetbrains 希望这个新语言能够推动 IntelliJ IDEA 的销售。 Kotlin v1.0 于 2016 年 2 月 15 日发布。这被认为是第一个官方稳定版本，并且 JetBrains 已准备从该版本开始的长期向后兼容性。 在 Google I/O 2017 中，Google 宣布在 Android 上为 Kotlin 提供支持。 Kotlin设计的目的创建一种兼容Java的语言 让它比Java更安全，能够静态检测常见的陷阱。如：引用空指针 让它比Java更简洁，通过支持variable type inference，higher-order functions (closures)，extension functions，mixins and first-class delegation等实现。 让它比最成熟的竞争对手Scala语言更加简单 java的缺陷：对象可以赋值null造成NPE 受检异常(checked exception) 属性getter，setter太烦 接口不能有实现（java8 fixed） 缺乏Lambda(java8 fixed) 方法Overloading对可读性和动态调用造成伤害。 语言层缺乏模块化支持 并发支持很糟糕 原始类型不是对象&gt; Kotlin优势：创建一种兼容Java的语言 让它比Java更安全，能够静态检测常见的陷阱。如：引用空指针 让 它比Java更简洁，通过支持variable type inference，higher-order functions (closures)，extension functions，mixins and first-class delegation等实现。 语言特性轻量级： 这一点对于Android来说非常重要。项目所需要的库应该尽可能的小。Android对于方法数量有严格的限制，Kotlin只额外增加了大约6000个方法。 互操作： Kotlin可与Java语言无缝通信。这意味着我们可以在Kotlin代码中使用任何已有的Java库；因此，即便这门语言还很年轻，但却已经可以使用成百上千的库了。除此之外，Kotlin代码还可以为Java代码所用，这意味着我们可以使用这两种语言来构建软件。你可以使用Kotlin开发新特性，同时使用Java实现代码基的其他部分。 强类型： 我们很少需要在代码中指定类型，因为编译器可以在绝大多数情况下推断出变量或是函数返回值的类型。这样就能获得两个好处：简洁与安全。 Null安全： Java最大的一个问题就是null。如果没有对变量或是参数进行null判断，那么程序当中就有可能抛出大量的NullPointerException，然而在编码时这些又是难以检测到的。Kotlin使用了显式的null，这会强制我们在必要时进行null检查。 适用平台只要能用Java的地方就能用Kotlin， Kotlin支持所有主要的开发工具以及服务，比如： * IntelliJ IDEA、Android Studio和Eclipse； * Maven、Gradle和Ant； * spring Boot（Kotlin 支持今天正式发布！）； * GitHub，Slack，甚至Minecraft。 分类整理一下 Kotlin VS Java语法简单不啰嗦Kotlin的一个主要优点是它的简洁。 你用更少的代码获得更多的功能。 ① Kotlin 支持类型推断，没有 Java 那样的啰嗦。 ② 用 var 表示变量，val 表示常量更加的简洁 ③ 方法也很简单，连 function 都缩写成了 fun ④ 类的继承和实现很简单，使用:即可 ⑤ Kotlin 每个句子都不需要加分号 (;) 避免空指针异常在许多编程语言中最大的痛苦 - 空指针异常。 但是使用Kotlin，这个问题得到了很好的解决 ① 在类型上的处理，即在类型后面加上?，即表示这个变量或参数以及返回值可以为 null，否则不允许为变量参数赋值为 null 或者返回 null ② 对于一个可能是 null 的变量或者参数，在调用对象方法或者属性之前，需要加上?，否则编译无法通过。 支持方法拓展Kotlin有一个聪明的解决方案 - 扩展功能 ，帮助你摆脱所有的util类一劳永逸。扩展函数几乎是一个通常的Kotlin函数。 但是当你声明它，你需要指定的实例将具有扩展功能的类。 注意：Kotlin 的方法扩展并不是真正修改了对应的类文件，而是在编译器和 IDE 方面做得处理。使我们看起来像是扩展了方法。 高阶函数， 函数式编程支持所谓的高阶函数就是：可以接受函数作为参数，也可以返回函数作为结果。 Kotlin 支持了 Streams API 和方法引用，这样函数式编程更加方便。比如下面的代码就是我们结合 Jsoup，来抓取某个 proxy 网站的数据，代码更加简单，实现起来也快速。 关于性能Kotlin 的执行效率和 Java 代码的执行效率理论上一致的。有时候 Kotlin 可能会显得高一些。比如 Kotlin 提供了方法的 inline 设置，可以设置某些高频方法进行 inline 操作，减少了运行时的进栈出栈和保存状态的开销。 与Java互操作Kotlin 在设计时就考虑了 Java 互操作性。可以从 Kotlin 中自然地调用现存的 Java 代码，并且在 Java 代码中也可以 很顺利地调用 Kotlin 代码。 总结Kotlin的特性有很多，总的来说， Kotlin这门语言简化了Java , 完全是从一个是实用派的角度，而不是学院派的角度。 相比于JRuby , Jython这些一移植到JVM上的语言， Kotlin 和Java 和互操作感觉更加自然。 每个语言的流行都需要一个引爆点，就像Ruby on Rails 引爆了Ruby 一样， Android 也许就是之前不那么流行的Kotlin的引爆点。 这里有一篇不错的入门实战教程，非常简单：http://www.jianshu.com/p/cf1f96c56150 Kotlin这里就不说了，太乏味了，最后一句话总结一下kotlin Android届的Swift（请深刻理解其中的含义） 各位Android的同仁们，是时候了，不管是为了喜好还是为了以后的规划，你都应该停下手上的活，抽出一切空余时间进攻kotlin，相信我，不学你会后悔的，哈哈！当然有机会我也会去了解，接触一些kotlin开发的知识，哪怕我不会转到哪上面去，这就是我们所谓的广度优先！ 如果想简单入门kotlin语法和一些特点可以看这里：http://www.jianshu.com/p/1ea733ea197d 学习资源： 1.kotlin官方中文翻译文档网址 2.Kotlin官网 3.kotlin中文官网 4.kotlin的gitbook网址 在线学习 Kotlin官方文档]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
        <tag>kotlin——要火了❤️，你还在等什么？</tag>
        <tag>Google I/O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel5实战文档]]></title>
    <url>%2F2017%2F05%2F17%2FLaravel5%E5%AE%9E%E6%88%98%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[Laravel 从2.0开始就被不少程序员所熟知并流行起来。目前最新的版本是5.0。Laravel 3.x 与之后的 4.x 和 5.x有着非常大的变化。通过官方文档或中文社区的文档可以看得出来。 更多相关更查看官方文档 中文文档地址：点击查看 因为 Laravel 4.x出来的时间不是特别长，以及 Laravel 5.x 比 4.x 在更优秀。所以，我们研究与使用就以 5.x 为基准。 一、安装 ComposerComposer 是 PHP 用来管理依赖（dependency）关系的工具。你可以在自己的项目中声明所依赖的外部工具库（libraries），Composer 会帮你安装这些依赖的库文件。 关于 Composer 的中文文档地址：http://www.phpcomposer.com/ Linux &amp; Mac 安装方式123$ sudo -s$ curl -sS https://getcomposer.org/installer | php$ mv composer.phar /usr/local/bin/composer 如果您的 Composer 版本过低，则会有警告提示。通过如此命令升级您的 Composer 1sudo /usr/local/bin/composer self-update 关于 Composer 的命令操作以及包加载的优化，请查看上面的地址。 二、PHP 环境需求 PHP 版本 &gt;= 5.4 Mcrypt PHP 扩展。此扩展是用来加密解密用的。支持多种加密方式。 OpenSSL PHP 扩展。为 https 提供驱动支持。当然，还有更多功能。 Mbstring PHP 扩展。处理各国语言字符的扩展。 Tokenizer PHP 扩展。PHP 源码分析工具。 三、Laravel 框架出击1）使用 Composer 下载 Laravel 安装包：1composer global require "laravel/installer=~1.1" 以上命令在任何位置执行都可以。是全局有效。提示：如果网络不好。请任性地使用VPN吧。没有？买呗！！！ 命令正常执行，会有如下输出： 1234567891011121314151617181920212223Changed current directory to /Users/qlj/.composer./composer.json has been updatedLoading composer repositories with package informationUpdating dependencies (including require-dev) - Installing symfony/process (v2.6.5) Downloading: 100% - Installing symfony/console (v2.6.5) Downloading: 100% - Installing guzzlehttp/streams (2.1.0) Loading from cache - Installing guzzlehttp/guzzle (4.2.3) Loading from cache - Installing laravel/installer (v1.2.0) Downloading: 100%symfony/console suggests installing symfony/event-dispatcher ()symfony/console suggests installing psr/log (For using the console logger)Writing lock fileGenerating autoload files 请确定把 ~/.composer/vendor/bin 路径放置于您的 PATH 里， 这样 laravel 执行文件就会存在你的系统。 2）mac 下将 laravel 放到系统 PATH 变量中1vim ~/.bash_profile 在文件末尾追加以下代码： 1export PATH=/Users/qlj/.composer/vendor/bin:$PATH 小贴士：mac和linux终端一般用bash来进行解析。当bash在读完了整体环境变量的/etc/profile并借此调用其他配置文件后，接下来则是会读取用户自定义的个人配置文件。bash读取的文件总共有三种： ~/.bash_profile ~/.bash_login ~/.profile 其实bash再启动是只读上面文件的一个，而读取的顺序则是依照上面的顺序。也就是说读到bash_profile就不读后面的了，如果bash_profile不存在，后面的才能有机会。 设置成功之后，请关闭当前会话的所有命令行窗口。因为，修改~/.bash_profile 这一类文件只能再下次启动命令窗口的时候才会加载。已经打开的窗口不能自动重新加载。这也是导致很多人设置成功之后，在命令输入 laravel 命令提示找不到命令的原因所在。 3）创建第一个 Laravel 项目在上面的第2步中，我们已经将 ~/.composer/vendor/bin 放到了系统的 PATH 变量中。此时，我们在命令行中可以使用 laravel 命令来创建一个项目了。进入你项目所在的目录下： 12cd /Users/qlj/codespace/phpcodelaravel new laravel 执行成功会输出如下信息： 12345Crafting application...Generating optimized class loaderCompiling common classesApplication key [QivNTbKrvAGGv7nh1glCv5Ypw6sz1Z7h] set successfully.Application ready! Build something amazing. 此时进入 laravel 目录下，可以看到已经为我们生成了一个完整的项目目录结构。关于目录结构我们后面再细细介绍。 4）让 Laravel 跑起来 在 /etc/hosts 增加一个测试地址网站：test.laravel.com 在 apache的http-vhosts.conf 同步增加一个虚拟服务器。代码如下： 1234567&lt;VirtualHost *:80&gt; ServerAdmin 753814253@qq.com DocumentRoot &quot;/Users/qlj/codespace/phpcode/laravel/public/&quot; ServerName test.laravel.com ErrorLog &quot;/private/var/log/apache2/test.laravel.com-error_log&quot; CustomLog &quot;/private/var/log/apache2/test.laravel.com-access_log&quot; common&lt;/VirtualHost&gt; 在浏览器地址栏输入：test.laravel.com 如果看到了 Laravel 的 LOGO。说明，您已经安装成功了。 如果报以下错误： 1Use of undefined constant MCRYPT_RIJNDAEL_128 - assumed &apos;MCRYPT_RIJNDAEL_128&apos; 这是您没有安装 PHP mcrypt 扩展导致。 Mac 系统下安装 mcrypt： 4.1) mac 系统mcrypt库安装1brew install mcrypt 如果您的系统是 Centos 之类的系统，通过以下命令可以更新PHP或相关扩展所依赖系统扩展。 123sudo -sLANG=Cyum -y install gcc gcc-c++ autoconf libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel glibc glibc-devel glib2 glib2-devel bzip2 bzip2-devel ncurses ncurses-devel curl curl-devel e2fsprogs e2fsprogs-devel krb5 krb5-devel libidn libidn-devel openssl openssl-devel openldap openldap-devel nss_ldap openldap-clients openldap-servers 4.2）PHP mcrypt 扩展库安装因为PHP5.3以上版本mcrypt核心中已经内置了mcrypt扩展。由于，不同版本的PHP默认开启与否不一样。因为，我的是Mac内置的PHP5.4.30没有开启。所以，有两种方法安装mcrypt扩展。 4.2.1）源码完全安装这种方式就是下载一个 php 源码码下来，然后完整编译php 源码安装。安装方式略。 4.2.2）增量源码安装这种方式下载一个与当前系统PHP版本一致的php源码包，然后，把源码里面的扩展包的mcrypt进行编译安装。这种方式花时间较少。不影响当前的PHP配置。 因为我不想改变现有环境的PHP。所以，我选择第二种增量安装方式。这种方式以前也没有试过。权当一次学习吧。 首先，我们去下载php源码。地址：http://cn.php.net/releases/ 我选择了中国的镜像下载点：地址http://cn2.php.net/get/php-5.4.30.tar.gz/from/this/mirror 下载成功之后，执行命令： 123456tar -zxvf mirrorcd /Users/qlj/Downloads/php-5.4.30/ext/mcrypt//usr/bin/phpize./configure --with-mcrypt=/usr/local/homebrew/Cellar/mcrypt/2.6.8makemake install 上面的./configure 后台是配置mcrypt的位置。因为 php 通过PHP的mcrypt扩展调用系统的mcrypt扩展来完成加密的。 修改php.ini文件。在文件末尾增加一行： 1extension=mcrypt.so 4.3 让项目的 storage 目录具备写入权限1chmod 0777 storage Laravel 框架默认会将缓存、session、日志写入该目录。 5）Laravel5 目录结构介绍 Laravel RootPath app Commands Console – Events – 所有应用事件定义在这里 Exceptions – 自定义异常 Handlers Http – Controler在这里。因为Controller都是与Http请求相关。 Providers – 类似于四层架构的S层（服务层） bootstrap – 启动框架时执行里面的程序 config – 框架所有的配置全部在这里 database – 数据库迁移等操作在这里 public – 项目的入口文件 resources – 图片、样式、JS等资源文件存放位置 storage – 模板缓存、应用缓存、session、日志存放这里 tests – phpunit单元测试程序放这里 vendor – 第三方包以及 Laravel 核心包放这里 更多请看：http://www.golaravel.com/laravel/docs/5.0/structure/ 6）GET &amp;&amp; POST7）数据库操作7.1 配置 配置文件地址：app/config/database.php Laravel 支持读写分离。配置非常简单。 123456789101112131415&apos;mysql&apos; =&gt; [ &apos;read&apos; =&gt; [ &apos;host&apos; =&gt; &apos;192.168.1.1&apos;, ], &apos;write&apos; =&gt; [ &apos;host&apos; =&gt; &apos;196.168.1.2&apos; ], &apos;driver&apos; =&gt; &apos;mysql&apos;, &apos;database&apos; =&gt; &apos;database&apos;, &apos;username&apos; =&gt; &apos;root&apos;, &apos;password&apos; =&gt; &apos;&apos;, &apos;charset&apos; =&gt; &apos;utf8&apos;, &apos;collation&apos; =&gt; &apos;utf8_unicode_ci&apos;, &apos;prefix&apos; =&gt; &apos;&apos;,], 目前 Laravel 支持四种数据库系统： MySQL、Postgres、SQLite、以及 SQL Server。 个人观点：Postgres 数据库在国外使用越来越广泛，并且性能以及管理优于MySQL。也是开源免费的关系型数据库。 7.2 执行 Select 查找 1$results = DB::select('select * from users where id = ?', [1]); select 方法会返回一个 array 结果。 7.3 执行 Insert 语法 1DB::insert('insert into users (id, name) values (?, ?)', [1, 'Dayle']); 7.4 执行 Update 语法 1DB::update('update users set votes = 100 where name = ?', ['John']); 7.5 执行 Delete 语法 1DB::delete('delete from users'); 注意： update 和 delete 语法会返回在操作中所影响的数据笔数。 7.6 事务操作 12345DB::transaction(function()&#123; DB::table('users')-&gt;update(['votes' =&gt; 1]); DB::table('posts')-&gt;delete();&#125;); 除了这种以原生语句操作数据库的方式外，还有一种就是采用对象方法的形式组装SQL语句并执行。 7.7 从数据表中取得所有的数据列 12345$users = DB::table('users')-&gt;get();foreach ($users as $user)&#123; var_dump($user-&gt;name);&#125; 7.8 从数据表中分块查找数据列 1234567DB::table('users')-&gt;chunk(100, function($users)&#123; foreach ($users as $user) &#123; // &#125;&#125;); 7.9 从数据表中取得单一数据列的单一字段 1$name = DB::table('users')-&gt;where('name', 'John')-&gt;pluck('name'); 7.10 取得单一字段值的列表 1$roles = DB::table('roles')-&gt;lists('title'); 7.11 更多高级用法 1234567891011121314151617181920212223242526$users = DB::table('users') -&gt;where('votes', '&gt;', 100) -&gt;orWhere('name', 'John') -&gt;get();$users = DB::table('users') -&gt;whereNotBetween('votes', array(1, 100))-&gt;get();$users = DB::table('users') -&gt;orderBy('name', 'desc') -&gt;groupBy('count') -&gt;having('count', '&gt;', 100) -&gt;get();DB::table('users') -&gt;leftJoin('posts', 'users.id', '=', 'posts.user_id') -&gt;get();DB::table('users') -&gt;where('name', '=', 'John') -&gt;orWhere(function($query) &#123; $query-&gt;where('votes', '&gt;', 100) -&gt;where('title', '&lt;&gt;', 'Admin'); &#125;) -&gt;get(); 7.12 打印执行的SQL语句 这个功能可以说是非常实用且常用的功能了。 开启日志： 1DB::connection()-&gt;enableQueryLog(); 要得到执行过的查找纪录数组，你可以使用 getQueryLog 方法： 1$queries = DB::getQueryLog(); 7.13 Laravel 5 ActiverRecord 详解 以下是 Laravel 5 ActiveRecord 操作 由于 Model 这样的东西是属于多个系统（前台、后台、其他）。所以，一般情况下，我们都是将其放在一起。而不是与某个系统关联放一起。所以，我们将会用到 composer 来实现自动加载。 首先，在项目根目录下面创建一个 models 目录。当然，你也可以在其他位置创建这个目录。中需要在 composer里面能加载到即可。 其次，以创建 user 表的 model 为例。在 models 目录下创建一个 User.php 脚本。代码如下： 123456789&lt;?phpnamespace Models;use Illuminate\Database\Eloquent\Model;class User extends Model &#123; protected $table = 'users'; protected $primaryKey = 'id'; public $timestamps = false;&#125; 注意。因为，我们的 users 类需要继承 Model。所以，需要： 1use Illuminate\Database\Eloquent\Model; 我们将 models 目录映射为 Models PHP命名空间。单单，使用 namespace Models的话，在项目中使用还不能正确加载。所以，我们需要 composer 工具来为我们正确让其他脚本能加载到。 修改项目根目录下的 composer.json 文件，找到 autoload 那块json。 123456789"autoload": &#123; "classmap": [ "database" ], "psr-4": &#123; "App\\": "app/", "Models\\" : "models/" &#125; &#125;, 从上面可以看出。我已经将相对于项目根目录下的 models 映射为 Models 全名空间了。 现在，我们来使用 User 操作数据： 123use Models;$users = Models\User::all();var_dump($users); 更多关于Laravel ActiveRecord的操作参考中文文档：http://www.golaravel.com/laravel/docs/5.0/eloquent/ 如果您曾经使用如下命令优化过 composer 包。那么，很有可能导致修改 composer.json没效果。 1composer dump-autoload --optimize 那么，您需要修改之后，再执行此命令来清除之后的优化缓存。 8）缓存操作Laravel 为各种不同的缓存系统提供一致的 API 。您可以在此为应用程序指定使用哪一种缓存系统， Laravel 支持各种常见的后端缓存系统，如 Memcached 和 Redis 。 配置文件：app/config/cache.php 8.1 保存对象到缓存中 1Cache::put('key', 'value', $minutes); 8.2 使用 Carbon 对象配置缓存过期时间 12$expiresAt = Carbon::now()-&gt;addMinutes(10);Cache::put('key', 'value', $expiresAt); 8.3 若是对象不存在，则将其存入缓存中 1Cache::add('key', 'value', $minutes); 当对象确实被加入缓存时，使用 add 方法将会返回 true 否则会返回 false 。 8.4 确认对象是否存在 1234if (Cache::has('key'))&#123; //&#125; 8.5 从缓存中取得对象 1$value = Cache::get('key'); 8.6 取得对象或是返回默认值 12$value = Cache::get('key', 'default');$value = Cache::get('key', function() &#123; return 'default'; &#125;); 8.7 永久保存对象到缓存中 1Cache::forever('key', 'value'); 8.8 有时候您会希望从缓存中取得对象，而当此对象不存在时会保存一个默认值，您可以使用 Cache::remember 方法： 1234$value = Cache::remember('users', $minutes, function()&#123; return DB::table('users')-&gt;get();&#125;); 8.9 从缓存中删除对象 1Cache::forget('key'); 更多关于缓存的中文文档：http://www.golaravel.com/laravel/docs/5.0/cache/ 9）Session操作使用session之前，需要先对 Laravel 配置进行设置。默认的 session 保存在 storage 中。通过配置，我们可以保存到memcached、redis等缓存服务器中。 配置文件：app/config/session.php 9.1 读取 Session 值 12345$value = Session::get('key');// 如果没有取到值，则返回默认值。$value = Session::get('key', 'default');// 或$value = session('key'); 9.2 写入 Session 值 1Session::push('user.teams', 'developers'); 9.3 从 Session 取回对象，并删除 1$value = Session::pull('key', 'default'); 9.4 从 Session 取出所有对象 1$data = Session::all(); 9.5 判断对象在 Session 中是否存在 1234if (Session::has('users'))&#123; //&#125; 9.6 从 Session 中移除对象 1Session::forget('key'); 9.7 清空所有 Session 1Session::flush(); 9.8 重新产生 Session ID 1Session::regenerate(); 更多关于 session 的中文文档：http://www.golaravel.com/laravel/docs/5.0/session/ 10）Cookie 操作10.1 读取Cookie值 1$value = Request::cookie('name'); 10.2 写入Cookie值 12$response = new Illuminate\Http\Response('Hello World');$response-&gt;withCookie(cookie('name', 'value', $minutes)); 稍微复杂点。如果使用use加载命令空间。代码会变成如下： 12$response = new Response('Hello World');$response-&gt;withCookie(cookie('name', 'value', $minutes)); 11）Laravel Commands12） Laravel artisan 命令关于 artisan 命令的使用，我们在创建项目的时候，已经使用过一次了。有了这个命令，在开发中我们会省掉很多体力活。关于更多的命令使用，请看中文文档：http://www.golaravel.com/laravel/docs/5.0/artisan/ 13）分页13.1 最简单的分页 1$users = DB::table('users')-&gt;paginate(15); 13.2 对 Eloquent 模型分页 12$allUsers = User::paginate(15);$someUsers = User::where('votes', '&gt;', 100)-&gt;paginate(15); 13.3 追回参数到URL末尾 在分页的时候，我们会搜索查询分页。默认情况下，是不会把URL中的参数附加上去的。于是，就有了以下的解决方案： 1$users = DB::table('users')-&gt;paginate(15)-&gt;appends(array('keyword' =&gt; '菠萝蜜')); Laravel 分页是非常方便快捷的。更多的文档请参考中文文档：http://www.golaravel.com/laravel/docs/5.0/pagination/ 14）实用的辅助方法14.1 产生给定控制器行为的网址。 1$url = action('HomeController@getIndex', $params); 注意：HomeController以及getIndex必须是存在的类和方法。否则，会报错。 14.2 产生给定路由名称的网址。 1$url = route('routeName', []); 14.3 产生资源的网址。 1$url = asset('img/photo.jpg'); 14.4 产生给定路径的 HTTPS 完整网址。 1echo secure_url('foo/bar', $parameters = array()); 14.5 产生给定路径的完整网址。 1echo url('foo/bar', $parameters = array(), $secure = null); 14.6 返回 取得现在 CSRF token 的值。 1$token = csrf_token(); 14.7 打印给定变量并结束脚本执行。 1dd($value); 更多辅助方法参考中文文档：http://www.golaravel.com/laravel/docs/5.0/helpers/ 15）配置多个应用16）配置ssdb存储session16.1 首先，我们要安装配置ssdb1、下载 1$ wget https://github.com/ideawu/ssdb/archive/master.zip 2、解压并安装 1234$ unzip master$ cd ssdb-master$ make $ make install 3、启动ssdb 123$ ./ssdb-server ssdb.conf 要在后台运行，执行命令：$ ./ssdb-server -d ssdb.conf 4、随服务器重启 123$ vim /etc/rc.local在文件末尾增加：/usr/local/ssdb/ssdb-server -d /usr/local/ssdb/ssdb.conf 5、停止 ssdb-server 1$ ./ssdb-server ssdb.conf -s stop 16.2 实现 PHP SessionHandlerInterface 接口说起 SessionHandlerInterface 接口大家可能都比较陌生。但是，他在如今的 PHP 框架中却充满了他的影子。比如我们常见的YII、ThinkPHP等框架都已经使用它很久了。他到底是什么东西呢？ SessionHandlerInterface 从名字上来解释就是 Session会话句柄接口。他的功能就是专门用来扩展 Session 会话的管理。通过扩展该接口，您可以将 session 会话的数据存储在任意您熟知的存储介质中。比如：mysql、memcache、redis等。 咱们来看看 SessionHandlerInterface 接口的定义：123456789SessionHandlerInterface &#123;/* 方法 */abstract public bool close ( void )abstract public bool destroy ( string $session_id )abstract public bool gc ( string $maxlifetime )abstract public bool open ( string $save_path , string $name )abstract public string read ( string $session_id )abstract public bool write ( string $session_id , string $session_data )&#125; 1、open 方法通常用于将数据存储置于文件中的情况下，打开文件代码存储位置。因为，我们要将数据存放于内存或数据库这样的存储介质中。所以，一般来说，这个方法不需要实现。留空即可。 2、destroy 方法应该从永久存储移除与 $sessionId 关联的数据。 3、gc 方法应该销毁所有比给定 $lifetime UNIX 时间戳记还旧的 session 数据。对于会自己过期的系统如 Memcached 和 Redis，这个方法可以留空。 4、write 方法应该写入给定 $data 字串与 $sessionId 的关联到一些永久存储系统，例如：MongoDB、 Dynamo、等等。 5、read 方法应该返回与给定 $sessionId 关联的 session 数据的字串形态。当你的驱动取回或保存 session 数据时不需要做任何序列化或进行其他编码，因为 Laravel 将会为你进行序列化 6、close 方法，就像 open 方法，通常也可以忽略。对大部份的驱动来说，并不需要它。 知道了每个方法的功能。那么接下来，一起来实现将 session 数据保存到ssdb中。 以下是我实现的用于session数据存储到ssdb的类。已经通过真实项目检验。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?php/** * Laravel 5.x 之 SSDB SESSION驱动。 * 因为原本的 SessionHandler 类不满足 Laravel 5.x的要求，只能通过重写来满足框架的要求。 */namespace SSDB;class LaravelSessionHandler extends SessionHandler &#123; /** * @param Client $ssdb * @param int $ttl */ public function __construct($save_path, $ttl = null, $prefix = 'sess_') &#123; $this-&gt;_ttl = $ttl ?: ini_get('session.gc_maxlifetime'); $this-&gt;_prefix = $prefix; $components = parse_url($save_path); if ($components === false || !isset($components['scheme'], $components['host'], $components['port']) || strtolower($components['scheme']) !== 'tcp') &#123; throw new Exception('Invalid session.save_path: ' . $save_path); &#125; $this-&gt;_client = new Client($components['host'], $components['port']); if (isset($components['query'])) &#123; parse_str($components['query'], $query); if (isset($query['auth'])) &#123; $this-&gt;_client-&gt;auth($query['auth']); &#125; &#125; &#125; /** * @param string $save_path * @param string $name * @return boolean */ public function open($save_path, $name) &#123; return true; &#125;&#125; 我是在ssdb/phpssdb包中继承并增加的。 以上代码因为用到了 ssdb ，所以，我们还需要安装 ssdb 客户端代码。 首先，在项目的 composer.json 中对应的节增加如下代码： 123456... "require": &#123; ... "ssdb/phpssdb": "dev-master" &#125;... 其次，在对应项目根目录下执行如下命令： 1composer update 通过这样执行之后会在命令行输出以下内容，说明安装成功： 123456789qinlj:laravel qlj$ composer updateLoading composer repositories with package informationUpdating dependencies (including require-dev) - Installing ssdb/phpssdb (dev-master 4583553) Loading from cacheWriting lock fileGenerating autoload filesGenerating optimized class loader 16.3）让 Laravel 接受 ssdb session 驱动Laravel 框架提供了一个注册session扩展驱动类的方法。在项目根目录\app\Providers\AppServiceProvider.php文件中的boot()方法增加如下代码： 12345// 注册 ssdb session 扩展。Session::extend('ssdb', function($app)&#123; return new \SSDB\LaravelSessionHandler(config('session.connection'));&#125;); 超级友情提示：Session、Cookie、Db等这种类对应的命名空间是： 123Illuminate\Support\Facades\SessionIlluminate\Support\Facades\CookieIlluminate\Support\Facades\Db 这是为了摒弃各种难用的底层驱动封装的方法提供的顶层友好的类。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHP面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel安全篇入门]]></title>
    <url>%2F2017%2F05%2F16%2FLaravel%E5%AE%89%E5%85%A8%E7%AF%87%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[安全性在设计Web应用程序是非常重要的特性。它确保了网站的用户数据的安全。Laravel提供了各种机制来确保网站的安全。一些特征列出如下- 存储密码 − Laravel提供了一个名为“Hash”类来提供安全Bcrypt散列。密码可以通过以下方式散列。 $password = Hash::make(&apos;secret&apos;); make() 函数将使用一个值作为参数，将返回其哈希值。散列值可以用check()函数进行检查如下所示。 Hash::check(&apos;secret&apos;, $hashedPassword) 上述函数将返回布尔值。如果密码匹配它将返回true，否则返回false。 认证用户-在Laravel其他主要安全功能是验证用户和执行某些操作。Laravel使得此任务更容易，要做到这一点可以通过使用Auth::attempt()方法。 if (Auth::attempt(array(&apos;email&apos; =&gt; $email, &apos;password&apos; =&gt; $password))) { return Redirect::intended(&apos;home&apos;); } Auth::attempt()方法将凭证作为参数，并验证存储在数据库中的这些凭据，如果它是匹配将返回true，否则返回 false。 CSRF保护/跨站请求伪造 (XSS) − 攻击者把客户端的JavaScript代码放页面在其他用户查看的页面时，跨站点脚本(XSS)攻击发生。 为了避免这种攻击，千万不要相信任何用户提交的数据并转义任何危险的字符。在Blade模板应该使用双括号语法({{$value}})， 如果使用 {!! $value !!} 语法，数据会其原始格式来显示所以一定是安全的。 避免SQL注入- SQL注入漏洞当应用程序插入任意和未经过滤的用户输入的SQL查询时存在的。默认情况下，Laravel会保护免受这种类型的攻击，因为在后台查询生成器使用PHP数据对象(PDO)类。 PDO使用prepared语句，它允许您安全地传递任何参数，而无需转义它们。 Cookies - 默认情况下安全 − Laravel使用Cookie类使得它很容易创建，读取和过期的cookies。在Laravel所有的Cookie是自动签名和加密。 这意味着，如果它们被篡改，Laravel将自动丢弃它们。这也表示你将不能够从客户端使用 JavaScript 读取。 交换敏感数据时强制HTTPS − HTTPS防止在同一网络上拦截私人信息，如会话变量，并使用受害者这些信息来登录。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel入门——前后端分离]]></title>
    <url>%2F2017%2F05%2F16%2FLaravel%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[Auth 认证原理简述Laravel 的认证是使用 guard 与 provider 配合完成， guard 负责认证的业务逻辑，认证信息的服务端保存等； provider 负责提供认证信息的持久化数据提供。 请求提交给 guard， guard 从 provider 里取出数据（类似用户名、密码等），验证输入数据与服务器端存储的数据是否吻合。如果提交的数据正确，再做 session 等业务的处理（如有需要）。 认证脚手架 首先我们导入 Laravel 的自带的认证脚手架 php artisan make:auth 执行数据库迁移：php artisan migrate 修改 Auth 认证的配置文件 config/auth.php 在 gurads 处，添加 admin guard 用于后台管理员认证 &apos;guards&apos; =&gt; [ &apos;web&apos; =&gt; [ &apos;driver&apos; =&gt; &apos;session&apos;, &apos;provider&apos; =&gt; &apos;users&apos;, ], &apos;admin&apos; =&gt; [ &apos;driver&apos; =&gt; &apos;session&apos;, &apos;provider&apos; =&gt; &apos;admins&apos;, ], &apos;api&apos; =&gt; [ &apos;driver&apos; =&gt; &apos;token&apos;, &apos;provider&apos; =&gt; &apos;users&apos;, ], ], 在 providers 处添加 admins provider，使用 Admin 模型 &apos;providers&apos; =&gt; [ &apos;users&apos; =&gt; [ &apos;driver&apos; =&gt; &apos;eloquent&apos;, &apos;model&apos; =&gt; App\User::class, ], &apos;admins&apos; =&gt; [ &apos;driver&apos; =&gt; &apos;eloquent&apos;, &apos;model&apos; =&gt; App\Admin::class, ], ], 创建后台管理员模型我们再创建一个 Admin 模型，用于后台管理员登录验证。 php artisan make:model Admin -m -m 参数会同时生成数据库迁移文件 xxxx_create_admins_table 修改 app/Admin.php 模型文件 &lt;?php namespace App; use Illuminate\Notifications\Notifiable; use Illuminate\Foundation\Auth\User as Authenticatable; class Admin extends Authenticatable { use Notifiable; /** * The attributes that are mass assignable. * * @var array */ protected $fillable = [ &apos;name&apos;, &apos;password&apos;, ]; /** * The attributes that should be hidden for arrays. * * @var array */ protected $hidden = [ &apos;password&apos;, &apos;remember_token&apos;, ]; } 编辑 xxxx_create_admins_table 文件，后台管理员模型结构与前台用户差不多，去掉 email 字段，name 字段设为 unique &lt;?php use Illuminate\Support\Facades\Schema; use Illuminate\Database\Schema\Blueprint; use Illuminate\Database\Migrations\Migration; class CreateAdminsTable extends Migration { /** * Run the migrations. * * @return void */ public function up() { Schema::create(&apos;admins&apos;, function (Blueprint $table) { $table-&gt;increments(&apos;id&apos;); $table-&gt;string(&apos;name&apos;)-&gt;unique(); $table-&gt;string(&apos;password&apos;); $table-&gt;rememberToken(); $table-&gt;timestamps(); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::dropIfExists(&apos;admins&apos;); } } 管理员模型填充数据定义一个数据模型工厂，在 database/factories/ModelFactory.php 中添加如下代码 $factory-&gt;define(App\Admin::class, function (Faker\Generator $faker) { static $password; return [ &apos;name&apos; =&gt; $faker-&gt;firstName, &apos;password&apos; =&gt; $password ?: $password = bcrypt(&apos;secret&apos;), &apos;remember_token&apos; =&gt; str_random(), ]; }); 使用 Faker 随机填充用户名在 database/seeds 目录下生成 AdminsTableSeeder.php 文件。 php artisan make:seeder AdminsTableSeeder 编辑 database/seeds/AdminsTableSeeder.php 文件的 run 方法，添加个管理员用户，密码为 public function run() { factory(&apos;App\Admin&apos;, )-&gt;create([ &apos;password&apos; =&gt; bcrypt(&apos;&apos;) ]); } 在 database/seeds/DatabaseSeeder.php 的 run 方法里调用 AdminsTableSeeder 类 public function run() { $this-&gt;call(AdminsTableSeeder::class); } 执行数据库迁移命令php artisan migrate --seed 数据库里会创建 admins 表，并且生成了条数据 创建后台页面创建控制器 php artisan make:controller Admin/LoginController php artisan make:controller Admin/IndexController 其中， Admin/LoginController 负责登录逻辑； Admin/IndexController 管理登录后的首页。 编辑 Admin/LoginController.php &lt;?php namespace App\Http\Controllers\Admin; use App\Http\Controllers\Controller; use Illuminate\Foundation\Auth\AuthenticatesUsers; class LoginController extends Controller { /* |-------------------------------------------------------------------------- | Login Controller |-------------------------------------------------------------------------- | | This controller handles authenticating users for the application and | redirecting them to your home screen. The controller uses a trait | to conveniently provide its functionality to your applications. | */ use AuthenticatesUsers; /** * Where to redirect users after login / registration. * * @var string */ protected $redirectTo = &apos;/admin&apos;; /** * Create a new controller instance. * * @return void */ public function __construct() { $this-&gt;middleware(&apos;guest.admin&apos;, [&apos;except&apos; =&gt; &apos;logout&apos;]); } /** * 显示后台登录模板 */ public function showLoginForm() { return view(&apos;admin.login&apos;); } /** * 使用 admin guard */ protected function guard() { return auth()-&gt;guard(&apos;admin&apos;); } /** * 重写验证时使用的用户名字段 */ public function username() { return &apos;name&apos;; } } 编辑 Admin/IndexController.php &lt;?php namespace App\Http\Controllers\Admin; use Illuminate\Http\Request; use App\Http\Requests; use App\Http\Controllers\Controller; class IndexController extends Controller { /** * 显示后台管理模板首页 */ public function index() { return view(&apos;admin.index&apos;); } } 后台显示模板复制 views/layouts/app.blade.php 成 views/layouts/admin.blade.php 编辑后台管理布局模板 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=&quot;&gt; &lt;!-- CSRF Token --&gt; &lt;meta name=&quot;csrf-token&quot; content=&quot;`{`{ csrf_token() }`}`&quot;&gt; &lt;title&gt;`{`{ config(&apos;app.name&apos;, &apos;Laravel&apos;) }`}` - Admin&lt;/title&gt; &lt;!-- Styles --&gt; &lt;link href=&quot;`{`{ asset(&apos;css/app.css&apos;) }`}`&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;nav class=&quot;navbar navbar-default navbar-static-top&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;!-- Collapsed Hamburger --&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#app-navbar-collapse&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle Navigation&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;!-- Branding Image --&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;`{`{ url(&apos;/&apos;) }`}`&quot;&gt; `{`{ config(&apos;app.name&apos;, &apos;Laravel&apos;) }`}` &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;app-navbar-collapse&quot;&gt; &lt;!-- Left Side Of Navbar --&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &amp;nbsp; &lt;/ul&gt; &lt;!-- Right Side Of Navbar --&gt; &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; &lt;!-- Authentication Links --&gt; @if (auth()-&gt;guard(&apos;admin&apos;)-&gt;guest()) &lt;li&gt;&lt;a href=&quot;`{`{ url(&apos;/admin/login&apos;) }`}`&quot;&gt;Login&lt;/a&gt;&lt;/li&gt; `{`{--&lt;li&gt;&lt;a href=&quot;`{`{ route(&apos;register&apos;) }`}`&quot;&gt;Register&lt;/a&gt;&lt;/li&gt;--}`}` @else &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; role=&quot;button&quot; aria-expanded=&quot;false&quot; aria-haspopup=&quot;true&quot;&gt; `{`{ auth()-&gt;guard(&apos;admin&apos;)-&gt;user()-&gt;name }`}` &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt; &lt;a href=&quot;`{`{ url(&apos;/admin/logout&apos;)}`}`&quot; onclick=&quot;event.preventDefault(); document.getElementById(&apos;logout-form&apos;).submit();&quot;&gt; Logout &lt;/a&gt; &lt;form id=&quot;logout-form&quot; action=&quot;`{`{ url(&apos;/admin/logout&apos;)}`}`&quot; method=&quot;POST&quot; style=&quot;display: none;&quot;&gt; `{`{ }`}` //里面放 csrf_field加（） &lt;/form&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; @endif &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; @yield(&apos;content&apos;) &lt;!-- Scripts --&gt; &lt;script src=&quot;`{`{ asset(&apos;js/app.js&apos;) }`}`&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 复制 views/auth/login.blade.php 成 views/admin/login.blade.php 编辑该模板，更改布局文件为 layouts.admin， 把表单的提交 url 改为 admin/login，email 字段改成 name字段，去掉找回密码的部分 @extends(&apos;layouts.admin&apos;) @section(&apos;content&apos;) &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md- col-md-offset-&quot;&gt; &lt;div class=&quot;panel panel-default&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt;Admin Login&lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;form class=&quot;form-horizontal&quot; role=&quot;form&quot; method=&quot;POST&quot; action=&quot;`{`{ url(&apos;/admin/login&apos;) }`}`&quot;&gt; `{`{ }`}` //里面放 csrf_field加（） &lt;div class=&quot;form-group`{`{ $errors-&gt;has(&apos;name&apos;) ? &apos; has-error&apos; : &apos;&apos; }`}`&quot;&gt; &lt;label for=&quot;name&quot; class=&quot;col-md- control-label&quot;&gt;Name&lt;/label&gt; &lt;div class=&quot;col-md-&quot;&gt; &lt;input id=&quot;name&quot; type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;name&quot; value=&quot;`{`{ old(&apos;name&apos;) }`}`&quot; required autofocus&gt; @if ($errors-&gt;has(&apos;name&apos;)) &lt;span class=&quot;help-block&quot;&gt; &lt;strong&gt;`{`{ $errors-&gt;first(&apos;name&apos;) }`}`&lt;/strong&gt; &lt;/span&gt; @endif &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group`{`{ $errors-&gt;has(&apos;password&apos;) ? &apos; has-error&apos; : &apos;&apos; }`}`&quot;&gt; &lt;label for=&quot;password&quot; class=&quot;col-md- control-label&quot;&gt;Password&lt;/label&gt; &lt;div class=&quot;col-md-&quot;&gt; &lt;input id=&quot;password&quot; type=&quot;password&quot; class=&quot;form-control&quot; name=&quot;password&quot; required&gt; @if ($errors-&gt;has(&apos;password&apos;)) &lt;span class=&quot;help-block&quot;&gt; &lt;strong&gt;`{`{ $errors-&gt;first(&apos;password&apos;) }`}`&lt;/strong&gt; &lt;/span&gt; @endif &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;col-md- col-md-offset-&quot;&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; name=&quot;remember&quot;&gt; Remember Me &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;col-md- col-md-offset-&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt; Login &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; @endsection 复制 views/home.blade.php 成 views/admin/index.blade.php 编辑该模板 @extends(&apos;layouts.admin&apos;) @section(&apos;content&apos;) &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md- col-md-offset-&quot;&gt; &lt;div class=&quot;panel panel-default&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt;Dashboard&lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; You are logged in admin dashboard! &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; @endsection 添加后台路由编辑 routes/web.php， 添加以下内容 Route::group([&apos;prefix&apos; =&gt; &apos;admin&apos;], function () { Route::group([&apos;middleware&apos; =&gt; &apos;auth.admin&apos;], function () { Route::get(&apos;/&apos;, &apos;Admin\IndexController@index&apos;); }); Route::get(&apos;login&apos;, &apos;Admin\LoginController@showLoginForm&apos;)-&gt;name(&apos;admin.login&apos;); Route::post(&apos;login&apos;, &apos;Admin\LoginController@login&apos;); Route::post(&apos;logout&apos;, &apos;Admin\LoginController@logout&apos;); }); 后台管理认证中间件创建后台管理认证中间件 php artisan make:middleware AuthAdmin 编辑 AuthAdmin &lt;?php namespace App\Http\Middleware; use Closure; class AuthAdmin { /** * Handle an incoming request. * * @param \Illuminate\Http\Request $request * @param \Closure $next * @return mixed */ public function handle($request, Closure $next) { if (auth()-&gt;guard(&apos;admin&apos;)-&gt;guest()) { if ($request-&gt;ajax() || $request-&gt;wantsJson()) { return response(&apos;Unauthorized.&apos;, ); } else { return redirect()-&gt;guest(&apos;admin/login&apos;); } } return $next($request); } } 创建后台管理登录跳转中间件，用于有些操作在登录之后的跳转 php artisan make:middleware GuestAdmin 编辑该中间件的 handle 方法 public function handle($request, Closure $next) { if (auth()-&gt;guard(&apos;admin&apos;)-&gt;check()) { return redirect(&apos;/admin&apos;); } return $next($request); } 在 app/Http/Kernel.php 中注册以上中间件 protected $routeMiddleware = [ ...... &apos;auth.admin&apos; =&gt; \App\Http\Middleware\AuthAdmin::class, &apos;guest.admin&apos; =&gt; \App\Http\Middleware\GuestAdmin::class, ]; 处理注销经过上面的步骤，已经实现了前后台分离登录，但是不管是在前台注销，还是在后台注销，都销毁了所有的 session，导致前后台注销连在一起。所以我们还要对注销的方法处理一下。 原来的 logout 方法是这样写的，在 Illuminate\Foundation\Auth\AuthenticatesUsers 里 public function logout(Request $request) { $this-&gt;guard()-&gt;logout(); $request-&gt;session()-&gt;flush(); $request-&gt;session()-&gt;regenerate(); return redirect(&apos;/&apos;); } 注意这一句 $request-&gt;session()-&gt;flush(); 将所有的 session 全部清除，这里不分前台、后台，所以要对这里进行改造。因为前台、后台注销都要修改，所以我们新建一个 trait，前后台都可以使用。 新建一个文件 app/Extensions/AuthenticatesLogout.php &lt;?php namespace App\Extensions; use Illuminate\Http\Request; trait AuthenticatesLogout { public function logout(Request $request) { $this-&gt;guard()-&gt;logout(); $request-&gt;session()-&gt;forget($this-&gt;guard()-&gt;getName()); $request-&gt;session()-&gt;regenerate(); return redirect(&apos;/&apos;); } } 我们将上面的那一句改成 $request-&gt;session()-&gt;forget($this-&gt;guard()-&gt;getName()); 只是删除掉当前 guard 所创建的 session，这样就达到了分别注销的目的。 修改 Auth/LoginController.php 和 Admin/LoginController.php，将 class LoginController extends Controller { use AuthenticatesUsers; 改掉，在文件的前面别忘了加上 use 语句 use App\Extensions\AuthenticatesLogout; ... class LoginController extends Controller { use AuthenticatesUsers, AuthenticatesLogout { AuthenticatesLogout::logout insteadof AuthenticatesUsers; } ...]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>框架</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel入门——MVC实战]]></title>
    <url>%2F2017%2F05%2F16%2FLaravel%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94MVC%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[Controller期间受到很多私事影响，终于还是要好好写写laravel的教程了。 上一篇我们说了数据库和Eloquent的基本用法，如计划一样，这一篇文章我们说说Laravel中Model，Controller，Views的工作流程，也就是下面这个顺序： 1.注册路由 —&gt; 2.创建控制器 —&gt; 3. 控制器中获取数据库数据 —&gt; 4.在视图中展示数据 英文的表达可能会更加贴切一点： register routes make a controller fetch data from database load a view to display data 在laravel中，最常见的流程就是这个样子的，我们在实现某个功能的时候，通常就是走上面的这个流程。比如我们这个blog项目中，我们需要实现下面的功能： 展示所有的文章 // blog首页 展示一篇文章 //文章详情页 创建一篇文章 // 文章发布页面 修改一篇文章 // 文章修改页面 删除一篇文章 // 后台管理 在这一篇文章中，我们集中精力解决一下第一个功能，所以我们按照上面的流程来走一遍： PS : 上次我们使用artisan tinker这个工具在命令行中对数据库的数据进行了CRUD，现在就要将这些应用到MVC当中了。 注册路由我们这里会从头开始，也就是会先删除app/Http/Controllers/ArticleController.php这个文件 在系列文章的第二篇当中，我们在app/Http/routes.php中注册了我们首页的路由： 1Route::get(&apos;/&apos;,&apos;ArticleController@index&apos;); 可以直接使用这个路由，所以我们可以进入下一步。 创建控制器 这里需要注意的是，如果你使用了Homestead，请先ssh登录到你的虚拟机中执行命令；还有就是，请先删除之前课程遗留的ArticleController，如果你想偷懒，可以跳过这一步 创建控制器的时候你可以手动创建，不过还是推荐使用artisan这个命令行工具，在项目目录之下，命令行执行： 1php artisan make:controller ArticleController --plain 这里需要说明的是–plain这个参数表明只要一个简单的controller，里面不需要生成一堆如show(),create()等方法。 控制器中获取数据库数据打开这个重新创建的ArticleController.php： 12345678910class ArticleController extends Controller&#123; public function index()&#123;$articles = Article::all(); return $articles;&#125;&#125; 我们创建一个index()方法，这是因为我们在routes.php当中注册的路由指定要加载ArticleController的index()方法，我们在index()方法中使用Article::all()将数据库中articles这张表中的所有的记录查找出来，直接返回。 如你看到的一样，如果你直接返回查找到得数据，Laravel会默认将这些数据转换成json格式，因为laravel可能是出于这样的考虑：一般这种情况下地返回，通常都是在创建api功能，比如你为你的一个手机App写的api一样，json数据无疑是很好的选择。 顺便安利一下大家使用百度团队的这个FeHelper这个chrome插件： 1https://github.com/zxlie/FeHelper 但是在这里我们并不是想直接返回json，取而代之的是，我们的目的是加载视图，将数据展示出来。所以这就是我们下一步的工作了 在视图中展示数据这里我们首先需要修改的是ArticleController中的index()方法： 123456public function index()&#123;$articles = Article::all(); return view(&apos;articles.index&apos;,compact(&apos;articles&apos;));&#125; 我们只是修改了return这一行的代码，使用view()方法加载视图，这个视图就是位于resources/views/articles/中的index.blade.php(我们还没有创建)，最后使用compact(‘articles’)将数据传给视图文件：关于这个视图传递变量的问题，你可以参考教程的第三篇 然后，我们需要创建我们的视图文件，在resources/views/articles/下创建index.blade.php文件： 1234@extends(&apos;app&apos;)@section(&apos;content&apos;)&lt;h1&gt;这是index.blade.php&lt;/h1&gt;@endsection 写上上面的内容，关于视图文件的blade模板，可以参考教程的第三篇，然后浏览器访问一下看看： 视图文件正确之后，我们需要将传递给视图的$articles变量的内容展示出来： 12345678@extends(&apos;app&apos;)@section(&apos;content&apos;)@foreach($articles as $article)&lt;h1&gt;`&#123;`&#123; $article-&gt;title &#125;`&#125;`&lt;/h1&gt;&lt;p&gt;`&#123;`&#123; $article-&gt;intro &#125;`&#125;`&lt;/p&gt;&lt;hr&gt;@endforeach@endsection 我们使用”@foreach”来将所有的文章循环出来，浏览器访问看看： 这里我们的首页展示也就基本完成了，然而在我们的实际blog中，我们会在每个标题出给出我们的文章链接，也就是为每个文章添加一个详情展示的页面，用户点击文章的链接之后，我们展示相应的文章详情。我们来实现这个功能 显示文章详情通过文章展示来快速体验上面的流程： 1.注册路由来到app/Http/routes.php中，我们增加一个路由： 1Route::get(&apos;articles/&#123;id&#125;&apos;,&apos;ArticleController@show&apos;); 上面的路由articles/{id}指定我们需要加载ArticleController中的show()方法。这里需要注意的是{id}这个表达：这是表示id是一个路由变量，也就是当我们访问类似下面这两个路由的时候： 12http://blog.dev/articles/1 //id 为1http://blog.dev/articles/foo // id为foo 先不急着访问，因为我们还没有创建show()方法，这里只是作为说明。 在laravel中，路由变量写在{}括号中，这个id对应我们等下写的show()方法的参数。 2.编写show()在ArticleController增加show()方法： 1234public function show($id)&#123;return $id;&#125; 我们在show($id)方法中，首先接受参数id，然后直接返回。现在我们可以访问上面的两个url了，看到的类似下面这个效果： 3.获取数据然而在show()方法中，我们也是需要从数据库中加载获取数据，所以我们先修改show()方法： 12345public function show($id)&#123;$article = Article::find($id);return $article;&#125; 我们通过find()方法从数据库中查找一条记录，然后直接返回，我们来看看效果： 4.加载视图获取数据之后，我们需要加载相应地视图来展示数据，还是修改show()方法： 12345public function show($id)&#123;$article = Article::find($id);return view(&apos;articles.show&apos;,compact(&apos;article&apos;));&#125; 类似地，我们使用view()加载show.blade.php，然后compact()将变量传递过去。所以我们去创建show.blade.php视图文件吧： 123456@extends(&apos;app&apos;)@section(&apos;content&apos;)&lt;h1&gt;`&#123;`&#123; $article-&gt;title &#125;`&#125;`&lt;/h1&gt;&lt;hr&gt;&lt;p&gt;`&#123;`&#123; $article-&gt;content &#125;`&#125;`&lt;/p&gt;@endsection 这里跟index.blade.php视图文件差不多，我们只是去掉了@foreach，在来访问一下看看： 到这里，我们的文章展示页面也可以说是完成了，然而当我们访问这个下面这个链接的时候： 1http://blog.dev/articles/3 报错了！这是因为我们在show()方法中使用$article = Article::find($id);来查找一篇文章，但是我们的数据库中的articles表并没有id为3的记录，也就是id为3的时候，$article变量已经是null了，这个时候我们如果还是希望在视图中使用{{ $article-&gt;title }}，所以才会出现错误： 1Trying to get property of non-object.... PS: 如果你想调试，看看$article到底是什么，你可以在laravel中使用dd($article)来调试 那这个要怎么解决呢？有两种方法： 第一，自己写个if条件判断：12345678public function show($id)&#123;$article = Article::find($id);if(is_null($article))&#123;abort(404);&#125;return view(&apos;articles.show&apos;,compact(&apos;article&apos;));&#125; 如果$article为空，直接abort()一个404页面。再来访问一下： 这里貌似还是会看到一堆错误，为什么呢？那是因为在.env中我们设置了APP_DEBUG=true，所以还会有下面的一堆错误，我们在实际的线上部署环境中，APP_DEBUG=false才是我们的设置。我们来体验一把将APP_DEBUG=false，见证一下我们的404页面： 这个404页面，你可以自定义：就是在resources/views/errors/文件夹下创建一个404.blade.php。 实际例子就是这样的(彩蛋)： 1https://jellybool.com/show404page 你也可以在我的blog地址栏随便输入一堆东西，看看找不到文章的时候是什么样的404 page 。 第二，使用findOrFail()上面的条件判断其实很不错了，但是这里我还是推荐使用findOrFail()这个方法： 123456public function show($id)&#123;$article = Article::findOrFail($id); return view(&apos;articles.show&apos;,compact(&apos;article&apos;));&#125; findOrFail()表示首先尝试find，如果找不到就fail，抛出一个Eloquent Exception，所以我们再来访问尝试一下： 我们应该会得到一样的结果. 然后我们回到我们的index.blade.php中为每篇文章添加链接： 12345@foreach($articles as $article)&lt;h1&gt;&lt;a href=&quot;/articles/`&#123;`&#123; $article-&gt;id &#125;`&#125;`&quot;&gt;`&#123;`&#123; $article-&gt;title &#125;`&#125;`&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;`&#123;`&#123; $article-&gt;intro &#125;`&#125;`&lt;/p&gt;&lt;hr&gt;@endforeach 访问来看看： 注意我们这里直接使用了href=”/articles/{{ $article-&gt;id }}“进行链接，你也可以使用action()这个方法： 12345@foreach($articles as $article)&lt;h1&gt;&lt;a href=&quot;`&#123;`&#123; action(&apos;ArticleController@show&apos;,[$article-&gt;id]) &#125;`&#125;`&quot;&gt;`&#123;`&#123; $article-&gt;title &#125;`&#125;`&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;`&#123;`&#123; $article-&gt;intro &#125;`&#125;`&lt;/p&gt;&lt;hr&gt;@endforeach action()这个方法第一个参数表明要加载ArticleController的show()方法，跟routes一样，第二个参数用数组传入相应地参数[$article-&gt;id]。 你还有第三种选择，使用url()方法： 12345@foreach($articles as $article)&lt;h1&gt;&lt;a href=&quot;`&#123;`&#123; url(&apos;articles/&apos;,$article-&gt;id) &#125;`&#125;`&quot;&gt;`&#123;`&#123; $article-&gt;title &#125;`&#125;`&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;`&#123;`&#123; $article-&gt;intro &#125;`&#125;`&lt;/p&gt;&lt;hr&gt;@endforeach url()方法第一个参数传入url路径，第二个参数直接传入变量。 上面的三种方法，选择一种自己喜欢的就可以了。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>框架</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel入门——契约简介]]></title>
    <url>%2F2017%2F05%2F16%2FLaravel%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%A5%91%E7%BA%A6%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[简介 Laravel 中的契约是指框架提供的一系列定义核心服务的接口（interface）。 例如，Illuminate\Contracts\Queue\Queue 契约定义了队列任务所需的方法，而 Illuminate\Contracts\Mail\Mailer 契约定义了发送电子邮件所需的方法。 框架对每个契约都提供了相应的实现。例如，Laravel 提供了具有各种驱动的队列实现和由 SwiftMailer 提供支持的邮件驱动实现。 所有的 Laravel 契约都有他们自己的 GitHub 库。这为所有可用的契约提供了一个快速参考指南，同时也可单独作为低耦合的扩展包给其他包开发者使用。 契约 VS. FacadesLaravel Facades 和辅助函数提供了一种使用 Laravel 服务的简单方法，即不需要通过类型提示并从服务容器中解析契约。在大多数情况下，每个 Facades 都有一个等效的契约。 不同于门面不需要在构造函数中进行类型提示，契约允许你在类中定义显式的依赖。一些开发者倾向于以契约这种方式明确地定义它们的依赖项，而其它开发者则更喜欢 Facades 带来的便捷。 对于大多数应用程序来说，不管是使用门面还是契约都可以。但是，如果你正在构建一个扩展包，为了方便测试，你应该强烈考虑契约。何时使用契约 综上所述，使用契约或是 Facades 很大程度上归结于个人或者开发团队的喜好。不管是契约还是 Facades 都可以创建出健壮的、易测试的 Laravel 应用程序。如果你长期关注类的单一职责，你会注意到使用契约还是 Facades 其实没多少实际意义上的区别。 然而，你可能还是会有几个关于契约的问题。例如，为什么要使用接口？不使用接口会比较复杂吗？下面让我们谈下使用接口的原因：低耦合和简单性。 低耦合首先，让我们来看一些高耦合缓存实现的代码。如下: &lt;?php namespace App\Orders; class Repository { /** * 缓存实例。 */ protected $cache; /** * 创建一个仓库实例。 * * @param \SomePackage\Cache\Memcached $cache * @return void */ public function __construct(\SomePackage\Cache\Memcached $cache) { $this-&gt;cache = $cache; } /** * 按照 Id 检索订单 * * @param int $id * @return Order */ public function find($id) { if ($this-&gt;cache-&gt;has($id)) { // } } } 在这个类中，程序与给定的缓存实现高耦合。因为我们依赖于一个扩展包的特定缓存类。一旦这个扩展包的 API 被更改了，我们的代码就必须跟着改变。 同样的，如果我们想要将底层的的缓存技术（ Memcached ）替换为另一种缓存技术（ Redis ），那又得再次修改这个 repository 类。而 repository 类不应该了解太多关于谁提供了这些数据或是如何提供的等等。 比起上面的做法，我们可以使用一个简单的、与扩展包无关的接口来改进我们的代码： &lt;?php namespace App\Orders; use Illuminate\Contracts\Cache\Repository as Cache; class Repository { /** * 缓存实例。 */ protected $cache; /** * 创建一个仓库实例。 * * @param Cache $cache * @return void */ public function __construct(Cache $cache) { $this-&gt;cache = $cache; } } 现在，更改之后的代码没有与任何扩展包甚至是 Laravel 耦合。而契约扩展包不包含任何实现和依赖项，你可以轻松地编写任何给定契约的替代实现，来实现不修改任何关于缓存消费的代码就可以替换缓存实现。 简单性当所有 Laravel 的服务都使用简洁的接口定义，就很容易判断给定服务提供的功能。 可以将契约视为说明框架功能的简洁文档。 除此之外，当依赖的接口足够简洁时，代码的可读性和可维护性会大大提高。比起搜索一个大型复杂的类中有哪些可用的方法，不如检索一个简单、 干净的接口来参考更妥当。如何使用契约 Laravel 中的许多类型的类都是通过 服务容器 解析出来的，包括控制器、事件监听器、中间件、任务队列，甚至路由闭包。所以，要获得一个契约的实现，你只需要在被解析的类的构造函数中添加「类型提示」即可。 例如，看看这个事件监听器： &lt;?php namespace App\Listeners; use App\User; use App\Events\OrderWasPlaced; use Illuminate\Contracts\Redis\Database; class CacheOrderInformation { /** * Redis 数据库实现。 */ protected $redis; /** * 创建事件处理器实例。 * * @param Database $redis * @return void */ public function __construct(Database $redis) { $this-&gt;redis = $redis; } /** * 处理事件。 * * @param OrderWasPlaced $event * @return void */ public function handle(OrderWasPlaced $event) { // } } 当事件监听器被解析时，服务容器会读取类的构造函数上的类型提示，并注入对应的值。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>框架</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel入门——容器简介]]></title>
    <url>%2F2017%2F05%2F16%2FLaravel%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Laravel容器 DIDI 就是常说的依赖注入，那么究竟什么是依赖注入呢？ 打个比方，电脑（非笔记本哈）需要键盘和鼠标我们才能进行操作，这个‘需要’换句话说就是‘依赖’键盘和鼠标。 那么，相应的，一个类需要另一个类才能进行作业，那么这也就是依赖。 class Computer { protected $keyboard; public function __construct() { $this-&gt;$keyboard = new Keyboard(); } } 这里的Computer类依赖了键盘类。 好，既然我们已经知道了什么是依赖，那么什么是注入呢？ 我们改造一下上面的代码： class Computer { protected $keyboard; public function __construct(Keyboard $keyboard) { $this-&gt;$keyboard = $keyboard; } } $computer = new Computer(new Keyboard()); 这里的Computer类依赖注入了Keyboard类。 关于依赖注入，我的理解是：所需要的类通过参数的形式传入的就是依赖注入。理解了依赖注入，我们可以接着理解 IOC。 IOCIOC 是什么呢？ 中文叫控制反转。啥意思呢？ 这个看明白了 DI 后就能很容易的理解了。 通过 DI 我们可以看到，一个类所需要的依赖类是由我们主动实例化后传入类中的。 控制反转和这个有什么关系呢？ 控制反转意思是说将依赖类的控制权交出去，由主动变为被动。 看一段 laravel 代码： namespace App\Http\Controllers; use Illuminate\Http\Request; class SessionController extends Controller { public function login(Request $request) { //这就是IOC，我们不需要主动传入类了一切由laravel去实现 } } 看到这你可能有疑问了，这是怎么实现的呢？ 这就是靠服务容器了，请往下接着看。 服务容器看了很多文章，我一致认为服务容器就是一种设计模式。 它的目的就是解耦依赖。 它有点类似于我前面说的《享元模式》。区别在于服务容器解决了所有依赖的实现。 这里我们再从头至尾的看一遍，怎么一步步演化出服务容器。依然是电脑的例子，我们知道电脑依赖键盘鼠标，可是键盘鼠标也有很多种呀。 先看一个最原始的代码例子： class Computer { protected $keyboard; public function __construct($type = null) { switch($type) { case &apos;common&apos;: return new CommonKeyboard(); case &apos;awesome&apos;: return new AweSomeKeyboard(); default: return new Keyboard(); } } } 或许你一眼就看出了问题在哪。 如果我们又要增加一钟键盘，那我们又得对这个类进行修改。这样下去，这个类会变得庞大且耦合程度过高。 那么我们可以怎么修改呢？工厂模式这样我们可以避免直接的修改 Computer 类。 简单工厂class Factory { public static function getInstance($type){ switch($type) { case &apos;common&apos;: $this-&gt;keyboard = new CommonKeyboard(); break; case &apos;awesome&apos;: $this-&gt;keyboard = new AweSomeKeyboard(); break; default: $this-&gt;keyboard = new Keyboard(); break; } } } class Computer { protected $keyboard; public function __construct($type == null) { $this-&gt;keyboard = Factory::getInstance($type); } } 这样使用简单工厂模式后，我们后续的修改可以不用对 Computer 类进行操作而只要修改工厂类就行了。这就相当于对 Computer 类进行了解耦。 Computer 类虽不在依赖那些键盘类了，但是却变为依赖工厂类了。 后续添加新类型的键盘就必须对工厂类进行修改。 所以这个工厂类还不能很好的满足要求，我们知道电脑对键盘的接口都是一致的，键盘必须实现这一接口才能被电脑识别，那我们对 Computer 和 Keyboard 类进行修改。 DI（依赖注入）interface Board { public function type(); } class CommonBoard implements Board { public function type(){ echo &apos;普通键盘&apos;; } } class MechanicalKeyboard implements Board { public function type(){ echo &apos;机械键盘&apos;; } } class Computer { protected $keyboard; public function __construct (Board $keyboard) { $this-&gt;keyboard = $keyboard; } } $computer = new Computer(new MechanialKeyBoard()); 可是这样也有问题，如果我们后续对这台电脑使用的键盘不满意要进行替换呢？ 我们又回到原点了，必须去修改传入的键盘类。 能不能做成可配置的呢？ IOC 服务容器（超级工厂）class Container { protected $binds; protected $instances; public function bind($abstract, $concrete) { if ($concrete instanceof Closure) { $this-&gt;binds[$abstract] = $concrete; } else { $this-&gt;instances[$abstract] = $concrete; } } public function make($abstract, $parameters = []) { if (isset($this-&gt;instances[$abstract])) { return $this-&gt;instances[$abstract]; } array_unshift($parameters, $this); return call_user_func_array($this-&gt;binds[$abstract], $parameters); } } 这就是一个简单的 IOC 服务容器。这个怎么解决我们上述的问题呢？ $container = new Container; $container-&gt;bind(&apos;Board&apos;, function($container){ return new CommonBoard; }); $container-&gt;bind(&apos;Computer&apos;,function($container,$module){ return new Computer($container-&gt;make($module)); }); $computer = $container-&gt;make(&apos;Computer&apos;,[&apos;Board&apos;]); 这里生产出来的 Computer 类就是一个使用普通键盘的电脑类了。 解释一下代码： bind(name,function($container){ return new Name; }) 这里的name和Name之间的关系是：当我需要name类的时候你就给我实例化Name类。 make(name)方法是对name进行生产返回一个实例。如果我们要更换键盘怎么办呢？ $container-&gt;bind(&apos;Board&apos;, function($container){ return new MechanicalBoard; }); $container-&gt;bind(&apos;Computer&apos;,function($container,$module){ return new Computer($container-&gt;make($module)); }); $computer = $container-&gt;make(&apos;Computer&apos;,[&apos;Board&apos;]); 只要对 bind 绑定的 Board 类的实现进行修改，我们就可以很容易替换掉键盘了。这就是一个服务容器。 对服务容器进行一个理解： 容器就是一个装东西的，好比碗。而服务就是这个碗要装的饭呀，菜呀，等等东西。当我们需要饭时，我们就能从这个碗里拿到。如果你想在饭里加点菜（也就是饭依赖注入了菜），我们从碗里直接拿饭就可以了，而这些依赖都由容器解决了（这也就是控制反转）。 我们需要做的就是对提供的服务进行维护。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>框架</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel入门——路由]]></title>
    <url>%2F2017%2F05%2F16%2FLaravel%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[作为一个 web 后台框架，路由无疑是极其重要的一部分。本博客接下来几篇文章都将会围绕路由这一主题来展开讨论，分别讲述： 和之前一样，第一篇将会利用单元测试样例说明我们在平时可能用到的 route 的 api 函数用法，后面几篇文章将会剖析 laravel 的 route 源码。下面开始介绍 laravel 中路由的各种用法。 路由属性注册所有 Laravel 路由都定义在位于 routes 目录下的路由文件中，这些文件通过框架自动加载。routes/web.php 文件定义了 web 界面的路由，这些路由被分配了 web 中间件组，从而可以提供 session 和 csrf 防护等功能。routes/api.php 中的路由是无状态的，被分配了 api 中间件组。 对大多数应用而言，都是从 routes/web.php 文件开始定义路由。 路由 method 方法我们可以注册路由来响应任何 HTTP 请求： Route::get($uri, $callback); Route::post($uri, $callback); Route::put($uri, $callback); Route::patch($uri, $callback); Route::delete($uri, $callback); Route::options($uri, $callback); 有时候还需要注册路由响应多个 HTTP 请求 —— 这可以通过 match 方法来实现。或者，可以使用 any 方法注册一个路由来响应所有 HTTP 请求： Route::match([&apos;get&apos;, &apos;post&apos;], &apos;/&apos;, function () { // }); Route::any(&apos;foo&apos;, function () { // }); 值得注意的是，一般的 HTML 表单仅仅支持 get、post，并不支持 put、patch、delete 等动作，这时候就需要在前端添加一个隐藏的 _method 字段到给表单中，其值被用作 HTTP 请求方法名： &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;&gt; 在 web 路由文件中所有请求方式为 PUT、POST 或 DELETE 的 HTML 表单都会包含一个 CSRF 令牌字段，否则，请求会被拒绝。关于 CSRF 的更多细节，可以参考 浅谈 CSRF 攻击方式： 1234&lt;form method=&quot;POST&quot; action=&quot;/profile&quot;&gt; `&#123;`&#123; &#125;`&#125;` //里面放 csrf_field加（） ...&lt;/form&gt; 路由 scheme 协议对于 web 后台框架来说，路由的 scheme 底层协议一般使用 http、https: Route::get(&apos;foo/{bar}&apos;, [&apos;http&apos;, function () { }]); Route::get(&apos;foo/{bar}&apos;, [&apos;https&apos;, function () { }]); 路由 domain 子域名子域名可以像 URI 一样被分配给路由参数，子域名可以通过路由属性中的 domain 来指定： Route::domain(&apos;api.name.bar&apos;) -&gt;get(&apos;foo/bar&apos;, function ($name) { return $name; }); Route::get(&apos;foo/bar&apos;, [&apos;domain&apos; =&gt; &apos;api.name.bar&apos;, function ($name) { return $name; }]); 路由 prefix 前缀可以为路由添加一个给定 URI 前缀，通过利用路由属性的 prefix 指定： Route::prefix(&apos;pre&apos;) -&gt;get(&apos;foo/bar&apos;, function () { }); Route::get(&apos;foo/bar&apos;, [&apos;prefix&apos; =&gt; &apos;pre&apos;, function () { }]); Route::get(&apos;foo/bar&apos;, function () { })-&gt;prefix(&apos;pre&apos;); 路由 where 正则约束可以为路由的 URI 参数指定正则约束： Route::get(&apos;{one}&apos;, [&apos;where&apos; =&gt; [&apos;one&apos; =&gt; &apos;(.+)&apos;], function () { }]); Route::get(&apos;{one}&apos;, function () { })-&gt;where(&apos;one&apos;, &apos;(.+)&apos;); 如果想要路由参数在全局范围内被给定正则表达式约束，可以使用 pattern 方法。在 RouteServiceProvider 类的 boot 方法中定义约束模式： public function boot() { Route::pattern(&apos;one&apos;, &apos;(.+)&apos;); parent::boot(); } 路由 middleware 中间件为路由添加中间件，通过利用路由属性的 middleware 指定： Route::middleware(&apos;web&apos;) -&gt;get(&apos;foo/bar&apos;, function () { }); Route::get(&apos;foo/bar&apos;, [&apos;middleware&apos; =&gt; &apos;web&apos;, function () { }]); Route::get(&apos;foo/bar&apos;, function () { })-&gt;middleware(&apos;web&apos;); 路由 namespace 属性可以为路由的控制器添加 namespace 来指定控制器的命名空间： Route::namespace(&apos;Namespace\\Example\\&apos;) -&gt;get(&apos;foo/bar&apos;, function () { }); Route::get(&apos;foo/bar&apos;, [&apos;namespace&apos; =&gt; &apos;Namespace\\Example\\&apos;, function () { }]); 路由 uses 属性可以为路由添加 URI 对应的执行逻辑，例如闭包或者控制器： Route::get(&apos;foo/bar&apos;, [&apos;uses&apos; =&gt; function () { }]); Route::get(&apos;foo/bar&apos;, [&apos;uses&apos; =&gt; ‘Illuminate\Tests\Routing\RouteTestControllerStub@index’]); Route::get(&apos;foo/bar&apos;)-&gt;uses(function () { }); Route::get(&apos;foo/bar&apos;)-&gt;uses(‘Illuminate\Tests\Routing\RouteTestControllerStub@index’); 路由 as 别名可以为路由指定别名，通过路由属性的 as 来指定： Route::as(&apos;Foo&apos;) -&gt;get(&apos;foo/bar&apos;, function () { }); Route::name(&apos;Foo&apos;) -&gt;get(&apos;foo/bar&apos;, function () { }); Route::get(&apos;foo/bar&apos;, [&apos;as&apos; =&gt; &apos;Foo&apos;, function () { }]); Route::get(&apos;foo/bar&apos;, function () { })-&gt;name(&apos;Foo&apos;); 路由 group 群组属性可以为一系列具有类似属性的路由归为同一组，利用 group 将这些路由归并到一起： Route::group([&apos;domain&apos; =&gt; &apos;group.domain.name&apos;, &apos;prefix&apos; =&gt; &apos;grouppre&apos;, &apos;where&apos; =&gt; [&apos;one&apos; =&gt; &apos;(.+)&apos;], &apos;middleware&apos; =&gt; &apos;groupMiddleware&apos;, &apos;namespace&apos; =&gt; &apos;Namespace\\Group\\&apos;, &apos;as&apos; =&gt; &apos;Group::&apos;,] function () { Route::get(&apos;/replace&apos;,‘domain’ =&gt; &apos;route.domain.name&apos;， &apos;uses&apos; =&gt; function () { return &apos;replace&apos;; }); Route::get(&apos;additional/{one}/{two}&apos;, &apos;prefix&apos; =&gt; &apos;routepre&apos;, &apos;where&apos; =&gt; &apos;[&apos;one&apos; =&gt; &apos;([0-9]+)&apos;,&apos;two&apos; =&gt; &apos;(.+)&apos;]&apos;, &apos;middleware&apos; =&gt; &apos;routeMiddleware&apos;, &apos;namespace&apos; =&gt; &apos;Namespace\\Group\\&apos;, &apos;as&apos; =&gt; &apos;Route&apos;, &apos;use =&gt; &apos;function () { return &apos;additional&apos;; }); }); $this-&gt;assertEquals(&apos;replace&apos;, $router-&gt;dispatch(Request::create(&apos;http://route.domain.name/grouppre/replace&apos;, &apos;GET&apos;))-&gt;getContent()); $this-&gt;assertEquals(&apos;additional&apos;, $router-&gt;dispatch(Request::create(&apos;http://group.domain.name/routepre/grouppre/additional/111/add&apos;, &apos;GET&apos;))-&gt;getContent()); $routes = $router-&gt;getRoutes()-&gt;getRoutes(); $action = $routes[0]-&gt;getAction(); $this-&gt;assertEquals(&apos;Namespace\\Group\\&apos;, $action[&apos;namespace&apos;]); $this-&gt;assertEquals(&apos;Group::&apos;, $action[&apos;as&apos;]); $routes = $router-&gt;getRoutes()-&gt;getRoutes(); $action = $routes[1]-&gt;getAction(); $this-&gt;assertEquals([&apos;groupMiddleware&apos;, &apos;routeMiddleware&apos;], $action[&apos;middleware&apos;]); $this-&gt;assertEquals(&apos;Namespace\\Group\\Namespace\\Group\\&apos;, $action[&apos;namespace&apos;]); $this-&gt;assertEquals(&apos;Group::Route&apos;, $action[&apos;as&apos;]); group 群组的属性分为两类：替换型、递增型。当群组属性与路由属性重复的时候，替换型属性会用路由的属性替换群组的属性，递增型的属性会综合路由和群组的属性。 在上面的例子可以看出： domain 这个属性是替换型属性，路由的属性会覆盖和替换群组的这几个属性；prefix、middleware、namespace、as 、where 这几个属性是递增型属性，路由的属性和群组属性会相互结合。 另外值得注意的是： 路由的 prefix 属性具有优先级，因此上面第二个路由的 uri 是 routepre/grouppre/additional/111/add, 而不是 grouppre/routepre/additional/111/add； where 属性对于相同的路由参数会替换，不同的路由参数会结合，因此上面 where 中 one 被替换，two 被结合进来 路由参数与匹配laravel 允许在注册定义路由的时候设定路由参数，以供控制器或者闭包所用。路由参数可以设定在 URI 中，也可以设定在 domain 中。 路由编码匹配对于已编码的请求 URI，框架会自动进行解码然后进行匹配: $router = $this-&gt;getRouter(); $router-&gt;get(&apos;foo/bar/åαф&apos;, function () { return &apos;hello&apos;; }); $this-&gt;assertEquals(&apos;hello&apos;, $router-&gt;dispatch(Request::create(&apos;foo/bar/%C3%A5%CE%B1%D1%84&apos;, &apos;GET&apos;))-&gt;getContent()); $router = $this-&gt;getRouter(); $route = $router-&gt;get(&apos;foo/{file}&apos;, function ($file) { return $file; }); $this-&gt;assertEquals(&apos;oxygen%20&apos;, $router-&gt;dispatch(Request::create(&apos;http://test.com/foo/oxygen%2520&apos;, &apos;GET&apos;))-&gt;getContent()); 路由参数路由参数总是通过花括号进行包裹，这些参数在路由被执行时会被传递到路由的闭包。路由参数不能包含 - 字符，需要的话可以使用 _ 替代。 $router = $this-&gt;getRouter(); $route = $router-&gt;get(&apos;foo/{age}&apos;, [&apos;domain&apos; =&gt; &apos;api.{name}.bar&apos;, function ($name, $age) { return $name.$age; }]); $this-&gt;assertEquals(&apos;taylor25&apos;, $router-&gt;dispatch(Request::create(&apos;http://api.taylor.bar/foo/25&apos;, &apos;GET&apos;))-&gt;getContent()); $route = new Route(&apos;GET&apos;, &apos;images/{id}.{ext}&apos;, function () { }); $request1 = Request::create(&apos;images/1.png&apos;, &apos;GET&apos;); $this-&gt;assertTrue($route-&gt;matches($request1)); $route-&gt;bind($request1); $this-&gt;assertTrue($route-&gt;hasParameter(&apos;id&apos;)); $this-&gt;assertFalse($route-&gt;hasParameter(&apos;foo&apos;)); $this-&gt;assertEquals(&apos;1&apos;, $route-&gt;parameter(&apos;id&apos;)); $this-&gt;assertEquals(&apos;png&apos;, $route-&gt;parameter(&apos;ext&apos;)); 路由可选参数有时候可能需要指定可选的路由参数，这可以通过在参数名后加一个？标记来实现，这种情况下需要给相应的变量指定默认值： $router = $this-&gt;getRouter(); $router-&gt;get(&apos;{foo?}/{baz?}&apos;, function ($name = &apos;taylor&apos;, $age = 25) { return $name.$age; }); $this-&gt;assertEquals(&apos;fred25&apos;, $router-&gt;dispatch(Request::create(&apos;fred&apos;, &apos;GET&apos;))-&gt;getContent()); $router-&gt;get(&apos;default/{foo?}/{baz?}&apos;, function ($name, $age = 25) { return $name.$age; })-&gt;default(&apos;name&apos;, &apos;taylor&apos;); $this-&gt;assertEquals(&apos;fred25&apos;, $router-&gt;dispatch(Request::create(&apos;fred&apos;, &apos;GET&apos;))-&gt;getContent()); 路由参数正则约束可以使用路由实例上的 where 方法来约束路由参数的格式。where 方法接收参数名和一个正则表达式来定义该参数如何被约束： Route::get(&apos;user/{name}&apos;, function ($name) { // })-&gt;where(&apos;name&apos;, &apos;[A-Za-z]+&apos;); 如果想要路由参数在全局范围内被给定正则表达式约束，可以使用 pattern 方法。在 RouteServiceProvider 类的 boot 方法中定义约束模式: public function boot() { Route::pattern(&apos;id&apos;, &apos;[0-9]+&apos;); parent::boot(); } 值得注意的是，路由参数是不允许出现 / 字符的，例如： $router-&gt;get(&apos;{one?}&apos;, [ &apos;uses&apos; =&gt; function ($one = null){ return $one; }, ]); $request = Request::create(&apos;foo/bar/baz&apos;, &apos;GET&apos;); $this-&gt;assertFalse($route-&gt;matches($request)); 上例中 one 只能匹配 foo，不能匹配 foo/bar/baz, 这时就需要对 one 进行正则约束： public function testLeadingParamDoesntReceiveForwardSlashOnEmptyPath() { $router = $this-&gt;getRouter(); $router-&gt;get(&apos;{one?}&apos;, [ &apos;uses&apos; =&gt; function ($one = null){ return $one; }, &apos;where&apos; =&gt; [&apos;one&apos; =&gt; &apos;(.+)&apos;], ]); $this-&gt;assertEquals(&apos;foo&apos;, $router-&gt;dispatch(Request::create(&apos;/foo&apos;, &apos;GET&apos;))-&gt;getContent()); $this-&gt;assertEquals(&apos;foo/bar/baz&apos;, $router-&gt;dispatch(Request::create(&apos;/foo/bar/baz&apos;, &apos;GET&apos;))-&gt;getContent()); } 路由中间件HTTP 中间件为过滤进入应用的 HTTP 请求提供了一套便利的机制。例如，Laravel 内置了一个中间件来验证用户是否经过认证，如果用户没有经过认证，中间件会将用户重定向到登录页面，否则如果用户经过认证，中间件就会允许请求继续往前进入下一步操作。 Laravel 框架自带了一些中间件，包括认证、CSRF 保护中间件等等。所有的中间件都位于 app/Http/Middleware 目录。 中间件之前 / 之后 / 终止一个中间件是请求前还是请求后执行取决于中间件本身。比如，以下中间件会在请求处理前执行一些任务： class BeforeMiddleware { public function handle($request, Closure $next) { // 执行动作 return $next($request); } } class AfterMiddleware { public function handle($request, Closure $next) { $response = $next($request); // 执行动作 return $response; } } 有时候中间件可能需要在 HTTP 响应发送到浏览器之后做一些工作。比如，Laravel 内置的 “session” 中间件会在响应发送到浏览器之后将 Session 数据写到存储器中，为了实现这个功能，需要定义一个终止中间件并添加 terminate 方法到这个中间件： class StartSession { public function handle($request, Closure $next) { return $next($request); } public function terminate($request, $response) { // 存储session数据... } } 全局中间件如果你想要中间件在每一个 HTTP 请求期间被执行，只需要将相应的中间件类设置到 app/Http/Kernel.php 的数组属性 $middleware 中即可。 protected $middleware = [ \Illuminate\Foundation\Http\Middleware\CheckForMaintenanceMode::class, \Illuminate\Foundation\Http\Middleware\ValidatePostSize::class, \App\Http\Middleware\TrimStrings::class, \Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull::class, ]; 路由中间件如果你想要分配中间件到指定路由，可以传递完整的类名： use App\Http\Middleware\CheckAge; Route::get(&apos;admin/profile&apos;, function () { // })-&gt;middleware(CheckAge::class); 或者可以给中间件提供一个别名： public function testDefinedClosureMiddleware() { $router = $this-&gt;getRouter(); $router-&gt;get(&apos;foo/bar&apos;, [&apos;middleware&apos; =&gt; &apos;foo&apos;, function () { return &apos;hello&apos;; }]); $router-&gt;aliasMiddleware(&apos;foo&apos;, function ($request, $next) { return &apos;caught&apos;; }); $this-&gt;assertEquals(&apos;caught&apos;, $router-&gt;dispatch(Request::create(&apos;foo/bar&apos;, &apos;GET&apos;))-&gt;getContent()); } 也可以应该在 app/Http/Kernel.php 文件中分配给该中间件一个 key，默认情况下，该类的 $routeMiddleware 属性包含了 Laravel 自带的中间件，要添加你自己的中间件，只需要将其追加到后面并为其分配一个 key，例如： protected $routeMiddleware = [ &apos;auth&apos; =&gt; \Illuminate\Auth\Middleware\Authenticate::class, &apos;auth.basic&apos; =&gt; \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class, &apos;bindings&apos; =&gt; \Illuminate\Routing\Middleware\SubstituteBindings::class, &apos;can&apos; =&gt; \Illuminate\Auth\Middleware\Authorize::class, &apos;guest&apos; =&gt; \App\Http\Middleware\RedirectIfAuthenticated::class, &apos;throttle&apos; =&gt; \Illuminate\Routing\Middleware\ThrottleRequests::class, ]; Route::get(&apos;admin/profile&apos;, function () { // })-&gt;middleware(&apos;auth&apos;); 使用数组分配多个中间件到路由： Route::get(&apos;/&apos;, function () { // })-&gt;middleware(&apos;first&apos;, &apos;second&apos;); 中间件组有时候你可能想要通过指定一个键名的方式将相关中间件分到同一个组里面，从而更方便将其分配到路由中，这可以通过使用 HTTP Kernel 的 $middlewareGroups 属性实现。 Laravel 自带了开箱即用的 web 和 api 两个中间件组以分别包含可以应用到 Web UI 和 API 路由的通用中间件： protected $middlewareGroups = [ &apos;web&apos; =&gt; [ \App\Http\Middleware\EncryptCookies::class, \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class, \Illuminate\Session\Middleware\StartSession::class, \Illuminate\View\Middleware\ShareErrorsFromSession::class, \App\Http\Middleware\VerifyCsrfToken::class, \Illuminate\Routing\Middleware\SubstituteBindings::class, ], &apos;api&apos; =&gt; [ &apos;throttle:60,1&apos;, &apos;auth:api&apos;, ], ]; Route::get(&apos;/&apos;, function () { // })-&gt;middleware(&apos;web&apos;); 值得注意的是，中间件组中可以循环嵌套中间件组： public function testMiddlewareGroupsCanReferenceOtherGroups() { unset($_SERVER[&apos;__middleware.group&apos;]); $router = $this-&gt;getRouter(); $router-&gt;get(&apos;foo/bar&apos;, [&apos;middleware&apos; =&gt; &apos;web&apos;, function () { return &apos;hello&apos;; }]); $router-&gt;aliasMiddleware(&apos;two&apos;, &apos;Illuminate\Tests\Routing\RoutingTestMiddlewareGroupTwo&apos;); $router-&gt;middlewareGroup(&apos;first&apos;, [&apos;two:abigail&apos;]); $router-&gt;middlewareGroup(&apos;web&apos;, [&apos;Illuminate\Tests\Routing\RoutingTestMiddlewareGroupOne&apos;, &apos;first&apos;]); $this-&gt;assertEquals(&apos;caught abigail&apos;, $router-&gt;dispatch(Request::create(&apos;foo/bar&apos;, &apos;GET&apos;))-&gt;getContent()); $this-&gt;assertTrue($_SERVER[&apos;__middleware.group&apos;]); unset($_SERVER[&apos;__middleware.group&apos;]); } 中间件参数中间件还可以接收额外的自定义参数，例如，如果应用需要在执行给定动作之前验证认证用户是否拥有指定的角色，可以创建一个 CheckRole 来接收角色名作为额外参数。 额外的中间件参数会在 $next 参数之后传入中间件： namespace App\Http\Middleware; use Closure; class CheckRole { public function handle($request, Closure $next, $role) { if (! $request-&gt;user()-&gt;hasRole($role)) { // Redirect... } return $next($request); } } Route::put(&apos;post/{id}&apos;, function ($id) { // })-&gt;middleware(&apos;role:editor&apos;); 中间件的顺序当 router 中有多个中间件的时候，中间件的执行顺序并不是严格按照中间件数组进行的，框架中存在一个数组 $middlewarePriority, 规定了这个数组中各个中间件的顺序： protected $middlewarePriority = [ \Illuminate\Session\Middleware\StartSession::class, \Illuminate\View\Middleware\ShareErrorsFromSession::class, \Illuminate\Auth\Middleware\Authenticate::class, \Illuminate\Session\Middleware\AuthenticateSession::class, \Illuminate\Routing\Middleware\SubstituteBindings::class, \Illuminate\Auth\Middleware\Authorize::class, ]; 当我们使用了上面其中多个中间件的时候，框架会自动按照上面的数组进行排序： public function testMiddlewarePrioritySorting() { $middleware = [ Placeholder1::class, SubstituteBindings::class, Placeholder2::class, Authenticate::class, Placeholder3::class, ]; $router = $this-&gt;getRouter(); $router-&gt;middlewarePriority = [Authenticate::class, SubstituteBindings::class, Authorize::class]; $route = $router-&gt;get(&apos;foo&apos;, [&apos;middleware&apos; =&gt; $middleware, &apos;uses&apos; =&gt; function ($name) { return $name; }]); $this-&gt;assertEquals([ Placeholder1::class, Authenticate::class, SubstituteBindings::class, Placeholder2::class, Placeholder3::class, ], $router-&gt;gatherRouteMiddleware($route)); } 控制器控制器类 更普遍的方法是使用控制器来组织管理这些行为。控制器可以将相关的 HTTP 请求封装到一个类中进行处理。通常控制器存放在 app/Http/Controllers 目录中. 所有的 Laravel 控制器应该继承自 Laravel 自带的控制器基类 Controller，控制器基类提供了一些很方便的方法如 middleware，用于添加中间件到控制器动作： class UserController extends Controller { public function show($id) { return view(&apos;user.profile&apos;, [&apos;user&apos; =&gt; User::findOrFail($id)]); } } Route::get(&apos;user/{id}&apos;, &apos;UserController@show&apos;); 单动作控制器如果想要定义一个只处理一个动作的控制器，可以在这个控制器中定义 __invoke 方法，当为这个单动作控制器注册路由的时候，不需要指定方法： public function testDispatchingCallableActionClasses() { $router = $this-&gt;getRouter(); $router-&gt;get(&apos;foo/bar&apos;, &apos;Illuminate\Tests\Routing\ActionStub&apos;); $this-&gt;assertEquals(&apos;hello&apos;, $router-&gt;dispatch(Request::create(&apos;foo/bar&apos;, &apos;GET&apos;))-&gt;getContent()); $router-&gt;get(&apos;foo/bar2&apos;, [ &apos;uses&apos; =&gt; &apos;Illuminate\Tests\Routing\ActionStub@func&apos;, ]); $this-&gt;assertEquals(&apos;hello2&apos;, $router-&gt;dispatch(Request::create(&apos;foo/bar2&apos;, &apos;GET&apos;))-&gt;getContent()); } class ActionStub extends Controller { public function __invoke() { return &apos;hello&apos;; } } 控制器中间件将中间件放在控制器构造函数中更方便，在控制器的构造函数中使用 middleware 方法你可以很轻松的分配中间件给该控制器。你甚至可以限定该中间件应用到该控制器类的指定方法： class UserController extends Controller { public function __construct() { $this-&gt;middleware(&apos;auth&apos;); $this-&gt;middleware(&apos;log&apos;)-&gt;only(&apos;index&apos;); $this-&gt;middleware(&apos;subscribed&apos;)-&gt;except(&apos;store&apos;); } } callAction 方法值得注意的是每次执行控制器方法都会先执行控制器的 callAction 函数： public function callAction($method, $parameters) { return call_user_func_array([$this, $method], $parameters); } 测试样例： unset($_SERVER[&apos;__test.controller_callAction_parameters&apos;]); $router-&gt;get(($str = str_random()).&apos;/{one}/{two}&apos;, &apos;Illuminate\Tests\Routing\RouteTestAnotherControllerWithParameterStub@oneArgument&apos;); $router-&gt;dispatch(Request::create($str.&apos;/one/two&apos;, &apos;GET&apos;)); $this-&gt;assertEquals([&apos;one&apos; =&gt; &apos;one&apos;, &apos;two&apos; =&gt; &apos;two&apos;], $_SERVER[&apos;__test.controller_callAction_parameters&apos;]); class RouteTestAnotherControllerWithParameterStub extends Controller { public function callAction($method, $parameters) { $_SERVER[&apos;__test.controller_callAction_parameters&apos;] = $parameters; } public function oneArgument($one) { } } __call 方法和普通类一样，若控制器中没有对应 classname@method 中的 method , 则会调用类的 __call 函数。 public function testCallableControllerRouting() { $router = $this-&gt;getRouter(); $router-&gt;get(&apos;foo/bar&apos;, &apos;Illuminate\Tests\Routing\RouteTestControllerCallableStub@bar&apos;); $router-&gt;get(&apos;foo/baz&apos;, &apos;Illuminate\Tests\Routing\RouteTestControllerCallableStub@baz&apos;); $this-&gt;assertEquals(&apos;bar&apos;, $router-&gt;dispatch(Request::create(&apos;foo/bar&apos;, &apos;GET&apos;))-&gt;getContent()); $this-&gt;assertEquals(&apos;baz&apos;, $router-&gt;dispatch(Request::create(&apos;foo/baz&apos;, &apos;GET&apos;))-&gt;getContent()); } class RouteTestControllerCallableStub extends Controller { public function __call($method, $arguments = []) { return $method; } } 路由参数依赖注入与绑定Laravel 使用服务容器解析所有的 Laravel 控制器，因此，可以在控制器的构造函数中类型声明任何依赖，这些依赖会被自动解析并注入到控制器实例中。路由的参数绑定可以分为两种：显示绑定与隐示绑定。路由隐示绑定 控制器方法期望输入路由参数，只需要将路由参数放到其他依赖之后 Route::put(&apos;user/{id}&apos;, &apos;UserController@update&apos;); class UserController extends Controller { public function update(Request $request, $id) { } } 可以在控制器的动作方法中进行依赖的类型提示，例如，我们可以在某个方法中类型提示 Illuminate\Http\Request 实例： class UserController extends Controller { public function store(Request $request) { $name = $request-&gt;input(&apos;name&apos;); } } 可以为控制器的动作方法中添加数据库模型的主键，框架会自动利用主键来获取对应的记录，需要注意的是，route 定义路由的路由参数必须和控制器内的变量名相同，例如下例中路由参数 userid 和控制器参数 userid: Route::put(&apos;user/{userid}&apos;, &apos;UserController@update&apos;); class UserController extends Controller { public function update(UserModel $userid) { $userid-&gt;name = &apos;taylor&apos;; $userid-&gt;update(); } } 综合测试样例：public function testImplicitBindingsWithOptionalParameter() { unset($_SERVER[&apos;__test.controller_callAction_parameters&apos;]); $router-&gt;get(($str = str_random()).&apos;/{user}/{defaultNull?}/{team?}&apos;, [ &apos;middleware&apos; =&gt; SubstituteBindings::class, &apos;uses&apos; =&gt; &apos;Illuminate\Tests\Routing\RouteTestAnotherControllerWithParameterStub@withModels&apos;, ]); $router-&gt;dispatch(Request::create($str.&apos;/1&apos;, &apos;GET&apos;)); $values = array_values($_SERVER[&apos;__test.controller_callAction_parameters&apos;]); $this-&gt;assertInstanceOf(&apos;Illuminate\Http\Request&apos;, $values[0]); $this-&gt;assertEquals(1, $values[1]-&gt;value); $this-&gt;assertNull($values[2]); $this-&gt;assertInstanceOf(&apos;Illuminate\Tests\Routing\RoutingTestTeamModel&apos;, $values[3]); } class RouteTestAnotherControllerWithParameterStub extends Controller { public function callAction($method, $parameters) { $_SERVER[&apos;__test.controller_callAction_parameters&apos;] = $parameters; } public function withModels(Request $request, RoutingTestUserModel $user, $defaultNull = null, RoutingTestTeamModel $team = null) { } } class RoutingTestUserModel extends Model { public function getRouteKeyName() { return &apos;id&apos;; } public function where($key, $value) { $this-&gt;value = $value; return $this; } public function first() { return $this; } public function firstOrFail() { return $this; } } class RoutingTestTeamModel extends Model { public function getRouteKeyName() { return &apos;id&apos;; } public function where($key, $value) { $this-&gt;value = $value; return $this; } public function first() { return $this; } public function firstOrFail() { return $this; } } 路由显示绑定除了隐示地转化路由参数外，我们还可以给路由参数显示提供绑定。显示绑定有 bind、model 两种方法。 通过 bind 为参数绑定闭包函数： public function testRouteBinding() { $router = $this-&gt;getRouter(); $router-&gt;get(&apos;foo/{bar}&apos;, [&apos;middleware&apos; =&gt; SubstituteBindings::class, &apos;uses&apos; =&gt; function ($name) { return $name; }]); $router-&gt;bind(&apos;bar&apos;, function ($value) { return strtoupper($value); }); $this-&gt;assertEquals(&apos;TAYLOR&apos;, $router-&gt;dispatch(Request::create(&apos;foo/taylor&apos;, &apos;GET&apos;))-&gt;getContent()); } 通过 bind 为参数绑定类方法，可以指定 classname@method，也可以直接使用类名，默认会调用类的 bind 函数： public function testRouteClassBinding() { $router = $this-&gt;getRouter(); $router-&gt;get(&apos;foo/{bar}&apos;, [&apos;middleware&apos; =&gt; SubstituteBindings::class, &apos;uses&apos; =&gt; function ($name) { return $name; }]); $router-&gt;bind(&apos;bar&apos;, &apos;Illuminate\Tests\Routing\RouteBindingStub&apos;); $this-&gt;assertEquals(&apos;TAYLOR&apos;, $router-&gt;dispatch(Request::create(&apos;foo/taylor&apos;, &apos;GET&apos;))-&gt;getContent()); } public function testRouteClassMethodBinding() { $router = $this-&gt;getRouter(); $router-&gt;get(&apos;foo/{bar}&apos;, [&apos;middleware&apos; =&gt; SubstituteBindings::class, &apos;uses&apos; =&gt; function ($name) { return $name; }]); $router-&gt;bind(&apos;bar&apos;, &apos;Illuminate\Tests\Routing\RouteBindingStub@find&apos;); $this-&gt;assertEquals(&apos;dragon&apos;, $router-&gt;dispatch(Request::create(&apos;foo/Dragon&apos;, &apos;GET&apos;))-&gt;getContent()); } class RouteBindingStub { public function bind($value, $route) { return strtoupper($value); } public function find($value, $route) { return strtolower($value); } } 通过 model 为参数绑定数据库模型，路由的参数就不需要和控制器方法中的变量名相同，laravel 会利用路由参数的值去调用 where 方法查找对应记录： if ($model = $instance-&gt;where($instance-&gt;getRouteKeyName(), $value)-&gt;first()) { return $model; } 测试样例如下： public function testModelBinding() { $router = $this-&gt;getRouter(); $router-&gt;get(&apos;foo/{bar}&apos;, [&apos;middleware&apos; =&gt; SubstituteBindings::class, &apos;uses&apos; =&gt; function ($name) { return $name; }]); $router-&gt;model(&apos;bar&apos;, &apos;Illuminate\Tests\Routing\RouteModelBindingStub&apos;); $this-&gt;assertEquals(&apos;TAYLOR&apos;, $router-&gt;dispatch(Request::create(&apos;foo/taylor&apos;, &apos;GET&apos;))-&gt;getContent()); } class RouteModelBindingStub { public function getRouteKeyName() { return &apos;id&apos;; } public function where($key, $value) { $this-&gt;value = $value; return $this; } public function first() { return strtoupper($this-&gt;value); } } 若绑定的 model 并没有找到对应路由参数的记录，可以在 model 中定义一个闭包函数，路由参数会调用闭包函数： public function testModelBindingWithCustomNullReturn() { $router = $this-&gt;getRouter(); $router-&gt;get(&apos;foo/{bar}&apos;, [&apos;middleware&apos; =&gt; SubstituteBindings::class, &apos;uses&apos; =&gt; function ($name) { return $name; }]); $router-&gt;model(&apos;bar&apos;, &apos;Illuminate\Tests\Routing\RouteModelBindingNullStub&apos;, function () { return &apos;missing&apos;; }); $this-&gt;assertEquals(&apos;missing&apos;, $router-&gt;dispatch(Request::create(&apos;foo/taylor&apos;, &apos;GET&apos;))-&gt;getContent()); } public function testModelBindingWithBindingClosure() { $router = $this-&gt;getRouter(); $router-&gt;get(&apos;foo/{bar}&apos;, [&apos;middleware&apos; =&gt; SubstituteBindings::class, &apos;uses&apos; =&gt; function ($name) { return $name; }]); $router-&gt;model(&apos;bar&apos;, &apos;Illuminate\Tests\Routing\RouteModelBindingNullStub&apos;, function ($value) { return (new RouteModelBindingClosureStub())-&gt;findAlternate($value); }); $this-&gt;assertEquals(&apos;tayloralt&apos;, $router-&gt;dispatch(Request::create(&apos;foo/TAYLOR&apos;, &apos;GET&apos;))-&gt;getContent()); } class RouteModelBindingNullStub { public function getRouteKeyName() { return &apos;id&apos;; } public function where($key, $value) { return $this; } public function first() { } } class RouteModelBindingClosureStub { public function findAlternate($value) { return strtolower($value).&apos;alt&apos;; } } router 扩展方法router 支持添加自定义的方法，只需要利用 macro 函数来注册对应的函数名和函数实现： public function testMacro() { $router = $this-&gt;getRouter(); $router-&gt;macro(&apos;webhook&apos;, function () use ($router) { $router-&gt;match([&apos;GET&apos;, &apos;POST&apos;], &apos;webhook&apos;, function () { return &apos;OK&apos;; }); }); $router-&gt;webhook(); $this-&gt;assertEquals(&apos;OK&apos;, $router-&gt;dispatch(Request::create(&apos;webhook&apos;, &apos;GET&apos;))-&gt;getContent()); $this-&gt;assertEquals(&apos;OK&apos;, $router-&gt;dispatch(Request::create(&apos;webhook&apos;, &apos;POST&apos;))-&gt;getContent()); }]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>框架</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel入门——数据库操作]]></title>
    <url>%2F2017%2F05%2F16%2FLaravel%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Laravel提供了3种操作数据库方式：DB facade（原始方式）、查询构造器和Eloquent ORM。 数据库的配置文件在config目录下的database.php里。打开这个文件，找到mysql的配置项。 目录 一、使用DB façade（原始查找）操作数据库 二、使用查询构造器操作数据库（核心）（重要） 三、Eloquent ORM操作数据库 详细目录结构：一、使用DB façade（原始查找）操作数据库+ （1）基本的数据库操作路由配置 + （2）数据库façade操作模型StudentController建立 二、使用查询构造器操作数据库（核心）（重要） （1）新增数据 1-1. 新增数据返回布尔值 1-2. 新增数据返回ID 1-3. 新增多条数据 （2）修改数据 2-1. *常用修改数据方式 2-2. 自增自减修改数据方式 （3）修改数据 （4）查询数据（first()、where()、pluck()、select()、chunk()） （5）内置的聚合函数 三、Eloquent ORM操作数据库（1）Eloquent ORM模型的建立及查询数据 （2）Eloquent ORM中新增数据、自定义时间戳、批量赋值 （3）Eloquent ORM修改数据 （4）Eloquent ORM 删除数据 实战使用一、使用DB façade（原始查找）操作数据库（1）基本的数据库操作路由配置：//新增数据 Route::get(&apos;student/add/{name?}/{age?}&apos;,[&apos;uses&apos; =&gt; &apos;StudentController@addStudentInfo&apos;])-&gt;where([&apos;name&apos; =&gt; &apos;^[\x{4e00}-\x{9fa5}_a-zA-Z0-9]+$&apos;,&apos;age&apos; =&gt; &apos;\d+&apos;]); //修改数据 Route::get(&apos;student/update/{id?}/{name?}&apos;,[&apos;uses&apos; =&gt; &apos;StudentController@updateStudentInfo&apos;])-&gt;where([&apos;id&apos; =&gt; &apos;\d+&apos;,&apos;name&apos; =&gt; &apos;^[\x{4e00}-\x{9fa5}_a-zA-Z0-9]+$&apos;]); //删除数据 Route::get(&apos;student/delete/{id}&apos;,[&apos;uses&apos; =&gt; &apos;StudentController@deleteStudentInfo&apos;])-&gt;where([&apos;id&apos;=&gt;&apos;\d+&apos;]); //查询数据 Route::get(&apos;student/find&apos;,[&apos;uses&apos; =&gt; &apos;StudentController@findStudentInfo&apos;]); （2）数据库façade操作模型StudentController建立（app\Http\Controllers\StudentController.php）namespace App\Http\Controllers; use Illuminate\Routing\Controller as BaseController; use Illuminate\Support\Facades\DB; class StudentController extends Controller { /** * [新增数据] * @param string $name [新增姓名] * @param integer $age [新增年龄] * @return [Boolean] [新增情况] */ public function addStudentInfo($name = &apos;我的女神&apos;,$age = 16){ $insertBoolean = DB::insert(&apos;insert into student(name, age) values(?, ?)&apos;,[$name,$age]); return var_dump($insertBoolean); //bool(true) } /** * [修改数据] * @param integer $id [要修改的ID] * @param string $name [要修改成的姓名] * @return [int] [修改的行数] */ public function updateStudentInfo($id = 1002,$name = &apos;放牛娃的春天&apos;){ $updateRows = DB::update(&apos;update student set name = ? where id = ?&apos;,[$name,$id]); return var_dump($updateRows); //int(1) } /** * [删除数据] * @param [type] $id [要删除行的ID] * @return [int] [删除的行数] */ public function deleteStudentInfo($id){ $deleteRows = DB::delete(&apos;delete from student where id = ?&apos;,[$id]); return $deleteRows; //int(1) } /** * [查询数据] * @return [array] [查询数据的数组集合] */ public function findStudentInfo(){ $doc = DB::select(&apos;select * from student&apos;); return dd($doc); //调试模式dd() } } 二、使用查询构造器操作数据库（核心）（重要）简介：Laravel查询构造器（query builder）提供方便、流畅的接口，用来建立及执行数据库查找语法；其使用PDO参数绑定，以保护应用程序免于SQL注入因此传入的参数不需额外转义特殊字符 详细了解PDO参数绑定，请参考：https://www.jianshu.com/p/f432fee5d901 （1）新增数据1-1.新增数据返回布尔值 /** * [使用查询构造器新增数据] * @param string $name [新增的姓名] * @param integer $age [新增的年龄] * @return [boolean] [新增是否成功] */ public function queryAdd($name = &apos;王小二的女朋友&apos;,$age = 23){ $addBool = DB::table(&apos;student&apos;)-&gt;insertGetId([ &apos;name&apos; =&gt; $name, &apos;age&apos; =&gt; $age ]); return var_dump($addBool); //int(1009) } 1-2.新增数据返回ID /** * [使用查询构造器新增数据] * @param string $name [新增的姓名] * @param integer $age [新增的年龄] * @return [int] [新增的ID] */ public function queryAdd($name = &apos;王小二的女朋友&apos;,$age = 23){ $addId = DB::table(&apos;student&apos;)-&gt;insertGetId([ &apos;name&apos; =&gt; $name, &apos;age&apos; =&gt; $age ]); return var_dump($addId); //int(1009) } 1-3.新增多条数据 /** * [使用查询构造器新增多条数据] * @return [boolean] [新增是否成功] */ public function queryAddMore(){ $addBool = DB::table(&apos;student&apos;)-&gt;insert([ [&apos;name&apos; =&gt; &apos;赵云&apos;, &apos;age&apos; =&gt; 32], [&apos;name&apos; =&gt; &apos;张飞&apos;, &apos;age&apos; =&gt; 35], [&apos;name&apos; =&gt; &apos;周瑜&apos;, &apos;age&apos; =&gt; 28], [&apos;name&apos; =&gt; &apos;黄盖&apos;, &apos;age&apos; =&gt; 36] ]); return var_dump($addBool); // bool(true) } （2）修改数据2-1. *常用修改数据方式： /** * [使用查询构造器更新数据] * @param integer $id [要更新的ID] * @param string $name [要更新的姓名] * @return [int] [更新的行数] */ public function queryUpdate($id = 1007,$name = &apos;放牧的星星&apos;){ $updateRows = DB::table(&apos;student&apos;)-&gt;where(&apos;id&apos;, $id)-&gt;update([&apos;name&apos; =&gt; $name]); return var_dump($updateRows); //int(1) } 2-2. 自增自减修改数据方式： （3）删除数据/** * [使用查询构造器删除数据] * @param [int] $id [要删除项的ID] * @return [int] [删除的行数] */ public function queryDelete($id){ $deleteRows = DB::table(&apos;student&apos;)-&gt;where([&apos;id&apos; =&gt; $id])-&gt;delete(); // 删除总表 ( 不建议使用 ) // DB::table(&apos;student&apos;)-&gt;truncate(); return var_dump($deleteRows); // int(1) } （4）查询数据（ get()、 first() 、 where() 、 pluck() 、 lists()[新版本已弃用] 、 select() 、 chunk() ）/** * [查询构造器查询数据] */ public function queryFind(){ //1. first方法使用，查找制定顺序的第一个（默认升序asc） /*$doc = DB::table(&apos;student&apos;)-&gt;orderBy(&apos;id&apos;,&apos;asc&apos;)-&gt;first(); print_r($doc); 打印：stdClass Object ( [id] =&gt; 1003 [name] =&gt; 大黄蜂 [age] =&gt; 18 [sex] =&gt; 10 [created_at] =&gt; 0 [updated_at] =&gt; 0 )*/ //2. where使用 ( 查询ID小于1005的所有数据 ) /*2-1. $doc = DB::table(&apos;student&apos;)-&gt;where(&apos;id&apos;,&apos;&lt;&apos;,1005)-&gt;get(); 2-2. $doc = DB::table(&apos;student&apos;)-&gt;whereRaw(&apos;id &gt; ? and age &lt; ?&apos;,[1001,20])-&gt;get();*/ //3. pluck方法使用 ( 返回对应字段的列的数组 ) /* $doc = DB::table(&apos;student&apos;)-&gt;where(&apos;age&apos;,&apos;&gt;=&apos;,30)-&gt;pluck(&apos;name&apos;,&apos;id&apos;); print_r($doc); //打印： Illuminate\Support\Collection Object ( [items:protected] =&gt; Array ( [0] =&gt; 赵云 [1] =&gt; 张飞 [2] =&gt; 黄盖 ) )*/ //4. lists方法的使用 ( 返回对应字段的key-value数组，类似于上面的pluck方法 ) [注意新版本Laravel已经弃用该lists方法] // $doc = DB::table(&apos;student&apos;)-&gt;where(&apos;age&apos;,&apos;&gt;=&apos;,30)-&gt;lists(&apos;name&apos;,&apos;id&apos;); //5. select方法的使用 (返回对应字段的数据列表) /*$doc = DB::table(&apos;student&apos;)-&gt;where(&apos;id&apos;,&apos;&lt;=&apos;,&apos;1004&apos;)-&gt;select(&apos;name&apos;,&apos;age&apos;,&apos;id&apos;)-&gt;get(); print_r($doc); //打印： Illuminate\Support\Collection Object ( [items:protected] =&gt; Array ( [0] =&gt; stdClass Object ( [name] =&gt; 大黄蜂 [age] =&gt; 18 [id] =&gt; 1003 ) [1] =&gt; stdClass Object ( [name] =&gt; 我的女神 [age] =&gt; 16 [id] =&gt; 1004 ) ) )*/ // 6. chunk方法的使用 ( 分段查询 ) /*DB::table(&apos;student&apos;)-&gt;orderBy(&apos;id&apos;,&apos;desc&apos;)-&gt;chunk(2,function($result){ dd($result); });*/ //dd($doc); //return var_dump($doc); } （5）内置的聚合函数 常用：count()、max()、min()、avg()、sum() /** * [查询构造器聚合函数] */ public function queryFunc(){ $count = DB::table(&apos;student&apos;)-&gt;count(); echo $count; // 11 $max = DB::table(&apos;student&apos;)-&gt;max(&apos;age&apos;); echo $max; //36 $avg = DB::table(&apos;student&apos;)-&gt;avg(&apos;age&apos;); echo $avg; //21.0909 $sum = DB::table(&apos;student&apos;)-&gt;sum(&apos;age&apos;); echo $sum; //232 } 三、Eloquent ORM操作数据库概述： Laravel 的 Eloquent ORM 提供了漂亮、简洁的 ActiveRecord 实现来和数据库的互动。 每个数据库表会和一个对应的「模型」互动。 在开始之前，记得把 config/database.php 里的数据库连接配置好。 我们先从建立一个 Eloquent 模型开始。模型通常放在 app 目录下，但是您可以将它们放在任何地方，只要能通过 composer.json 自动载入。所有的 Eloquent 模型都继承于 Illuminate\Database\Eloquent\Model . 1. Eloquent ORM模型的建立及查询数据/** * [ORM操作数据库查询数据] * @return [type] [数据集合] */ public function eloquentORM(){ //1. 查询所有数据 $results1 = Student::all(); $results1 = Student::get(); //2. 根据主键查找其中某条数据 $results2 = Student::find(1001); //3. 根据主键查找/如果没查到报错 $results3 = Student::findOrFail(1007); //4. 带条件查询 $results4 = Student::where(&apos;id&apos;,&apos;&gt;&apos;,1008)-&gt;orderBy(&apos;age&apos;,&apos;desc&apos;)-&gt;get(); //5. 分段查询 Student::chunk(2,function($results5){}); //6. 聚合函数使用 $count = Student::sum(&apos;age&apos;); } 2. Eloquent ORM中新增数据、自定义时间戳、批量赋值/** * [使用ORM新增数据] * @return [object] [新增的数据项] */ public function eloquentORMAdd(){ /* $student = new Student(); $student-&gt;name = &apos;叮咚叮咚的小溪&apos;; $student-&gt;age = 12; $s = $student-&gt;save(); dd($student);*/ //2. 使用模型的Create方法新增数据 ( 报错：需要在Student模型中添加：protected $fillable = [&apos;name&apos;,&apos;age&apos;]; ) /*$result = Student::create( [&apos;name&apos; =&gt; &apos;两只吵架的小英短&apos;,&apos;age&apos; =&gt; 1] ); dd($result);*/ // 3. firstOrCreate() 查询，无则新增，返回新的实例对象 /*$result = Student::firstOrCreate( [&apos;name&apos; =&gt; &apos;张飞&apos;] ); dd($result);*/ // 4. firstOrNew() 查询，无则新增，新增需要save，返回新的实例 /*$result = Student::firstOrNew( [&apos;name&apos; =&gt; &apos;共烧茄子拌豆腐&apos;,&apos;age&apos; =&gt; 12] ); $result -&gt; save(); dd($result);*/ } 3. Eloquent ORM修改数据/** * [使用ORM更新数据] */ public function eloquentORMUpdate(){ //1. 通过模型更新 /*$student = Student::find(1017); $student-&gt;name = &apos;红色小短裙的胖胖猪&apos;; $student-&gt;age = 8; $bool = $student-&gt;save(); dd($bool);*/ //true //报错： Call to a member function format() on string 解决：Student模型中关闭方法asDateTime //2. 通过结合查询语句 批量更新 $rowNum = Student::where(&apos;id&apos;,&apos;&gt;&apos;,1022)-&gt;update( [&apos;age&apos; =&gt; 32] ); var_dump($rowNum); //int(1) } 4. Eloquent ORM 删除数据/** * [eloquentORMDelete description] * @return [type] [description] */ public function eloquentORMDelete(){ //1. 通过模型删除 /* $student = Student::find(1016); $bool = $student-&gt;delete(); var_dump($bool); //bool(true)*/ //2. 通过主键值删除 /*$numRow = Student::destroy(1022, 1018); var_dump($numRow); //int(1)*/ //3. 通过指定条件删除 /* $numRow = Student::where(&apos;id&apos;,&apos;&gt;&apos;,1013)-&gt;delete(); var_dump($numRow); //int(7)*/ }]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>框架</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel入门——视图]]></title>
    <url>%2F2017%2F05%2F16%2FLaravel%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[Blade 简介Blade 是由 Laravel 提供的非常简单但功能强大的模板引擎，不同于其他流行的 PHP 模板引擎，Blade 在视图中并不约束你使用 PHP 原生代码。所有的 Blade 视图最终都会被编译成原生 PHP 代码并缓存起来直到被修改，这意味着对应用的性能而言 Blade 基本上是零开销。 Blade 视图文件（也叫模板文件）使用 .blade.php 文件扩展名，都存放在 resources/views 目录下。 模板继承1. 定义布局使用 Blade 的两个最大优点是模板继承和片段组合，开始之前让我们先看一个例子。 首先，我们测试主页面布局，由于大多数 Web 应用在不同页面中使用同一个布局，可以很方便的将这个布局定义为一个单独的 Blade 页面。 在 resources/views/layouts 目录中，创建一个布局文件 layout.blade.php，内容如下： 1234567891011121314&lt;html&gt; &lt;head&gt; &lt;title&gt;应用名称 - @yield(&apos;title&apos;)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; @section(&apos;sidebar&apos;) 这里是侧边栏 @show &lt;div class=&quot;container&quot;&gt; @yield(&apos;content&apos;) &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 该文件包含典型的 HTML 标记，不过，注意 “@section” 和 “@yield” 指令，前者定义了一个内容片段，而后者用于显示给定片段的内容。 现在我们已经为应用定义了一个布局，接下来定义继承该布局的子页面。 2. 继承布局定义子页面时，可以使用 Blade 的 “@extends” 指令来指定子页面所继承的布局，继承一个 Blade 布局的视图可以使用 “@section” 指令注入内容到布局定义的内容片段中。 如上面例子所示，这些片段的内容将会显示在布局中使用 @yield 的地方。 在 resources/views 目录中，创建视图文件 child.blade.php，内容如下： 123456789101112@extends(&apos;layouts.layout&apos;) @section(&apos;title&apos;, &apos;视图标题&apos;) @section(&apos;sidebar&apos;) @parent &lt;p&gt;这是子页面的内容&lt;/p&gt;@endsection @section(&apos;content&apos;) &lt;p&gt;这里是主体内容，完善中...&lt;/p&gt;@endsection 在本例中，sidebar 片段使用 “@parent” 指令来追加（而非覆盖）内容到布局的侧边栏，”@parent” 指令在视图渲染时将会被布局中的内容替换。 然后，在 routes/web.php 中定义路由以便访问该视图。 123Route::get(&apos;blade&apos;, function () &#123; return view(&apos;child&apos;);&#125;); 在浏览器中访问 http://www.adm.devp/blade ，查看显示效果。 3. 组件&amp;插槽组件和插槽给内容片段（section）和布局（layout）带来了方便，不过，有些人可能会发现组件和插槽的模型更容易理解。 首先，我们假设有一个可复用的“alert”组件，我们想要在整个应用中都可以复用它。 创建 resources/views/alert.blade.php 文件，内容如下： 123&lt;div class=&quot;alert alert-danger&quot;&gt; `&#123;`&#123; $slot &#125;`&#125;`&lt;/div&gt; {{ $slot }} 变量包含了我们想要注入组件的内容，现在，要构建这个组件，我们可以使用 Blade 指令 @component。 123@component(&apos;alert&apos;) &lt;strong&gt;Whoops!&lt;/strong&gt; Something went wrong!@endcomponent 有时，为组件定义多个插槽很有用。下面我们来编辑 alert 组件。 修改 resources/views/alert.blade.php 文件： 1234&lt;div class=&quot;alert alert-danger&quot;&gt; &lt;div class=&quot;alert-title&quot;&gt;`&#123;`&#123; $title &#125;`&#125;`&lt;/div&gt; `&#123;`&#123; $slot &#125;`&#125;`&lt;/div&gt; 现在，我们可以使用指令 @slot 注入内容到命名的插槽。任何不在 @slot 指令中的内容都会被传递到组件的 $slot 变量中。 1234567@component(&apos;alert&apos;) @slot(&apos;title&apos;) Forbidden @endslot You are not allowed to access this resource!@endcomponent 这段代码的意思是通过组件名 alert 去查找对应的视图文件，装载到当前视图，然后通过组件中 “@slot” 定义的插槽内容去渲染插槽视图中对应的插槽位，如果组件没有为某个插槽位定义对应的插槽内容片段，则组件中的其他不在 “@slot” 片段中的内容将会用于渲染该插槽位，如果没有其他多余内容则对应插槽位为空。传递额外数据到组件 有时，你可能需要传递额外数据到组件，出于这个原因，你可以传递数组数据作为第二个参数到 @component 指令，所有数据都会在组件模板中以变量方式生效： 123@component(&apos;alert&apos;, [&apos;foo&apos; =&gt; &apos;bar&apos;]) ...@endcomponent 4. 数据显示可以通过两个花括号包裹变量的形式，来显示传递到视图的数据。 比如，如果给出如下路由： 123Route::get(&apos;greeting&apos;, function () &#123; return view(&apos;welcome&apos;, [&apos;name&apos; =&gt; &apos;jack&apos;]);&#125;); 在视图文件中，显示 name 变量的内容： 1`&#123;`&#123; $name &#125;`&#125;` 你还可以在视图文件中输出任何 PHP 函数的结果，实际上，可以将任何 PHP 代码放到 Blade 模板中： 1The current UNIX timestamp is `&#123;`&#123; time() &#125;`&#125;`. 注：Blade 的 “{{ }}“ 语句已经经过 PHP 的 htmlentities 函数处理以避免 XSS 攻击。 5. 输出存在的数据有时候你想要输出一个变量，但是不确定该变量是否被设置，我们可以通过如下 PHP 代码： 1&#123; isset($name) ? $name : &apos;Default&apos; &#125;`&#125;` 除了使用三元运算符，Blade 还提供了更简单的方式： 1`&#123;`&#123; $name or &apos;Default&apos; &#125;`&#125;` 在本例中，如果 $name 变量存在，其值将会显示，否则将会显示 Default。 6. 显示原生数据默认情况下，Blade 的 {{ }} 语句已经通过 PHP 的 htmlentities 函数处理以避免 XSS 攻击，如果你不想要数据被处理，比如要输出带 HTML 元素的富文本，可以使用如下语法： 1Hello, &#123;!! $name !!&#125;. 注：输出用户提供的内容时要当心，对用户提供的内容总是要使用双花括号包裹以避免直接输出 HTML 代码。 7. 渲染 JSON 内容有时，你可能会将数据以数组方式传递到视图再将其转化为 JSON 格式以便初始化某个 JavaScript 变量，例如： 123&lt;script&gt; var app = &lt;?php echo json_encode($array); ?&gt;;&lt;/script&gt; 这样显得很麻烦，有更简便的方式来实现这个功能，那就是 Blade 的 @json 指令： 123&lt;script&gt; var app = @json($array);&lt;/script&gt; 8. Blade &amp; JavaScript 框架由于很多 JavaScript 框架也是用花括号来表示要显示在浏览器中的表达式，如 Vue，我们可以使用 @ 符号来告诉 Blade 引擎该表达式应该保持原生格式不作改动。比如： 12&lt;h1&gt;Laravel&lt;/h1&gt;Hello, @`&#123;`&#123; name &#125;`&#125;`. 在本例中，@ 符号在编译阶段会被 Blade 移除，但是，{{ name }} 表达式将会保持不变，从而可以被 JavaScript 框架正常渲染。@verbatim指令 如果你在模板中有很大一部分篇幅显示 JavaScript 变量，那么可以将这部分 HTML 封装在 @verbatim 指令中，这样就不需要在每个 Blade 输出表达式前加上 @ 前缀。 12345@verbatim &lt;div class=&quot;container&quot;&gt; Hello, `&#123;`&#123; name &#125;`&#125;`. &lt;/div&gt;@endverbatim 9. 流程控制除了模板继承和数据显示之外，Blade 还为常用的 PHP 流程控制提供了便利操作，例如条件语句和循环。If 语句 可以使用 @if , @elseif , @else 和 @endif 来构造 if 语句，这些指令的功能和 PHP 相同： 1234567@if (count($records) === 1) I have one record!@elseif (count($records) &gt; 1) I have multiple records!@else I don&apos;t have any records!@endif 为方便起见，Blade 还提供了 @unless 指令，表示除非： 123@unless (Auth::check()) You are not signed in.@endunless 此外，Blade 还提供了 “@isset” 和 “@empty” 指令，分别对应 PHP 的 isset 和 empty 方法： 1234567@isset($records) // $records is defined and is not null...@endisset @empty($records) // $records is &quot;empty&quot;...@endempty 10. 认证指令@auth 和 @guest 指令可用于快速判断当前用户是否登录： 1234567@auth // 用户已登录...@endauth @guest // 用户未登录...@endguest 如果需要的话，你也可以在使用 @auth 和 @guest 的时候指定登录用户类型： 1234567@auth(&apos;admin&apos;) // The user is authenticated...@endauth @guest(&apos;admin&apos;) // The user is not authenticated...@endguest 关于用户登录认证我们后面再讲到用户认证的时候再深入探讨。 11. Switch 语句switch 语句可以通过 @switch，@case，@break，@default 和 @endswitch 指令构建： 123456789101112@switch($i) @case(1) First case... @break @case(2) Second case... @break @default Default case...@endswitch 12. 循环语句Blade 还提供了简单的指令用于处理 PHP 的循环结构。 1234567891011121314151617@for ($i = 0; $i &lt; 10; $i++) The current value is `&#123;`&#123; $i &#125;`&#125;`@endfor @foreach ($users as $user) &lt;p&gt;This is user `&#123;`&#123; $user-&gt;id &#125;`&#125;`&lt;/p&gt;@endforeach @forelse ($users as $user) &lt;li&gt;`&#123;`&#123; $user-&gt;name &#125;`&#125;`&lt;/li&gt;@empty &lt;p&gt;No users&lt;/p&gt;@endforelse @while (true) &lt;p&gt;I&apos;m looping forever.&lt;/p&gt;@endwhile 注：在循环的时候可以使用 $loop 变量获取循环信息，例如是否是循环的第一个或最后一个迭代。 使用循环的时候还可以结束循环或跳出当前迭代： 1234567891011@foreach ($users as $user) @if ($user-&gt;type == 1) @continue @endif &lt;li&gt;`&#123;`&#123; $user-&gt;name &#125;`&#125;`&lt;/li&gt; @if ($user-&gt;number == 5) @break @endif@endforeach 还可以使用指令声明来引入条件： 12345@foreach ($users as $user) @continue($user-&gt;type == 1) &lt;li&gt;`&#123;`&#123; $user-&gt;name &#125;`&#125;`&lt;/li&gt; @break($user-&gt;number == 5)@endforeach 13. $loop 变量在循环的时候，可以在循环体中使用 $loop 变量，该变量提供了一些有用的信息，比如当前循环索引，以及当前循环是不是第一个或最后一个迭代： 1234567891011@foreach ($users as $user) @if ($loop-&gt;first) This is the first iteration. @endif @if ($loop-&gt;last) This is the last iteration. @endif &lt;p&gt;This is user `&#123;`&#123; $user-&gt;id &#125;`&#125;`&lt;/p&gt;@endforeach 如果是嵌套循环，可以通过 $loop 变量的 parent 属性访问父级循环： 1234567@foreach ($users as $user) @foreach ($user-&gt;posts as $post) @if ($loop-&gt;parent-&gt;first) This is first iteration of the parent loop. @endif @endforeach@endforeach $loop 变量还提供了其他一些有用的属性： 123456789属性 说明$loop-&gt;index 当前循环迭代的索引 (从0开始)$loop-&gt;iteration 当前循环迭代 (从1开始)$loop-&gt;remaining 当前循环剩余的迭代$loop-&gt;count 迭代数组元素的总数量$loop-&gt;first 是否是当前循环的第一个迭代$loop-&gt;last 是否是当前循环的最后一个迭代$loop-&gt;depth 当前循环的嵌套层级$loop-&gt;parent 嵌套循环中的父级循环变量 Blade 还允许你在视图中定义注释，然而，不同于 HTML 注释，Blade 注释并不会包含到 HTML 中被返回： 1`&#123;`&#123;-- This comment will not be present in the rendered HTML --&#125;`&#125;` 14. 嵌入原生 PHP 代码在一些场景中，嵌入 PHP 代码到视图中很有用，你可以使用 @php 指令在模板中执行一段原生 PHP 代码： 123@php //@endphp 注：尽管 Blade 提供了这个特性，如果过于频繁地使用它意味着你在视图模板中嵌入了过多的业务逻辑，需要注意。 15. 包含子视图Blade 的 @include 指令允许你很轻松地在一个视图中包含另一个 Blade 视图，所有父级视图中的变量在被包含的子视图中依然有效： 1234567&lt;div&gt; @include(&apos;shared.errors&apos;) &lt;form&gt; &lt;!-- Form Contents --&gt; &lt;/form&gt;&lt;/div&gt; 上述指令会在当前目录下的 shared 子目录中寻找 errors.blade.php 文件并将其内容引入当前视图。 尽管被包含的视图可以继承所有父视图中的数据，你还可以传递额外参数到被包含的视图： 1@include(&apos;view.name&apos;, [&apos;some&apos; =&gt; &apos;data&apos;]) 当然，如果你尝试包含一个不存在的视图，Laravel 会抛出错误，如果你想要包含一个有可能不存在的视图，可以使用 @includeIf 指令： 1@includeIf(&apos;view.name&apos;, [&apos;some&apos; =&gt; &apos;data&apos;]) 如果包含的视图取决于一个给定的布尔条件，可以使用 @includeWhen 指令： 1@includeWhen($boolean, &apos;view.name&apos;, [&apos;some&apos; =&gt; &apos;data&apos;]) 要包含给定数组中的第一个视图，可以使用 @includeFirst 指令： 1@includeFirst([&apos;custom.admin&apos;, &apos;admin&apos;], [&apos;some&apos; =&gt; &apos;data&apos;]) 注：不要在 Blade 视图中使用 DIR 和 FILE 常量，因为它们会指向缓存视图的路径。 16. 渲染集合视图可以使用 Blade 的 @each 指令通过一行代码循环引入多个局部视图： 1@each(&apos;view.name&apos;, $jobs, &apos;job&apos;) 该指令的第一个参数是数组或集合中每个元素要渲染的局部视图，第二个参数是你希望迭代的数组或集合，第三个参数是要分配给当前视图的变量名。 举个例子，如果你要迭代一个 jobs 数组，通常你需要在局部视图中访问 $job 变量。在局部视图中可以通过 key 变量访问当前迭代的键。 你还可以传递第四个参数到 @each 指令，该参数用于指定给定数组为空时渲染的视图： 1@each(&apos;view.name&apos;, $jobs, &apos;job&apos;, &apos;view.empty&apos;) 17. 堆栈Blade 允许你推送内容到命名堆栈，以便在其他视图或布局中渲染。这在子视图中引入指定 JavaScript 库时很有用： 123@push(&apos;scripts&apos;) &lt;script src=&quot;/example.js&quot;&gt;&lt;/script&gt;@endpush 推送次数不限，要渲染完整的堆栈内容，传递堆栈名称到 @stack 指令即可： 12345&lt;head&gt; &lt;!-- Head Contents --&gt; @stack(&apos;scripts&apos;)&lt;/head&gt; 18. 服务注入@inject 指令可以用于从服务容器中获取服务，传递给 @inject 的第一个参数是服务对应的变量名，第二个参数是要解析的服务类名或接口名： 12345@inject(&apos;metrics&apos;, &apos;App\Services\MetricsService&apos;) &lt;div&gt; Monthly Revenue: `&#123;`&#123; $metrics-&gt;monthlyRevenue() &#125;`&#125;`.&lt;/div&gt; 19. 扩展 BladeBlade 甚至还允许你自定义指令，可以使用 directive 方法来注册一个指令。当 Blade 编译器遇到该指令，将会传入参数并调用提供的回调。 下面的例子创建了一个 @datetime($var) 指令格式化给定的 DateTime 的实例 $var： 12345678910111213141516171819202122232425262728293031&lt;?php namespace App\Providers; use Illuminate\Support\Facades\Blade;use Illuminate\Support\ServiceProvider; class AppServiceProvider extends ServiceProvider&#123; /** * Perform post-registration booting of services. * * @return void */ public function boot() &#123; \Blade::directive(&apos;datetime&apos;, function($expression) &#123; return &quot;&lt;?php echo date(&apos;Y-m-d H:i:s&apos;, $expression); ?&gt;&quot;; &#125;); &#125; /** * 在容器中注册绑定. * * @return void */ public function register() &#123; // &#125;&#125; 在视图文件中使用该自定义指令： 1@datetime(1508888888) 注：更新完 Blade 指令逻辑后，必须删除所有的 Blade 缓存视图。缓存的 Blade 视图可以通过 Artisan 命令 view:clear 移除。 20. 自定义 if 语句在定义一些简单、自定义的条件语句时，编写自定义指令往往复杂性大于必要性，因为这个原因，Blade 提供了一个 Blade::if 方法通过闭包的方式快速定义自定义的条件指令，例如，我们来自定义一个条件来检查当前应用的环境，我们可以在 AppServiceProvider 的 boot 方法中定义这段逻辑。 12345678910111213use Illuminate\Support\Facades\Blade; /** * Perform post-registration booting of services. * * @return void */public function boot()&#123; \Blade::if(&apos;env&apos;, function ($environment) &#123; return app()-&gt;environment($environment); &#125;);&#125; 定义好自定义条件后，就可以在模板中使用了： 12345@env(&apos;local&apos;) The application is in the local environment...@else The application is not in the local environment...@endenv]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>框架</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel入门——控制器]]></title>
    <url>%2F2017%2F05%2F16%2FLaravel%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%8E%A7%E5%88%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[简介 控制器是模型和视图的桥梁！ 手动写Controller在App\Http\Controllers下编写Controller，本身会自带一个Controller，我们可以新建一个Controller继承该Controller。 之前是直接在路由就返回视图，而视图一般应该由Controller来操作。我们可以像这样定义指向该控制器动作的路由： //第二个参数@之前的是控制器名称，之后是方法名称 Route::get(&apos;user/{id}&apos;, &apos;UserController@showProfile&apos;); 还能自动创建，使用artisan命令，在根目录，也就是app文件所在的目录（我也不太清楚其他目录行不行） php artisan make:controller UserController 如果要改自定义Controller的目录，也就是再建一个文件夹做个分类，那么要记得改namespace，而且继承的Controller要用use引入。而且路由的第二个参数也要加上新建的目录。‘Admin\UserController@showProfile’ RESTful 资源控制器Route::resource(&apos;photo&apos;, &apos;PhotoController&apos;); 控制器用于将相关的 HTTP 请求封装到一个类中进行处理，这些控制器类存放在 app/Http/Controllers 目录下。 控制器入门定义控制器可使用 Artisan 命令快速创建一个控制器。 php artisan make:controller UserController 这样，会自动生成 app/Http/Controllers/UserController.php 文件，内容如下： &lt;?php namespace App\Http\Controllers; use Illuminate\Http\Request; class UserController extends Controller { // } 所有的控制器一般会继承 Laravel 自带的控制器基类 App\Http\Controllers\Controller。 现在，在该控制器中添加 show 方法。 &lt;?php namespace App\Http\Controllers; use App\User; use Illuminate\Http\Request; class UserController extends Controller { /** * 为指定用户显示详情 * * @param int $id * @return Response */ public function show($id) { return view(&apos;user.profile&apos;, [&apos;user&apos; =&gt; User::findOrFail($id)]); } } 然后，在 routes/web.php 中定义路由： Route::get(&apos;user/{id}&apos;, &apos;UserController@show&apos;); 现在，如果一个请求匹配上面的路由 URI，UserController 的 show 方法就会被执行，当然，路由参数也会被传递给这个方法。 此外，这里的 show 方法里面还用到了 view 方法，该方法用于将 user 变量渲染到 user/profile 视图中。 然后在 resources/veiws 目录下创建 user 子目录，然后在 user 目录下新建 profile.blade.php 视图文件，内容如下： {{ dd($user) }} 现在，在浏览器中访问 http://www.adm.devp/user/1 ，就可看到打印结果： User {#208 ▼ #fillable: array:3 [▶] #hidden: array:2 [▶] #connection: &quot;mysql&quot; #table: null #primaryKey: &quot;id&quot; #keyType: &quot;int&quot; +incrementing: true #with: [] #withCount: [] #perPage: 15 +exists: true +wasRecentlyCreated: false #attributes: array:7 [▶] #original: array:7 [▶] #changes: [] #casts: [] #dates: [] #dateFormat: null #appends: [] #dispatchesEvents: [] #observables: [] #relations: [] #touches: [] +timestamps: true #visible: [] #guarded: array:1 [▶] #rememberTokenName: &quot;remember_token&quot; } 注：控制器并不是一定要继承基类，不过，那样的话就不能使用一些基类提供的便利方法了，比如 middleware、validate 和 dispatch 等。 命名空间在定义控制器路由时，我们并没有指定完整的控制器命名空间，而只是指定了 App\Http\Controllers 之后的部分，那为什么可以这么做呢？ 这是因为在 RouteServiceProvider 文件中，已经定义了 App\Http\Controllers ，故而我们只需指定后面的相对命名空间即可。 如果你在 App\Http\Controllers 目录下选择使用 PHP 命名空间嵌套或组织控制器，只需要使用相对于 App\Http\Controllers 命名空间的指定类名即可。 因此，如果你的完整控制器类是 App\Http\Controllers\Photos\AdminController，则可以像这样注册路由： Route::get(&apos;foo&apos;, &apos;Photos\AdminController@method&apos;); 单方法控制器如果你的控制器只有一个方法，则可以在这个控制器中定义 __invoke 方法： &lt;?php namespace App\Http\Controllers; use App\User; use App\Http\Controllers\Controller; class ShowProfile extends Controller { /** * 展示给定用户的详情 * * @param int $id * @return Response */ public function __invoke($id) { return view(&apos;user.profile&apos;, [&apos;user&apos; =&gt; User::findOrFail($id)]); } } 当你为单方法控制器注册路由时，不需要指定方法： Route::get(&apos;user/{id}&apos;, &apos;ShowProfile&apos;); 原理是当尝试以调用函数的方式调用一个对象时，__invoke() 魔术方法会被自动调用。 控制器中间件中间件可以像这样分配给控制器路由： Route::get(&apos;profile&apos;, &apos;UserController@show&apos;)-&gt;middleware(&apos;auth&apos;); 不过，将中间件放在控制器的构造函数中更方便，在控制器的构造函数中使用 middleware 方法可以轻松地分配中间件给该控制器（该方法继承自控制器基类）。 &lt;?php namespace App\Http\Controllers; use App\User; use Illuminate\Http\Request; class UserController extends Controller { public function __construct() { $this-&gt;middleware(&apos;token&apos;); } /** * 为指定用户显示详情 * * @param int $id * @return Response */ public function show($id) { return view(&apos;user.profile&apos;, [&apos;user&apos; =&gt; User::findOrFail($id)]); } } 在这个示例中，我们在控制器的构造方法中使用了 token 中间件，但是我们还没有定义和注册 token 中间件。 创建 token 中间件：php artisan make:middleware Token 这样，就会自动生成 app/Http/Middleware/Token.php 文件，稍作修改后，内容如下： &lt;?php namespace App\Http\Middleware; use Closure; class Token { /** * Handle an incoming request. * * @param \Illuminate\Http\Request $request * @param \Closure $next * @return mixed */ public function handle($request, Closure $next) { // 如果 token 的值不是 abcdef，则跳转到首页。 if ($request-&gt;token != &apos;abcdef&apos;) { return redirect(&apos;/&apos;); } // 如果 token 正确，就正常访问 return $next($request); } } 注册 token 中间件：修改 app/Http/Kernel.php 文件，为 $routeMiddleware 属性添加一个新的键值对即可。 &apos;token&apos; =&gt; \App\Http\Middleware\Token::class, 这样，当我们访问 http://www.adm.devp/user/1 时，会跳转到首页；访问 http://www.adm.devp/user/1?token=abcdef 时，才能访问到正确的页面。 除此之外，我们还可以指定中间件对指定方法生效或者排除指定方法的校验： $this-&gt;middleware(&apos;auth&apos;)-&gt;only(&apos;show&apos;); // 只对该方法生效 $this-&gt;middleware(&apos;auth&apos;)-&gt;except(&apos;show&apos;); // 对该方法以外的方法生效 如果要指定多个控制器方法可以以数组的方式传参： $this-&gt;middleware(&apos;auth&apos;)-&gt;only([&apos;show&apos;, &apos;index&apos;]); // 只对指定方法生效 $this-&gt;middleware(&apos;auth&apos;)-&gt;except([&apos;show&apos;, &apos;index&apos;]); // 对指定方法以外的方法生效 在控制器中还可以使用闭包注册中间件，这为我们定义只在某个控制器中使用的中间件提供了方便，而无需定义完整的中间件类： $this-&gt;middleware(function ($request, $next) { // ... return $next($request); }); 还是以 UserController 为例，我们为其定义一个匿名中间件： use App\User; use Illuminate\Http\Request; use Symfony\Component\HttpKernel\Exception\NotFoundHttpException; class UserController extends Controller { public function __construct() { $this-&gt;middleware(function($request, $next){ if($request-&gt;input(&apos;token&apos;)!=&apos;abcdef&apos;){ throw new NotFoundHttpException(); } return $next($request); }); } } 这样当我们访问 http://www.adm.devp/user/1 时会抛出 404 异常；只有当访问 http://www.adm.devp/user/1?token=abcdef 时才能正常展示。 资源控制器Laravel 的资源控制器可以很便捷地构建基于资源的 RESTful 控制器。 例如，你可能想要在应用中创建一个控制器，用于处理关于文章存储的 HTTP 请求，使用 Artisan 命令 make:controller，我们可以快速创建这样的控制器： php artisan make:controller PostController --resource 这样，会自动生成 app/Http/Controllers/PostController.php 文件，内容如下： &lt;?php namespace App\Http\Controllers; use Illuminate\Http\Request; class PostController extends Controller { /** * Display a listing of the resource. * * @return \Illuminate\Http\Response */ public function index() { // } /** * Show the form for creating a new resource. * * @return \Illuminate\Http\Response */ public function create() { // } /** * Store a newly created resource in storage. * * @param \Illuminate\Http\Request $request * @return \Illuminate\Http\Response */ public function store(Request $request) { // } /** * Display the specified resource. * * @param int $id * @return \Illuminate\Http\Response */ public function show($id) { // } /** * Show the form for editing the specified resource. * * @param int $id * @return \Illuminate\Http\Response */ public function edit($id) { // } /** * Update the specified resource in storage. * * @param \Illuminate\Http\Request $request * @param int $id * @return \Illuminate\Http\Response */ public function update(Request $request, $id) { // } /** * Remove the specified resource from storage. * * @param int $id * @return \Illuminate\Http\Response */ public function destroy($id) { // } } 接下来，可以通过 resource 方法为该控制器注册一个资源路由： Route::resource(&apos;posts&apos;, &apos;PostController&apos;); 这个路由声明包含了处理文章资源对应方法的多个路由。具体如下表： 请求方式 URI路径 控制器方法 路由名称 说明 GET /posts index posts.index 文章列表（首页） GET /posts/create create posts.create 新增文章的表单界面 POST /posts store posts.store 执行存储新文章 GET /posts/{post} show posts.show 查看指定的文章 GET /posts/{post}/edit edit posts.edit 更新文章的表单界面 PUT/PATCH /posts/{post} update posts.update 执行更新文章 DELETE /posts/{post} destroy posts.destroy 执行删除文章 指定资源模型如果你使用了路由模型绑定，并且想要在资源控制器的方法中对模型实例进行依赖注入，可以在生成控制器时使用 –model 选项： php artisan make:controller PostController --resource --model=Post 不过，不推荐使用这种模型绑定，因为这里会涉及到对模型数据的缓存逻辑，为性能考虑，我们不想总是从数据库取数据，所以，尽量保持单个功能的简单和单一职责，让开发者自己去组装需要的功能，这是 Unix 奉行的设计哲学，也是我们在系统设计的时候需要考量的重要因素。 伪造表单方法由于 HTML 表单不支持发起 PUT、PATCH 和 DELETE 请求，需要添加一个隐藏的 _method 字段来伪造 HTTP 请求方式，辅助函数 method_field 可以帮我们做这件事： {{ method_field('PUT') }} 部分资源路由声明资源路由时可以指定该路由处理的动作子集： Route::resource(&apos;post&apos;, &apos;PostController&apos;, [&apos;only&apos; =&gt; [&apos;index&apos;, &apos;show&apos;] ]); Route::resource(&apos;post&apos;, &apos;PostController&apos;, [&apos;except&apos; =&gt; [&apos;create&apos;, &apos;store&apos;, &apos;update&apos;, &apos;destroy&apos;] ]); API资源路由声明被 API 消费的资源路由时，你可能需要排除展示 HTML 模板的路由，如 create 和 edit，为了方便起见，Laravel 提供了 apiResource 方法自动排除这两个路由： Route::apiResource(&apos;post&apos;, &apos;PostController&apos;); 命名资源路由默认情况下，所有资源控制器的动作都有一个路由名称，不过，我们可以通过传入 names 数组来覆盖这些默认的名称： Route::resource(&apos;post&apos;, &apos;PostController&apos;, [&apos;names&apos; =&gt; [&apos;create&apos; =&gt; &apos;post.build&apos;] ]); 命名资源路由参数默认情况下，Route::resource 将会基于资源名称的单数格式为资源路由创建路由参数，你可以通过在选项数组中传递 parameters 来覆盖这一默认设置。 parameters 是资源名称和参数名称的关联数组： Route::resource(&apos;user&apos;, &apos;AdminUserController&apos;, [&apos;parameters&apos; =&gt; [ &apos;user&apos; =&gt; &apos;admin_user&apos; ]]); 上面的示例代码会为资源的 show 路由生成如下 URL： /user/{admin_user} 补充资源控制器如果需要在默认资源路由之外添加额外的路由到资源控制器，应该在调用 Route::resource 之前定义这些路由，否则，通过 resource 方法定义的路由可能无意中覆盖掉补充的额外路由： Route::get(&apos;posts/popular&apos;, &apos;PostController@method&apos;); Route::resource(&apos;posts&apos;, &apos;PostController&apos;); 注：注意保持控制器的单一职责，如果你发现指向控制器动作的路由超过默认提供的资源控制器动作集合了，考虑将你的控制器分割成多个更小的控制器。 依赖注入构造函数注入Laravel 使用服务容器解析所有的 Laravel 控制器，因此，可以在控制器的构造函数中注入任何依赖，这些依赖会被自动解析并注入到控制器实例中： &lt;?php namespace App\Http\Controllers; use App\Repositories\UserRepository; class UserController extends Controller { /** * The user repository instance. */ protected $users; /** * 创建新的控制器实例 * * @param UserRepository $users * @return void */ public function __construct(UserRepository $users) { $this-&gt;users = $users; } } 当然，你还可以注入任何 Laravel 契约，如果容器可以解析，就可以进行依赖注入。注入依赖到控制器可以让应用更加易于测试，同时也更加方便使用。 普通方法注入除了构造函数注入之外，还可以在控制器的普通方法中进行依赖注入，例如，我们可以在某个方法中注入 Illuminate\Http\Request 实例： &lt;?php namespace App\Http\Controllers; use Illuminate\Http\Request; class UserController extends Controller { /** * 存储新用户 * * @param Request $request * @return Response */ public function store(Request $request) { $name = $request-&gt;input(&apos;name&apos;); // } } 如果控制器方法期望输入路由参数，只需要将路由参数放到其他依赖之后，例如，如果你的路由定义如下： Route::put(&apos;user/{id}&apos;, &apos;UserController@update&apos;); 则需要以如下方式定义控制器方法来注入 Illuminate\Http\Request 依赖并访问路由参数 id： &lt;?php namespace App\Http\Controllers; use Illuminate\Http\Request; class UserController extends Controller { /** * 更新指定用户 * * @param Request $request * @param int $id * @return Response */ public function update(Request $request, $id) { // } }]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>框架</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel入门——执行流程与生命周期]]></title>
    <url>%2F2017%2F05%2F16%2FLaravel%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[请求流程通过apache或者nginx的设置所有用户的请求都会被导入到/public/index.php 来进行处理。 index.php 脚本按照如下的流程执行 加载位于/bootstrap/autoload.php 的composer 类加载器 从/bootstrap/app.php 生成一个app实例 将请求发送到http内核( /app/HTTP/Kernel =&gt; /Illuminate/Foundation/Gttp/Kernel ) 或者控制台内核 处理请求前执行bootstrappers 数组定义的内容包括：配置错误处理、配置日志记录等 处理请求前执行middlewarePriority 数组定义的http中间件 执行 kernel实例的handel() 方法来返回response 一、 laravel结构｜– app 包含Controller、Model、路由等在内的应用目录，大部分业务将在该目录下进行 ｜ ｜– Console 命令行程序目录 ｜ ｜ ｜– Commands 包含了用于命令行执行的类，可在该目录下自定义类 ｜ ｜ ｜– Kernel.php 命令调用内核文件，包含commands变量(命令清单，自定义的命令需加入到这里)和schedule方法(用于任务调度，即定时任务) ｜ ｜– Events 事件目录 ｜ ｜– Exceptions 包含了自定义错误和异常处理类 ｜ ｜– Http HTTP传输层相关的类目录 ｜ ｜ ｜– Controllers 控制器目录 ｜ ｜ ｜– Middleware 中间件目录 ｜ ｜ ｜– Requests 请求类目录 ｜ ｜ ｜– Kernel.php 包含http中间件和路由中间件的内核文件 ｜ ｜ ｜– routes.php 强大的路由 ｜ ｜– Jobs 该目录下包含队列的任务类 ｜ ｜– Listeners 监听器目录 ｜ ｜– Providers 服务提供者目录 ｜ ｜– User.php 自带的模型实例，我们新建的Model默认也存储在该目录 ｜– bootstrap 框架启动载入目录 ｜ ｜– app.php 创建框架应用实例 ｜ ｜– autoload.php 自动加载 ｜ ｜– cache 存放框架启动缓存，web服务器需要有该目录的写入权限 ｜– config 各种配置文件的目录 ｜ ｜– app.php 系统级配置文件 ｜ ｜– auth.php 用户身份认证配置文件，指定好table和model就可以很方便地用身份认证功能了 ｜ ｜– broadcasting.php 事件广播配置文件 ｜ ｜– cache.php 缓存配置文件 ｜ ｜– compile.php 编译额外文件和类需要的配置文件，一般用户很少用到 ｜ ｜– database.php 数据库配置文件 ｜ ｜– filesystems.php 文件系统配置文件，这里可以配置云存储参数 ｜ ｜– mail.php 电子邮件配置文件 ｜ ｜– queue.php 消息队列配置文件 ｜ ｜– services.php 可存放第三方服务的配置信息 ｜ ｜– session.php 配置session的存储方式、生命周期等信息 ｜ ｜– view.php 模板文件配置文件，包含模板目录和编译目录等 ｜– database 数据库相关目录 ｜ ｜– factories 5.1以上版本的新特性，工厂类目录，也是用于数据填充 ｜ ｜ ｜– ModelFactory.php 在该文件可定义不同Model所需填充的数据类型 ｜ ｜– migrations 存储数据库迁移文件 ｜ ｜– seeds 存放数据填充类的目录 ｜ ｜– DatabaseSeeder.php 执行php artisan db:seed命令将会调用该类的run方法。该方法可调用执行该目录下其他Seeder类，也可调用factories方法生成ModelFactory里定义的数据模型 ｜– public 网站入口，应当将ip或域名指向该目录而不是根目录。可供外部访问的css、js和图片等资源皆放置于此 ｜ ｜– index.php 入口文件 ｜ ｜– .htaccess Apache服务器用该文件重写URL ｜ ｜– web.config IIS服务器用该文件重写URL ｜– resources 资源文件目录 ｜ ｜– assets 可存放包含LESS、SASS、CoffeeScript在内的原始资源文件 ｜ ｜– lang 本地化文件目录 ｜ ｜– views 视图文件就放在这啦 ｜– storage 存储目录。web服务器需要有该目录及所有子目录的写入权限 ｜ ｜– app 可用于存储应用程序所需的一些文件 ｜ ｜– framework 该目录下包括缓存、sessions和编译后的视图文件 ｜ ｜– logs 日志目录 ｜– tests 测试目录 ｜– vendor 该目录下包含Laravel源代码和第三方依赖包 ｜– .env 环境配置文件。config目录下的配置文件会使用该文件里面的参数，不同生产环境使用不同的.env文件即可。 ｜– artisan 强大的命令行接口，你可以在app/Console/Commands下编写自定义命令 ｜– composer.json 存放依赖关系的文件 ｜– composer.lock 锁文件，存放安装时依赖包的真实版本 ｜– gulpfile.js gulp（一种前端构建工具）配置文件 ｜– package.json gulp配置文件 ｜– phpspec.yml phpspec（一种PHP测试框架）配置文件 ｜– phpunit.xml phpunit（一种PHP测试框架）配置文件 ｜– server.php PHP内置的Web服务器将把这个文件作为入口。以public/index.php为入口的可以忽略掉该文件 二、生命周期1. 入口文件：Laravel框架所有请求入口统一进入/public/index.php文件，请求通过Ngxin/Apache指向该文件。index.php文件是加载其他文件入口，本身代码不多。 index.php文件载入通过Composer生产的自动加载配置，然后从bootstrap/app.php获取应用实例，创建服务容器。 2.Http/Console内核接上面，请求被发送到HTTP内核或Console内核，取决于应用请求类型（会在下篇文章说明）。这两个内核为所有请求必须经过的中央处理器， 下面介绍App\Http\Kernel的HTTP内核： HTTP内核 继承自Illuminate\Foundation\Http\Kernel类，该类定义了一个bootstrappers数组，该数组中的类在请求被执行前运行，bootstrappers配置了错误处理、日志、检测应用环境、其他在请求被处理前需要处理的任务。 HTTP内核还定义请求处理前需要经过HTTP中间件，该中间件处理HTTP会话的读写、判断应用是否处于维护模式，验证CSRF令牌（防止CSRF攻击）等。 HTTP内核标签方法handle：获取一个Request，返回一个Response，输入HTTP请求，返回HTTP响应。 3.服务提供者内核启动会为应用载入服务提供者，服务提供者都被配置在config/app.php配置文件的providers数组中。服务提供者被注册后，boot方法被调用。 服务提供者负责启动框架的所有组件，如数据库、队列、验证器、路由组件等。因他们启动并配置框架提供的所有特性，服务提供者是整个Laravel启动过程中最重要部分。 「延迟」提供器：即providers数组中较多服务都是提供的实际服务需要才会加载。 4. 分发请求一旦应用被启动且所有服务提供者被注册，Request将会被交给路由器进行分发，路由器将会分发请求到路由或控制器，同时运行所有路由指定的中间件。 三、启动过程index.php bootstrap/autoload.php --&gt; 自动加载 bootstrap/app.php --&gt; 初始化服务容器(注册基础的服务提供者(事件、日志、路由)、注册核心类别名) bootstrap/app.php --&gt; 注册共享的Kernel和异常处理器 Foundation\Http\Kernel.php --&gt; 处理请求和响应 index.php --&gt; 将响应信息发送到浏览器 index.php --&gt; 处理继承自TerminableMiddleware接口的中间件（Session）并结束应用生命周期 其中处理请求和响应包括： 解析Illuminate\Contracts\Http\Kernel，实例化App\Http\Kernel 实例化Kernel ： 构造函数：设置$app/$router，初始化$router中middleware数值 handle处理请求： 加载路由中间件、加载环境变量、加载配置文件、加载异常处理机制、注册门面、注册服务提供者、启动服务提供者、管道模式注入中间件 将响应信息发送到浏览器 注册request实例到容器 ($app[‘request’]-&gt;Illuminate\Http\Request) – $request是经过Symfony封装的请求对象 清空之前容器中的request实例 调用bootstrap方法，启动一系列启动类的bootstrap方法： Illuminate\Foundation\Bootstrap\DetectEnvironment 环境配置（$app[‘env’]） Illuminate\Foundation\Bootstrap\LoadConfiguration 基本配置（$app[‘config’]） Illuminate\Foundation\Bootstrap\ConfigureLogging 日志文件（$app[‘log’]） Illuminate\Foundation\Bootstrap\HandleExceptions 错误&amp;异常处理 Illuminate\Foundation\Bootstrap\RegisterFacades 清除已解析的Facade并重新启动，注册config文件中alias定义的所有Facade类到容器 Illuminate\Foundation\Bootstrap\RegisterProviders 注册config中providers定义的所有Providers类到容器 Illuminate\Foundation\Bootstrap\BootProviders 调用所有已注册Providers的boot方法 通过Pipeline发送请求，经过中间件，再由路由转发，最终返回响应 1.自动加载包括全局函数的加载、顶级命名空间映射、PSR0、PSR4标准的实现 2.初始化服务容器 注册容器本身 将基本的绑定注册到容器中，包括容器自身、容器实例名称app 实例化 app, Illuminate\Container\Container 关键代码： protected function registerBaseBindings() { static::setInstance($this); $this-&gt;instance(&apos;app&apos;, $this); $this-&gt;instance(Container::class, $this); } 注册基础服务提供者 向容器分别注册了Key为以下值得实例 events log router、url、redirect、Illuminate\Contracts\Routing\ResponseFactory 关键代码： protected function registerBaseServiceProviders() { $this-&gt;register(new EventServiceProvider($this)); $this-&gt;register(new LogServiceProvider($this)); $this-&gt;register(new RoutingServiceProvider($this)); } 注册容器别名(注册共享的Kernel) 在调用此方法之前，我们想取得一个容器实例的做法是 App::make(‘app’);现在我们可以使用三种方法来取得一个容器实例app App::make(&apos;Illuminate\Foundation\Application&apos;) App::make(&apos;Illuminate\Contracts\Container\Container&apos;) App::make(&apos;Illuminate\Contracts\Foundation\Application&apos;) 关键代码： public function registerCoreContainerAliases(){ ... } 3. 注册共享的Kernel和异常处理器关键代码： $app-&gt;singleton( Illuminate\Contracts\Http\Kernel::class, App\Http\Kernel::class ); $app-&gt;singleton( Illuminate\Contracts\Console\Kernel::class, App\Console\Kernel::class ); $app-&gt;singleton( Illuminate\Contracts\Debug\ExceptionHandler::class, App\Exceptions\Handler::class ); 4. 处理请求和响应实例化App\Http\Kernel 构造函数：设置$app/$router，初始化$router中middleware数值 关键代码： public function __construct(Application $app, Router $router) { $this-&gt;app = $app; $this-&gt;router = $router; $router-&gt;middlewarePriority = $this-&gt;middlewarePriority; foreach ($this-&gt;middlewareGroups as $key =&gt; $middleware) { $router-&gt;middlewareGroup($key, $middleware); } foreach ($this-&gt;routeMiddleware as $key =&gt; $middleware) { $router-&gt;aliasMiddleware($key, $middleware); } } 5. handle处理请求 a. 注册request实例到容器 ($app[‘request’]-&gt;Illuminate\Http\Request) – $request是经过Symfony封装的请求对象 b. 清空之前容器中的request实例 c. 调用bootstrap方法，启动一系列启动类的bootstrap方法 d. 通过Pipeline发送请求，经过中间件，再由路由转发，最终返回响应 关键代码： protected function sendRequestThroughRouter($request) { $this-&gt;app-&gt;instance(&apos;request&apos;, $request); Facade::clearResolvedInstance(&apos;request&apos;); $this-&gt;bootstrap(); return (new Pipeline($this-&gt;app)) -&gt;send($request) -&gt;through($this-&gt;app-&gt;shouldSkipMiddleware() ? [] : $this-&gt;middleware) -&gt;then($this-&gt;dispatchToRouter()); } ​ 6. bootstrap方法 a.检测环境变量文件是否正常 b.取得配置文件，即把/config/下的所有配置文件读取到容器（app()-&gt;make(‘config’)可以查看所有配置信息） c.注册异常： set_error_handler,set_exception_handler, register_shutdown_function d.把/config/app.php里面的aliases项利用PHP库函数class_alias创建别名，从此，我们可以使用App::make(‘app’)方式取得实例 e.把/config/app.php里面的providers项,注册到容器 f.运行容器中注册的所有的ServiceProvider中得boot方法 关键代码： protected $bootstrappers = [ \Illuminate\Foundation\Bootstrap\LoadEnvironmentVariables::class, \Illuminate\Foundation\Bootstrap\LoadConfiguration::class, \Illuminate\Foundation\Bootstrap\HandleExceptions::class, \Illuminate\Foundation\Bootstrap\RegisterFacades::class, \Illuminate\Foundation\Bootstrap\RegisterProviders::class, \Illuminate\Foundation\Bootstrap\BootProviders::class, ]; 7. 将响应信息发送到浏览器关键代码： $response-&gt;send(); ​ 9. 处理继承自TerminableMiddleware关键代码： $kernel-&gt;terminate($request, $response); ​ 10. Laravel路由$this-&gt;dispatchToRouter() --&gt; $this-&gt;router-&gt;dispatch($request) --&gt; $this-&gt;dispatchToRoute($request); -- /Illuminate/Routing/Router.php --&gt; $response = $this-&gt;runRouteWithinStack($route, $request); //干货来了 protected function runRouteWithinStack(Route $route, Request $request) { // 取得routes.php里面的Middleware节点 $middleware = $this-&gt;gatherRouteMiddlewares($route); //这个有点眼熟 return (new Pipeline($this-&gt;container)) -&gt;send($request) -&gt;through($middleware) //执行上述的中间件 -&gt;then(function($request) use ($route) { //不容易啊，终于到Controller类了 return $this-&gt;prepareResponse( $request, $route-&gt;run($request); //run控制器 ); }); } 服务提供者 服务提供是启动Laravel关键部分，应用实例被创建，服务提供被注册，请求被启动后的应用进行处理。默认存放在app/Providers目录下。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>框架</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017@Swift——后感]]></title>
    <url>%2F2017%2F05%2F15%2F2017-Swift%E2%80%94%E2%80%94%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[2017@Swift——中国开发者大会（第二站） 会议时间：2017年5月13日-5月14日， 地址：深圳凯宾斯基酒店， 人数：400人 嘉宾：18人，其中8位国外，8位国内。 第一天所有外国嘉宾的演讲时间，第二天是国内大牛的演讲时间！ 记得第一站是去年在北京举行，当时项目太赶，就没有去，今年有幸能参加此次大会，并且收获真心不少。因此这里稍微整理了一下这两天最大的感触，和所学到的东西！ 当然关于技术的分享，后期会有专门的文章与结合简单的实战整理一并分享出来，敬请期待……. 更多信息请点2017@Swift——中国开发者大会,同时后面也会抽空整理一下会议中讲到的内容，底层，细节与实现，敬请期待！ 2017@Swift——后感 这种收获真不是一两句话或者一两篇文章就能说清楚的，如果你有事吗疑问或者想了解先关内容也可以直接关注我，联系我！ 第二届 @Swift 中国开发者大会 英语能力 交友 技术 英语为什么这里我把英语能力放在最前面，肯定是有原因的。 1. 开会第一天所有都是老外，所有人都直接用英语讲，几乎听不太懂，所以导致很多东西根本没有听到重点与细节 2. 会后交流，与提问，人家都能听懂，甚至都能提出自己的问题与观点，甚至还能通嘉宾进行更多更加升入的交流与讨论，而我却只能翻译或者发呆 3. 技术的学习，几乎所有的最好，最新的技术资料都是从英文开始的，当你开始看中文翻译资料或者开始研究的时候，人家已经换了一种技术 4. 后期的规划问题，出国旅游，出国发展（有点长远，当然也不是没有可能的），或者有机会接触外国朋友。 总结：针对程序员，哪怕只有一点基础的，技术这种东西都可以慢慢学，或者在实际项目中提高，如果你英文不好很多事情真的很难进行下去，除非你没有什么长远的目标或者没有自己个人的规划。 交友经过这次会议之后，看到了很多牛人，也认识了不少牛人之后才知道自己的渺小，才知道自己原来离期望中太远太远。 1. 最有名的Swift框架RXSwift的作者 2. Google工程师 3. 腾讯，美团，礼物说，阿里等一些非常厉害的架构师，同时也是技术迷 4. 不少技术书籍的作者，其中有一位是我非常喜欢的巧哥@唐巧 5. 不同公司的技术主管，开发人员，初入门的程序员 6. 两天的会议中认识到了不少来自去全国各地参会者，也结下了不少好友！ 总结：永远不要觉得自己多牛逼，当你真的看到牛人之后你就会发现，其实自己真的很low，哪怕你做过再多项目，写过再多代码，不思考，不提升依然是个菜鸟。 技术1. 主题就是Swift：iOS，后台肯定是重心 2. Swift实现AI，智能，机器学习，树莓派的结合，后期的转行。 3. 实现属于自己的东西，小的方向比如小框架，静态或者动态库，大的话其中有人自己写了一个Swift转H5的编译器 4. App性能的提升，多线程，锁，MVVM, 自动化（测试，脚本） 5. 包括开发，集成，测试，发布，维护需要有一套完成的规范与流程。 总之，程序员是一个需要时刻保持学习的职业，不学你就将被淘汰，不管学习技术，管理，社交，英语或者学习别人成功或失败的经验 未来的路还很长，希望一路上的坎坷能让我足够强大。 说说我接下来的规划（我只谈短期1-2年）： 1. 学习英语，不管是自学还是报班这都是现阶段最最最重要的任务,同时也会长期的坚持下去。 2. 着手Swift进行项目实战，对PHP实战后台开发进一步的提升，同时去了解Swift实现后台开发 3. iOS深挖：深入解析Max OS X &amp; iOS操作系统 4. 学习Python，了解机器学习等技术]]></content>
      <categories>
        <category>2017@Swift</category>
      </categories>
      <tags>
        <tag>2017@Swift——后感</tag>
        <tag>Swift</tag>
        <tag>大会后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017@Swift——中国开发者大会（第二天）]]></title>
    <url>%2F2017%2F05%2F15%2F2017-Swift%E2%80%94%E2%80%94%E4%B8%AD%E5%9B%BD%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%A4%A9%EF%BC%89%2F</url>
    <content type="text"><![CDATA[首先介绍一下会议信息 会议时间：2017年5月13日-5月14日， 地址：深圳凯宾斯基酒店， 人数：400人 嘉宾：18人，其中8位国外，8位国内。 第一天所有外国嘉宾的演讲时间，第二天是国内大牛的演讲时间！ 更多信息请点2017@Swift——中国开发者大会,同时后面也会抽空整理一下会议中讲到的内容，底层，细节与实现，敬请期待！ ============================================================================= 唐巧（小猿搜题产品技术负责人）Richards 和 Deltablue 是衡量语言运算速度的两个主流的评测代码。Swift 在这两个评测中，显示出远超 Objective-C 的性能。特别是 Richards 评测，Swift 比 Objective-C 快了 4 倍。那么，为什么 Swift 这么快呢？本次分享，我将从编译器优化，内存分配优化，引用计数优化，方法调用优化，面向协议编程的实现细节等方面来介绍 Swift 在性能上所做的努力。如果可能，我们也会一起看看编译器处理后的源码，加深我们对于这些优化的理解。 小猿搜题产品技术负责人，资深 iOS 开发者，曾开发过网易邮箱、网易微博、有道云笔记、猿题库、小猿搜题。喜欢写作和分享，维护着中国关注者最多的iOS领域的微信公众号「iOS开发by唐巧」，产出了超过 100 篇原创的 iOS 技术文章，出版了一本 iOS 进阶读物《iOS开发进阶》。 Swift 为什么这么快1. 第二天中，唯一一个使用英文演讲的国内大牛，挑战自我。 2. 从不同方便说明为什么swift比OC好：引用数，struct的内存布局，性能优化，编译器、内存、消息转发机制、引用数和protocol。 ============================================================================= 戴铭（滴滴出行技术专家） github.com/ming1016 结合实例介绍如何用 LLVM IR 中间语言和编译前端的语法解析来设计一门简洁易用支持多平台的 DSL 语言，从而提高开发效率。介绍如何使用 Swift 开发一个类似 Clang 并且支持插件的简版编译前端，从而优化代码，提高工程质量。此外还会简单介绍一些有趣的实践。 微博@戴铭。滴滴出行技术专家，技术上主要负责滴滴出行 iOS 相关的开发工作。时常会将对新技术的深入研究和工作的经验总结发在微博上。对 ReactiveCocoa，RxSwift，软件架构，性能优化和算法有着浓厚的兴趣。最近正在研究iOS编译相关底层技术，用来解决工程优化问题，到时会将成果分享出来。 学习 iOS 编译原理能做哪些有意思的事情1. 这哥们可谓是有着一双被编程耽误了的画手，不但主题，技术吸引人，所画出来的作品更是让人回味。 2. 先讲了一个关于flexbox布局的web代码，自己使用swift写了一个解析器。 3. 结合上面的实现个性化的讲解了一下编译器前后端，及编译的整个过程 ============================================================================= 柯灵杰（腾讯公司iOS开发）图片组件可以说是app开发中使用最多的组件之一，它既简单也不简单，如何设计和开发一个具有高扩展性，高性能的图片组件呢？本次分享将会从架构设计到性能优化等多方面，全面解析一个优秀图片组件的设计和开发原理，以及在性能优化和架构设计方面的一些经验和探索。 柯灵杰（lingtonke），腾讯公司 iOS 开发。腾讯学院认证讲师，主要讲授课程《设计模式》。曾参加过 QQ、QZone、微云、企鹅 MV、闪咖等的开发。他主导开发的图片组件，在腾讯内被多个项目使用，获得公司内多项优秀组件奖，目前已着手对业内开源。同时他还是数项技术发明专利的发明人，曾参加过程序员 LiveShow《有码的开发哥无码的直播》。目前是腾讯 QZone 团队 iOS 开发。 打造易扩展的高性能图片组件1. 如何设计高性能易拓展的图片组件，一步一步的优化。 2. 综合分析的不同框架，不同实现方案，不同技术的优缺点。 3. 当时我会中问到是否开源，回答是会，并且预计年底会开源。 ============================================================================= 王文槿（UC资深开发工程师）来自 UC 浏览器的 iPhone 组，参与了 UC 浏览器，UC 头条和夸克浏览器相关产品的开发，工作中主要使用 OC 和 Weex 。不过业余是不折不扣的 Swift 爱好者，自诩 Swift 的函数式编程的布道师。曾经先后通过文章&amp;演讲的形式分享了 Swift 异步串行/并行编程以及函数式的设计模式等话题。 一个轻量级 FRP 框架的诞生记1. 之前UC面试过一次，可惜挂了 2. 主要结合实际以一个很简单的Demo演示了MVVM，并且很清晰的解答了众多为止疑惑的参会者。 ============================================================================= 赵恩生（美团点评高级工程师）随着业务拆分和组件化的完成，美团 iOS 客户端在集成和交付的道路上越发艰难。在业务代码下放后，如何能保证客户端的安全稳定；面对千万用户，如何能快速优雅地组建并交付一个完整的客户端，这一切的一切都值得思考和深究。 希望通过本次分享，和各位一起探讨如何玩转大业务体量下的众多组件、如何搭建整个客户端的发布流程。 美团点评高级工程师，曾维护美团 iOS 客户端，现负责 iOS 发布流程相关工作，专业打杂，通过对复杂业务下组件发布集成的踩坑总结，对 CI CD 有一定的认识和理解。闲暇时喜欢捣鼓乱七八糟的东西，自学习得包括疏通下水道，手机贴膜，设备维修在内的一些奇怪技能。 组件 + 组建 = 美团 iOS 客户端1. 美团开发，集成，打包，测试，发布整个流程的工作与注意点。 2. 组件式的开发方式，规范性的流程与测试形成一个闭环 3. 校验，避错，后期的修复的考虑及解决方案 4. CI的基本流程介绍 ============================================================================= 傅若愚（ThoughtWorks 高级咨询师）是的，你一定听说过 Metal，或者你还写过一些 Metal 的 Shader。不过，说实话，喝了两杯啤酒之后，面对 Xcode，我们能做点儿更有趣的东西么？要不要来试试？ 来自 ThoughtWorks，刚睡醒的移动开发者，喝高了的 Tech Lead，SwiftyJSON 的作者（但这家伙已经弃坑……Oh，别担心，其他人还在维护）。业余喜读书，文史哲无所禁忌，爱美食与啤酒（最近爱上了 American Pale Ale），今年大概 17 岁的样子。 一些跟 Metal 有关系，肯定有趣但多半没用的东西1. 主要是机器学习，高逼格式的讲解了神经网络 2. 输入图片，视频染色然后渲染并输出对应的效果。 3. 主要是一些基础的概念，理论知识。 ============================================================================= 尹航（Google 工程师）深度学习总是让人联想到成吨的数据、笨重的服务器。但在移动端，我们能不能利用深度学习做一点有趣的事情呢？本次分享，让我们看看如何在iOS上运行起工业级的深度学习框架TensorFlow吧。 一个技能树歪掉的开发者。iOS 首个游戏辅助“叉叉助手”作者，也曾经编写《Cocos2d-x高级开发教程》，目前兴趣有移动安全和机器学习，Google 工程师，从事 Gmail 语义理解相关开发。 TensorFlow+iOS=❤️: 造一个颜文字输入法1. 机器学习，实战了一个emoji表情的输出。 2. 介绍了TensorFlow，介绍了他的一些特性与简单的应用 ============================================================================= 唐晓轩（礼物说联合创始人）Live Coding 礼物说联合创始人，全栈打杂工程师，公众号糖炒小虾，热衷于折腾各种黑技术。 当 Swift 遇上树莓派1. swift和树莓派之间的交互。 2. Swift+ARM，展示了一个watch跑的超级玛丽。 3. 展示数个小Demo，演示怎么与实际相结合，并提到为了对小米设备的实际应用 ============================================================================= 第二天尾声…到此整个会议已经全部结束，这一天在技术，底层，架构等方面收获就完全不一样了，同时后期会有文章介绍相关内容！ 随后，大家都纷纷离开准备回家或者会工作的城市！]]></content>
      <categories>
        <category>2017@Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>大会</tag>
        <tag>2017@Swift——中国开发者大会（第二天）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017@Swift——中国开发者大会（第一天）]]></title>
    <url>%2F2017%2F05%2F15%2F2017-Swift%E2%80%94%E2%80%94%E4%B8%AD%E5%9B%BD%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A%EF%BC%88%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%89%2F</url>
    <content type="text"><![CDATA[首先介绍一下会议信息 会议时间：2017年5月13日-5月14日， 地址：深圳凯宾斯基酒店， 人数：400人 嘉宾：18人，其中8位国外，8位国内。 第一天所有外国嘉宾的演讲时间，第二天是国内大牛的演讲时间！ 更多信息请点2017@Swift——中国开发者大会,同时后面也会抽空整理一下会议中讲到的内容，底层，细节与实现，敬请期待！ ================================================================================================================================= Tuomas Artman（Uber 移动架构和框架组负责人）Uber 使用 Swift 重写了 app，在这个分享中，Tuomas 会介绍如何在上百人的团队中使用 Swift 进行开发，并介绍 Uber 重写过程中遇到的各种问题和解决方法。Tuomas 是 Uber 移动架构和框架组的负责人。在来湾区之前，他创立了一家芬兰知名的数字资讯公司，还在上海的一家公司工作过一年，开发游戏和多用户技术平台。 Swift with hundreds of engineers1. 使用swift重构Uber的过程中good，bad，ugly。 2. 对架构重新设计了，并且将他成为router-&gt;interaction-&gt;builder简称RIBs。适用于Android和iOS双平台。 3. 重构后Uber的崩溃率降到了0.01%，这确实是一个非常理想的数据。 4. binary size关于Uber包的大小。 5. 关于如何缩短Uber的编译时间 6. 最后聊了一下unit test。 ================================================================================================================================= Sam Davies（RayWenderlich CTO）从基础的 NSOperation 一直到 Grand Central Dispatch，彻底讲明白 iOS 并发。此外还会涉及一些高级内容，比如 dispatch group 和线程安全。 Concurrency on iOS1. 异步并发。 2. 提出了开发中经常遇到的一些问题和解决方案 3. 提到了反转优先级 ================================================================================================================================= Igor Jerkovic（前 Facebook 资深开发者）Igor 在 Facebook 的视频团队工作了五年，非常熟悉国外大公司的那一套理论。他会在这次分享中介绍如何提高开发效率和代码质量。 我很喜欢编程，也喜欢学习新东西，尝试不同的方法。2011-2013 年我在 Facebook 实习，负责开发 iOS 项目。2014 年我正式加入 Facebook，一直在视频团队工作到 2016年。现在我在 Bellabeat 工作，这是一家和健康相关的创业公司，在旧金山、深圳和萨格勒布都有办公室。 iOS development efficiency at Facebook1. Facebook的开发流程，包括各种开发中的规范 2. 介绍了很多实用的工具Buck... ================================================================================================================================= Sommer Panage（Chorus Fitness 核心 iOS）在这个分享中，我会介绍无障碍和 VoiceOver。首先说明为什么无障碍支持很重要，然后通过一个权威的 iOS 应用了解你可以实现哪些无障碍功能。接着我会介绍 iOS 无障碍 API 以及如何对接 VoiceOver。最后，我会补充一些有趣的无障碍知识，除了支持 VoiceOver，我们还能做得更好。 Sommer Panage 目前是 Chorus Fitness 的核心 iOS 开发。在这之前，她做了两年 iOS freelancer，与此同时她还成为了一名马戏表演者和教练。更早的时候，她在 Twitter 和 Apple 的无障碍团队工作。Sommer 对心理学和计算机科学两个领域都有涉猎。在编写代码之余，她还会做绳索训练、高空秋千、倒立、跑步和抱石。你可以在 Twitter 上关注她，@sommer。 From Zero to Hero: Making your iOS App Accessible to VoiceOver and Beyond1. 主要是无障碍应用开发 2. 讲了iOS中的accessibility programing，并演示了对失明者的交互与使用。 3. 通过code演示了一些使用方式 ================================================================================================================================= Krunoslav Zaher（RxSwift 框架作者）我会介绍开发 Rx 的初衷、我对 Rx 的看法、Rx 的特点以及 Rx 和传统编程方式的区别。我还会介绍 Rx 的性能、不同设计模式的实现方式以及如何关联 Rx 和状态机。 在行业内摸爬滚打了 16 年。做过很多东西，增强现实引擎、BPM 系统、手机应用、机器人……最近在研究函数式编程和链式编程。白天我会帮准妈妈们听婴儿的心跳，晚上我会哄自己的宝贝女儿睡觉。 Thinking in Rx way1. 主要是对rx的用法介绍。 2. 提到了他写RX的初衷 ================================================================================================================================= Marius Rackwitz（CocoaPods、Realm 核心开发者）Marius 从大学毕业开始就从事移动端和 web 应用开发。最近他开始专注移动端开发，尤其是 iOS 和 Objective-C，以及后起之秀 Swift。当然，作为 CocoaPods 核心成员，他也没有抛弃 Ruby。加入 Realm 之后，他在社区中更加活跃，参与了很多大会。 JavaScript for Swift Developer1. 这哥们整个演讲的过程中很是激情，但是却让在场大部分参会者归为叛徒的了（哈哈，开个玩笑）。 2. JavaScript for Swift Developer主要是两者之间的不同。 ================================================================================================================================= Kyle Jessup（Perfect 框架作者，CTO）Perfect 作者，Lasso 编程语言（被苹果的子公司 Claris 收购）的服务端核心开发者。Kyle 自学能力很强，对 Swift、Java 和 C++ 都有深入了解。 小时候，Kyle 的父亲——一名曾在美国海军潜艇上服役的核工程师——送给他一台雅达利 800 个人电脑。从那时起，他就对技术产生兴趣，一直延续到现在。 Kyle 在德克萨斯的达拉斯出生，2015 年搬到加拿大，加入 PerfectlySoft 团队。 Swift作为后端开发相关1. 演示并分享了Swift实现后端开发的利弊 2. 介绍了了Perfect ================================================================================================================================= Saul Mora（流利说 iOS 工程师，MagicalRecord 作者）从上古时代开始接触 iOS，熟悉手动内存管理、编译器宏、pthread 和 头文件。Saul Mora 为了表达对编程前辈的尊重，在 Swift 中使用带可选变量的 Nib 编写 UI。掌握了 Objective C 之后，Saul 开始环游世界，进行历练。为了应对前方的算法挑战，Saul 积极拥抱 Swift。最近，Saul 生活在现代中国的核心城市——上海。他在流利说寺修行，开发这款优秀的 app，帮助中国用户学习英语。 Building Confidence: Testing iOS applications1. 以一个很滑稽很有乔布斯风格的开场吸引住了在场的参会者 2. 分析并深入讲解了测试的重要性和原则 ============================================================================= 第一天尾声…第一天的会议也就这样结束了，整个会议中大家谈论最多的问题就是关于英语的能力，这个后面会有相关的文章详细说明！]]></content>
      <categories>
        <category>2017@Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>2017@Swift——中国开发者大会（第一天）</tag>
        <tag>大会</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP实用库整理]]></title>
    <url>%2F2017%2F04%2F16%2FPHP%E5%AE%9E%E7%94%A8%E5%BA%93%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. Dispatch – 微框架Dispatch是一个PHP小框架。它并没有给你完整的MVC设置，但你可以定义URL规则和方法，以便更好组织应用程序。这对API、简单的站点或原型来说是完美的。 //包含库 include &apos;dispatch.php&apos;; // 定义你的路由 get(&apos;/greet&apos;, function () { //渲染视图 render(&apos;greet-form&apos;); }); //post处理 post(&apos;/greet&apos;, function () { $name = from($_POST, &apos;name&apos;); // render a view while passing some locals render(&apos;greet-show&apos;, array(&apos;name&apos; =&gt; $name)); }); // serve your site dispatch(); 你可以匹配特定类型的HTTP请求和路径，渲染视图或做更多事情。如果你合并Dispatch和其他框架，那你就可以拥有一个相当强大并且轻量级的程序！ 2. Klein – PHP快如闪电的路由Klein是另一款针对PHP5.3+版本的轻量级路由库。虽然它有一些比Dispatch冗长的语法，但它相当快。这有一个例子： respond(&apos;/[:name]&apos;, function ($request) { echo &apos;Hello &apos; . $request-&gt;name; }); 你也可以定制来指定HTTP方法和使用正则表达式作为路径。 respond(&apos;GET&apos;, &apos;/posts&apos;, $callback); respond(&apos;POST&apos;, &apos;/posts/create&apos;, $callback); respond(&apos;PUT&apos;, &apos;/posts/[i:id]&apos;, $callback); respond(&apos;DELETE&apos;, &apos;/posts/[i:id]&apos;, $callback); //匹配多种请求方法: respond(array(&apos;POST&apos;,&apos;GET&apos;), $route, $callback); //你或许也想在相同的地方处理请求 respond(&apos;/posts/[create|edit:action] /[i:id] &apos;, function ($request, $response) { switch ($request-&gt;action) { // do something } }); 对于小型项目来说这是很棒的，但当你把一个像这样的库用于大型应用时，你不得不遵守规矩，因为你的代码可能很快就变得不可维护。所以你最好搭配一个像Laravel或者CodeIgniter这样完全成熟的框架。 3. Ham – 带缓存的路由库Ham也是一款轻量级的路由框架，但是它利用缓存甚至获得了更快的速度。它通过把任何I/O相关的东西缓存进XCache/APC。下面是一个例子： require &apos;../ham/ham.php&apos;; $app = new Ham(&apos;example&apos;); $app-&gt;config_from_file(&apos;settings.php&apos;); $app-&gt;route(&apos;/pork&apos;, function($app) { return &quot;Delicious pork.&quot;; }); $hello = function($app, $name=&apos;world&apos;) { return $app-&gt;render(&apos;hello.html&apos;, array( &apos;name&apos; =&gt; $name )); }; $app-&gt;route(&apos;/hello/&lt;string&gt;&apos;, $hello); $app-&gt;route(&apos;/&apos;, $hello);$app-&gt;run(); 这个库要求你至少安装了XCache或APC其中的一个，这可能意味着，在大多数主机提供商提供的主机上它可能用不了。但是如果你拥有一个安装它们其一的主机，或者你可以操控你的web服务器，你应该尝试这款最快的框架。 4. Assetic – 资源管理Assetic是一个PHP的资源管理框架，用于合并和减小了CSS/JS资源。下面是例子。 use Assetic\Asset\AssetCollection; use Assetic\Asset\FileAsset; use Assetic\Asset\GlobAsset; $js = new AssetCollection( array( new GlobAsset(&apos;/path/to/js/*&apos;), new FileAsset(&apos;/path/to/another.js&apos;), ) ); //当资源被输出时，代码会被合并 echo $js-&gt;dump(); 以这种方式合并资源是一个好主意，因为它可以加速站点。不仅仅总下载量减小了，也消除了大量不必要的HTTP请求(这是最影响页面加载时间的两件事) 5. ImageWorkshop – 带层的图片处理ImageWorkshop是一个让你操控带层图片的开源库。借助它你可以重定义尺寸、裁剪、制作缩略图、打水印或做更多事情。下面是一个例子： // 从norway.jpg图片初始化norway层 $norwayLayer = ImageWorkshop::initFromPath(&apos;/path/to/images/norway.jpg&apos;); // 从watermark.png图片初始化watermark层(水印层) $watermarkLayer = ImageWorkshop::initFromPath(&apos;/path/to/images/watermark.png&apos;); // 这是生成的图片! $image = $norwayLayer-&gt;getResult(); header(&apos;Content-type: image/jpeg&apos;); // We choose to show a JPG with a quality of 95% imagejpeg($image, null, 95); exit; ImageWorkshop被开发用于使一些PHP中最通用的处理图片的案例简化，如果你需要一些更强大的东西，你应该看下Imagine library！ 6. Snappy – 快照/PDF库Snappy是一个PHP5库，可以生成快照、URL、HTML、PDF。它依赖于wkhtmltopdf binary（在Linux，Windows和OSX上都可用）。你可以像这样使用它们： require_once &apos;/path/to/snappy/src/autoload.php&apos;; use Knp\Snappy\Pdf; //通过wkhtmltopdf binary路径初始化库 $snappy = new Pdf(&apos;/usr/local/bin/wkhtmltopdf&apos;); //通过把Content-type头设置为pdf来在浏览器中展示pdf header(&apos;Content-Type: application/pdf&apos;); header(&apos;Content-Disposition: attachment; filename=&quot;file.pdf&quot;&apos;); echo $snappy-&gt;getOutput(&apos;http://www.github.com&apos;); 要记得，你的主机提供商可能不允许调用外部二进制程序。 7. Idiorm – 轻量级ORM库Idiorm是个人之前在本网站教程中用过最喜爱的一款。它是一款轻量级的ORM库，一个建立在PDO之上的PHP5查询构造器。借助它，你可以忘记如何书写乏味的SQL： $user = ORM::for_table(&apos;user&apos;) -&gt;where_equal(&apos;username&apos;, &apos;j4mie&apos;) -&gt;find_one(); $user-&gt;first_name = &apos;Jamie&apos;; $user-&gt;save(); $tweets = ORM::for_table(&apos;tweet&apos;) -&gt;select(&apos;tweet.*&apos;) -&gt;join(&apos;user&apos;, array( &apos;user.id&apos;, &apos;=&apos;, &apos;tweet.user_id&apos; )) -&gt;where_equal(&apos;user.username&apos;, &apos;j4mie&apos;) -&gt;find_many(); foreach ($tweets as $tweet) { echo $tweet-&gt;text; } Idiorm有一个姊妹库叫Paris，Paris是一个基于Idiorm的Active Record实现。 8. Underscore – PHP的工具腰带Underscore是原始Underscore.js的一个接口 – Javascript应用的工具腰带。PHP版本没有让人失望，而且支持了几乎所有原生功能。下面是一些例子： __::each(array(1, 2, 3), function($num) { echo $num . &apos;,&apos;; }); // 1,2,3, $multiplier = 2; __::each(array(1, 2, 3), function($num, $index) use ($multiplier) { echo $index . &apos;=&apos; . ($num * $multiplier) . &apos;,&apos;; }); // prints: 0=2,1=4,2=6, __::reduce(array(1, 2, 3), function($memo, $num) { return $memo + $num; }, 0); // 6 __::find(array(1, 2, 3, 4), function($num) { return $num % 2 === 0; }); // 2 __::filter(array(1, 2, 3, 4), function($num) { return $num % 2 === 0; }); // array(2, 4) 这个库也支持链式语法，这使得它更为强大。 9. Requests – 简单HTTP请求Requests是一个简化HTTP请求的库。如果你和我一样，几乎从来都记不住传递给Curl的各种各样的参数，那么它就是为你准备的： $headers = array(&apos;Accept&apos; =&gt; &apos;application/json&apos;); $options = array(&apos;auth&apos; =&gt; array(&apos;user&apos;, &apos;pass&apos;)); $request = Requests::get(&apos;https://api.github.com/gists&apos;, $headers, $options); var_dump($request-&gt;status_code); // int(200) var_dump($request-&gt;headers[&apos;content-type&apos;]); // string(31) &quot;application/json; charset=utf-8&quot; var_dump($request-&gt;body); // string(26891) &quot;[…]&quot; 借助这个库，你可以发送HEAD、GET、POST、PUT、DELTE和PATCH HTTP请求，你可以通过数组添加文件和参数，并且可以访问所有相应数据。 10. Buzz – 简单的HTTP请求库Buzz是另一个完成HTTP请求的库。下面是一个例子： $request = new Buzz\Message\Request(&apos;HEAD&apos;, &apos;/&apos;, &apos;http://google.com&apos;); $response = new Buzz\Message\Response(); $client = new Buzz\Client\FileGetContents(); $client-&gt;send($request, $response); echo $request; echo $response; 因为它缺乏文档，所以你不得不阅读源码来获知它支持的所有参数。 11. Goutte – Web抓取库Goutte是一个抓取网站和提取数据的库。它提供了一个优雅的API，这使得从远程页面上选择特定元素变得简单。 require_once &apos;/path/to/goutte.phar&apos;; use Goutte\Client; $client = new Client();$crawler = $client-&gt;request(&apos;GET&apos;, &apos;http://www.symfony-project.org/&apos;); //点击链接$link = $crawler-&gt;selectLink(&apos;Plugins&apos;)-&gt;link();$crawler = $client-&gt;click($link); //使用一个类CSS语法提取数据$t = $crawler-&gt;filter(&apos;#data&apos;)-&gt;text(); echo &quot;Here is the text: $t&quot;; 12. Carbon – DateTime 库Carbon 是 DateTime API 的一个简单扩展。 printf(&quot;Right now is %s&quot;, Carbon::now()-&gt;toDateTimeString()); printf(&quot;Right now in Vancouver is %s&quot;, Carbon::now(&apos;America/Vancouver&apos;)); $tomorrow = Carbon::now()-&gt;addDay(); $lastWeek = Carbon::now()-&gt;subWeek(); $nextSummerOlympics = Carbon::createFromDate(2012)-&gt;addYears(4); $officialDate = Carbon::now()-&gt;toRFC2822String(); $howOldAmI = Carbon::createFromDate(1975, 5, 21)-&gt;age; $noonTodayLondonTime = Carbon::createFromTime(12, 0, 0, &apos;Europe/London&apos;); $endOfWorld = Carbon::createFromDate(2012, 12, 21, &apos;GMT&apos;); //总是以UTC对比 if (Carbon::now()-&gt;gte($endOfWorld)) { die(); } if (Carbon::now()-&gt;isWeekend()) { echo &apos;Party!&apos;; } echo Carbon::now()-&gt;subMinutes(2)-&gt;diffForHumans(); // &apos;2分钟之前&apos; 13. Ubench – 微型基准库Ubench 是一个用于评测PHP代码的微型库，可监控（代码）执行时间和内存使用率。下面是范例： use Ubench\Ubench; $bench = new Ubench; $bench-&gt;start();//执行一些代码 $bench-&gt;end();//获取执行消耗时间和内存 echo $bench-&gt;getTime(); // 156ms or 1.123s echo $bench-&gt;getTime(true); // elapsed microtime in floatecho $bench-&gt;getTime(false, &apos;%d%s&apos;); // 156ms or 1s echo $bench-&gt;getMemoryPeak(); // 152B or 90.00Kb or 15.23Mb echo $bench-&gt;getMemoryPeak(true); // memory peak in bytes 内存峰值 echo $bench-&gt;getMemoryPeak(false, &apos;%.3f%s&apos;); // 152B or 90.152Kb or 15.234Mb //在结束标识处返回内存使用情况 echo $bench-&gt;getMemoryUsage(); // 152B or 90.00Kb or 15.23Mb (仅)在开发时运行这些校验是一个好主意。 14. Validation – 输入验证引擎Validation 声称是PHP库里最强大的验证引擎。但是，它能名副其实吗？看下面： use Respect\Validation\Validator as v; //简单验证 $number = 123; v::numeric()-&gt;validate($number); //true //链式验证 $usernameValidator = v::alnum()-&gt;noWhitespace()-&gt;length(1,15); $usernameValidator-&gt;validate(&apos;alganet&apos;); //true //验证对象属性 $user = new stdClass;$user-&gt;name = &apos;Alexandre&apos;; $user-&gt;birthdate = &apos;1987-07-01&apos;; //在一个简单链中验证他的属性 $userValidator = v::attribute(&apos;name&apos;, v::string()-&gt;length(1,32)) -&gt;attribute(&apos;birthdate&apos;, v::date()-&gt;minimumAge(18)); $userValidator-&gt;validate($user); //true 你可以通过这个库验证你的表单或其他用户提交的数据。除此之外，它内置了很多校验，抛出异常和定制错误信息。 15. Filterus – 过滤库Filterus是另一个过滤库，但它不仅仅可以验证，也可以过滤匹配预设模式的输出。下面是一个例子： $f = Filter::factory(&apos;string,max:5&apos;); $str = &apos;This is a test string&apos;; $f-&gt;validate($str); // false $f-&gt;filter($str); // &apos;This &apos; Filterus有很多内建模式，支持链式用法，甚至可以用独立的验证规则去验证数组元素。 16. Faker – 假数据生成器Faker 是一个为你生成假数据的PHP库。当你需要填充一个测试数据库，或为你的web应用生成测试数据时，它能派上用场。它也非常容易使用： //引用Faker 自动加载器 require_once &apos;/path/to/Faker/src/autoload.php&apos;; //使用工厂创建来创建一个Faker\Generator实例 $faker = Faker\Factory::create();//通过访问属性生成假数据 echo $faker-&gt;name; // &apos;Lucy Cechtelar&apos;; echo $faker-&gt;address; // &quot;426 Jordy Lodge // Cartwrightshire, SC 88120-6700&quot; echo $faker-&gt;text; // Sint velit eveniet. Rerum atque repellat voluptatem quia ... 只要你继续访问对象属性，它将继续返回随机生成的数据。 17. Mustache.php – 优雅模板库Mustache是一款流行的模板语言，实际已经在各种编程语言中得到实现。使用它，你可以在客户端或服务段重用模板。 正如你猜得那样，Mustache.php 是使用PHP实现的。 $m = new Mustache_Engine; echo $m-&gt;render(&apos;Hello `{`{planet}`}`&apos;, array(&apos;planet&apos; =&gt; &apos;World!&apos;)); // &quot;Hello World!&quot; 建议看一下官方网站Mustache docs 查看更多高级的例子。 18. Gaufrette – 文件系统抽象层Gaufrette是一个PHP5库，提供了一个文件系统的抽象层。它使得以相同方式操控本地文件，FTP服务器，亚马逊 S3或更多操作变为可能。它允许你开发程序时，不用了解未来你将怎么访问你的文件。 use Gaufrette\Filesystem;use Gaufrette\Adapter\Ftp as FtpAdapter; use Gaufrette\Adapter\Local as LocalAdapter; //本地文件: $adapter = new LocalAdapter(&apos;/var/media&apos;); //可选地使用一个FTP适配器 $ftp = new FtpAdapter($path, $host, $username, $password, $port); //初始化文件系统 $filesystem = new Filesystem($adapter); //使用它 $content = $filesystem-&gt;read(&apos;myFile&apos;); $content = &apos;Hello I am the new content&apos;; $filesystem-&gt;write(&apos;myFile&apos;, $content); 也有缓存和内存适配器，并且随后将会增加更多适配器。 19. Omnipay – 支付处理库Omnipay是一个PHP支付处理库。它有一个清晰一致的API，并且支持数十个网关。使用这个库，你仅仅需要学习一个API和处理各种各样的支付处理器。下面是一个例子： use Omnipay\CreditCard;use Omnipay\GatewayFactory;$gateway = GatewayFactory::create(&apos;Stripe&apos;);$gateway-&gt;setApiKey(&apos;abc123&apos;);$formData = [&apos;number&apos; =&gt; &apos;4111111111111111&apos;, &apos;expiryMonth&apos; =&gt; 6, &apos;expiryYear&apos; =&gt; 2016];$response = $gateway-&gt;purchase([&apos;amount&apos; =&gt; 1000, &apos;card&apos; =&gt; $formData]); if ($response-&gt;isSuccessful()) { //支付成功:更新数据库 print_r($response); } else if ($response-&gt;isRedirect()) { //跳转到异地支付网关 $response-&gt;redirect(); } else { //支付失败:向客户显示信息 exit($response-&gt;getMessage()); } 使用相同一致的API，可以很容易地支持多种支付处理器，或在需要时进行切换。 20. Upload – 处理文件上传Upload是一个简化文件上传和验证的库。上传表单时，这个库会校验文件类型和尺寸。 $storage = new \Upload\Storage\FileSystem(&apos;/path/to/directory&apos;); $file = new \Upload\File(&apos;foo&apos;, $storage); //验证文件上传 $file-&gt;addValidations(array( //确保文件类型是&quot;image/png&quot; new \Upload\Validation\Mimetype(&apos;image/png&apos;), //确保文件不超过5M(使用&quot;B&quot;,&quot;K&quot;,&quot;M&quot;或者&quot;G&quot;) new \Upload\Validation\Size(&apos;5M&apos;))); //试图上传文件 try { //成功 $file-&gt;upload(); }catch (\Exception $e) { //失败! $errors = $file-&gt;getErrors(); } 它将减少不少乏味的代码。 21. HTMLPurifier – HTML XSS 防护HTMLPurifier是一个HTML过滤库，通过强大的白名单和聚集分析，保护你代码远离XSS攻击。它也确保输出标记符合标准。 (源码在github上) require_once &apos;/path/to/HTMLPurifier.auto.php&apos;; $config = HTMLPurifier_Config::createDefault(); $purifier = new HTMLPurifier($config); $clean_html = $purifier-&gt;purify($dirty_html); 如果你的网站允许用户提交 HTML 代码，不修改就展示代码的话，那这时候就是用这个库的时候了。 22. ColorJizz-PHP – 颜色操控库ColorJizz是一个简单的库，借助它你可以转换不同的颜色格式，并且做简单的颜色运算 use MischiefCollective\ColorJizz\Formats\Hex; $red_hex = new Hex(0xFF0000); $red_cmyk = $hex-&gt;toCMYK(); echo $red_cmyk; // 0,1,1,0 echo Hex::fromString(&apos;red&apos;)-&gt;hue(-20)-&gt;greyscale(); // 555555 它已经支持并且可以操控所有主流颜色格式了 23. PHP Geo – 地理位置定位库phpgeo是一个简单的库，用于计算地理坐标之间高精度距离。例如： use Location\Coordinate;use Location\Distance\Vincenty; $coordinate1 = new Coordinate(19.820664, -155.468066); // Mauna Kea Summit 茂纳凯亚峰 $coordinate2 = new Coordinate(20.709722, -156.253333); // Haleakala Summit $calculator = new Vincenty(); // returns 128130.850 (meters; ≈128 kilometers) $distance = $calculator-&gt;getDistance($coordinate1, $coordinate2); 它将在使用地理位置数据的app里出色工作。你可以试译 HTML5 Location API，雅虎的API（或两者都用，我们在weather web app tutorial中这样做了），来获取坐标。 24. ShellWrap – 优美的命令行包装器借助 ShellWrap 库，你可以在PHP代码里使用强大的 Linux/Unix 命令行工具。 require ‘ShellWrap.php’; use \MrRio\ShellWrap as sh; //列出当前文件下的所有文件 echo sh::ls(); //检出一个git分支 sh::git(&apos;checkout&apos;, &apos;master&apos;); //你也可以通过管道把一个命令的输出用户另一个命令 //下面通过curl跟踪位置，然后通过grep过滤’html’管道来下载example.com网站 echo sh::grep(&apos;html&apos;, sh::curl(&apos;http://example.com&apos;, array( &apos;location&apos; =&gt; true ))); //新建一个文件 sh::touch(&apos;file.html&apos;); //移除文件 sh::rm(&apos;file.html&apos;); //再次移除文件(这次失败了,然后因为文件不存在而抛出异常) try { sh::rm(&apos;file.html&apos;); } catch (Exception $e) { echo &apos;Caught failing sh::rm() call&apos;; } 当命令行里发生异常时，这个库抛出异常，所以你可以及时对之做出反应。它也可以通过管道让你一个命令的输出作为另一个命令的输入，来实现更强的灵活性]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP技能树汇总(超全面)]]></title>
    <url>%2F2017%2F04%2F16%2FPHP%E6%8A%80%E8%83%BD%E6%A0%91%E6%B1%87%E6%80%BB-%E8%B6%85%E5%85%A8%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[该仓库主要真是国内 PHP 面试经常被问到的知识点做汇总。仅是针对性指出知识点，相应还需自己查找相关资料系统学习。我希望各位能不仅仅了解是什么，还要了解为什么，以及背后的原理。 如果您有对相应知识点非常系统的资料，欢迎 PR 增加链接。不建议您使用 fork，资料会随时更新。 如果你现在处于以下几种状态，本资料非常适合你： 准备换工作，不知道从哪开始准备 技术遇到瓶颈，不知道该学什么 准备学 PHP，但不知道领域有多深 基础篇 了解大部分数组处理函数 字符串处理函数 区别 mb_ 系列函数 &amp; 引用，结合案例分析 == 与 === 区别 isset 与 empty 区别 全部魔术函数理解 static、$this、self 区别 private、protected、public、final 区别 OOP 思想 抽象类、接口 分别使用场景 Trait 是什么东西 echo、print、print_r 区别(区分出表达式与语句的区别) construct 与 destruct 区别 static 作用（区分类与函数内）手册 、SOF __toString() 作用 单引号&#39;与双引号&quot;区别 常见 HTTP 状态码，分别代表什么含义 301 什么意思 404 呢? 进阶篇 Autoload、Composer 原理 PSR-4 、原理 Session 共享、存活时间 异常处理 如何 foreach 迭代对象 如何数组化操作对象 $obj[key]; 如何函数化对象 $obj(123); yield 是什么，说个使用场景 yield PSR 是什么，PSR-1, 2, 4, 7 如何获取客户端 IP 和服务端 IP 地址 客户端 IP 服务端 IP 了解代理透传 实际IP 的概念 如何开启 PHP 异常提示 php.ini 开启 display_errors 设置 error_reporting 等级 运行时，使用 ini_set(k, v); 动态设置 如何返回一个301重定向 [WARNING] 一定当心设置 301 后脚本会继续执行，不要认为下面不会执行，必要时使用 die or exit 如何获取扩展安装路径 phpinfo(); 页面查找 extension_dir 命令行 php -i |grep extension_dir 运行时 echo ini_get(&#39;extension_dir&#39;); 字符串、数字比较大小的原理，注意 0 开头的8进制、0x 开头16进制 字符串比较大小，从左(高位)至右，逐个字符 ASCII 比较 BOM 头是什么，怎么除去 0xEF,0xBB,0xBF 检测、去除 什么是 MVC 依赖注入实现原理 如何异步执行命令 模板引擎是什么，解决什么问题、实现原理（Smarty、Twig、Blade） 如何实现链式操作 $obj-&gt;w()-&gt;m()-&gt;d(); Xhprof 、Xdebug 性能调试工具使用 索引数组 [1, 2] 与关联数组 [&#39;k1&#39;=&gt;1, &#39;k2&#39;=&gt;2] 有什么区别 缓存的使用方式、场景 实践篇 给定二维数组，根据某个字段排序 如何判断上传文件类型，如：仅允许 jpg 上传 不使用临时变量交换两个变量的值 $a=1; $b=2; =&gt; $a=2; $b=1; strtoupper 在转换中文时存在乱码，你如何解决？php echo strtoupper(&#39;ab你好c&#39;); Websocket、Long-Polling、Server-Sent Events(SSE) 区别 “Headers already sent” 错误是什么意思，如何避免 算法篇 快速排序（手写） 冒泡排序（手写） 二分查找（了解） 查找算法 KMP（了解） 深度、广度优先搜索（了解） LRU 缓存淘汰算法（了解，Memcached 采用该算法） 数据结构篇（了解） 堆、栈特性 队列 哈希表 链表 对比篇 Cookie 与 Session 区别 GET 与 POST 区别 include 与 require 区别 include_once 与 require_once 区别 Memcached 与 Redis 区别 MySQL 各个存储引擎、及区别（一定会问 MyISAM 与 Innodb 区别） HTTP 与 HTTPS 区别 Apache 与 Nginx 区别 define() 与 const 区别 traits 与 interfaces 区别 及 traits 解决了什么痛点？ Git 与 SVN 区别 数据库篇 MySQL CRUD JOIN、LEFT JOIN 、RIGHT JOIN、INNER JOIN UNION GROUP BY + COUNT + WHERE 组合案例 常用 MySQL 函数，如：now()、md5()、concat()、uuid()等 1:1、1:n、n:n 各自适用场景 了解触发器是什么，说个使用场景 数据库优化手段 索引、联合索引（命中条件） 分库分表（水平分表、垂直分表） 分区 会使用 explain 分析 SQL 性能问题，了解各参数含义 重点理解 type、rows、key Slow Log（有什么用，什么时候需要） MSSQL(了解) 查询最新5条数据 NOSQL Redis、Memcached、MongoDB 对比、适用场景（可从以下维度进行对比） 持久化 支持多钟数据类型 可利用 CPU 多核心 内存淘汰机制 集群 Cluster 支持 SQL 性能对比 支持事务 应用场景 你之前为了解决什么问题使用的什么，为什么选它？ 服务器篇 查看 CPU、内存、时间、系统版本等信息 find 、grep 查找文件 awk 处理文本 查看命令所在目录 自己编译过 PHP 吗？如何打开 readline 功能 如何查看 PHP 进程的内存、CPU 占用 如何给 PHP 增加一个扩展 修改 PHP Session 存储位置、修改 INI 配置参数 负载均衡有哪几种，挑一种你熟悉的说明其原理 数据库主从复制 M-S 是怎么同步的？是推还是拉？会不会不同步？怎么办 如何保障数据的可用性，即使被删库了也能恢复到分钟级别。你会怎么做。 数据库连接过多，超过最大值，如何优化架构。从哪些方便处理？ 502 大概什么什么原因？ 如何排查 504呢？ 架构篇 偏运维（了解）： 负载均衡（Nginx、HAProxy、DNS） 主从复制（MySQL、Redis） 数据冗余、备份（MySQL增量、全量 原理） 监控检查（分存活、服务可用两个维度） MySQL、Redis、Memcached Proxy 、Cluster 目的、原理 分片 高可用集群 RAID 源代码编译、内存调优 缓存 工作中遇到哪里需要缓存，分别简述为什么 搜索解决方案 性能调优 各维度监控方案 日志收集集中处理方案 国际化 数据库设计 静态化方案 画出常见 PHP 应用架构图 框架篇 ThinkPHP（TP）、CodeIgniter（CI）、Zend（非 OOP 系列） Yaf、Phalcon（C 扩展系） Yii、Laravel、Symfony（纯 OOP 系列） Swoole、Workerman （网络编程框架） 对比框架区别几个方向点 是否纯 OOP 类库加载方式（自己写 autoload 对比 composer 标准） 易用性方向（CI 基础框架，Laravel 这种就是高开发效率框架以及基础组件多少） 黑盒（相比 C 扩展系） 运行速度（如：Laravel 加载一大堆东西） 内存占用 设计模式 单例模式（重点） 工厂模式（重点） 观察者模式（重点） 依赖注入（重点） 装饰器模式 代理模式 组合模式 安全篇 SQL 注入 XSS 与 CSRF 输入过滤 Cookie 安全 禁用 mysql_ 系函数 数据库存储用户密码时，应该是怎么做才安全 验证码 Session 问题 安全的 Session ID （让即使拦截后，也无法模拟使用） 目录权限安全 包含本地与远程文件 文件上传 PHP 脚本 eval 函数执行脚本 disable_functions 关闭高危函数 FPM 独立用户与组，给每个目录特定权限 了解 Hash 与 Encrypt 区别 高阶篇 PHP 数组底层实现 （HashTable + Linked list） Copy on write 原理，何时 GC PHP 进程模型，进程通讯方式，进程线程区别 yield 核心原理是什么 PDO prepare 原理 PHP 7 与 PHP 5 有什么区别 Swoole 适用场景，协程实现方式 前端篇 原生获取 DOM 节点，属性 盒子模型 CSS 文件、style 标签、行内 style 属性优先级 HTML 与 JS 运行顺序（页面 JS 从上到下） JS 数组操作 类型判断 this 作用域 .map() 与 this 具体使用场景分析 Cookie 读写 JQuery 操作 Ajax 请求（同步、异步区别）随机数禁止缓存 Bootstrap 有什么好处 跨域请求 N 种解决方案 新技术（了解） ES6 模块化 打包 构建工具 vue、react、webpack、 前端 mvc 优化 浏览器单域名并发数限制 静态资源缓存 304 （If-Modified-Since 以及 Etag 原理） 多个小图标合并使用 position 定位技术 减少请求 静态资源合为单次请求 并压缩 CDN 静态资源延迟加载技术、预加载技术 keep-alive CSS 在头部，JS 在尾部的优化（原理） 网络篇 IP 地址转 INT 192.168.0.1/16 是什么意思 DNS 主要作用是什么？ IPv4 与 v6 区别 网络编程篇 TCP 三次握手流程 TCP、UDP 区别，分别适用场景 有什么办法能保证 UDP 高可用性(了解) TCP 粘包如何解决？ 为什么需要心跳？ 什么是长连接？ HTTPS 是怎么保证安全的？ 流与数据报的区别 进程间通信几种方式，最快的是哪种？ fork() 会发生什么？ API 篇 RESTful 是什么 如何在不支持 DELETE 请求的浏览器上兼容 DELETE 请求 常见 API 的 APP_ID APP_SECRET 主要作用是什么？阐述下流程 API 请求如何保证数据不被篡改？ JSON 和 JSONP 的区别 数据加密和验签的区别 RSA 是什么 API 版本兼容怎么处理 限流（木桶、令牌桶） OAuth 2 主要用在哪些场景下 JWT PHP 中 json_encode([&#39;key&#39;=&gt;123]); 与 return json_encode([]); 区别，会产生什么问题？如何解决 加分项 了解常用语言特性，及不同场景适用性。 PHP VS Golang PHP VS Python PHP VS JAVA 了解 PHP 扩展开发 熟练掌握 C PHP常用技能消息队列 应用场景 秒杀 抢购 发送消息 发送卡券 Redis List RabbitMQ 生成二维码 QR Code 即时通信 应用场景 客服 聊天 监控实时监控数据 群发 MeepoPS workerman 抽象画图 应用场景 数据统计 性能统计 JpGraph 安装扩展mcrypt扩展yum install libmcrypt libmcrypt-devel php-mcrypt mhash php性能优化PHP语言级性能优化 避免使用魔法函数如__get() 尽量使用自带函数完成 自带函数功能一致的情况下性能不同 禁用错误抑制符@ 合理使用内存,及时unset()释放不使用的内存(unset有释放不掉的内存) 合理使用正则 避免在循环内做运算(循环内的计算式将会被重复计算) 减少密集型业务(PHP不适合密集型运算的场景),适合衔接webserver与后端服务、UI呈现 务必使用带引号的字符串做键值(PHP会将没有引号的键值作为常量,产生查找常量的开销) PHP周边问题的优化 减少文件类的操作(内存&gt;&gt;数据库&gt;磁盘&gt;网络) 减少PHP发起的网络请求(设置超时时间,将串行请求并行化”使用curl_multi,使用swoole扩展”) 压缩PHP输出,利:利于我们的数据输出,client端能更快的获取到数据;弊:产生额外的CPU开销(Gzip即可) PHP缓存复用(多次请求,内容不变的情况) Smarty调优和重叠时间窗口]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GC机制中GC算法]]></title>
    <url>%2F2017%2F03%2F22%2FGC%E6%9C%BA%E5%88%B6%E4%B8%ADGC%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[垃圾回收机制(garbage collection)在高级语言中有个很重要的机制叫做垃圾回收(gc)，高级语言不需要手动释放变量，是由语言本身来判断什么时候释放某个变量，而我们需要了解某个变量什么时候被语言释放(回收)了。 在PHP中没有任何变量指向一个对象时，这个对象就成了垃圾，PHP会将其在内存中销毁，这就是PHP的垃圾回收机制，防止内存溢出 一、引用计数我们知道，PHP变量是存在一个叫zval的变量容器里面，zval有两个变量，一个是is_ref来标识这个变量是否属于引用，一个是refcount用来统计指向这个变量容器的变量的个数 如下例所示： 1234567891011121314&lt;?php $a = &quot;String&quot;; xdebug_debug_zval(&apos;a&apos;); # 输出结果# a: (refcount=1, is_ref=0)=&apos;String&apos;// 将$a赋给$b $b = $a; xdebug_debug_zval(&apos;a&apos;);# 输出结果# a: (refcount=2, is_ref=0)=&apos;String&apos;// 此时我们可以看到refcount的值变为了2，也就是有两个变量指向了这个变量容器 当变量不在指向变量容器，或者调用了unset（unset的真实含义并不是删除某个变量，而是让他不再指向某个变量容器）refcount的值就会减少 12345678910&lt;?php $a = &quot;new string&quot;; $c = $b = $a; xdebug_debug_zval( &apos;a&apos; ); unset( $b, $c ); xdebug_debug_zval( &apos;a&apos; ); # 输出结果# a: (refcount=3, is_ref=0)=&apos;new string&apos;# a: (refcount=1, is_ref=0)=&apos;new string 上面的例子只是简单的说明了字符串这种简单类型，PHP中array和Object这种复合类型的时候，就会稍微复杂一点 123456789&lt;?php$a = array( &apos;meaning&apos; =&gt; &apos;life&apos;, &apos;number&apos; =&gt; 42 );xdebug_debug_zval( &apos;a&apos; );# 输出结果a: (refcount=1, is_ref=0)=array ( &apos;meaning&apos; =&gt; (refcount=1, is_ref=0)=&apos;life&apos;, &apos;number&apos; =&gt; (refcount=1, is_ref=0)=42) 这个时候会产生三个变量容器分别是a、meaning、number。我们在对程序做一些修改 1234567891011&lt;?php$a = array( &apos;meaning&apos; =&gt; &apos;life&apos;, &apos;number&apos; =&gt; 42 );$a[&apos;life&apos;] = $a[&apos;meaning&apos;];xdebug_debug_zval( &apos;a&apos; );# 输出结果a: (refcount=1, is_ref=0)=array ( &apos;meaning&apos; =&gt; (refcount=2, is_ref=0)=&apos;life&apos;, &apos;number&apos; =&gt; (refcount=1, is_ref=0)=42, &apos;life&apos; =&gt; (refcount=2, is_ref=0)=&apos;life&apos;) 我们可以看到life和meaning是指向的同一个变量容器，所以他们的refcount都是2 如果我们将一个数组元素添加给自己本身: 12345678910&lt;?php$a = array( &apos;one&apos; );$a[] = &amp;$a;xdebug_debug_zval( &apos;a&apos; );# 输出结果a: (refcount=2, is_ref=1)=array ( 0 =&gt; (refcount=1, is_ref=0)=&apos;one&apos;, 1 =&gt; (refcount=2, is_ref=1)=...) 我们看到了a本身和第二个元素1的refcount为2，这样形成了一个递归循环，a的第二个元素指向了他自己。如果对$a进行unset操作，$a的变量容器引用次数减一，变成了： 1234(refcount=1, is_ref=1)=array ( 0 =&gt; (refcount=1, is_ref=0)=&apos;one&apos;, 1 =&gt; (refcount=1, is_ref=1)=...) 尽管没有变量指向这个容器，由于他自己的第二个元素始终指向他本身，就没有办法回收这个变量容器，造成了内存泄露 二、回收周期(Collecting Cycles)我们可以从上面的例子看到，PHP的引用计数内存的机制，无法处理循环的引用内存泄露问题，在PHP5.3（或者是5.4）版本，使用了一种叫同步周期回收的算法，来处理这个内存泄露的问题。 这个算法的基础规则是： 如果一个引用计数增加，它将继续被使用，当然就不再在垃圾中。如果引用计数减少到零，所在变量容器将被清除(free)。就是说，仅仅在引用计数减少到非零值时，才会产生垃圾周期(garbage cycle)。其次，在一个垃圾周期中，通过检查引用计数是否减1，并且检查哪些变量容器的引用次数是零，来发现哪部分是垃圾。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP应用——前端UI库汇总]]></title>
    <url>%2F2017%2F03%2F16%2FPHP%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E5%89%8D%E7%AB%AFUI%E5%BA%93%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[移动端UI框架Mint UI（饿了么团队） 中文官网：http://mint-ui.github.io/#!/zh-cn 描述：基于vue的移动端UI框架 SUI Mobile（阿里巴巴共享业务事业部UED团队） 官网：http://m.sui.taobao.org/ 描述：一套基于 Framework7 开发的UI库。基于IOS风格。它非常轻量、精美，只需要引入我们的CDN文件就可以使用， 并且能兼容到 iOS 6.0+ 和 Android 4.0+，非常适合开发跨平台Web App。 Weui（微信官方设计团队） 描述：WeUI 为微信 Web 服务量身设计,是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信 Web 开发量身设计，可以令用户的使用感知更加统一。 包含button、cell、dialog、 progress、 toast、article、actionsheet、icon等各式元素。 YDUI Touch 官网：http://www.ydui.org/ 描述：一只注重审美，且性能高效的移动端&amp;微信UI。 基于jQuery GMU（百度GMU小组开发） 描述：基于zepto的轻量级mobile UI组件库，符合jquery ui使用规范，提供webapp、pad端简单易用的UI组件。 兼容iOS3+ / android2.1+，支持国内主流移动端浏览器，如safari, chrome, UC, qq等。 FrozenUI（QQVIP FD团队• Alloyteam团队） 官方地址：http://frozenui.github.io/ 描述：简单易用，轻量快捷，为移动端服务的前端框架。基于手Q样式规范。应用在腾讯手Q增值业务。兼容android 2.3 +，ios 4.0 + 。 Amaze UI 官方地址：http://amazeui.org/ 描述：中国首个开源 HTML5 跨屏前端框架。Amaze UI 关注中文排版，根据用户代理调整字体， 基于jQuery,实现更好的中文排版效果。 Pure 中文官网：https://www.purecss.cn/ 描述：纯CSS, 美国雅虎公司出品的一组轻量级、响应式纯css模块，适用于任何Web项目。 PC 端 UI框架iView 官网地址：https://www.iviewui.com/ 描述：一套基于 Vue.js 的高质量 UI 组件库。iView 是一套基于 Vue.js 的开源 UI 组件库，主要服务于 PC 界面的中后台产品。 Element UI（饿了么团队） 官方地址：http://element-cn.eleme.io/#/zh-CN 描述：基于 Vue 2.0 的桌面端组件库 SUI（阿里巴巴国际UED团队-商家业务事业部） 官网地址：http://sui.taobao.org/ 描述：一套基于bootstrap开发的前端组件库，同时她也是一套设计规范。 基于jquery H-ui 官方地址：http://www.h-ui.net/ 描述：轻量级前端框架，简单免费，兼容性好，服务中国网站。 基于jQuery layui 官方地址：http://www.layui.com/ 描述：更多是为服务端程序员量身定做，你无需涉足各种前端工具的复杂配置，只需面对浏览器本身，让一切你所需要的元素与交互，从这里信手拈来。 layui 兼容人类正在使用的全部浏览器（IE6/7除外），可作为 PC 端后台系统与前台界面的速成开发方案。 uiKit（YOOtheme 团队） 官网地址：http://www.getuikit.net/ 描述：一款轻量级、模块化的前端框架，可快速构建强大的web前端界面。 UIkit 兼容 IE9 以上现代浏览器。在 IE8 及其以下版本中，所有JavaScript 都会失效。依赖jQuery Bootstrap 中文官网：http://www.bootcss.com/ 描述：简洁、直观、强悍的前端开发框架，让web开发更迅速、简单。 jQuery UI 官方网址：http://jqueryui.com/ ionic 中文官网网址：http://www.ionic-china.com/基于angular 描述：ionic是一个强大的 HTML5应用程序开发框架(HTML5 Hybrid Mobile App Framework)。ionic 主要关注外观和体验，以及和你的应用程序的 UI 交互，特别适合用于基于 Hybird 模式的 HTML5 移动应用程序开发。 ionic是一个轻量的手机UI库，具有速度快，界面现代化、美观等特点。 Framework7 官网地址：http://framework7.cn/ 描述：Framework7 是一个开源免费的框架可以用来开发混合移动应用（原生和HTML混合）或者开发 iOS &amp; Android 风格的WEB APP。 也可以用来作为原型开发工具，可以迅速创建一个应用的原型。她只专注于为 iOS 和 Google Material 设计提供最好的体验。 OnsenUI 官网地址：https://onsen.io/ 描述：用来构建混合移动端APP的 HTML5 UI 框架 react-native 中文官网地址：http://reactnative.cn/ 描述：React Native使你能够在Javascript和React的基础上获得完全一致的开发体验，构建世界一流的原生APP。 React Native着力于提高多平台开发的开发效率 —— 仅需学习一次，编写任何平台。(Learn once, write anywhere) weex 官网地址：http://weex.apache.org/cn/ 描述：Weex 提供强大的跨平台能力，可以使用相同的 API 开发 Web，Android 和 iOS 应用。 同时，我们对接口了丰富的扩展能力。 注：文章来源与前端UI框架小汇总,方便后续使用]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP拓展篇——Composer实战操作指南]]></title>
    <url>%2F2017%2F03%2F02%2FPHP%E6%8B%93%E5%B1%95%E7%AF%87%E2%80%94%E2%80%94Composer%E5%AE%9E%E6%88%98%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[Composer是什么玩过Linux或者玩过编程的应该都知道，yum、apt-get、npm、bower等命令，composer其实和上面是一样的，只是composer专门给PHP用。 就像iOS中的Pods，Carthage，Android中的gradle pod = cocoapods 编译成静态链接库或者动态框架文件，会修改Xcode项目属性配置依赖关系 Carthage 去中心化(无中心库), 非侵入性：动态框架，不会修改Xcode项目属性配置依赖关系 gradle(JCenter，mavenCenter，JitPack)。Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建开源工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，抛弃了基于XML的各种繁琐配置。面向Java应用为主。 而Composer 是 PHP5.3以上 的一个依赖管理工具。它允许你声明项目所依赖的代码库，它会在你的项目中为你快速安装他们。涉及 “packages” 和 “libraries”。平时我们安装一个PHP类库，需要搜索-&gt;下载；使用composer，我们只要知道包名，直接composer insatll就可以了。 Composer 也只是一段 PHP 脚本，用官方的话说就是： 是 PHP 用来管理依赖（dependency）关系的工具。你可以在自己的项目中声明所依赖的外部工具库（libraries），Composer 会帮你安装这些依赖的库文件。 Composer用途 安装PHP包、依赖库。 通过过composer，我们可以使用大量的第三方库，而无需自己造轮子 比如 monolog $ composer require monolog/monolog laravel $ composer create-project laravel/laravel learnlaravel5 5.0.22 thinkphp5：然后在命令行下面，切换到你的web根目录下面并执行下面的命令： $ composer create-project topthink/think=5.0.* tp5 –prefer-dist 你可以在 https://packagist.org/ 找到你需要的库。甚至你可以提交自己写的优秀的库到该平台里供大家使用。 安装废话不多说，直接上代码 安装 curl -sS https://getcomposer.org/installer | php 全局 mv composer.phar /usr/local/bin/composer 之后，就可以直接使用composer install安装包了。不过通常情况下只需将composer.phar的位置加入到PATH就可以，不一定要全局安装。 镜像 composer config -g repo.packagist composer https://packagist.phpcomposer.com 常见镜像地址： https://packagist.org 国外的 http://packagist.phpcomposer.com 中国全量镜像 https://pkg.phpcomposer.com/ https://www.phpcomposer.com/ 更新 composer self-update 操作执行结束，会在当前目录下生成composer.phar文件，在Linux里，composer.phar是可执行程序。 例如，我们可以使用php composer.phar update执行更新操作。 全局安装： mv composer.phar /usr/local/bin/composer 验证composer[parallels@centos-7 html]$ composer ______ / ____/___ ____ ___ ____ ____ ________ _____ / / / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/ / /___/ /_/ / / / / / / /_/ / /_/ (__ ) __/ / \____/\____/_/ /_/ /_/ .___/\____/____/\___/_/ /_/ Composer version 1.8.4 2019-02-11 10:52:10 Usage: command [options] [arguments] Options: ... version[parallels@centos-7 html]$ composer -V Composer version 1.8.4 2019-02-11 10:52:10 使用初始化在自己想要创建项目的地方新建一个文件夹，命名为 ComposerP1，在文件夹下新建文件 composer.json： { &quot;require&quot;: { } } 命令行切换到 ComposerP1 目录下，运行： composer update 就会在该目录下生成一个vendor文件夹。以后所有的第三扩展包都会安装在这里。 安装扩展包在项目目录下创建一个composer.json文件，指明依赖，比如，你的项目依赖 monolog： { &quot;require&quot;: { &quot;monolog/monolog&quot;: &quot;1.2.*&quot; }, &quot;config&quot;: { // 解决有时候因为https造成的问题 &quot;secure-http&quot;: false } } 安装依赖安装依赖非常简单，只需在项目目录下运行： composer install 如果没有全局安装的话，则运行： php composer.phar install 更新全部的包（谨慎使用）： composer update 注意：使用composer install或者composer update命令将会更新所有的扩展包，项目中使用需谨慎！！！若只安装指定的包推荐在命令行使用一下命名进行安装。 composer require monolog/monolog 如果需要指定版本： composer require “monolog/monolog:1.2.*” 更新某个包： composer update monolog/monolog 移除某个包： composer remove monolog/monolog 如果手动更新了composer.json需要更新autoload： composer dump-autoload 命令汇总 composer list 列出所有可用的命令 composer init 初始化composer.json文件(就不劳我们自己费力创建啦)，会要求输入一些信息来描述我们当前的项目，还会要求输入依赖包 composer install 读取composer.json内容，解析依赖关系，安装依赖包到vendor目录下 composer update 更新最新的依赖关系到compsoer.lock文件，解析最新的依赖关系并且写入* composer.lock文件 composer search packagename 搜索包，packagename替换为你想查找的包名称 composer require packagename 添加对packagename的依赖，packagename可修改为你想要的包名称 composer show packagename composer self-update 更新 composer.phar文件自身 composer dump-autoload –optimize 优化一下自动加载 composer command –help 以上所有命令都可以添加 –help选项查看帮助信息]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于事务入门]]></title>
    <url>%2F2017%2F02%2F19%2F%E5%85%B3%E4%BA%8E%E4%BA%8B%E5%8A%A1%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[事务一、事务的属性ACID 原子性(atomicity):事务是一个原子操作单元，要么全部执行，要么全部都不执行 一致性(consistent): 在事务开始和完成时，数据都必须保持一致性。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。 隔离性(lsolation): 数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的独立环境执行。这意味着事务处理过程中的中间状态对外部是不可见的。 持久性(Durable): 事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。 ###二、并发事务带来的问题 1.更新丢失当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题－－最后的更新覆盖了由其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖另一个编辑人员所做的更改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题。 2.脏读一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做”脏读”。 3.不可重复读不可重复读（Non-Repeatable Reads）：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。 4.幻读一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。 ###三、事务的隔离级别 1.读取未提交的内容(Read Uncommitted) (1)所有事务都可以看到其他未提交事务的执行结果 (2)该隔离级别引发的问题就是脏读：读取到了未提交的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#首先，修改隔离级别set tx_isolation=&apos;READ-UNCOMMITTED&apos;;select @@tx_isolation;+------------------+| @@tx_isolation |+------------------+| READ-UNCOMMITTED |+------------------+#事务A：启动一个事务start transaction;select * from tx;+------+------+| id | num |+------+------+| 1 | 1 || 2 | 2 || 3 | 3 |+------+------+#事务B：也启动一个事务(那么两个事务交叉了) 在事务B中执行更新语句，且不提交start transaction;update tx set num=10 where id=1;select * from tx;+------+------+| id | num |+------+------+| 1 | 10 || 2 | 2 || 3 | 3 |+------+------+#事务A：那么这时候事务A能看到这个更新了的数据吗?select * from tx;+------+------+| id | num |+------+------+| 1 | 10 | ---&gt;可以看到！说明我们读到了事务B还没有提交的数据| 2 | 2 || 3 | 3 |+------+------+#事务B：事务B回滚,仍然未提交rollback;select * from tx;+------+------+| id | num |+------+------+| 1 | 1 || 2 | 2 || 3 | 3 |+------+------+#事务A：在事务A里面看到的也是B没有提交的数据select * from tx;+------+------+| id | num |+------+------+| 1 | 1 | ---&gt;脏读意味着我在这个事务中(A中)，事务B虽然没有提交，但它任何一条数据变化我 都可以看到！| 2 | 2 || 3 | 3 |+------+------+ 2.读取提交内容(Read Committed) 它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。 但是它出现的问题是：不可重复读，不可重复读意味着我们在同一个事务中执行完全相同的select语句看到的可能是完全不一样的结果。 导致这种情况的原因有： (1)有一个交叉的事务有新的commit，导致了数据的改变 （2）一个数据库被多个实例操作时，同一个事务的其他实例在该实例处理其间有可能会有新的commit 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#首先修改隔离级别set tx_isolation=&apos;read-committed&apos;;select @@tx_isolation;+----------------+| @@tx_isolation |+----------------+| READ-COMMITTED |+----------------+#事务A：启动一个事务start transaction;select * from tx;+------+------+| id | num |+------+------+| 1 | 1 || 2 | 2 || 3 | 3 |+------+------+#事务B：也启动一个事务(那么两个事务交叉了) 在这事务中更新数据，且未提交start transaction;update tx set num=10 where id=1;select * from tx;+------+------+| id | num |+------+------+| 1 | 10 || 2 | 2 || 3 | 3 |+------+------+#事务A：这个时候我们在事务A中能看到数据的变化吗?select * from tx; ---------------&gt;+------+------+ || id | num | |+------+------+ || 1 | 1 |---&gt;并不能看到！ || 2 | 2 | || 3 | 3 | |+------+------+ |——&gt;相同的select语句，结果却不一样 |#事务B：如果提交了事务B呢? |commit; | |#事务A: |select * from tx; ---------------&gt;+------+------+| id | num |+------+------+| 1 | 10 |---&gt;因为事务B已经提交了，所以在A中我们看到了数据变化| 2 | 2 || 3 | 3 |+------+------+ 3.可重读（Repeatable Read） (1)这是MySQL的默认事务隔离级别 (2)它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行 (3)此级别可能出现的问题——幻读(Phantom Read)：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行 (4)InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#首先，更改隔离级别set tx_isolation=&apos;repeatable-read&apos;;select @@tx_isolation;+-----------------+| @@tx_isolation |+-----------------+| REPEATABLE-READ |+-----------------+#事务A：启动一个事务start transaction;select * from tx;+------+------+| id | num |+------+------+| 1 | 1 || 2 | 2 || 3 | 3 |+------+------+#事务B：开启一个新事务(那么这两个事务交叉了) 在事务B中更新数据，并提交start transaction;update tx set num=10 where id=1;select * from tx;+------+------+| id | num |+------+------+| 1 | 10 || 2 | 2 || 3 | 3 |+------+------+commit;#事务A：这时候即使事务B已经提交了,但A能不能看到数据变化？select * from tx;+------+------+| id | num |+------+------+| 1 | 1 | ---&gt;还是看不到的！(这个级别2不一样，也说明级别3解决了不可重复读问题)| 2 | 2 || 3 | 3 |+------+------+#事务A：只有当事务A也提交了，它才能够看到数据变化commit;select * from tx;+------+------+| id | num |+------+------+| 1 | 10 || 2 | 2 || 3 | 3 |+------+------+ 4.可串行化(Serializable) (1)这是最高的隔离级别 (2)它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的数据行上加上共享锁。 (3)在这个级别，可能导致大量的超时现象和锁竞争 123456789101112131415161718#首先修改隔离界别set tx_isolation=&apos;serializable&apos;;select @@tx_isolation;+----------------+| @@tx_isolation |+----------------+| SERIALIZABLE |+----------------+#事务A：开启一个新事务start transaction;#事务B：在A没有commit之前，这个交叉事务是不能更改数据的start transaction;insert tx values(&apos;4&apos;,&apos;4&apos;);ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transactionupdate tx set num=10 where id=1;ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP实战——苹果IAP支付接入]]></title>
    <url>%2F2017%2F02%2F16%2FPHP%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E8%8B%B9%E6%9E%9CIAP%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%2F</url>
    <content type="text"><![CDATA[IAP支付流程大致的业务逻辑是这样的。 向服务器请求商品订单号码以及ituns配置的商品ID 发起IAP购买请求 购买流程结束后, 向服务器发起验证凭证以及支付结果的请求 验证流程结束完成购买流程。 细化支付验证流程：首先简单说明一下整个流程, 此处以我们APP开发为例, 说明客户端进行支付, 服务器端进行验证的逻辑, 保证整个IAP支付的安全性 整个流程大体为 客户端请求商品订单 获取IAP商品id IAP商品查询 用户支付 客户端发送订单号+支付凭证到服务器 服务器验证凭证是否合法 返回结果到客户端 客户端业务逻辑处理 最近看到很多人在网上询问关于Apple应用内购的服务端验证问题，之前实现了一个PHP版本的封装，今天整理一下，记录在这里，供需要的朋友参考， 注意，这里是PHP版本，其他语言验证方式一样，请自行实现： 1、App端包含Apple应用内购的产品； 2、验证方式为服务端验证（另一种为App应用本地验证，此文不做介绍）； 使用到的类库看这里：Apple内购校验 （不要忘了给个star o(￣︶￣)o） 下面介绍一下使用方法： 创建一个名为Demo.php的文件，将以下内容拷贝至Demo.php文件中： require_once &apos;src/AppleIAP/AppleInAppPurchaseVerification.php&apos;; use AppleIAP\AppleInAppPurchaseVerification; //apple返回的支付参数 receipt-data $receiptData = &apos;MIXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&apos;; //如果产品类型为订阅型的，请使用校验需要的密码；如果不是订阅型的产品，请将其置为空字符串 $password = &apos;baXXXXXXXXXXXXXXXXXXXXXXXXX&apos;; $appleIAP = newAppleInAppPurchaseVerification($receiptData,$password,true); $result = $appleIAP-&gt;validateReceipt(); echo $result; 结果输出说明： A、校验通过：会得到一个json数据，包含购买产品的详细信息； B、校验失败：会得到一个错误代码。 PHP实战代码 &lt;?php //* 随着苹果系统越来越强大，有种马上要开始胡来的节奏，个人认为强制添加内购就是其中之一，虽然很多人都特别鄙视这种行为，然并卵。 //* 具体的官方给出的验证规则，大家可以详细阅读看看：http://zengwu3915.blog.163.com/blog/static/2783489720137605156966/?suggestedreading //* apple官方提供的文档地址：https://developer.apple.com/library/prerelease/ios/releasenotes/General/ValidateAppStoreReceipt/Chapters/ValidateRemotely.html $apple_receipt = $this-&gt;_post(&apos;apple_receipt&apos;); //苹果内购的验证收据,由客户端传过来 $jsonData = array(&apos;receipt-data&apos;=&gt;$apple_receipt);//这里本来是需要base64加密的，我这里没有加密的原因是客户端返回服务器端之前，已经作加密处理 $jsonData = json_encode($jsonData); //$url = &apos;https://buy.itunes.apple.com/verifyReceipt&apos;; 正式验证地址 //$url = &apos;https://sandbox.itunes.apple.com/verifyReceipt&apos;; //测试验证地址 $response = http_post_data($url,$jsonData); if($response-&gt;{&apos;status&apos;} == 0){ echo &apos;验证成功&apos;; }else{ echo &apos;验证失败&apos;.$response-&gt;{&apos;status&apos;}; } //curl请求苹果app_store验证地址 function http_post_data($url, $data_string) { $curl_handle=curl_init(); curl_setopt($curl_handle,CURLOPT_URL, $url); curl_setopt($curl_handle,CURLOPT_RETURNTRANSFER, true); curl_setopt($curl_handle,CURLOPT_HEADER, 0); curl_setopt($curl_handle,CURLOPT_POST, true); curl_setopt($curl_handle,CURLOPT_POSTFIELDS, $data_string); curl_setopt($curl_handle,CURLOPT_SSL_VERIFYHOST, 0); curl_setopt($curl_handle,CURLOPT_SSL_VERIFYPEER, 0); $response_json =curl_exec($curl_handle); $response =json_decode($response_json); curl_close($curl_handle); return $response; } ?&gt;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基本操作汇总]]></title>
    <url>%2F2017%2F02%2F15%2FMySQL%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[数据类型 对于整型来说TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT等 指定长度是没有意义的，它不会限制值的范围，只会影响显示字符的个数，比如int(10) 如果不足十位的会补足0（通过zerofill属性来显示）。值得注意的是，如果字符少于位数则会补足0，如果超过了宽度则不受影响。 对于实数类型来说FLOAT（四个字节）、DOUBLE（八个字节）、DECIMAL（可以存储比BIGINT还要大的整型，可以存储精确的小数，16字节，精度较高的运算一般用decimal） 字符串类型VARCHAR、CHAR、TEXT、BLOB char的长度是固定的，最大为255个字符，而char的最大长度是255每个字符占用的字节数，比如utf8编码就是255\3,gbk就是255*2 varchar代表变长，最大的长度为65535个字节，如果采用varchar的话需要用1-2个字节来存储长度信息（255个字节一下需要1个字节，超过255需要两个字节）。而varchar最大字符数也是根据编码来决定（注意：char和varchar后面跟的数字都是指字符数），如果是utf8编码，varchar最大字符数=65535/3约为21845个字符，如果是gbkvarchar最大字符数=65533/2约为32766个字符 text和blob类型查询的时候会产生临时表，尽量不要使用 日期和时间类型（尽量使用TIMESTAMP，比DATETIME空间效率高） 常用命令 veresion(); //显示当前服务版本 now(); //显示当前时间 user(); //显示当前用户 concat(‘a’, ‘b’); //字符链接 concat_ws(‘-‘, ‘a’, ‘b’); //使用指定分隔符连接 lower(‘MYSQL’) upper(‘mysql’) //大小写转换 left(‘mysql’, 2) //左截取 right(‘mysql’, 2) //右截取 length(‘mysql’) //获取字符串长度 replace(‘-my-sql’, ‘-‘, ‘+’) //替换字符 substring(‘mysql’, 1 ,2) //截取字符 date_format(‘2017-9-11’, ‘%Y-%m-%d’); //日期格式化 avg(); //平均值 count(); //总数 max(); min() //最大值，最小值 sum(); //求和 常用数据库操作1.创建数据库12create &#123;database|schema&#125; [if not exists] db_name [default] character set [=] charset_name例：CREATE DATABASE test; 2.修改数据库12alter &#123;database|schema&#125; db_name [default] character set [=] charset_name例：ALTER DATABASE test CHARACTER SET utf8; 3.删除数据库12drop &#123;database|schema&#125; [if exists] db_name例：DROP DATABASE test; 常用数据表操作1.创建表1234567891011create table [if not exists] tbl_name( age tinyint(2) unsigned not null auto_increment primary key);例：CREATE TABLE user( id INT(10) UNSIGNED AUTO_INCREMENT PRIMARY KEY,//主键自增 name VARCHAR(20) NOT NULL UNIQUE KEY,//唯一 price DECIMAL(8,2) UNSIGNED DEFAULT 0.00,//默认 cid INT(10) UNSIGNED, KEY cid(cid), FOREIGN KEY (cid) REFERENCES cate (id) ON DELETE CASCADE//外键 （删除时执行CASCADE）) ENGINE=InnoDB DEFAULT CHARSET=utf8; 2.查看表结构12show colums from tbl_name;例：SHOW COLUMUNS FROM user 3. 修改表结构1234alter table tbl_name op[add|drop|modify] [column] (col_name column_definition,..);例：ALTER TABLE user ADD num INT(10) UNSIGNED, time INT(10) UNSIGNED; // 添加字段ALTER TABLE user DROP num,DROP time; // 删除字段 4.插入12（1）insert [into] tbl_name [(col_name,..)] &#123;values|value&#125; (&#123;expr|default&#125;,...),(...),...;例：INSERT user (id,name,price) VALUES (DEFAULT,tom&apos;,20); 5.更新12update tbl_name set col_name1=&#123;expr1|default&#125; [,col_name2=&#123;expr2|default&#125;].. [where where_condition]例：UPDATE user SET num = num + id; 6.删除12delete from tbl_name [where where_condition]例：DELETE FROM user WHERE id=3; 约束性(1)主键约束：primary key 每个表只存在一个 保证记录的唯一性 自动为not null 添加了主键约束 (2)唯一约束： unique key 每个表可以存在多个 保证记录的唯一性 可以存一个null 添加了唯一约束 (3)默认约束：default 给列添加了默认值 123例如：ALTER TABLE user ALTER num SET DEFAULT 0;ALTER TABLE user ALTER num DROP DEFAULT; (4)非空约束(5)外键约束 保证了数据的一致性，实现了1对1,1对多的关系 cascade：从父表中删除或更新且自动删除或更新子表中的匹配行 set nul： 从父表删除或更新并设置子表中的外键列为null。如果使用该选项，必须保证子表没有指定not null restrict：拒绝对父表的删除或更新操作 123456添加外键约束： alter table tbl_name add [constraint [symbol]] foreign key [index_name] (index_col_name,...) reference_definition 例：ALTER TABLE user ADD FOREIGN KEY (cid) REFERENCES cate (id) 删除外键约束： alter table tbl_name drop foreign key symbol 例：ALTER TABLE user DROP FOREIGN KEY cid; 子查询 嵌套在内部，始终出现在括号内; 可以包含多个关键字或条件，如distinct，group by，order by，limit，函数等;外层可以是：select，insert，update，set 1.比较运算符:=,&gt;,&lt;,&lt;=,&gt;=,&lt;&gt;123select * from t1 where col_name1 &gt;= ANY (select col_name2 from t2);(1)any:符合任意一个(2)all:符合所有 2.（not）in/exists1select * from t1 where col_name1 NOT IN ALL (select col_name2 from t2); 连接查询内连接（inner join），左连接（left join）， 右连接（right join）,全连接（full join）， 交叉连接（across join）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788现有两张表A、B表Aid name 1 张2 李3 王表Bid address A_id1 北京 12 上海 33 南京 10**************left join**********SELECT A.name, B.addressFROM ALEFT JOIN B ON A.id = B.A_id 结果是：name address张 北京李 NULL王 上海可以看到A表（左边的表）的所有行都显示出来了，B表中没有匹配到的行是NULL值************right join***********SELECT A.name, B.addressFROM ARIGHT JOIN B ON A.id = B.A_id结果是：name address张 北京王 上海NULL 南京与left join相反，B表（右边的表）中的行全显示出来，A表中匹配不到的行显示NULL**********inner join************select A.name,B.address from A inner join Bon A.id = B.A_id结果是：name address张 北京王 上海内连接等价于：SELECT A.name, B.addressFROM A, BWHERE A.id = B.A_id内连接只返回A、B两表都有的行，相当于A、B的交集*********full join**********全外连接返回参与连接的两个数据集合中的全部数据，无论它们是否具有与之相匹配的行。在功能上，它等价于对这两个数据集合分别进行左外连接和右外连接，然后再使用消去重复行的并操作将上述两个结果集合并为一个结果集select * from A full join B结果是：id name id address A_id1 张 1 北京 12 李 1 北京 13 王 1 北京 11 张 2 上海 32 李 2 上海 33 王 2 上海 31 张 3 南京 102 李 3 南京 103 王 3 南京 10*********across join***********返回笛卡尔积，A*BSELECT * FROM ACROSS JOIN B结果是：id name id address A_id1 张 1 北京 12 李 1 北京 13 王 1 北京 11 张 2 上海 32 李 2 上海 33 王 2 上海 31 张 3 南京 102 李 3 南京 103 王 3 南京 10等价于sql：select * from A,B 联合查询（union与union all） 把多个结果集集中在一起]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx基本使用笔记]]></title>
    <url>%2F2017%2F01%2F04%2FNginx%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.常见操作`nginx -s signal` signal的值可以是： stop 快速关机 quit 正常关机 reload 重新加载配置文件 reopen 重新打开日志文件 2.配置文件nginx是由模块组成的，这些模块在配置文件中又有指定的指令。 指令被分成简单指令和块指令。简单指令包括名称和用空格分割的参数以及用来结尾的分号(;)。 一个块指令和简单指令有相同的结构，但是它使用大括号({and})来包围一系列说明来替代使用分号作为结尾。 放在配置文件最外面的指令的称之为主文，event,http指令在主文中；server在http中， location在server中。 3.静态服务Web服务器一个重要的任务就是提供文件（如图像或者静态html页面）。 根据需求，你将实现一个例子，文件被本地不同的目录服务着，如/data/www 包含html文件，/data/images 包含图片。这需要编辑配置文件，在http块中设置server块。 首先，创建/data/www 目录并放置index.html文件（文件中可以是任意内容）。 然后创建/data/images目录并放置一些图片。 接下来，打开配置文件。默认的配置文件已经包含了几个server块的例子，大多数都被注释掉了。 现在注释掉所有的块，并开始一个新的server块。 1234http &#123; server &#123; &#125;&#125; 一般情况下，配置文件中包含多个server块，它们之间以监听的端口号和server name来区分。 一旦nginx决定了哪个server处理请求，它测试在请求的对server块内定义的位置指令的参数头中指定的URI。 添加location到server中123location / &#123; root /data/www;&#125; 与请求的URI相比，location块指定了“/”前缀。为了匹配请求，该URI会被添加到root指令指定的路径中， 即，到/data/www，在本地文件系统中组成请求文件的路径。如果有多个匹配的location块，nginx会选择前缀最长的。 上面的location块提供了最短的前缀，如果其他的location块匹配失败，这个location块就会被使用。 现在来添加第二个location:123location /images/ &#123; root /data;&#125; 它与带/images/的请求请求匹配。（location / ，当然也匹配，除非有更短的前缀。） #####现在server中是这样的： 12345678server &#123; location / &#123; root /data/www; &#125; location /images/ &#123; root /data; &#125;&#125; 重启配置文件，让配置生效 nginx -s reload 这已经是一个可以工作的服务器配置文件，它监听的是80端口，可在本地通过http://localhost/访问。 响应带/images/的URI路由请求时，服务器将会从/data/images目录发送文件。 例如，响应 http://localhost/images/example.png 路由请求，nginx将会发送/data/images/example.png 文件。如果这个文件不存在，nginx将会发出404错误的响应。不带/images/的URIs请求将会映射到/data/www目录。 例如，为了响应http://localhost/some/example.html请求，nginx将会发送/data/www/some/example.html文件。 3.代理服务器服务器A接受到请求后，将请求转发给其他的服务器B，从服务器B处获得响应，并将取得的相应返回给客户端，服务器B则是服务器A的代理服务器 首先，我们新增一个server 123456server &#123; listen 8080; root /data/up1; location / &#123; &#125;&#125; 这是一个简单的server块，监听8080端口（此前，listen指令没有被提起是由于已经使用了标准的80端口），并将所有的请求 映射到本地文件系统的/data/up1目录。创建这个目录，并将index.html文件放置其中。注意root指令已经被放置在server环境中。 当location块被选中服务请求时，root指令就会被使用，当然不包括自己的root指令。 修改第一个location块，放置proxy_pass指令与协议、名称和参数中指定的代理服务器端口 12345678server &#123; location / &#123; proxy_pass http://localhost:8080; &#125; location /images/ &#123; root /data; &#125;&#125; 修改第二个location块，它目前映射所有带/images/前缀的请求到/data/images 目录下的文件，是为了使其符合典型的文件扩展的图像请求 123location ~ \.(gif|jpg|png)$ &#123; root /data/images;&#125; 该参数是一个正则表达式，匹配所有.gif,.jpg,.png 结尾的路由。正则表达式应该优于～。相应的请求都会被映射到 /data/images目录。 当nginx选择一个location块服务一个请求时，它首先检查location指令的指定前缀，记住location最长的前缀， 然后检查正则表达式。如果有一个匹配的正则表达式，nginx会挑选location块，否则它会选择之前的。因此代理服务器的配置文件应该是这样的: 12345678server &#123; location / &#123; proxy_pass http://localhost:8080/; &#125; location ~ \.(gif|jpg|png)$ &#123; root /data/images; &#125;&#125; 此服务器会筛选出以.gif,.jpg,.png 结尾的请求，并将他们映射到/data/images目录下(通过添加URI到root指令的参数上)， 然后通过所有其它请求到代理服务器配置上 `nginx -s reload` 重启配置使更改生效 4. FastCGI代理nginx可用于路由请求FastCGI服务器，FastCGI服务器运行各种不同的框架和编程语言，如PHP，建立的应用。 最常用与 FastCGI server工作的nginx配置，用fastcgi_pass指令替代了proxy_pass指令，并设置fastcgi_param 参数传递给FastCGI server。 假设FastCGI server通过localhost:9000可以访问。 以上一节代理配置作为基础，用fastcgi_pass指令替换proxy_pass指令，并修改参数为localhost:9000。在PHP中， SCRIPT_FILENAME参数用来确定脚本名，QUERY_STRING参数用来传递请求参数。 12345678910server &#123; location / &#123; fastcgi_pass localhost:9000; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param QUERY_STRING $query_string; &#125; location ~ \.(gif|jpg|png)$ &#123; root /data/images; &#125;&#125; nginx与PHP通信首先我们先简单的看一份nginx server 12345678910111213server &#123; listen 80 default_server; index index.php; root /home/work/ location ~[^/]\.php(/l$) &#123; fastcgi_pass unix:/tmp/php-cgi.sock; fastcgi_index index.php; include fastcgi.conf; &#125; access_log /home/work/logs/default.log;&#125; CGI是通用网关协议，FastCGI则是一种常住进程的CGI模式程序。我们所熟知的PHP-FPM会通过用户配置来管理一批FastCGI进程，例如在PHP-FPM管理下的某个FastCGI进程挂了，PHP-FPM会根据用户配置来看是否要重启补全，PHP-FPM更像是管理器，而真正衔接Nginx与PHP的则是FastCGI进程。 我们可以看到server中包含了fastcgi.conf，里面是一些fastcgi_param的配置项，如下： 123456789101112131415161718192021222324fastcgi_param QUERY_STRING $query_string;fastcgi_param REQUEST_METHOD $request_method;fastcgi_param CONTENT_TYPE $content_type;fastcgi_param CONTENT_LENGTH $content_length;fastcgi_param SCRIPT_NAME $fastcgi_script_name;fastcgi_param REQUEST_URI $request_uri;fastcgi_param DOCUMENT_URI $document_uri;fastcgi_param DOCUMENT_ROOT $document_root;fastcgi_param SERVER_PROTOCOL $server_protocol;fastcgi_param HTTPS $https if_not_empty;fastcgi_param GATEWAY_INTERFACE CGI/1.1;fastcgi_param SERVER_SOFTWARE nginx/$nginx_version;fastcgi_param REMOTE_ADDR $remote_addr;fastcgi_param REMOTE_PORT $remote_port;fastcgi_param SERVER_ADDR $server_addr;fastcgi_param SERVER_PORT $server_port;fastcgi_param SERVER_NAME $server_name;# PHP only, required if PHP was built with --enable-force-cgi-redirectfastcgi_param REDIRECT_STATUS 200;fastcgi_param PHP_VALUE &quot;open_basedir=$document_root:/usr/share/pear:/usr/share/php:/etc/phpMyAdmin:/tmp:/proc&quot;; fastcig_param中所声明的内容会传到php-fpm（或者其他fast-cgi server）所管理的fast-cgi进程。我们可以看到，fastcgi_param中都是一些服务器的信息，如remote_addr(访问用户的ip)等，他就可以把这些信息传递给后端程序，如PHP的$_SERVER]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一步一步教你如何写开发文档]]></title>
    <url>%2F2017%2F01%2F02%2F%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E5%86%99%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[你有没有遇到过，突然老板或者老大跟你说，你根据项目或者根据功能写一份开发文档，当时很开心的答应了，后来想想，既然懵了。 开发文档是什么鬼？写了这么多年代码都没写过什么开发文档，最多也就只是产品的需求文档，说明文档，代码的注释与规范文档，或者说过苹果的开发文档，因为之前刚好写过一次很简单的，最近公司又开始要写上面开发文档了，而且发现确实很多同学都不会，我在想，我是不是该做点什么……。 前言App开发过程中的文档分为很多种，比如最常见的就是官方的开发文档，这种比较倾向代码和接口，但是你可能还见过或者听过其他文档。 比如，这里根据个人理解整理了几个。 开发文档 需求(原型)文档 需求(说明)文档 技术方案文档 Bug修复文档 注释文档 代码与UI规范文档 性能优化文档 是不是有点晕了，哪有这么多鬼，其实按照之前的习惯，我都是一份开发文档就够了，基本上包含上面的东西，只是看你怎么细分。 开发文档概述实际开发中如果真的遇到要写上面开发文档可以从下面几个角度写。 一. 开发环境及工具 二. 项目或功能（需求）描述（最好有流程图或者UML）- 需求文档 三. 编写目的（用户特征和水平） 四. 项目或功能背景 五. 模块与关系 六. 类或术语说明 七. 参考资料（网络或公司内部资料，UI，原型，说明文档） 八. 项目进度预估 九. 难点预估（条件与限制） 十. 功能与所计划采用的技术 - 技术方案文档 十一. 用户界面与交互 十二. 软件（代码）接口 - 注释文档 十三. 通信（网络）接口 - 接口文档 十四. 问题与修复说明 - Bug修复文档 十五. 性能分析与优化 当然也不是说这些全部要写，可以根据项目或者功能适当编写。 下面大概一个个的说明一些每一个步骤是什么意思，需要怎么写，这里主要以iOS开发中App开发文档为规范，并使用苹果最新的语言Swift作为唯一语言。 一. 开发环境及工具 Mac OX 10 iPhone或者iPad 5+ 2+ 必须真机 iOS 8+ Xcode 8+ 其他工具：Tower，cornerstone 主要指明开发在工具，开发平台，开发版本的支持。描述软件的运行环境，包括硬件平台、硬件要求、操作系统和版本，以及其他的软 件或与其共存的应用程序等。 二. 项目或功能（需求）描述（最好有流程图或者UML）- 需求文档 顶层数据流图； 用例UseCase图； 系统流程图； 层次方框图。 主要根据产品给出的需求结合原型进行描述，并适当给出相应的图。 三. 编写目的（用户特征和水平） 描述最终用户应具有的受教育水平、工作经验及技术专长。 次软件或者功能编写的目的，对项目，对用户，对公司有什么好处。 四. 项目或功能背景 标识待开发软件产品的名称、代码； 列出本项目的任务提出者、项目负责人、系统分析员、系统设计员、程序设计员、程序员、资料员以及与本项目开展工作直接有关的人员和用户； 说明该软件产品与其他有关软件产品的相互关系。 此项目或功能编写之前市面上的情况，公司和用户的情况 五. 模块与关系 项目或功能对应模块在位置，入口，和其他模块的关系 六. 类或术语说明 项目或功能对应类的说明，和开发中使用到的一些相关的术语的说明 七. 参考资料（网络或公司内部资料，UI，原型，说明文档） 列举编写软件需求规格说明时所参考的资料，包括项目经核准的计划任务书、合同、引用的标准和规范、项目开发计划、需求规格说明、使用实例文档，以及相关产品的软件需求规格说明。 在这里应该给出详细的信息，包括标题、作者、版本号、发表日期、出版单位或资料来源。 网络资料，尤其是苹果的，也可以群里或者博客，文章等。公司内部的UI，原型，说明，网络接口资料 八. 项目进度预估 预计从上面开始到指定的时间节点完成任务或者完成对应的部分 九. 难点预估（条件与限制） 其中考虑到或者可能会遇到什么技术或者实现难点 十. 功能与所计划采用的技术 - 技术方案文档 将要采用的图形用户界面标准或产品系列的风格； 屏幕布局； 菜单布局； 输入输出格式； 错误信息显示格式； 建议采用RAD开发工具， 比如Visio，构造用户界面。 根据项目或者功能需求，在代码层面所使用的技术或者实现方案，或者比如说ios中布局方式的使用。 十一. 用户界面与交互 根据用户界面和入口说明交互与使用步骤并 十二. 软件（代码）接口 - 注释文档 每一个方法和属性对应的注释，一般是私有的话使用private但是也要注释，公开的都会使用标准的注释说明，苹果有自带的快捷键（command+option+/），之前有个插件叫VVDocument 十三. 通信（网络）接口 - 接口文档 网络请求对应的说明包括对应的参数，字段和返回值，也可以是数据模型层对应的模型属性和方法的说明 十四. 问题与修复说明 - Bug修复文档 开发或者测试的过程中出现了什么比较重要的bug，不要什么bug都写上，然后说明解决的方案 十五. 性能分析与优化 时间特性 响应时间； 更新处理时间； 数据转换与传输时间； 运行时间等。 适应性 在操作方式、运行环境、与其他软件的接口以及开发计划等发生变化时，软件的适应能力。 到此完成之后，根据实际需求和个人能力，个人理解分析项目或者功能那些地方需要进行优化一下，打算怎么去优化他。 后期会继续完善(根据项目或功能整理一套完整的开发文档)……. 注：这里是按照功能，并不是按照整个项目分，如果要写整个项目的开发文档也可以再根据功能细分。]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP彩蛋篇——意想不到的惊喜]]></title>
    <url>%2F2016%2F12%2F24%2FPHP%E5%BD%A9%E8%9B%8B%E7%AF%87%E2%80%94%E2%80%94%E6%84%8F%E6%83%B3%E4%B8%8D%E5%88%B0%E7%9A%84%E6%83%8A%E5%96%9C%2F</url>
    <content type="text"><![CDATA[前几天，听一个前辈说到，关于PHP中彩蛋的概念，顿时不知所云。作为漫威终极粉的我，彩蛋的概念，深深的植入已经在我脑子里。 但是PHP彩蛋我也是第一次听说，也问了几个近几年刚做PHP的朋友，都没有听过，估计只有老一辈的程序员们都知道。 彩蛋指电影中不仔细寻觅，会被忽略的有趣细节；还有就是影片剧情结束后，在演职员表滚屏时或之后出现的电影片段（通常是一些幽默场景或是跟续集有关的情节线索）。 在PHP中彩蛋，我们把它认为是：惊喜。就是只要在运行PHP的服务器上，在域名后面输入下面的字符参数，就能返回一些意想不到的信息(有些服务器屏蔽)。 PHP中4个彩蛋 ?=PHPB8B5F2A0-3C92-11d3-A3A9-4C7B08C10000 (PHP信息/贡献者列表) ?=PHPE9568F34-D428-11d2-A769-00AA001ACF42 (PHP的LOGO) ?=PHPE9568F35-D428-11d2-A769-00AA001ACF42 (Zend LOGO) ?=PHPE9568F36-D428-11d2-A769-00AA001ACF42 (PHP LOGO 蓝色大象) 配置好PHP解析服务器之后，写一个PHP程序如下： 123&lt;?phpinfo();?&gt; 访问的时候index.php，然后拼接上面的参数，如下 www.icocos.cn/index.php?=PHPB8B5F2A0-3C92-11d3-A3A9-4C7B08C10000 www.icocos.cn/index.php?=PHPE9568F34-D428-11d2-A769-00AA001ACF42 www.icocos.cn/index.php?=PHPE9568F35-D428-11d2-A769-00AA001ACF42 www.icocos.cn/index.php?=PHPE9568F36-D428-11d2-A769-00AA001ACF42 就可以看到，如下参数的信息了。 如果你在博客或者网站上也发现了这个问题，不用马上去解决他。这不算是漏洞。只是开源团队开的一个玩笑，全世界的人都认可了的玩笑，所以他并不是PHP的漏洞。 当然，也有部分奇葩的人，会借助这个彩蛋去做一些事情，比如： 有些网站采用动态脚本生成纯静态HTML页或者是采用URL重写实现伪静态页面，如果网站使用的是PHP开发的话，可以尝试使用彩蛋的探测法，然后根据特有的技术，去做一些破坏或者攻击！ 解决办法可以通过apache或者nginx的配置文件去屏蔽。 默认情况下彩蛋的功能在php.ini中是开启的 12345678910;;;;;;;;;;;;;;;;;; Miscellaneous ;;;;;;;;;;;;;;;;;;; Decides whether PHP may expose the fact that it is installed on the server; (e.g. by adding its signature to the Web server header). It is no security; threat in any way, but it makes it possible to determine whether you use PHP; on your server or not.; http://php.net/expose-phpexpose_php = On //暴露 只要将expose_php设置为Off即可！ expose_php = Off 也可以通过设置.htaccess来进行屏蔽。 1RewriteCond %&#123;QUERY_STRING&#125; \=PHP[0-9a-f]&#123;8&#125;-[0-9a-f]&#123;4&#125;-[0-9a-f]&#123;4&#125;-[0-9a-f]&#123;4&#125;-[0-9a-f]&#123;12&#125; [NC] RewriteRule .* - [F]]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP中常用自定义函数]]></title>
    <url>%2F2016%2F12%2F22%2FPHP%E4%B8%AD%E5%B8%B8%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[目录 日期格式标准输出 UTF8字符串加密 UTF8字符串解密 获取某张表的字段 换行输出（一般用于调试 eg：在循环中输出） 常用表单类型 根据下标获取字段类型（常用且可配置） 网站菜单列表（这里只是例子） 读取base64编码后的图片并保存到path（实测可用） 验证手机号是否正确（常规） 查询当前数据库所有的表名 获取项目根路径 验证邮箱格式（常规） 删除目录下的文件：权限不足可能导致失败 记录日志文本到.txt文件-日志文件可即时删除 二维对象数组转换为二维数组 将XML字符串转为array 产生一个订单号 输出xml字符 返回xml 对象 XML编码 数据XML编码 设置结果（常用于异步请求返回格式） curl请求（整理于微信） 生成随机字符串 php二维数组排序(升、降) 日期换算为 今天 昨天 2天前 一周前 一个月前 一年前 返回由二维数组的其中两个字段(键)组成的一维数组 查找二维数组中某一条数据 查询数据，返回这个字段的列 replace_unicode_escape_sequenc 中文被unicode编码后了的数据，解码出中文 Unicode解 unicode编码 持续更新….. 日期格式标准输出&lt;?php use service\DataService; use service\NodeService; use think\Db; /** * 日期格式标准输出 * @param string $datetime 输入日期 * @param string $format 输出格式 * @return false|string */ function format_datetime($datetime, $format = &apos;Y年m月d日 H:i:s&apos;) { return date($format, strtotime($datetime)); } UTF8字符串加密/** * UTF8字符串加密 * @param string $string * @return string */ function encode($string) { list($chars, $length) = [&apos;&apos;, strlen($string = iconv(&apos;utf-8&apos;, &apos;gbk&apos;, $string))]; for ($i = 0; $i &lt; $length; $i++) { $chars .= str_pad(base_convert(ord($string[$i]), 10, 36), 2, 0, 0); } return $chars; } UTF8字符串解密/** * UTF8字符串解密 * @param string $string * @return string */ function decode($string) { $chars = &apos;&apos;; foreach (str_split($string, 2) as $char) { $chars .= chr(intval(base_convert($char, 36, 10))); } return iconv(&apos;gbk&apos;, &apos;utf-8&apos;, $chars); } 获取某张表的字段/** * description：获取某张表的字段 * author：wanghua * @param $tablename * @return array */ function getTableFieldsByName($tablename){ if(!$tablename)return []; $prefix = config(&apos;database.prefix&apos;); if($prefix &amp;&amp; false !== strpos($tablename, $prefix)) $tablename = $prefix.$tablename; return Db::table($tablename)-&gt;getTableFields(); } 换行输出（一般用于调试 eg：在循环中输出）/** * description：换行输出（一般用于调试 eg：在循环中输出） * author：wanghua */ function brEcho($msg){ echo &apos;&lt;br/&gt;&apos;; echo $msg; echo &apos;&lt;br/&gt;&apos;; } 常用表单类型/** * description：常用表单类型 1 input 2 select 3 radio 4 textarea 5 textarea_editer 6 img * author：wanghua * @param string $type * @param bool|false $all * @return array|string */ function getFormType($type=&apos;&apos;, $all=false){ $arr = [&apos;&apos;,&apos;input&apos;,&apos;date&apos;,&apos;select&apos;,&apos;radio&apos;,&apos;textarea&apos;,&apos;textarea_editer&apos;, &apos;img&apos;]; if($type){ if(is_numeric($type)){ return isset($arr[$type])?$arr[$type]:$type; }else{ return $type; } } if($all){ return $arr; } return &apos;&apos;; } 根据下标获取字段类型（常用且可配置）/** * description：根据下标获取字段类型（常用且可配置） * author：wh */ function getFieldsType($type=&apos;&apos;, $all=false){ $arr = [&apos;&apos;,&apos;int&apos;,&apos;float&apos;,&apos;varchar&apos;,&apos;text&apos;,&apos;longtext&apos;]; if($type){ return empty($arr[$type])?$type:$arr[$type]; } if($all){ return $arr; } return $type; } 网站菜单列表（这里只是例子）/** * description：网站菜单列表（这里只是例子） * author：wh * @param $type 下标值 * @param string $all 返回所有 * @return array */ function getMenuType($type, $all=&apos;&apos;){ $arr = [ 1=&gt;&apos;首页&apos;, 2=&gt;&apos;关于我们&apos;, 3=&gt;&apos;课程设置&apos;, 4=&gt;&apos;招生信息&apos;, 5=&gt;&apos;师资队伍&apos;, 6=&gt;&apos;优秀学生&apos;, 7=&gt;&apos;新闻资讯&apos;, 8=&gt;&apos;联系我们&apos; ]; if($type){ return empty($arr[$type])?$type:$arr[$type]; } if($all){ return $arr; } return $type; } 读取base64编码后的图片并保存到path（实测可用）/** * description：读取base64编码后的图片并保存到path（实测可用） * author：wh * @param $base64_image_content * @param $path * @return bool|string */ function base64_image_content($base64_image_content,$path){ //匹配出图片的格式 if (preg_match(&apos;/^(data:\s*image\/(\w+);base64,)/&apos;, $base64_image_content, $result)){ $type = $result[2]; $new_file = $path.&quot;/&quot;.date(&apos;Ymd&apos;,time()).&quot;/&quot;; if(!file_exists($new_file)){ //检查是否有该文件夹，如果没有就创建，并给予最高权限 mkdir($new_file, 0777); } $new_file = $new_file.time().&quot;.{$type}&quot;; if (file_put_contents($new_file, base64_decode(str_replace($result[1], &apos;&apos;, $base64_image_content)))){ return &apos;/&apos;.$new_file; }else{ return false; } }else{ return false; } } 验证手机号是否正确（常规）/** * 验证手机号是否正确（常规） * @author wanghua */ function is_mobile($mobile) { if (!is_numeric($mobile)) { return false; } return preg_match(&apos;#^13[\d]{9}$|^14[5,7]{1}\d{8}$|^15[^4]{1}\d{8}$|^17[0,6,3,7,8]{1}\d{8}$|^18[\d]{9}$#&apos;, $mobile) ? true : false; } 查询当前数据库所有的表名/** * description：查询当前数据库所有的表名 * author：wh * @return mixed 返回表名一维数组 */ function getTables(){ return array_column(Db::query(&apos;SHOW TABLES;&apos;), &apos;Tables_in_&apos;.config(&apos;database.database&apos;)); } 获取项目根路径/** * description：获取项目根路径 * author：wanghua */ if (!function_exists(&apos;get_root_path&apos;)) { function get_root_path(){ $str = str_replace(&apos;\\&apos;, &apos;/&apos;, APP_PATH); return $str.&apos;..&apos;; } } 验证邮箱格式（常规）/** * 验证邮箱格式（常规） */ function is_email($email){ return preg_match(&quot;/([\w\-]+\@[\w\-]+\.[\w\-]+)/&quot;,$email)?true:false; } 删除目录下的文件：权限不足可能导致失败/** * description：删除目录下的文件：权限不足可能导致失败 * author：wanghua * @param $backpath * @return bool */ function deleteFile($path=&apos;&apos;){ if(!$path|| !file_exists($path))return false; $files = scandir($path); if($files){ foreach ($files as $key =&gt; $val){ if(!in_array($val, [&apos;.&apos;, &apos;..&apos;])){ unlink($path.$val); } } return true; }else{ return false; } } 记录日志文本到.txt文件-日志文件可即时删除if(!function_exists(&apos;log_to_write_txt&apos;)){ /** * 记录日志文本到.txt文件-日志文件可即时删除 * wanghua * @param string $data * @param string $filepath 默认保存路径 */ function log_to_write_txt($data = &apos;test&apos;, $filepath = &apos;/runtime/log.txt&apos;){ //IP白名单-正式运营后可开启 //$white_ips = [ // &apos;183.67.48.137&apos; //]; //if(in_array(get_client_ip(), $white_ips)){ $filepath = get_root_path().$filepath; $str = &apos;&apos;; file_put_contents($filepath, is_object($data)||is_array($data)?$str.json_encode($data).&quot;\n&quot;:$str.$data.&quot;\n&quot;, FILE_APPEND); //}else{ // file_put_contents($filepath, &apos;white_ips have not check success &apos;.&quot;\n&quot;, FILE_APPEND); //} } } 二维对象数组转换为二维数组/** * description：二维对象数组转换为二维数组 * author：wanghua */ if (!function_exists(&apos;objToArray&apos;)) { function objToArray($peoples){ $tmp = []; foreach ($peoples as $k=&gt;$v){ $tmp[$k] = is_object($v)?$v-&gt;toArray():$v; } return $tmp; } } 将XML字符串转为array//将XML字符串转为array if (!function_exists(&apos;xmlStrToArray&apos;)) { function xmlStrToArray($xml){ //禁止引用外部xml实体 libxml_disable_entity_loader(true); $values = json_decode(json_encode(simplexml_load_string($xml, &apos;SimpleXMLElement&apos;, LIBXML_NOCDATA)), true); return $values; } } 产生一个订单号/** * description：产生一个订单号 * 说明：userid一般是定长 * author：wanghua */ if (!function_exists(&apos;createOrderNo&apos;)) { function createOrderNo(){ return time().session(&apos;user.userid&apos;).rand(10000,99999); } } 输出xml字符/** * 输出xml字符 * @throws WxPayException **/ if (!function_exists(&apos;toXml&apos;)) { function toXml($data){ if(!is_array($data) || count($data) &lt;= 0){ throw new WxPayException(&quot;数组数据异常！&quot;); } $xml = &quot;&lt;xml&gt;&quot;; foreach ($data as $key=&gt;$val){ if (is_numeric($val)){ $xml.=&quot;&lt;&quot;.$key.&quot;&gt;&quot;.$val.&quot;&lt;/&quot;.$key.&quot;&gt;&quot;; }else{ $xml.=&quot;&lt;&quot;.$key.&quot;&gt;&lt;![CDATA[&quot;.$val.&quot;]]&gt;&lt;/&quot;.$key.&quot;&gt;&quot;; } } $xml.=&quot;&lt;/xml&gt;&quot;; return $xml; } } 返回xml 对象/** * description：返回xml 对象 * author：wanghua * @param bool $res * @return string */ if (!function_exists(&apos;xmlResReturn&apos;)) { function xmlResReturn($res = true){ $tmp_suc = $res?&apos;SUCCESS&apos;:&apos;FAIL&apos;; $tmp_ok = $res?&apos;OK&apos;:&apos;ERR&apos;; $xml = &quot;&lt;xml&gt; &lt;return_code&gt;&lt;![CDATA[{$tmp_suc}]]&gt;&lt;/return_code&gt; &lt;return_msg&gt;&lt;![CDATA[{$tmp_ok}]]&gt;&lt;/return_msg&gt; &lt;/xml&gt;&quot;; return simplexml_load_string($xml); } } XML编码/** * XML编码 * @param mixed $data 数据 * @param string $encoding 数据编码 * @param string $root 根节点名 * @return string */ if (!function_exists(&apos;xml_encode&apos;)) { function xml_encode($data, $encoding=&apos;utf-8&apos;, $root=&apos;xml&apos;) { $xml = &apos;&lt;?xml version=&quot;1.0&quot; encoding=&quot;&apos; . $encoding . &apos;&quot;?&gt;&apos;; $xml .= &apos;&lt;&apos; . $root . &apos;&gt;&apos;; $xml .= data_to_xml($data); $xml .= &apos;&lt;/&apos; . $root . &apos;&gt;&apos;; return $xml; } } 数据XML编码/** * 数据XML编码 * @param mixed $data 数据 * @return string */ if (!function_exists(&apos;data_to_xml&apos;)) { function data_to_xml($data) { $xml = &apos;&apos;; foreach ($data as $key =&gt; $val) { is_numeric($key) &amp;&amp; $key = &quot;item id=\&quot;$key\&quot;&quot;; $xml .= &quot;&lt;$key&gt;&quot;; $xml .= ( is_array($val) || is_object($val)) ? data_to_xml($val) : $val; list($key, ) = explode(&apos; &apos;, $key); $xml .= &quot;&lt;/$key&gt;&quot;; } return $xml; } } 设置结果（常用于异步请求返回格式）/** * description：设置结果（常用于异步请求返回格式） * author：wanghua * @param int $code * @param string $msg * @param array $data * @param bool $is_return_json 是否返回json * @return array|string */ if (!function_exists(&apos;set_res&apos;)) { function set_res($code = 0, $msg = &apos;&apos;, $data = [], $is_return_json = false){ $r = [&apos;code&apos; =&gt; $code, &apos;msg&apos; =&gt; $msg, &apos;data&apos;=&gt;$data]; return $is_return_json?json_encode($r):$r; } } curl请求（整理于微信）/** * description：curl请求（整理于微信） * author：wanghua * @param $url * @return mixed */ if (!function_exists(&apos;req_url&apos;)) { function req_url($url){ //初始化curl $ch = curl_init(); //设置超时 curl_setopt($ch, CURLOPT_TIMEOUT, 180);//$this-&gt;curl_timeout curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER,FALSE); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST,FALSE); curl_setopt($ch, CURLOPT_HEADER, FALSE); curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE); //使用代理抓取内容 //if(\Config::CURL_PROXY_HOST != &quot;0.0.0.0&quot; // &amp;&amp; \Config::CURL_PROXY_PORT != 0){ // curl_setopt($ch,CURLOPT_PROXY, &apos;0.0.0.0&apos;); // curl_setopt($ch,CURLOPT_PROXYPORT, 0); //} //运行curl，结果以jason形式返回 $res = curl_exec($ch); curl_close($ch); //取出openid return json_decode($res,true); } } 生成随机字符串if (!function_exists(&apos;rand_str&apos;)) { /** * 生成随机字符串 * @param int $length 生成长度 * @param int $type 生成类型：0-小写字母+数字，1-小写字母，2-大写字母， * 3-数字，4-小写+大写字母，5-小写+大写+数字 * @return string */ function rand_str($length = 8, $type = 0) { $a = &apos;abcdefghijklmnopqrstuvwxyz&apos;; $A = &apos;ABCDEFGHIJKLMNOPQRSTUVWXYZ&apos;; $n = &apos;0123456789&apos;; switch ($type) { case 1: $chars = $a; break; case 2: $chars = $A; break; case 3: $chars = $n; break; case 4: $chars = $a.$A; break; case 5: $chars = $a.$A.$n; break; default: $chars = $a.$n; } $str = &apos;&apos;; for ($i = 0; $i &lt; $length; $i++) { $str .= $chars[ mt_rand(0, strlen($chars) - 1) ]; } return $str; } } php二维数组排序(升、降)if(!function_exists(&apos;arrArrToSort&apos;)){ /** * description：php二维数组排序(升、降) * author：wanghua * @param $data 数据源(必须是二维数组) * @param $field 要排序的字段(必须) eg：年龄或者价格 * @param bool $sort 排序方式 * @param bool $unique_field 指定唯一字段 eg：例如userID一般都是唯一的 * @return array 返回排序后的数据源 */ function arrArrToSort($data, $field, $sort=true, $unique_field){ //取出排序源 $field_arr_key = array_column($data, $unique_field); $field_arr_val = array_column($data, $field); $source_arr = []; foreach ($field_arr_key as $key=&gt;$val){ $source_arr[$val] = $field_arr_val[$key]; } //排序 if($sort)arsort($source_arr); else asort($source_arr) ; //重组数据 $new_arr = []; foreach ($source_arr as $k=&gt;$v){ foreach ($data as $a=&gt;$b){ if($k == $b[$unique_field]){ array_push($new_arr, $b); } } } return $new_arr; } } 日期换算为 今天 昨天 2天前 一周前 一个月前 一年前if(!function_exists(&apos;returnDateString&apos;)){ /** * description：日期换算为 今天 昨天 2天前 一周前 一个月前 一年前 * author：wanghua * @param $date 时间戳 */ function returnDateString($date){ $date = $date*1; $arr = [ 0=&gt;&apos;今天&apos;, 1=&gt;&apos;昨天&apos;, 2=&gt;&apos;前天&apos;, 7=&gt;&apos;一周前&apos;, 30=&gt;&apos;一个月前&apos;, 365=&gt;&apos;一年前&apos;, -1=&gt;&apos;很久以前&apos;, ]; //今天 $today = strtotime(date(&apos;Y-m-d&apos;)); if(($date-$today)&gt;=0){ return $arr[0]; }else if(($date-$today)&lt;0 &amp;&amp; ($today-$date)&lt;=86400){ return $arr[1]; }else if(($date-$today)&lt;0 &amp;&amp; ($today-$date)&lt;=86400*2){ return $arr[2]; }else if(($date-$today)&lt;0 &amp;&amp; ($today-$date)&lt;=86400*7){ return $arr[7]; }else if(($date-$today)&lt;0 &amp;&amp; ($today-$date)&lt;=86400*30){ return $arr[30]; }else if(($date-$today)&lt;0 &amp;&amp; ($today-$date)&lt;=86400*365){ return $arr[365]; } return $arr[-1]; } } 返回由二维数组的其中两个字段(键)组成的一维数组if(!function_exists(&apos;keyValByArrArr&apos;)){ /** * description：返回由二维数组的其中两个字段(键)组成的一维数组 * author：wanghua */ function keyValByArrArr($data, $key, $key2){ $data = objToArray($data); $arr = array_column($data, $key); $arr2 = array_column($data, $key2); $tmp = []; foreach ($arr as $k=&gt;$v){ $tmp[$v]=$arr2[$k]; } return $tmp; } } 查找二维数组中某一条数据if(!function_exists(&apos;returnArrSomeOne&apos;)){ /** * description：查找二维数组中某一条数据 * author：wanghua */ function returnArrSomeOne($data, $field, $val){ foreach ($data as $k=&gt;$v){ if($v[$field] == $val){ return $v; } } return false; } } 查询数据，返回这个字段的列if(!function_exists(&apos;getTabFieldByCon&apos;)){ /** * description：查询数据，返回这个字段的列 * author：wanghua * @param $table * @param $field */ function getTabFieldByCon($table, $field, $condition=[]){ if($condition) { $d = Db::table($table)-&gt;field($field)-&gt;where($condition)-&gt;find(); return $d[$field]; } else { $d = Db::table($table)-&gt;field($field)-&gt;select(); return array_column($d, $field); } } } replace_unicode_escape_sequencif(!function_exists(&apos;replace_unicode_escape_sequence&apos;)){ /** * description： 调用 $name = &apos;\u65b0\u6d6a\u5fae\u535a&apos;; $data = unicodeDecode($name); //输出新浪微博 * author：wanghua * @param $match * @return string */ function replace_unicode_escape_sequence($match) { return mb_convert_encoding(pack(&apos;H*&apos;, $match[1]), &apos;UTF-8&apos;, &apos;UCS-2BE&apos;); } } 中文被unicode编码后了的数据，解码出中文 Unicode解if(!function_exists(&apos;unicodeDecode&apos;)){ /** * description：中文被unicode编码后了的数据，解码出中文 Unicode解码 * author：wanghua * @param $data * @return null|string|string[] */ function unicodeDecode($data){ $rs = preg_replace_callback(&apos;/\\\\u([0-9a-f]{4})/i&apos;, &apos;replace_unicode_escape_sequence&apos;, $data); return $rs; } } unicode编码if(!function_exists(&apos;unicodeEncode&apos;)){ /** * description：unicode编码 * author：wanghua * @param $str * @return string */ function unicodeEncode($str){ //split word preg_match_all(&apos;/./u&apos;,$str,$matches); $unicodeStr = &quot;&quot;; foreach($matches[0] as $m){ //拼接 $unicodeStr .= &quot;&amp;#&quot;.base_convert(bin2hex(iconv(&apos;UTF-8&apos;,&quot;UCS-4&quot;,$m)),16,10); } return $unicodeStr; } }]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tp5安全篇入门]]></title>
    <url>%2F2016%2F12%2F13%2FTp5%E5%AE%89%E5%85%A8%E7%AF%87%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[输入安全设置public目录为唯一对外访问目录，不能把资源文件放入到应用目录； 使用框架提供的请求变量获取方法（Request类的param方法及input助手函数）而不是原生系统变量获取用户输入的数据； 使用验证类或者验证方法对业务数据设置必要的验证规则； 设置安全过滤函数对用户输入的数据进行过滤处理。 htmlspecialchars()此函数是将用户输入的所有信息原样输出。 避免用户输入的html，js等代码被浏览器解析影响服务器原来的功能，有效避免黑客攻击。 strip_tags() 函数默认删除字符串中所有html标签，也可以指定删除部分html标签。 &lt;?php $str = &quot;&lt;font color=&apos;red&apos; size=7&gt;Linux&lt;/font&gt; &lt;i&gt;Apache&lt;/i&gt; &lt;u&gt;Mysql&lt;/u&gt; &lt;b&gt;PHP&lt;/b&gt;&quot;; echo strip_tags($str); //删除了全部HTML标签，输出：Linux Apache Mysql PHP echo strip_tags($str,&quot;&lt;font&gt;&quot;); //输出&lt;font color=&apos;red&apos; size=7&gt;Linux&lt;/font&gt;Apache Mysql PHP echo strip_tags($str,&quot;&lt;b&gt;&lt;u&gt;&lt;i&gt;&quot;); //输出Linux &lt;i&gt;Apache&lt;/i&gt; &lt;u&gt;Mysql&lt;/u&gt; &lt;b&gt;PHP&lt;/b&gt; ?&gt; 数据库安全尽量少使用字符串查询条件，如果不得以的情况下，使用手动参数绑定参数； 不要让用户输入决定要查询或者写入的字段； 对于敏感数据在输出的时候使用hidden方法进行隐藏； 对于数据的写入操作应当做好权限检查工作； 写入数据严格使用field方法限制写入字段； 对于需要输出到页面的数据做好必要的XSS过滤。 注：XSS（Cross Site Scripting）跨站脚本攻击，一种常见的web攻击手段，与SQL注入类似。黑客通过在插入恶意脚本，实现对用户浏览器的控制。 上传安全主要指对上传的文件进行安全性验证。系统的think\file提供了文件上传的安全支持，包括对文件后缀、文件类型、文件大小及上传图片文件的合法性检查，确保你已经在上传操作中启用了这些合法性检查。 其他安全性建议 对所有公共的操作方法做必要的安全检查，防止用户通过URL直接调用； 不要缓存需要用户认证的页面； 对用户的上传文件，做必要的安全检查，例如上传路径和非格式； 对于项目进行充分的测试，避免业务逻辑的安全隐患； 做好服务器安全防护。 ThinkPHP框架是国内比较流行的PHP框架之一，虽然跟国外的那些个框架没法比，但优点在于，恩，中文手册很全面。最近研究SQL注入，之前用TP框架的时候因为底层提供了安全功能，在开发过程中没怎么考虑安全问题。想知道TP到底是怎么实现防SQL注入的，所以看了一些源码。结合phith0n大牛在乌云上发的漏洞，分析了一下，整理了一些思路~~ 一、不得不说的I函数TP系统提供了I函数用于输入变量的过滤。整个函数主体的意义就是获取各种格式的数据，比如I(‘get.’)、I(‘post.id’)，然后用htmlspecialchars函数（默认情况下）进行处理。如果需要采用其他的方法进行安全过滤，可以从/ThinkPHP/Conf/convention.php中设置： &apos;DEFAULT_FILTER&apos; =&gt; &apos;strip_tags&apos;, //也可以设置多种过滤方法 &apos;DEFAULT_FILTER&apos; =&gt; &apos;strip_tags,stripslashes&apos;, 从/ThinkPHP/Common/functions.php中可以找到I函数，源码如下： /** * 获取输入参数 支持过滤和默认值 * 使用方法: * &lt;code&gt; * I(&apos;id&apos;,0); 获取id参数 自动判断get或者post * I(&apos;post.name&apos;,&apos;&apos;,&apos;htmlspecialchars&apos;); 获取$_POST[&apos;name&apos;] * I(&apos;get.&apos;); 获取$_GET * &lt;/code&gt; * @param string $name 变量的名称 支持指定类型 * @param mixed $default 不存在的时候默认值 * @param mixed $filter 参数过滤方法 * @param mixed $datas 要获取的额外数据源 * @return mixed */ function I($name,$default=&apos;&apos;,$filter=null,$datas=null) { static $_PUT = null; if(strpos($name,&apos;/&apos;)){ // 指定修饰符 list($name,$type) = explode(&apos;/&apos;,$name,2); }elseif(C(&apos;VAR_AUTO_STRING&apos;)){ // 默认强制转换为字符串 $type = &apos;s&apos;; } /*根据$name的格式获取数据：先判断参数的来源，然后再根据各种格式获取数据*/ if(strpos($name,&apos;.&apos;)) {list($method,$name) = explode(&apos;.&apos;,$name,2);} // 指定参数来源 else{$method = &apos;param&apos;;}//设定为自动获取 switch(strtolower($method)) { case &apos;get&apos; : $input =&amp; $_GET;break; case &apos;post&apos; : $input =&amp; $_POST;break; case &apos;put&apos; : /*此处省略*/ case &apos;param&apos; : /*此处省略*/ case &apos;path&apos; : /*此处省略*/ } /*对获取的数据进行过滤*/ if(&apos;&apos; // 获取全部变量 $data = $input; $filters = isset($filter)?$filter:C(&apos;DEFAULT_FILTER&apos;); if($filters) { if(is_string($filters)){$filters = explode(&apos;,&apos;,$filters);} //为多种过滤方法提供支持 foreach($filters as $filter){ $data = array_map_recursive($filter,$data); //循环过滤 } } }elseif(isset($input[$name])) { // 取值操作 $data = $input[$name]; $filters = isset($filter)?$filter:C(&apos;DEFAULT_FILTER&apos;); if($filters) { /*对参数进行过滤，支持正则表达式验证*/ /*此处省略*/ } if(!empty($type)){ //如果设定了强制转换类型 switch(strtolower($type)){ case &apos;a&apos;: $data = (array)$data;break; // 数组 case &apos;d&apos;: $data = (int)$data;break; // 数字 case &apos;f&apos;: $data = (float)$data;break; // 浮点 case &apos;b&apos;: $data = (boolean)$data;break; // 布尔 case &apos;s&apos;: // 字符串 default:$data = (string)$data; } } }else{ // 变量默认值 $data = isset($default)?$default:null; } is_array($data) &amp;&amp; array_walk_recursive($data,&apos;think_filter&apos;); //如果$data是数组，那么用think_filter对数组过滤 return $data; } 恩，函数基本分成三块：第一块，获取各种格式的数据。第二块，对获取的数据进行循环编码，不管是二维数组还是三维数组。第三块，也就是倒数第二行，调用了think_filter对数据进行了最后一步的神秘处理。 让我们先来追踪一下think_filter函数： //1536行 版本3.2.3最新添加 function think_filter(&amp;$value){// 过滤查询特殊字符 if(preg_match(&apos;/^(EXP|NEQ|GT|EGT|LT|ELT|OR|XOR|LIKE|NOTLIKE|NOT BETWEEN|NOTBETWEEN|BETWEEN|NOTIN|NOT IN|IN)$/i&apos;,$value)){ $value .= &apos; &apos;; } } 这个函数很简单，一眼就可以看出来，在一些特定的关键字后面加个空格。但是这个叫think_filter的函数，仅仅加了一个空格，到底起到了什么过滤的作用？ 我们都知道重要的逻辑验证，如验证是否已登录，用户是否能购买某商品等，必须从服务器端验证，如果从前端验证的话，就很容易被绕过。同一个道理，在程序中，in/exp一类的逻辑结构，最好也是由服务器端来控制。 当从传递到服务器端的数据是这样：id[0]=in&amp;id[1]=1,2,3，如果没有think_filter函数的话，会被解析成下表中的1，也就会被当成服务器端逻辑解析。但如果变成如下表2的样子，因为多了一个空格，无法被匹配解析，也就避免了漏洞。 1. $data[&apos;id&apos;]=array(&apos;in&apos;=&gt;&apos;1,2,3&apos;) //经过think_filter过滤之后，会变成介个样子： 2. $data[&apos;id&apos;]=array(&apos;in &apos;=&gt;&apos;1,2,3&apos;) 二、SQL注入 相关的文件为:/ThinkPHP/Library/Think/Db.class.php(在3.2.3中改为了/ThinkPHP/Library/Think/Db/Driver.class.php) 以及 /ThinkPHP/Library/Think/Model.class.php。其中Model.class.php文件提供的是curd直接调用的函数，直接对外提供接口，Driver.class.php中的函数被curd操作间接调用。 //此次主要分析如下语句： M(&apos;user&apos;)-&gt;where($map)-&gt;find(); //在user表根据$map的条件检索出一条数据 大概说一下TP的处理思路。 首先将Model类实例化为一个user对象，然后调用user对象中的where函数处理$map，也就是将$map进行一些格式化处理之后赋值给user对象的成员变量$options（如果有其他的连贯操作，也是先赋值给user对象的对应成员变量，而不是直接拼接SQL语句，所以在写连贯操作的时候，无需像拼接SQL语句一样考虑关键字的顺序），接下来调用find函数。find函数会调用底层的，也就是driver类中的函数——select来获取数据。到了select函数，又是另一个故事了。 select除了要处理curd操作，还要处理pdo绑定，我们这里只关心curd操作，所以在select中调用了buildSelectSql，处理分页信息，并且调用parseSQL按照既定的顺序把SQL语句组装进去。虽然拼接SQL语句所需要的参数已经全部放在成员变量里了，但是格式不统一，有可能是字符串格式的，有可能是数组格式的，还有可能是TP提供的特殊查询格式，比如：$data[‘id’]=array(‘gt’,’100’);，所以在拼接之前，还要调用各自的处理函数，进行统一的格式化处理。我选取了parseWhere这个复杂的典型来分析。 关于安全方面的，如果用I函数来获取数据，那么会默认进行htmlspecialchars处理，能有效抵御xss攻击，但是对SQL注入没有多大影响。在过滤有关SQL注入有关的符号的时候，TP的做法很机智：先是按正常逻辑处理用户的输入，然后在最接近最终的SQL语句的parseWhere、parseHaving等函数中进行安全处理。这样的顺序避免了在处理的过程中出现注入。当然处理的方法是最普通的addslashes，根据死在沙滩上的前浪们说，推荐使用mysql_real_escape_string来进行过滤，但是这个函数只能在已经连接了数据库的前提下使用。感觉TP在这个地方可以做一下优化，毕竟走到这一步的都是连接了数据库的。 分析Model先说几个Model对象中的成员变量： // 主键名称 protected $pk = &apos;id&apos;; // 字段信息 protected $fields = array(); // 数据信息 protected $data = array(); // 查询表达式参数 protected $options = array(); // 链操作方法列表 protected $methods = array(&apos;strict&apos;,&apos;order&apos;,&apos;alias&apos;,&apos;having&apos;,&apos;group&apos;,&apos;lock&apos;,&apos;distinct&apos;,&apos;auto&apos;,&apos;filter&apos;,&apos;validate&apos;,&apos;result&apos;,&apos;token&apos;,&apos;index&apos;,&apos;force&apos;) 接下来分析where函数：public function where($where,$parse=null){ //如果非数组格式，即where(&apos;id=%d&amp;name=%s&apos;,array($id,$name))，对传递到字符串中的数组调用mysql里的escapeString进行处理 if(!is_null($parse) &amp;&amp; is_string($where)) { if(!is_array($parse)){ $parse = func_get_args();array_shift($parse);} $parse = array_map(array($this-&gt;db,&apos;escapeString&apos;),$parse); $where = vsprintf($where,$parse); //vsprintf() 函数把格式化字符串写入变量中 }elseif(is_object($where)){ $where = get_object_vars($where); } if(is_string($where) &amp;&amp; &apos;&apos; != $where){ $map = array(); $map[&apos;_string&apos;] = $where; $where = $map; } //将$where赋值给$this-&gt;where if(isset($this-&gt;options[&apos;where&apos;])){ $this-&gt;options[&apos;where&apos;] = array_merge($this-&gt;options[&apos;where&apos;],$where); }else{ $this-&gt;options[&apos;where&apos;] = $where; } return $this; } where函数的逻辑很简单，如果是where(‘id=%d&amp;name=%s’,array($id,$name))这种格式，那就对$id,$name变量调用mysql里的escapeString进行处理。escapeString的实质是调用mysql_real_escape_string、addslashes等函数进行处理。最后将分析之后的数组赋值到Model对象的成员函数——$where中供下一步处理。 再分析find函数：//model.class.php 行721 版本3.2.3 public function find($options=array()) { if(is_numeric($options) || is_string($options)){ /*如果传递过来的数据是字符串，不是数组*/ $where[$this-&gt;getPk()] = $options; $options = array(); $options[&apos;where&apos;] = $where; /*提取出查询条件，并赋值*/ } // 根据主键查找记录 $pk = $this-&gt;getPk(); if (is_array($options) &amp;&amp; (count($options) &gt; 0) &amp;&amp; is_array($pk)) { /*构造复合主键查询条件，此处省略*/ } $options[&apos;limit&apos;] = 1; // 总是查找一条记录 $options = $this-&gt;_parseOptions($options); // 分析表达式 if(isset($options[&apos;cache&apos;])){ /*缓存查询，此处省略*/ } $resultSet = $this-&gt;db-&gt;select($options); if(false === $resultSet){ return false;} if(empty($resultSet)) { return null; } // 查询结果为空 if(is_string($resultSet)){ return $resultSet;} //查询结果为字符串 // 读取数据后的处理，此处省略简写 $this-&gt;data = $this-&gt;_read_data($resultSet[0]); return $this-&gt;data; } $Pk为主键，$options为表达式参数，本函数的作用就是完善成员变量——options数组，然后调用db层的select函数查询数据，处理后返回数据。 跟进_parseOptions函数：protected function _parseOptions($options=array()) { //分析表达式 if(is_array($options)){ $options = array_merge($this-&gt;options,$options); } /*获取表名，此处省略*/ /*添加数据表别名，此处省略*/ $options[&apos;model&apos;] = $this-&gt;name;// 记录操作的模型名称 /*对数组查询条件进行字段类型检查，如果在合理范围内，就进行过滤处理；否则抛出异常或者删除掉对应字段*/ if(isset($options[&apos;where&apos;]) &amp;&amp; is_array($options[&apos;where&apos;]) &amp;&amp; !empty($fields) &amp;&amp; !isset($options[&apos;join&apos;])){ foreach ($options[&apos;where&apos;] as $key=&gt;$val){ $key = trim($key); if(in_array($key,$fields,true)){ //如果$key在数据库字段内，过滤以及强制类型转换之 if(is_scalar($val)) { /*is_scalar 检测是否为标量。标量是指integer、float、string、boolean的变量，array则不是标量。*/ $this-&gt;_parseType($options[&apos;where&apos;],$key); } }elseif(!is_numeric($key) &amp;&amp; &apos;_&apos; != substr($key,0,1) &amp;&amp; false === strpos($key,&apos;.&apos;) &amp;&amp; false === strpos($key,&apos;(&apos;) &amp;&amp; false === strpos($key,&apos;|&apos;) &amp;&amp; false === strpos($key,&apos;&amp;&apos;)){ // 如果$key不是数字且第一个字符不是_，不存在.(|&amp;等特殊字符 if(!empty($this-&gt;options[&apos;strict&apos;])){ //如果是strict模式，抛出异常 E(L(&apos;_ERROR_QUERY_EXPRESS_&apos;).&apos;:[&apos;.$key.&apos;=&gt;&apos;.$val.&apos;]&apos;); } unset($options[&apos;where&apos;][$key]); //unset掉对应的值 } } } $this-&gt;options = array(); // 查询过后清空sql表达式组装 避免影响下次查询 $this-&gt;_options_filter($options); // 表达式过滤 return $options; } 本函数的结构大概是，先获取了表名，模型名，再对数据进行处理：如果该条数据不在数据库字段内，则做出异常处理或者删除掉该条数据。否则，进行_parseType处理。parseType此处不再跟进，功能为:数据类型检测,强制类型转换包括int,float,bool型的三种数据。 函数运行到此处，就该把处理好的数据传到db层的select函数里了。此时的查询条件$options中的int,float,bool类型的数据都已经进行了强制类型转换，where（）函数中的字符串（非数组格式的查询）也进行了addslashes等处理。 继续追踪到select函数，就到了driver对象中了，还是先列举几个有用的成员变量： // 数据库表达式 protected $exp = array(&apos;eq&apos;=&gt;&apos;=&apos;,&apos;neq&apos;=&gt;&apos;&lt;&gt;&apos;,&apos;gt&apos;=&gt;&apos;&gt;&apos;,&apos;egt&apos;=&gt;&apos;&gt;=&apos;,&apos;lt&apos;=&gt;&apos;&lt;&apos;,&apos;elt&apos;=&gt;&apos;&lt;=&apos;,&apos;notlike&apos;=&gt;&apos;NOT LIKE&apos;,&apos;like&apos;=&gt;&apos;LIKE&apos;,&apos;in&apos;=&gt;&apos;IN&apos;,&apos;notin&apos;=&gt;&apos;NOT IN&apos;,&apos;not in&apos;=&gt;&apos;NOT IN&apos;,&apos;between&apos;=&gt;&apos;BETWEEN&apos;,&apos;not between&apos;=&gt;&apos;NOT BETWEEN&apos;,&apos;notbetween&apos;=&gt;&apos;NOT BETWEEN&apos;); // 查询表达式 protected $selectSql = &apos;SELECT%DISTINCT% %FIELD% FROM %TABLE%%FORCE%%JOIN%%WHERE%%GROUP%%HAVING%%ORDER%%LIMIT% %UNION%%LOCK%%COMMENT%&apos;; // 当前SQL指令 protected $queryStr = &apos;&apos;; // 参数绑定 protected $bind = array(); select函数：public function select($options=array()) { $this-&gt;model = $options[&apos;model&apos;]; $this-&gt;parseBind(!empty($options[&apos;bind&apos;])?$options[&apos;bind&apos;]:array()); $sql = $this-&gt;buildSelectSql($options); $result = $this-&gt;query($sql,!empty($options[&apos;fetch_sql&apos;]) ? true : false); return $result; } 版本3.2.3经过改进之后，select精简了不少。parseBind函数是绑定参数，用于pdo查询，此处不表。 buildSelectSql（）函数及其后续调用如下： public function buildSelectSql($options=array()) { if(isset($options[&apos;page&apos;])) { /*页码计算及处理，此处省略*/ } $sql = $this-&gt;parseSql($this-&gt;selectSql,$options); return $sql; } /* 替换SQL语句中表达式*/ public function parseSql($sql,$options=array()){ $sql = str_replace( array(&apos;%TABLE%&apos;,&apos;%DISTINCT%&apos;,&apos;%FIELD%&apos;,&apos;%JOIN%&apos;,&apos;%WHERE%&apos;,&apos;%GROUP%&apos;,&apos;%HAVING%&apos;,&apos;%ORDER%&apos;,&apos;%LIMIT%&apos;,&apos;%UNION%&apos;,&apos;%LOCK%&apos;,&apos;%COMMENT%&apos;,&apos;%FORCE%&apos;), array( $this-&gt;parseTable($options[&apos;table&apos;]), $this-&gt;parseDistinct(isset($options[&apos;distinct&apos;])?$options[&apos;distinct&apos;]:false), $this-&gt;parseField(!empty($options[&apos;field&apos;])?$options[&apos;field&apos;]:&apos;*&apos;), $this-&gt;parseJoin(!empty($options[&apos;join&apos;])?$options[&apos;join&apos;]:&apos;&apos;), $this-&gt;parseWhere(!empty($options[&apos;where&apos;])?$options[&apos;where&apos;]:&apos;&apos;), $this-&gt;parseGroup(!empty($options[&apos;group&apos;])?$options[&apos;group&apos;]:&apos;&apos;), $this-&gt;parseHaving(!empty($options[&apos;having&apos;])?$options[&apos;having&apos;]:&apos;&apos;), $this-&gt;parseOrder(!empty($options[&apos;order&apos;])?$options[&apos;order&apos;]:&apos;&apos;), $this-&gt;parseLimit(!empty($options[&apos;limit&apos;])?$options[&apos;limit&apos;]:&apos;&apos;), $this-&gt;parseUnion(!empty($options[&apos;union&apos;])?$options[&apos;union&apos;]:&apos;&apos;), $this-&gt;parseLock(isset($options[&apos;lock&apos;])?$options[&apos;lock&apos;]:false), $this-&gt;parseComment(!empty($options[&apos;comment&apos;])?$options[&apos;comment&apos;]:&apos;&apos;), $this-&gt;parseForce(!empty($options[&apos;force&apos;])?$options[&apos;force&apos;]:&apos;&apos;) ),$sql); return $sql; } 可以看到，在parseSql中用正则表达式拼接了sql语句，但并没有直接的去处理各种插叙你的数据格式，而是在解析变量的过程中调用了多个函数，此处拿parseWhere举例子。 protected function parseWhere($where) { $whereStr = &apos;&apos;; if(is_string($where)) { // 直接使用字符串条件 $whereStr = $where; } else{ // 使用数组表达式 /*设定逻辑规则，如or and xor等，默认为and，此处省略*/ $operate=&apos; AND &apos;; /*解析特殊格式的表达式并且格式化输出*/ foreach ($where as $key=&gt;$val){ if(0===strpos($key,&apos;_&apos;)) { // 解析特殊条件表达式 $whereStr .= $this-&gt;parseThinkWhere($key,$val); } else{ // 查询字段的安全过滤 $multi = is_array($val) &amp;&amp; isset($val[&apos;_multi&apos;]); //判断是否有复合查询 $key = trim($key); /*处理字段中包含的| &amp;逻辑*/ if(strpos($key,&apos;|&apos;)) { // 支持 name|title|nickname 方式定义查询字段 /*将|换成or，并格式化输出，此处省略*/ } elseif(strpos($key,&apos;&amp;&apos;)){ /*将&amp;换成and，并格式化输出，此处省略*/ } else{ $whereStr .= $this-&gt;parseWhereItem($this-&gt;parseKey($key),$val); } } $whereStr .= $operate; } $whereStr = substr($whereStr,0,-strlen($operate)); } return empty($whereStr)?&apos;&apos;:&apos; WHERE &apos;.$whereStr; } // where子单元分析 protected function parseWhereItem($key,$val) { $whereStr = &apos;&apos;; if(is_array($val)){ if(is_string($val[0])){ $exp = strtolower($val[0]); //如果是$map[&apos;id&apos;]=array(&apos;eq&apos;,100)一类的结构，那么解析成数据库可执行格式 if(preg_match(&apos;/^(eq|neq|gt|egt|lt|elt)$/&apos;,$exp)){ $whereStr .= $key.&apos; &apos;.$this-&gt;exp[$exp].&apos; &apos;.$this-&gt;parseValue($val[1]); } //如果是模糊查找格式 elseif(preg_match(&apos;/^(notlike|like)$/&apos;,$exp)){// 模糊查找,$map[&apos;name&apos;]=array(&apos;like&apos;,&apos;thinkphp%&apos;); if(is_array($val[1])) { //解析格式如下：$map[&apos;b&apos;] =array(&apos;notlike&apos;,array(&apos;%thinkphp%&apos;,&apos;%tp&apos;),&apos;AND&apos;); $likeLogic = isset($val[2])?strtoupper($val[2]):&apos;OR&apos;; //如果没有设定逻辑结构，则默认为OR if(in_array($likeLogic,array(&apos;AND&apos;,&apos;OR&apos;,&apos;XOR&apos;))){ /* 根据逻辑结构，组合语句，此处省略*/ $whereStr .= &apos;(&apos;.implode(&apos; &apos;.$likeLogic.&apos; &apos;,$like).&apos;)&apos;; } } else{ $whereStr .= $key.&apos; &apos;.$this-&gt;exp[$exp].&apos; &apos;.$this-&gt;parseValue($val[1]); } }elseif(&apos;bind&apos; == $exp ){ // 使用表达式，pdo数据绑定 $whereStr .= $key.&apos; = :&apos;.$val[1]; }elseif(&apos;exp&apos; == $exp ){ // 使用表达式 $map[&apos;id&apos;] = array(&apos;exp&apos;,&apos; IN (1,3,8) &apos;); $whereStr .= $key.&apos; &apos;.$val[1]; }elseif(preg_match(&apos;/^(notin|not in|in)$/&apos;,$exp)){ //IN运算 $map[&apos;id&apos;] = array(&apos;not in&apos;,&apos;1,5,8&apos;); if(isset($val[2]) &amp;&amp; &apos;exp&apos;==$val[2]){ $whereStr .= $key.&apos; &apos;.$this-&gt;exp[$exp].&apos; &apos;.$val[1]; }else{ if(is_string($val[1])) { $val[1] = explode(&apos;,&apos;,$val[1]); } $zone = implode(&apos;,&apos;,$this-&gt;parseValue($val[1])); $whereStr .= $key.&apos; &apos;.$this-&gt;exp[$exp].&apos; (&apos;.$zone.&apos;)&apos;; } }elseif(preg_match(&apos;/^(notbetween|not between|between)$/&apos;,$exp)){ //BETWEEN运算 $data = is_string($val[1])? explode(&apos;,&apos;,$val[1]):$val[1]; $whereStr .= $key.&apos; &apos;.$this-&gt;exp[$exp].&apos; &apos;.$this-&gt;parseValue($data[0]).&apos; AND &apos;.$this-&gt;parseValue($data[1]); }else{ //否则抛出异常 E(L(&apos;_EXPRESS_ERROR_&apos;).&apos;:&apos;.$val[0]); } } else{ //解析如：$map[&apos;status&amp;score&amp;title&apos;] =array(&apos;1&apos;,array(&apos;gt&apos;,&apos;0&apos;),&apos;thinkphp&apos;,&apos;_multi&apos;=&gt;true); $count = count($val); $rule = isset($val[$count-1]) ? (is_array($val[$count-1]) ? strtoupper($val[$count-1][0]) : strtoupper($val[$count-1]) ) : &apos;&apos; ; if(in_array($rule,array(&apos;AND&apos;,&apos;OR&apos;,&apos;XOR&apos;))){ $count = $count -1; }else{ $rule = &apos;AND&apos;; } for($i=0;$i&lt;$count;$i++){ $data = is_array($val[$i])?$val[$i][1]:$val[$i]; if(&apos;exp&apos;==strtolower($val[$i][0])) { $whereStr .= $key.&apos; &apos;.$data.&apos; &apos;.$rule.&apos; &apos;; }else{ $whereStr .= $this-&gt;parseWhereItem($key,$val[$i]).&apos; &apos;.$rule.&apos; &apos;; } } $whereStr = &apos;( &apos;.substr($whereStr,0,-4).&apos; )&apos;; } } else { //对字符串类型字段采用模糊匹配 $likeFields = $this-&gt;config[&apos;db_like_fields&apos;]; if($likeFields &amp;&amp; preg_match(&apos;/^(&apos;.$likeFields.&apos;)$/i&apos;,$key)) { $whereStr .= $key.&apos; LIKE &apos;.$this-&gt;parseValue(&apos;%&apos;.$val.&apos;%&apos;); }else { $whereStr .= $key.&apos; = &apos;.$this-&gt;parseValue($val); } } return $whereStr; } protected function parseThinkWhere($key,$val) { //解析特殊格式的条件 $whereStr = &apos;&apos;; switch($key) { case &apos;_string&apos;:$whereStr = $val;break; // 字符串模式查询条件 case &apos;_complex&apos;:$whereStr = substr($this-&gt;parseWhere($val),6);break; // 复合查询条件 case &apos;_query&apos;:// 字符串模式查询条件 /*处理逻辑结构，并且格式化输出字符串，此处省略*/ } return &apos;( &apos;.$whereStr.&apos; )&apos;; } 上面的两个函数很长，我们再精简一些来看：parseWhere首先判断查询数据是不是字符串，如果是字符串，直接返回字符串，否则，遍历查询条件的数组，挨个解析。由于TP支持_string，_complex之类的特殊查询，调用了parseThinkWhere来处理，对于普通查询，就调用了parseWhereItem。 在各自的处理过程中，都调用了parseValue，追踪一下，其实是用了addslashes来过滤，虽然addslashes在非utf-8编码的页面中会造成宽字节注入，但是如果页面和数据库均正确编码的话，还是没什么问题的。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tp5入门——前后台分离]]></title>
    <url>%2F2016%2F11%2F23%2FTp5%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%89%8D%E5%90%8E%E5%8F%B0%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[最开始组内讨论的过程中我发现，每个人对前后端分离的理解不一样，为了保证能在同一个频道讨论，先就什么是”前后端分离”达成一致。 大家一致认同的前后端分离的例子就是SPA(Single-page application)，所有用到的展现数据都是后端通过异步接口(AJAX/JSONP)的方式提供的，前端只管展现。从某种意义上来说，SPA确实做到了前后端分离，但这种方式存在两个问题： WEB服务中，SPA类占的比例很少。很多场景下还有同步/同步+异步混合的模式，SPA不能作为一种通用的解决方案。 现阶段的SPA开发模式，接口通常是按照展现逻辑来提供的，有时候为了提高效率，后端会帮我们处理一些展现逻辑，这就意味着后端还是涉足了View层的工作，不是真正的前后端分离。 SPA式的前后端分离，是从物理层做区分（认为只要是客户端的就是前端，服务器端的就是后端），这种分法已经无法满足我们前后端分离的需求，我们认为从职责上划分才能满足目前我们的使用场景： 前端：负责View和Controller层。 后端：只负责Model层，业务处理/数据等。 前后台分离1.前台index中controller的index.php输入 1234567891011121314&lt;?phpnamespace app\index\controller;class Index&#123;public function index()&#123;return "前台方法：index";&#125;public function test() &#123;echo "前台方法：test";&#125;&#125; 2.创建admin后台模块(index同级)，MVC中controller新建index.php 1234567891011121314&lt;?phpnamespace app\admin\controller;class Index &#123;public function index()&#123;return "后台方法：index";&#125;public function test() &#123;echo "后台方法：test";&#125;&#125; 访问结果 前台 http://com.test.php:8888/index/index http://com.test.php:8888/index/index/index http://com.test.php:8888/index/index/test 后台 http://com.test.php:8888/admin/index http://com.test.php:8888/admin/index/index http://com.test.php:8888/admin/index/test 3.public中新增admin.php入口文件，index.php同级，且内容保持一致 访问结果：上面的访问结果还是一样，只是一下访问的都是前台 http://com.test.php:8888/index.php http://com.test.php:8888/admin.php 4.实现绑定 public中admin.php和index.php的定义应用目录和加载框架引导文件中间 12345// 定义应用目录define('APP_PATH', __DIR__ . '/../application/');//TODO: ....// 加载框架引导文件require __DIR__ . '/../thinkphp/start.php'; 增加绑定1234// 绑定后台模块define("BIND_MODULE", 'admin');// 绑定前台模块define("BIND_MODULE", 'index'); 此时使用下面URL分别访问的是前台和后台 http://com.test.php:8888/index.php http://com.test.php:8888/admin.php 条件是需要开启隐藏入口文件功能tp5默认开启: 文档，架构中有隐藏说明(原理就是正则) 同时可以关闭路由，在配置文件最后面增加 12//关闭admin模块的路由，必须写到加载框架引导文件之后\think\App::route(false);]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tp5入门——脚本与配置]]></title>
    <url>%2F2016%2F11%2F19%2FTp5%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E8%84%9A%E6%9C%AC%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[ThinkPHP提供了灵活的全局配置功能，采用最有效率的PHP返回数组方式定义，支持惯例配置、公共配置、模块配置、扩展配置、场景配置、环境变量配置和动态配置。 对于有些简单的应用，你无需配置任何配置文件，而对于复杂的要求，你还可以扩展自己的独立配置文件。 系统的配置参数是通过静态变量全局存取的，存取方式简单高效。 配置功能由\think\Config类完成。 thinkphp配置类型有哪些？ 在thinkphp中，有6种配置。即惯例配置，应用配置、扩展配置、模块配置、场景配置、动态配置。 惯例配置就是系统默认的配置。 应用配置就是我们自己开发创建的应用单独的配置。 扩展配置主要是实现我们项目在开发过程中有一些扩展程序用到的配置。 模块配置就是我们在一个应用中，每一个模块的配置。 场景配置主要是实现我们在不同的开发环境中设置的配置。若我们在家里面办公，电脑环境可能不一样;公司里面办公，公司的电脑环境有不一样。 动态配置在我们模块中开发实现的动态配置。如我们在某一个控制器中定义数据库的配置。 脚本与配置 配置类型和位置 惯例配置：通用全局配置 thinkphp5_1/thinkphp/convention.php 应用配置：App应用，后台配置 thinkphp5_1/application/config.php 拓展配置：对真个配置文件分类管理(分目录) thinkphp5_1/application/database.php thinkphp5_1/application/extra/自定义配置文件 场景配置：环境切换配置： thinkphp5_1/application/config.php // 应用模式状态 ‘app_status’ =&gt; ‘home’, application新建对应home文件，编写配置 ‘app_status’ =&gt; ‘office’, application新建对应office文件，编写配置 模块配置：模块特有，对应模块config.php thinkphp5_1/application/admin 动态配置：临时性配置，执行的时候设置 设置动态配置系统方法： config(&apos;name&apos;, &apos;PHP动态配置&apos;); 系统类: \think\Config::set(&apos;name&apos;, &apos;PHP动态配置&apos;); 读取配置系统方法： config(&apos;key&apos;) 系统类： \think\Config::get(&apos;key&apos;) 使用use： use \think\Config Config::get(&apos;key&apos;) 数组： config(&apos;key&apos;) config(&apos;key.name&apos;) 上同 扩展配置分类： config(&apos;key.name&apos;) &apos;key&apos;所有 系统相关系统类： thinkphp5_1/thinkphp/library/think 系统方法： thinkphp5_1/thinkphp/helper.php 配置顺序配置文件加载顺序：反向加载，合并同名覆盖，不同名保留 动态配置 -&gt; 模块 -&gt; 场景 -&gt; 扩展 -&gt; 应用 -&gt; 管理 环境变量配置新建： thinkphp5_1/.env // 非php，直接键值对或数组，不支持中文 name=icocos [database] type=mysql root = root 读取： think\Env::get(&apos;name&apos;) think\Env::get(&apos;database.type&apos;) // 不能直接database.type]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tp5入门——路由入门与实战]]></title>
    <url>%2F2016%2F11%2F15%2FTp5%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E8%B7%AF%E7%94%B1%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[路由 官方文档里面是这样子定义的=&gt;路由的作用是简化URL访问地址，并根据定义的路由类型做出正确的解析。 手动解释一下： 平常我们按照习惯去访问我们的ThinkPHP项目的时候，常规的url应该是这样子写的，（本地举例）http://localhost/项目名/public/index.php/模块名/控制器名/方法名 一串url输进去之后，就会感觉很绝望，（小声吐槽）=&gt;“我只是想测试一个小接口让我打这么长一串地址、地址太长记不住呀……”。这个时候我们就可以用路由去简化他的地址，并且在缩短地址的同时进行一些规则的定义。 路由的作用： 简化URL地址，方便大家记忆 有利于搜索引擎的优化，比如可以被百度的爬虫抓取到 路由的三种模式： 普通模式 :完全使用PASH_INFO来访问，比如http://www.yd.com/index.php/index/index，域名+模块+控制器 混合模式 ：可以使用路由也可以不使用 强制模式 ：必须使用路由 注意：路由只针对应用，不针对模块，如果有些模块不像使用路由，需要在配置文件中关闭路由 12//关闭admin模块的路由，必须写到加载框架引导文件之后\think\App::route(false); 1.普通模式：完全使用PASH_INFO来访问1234// 是否开启路由'url_route_on' =&gt; false,// 是否强制使用路由'url_route_must' =&gt; false, 2.混合模式1234// 是否开启路由'url_route_on' =&gt; true,// 是否强制使用路由'url_route_must' =&gt; false, 3.强制模式1234// 是否开启路由'url_route_on' =&gt; true,// 是否强制使用路由'url_route_must' =&gt; false, 设置路由：一下直接修改application下的route.php 1.单个注册 在application下的route.php文件内更改 12use think\Route; //引入Route Route::rule('test','index/index/test'); //当URL访问http://com.test.php:8888/test时，访问的是index模块下的index下的控制器下的test方法 路由形式： 静态路由：Route::rule(‘/’,’index/index/index’);Route::rule(‘test’,’index/index/test’); 带参数的路由： Route::rule(‘time/:time’,’index/User/getTime’);http://com.test.php:8888/getTime/123456 可选参数的路由： Route::rule(‘time/[:time]/[:???]’,’index/User/getTime’);http://com.test.php:8888/getTimehttp://com.test.php:8888/getTime/123456 全动态路由(不推荐)： Route::rule(‘:X/:Y’,’index/User/getXY’);http://com.test.php:8888/11/22 完全匹配：Route::rule(‘rout$’=&gt;’index/User/getRout’);不加$符号，我们字comp后面加多少路径，比如http://com.test.php:8888/comp/asd/dfds/wer/ewr，页面都能输出 我是完全匹配路由 Route::rule(‘rout’,’index/User/getRout’);加上$符号，我们在comp后面加多少路径，比如http://com.test.php:8888/comp/comp/asd/dfds/wer/ewr，页面不能输出方法的内容 额外参数：Route::rule(‘test’,’index/index/test?id=1&amp;name=icocos’); 2.批量注册 rule方式 1Route::rule([ "test"=&gt;"index/index/test", 'time/:time'=&gt;'index/User/getTime' ],'','get'); //post,put,delete get方式 1Route::get([ "test"=&gt;"index/index/test", 'time/:time'=&gt;'index/User/getTime' ]); //post,put,delete 3.配置文件注册1return[ "test"=&gt;"index/index/test", 'time/:time'=&gt;'index/User/getTime']; 路由的请求方式一般请求方式有八种，但是TP里面有四种请求方式(GET，POST，PUT，DELETE)，其中GET，POST是最常用的，如果我们不指定请求类型，默认是*，所有的请求类型 支持get 12Route::rule('rtype','index/User/getRType','get');Route::get('rtype','index/User/getRType'); 支持post 1Route::post('rtype','index/User/getRType'); 既支持get有支持post 1Route::rule('rtype','index/User/getRType','get|post'); 支持全部请求方式 12Route::any('rtype','index/User/getRType');Route::rule('rtype','index/User/getRType','*'); 模拟PUT，DELETE 支持put请求 12Route::put('rtype','index/User/getRType');Route::rule('rtype','index/User/getRType','put'); 支持put请求 12Route::delete('rtype','index/User/getRType');Route::rule('rtype','index/User/getRType','delete'); 变量规则 Route::rule()；的最后一个参数，是一个数组，可以指定多个参数，用正则表达式来写，用来规范传入的参数必须是什么数据类型，或者必须是那些数据等等，比如 1Route::rule('getid/:id','index/User/getId','get',[],['id'=&gt;'\d']); //最后一个参数，表示id传参数必须是数字 路由参数 Route::rule()；的倒数第二个参数，是一个数组，可以用来指定请求的数据类型，也可以用来规定请求的URL后缀，比如 12Route::rule('getid/:id','index/User/getId','get',['method'=&gt;'get','ext'=&gt;'html'],['id'=&gt;'\d']);//请求方式必须是get,请求的后缀必须是html,访问的url为http://www.yd.com/getid/9.html，不带html后缀就请求失败 资源路由你的后台模块可能会有增删改查等操作，但是一个一个写太费劲，资源路由自动帮你生这些路由，你只需要在控制器内写这些方法， 设置后会自动注册7个路由规则，如下： 12345678标识 请求类型 生成路由规则 对应操作方法（默认）index GET blog indexcreate GET blog/create createsave POST blog saveread GET blog/:id readedit GET blog/:id/edit editupdate PUT blog/:id updatedelete DELETE blog/:id delete 实战12345678910111213141516//先创建blocknamespace app\index\controller;class Block&#123;public function index()&#123;echo '我是前台模块下的block';&#125;public function create()&#123;echo '我是前台模块下的block的create方法';&#125;public function read($id)&#123;echo $id;&#125;&#125;//然后在route.php下写上资源路由Route::resource('block','index/Block'); 效果：123//当你访问http://com.test.php:8888/block URL访问的是index方法//当你访问http://com.test.php:8888/block/15 URL访问的是read方法//当你访问http://com.test.php:8888/block/create URL访问的是create方法 快捷路由在index模块下创建一个Fastroute控制器，里面写下如下例子，除了index，其他方法都要加上get 123456789101112131415161718192021222324namespace app\index\controller;class Fastroute&#123;public function index()&#123;echo '我是Fast路由的index';&#125;public function getAA()&#123;echo "我是getAA";&#125;public function getBB()&#123;echo "我是BB";&#125;public function postInfo()&#123;&#125;public function putInfo()&#123;&#125;public function deleteInfo()&#123;&#125;&#125; 在route.php里面写下快捷路由 1234//注意：路由名字要和控制器名字一样Route::controller('Fastroute','index/Fastroute');//然后我们想访问getAA方法，我们可以通过访问URL http://com.test.php:8888/Fastroute/AA来访问//想访问getBB()，可以通过 http://com.test.php:8888/Fastroute/BB来访问 生成URL： 有两种方式 12Url::build(‘index/User/index’); url('index/User/index'); 查看生成方式12dump(url('index/User/index'));dump(Url::build('index/User/index')); 带参数 123url('index/User/index/id/10');url('index/User/index/abc',['id'=&gt;10,'name'=&gt;'icocos']);url('index/User/index/abc', 'id=10&amp;name=icocos'); 带锚点 1url('index/User/index/abc#name', 'id=10&amp;name=icocos'); 带域名 1url('index/User/index/abc#name@blog', 'id=10&amp;name=icocos'); 加入口文件1Url::root('/index.php'); //带入口文件]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tp5入门——加载显示UI]]></title>
    <url>%2F2016%2F11%2F03%2FTp5%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%8A%A0%E8%BD%BD%E6%98%BE%E7%A4%BAUI%2F</url>
    <content type="text"><![CDATA[在thinkPHP的MVC模式中，V：(view)视图 就是用于承载php回显数据的html文档 加载显示UI：加载显示View index/controller下新建User.php控制 里面写加载方法loadview // 系统函数 return View(); // View方式 $view = new \think\View; return $view-&gt;fetch(); // 在控制器方式：需要继承系统控制器类 $this-&gt;fetch(); controller同级目录新建View目录，里面新建user文件夹，里面新建loadview.html 其中 View是前台模块中MVC的View模块，View里面的user文件夹对应controller下的User.php控制器(注意大小写) View里面的user文件夹中的html名字对应User.php中的loadview方法，注意名字相同 数据输入123456return "iCocos"return json_encode(array("name"=&gt;"name","age"=&gt;"age")/["name"=&gt;"name","age"=&gt;"age"])return "&lt;h1&gt;H1&lt;/h1&gt;"default_return_type =&gt; 'html'/'json'default_ajax_return =&gt; 'json' 控制器初始化 必须继承控制器 只要调用控制器的任务方法都会先找初始化方法 提取控制器公告代码，后台权限把控 123public function _initialize() &#123;&#125; 前置操作定义方法之前做的事情，把一些公共的设置提取成方法，进行调用，但是必须结合系统控制器前置方法属性 1234567protected $beforeActionList=[ "abc", // 不让index方法使用def "def"=&gt;["except"=&gt;index], // 只让index方法使用ghi "ghi"=&gt;["only"=&gt;index] ]; 页面跳转12345thinkphp/library/think/Controller.phpLoader::import('controller/Jump', TRAIT_PATH, EXT);thinkphp/library/traits/controller/Jump.php 成功跳转1$this-&gt;success("成功",'index/index'); // 默认跳转到上一个页面 操作成功跳转的快捷方法1234567891011121314151617181920212223242526272829303132333435363738394041/** * 操作成功跳转的快捷方法 * @access protected * @param mixed $msg 提示信息 * @param string $url 跳转的 URL 地址 * @param mixed $data 返回的数据 * @param int $wait 跳转等待时间 * @param array $header 发送的 Header 信息 * @return void * @throws HttpResponseException */protected function success($msg = '', $url = null, $data = '', $wait = 3, array $header = [])&#123; if (is_null($url) &amp;&amp; !is_null(Request::instance()-&gt;server('HTTP_REFERER'))) &#123; $url = Request::instance()-&gt;server('HTTP_REFERER'); &#125; elseif ('' !== $url &amp;&amp; !strpos($url, '://') &amp;&amp; 0 !== strpos($url, '/')) &#123; $url = Url::build($url); &#125; $type = $this-&gt;getResponseType(); $result = [ 'code' =&gt; 1, 'msg' =&gt; $msg, 'data' =&gt; $data, 'url' =&gt; $url, 'wait' =&gt; $wait, ]; if ('html' == strtolower($type)) &#123; $template = Config::get('template'); $view = Config::get('view_replace_str'); $result = ViewTemplate::instance($template, $view) -&gt;fetch(Config::get('dispatch_success_tmpl'), $result); &#125; $response = Response::create($result, $type)-&gt;header($header); throw new HttpResponseException($response);&#125; 失败跳转1$this-&gt;success("失败",'index/index'); // 默认跳转到上一个页面 操作错误跳转的快捷方法12345678910111213141516171819202122232425262728293031323334353637383940/** * 操作错误跳转的快捷方法 * @access protected * @param mixed $msg 提示信息 * @param string $url 跳转的 URL 地址 * @param mixed $data 返回的数据 * @param int $wait 跳转等待时间 * @param array $header 发送的 Header 信息 * @return void * @throws HttpResponseException */protected function error($msg = '', $url = null, $data = '', $wait = 3, array $header = [])&#123; if (is_null($url)) &#123; $url = Request::instance()-&gt;isAjax() ? '' : 'javascript:history.back(-1);'; &#125; elseif ('' !== $url &amp;&amp; !strpos($url, '://') &amp;&amp; 0 !== strpos($url, '/')) &#123; $url = Url::build($url); &#125; $type = $this-&gt;getResponseType(); $result = [ 'code' =&gt; 0, 'msg' =&gt; $msg, 'data' =&gt; $data, 'url' =&gt; $url, 'wait' =&gt; $wait, ]; if ('html' == strtolower($type)) &#123; $template = Config::get('template'); $view = Config::get('view_replace_str'); $result = ViewTemplate::instance($template, $view) -&gt;fetch(Config::get('dispatch_error_tmpl'), $result); &#125; $response = Response::create($result, $type)-&gt;header($header); throw new HttpResponseException($response);&#125; 修改模板页面: application/config.php中12'dispatch_success_tmpl' =&gt; THINK_PATH . 'tpl' . DS . 'dispatch_jump.tpl','dispatch_error_tmpl' =&gt; THINK_PATH . 'tpl' . DS . 'dispatch_jump.tpl', /thinkphp/tpl/dispatch_jump.tpl1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&#123;__NOLAYOUT__&#125;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"/&gt; &lt;title&gt;跳转提示&lt;/title&gt; &lt;style type="text/css"&gt; *&#123; padding: 0; margin: 0; &#125; body&#123; background: #fff; font-family: "Microsoft Yahei","Helvetica Neue",Helvetica,Arial,sans-serif; color: #333; font-size: 16px; &#125; .system-message&#123; padding: 24px 48px; &#125; .system-message h1&#123; font-size: 100px; font-weight: normal; line-height: 120px; margin-bottom: 12px; &#125; .system-message .jump&#123; padding-top: 10px; &#125; .system-message .jump a&#123; color: #333; &#125; .system-message .success,.system-message .error&#123; line-height: 1.8em; font-size: 36px; &#125; .system-message .detail&#123; font-size: 12px; line-height: 20px; margin-top: 12px; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="system-message"&gt; &lt;?php switch ($code) &#123;?&gt; &lt;?php case 1:?&gt; &lt;h1&gt;:)&lt;/h1&gt; &lt;img src="/static/imagename.png" alt="" /&gt; // 状态图片 &lt;p class="success"&gt;&lt;?php echo(strip_tags($msg));?&gt;&lt;/p&gt; &lt;?php break;?&gt; &lt;?php case 0:?&gt; &lt;img src="/static/imagename.png" alt="" /&gt; // 状态图片 &lt;h1&gt;:(&lt;/h1&gt; &lt;p class="error"&gt;&lt;?php echo(strip_tags($msg));?&gt;&lt;/p&gt; &lt;?php break;?&gt; &lt;?php &#125; ?&gt; &lt;p class="detail"&gt;&lt;/p&gt; &lt;p class="jump"&gt; 页面自动 &lt;a id="href" href="&lt;?php echo($url);?&gt;"&gt;跳转&lt;/a&gt; 等待时间： &lt;b id="wait"&gt;&lt;?php echo($wait);?&gt;&lt;/b&gt; &lt;/p&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; (function()&#123; var wait = document.getElementById('wait'), href = document.getElementById('href').href; var interval = setInterval(function()&#123; var time = --wait.innerHTML; if(time &lt;= 0) &#123; location.href = href; clearInterval(interval); &#125;; &#125;, 1000); &#125;)(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; * @param mixed $code 状态码 * @param mixed $msg 提示信息 * @param string $url 跳转的 URL 地址 * @param mixed $data 返回的数据 * @param int $wait 跳转等待时间 * @param array $header 发送的 Header 信息 直接在code1和0之间指定对对应的内容可以 或者指定对应的模板页面12'dispatch_success_tmpl' =&gt; THINK_PATH . 'tpl' . DS . 'dispatch_success_jump.tpl','dispatch_error_tmpl' =&gt; THINK_PATH . 'tpl' . DS . 'dispatch_error_jump.tpl', /thinkphp/tpl/dispatch_success_jump.tpl /thinkphp/tpl/dispatch_error_jump.tpl 直接写dispatch_success_jump.tpl和dispatch_error_jump.tpl就可以实现自定义模板显示，具体显示根据需求或者业务进行调整 重定向 重定向(Redirect)就是通过各种方法将各种网络请求重新定个方向转到其它位置（如：网页重定向、域名的重定向、路由选择的变化也是对数据报文经由路径的一种重定向） 状态码： 301 redirect、302 redirect 我们在网站建设中，时常会遇到需要网页重定向的情况： 1.网站调整（如改变网页目录结构）； 2.网页被移到一个新地址； 3.网页扩展名改变(如应用需要把.php改成.Html或.shtml)。 这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。 我们先来了解一下用户/搜索引擎和网站一开始的交互流程。当用户或搜索引擎向一个网站服务器发出网页浏览请求时，该服务器将： 1.通过域名服务器(DNS)将域名转换为网站的IP地址，然后返回给客户 2.打开一个该IP套接口连接 3.记下通过该套接口的一个HTTP数据流 4.从WEB服务器接收一个响应请求的HTTP数据流。该数据流包含状态码，状态码的值由HTTP协议所决定。这里所说的“HTTP数据流”信息也叫“头信息(Header)”。 头信息中包括了日期，服务器类型，通常还会有一条“200 OK”信息。 如果一切良好，那么网络服务器就会将“200 OK”信息以及请求页面发送出去。 如果网站在这时候已经建立了重定向，那么服务器就会在头信息中包含一个“302 Moved Temporarily”或“301 Moved Permanent”之类的响应信息。 搜索引擎会根据服务器头信息中的内容作出决定。 URL 重定向12345678910111213141516171819202122232425 /** * URL 重定向 * @access protected * @param string $url 跳转的 URL 表达式 * @param array|int $params 其它 URL 参数 * @param int $code http code * @param array $with 隐式传参 * @return void * @throws HttpResponseException */ protected function redirect($url, $params = [], $code = 302, $with = []) &#123; if (is_integer($params)) &#123; $code = $params; $params = []; &#125; $response = new Redirect($url); $response-&gt;code($code)-&gt;params($params)-&gt;with($with); throw new HttpResponseException($response); &#125;$this-&gt; redirect('index/index',['name'=&gt;'name', 'id'=&gt;'99'], 301或302) 空操作作用解决用户恶意输入，报错影响用户体验 123public function _empty() &#123; $this-&gt; redirect('index/index')&#125; 空控制器网站上线每个控制都必须写空操作，不论前台后台，都必须写一个Error.php控制器 controller下新建一个Error.php控制器 123456789101112131415&lt;?phpnamespace app\index\controller;class Error&#123; // index重定向 public function index() &#123; $this-&gt;redirect('index/index'); &#125; // 空操作 public function _empty() &#123; $this-&gt; redirect('index/index') &#125; &#125;?&gt; 资料控制通过命令生成控制,主目录中有一个think可执行文件 1234567891011121314151617#!/usr/bin/env php&lt;?php// +----------------------------------------------------------------------// | ThinkPHP [ WE CAN DO IT JUST THINK ]// +----------------------------------------------------------------------// | Copyright (c) 2006-2016 http://thinkphp.cn All rights reserved.// +----------------------------------------------------------------------// | Licensed ( http://www.apache.org/licenses/LICENSE-2.0 )// +----------------------------------------------------------------------// | Author: yunwuxin &lt;448901948@qq.com&gt;// +----------------------------------------------------------------------// 定义项目路径define('APP_PATH', __DIR__ . '/application/');// 加载框架引导文件require __DIR__.'/thinkphp/console.php'; 在主目录即application同级目录中操作命令行：php think 1234567891011121314151617181920212223242526272829303132333435363738394041Think Console version 0.1Usage: command [options] [arguments]Options: -h, --help Display this help message -V, --version Display this console version -q, --quiet Do not output any message --ansi Force ANSI output --no-ansi Disable ANSI output -n, --no-interaction Do not ask any interactive question -v|vv|vvv, --verbose Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debugAvailable commands: build Build Application Dirs clear Clear runtime file help Displays help for a command list Lists commands make make:controller Create a new resource controller class make:model Create a new model class migrate migrate:breakpoint Manage breakpoints migrate:create Create a new migration migrate:rollback Rollback the last or to a specific migration migrate:run Migrate the database migrate:status Show migration status optimize optimize:autoload Optimizes PSR0 and PSR4 packages to be loaded with classmaps too, good for production. optimize:config Build config and common file cache. optimize:route Build route cache. optimize:schema Build database schema cache. queue queue:listen Listen to a given queue queue:restart Restart queue worker daemons after their current job queue:subscribe Subscribe a URL to an push queue queue:work Process the next job on a queue seed seed:create Create a new database seeder seed:run Run database seeders 创建MVC： 123php think make:controller app\index\controller\Conterphp think make:controller app\index\view\conterphp think make:controller app\index\model\conter]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tp5入门——huiadmin+MVC实战笔记]]></title>
    <url>%2F2016%2F10%2F27%2FTp5%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94huiadmin-MVC%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[MVC无人不知，可很多程序员对MVC的概念的理解似乎有误，换言之他们一直在错用MVC，尽管即使如此软件也能被写出来，然而软件内部代码的组织方式却是不科学的，这会影响到软件的可维护性、可移植性，代码的可重用性。 MVC即Model、View、Controller即模型、视图、控制器。我在和同行讨论技术，阅读别人的代码时发现，很多程序员倾向于将软件的业务逻辑放在Controller里，将数据库访问操作的代码放在Model里。 public中menu里面处理：管理员管理 模块 12345678&lt;dl id="menu-admin"&gt;&lt;dt&gt;&lt;i class="Hui-iconfont"&gt;&amp;#xe62d;&lt;/i&gt; 管理员管理&lt;i class="Hui-iconfont menu_dropdown-arrow"&gt;&amp;#xe6d5;&lt;/i&gt;&lt;/dt&gt;&lt;dd&gt;&lt;ul&gt;&lt;li&gt;&lt;a data-href="&#123;:url('admin/add')&#125;" data-title="添加用户" href="javascript:void(0)"&gt;添加用户&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/dd&gt;&lt;/dl&gt; data-href=”{:url(‘admin/add’)}”: 对应位置是admin/add,即当前view中admin里面的add.html 在view里面新建admin，里面在新建add.html,处理add.html中表单 1&lt;form class="form form-horizontal" id="form-admin-add" method="post" action="&#123;:url('admin/add')&#125;"&gt; action=”{:url(‘admin/add’)}”: 表单提交对应的是admin对应的控制器，里面的add方法 在controller里面新建Admin.php(必须大写),里面新增add方法 12345678910111213141516171819202122232425262728293031323334353637383940namespace app\admin\controller;use think\Controller;class Admin extends Controller&#123; public function add() &#123; // 是否是POST提交 if (request()-&gt;isPost()) &#123; //dump(input('post.')); $data = input('post.'); &lt;!--验证: AdminUser--&gt; $validate = validate('AdminUser'); if (!$validate-&gt;check($data)) &#123; $this-&gt;error($validate-&gt;getError()); &#125; &lt;!--加密--&gt; $data['password'] = md5($data['password'].'_#dev_icocos_php'); $data['status'] = 1; &lt;!--异常--&gt; try &#123; &lt;!--模型层数据传递：AdminUser--&gt; $id = model('AdminUser')-&gt;add($data); &#125; catch (\Exception $e) &#123; $this-&gt;error($e-&gt;getMessage()); &#125; &lt;!--状态判断--&gt; if ($id) &#123; $this-&gt;success('id='.$id.'的用户新增成功'); &#125; else &#123; $this-&gt;error('error'); &#125; &#125; else &#123; // 非POST &#125; return $this-&gt;fetch(); //显示到view &#125;&#125; 其中顶层模块新建common，里面新建两个文件夹 4.1 validate里面AdminUser.php对应全局验证，配置规则就可以 12345678910namespace app\common\validate;use think\Validate;class AdminUser extends Validate &#123; protected $rule = [ 'username' =&gt; 'require|max:20', 'password' =&gt; 'require|max:20', ];&#125; 4.2 common里面AdminUser.php对应模型数据 123456789101112131415namespace app\common\model;use think\Model;class AdminUser extends Model &#123; protected $autoWriteTimestamp = true; // 直接默认使用写入(创建)时间 public function add($data) &#123; if (!is_array($data)) &#123; exception("数据传输不合法"); &#125; &lt;!--数据库存储--&gt; $this-&gt;allowField(true)-&gt;save($data); return $this-&gt;id; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tp5入门——数据库(MySQL)操作]]></title>
    <url>%2F2016%2F10%2F18%2FTp5%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[MySQL 是最流行的关系型数据库管理系统，在WEB应用方面 MySQL 是最好的RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。 在本教程中，会让大家快速掌握 MySQL 的基本知识，并轻松使用 MySQL 数据库。 TP-&gt;DB：查询数据public function selectDB() { // // 1. 原生更新记录 $result1 = Db::query(&apos;delete from t_php_0002 where id=38&apos;); var_dump($result1); // 2. TPS岔村构造器方法 $result2 = DB::table(&apos;t_php_0002&apos;)-&gt;where(&apos;id&apos;, 39)-&gt;delete(); var_dump($result2); // 3. 去掉表前缀:think_ $result3 = Db::name(&apos;t_php_0002&apos;)-&gt;where(&apos;id&apos;, 40)-&gt;delete(); var_dump($result3); // 4. 助手Db函数 $db = db(&apos;t_php_0002&apos;); $result4 = $db-&gt;where(&apos;id&apos;, 41)-&gt;delete(); var_dump($result4); } 删除数据public function deleteDB() { // 1. 原生更新记录 $result1 = Db::query(&apos;select * from t_php_0002 where id&lt;&gt;5&apos;); var_dump($result1); // 2. TPS岔村构造器方法 $result2 = DB::table(&apos;t_php_0002&apos;)-&gt;where(&apos;id&apos;, 16)-&gt;select(); var_dump($result2); // 3. 去掉表前缀:think_ $result3 = Db::name(&apos;t_php_0002&apos;)-&gt;where(&apos;id&apos;, 16)-&gt;select(); var_dump($result3); // 4. 助手Db函数 $db = db(&apos;t_php_0002&apos;); $result4 = $db-&gt;where(&apos;id&apos;, 16)-&gt;select(); var_dump($result4); } 更新数据public function updateDB() { // 1. 原生更新记录 $result1 = Db::execute(&apos;update t_php_0002 set name = &quot;framework&quot; where id=16&apos;); var_dump($result1); // 2. TPS岔村构造器方法 DB::table(&apos;t_php_0002&apos;)-&gt;where(&apos;id&apos;, 16)-&gt;update([&apos;name&apos;=&gt;&quot;iCocos XXX&quot;]); // 3. 去掉表前缀:think_ Db::name(&apos;t_php_0002&apos;)-&gt;where(&apos;id&apos;, 16)-&gt;update([&apos;name&apos;=&gt;&quot;iCocos YYY&quot;]); // 4. 助手Db函数 $db = db(&apos;t_php_0002&apos;); $db-&gt;where(&apos;id&apos;, 16)-&gt;update([&apos;name&apos;=&gt;&quot;iCocos MMM&quot;]); } 插入数据public function insertDB() { // 1. 原生插入记录 $result1 = Db::execute(&apos;insert into t_php_0002 (name, status) values (&quot;thinkphp002&quot;, 12)&apos;); var_dump($result1); // 2. TPS岔村构造器方法 Db::table(&apos;t_php_0002&apos;)-&gt;insert([&apos;name&apos;=&gt;&apos;PHP0002&apos;,&apos;status&apos;=&gt;10]); // 3. 去掉表前缀:think_ Db::name(&apos;t_php_0002&apos;)-&gt;insert([&apos;name&apos;=&gt;&quot;iCocos&quot;]); $db = db(&apos;t_php_0002&apos;); // 4. 直接插 $result2 = $db-&gt;insert([&apos;name&apos;=&gt;&quot;iCocos four&quot;]); var_dump($result2); // 5. 插入并获取结果 $result3 = $db-&gt;insertGetId([&apos;name&apos;=&gt;&quot;iCocos four&quot;]); var_dump($result3); // 插入多条 $data1 = [ [&apos;name&apos;=&gt;&apos;x&apos;], [&apos;name&apos;=&gt;&apos;Y&apos;], [&apos;name&apos;=&gt;&apos;Z&apos;] ]; $res = $db-&gt;insertAll($data1); var_dump($res); }]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tp5入门——模块和方法调用]]></title>
    <url>%2F2016%2F10%2F16%2FTp5%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%A8%A1%E5%9D%97%E5%92%8C%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在ThinkPHP中，使用 $this 可以调用当前模块内的方法，但是很多情况下经常会在当前模块中调用其他模块的方法。这篇文章主要介绍了ThinkPHP跨模块调用操作,需要的朋友可以参考下。 模块和方法调用跨控制器调用: 当前模块public function callback_current_model() { // 调用前台User // 方式1：直接实例化-&gt;前台 $model1 = new \app\index\controller\User; echo $model1-&gt;index(); // 方法2： use \app\index\controller\User $model2 = new User; echo $model2-&gt;index(); // 方法3：系统方法 $model3 = controller(&quot;User&quot;); echo $model3-&gt;index(); } 跨控制器调用: 不同模块-&gt;后台public function callback_cothers_model() { // 调用前台User // 方式1：直接实例化 $model1 = new \app\admin\controller\Index; echo $model1-&gt;index(); // 方法2： use \app\index\controller\User $model2 = new AdminIndex; echo $model2-&gt;index(); // 方法3：系统方法 $model3 = controller(&quot;admin/Index&quot;); echo $model3-&gt;index(); } 调动当前模块当前控制器中的方法public function callback_current_method() { $this-&gt;test(); self::test(); Index::test(); action(&apos;test&apos;); } 调动当前模块其他控制器中的方法public function callback_others_method() { $model1 = new \app\index\controller\User; echo $model1-&gt;test(); echo action(&apos;User/test&apos;); } 调动其他模块其他控制器中的方法public function callback_others_model_method() { // 方式1：直接实例化 $model1 = new \app\admin\controller\Index; echo $model1-&gt;test(); echo action(&apos;admin/index/test&apos;); }]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tp5入门——程序执行流程]]></title>
    <url>%2F2016%2F10%2F10%2FTp5%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[对用户的第一次URL访问 http://[ip]|[localhost]/My/index.php/Index/show/ 所执行的流程进行详细的分析. 用户的URL访问首先是定位到了My项目的index.php 入口文件，项目的入口文件所做的其实是实例化一个App应用实例，并且执行这个应用。 注意：如果使用了URL_REWRITE，可能index.php已经被隐藏了 执行流程 1， 入口文件： ~/public/index.php// 定义应用目录常量 define(&apos;APP_PATH&apos;, __DIR__ . &apos;/../application/&apos;); // 加载框架引导文件 require __DIR__ . &apos;/../thinkphp/start.php&apos;; 2，加载框架引导文件：~/thinkphp/start.php// 1. 加载基础文件 require __DIR__ . &apos;/base.php&apos;; // 2. 执行应用 App::run()-&gt;send(); 3，加载基础文件定义常量，文件后缀，环境常量 加载环境变量配置文件 载入Loader类：~/thinkphp/library/think/Loader.php(自动加载类) // 注册自动加载 \think\Loader::register(); // 注册错误和异常处理机制： ~/thinkphp/library/think/Error.php \think\Error::register(); // 加载惯例配置文件:~/thinkphp/convention.php \think\Config::set(include THINK_PATH . &apos;convention&apos; . EXT); 4，加载运行应用：~/thinkphp/library/think/App.phpApp::run()-&gt;send(); run方法：public static function run(Request $request = null) 1, 加载$config = self::initCommon();// 加载命名空间: Loader::addNamespace($config[&apos;root_namespace&apos;]); // 初始化应用： config = self::init(); 加载各种配置文件 // 应用调试模式:self::$debug = Env::get(&apos;app_debug&apos;, Config::get(&apos;app_debug&apos;)); // 加载额外文件:$config[&apos;extra_file_list&apos;] // 设置系统时区: date_default_timezone_set($config[&apos;default_timezone&apos;]); // 监听 app_init： Hook::listen(&apos;app_init&apos;); 2,加载当前控制器中的init方法// 加载各种配置文件 // 加载公告文件 // 加载语言包 3, 设置时区4, 加载当前控制的路由检测5, 调用控制器中的exec方法：根据用户请求进行分发处理6, 根据不同的请求类型，加载对应文件module方法// 获取控制器名 // $controller = strip_tags($result[1] ?: $config[&apos;default_controller&apos;]); // $controller = $convert ? strtolower($controller) : $controller; // 设置当前请求的控制器、操作 // $request-&gt;controller(Loader::parseName($controller, 1))-&gt;action($actionName); 模块/控制器绑定，入口自动绑定，默认语言，系统语言包，监听 app_dispatch，URL 路由检测，记录路由和请求信息，监听 app_begin，请求缓存检查，清空类的实例化，输出数据到客户端，监听 app_end 5，相应输出// 输出数据到客户端 if ($data instanceof Response) { $response = $data; } elseif (!is_null($data)) { // 默认自动识别响应输出类型 $type = $request-&gt;isAjax() ? Config::get(&apos;default_ajax_return&apos;) : Config::get(&apos;default_return_type&apos;); $response = Response::create($data, $type); } else { $response = Response::create(); }]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第三十一篇——注册登录验证入门实战]]></title>
    <url>%2F2016%2F10%2F05%2FPHP%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%80%E7%AF%87%E2%80%94%E2%80%94%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[实现处理PHP+MySQLi+HTML实战，简单到不能再简单的注册登录页面效果！ PHP基础——注册登录验证入门实战连接数据库： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?php header('content-type:text/html;charset=utf-8'); ##### 建立连接: 这里使用MAMP默认提供的mysql和端口 $link = mysqli_connect('localhost', 'root', 'root', 'mysqli','8889') or die('连接数据失败&lt;\br&gt;'.mysqli__connect_errno($link).':'.mysqli__connect_error($link)); //var_dump($link); if (!$link) &#123; echo "错误连接"; echo 'ERROR'.mysqli_connect_errno().':'.mysqli_connect_error(); exit(); &#125; ##### 设置字符集 mysqli_query($link, 'SET NAMES UTF8'); ##### 打开指定数据库 $res = mysqli_select_db($link,'mysqli') or die('指定数据库不存在&lt;\br&gt;'.mysqli__errno($link).':'.mysqli__error($link));``` ### PHP操作请求```bash&lt;?phprequire_once 'connect.php';$act = $_REQUEST['act'];$username = $_POST['username'];$password = $_POST['password'];$regtime = time();// 根据不同的操作完成不同的功能switch ($act) &#123; case 'regist': $sql = "INSERT user(username,password,regtime) VALUES('&#123;$username&#125;','&#123;$password&#125;','&#123;$regtime&#125;')"; $res = mysqli_query($link, $sql); if ($res) &#123; echo "注册成功，恭喜发财, 第".mysqli_insert_id($link); echo '&lt;meta http-equiv="refresh" content="3;url=login.php"/&gt;'; &#125; else &#123; echo "注册失败，请先前往注册"; echo '&lt;meta http-equiv="refresh" content="3;url=regist.php"/&gt;'; &#125; break; case 'login': $sql = "SELECT * FROM user WHERE username='&#123;$username&#125;' AND password='&#123;$password&#125;'"; $res = mysqli_query($link, $sql); if ($res &amp;&amp; mysqli_num_rows($res)&gt;0) &#123; echo "登录成功，恭喜发财, 第".mysqli_insert_id($link); echo '&lt;meta http-equiv="refresh" content="3;url=home.php"/&gt;'; &#125; else &#123; echo "登录失败，请重新登录"; echo '&lt;meta http-equiv="refresh" content="3;url=login.php"/&gt;'; &#125; break;&#125; 注册页面与简单逻辑：12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;注册页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;注册页面&lt;/h3&gt; &lt;form action="doAction.php?act=regist" method="post"&gt; &lt;table border="1" width="80%" cellpadding="0" cellspacing="0" bgcolor="#ABCDEF"&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="username" id="username" placeholder="请输入合法用户名"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="password" id="password" placeholder="请输入密码"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2"&gt; &lt;input type="submit" value="注册"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 登录页面与简单逻辑：12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;登录页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;登录页面&lt;/h3&gt; &lt;form action="doAction.php?act=login" method="post"&gt; &lt;table border="1" width="80%" cellpadding="0" cellspacing="0" bgcolor="#ABCDEF"&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="username" id="" placeholder="请输入合法用户名"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="password" id="" placeholder="请输入密码"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2"&gt; &lt;input type="submit" value="登录"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 首页展示：12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;首页&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 实战代码以下是注册登录，验证PHP代码逻辑 index.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;梦工厂系统&lt;/title&gt;&lt;script type="text/javascript" src="js/jquery-1.9.0.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/login.js"&gt;&lt;/script&gt;&lt;link href="css/login.css" rel="stylesheet" type="text/css" /&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt; 登陆注册系统&lt;sup&gt;V2016&lt;/sup&gt; &lt;/h1&gt; &lt;div class="login" style="margin-top: 50px;"&gt; &lt;div class="header"&gt; &lt;div class="switch" id="switch"&gt; &lt;a class="switch_btn_focus" id="switch_qlogin" href="javascript:void(0);" tabindex="7"&gt;快速登录&lt;/a&gt; &lt;a class="switch_btn" id="switch_login" href="javascript:void(0);" tabindex="8"&gt;快速注册&lt;/a&gt; &lt;div class="switch_bottom" id="switch_bottom" style="position: absolute; width: 64px; left: 0px;"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="web_qr_login" id="web_qr_login" style="display: block; height: 235px;"&gt; &lt;!--登录--&gt; &lt;div class="web_login" id="web_login"&gt; &lt;div class="login-box"&gt; &lt;div class="login_form"&gt; &lt;!-- 表单操作 --&gt; &lt;form action="doAction.php?act=login" name="loginform" accept-charset="utf-8" id="login_form" class="loginForm" method="post"&gt; &lt;input type="hidden" name="did" value="0" /&gt; &lt;input type="hidden" name="to" value="log" /&gt; &lt;div class="uinArea" id="uinArea"&gt; &lt;label class="input-tips" for="u"&gt;帐号：&lt;/label&gt; &lt;div class="inputOuter" id="uArea"&gt; &lt;input type="text" id="u" name="username" class="inputstyle" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="pwdArea" id="pwdArea"&gt; &lt;label class="input-tips" for="p"&gt;密码：&lt;/label&gt; &lt;div class="inputOuter" id="pArea"&gt; &lt;input type="password" id="p" name="password" class="inputstyle" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div style="padding-left: 50px; margin-top: 20px;"&gt; &lt;input type="submit" value="登 录" style="width: 150px;" class="button_blue" /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--登录end--&gt; &lt;/div&gt; &lt;!--注册--&gt; &lt;div class="qlogin" id="qlogin" style="display: none;"&gt; &lt;div class="web_login"&gt; &lt;!-- 表单操作 --&gt; &lt;form name="form2" id="regUser" accept-charset="utf-8" action="doAction.php?act=reg" method="post"&gt; &lt;input type="hidden" name="to" value="reg" /&gt; &lt;input type="hidden" name="did" value="0" /&gt; &lt;ul class="reg_form" id="reg-ul"&gt; &lt;div id="userCue" class="cue"&gt;快速注册请注意格式&lt;/div&gt; &lt;li&gt;&lt;label for="user" class="input-tips2"&gt;用户名：&lt;/label&gt; &lt;div class="inputOuter2"&gt; &lt;input type="text" id="user" name="username" maxlength="16" class="inputstyle2" /&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt;&lt;label for="passwd" class="input-tips2"&gt;密码：&lt;/label&gt; &lt;div class="inputOuter2"&gt; &lt;input type="password" id="passwd" name="password" maxlength="16" class="inputstyle2" /&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt;&lt;label for="passwd2" class="input-tips2"&gt;确认密码：&lt;/label&gt; &lt;div class="inputOuter2"&gt; &lt;input type="password" id="passwd2" name="password2" maxlength="16" class="inputstyle2" /&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt;&lt;label for="email" class="input-tips2"&gt;邮箱：&lt;/label&gt; &lt;div class="inputOuter2"&gt; &lt;input type="email" id="email" name="email" class="inputstyle2" /&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="inputArea"&gt; &lt;input type="button" id="reg" style="margin-top: 10px; margin-left: 85px;" class="button_blue" value="同意协议并注册" /&gt; &lt;a href="#" class="zcxy" target="_blank"&gt;注册协议&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;div class="cl"&gt;&lt;/div&gt; &lt;/ul&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--注册end--&gt; &lt;/div&gt;&lt;/body&gt;&lt;/body&gt;&lt;/html&gt; login.css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239html &#123; &#125;body &#123; font-family:"Microsoft Yahei"; font-size:12px; margin:0;background: #fff url(../images/1.jpg) 50% 0 no-repeat;&#125;ul &#123; padding:0; margin:0;&#125;ul li &#123; list-style-type:none;&#125;a &#123; text-decoration:none;&#125;a:hover &#123; text-decoration:none;color:#f00;&#125;.cl&#123; clear: both;&#125;input[type="text"]:focus, input[type="password"]:focus &#123; outline:none;&#125;input::-ms-clear &#123; display:none;&#125;.login &#123; margin:0 auto; width:370px; border:2px solid #eee; border-bottom:none; position:relative;&#125;.header &#123; height:50px; border-bottom:1px solid #e2e2e2; position:relative; font-family:"Microsoft Yahei";&#125;.header .switch &#123; height:45px; position:absolute; left:60px; bottom:0; font-size:16px;&#125;.header .switch #switch_qlogin &#123; margin-right:85px;&#125;.header .switch .switch_btn &#123; color:#999; display:inline-block; height:45px; line-height:45px; outline:none; *hide-focus:expression(this.hideFocus=true);&#125;.header .switch .switch_btn_focus &#123; color:#333; display:inline-block; height:45px; line-height:45px; outline:none; *hide-focus:expression(this.hideFocus=true);&#125;.header .switch .switch_btn:hover &#123; color:#333; text-decoration:none;&#125;.header .switch .switch_btn_focus:hover &#123; text-decoration:none;&#125;#switch_bottom &#123; position:absolute; bottom:-1px;_bottom:-2px; border-bottom:2px solid #848484;&#125;.web_login &#123; width:370px; position:relative;&#125;#web_login&#123;_left:60px;*left:0;&#125;.web_login .login_form &#123; width:272px; margin:0 auto;&#125;.web_login .reg_form &#123; width:300px; margin:0 auto;&#125;.web_login .input-tips &#123; float:left; margin-top:10px; width:50px; height:42px; font-size:16px; line-height:42px; font-family:"Hiragino Sans GB", "Microsoft Yahei";&#125;.web_login .input-tips2 &#123; float:left; text-align:right; padding-right:10px; width:75px; height:30px; font-size:16px; margin-top:10px; clear:both; line-height:30px; font-family:"Hiragino Sans GB", "Microsoft Yahei";&#125;.web_login .inputOuter &#123; width:200px; height:42px; margin-top:10px; float:left; &#125;.web_login .inputOuter2 &#123; width:200px; margin-top:6px;margin-top:5px\9; float:left; &#125;.web_login .inputstyle &#123; width:200px; height:38px; padding-left:5px; line-height:30px;line-height:38px; border:1px solid #D7D7D7; background:#fff; color:#333;border-radius:2px; font-family:Verdana, Tahoma, Arial; font-size:16px; ime-mode:disabled;&#125;.web_login input.inputstyle2:focus,.web_login input.inputstyle:focus&#123;border:1px solid #198BD4;box-shadow:0 0 2px #198BD4;&#125;.web_login .inputstyle2 &#123; width:200px; height:34px; padding-left:5px; line-height:34px; border:1px solid #D7D7D7; background:#fff; color:#333;border-radius:2px; font-family:Verdana, Tahoma, Arial; font-size:16px; ime-mode:disabled;&#125;.web_login .uinArea &#123; height:55px; position:relative; z-index:10;&#125;.web_login .pwdArea &#123; height:55px; margin-bottom:10px; position:relative; z-index:3;&#125;.web_qr_login &#123; position:relative; overflow:hidden;&#125;.cue &#123; height:40px; line-height:40px; font-size:14px; border:1px #CCCCCC solid; margin-top:10px;margin-bottom:5px; text-align:center; font-family:"Hiragino Sans GB", "Microsoft Yahei";&#125;.login &#123; background-color:#ffffff;&#125;h1&#123;margin:80px auto 50px auto;text-align:center;color:#fff;margin-left:-25px;font-size:35px;font-weight: bold;text-shadow: 0px 1px 1px #555;&#125;h1 sup&#123; font-size: 18px; font-style: normal; position: absolute; margin-left: 10px;&#125;.login &#123;border:0;padding:5px 0;background: #fff;margin: 0 auto;-webkit-box-shadow: 1px 1px 2px 0 rgba(0, 0, 0, .3);box-shadow: 1px 1px 2px 0 rgba(0, 0, 0, .3);&#125;.web_login&#123;padding-bottom:20px;&#125;.jianyi&#123;color:#fff;text-align:center;margin-top:25px;color:#B3B8C4;&#125;.reg_form li &#123;height: 55px;&#125;.cue &#123;margin-top: 15px;margin-bottom: 10px;border:1px solid #eee;border-radius:3px;&#125;.web_login input.inputstyle2:focus, .web_login input.inputstyle:focus &#123;border: 1px solid #5796f;box-shadow: 0 0 0;&#125;.web_login .reg_form &#123;width: 300px;margin: 0 auto;&#125;.web_login .inputstyle2 &#123;border-radius:2px;width:210px;&#125;.web_login .input-tips2 &#123;padding-right: 5px;width: 80px;_width: 75px;_font-size:12px;&#125;.button_blue&#123; display:inline-block; float:left; height:41px;border-radius:4px; background:#2795dc;border:none;cursor:pointer; border-bottom:3px solid #0078b3;*border-bottom:none; color:#fff; font-size:16px;padding:0 10px;*width:140px; text-align:center;outline:none;font-family: "Microsoft Yahei",Arial, Helvetica, sans-serif;&#125;input.button_blue:hover&#123; background:#0081c1; border-bottom:3px solid #006698;*border-bottom:none; color:#fff; text-decoration:none;&#125;a.zcxy &#123;text-decoration: underline;line-height:58px;margin-left:15px;color: #959ca8;&#125;.web_login .login_form &#123;margin-top:30px;&#125;.web_login .uinArea &#123;height: 60px;&#125;.header .switch&#123;left:70px;&#125; login.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126$(function() &#123; $('#switch_qlogin').click( function() &#123; $('#switch_login').removeClass("switch_btn_focus").addClass( 'switch_btn'); $('#switch_qlogin').removeClass("switch_btn").addClass( 'switch_btn_focus'); $('#switch_bottom').animate(&#123; left : '0px', width : '70px' &#125;); $('#qlogin').css('display', 'none'); $('#web_qr_login').css('display', 'block'); &#125;); $('#switch_login').click( function() &#123; $('#switch_login').removeClass("switch_btn").addClass( 'switch_btn_focus'); $('#switch_qlogin').removeClass("switch_btn_focus").addClass( 'switch_btn'); $('#switch_bottom').animate(&#123; left : '154px', width : '70px' &#125;); $('#qlogin').css('display', 'block'); $('#web_qr_login').css('display', 'none'); &#125;); if (getParam("a") == '0') &#123; $('#switch_login').trigger('click'); &#125;&#125;);function logintab()&#123; scrollTo(0); $('#switch_qlogin').removeClass("switch_btn_focus").addClass('switch_btn'); $('#switch_login').removeClass("switch_btn").addClass('switch_btn_focus'); $('#switch_bottom').animate(&#123;left:'154px',width:'96px'&#125;); $('#qlogin').css('display','none'); $('#web_qr_login').css('display','block');&#125;//根据参数名获得该参数 pname等于想要的参数名 function getParam(pname) &#123; var params = location.search.substr(1); // 获取参数 平且去掉？ var ArrParam = params.split('&amp;'); if (ArrParam.length == 1) &#123; //只有一个参数的情况 return params.split('=')[1]; &#125; else &#123; //多个参数参数的情况 for (var i = 0; i &lt; ArrParam.length; i++) &#123; if (ArrParam[i].split('=')[0] == pname) &#123; return ArrParam[i].split('=')[1]; &#125; &#125; &#125; &#125; var reMethod = "GET", pwdmin = 6;$(document).ready(function() &#123; $('#user').blur(function()&#123; $.ajax(&#123; type: reMethod, url: "doAction.php?act=checkUser", data: "username=" + $("#user").val(), dataType: 'html', success: function(result) &#123; if (result==1) &#123; $('#user').focus().css(&#123; border: "1px solid red", boxShadow: "0 0 2px red" &#125;); $("#userCue").html('用户名已存在!'); return false; &#125; else &#123; $('#user').css(&#123; border: "1px solid #D7D7D7", boxShadow: "none" &#125;); &#125; &#125; &#125;); &#125;); $('#reg').click(function() &#123; if ($('#user').val() == "") &#123; $('#user').focus().css(&#123; border: "1px solid red", boxShadow: "0 0 2px red" &#125;); $('#userCue').html("&lt;font color='red'&gt;&lt;b&gt;×用户名不能为空&lt;/b&gt;&lt;/font&gt;"); return false; &#125; if ($('#user').val().length &lt; 4 || $('#user').val().length &gt; 16) &#123; $('#user').focus().css(&#123; border: "1px solid red", boxShadow: "0 0 2px red" &#125;); $('#userCue').html("&lt;font color='red'&gt;&lt;b&gt;×用户名位4-16字符&lt;/b&gt;&lt;/font&gt;"); return false; &#125; if ($('#passwd').val().length &lt; pwdmin) &#123; $('#passwd').focus(); $('#userCue').html("&lt;font color='red'&gt;&lt;b&gt;×密码不能小于" + pwdmin + "位&lt;/b&gt;&lt;/font&gt;"); return false; &#125; if ($('#passwd2').val() != $('#passwd').val()) &#123; $('#passwd2').focus(); $('#userCue').html("&lt;font color='red'&gt;&lt;b&gt;×两次密码不一致！&lt;/b&gt;&lt;/font&gt;"); return false; &#125; var reg = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(.[a-zA-Z0-9_-])+/; if (!reg.test($('#email').val())) &#123; $('#email').focus().css(&#123; border: "1px solid red", boxShadow: "0 0 2px red" &#125;); $('#userCue').html("&lt;font color='red'&gt;&lt;b&gt;×email格式不正确&lt;/b&gt;&lt;/font&gt;");return false; &#125; else &#123; $('#email').css(&#123; border: "1px solid #D7D7D7", boxShadow: "none" &#125;); &#125; $('#regUser').submit(); &#125;);&#125;); doAction.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166&lt;?php header('content-type:text/html;charset=utf-8');//基础引入require_once 'functions/mysql.func.php';require_once 'config/config.php';//邮件发送库require_once 'swiftmailer-master/lib/swift_required.php';require_once 'functions/common.func.php';//接受信息$act = $_REQUEST['act']; // 请求跳转操作$username = $_POST['username']; // 用户名$password = $_POST['password']; // 密码$link = connect3(); // 连接数据库$table = 'maizi_user';// 根据用户不同操作执行不同功能switch ($act) &#123; case 'reg': // 事务操作 // 1.关闭自动提交 mysqli_autocommit($link, FALSE); // 用户输入加产生数据 $email = $_POST['email']; $reg_time = time(); $token = md5($username.$password.$reg_time); // 生成Token $token_exptime = $reg_time+24*3600; // Token过期时间 $status = 1; // Token过期时间 $data = compact("username", "password","email","reg_time","token","token_exptime","status"); // 插入数据 $res_insert = insert($link, $data, $table); if ($res_insert) &#123; mysqli_commit($link); mysqli_autocommit($link, TRUE); echo "&lt;script&gt;alert('注册成功,立即登录');location.href='index.php'&lt;/script&gt;"; //alertMessage('注册成功,立即登录', 'index.php'); &#125; else &#123; mysqli_rollback($link); echo "&lt;script&gt;alert('注册失败,重新注册');location.href='index.php'&lt;/script&gt;"; //alertMessage('注册失败,重新注册', 'index.php'); &#125; break; // ================================== 发送邮件: 存在问题, 待调试 ================================== // 1. 初始化邮件服务器对象 $transport = Swift_SmtpTransport::newInstance('smtp.qq.com', 25); // 设置邮箱信息 $transport-&gt;setUsername(Mail_Name); $transport-&gt;setUsername(Mail_PWD); // 发送邮件对象 $mailer = Swift_Mailer::newInstance($transport); // ================= 消息对象: 发件人,收件人,设置主题和内天 ================= $message = Swift_Message::newInstance(); //发件人 $message-&gt;setFrom(array(Mail_Name)); //收件人 $message-&gt;setTo(array($email)); //主题 $message-&gt;setSubject("【梦工厂@iCocos】注册账号激活主题"); //内容 $actStr = "?act=active&amp;username=&#123;$username&#125;&amp;token=&#123;$token&#125;"; $url = "http://".$_SERVER['HTTP_HOST'].$_SERVER['PHP_SELF'].$actStr; $urlEncode = urlencode($url); $messageBody = &lt;&lt;&lt;EOF 尊敬的梦工厂用户，您好: 账号 &#123;$email&#125; ，注册并创建成功，请点击并激活, 前往主页, 详情如下： &lt;a href='&#123;$url&#125;' target='_blank'&gt;&#123;$urlEncode&#125;&lt;/a&gt; (该链接24小时内有效) 感谢您使用梦工厂，如果您在使用过程中有任何疑问，请参见下方提交工单联系我们。 谢谢！EOF; $message-&gt;setBody($messageBody, "text/html",'utf-8'); // 附件 $path = "images/maizi.png"; $message-&gt;attach(Swift_Attachment::fromPath($path, 'image/png')); // 发送操作 try &#123; $mail_res = $mailer-&gt;send($message); if ($mail_res &amp;&amp; $res_insert) &#123; mysqli_commit($link); mysqli_autocommit($link, TRUE); echo "&lt;script&gt;alert('注册成功,立即登录');location.href='index.php'&lt;/script&gt;"; &#125; else &#123; mysqli_rollback($link); echo "&lt;script&gt;alert('注册失败,重新注册');location.href='index.php'&lt;/script&gt;"; &#125; &#125; catch (Swift_ConnectionException $e) &#123; die("邮件服务器错误") . $e-&gt;getMessage(); &#125; // ================================== 发送邮件 ================================== break; case 'login': // 用户登录操作 $username = addslashes($username); $sql = "SELECT id, status FROM &#123;$table&#125; WHERE username='&#123;$username&#125;' AND password='&#123;$password&#125;'"; $user = fetchOne($link, $sql); if ($user) &#123; if ($user['status'] == 0) &#123; echo "&lt;script&gt;alert('请先激活,再登录');location.href='index.php'&lt;/script&gt;"; &#125; else &#123; echo "&lt;script&gt;alert('登录成功');location.href='index.php'&lt;/script&gt;"; &#125; &#125; else &#123; echo "&lt;script&gt;alert('用户名密码错误');location.href='index.php'&lt;/script&gt;"; &#125; break; case 'active': // 邮箱邮件外链激活操作 // http://com.mysqli.php:8888/logregmail/doAction.php // act=active&amp;username=sdsds&amp;token=ec821fcf18762a8cce7df5c47874b2f4 echo "点击邮件连接,跳转并激活成功,设置表status状态为1"; $token = $_POST['token']; // token $username = mysqli_real_escape_string($link, $username); $query = "SELECT id, token_exptime FROM &#123;$table&#125; WHERE username='&#123;$username&#125;'"; $user = fetchOne($link, $query); if ($user) &#123; // 检查是否超时 $now = time(); $token_exptime = $user['token_exptime']; if ($now&gt;$token_exptime) &#123; // 清空用户 delete($link, $table, "username='&#123;$username&#125;'"); echo "&lt;script&gt;alert('激活码无效,或者过期,请重新注册!!!');location.href='index.php'&lt;/script&gt;"; &#125; else &#123; // 激活操作:update-ststus $data=array('status'=&gt;1); $update = update($link, $data, $table, "username='&#123;$username&#125;'"); if ($update) &#123; echo "&lt;script&gt;alert('激活成功, 立即登录');location.href='index.php'&lt;/script&gt;"; &#125; else &#123; echo "&lt;script&gt;alert('激活失败,请重新激活!');location.href='index.php'&lt;/script&gt;"; &#125; &#125; &#125; else &#123; echo "&lt;script&gt;alert('激活失败,没有找到要激活的用户!!!');location.href='index.php'&lt;/script&gt;"; &#125; break; case 'checkUser': // Ajax用户注册状态检测 $username = mysqli_real_escape_string($link, $username); $query = "SELECT id FROM &#123;$table&#125; WHERE username='&#123;$username&#125;'"; $user = fetchOne($link, $query); if ($user) &#123; return 1; &#125; else &#123; return 0; &#125; break; default: die("非法操作"); break;&#125; config.php123456789101112131415161718192021&lt;?php$config=[ 'host'=&gt;'localhost', 'user'=&gt;'root', 'password'=&gt;'root', 'charset'=&gt;'utf8', 'dbName'=&gt;'maizi', 'dbPort'=&gt;'8889'];define('DB_HOST','localhost');define('DB_USER','root');define('DB_PWD','root');define('DB_CHARSET','utf8');define('DB_DBNAME','maizi');define('DB_PORT','8889');define('Mail_Name','2211523681@qq.com');define('Mail_PWD','???????'); mysql.func.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211&lt;?php/** * 连接 * @param string $host * @param string $user * @param string $password * @param string $charset * @param string $database * @return object 连接标识符 */function connect1($host,$user,$password,$charset,$database) &#123; $link = mysqli_connect ( $host, $user, $password ) or die ( '数据库连接失败&lt;br/&gt;ERROR ' . mysqli_connect_errno () . ':' . mysqli_connect_error () ); mysqli_set_charset ( $link, $charset ); mysqli_select_db ( $link, $database ) or die ( '指定数据库打开失败&lt;br/&gt;ERROR ' . mysqli_errno ( $link ) . ':' . mysqli_error ( $link ) ); return $link;&#125;/** * 连接 需要传递数组 * @param array $config * @return object */function connect2($config) &#123; $link = mysqli_connect ( $config ['host'], $config ['user'], $config ['password'] ) or die ( '数据库连接失败&lt;br/&gt;ERROR ' . mysqli_connect_errno () . ':' . mysqli_connect_error () ); mysqli_set_charset ( $link, $config ['charset'] ); mysqli_select_db ( $link, $config ['dbName'] ) or die ( '指定数据库打开失败&lt;br/&gt;ERROR ' . mysqli_errno ( $link ) . ':' . mysqli_error ( $link ) ); return $link;&#125;/** * 用常量的形式建立连接 * @return unknown */function connect3()&#123; $link = mysqli_connect ( DB_HOST, DB_USER, DB_PWD, DB_DBNAME, DB_PORT ) or die ( '数据库连接失败&lt;br/&gt;ERROR ' . mysqli_connect_errno () . ':' . mysqli_connect_error () ); mysqli_set_charset ( $link, DB_CHARSET ); mysqli_select_db ( $link, DB_DBNAME ) or die ( '指定数据库打开失败&lt;br/&gt;ERROR ' . mysqli_errno ( $link ) . ':' . mysqli_error ( $link ) ); return $link;&#125;/* array( 'username'=&gt;'king', 'password'=&gt;'king', 'age'=&gt;'12', 'regTime'=&gt;'123123123' ); INSERT user(username,password,age,regTime) VALUES('king','king','12','123123123'); *//** * 插入操作 * @param object $link * @param array $data * @param string $table * @return boolean */function insert($link,$data,$table)&#123; $keys = join ( ',', array_keys ( $data ) ); $vals = "'" . join ( "','", array_values ( $data ) ) . "'"; $query = "INSERT &#123;$table&#125;(&#123;$keys&#125;) VALUES(&#123;$vals&#125;)"; $res = mysqli_query ( $link, $query ); if ($res) &#123; return mysqli_insert_id ( $link ); &#125; else &#123; return false; &#125;&#125;/* array( 'username'=&gt;'king123', 'password'=&gt;'king123', 'age'=&gt;'32', 'regTime'=&gt;'123123123' ); UPDATE user SET username='king123',password='king123',age='32',regTime='123123123' WHERE id=1*//** * 更新操作 * @param object $link * @param array $data * @param string $table * @param string $where * @return boolean */function update($link, $data, $table, $where = null) &#123; foreach ( $data as $key =&gt; $val ) &#123; $set .= "&#123;$key&#125;='&#123;$val&#125;',"; &#125; $set = trim ( $set, ',' ); $where = $where == null ? '' : ' WHERE ' . $where; $query = "UPDATE &#123;$table&#125; SET &#123;$set&#125; &#123;$where&#125;"; $res = mysqli_query ( $link, $query ); if ($res) &#123; return mysqli_affected_rows ( $link ); &#125; else &#123; return false; &#125;&#125;//DELETE FROM user WHERE id=/** * 删除操作 * @param object $link * @param string $table * @param string $where * @return boolean */function delete($link, $table, $where = null) &#123; $where = $where ? ' WHERE ' . $where : ''; $query = "DELETE FROM &#123;$table&#125; &#123;$where&#125;"; $res = mysqli_query ( $link, $query ); if ($res) &#123; return mysqli_affected_rows ( $link ); &#125; else &#123; return false; &#125;&#125;/** * 查询指定记录 * @param object $link * @param string $query * @param string $result_type * @return array|boolean */function fetchOne($link, $query, $result_type = MYSQLI_ASSOC) &#123; $result = mysqli_query ( $link, $query ); if ($result &amp;&amp; mysqli_num_rows ( $result ) &gt; 0) &#123; $row = mysqli_fetch_array ( $result, $result_type ); return $row; &#125; else &#123; return false; &#125;&#125;/** * 查询所有记录 * @param object $link * @param string $query * @param string $result_type * @return array|boolean */function fetchAll($link, $query, $result_type = MYSQLI_ASSOC) &#123; $result = mysqli_query ( $link, $query ); if ($result &amp;&amp; mysqli_num_rows ( $result ) &gt; 0) &#123; while ( $row = mysqli_fetch_array ( $result, $result_type ) ) &#123; $rows [] = $row; &#125; return $rows; &#125; else &#123; return false; &#125;&#125;/** * 得到表中的记录数 * @param object $link * @param string $table * @return number|boolean */function getTotalRows($link, $table) &#123; $query = "SELECT COUNT(*) AS totalRows FROM &#123;$table&#125;"; $result = mysqli_query ( $link, $query ); if ($result &amp;&amp; mysqli_num_rows ( $result ) == 1) &#123; $row = mysqli_fetch_assoc ( $result ); return $row ['totalRows']; &#125; else &#123; return false; &#125;&#125;/** * 得到结果集的记录条数 * @param object $link * @param string $query * @return boolean */function getResultRows($link, $query) &#123; $result = mysqli_query ( $link, $query ); if ($result) &#123; return mysqli_num_rows ( $result ); &#125; else &#123; return false; &#125;&#125;/** * @param object $link */function getServerInfo($link) &#123; return mysqli_get_server_info ( $link );&#125;/** * @param object $link */function getClientInfo($link) &#123; return mysqli_get_client_info ( $link );&#125;/** * @param object $link */function getHostInfo($link)&#123; return mysqli_get_host_info($link);&#125;/** * @param object $link */function getProtoInfo($link) &#123; return mysqli_get_proto_info ( $link );&#125; 以上使用jquery-1.9.0.min.js实现JS基本功能交互，SwiftMailer实现用户邮箱验证，后期会根据实战抽一篇文章说关于邮箱和短信验证的实战！ 笔记总结：检测MySQLi扩展是否已经开启 phpinfo(); 检测MySQLi扩展是否已经加载，如果已经加载返回true，否则返回false var_dump(extension_loaded(‘mysqli’)); Fatal error(致命错误): Call to undefined function mysqli_connect()in G:\maizi\PHPAdvance\MySQLi\1-mysqli_connect.php on line 6 function_exists():检测某个函数是否存在 var_dump(function_exists(‘mysqli_connect’)); print_r(get_defined_functions()); mysqli_multi_query 执行多条SQL语句,每条SQL语句一定要以分号结尾，否则就会失败 如果多条SQL语句中有一条失败了，整个都会失败 结果集 mysqli_store_result():传输上一次产生的结果集 mysqli_more_results():判读是否有更多的结果集 mysqli_next_result():将结果集的指针向下移动一位 错误信息与编号 mysqli_connect_errno():连接产生的错误编号 mysqli_connect_error():连接产生的错误信息 mysqli_errno($link):得到上一步操作产生的错误编号 mysqli_error($link):得到上一步操作产生的错误信息 mysqli_querymysqli_query($link,$sql):执行SQL查询 1》只能执行一条SQL语句，SQL语句可以没有分号 2》mysqli_query()执行SELECT/SHOW/EXPLAIN/DESC/DESCRIBE这样关键字的SQL语句，执行 成功返回的是mysqli_result结果集，执行失败返回false； 执行其他SQL语句，执行成功返回true，失败返回false mysqli_affected_rowsmysqli_affected_rows($link):得到上一步操作产生的受影响的记录数 大于0的：受影响的记录数 等于0：没有记录被影响 等于-1：代表的SQL语句有问题 result_type$result_type的值为： MYSQLI_BOTH:关联+索引 MYSQLI_ASSOC:关联 MYSQLI_NUM:索引 连接不成功的情况： 1》用户名密码不正确 Warning: mysqli_connect(): (HY000/1045): Access denied for user ‘root‘@’localhost’ (using password: YES) in G:\maizi\PHPAdvance\MySQLi\2-mysqli_connect.php on line 5 bool(false) 2》MySQL服务器没有开启 ERROR 2003 (HY000): Can’t connect to MySQL server on ‘localhost’ (10061)Warning: mysqli_connect(): in G:\maizi\PHPAdvance\MySQLi\2-mysqli_connect.php on line 13 bool(false) 防止SQL注入 : ‘ or 1=1 转义特殊字符 预处理 1234567891011121314151617181920$username=addslashes($username);$username=mysqli_real_escape_string($username);$sql = "SELECT * FROM user WHERE username=? AND password=?";$sql = "SELECT id,username,password FROM user WHERE username=? AND password=?";if ($stmt=mysqli_prepare($link, $sql)) &#123; mysqli_stmt_bind_param($stmt, 'ss', $username, $password); mysqli_stmt_execute($stmt); mysqli_stmt_store_result($stmt); echo "--------"; echo '&lt;/br&gt;'.mysqli_stmt_affected_rows($stmt).'&lt;/br&gt;'; echo mysqli_stmt_num_rows($stmt).'&lt;/br&gt;'; echo "--------&lt;/br&gt;"; if (mysqli_stmt_affected_rows($stmt) == 1) &#123; mysqli_stmt_bind_result($stmt,$id,$username,$password); mysqli_stmt_reset($stmt); echo "登录成功"; echo "&lt;/br&gt;编号：".$id.'&lt;br/&gt;用户名:'.$username.'&lt;br/&gt;密码:'.$password; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第三十篇——数据库相关操作与分页功能封装]]></title>
    <url>%2F2016%2F09%2F28%2FPHP%E7%AC%AC%E4%B8%89%E5%8D%81%E7%AF%87%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E4%B8%8E%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[实现数据库相关操作(MySQLi)与分页功能初步实战与封装，入门学习笔记 连接与配置 123456789101112131415&lt;?php$config=[ 'host'=&gt;'localhost', 'user'=&gt;'root', 'password'=&gt;'root', 'charset'=&gt;'utf8', 'dbName'=&gt;'mysqli'];define('DB_HOST','localhost');define('DB_USER','root');define('DB_PWD','root');define('DB_CHARSET','utf8');define('DB_DBNAME','mysqli');define('DB_PORT','8889'); MySQL连接与d封装操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219&lt;?php/*** 连接* @param string $host* @param string $user* @param string $password* @param string $charset* @param string $database* @return object 连接标识符*/function connect1($host,$user,$password,$charset,$database) &#123; $link = mysqli_connect ( $host, $user, $password ) or die ( '数据库连接失败&lt;br/&gt;ERROR ' . mysqli_connect_errno () . ':' . mysqli_connect_error () ); mysqli_set_charset ( $link, $charset ); mysqli_select_db ( $link, $database ) or die ( '指定数据库打开失败&lt;br/&gt;ERROR ' . mysqli_errno ( $link ) . ':' . mysqli_error ( $link ) ); return $link;&#125;/*** 连接 需要传递数组* @param array $config* @return object*/function connect2($config) &#123; $link = mysqli_connect ( $config ['host'], $config ['user'], $config ['password'] ) or die ( '数据库连接失败&lt;br/&gt;ERROR ' . mysqli_connect_errno () . ':' . mysqli_connect_error () ); mysqli_set_charset ( $link, $config ['charset'] ); mysqli_select_db ( $link, $config ['dbName'] ) or die ( '指定数据库打开失败&lt;br/&gt;ERROR ' . mysqli_errno ( $link ) . ':' . mysqli_error ( $link ) ); return $link;&#125;/*** 用常量的形式建立连接* @return unknown*/function connect3()&#123; // define('DB_HOST','localhost'); // define('DB_USER','root'); // define('DB_PWD','root'); // define('DB_CHARSET','utf8'); // define('DB_DBNAME','mysqli'); // define('DB_POST','8889'); //mysqli_connect('localhost', 'root', 'root', 'mysqli','8889') $link = mysqli_connect ( DB_HOST, DB_USER, DB_PWD ,DB_DBNAME, DB_PORT) or die ( '数据库连接失败&lt;br/&gt;ERROR ' . mysqli_connect_errno () . ':' . mysqli_connect_error () ); mysqli_set_charset ( $link, DB_CHARSET ); mysqli_select_db ( $link, DB_DBNAME ) or die ( '指定数据库打开失败&lt;br/&gt;ERROR ' . mysqli_errno ( $link ) . ':' . mysqli_error ( $link ) ); // echo "连接成功"; return $link;&#125;/*array( 'username'=&gt;'king', 'password'=&gt;'king', 'age'=&gt;'12', 'regTime'=&gt;'123123123');INSERT user(username,password,age,regTime) VALUES('king','king','12','123123123');*//*** 插入操作* @param object $link* @param array $data* @param string $table* @return boolean*/function insert($link,$data,$table)&#123; $keys = join ( ',', array_keys ( $data ) ); $vals = "'" . join ( "','", array_values ( $data ) ) . "'"; $query = "INSERT &#123;$table&#125;(&#123;$keys&#125;) VALUES(&#123;$vals&#125;)"; $res = mysqli_query ( $link, $query ); if ($res) &#123; return mysqli_insert_id ( $link ); &#125; else &#123; return false; &#125;&#125;/*array( 'username'=&gt;'king123', 'password'=&gt;'king123', 'age'=&gt;'32', 'regTime'=&gt;'123123123');UPDATE user SET username='king123',password='king123',age='32',regTime='123123123' WHERE id=1*//*** 更新操作* @param object $link* @param array $data* @param string $table* @param string $where* @return boolean*/function update($link, $data, $table, $where = null) &#123; foreach ( $data as $key =&gt; $val ) &#123; $set .= "&#123;$key&#125;='&#123;$val&#125;',"; &#125; $set = trim ( $set, ',' ); $where = $where == null ? '' : ' WHERE ' . $where; $query = "UPDATE &#123;$table&#125; SET &#123;$set&#125; &#123;$where&#125;"; $res = mysqli_query ( $link, $query ); if ($res) &#123; return mysqli_affected_rows ( $link ); &#125; else &#123; return false; &#125;&#125;//DELETE FROM user WHERE id=/*** 删除操作* @param object $link* @param string $table* @param string $where* @return boolean*/function delete($link, $table, $where = null) &#123; $where = $where ? ' WHERE ' . $where : ''; $query = "DELETE FROM &#123;$table&#125; &#123;$where&#125;"; $res = mysqli_query ( $link, $query ); if ($res) &#123; return mysqli_affected_rows ( $link ); &#125; else &#123; return false; &#125;&#125;/*** 查询指定记录* @param object $link* @param string $query* @param string $result_type* @return array|boolean*/function fetchOne($link, $query, $result_type = MYSQLI_ASSOC) &#123; $result = mysqli_query ( $link, $query ); if ($result &amp;&amp; mysqli_num_rows ( $result ) &gt; 0) &#123; $row = mysqli_fetch_array ( $result, $result_type ); return $row; &#125; else &#123; return false; &#125;&#125;/*** 查询所有记录* @param object $link* @param string $query* @param string $result_type* @return array|boolean*/function fetchAll($link, $query, $result_type = MYSQLI_ASSOC) &#123; $result = mysqli_query ( $link, $query ); if ($result &amp;&amp; mysqli_num_rows ( $result ) &gt; 0) &#123; while ( $row = mysqli_fetch_array ( $result, $result_type ) ) &#123; $rows [] = $row; &#125; return $rows; &#125; else &#123; return false; &#125;&#125;/*** 得到表中的记录数* @param object $link* @param string $table* @return number|boolean*/function getTotalRows($link, $table) &#123; $query = "SELECT COUNT(*) AS totalRows FROM &#123;$table&#125;"; $result = mysqli_query ( $link, $query ); if ($result &amp;&amp; mysqli_num_rows ( $result ) == 1) &#123; $row = mysqli_fetch_assoc ( $result ); return $row ['totalRows']; &#125; else &#123; return false; &#125;&#125;/*** 得到结果集的记录条数* @param object $link* @param string $query* @return boolean*/function getResultRows($link, $query) &#123; $result = mysqli_query ( $link, $query ); if ($result) &#123; return mysqli_num_rows ( $result ); &#125; else &#123; return false; &#125;&#125;/*** @param object $link*/function getServerInfo($link) &#123; return mysqli_get_server_info ( $link );&#125;/*** @param object $link*/function getClientInfo($link) &#123; return mysqli_get_client_info ( $link );&#125;/*** @param object $link*/function getHostInfo($link)&#123; return mysqli_get_host_info($link);&#125;/*** @param object $link*/function getProtoInfo($link) &#123; return mysqli_get_proto_info ( $link );&#125; 分页功能的封装与实战操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;?php require_once 'mysql.func.php'; require_once 'config.php'; // 连接 $link=connect3(); // 表名 $table = 'user'; // 总条数 $totalRows = getTotalRows($link,$table); echo $totalRows; // 每页10条 $pageSize = 10; // 总页数 $totalPages = ceil($totalRows/$pageSize); echo $totalPages; // 接受当前页 $page = $_GET['page']?$_GET['page']:1; // 边界处理 if ($page&lt;1||$page==''||!is_numeric($page)) &#123; $page=1; &#125; if ($page&gt;$totalPages) &#123; $page=$totalPages; &#125; // 计算偏移量 $offset = ($page-1)*$pageSize; $query = "SELECT id,username,password,age,regtime FROM &#123;$table&#125; LIMIT &#123;$offset&#125;, &#123;$pageSize&#125;"; $users = fetchAll($link, $query); //var_dump($users); if (!$users) &#123; exit("没有用户数据"); &#125; // 形成用户列表?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;用户列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;用户列表&lt;/h2&gt; &lt;table border="1" width="80%" cellpadding="0" cellspacing="0" bgcolor="#ABCDEF"&gt; &lt;tr&gt; &lt;td&gt;编码&lt;/td&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;注册时间&lt;/td&gt; &lt;/tr&gt; &lt;?php foreach($users as $user):?&gt; &lt;tr&gt; &lt;td&gt;&lt;?php echo $user['id'];?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $user['username'];?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $user['password'];?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $user['age'];?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $user['regtime'];?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;?php endforeach;?&gt; &lt;/table&gt; &lt;p&gt; &lt;?php echo "&lt;a href=mainpage.php?page=1&gt;[首页]&lt;/a&gt;"; $prev = $page == 1 ? 1 : ($page-1); echo "&lt;a href=mainpage.php?page=".($prev)."&gt;[上一页]&lt;/a&gt;"; for ($i=1; $i&lt;=$totalPages ; $i++) &#123; // 当前页无连接 if ($page==$i) &#123; echo "[&#123;$i&#125;]"; &#125; else &#123; echo "&lt;a href='mainpage.php?page=&#123;$i&#125;'&gt;[&#123;$i&#125;]&lt;/a&gt;"; &#125; &#125; $nextv = $page == $totalPages ? $totalPages : ($page+1); echo "&lt;a href=mainpage.php?page=".($nextv)."&gt;[下一页]&lt;/a&gt;"; echo "&lt;a href=mainpage.php?page=$totalPages&gt;[尾页]&lt;/a&gt;"; ?&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2016%2F09%2F22%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[目录 系统安全 进程管理 用户管理 文件系统 网络测试 文件处理 压缩 定时任务（crontab） 系统安全 sudo su chmod setfacl 对某个用户单独设置某个文件的权限 进程管理 top ps kill -9强制杀死 -15正常杀死 pkill killall 用户管理 usermod 修改系统账户文件 useradd groupadd userdel 文件系统 mount umount fsck df du 网络测试 netstat 文件查看 head tail less/more 文件处理 touch unlink rename ln cp 压缩 tar 定时任务（crontab） crontab的使用 at 命令]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第二十九篇——MySQLi入门与常用操作总结]]></title>
    <url>%2F2016%2F09%2F10%2FPHP%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B9%9D%E7%AF%87%E2%80%94%E2%80%94MySQLi%E5%85%A5%E9%97%A8%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[目录 1.数据库 2.SQL语言 3.MySQLi扩展简介 为什么使用MySQLi扩展 MySQLi的安装及配置 4.MySQLi操作数据库步骤 1.连接MySQL 2.设置字符集 3.打开指定数据库 4.执行SQL查询 增 删 改 查 5.释放结果集 6.关闭连接 5.MySQLi常用函数 连接相关 数据操作 预处理操作 结果集相关 事务 数据库 数据库是一某种有组织的方式存储数据或文件的集合，容器 表是一种结构化的文件(特定类型数据的结构化清单)，存储特定类型的数据 模式：描述了数据库和表的布局及特性信息，定义数据在表中如何存储，存储什么样的数据，数据如何分解，各部分信息如何命名 列：表中的一个字段 行：一条记录 主健：一列或一组(多)列，其值能唯一区分表中的每一行。即表示特定的行。习惯：不重用，不更新，不修改 任意两行都不具有相同的值 每一个行都必须具有一个主健值，且不允许为空 数据库的好处：将数据持久化到本地，可以实现结构化查询，方便管理 DB：数据库 DBMS：数据库管理系统/软件 SQL：结构化查询语言，用户和DBMS通讯 MySQL缺点: 并不总是支持其他DBMS提供的功能和特性 存储特点：将数据存储到表中，再将表存储到库中， 一个数据库中多个表，有名字且唯一。 表具有一些特性，定义数据在表中如何存储，类似‘类’。 表由列(字段)组成，类似’属性’. 表中数据按照行存储，类似‘对象’. DBMS分类 基础共享文件系统 基础客户机-服务器软件: 服务器负责所有数据的访问处理软件，客户机与用户打交道的软件。 MySQL在4中引入InnoDB引擎，增加事务处理，改进全文搜索。4.1增加函数库，子查询，集成帮助。5增加存储过程，触发器，游标，视图。 读写分离：路由和分发的DS(datasource) 一个server方法必须定位到一个唯一的数据库上 在应用中需要自己去确定或者高速路由DS,访问的真实目标DS 让路由知道有那些真实的DS和他们的名字对应 让路由根据我传入的名字去返回真实的DataSource 依赖注入容器：就是一个对象，他知道怎么样初始化并配置对象及其依赖的所有对象 SQL语言 DQL：数据库查询语言 基础查询，条件查询，排序查询，常见函数，分组函数，分组查询，连接查询，子查询，分页查询，union查询 DML：数据操作语言 插入，修改，删除 DDL：数据定义语言 库和表管理，常见数据类型，常见约束 TCL：事务控制语言 事务和事务处理 不区分大小写：建议关键字大小，自定义名字小写！分号结尾，索引与换行注释 (#)或(– )或(/ /) 相关操作 显示所有数据库 show databases; 使用(进入)指定数据库 use mysql; 显示库中所有表 show tables; show tables from phpstudy; 选择查询当前所在数据库 select databases(); 创建表： create table t_mysql (id int, name varchar(20)); 删除表： drop table t_mysql; 查看表结构： desc t_mysql; 插入数据： insert into t_mysql (id, name) values (2,”Vivian”); 查询数据库所有字段： select * from t_mysql; 更新数据库： update t_mysql set name=”MySQL” where id=4; 删除表中数据 delete from t_mysql where id=4 or name=”MySQL”; delete from t_mysql; // 删除所有 使用delete删除的数据可以找回使用drop删除的数据找不回来 查看版本： mysql&gt; select version(); MySQLi简介PHP5.4之后mysql扩展废弃，不再更新，官方推荐使用mysqli，mysqli是mysql扩展的增强版，5.4默认支持 #####mysqli功能 操作数据库 面向对象和面向过程 支持预处理 支持多语句 支持事务 MySQLi配置 略过安装，因为默认支持，如果是集成环境，也是不用安装和配置的！ 配置php_mysqli.dll扩展，在php.ini中开启 配置extension_dir=”ext所在目录” 重启服务器 MySQL相关配置 mysqli.max_persistent = -1 可以创建的持久化连接的最大数量，-1代表无限制 mysqli.allow_local_infile = On 允许Mysql的Load Data语句访问PHP角度看的本地文件。 mysqli.allow_persistent = On 开启使用mysqli_connect()函数创建持久化连接的能力 mysqli.max_links = -1 最大连接数，-1代表无限制 mysqli.default_port = 3306 默认端口号3306 mysqli.default_socket = 当连接到本地数据库服务器时如果没有指定其他socket名称，使用的默认socket名称 mysqli.default_host = 当连接到数据库服务器时， 如果没有指定其他主机地址，使用的默认服务器主机。不要在 安全模式下使用 mysqli.default_user = 当连接到数据库服务器时，如果没有指定其他用户名，使用的默认用户名。不要在 安全模式下使用。 mysqli.default_pw = 当连接到数据库服务器时，如果灭有指定其他密码，使用的默认密码。不要在 安全模式下使用。 mysqli.reconnect = Off 连接丢失时是否自动重新连接。 MySQLi检测 phpinfo #php配置 extension_loaded(‘mysqli’) #连接方法 mysqli_connect() # 直接调用 function_exists(‘mysqli_connect’) #是否存在方法 get_defined_functions() #s获取定义的方法 MySQLi操作步骤PHP打开错误提示和关闭错误提示的方法 找到php的配置文件，也就是php.ini 在文件中查找 ‘display_errors’ 查找到 display_errors = Off 或者 display_errors = On， Off为关闭错误提示，On为打开错误提示，根据需求修改即可。 也可在php文件中加入以下代码 123456//禁用错误报告error_reporting(0);//报告运行时错误error_reporting(E_ERROR | E_WARNING | E_PARSE);//报告所有错误error_reporting(E_ALL); 一、建立连接 直接连接 12345678910header('content-type:text/html;charset=utf-8');##### 建立连接: 这里使用MAMP默认提供的mysql和端口$link = mysqli_connect('localhost', 'root', 'root', 'mysqli','8889');var_dump($link);if (!$link) &#123; echo "错误连接"; echo 'ERROR'.mysqli_connect_errno().':'.mysqli_connect_error(); exit();&#125;echo "成功"; 初始化连接 12345678910111213141516171819$link=mysqli_init();if(!$link)&#123; die('MySQLi Init Failed');&#125;设置连接选项if(!mysqli_options($link,MYSQLI_INIT_COMMAND,'SET AUTOCOMMIT=0'))&#123; die('MySQLI Options Failed');&#125;//建立MySQL的连接if(!mysqli_real_connect($link,'localhost','root','root'))&#123; die('Connect Error &lt;br/&gt;'.mysqli_connect_errno().':'.mysqli_connect_error());&#125;if(mysqli_ping($link))&#123; echo 'Connect is Ok';&#125;else&#123; echo 'Error '.mysqli_error();&#125; 查看配置信息 123456789101112131415//得到和MySQL相关信息echo 'MySQL客户端版本信息：'.mysqli_get_client_info($link).'&lt;br/&gt;';echo 'MySQL客户端版本：'.mysqli_get_client_version($link).'&lt;br/&gt;';echo 'MySQL服务器的版本号：'.mysqli_get_server_info($link).'&lt;br/&gt;';echo 'MySQL服务器的版本：'.mysqli_get_server_version($link).'&lt;br/&gt;';echo 'MySQL服务器主机名和连接类型：'.mysqli_get_host_info($link).'&lt;br/&gt;';echo 'MySQL协议的版本信息：'.mysqli_get_proto_info($link).'&lt;br/&gt;';echo '当前系统的状态：'.mysqli_stat($link).'&lt;br/&gt;';echo '当前线程连接ID：'.mysqli_thread_id($link).'&lt;br/&gt;';if(mysqli_thread_safe())&#123; echo '启动安全线程';&#125;else&#123; echo '未启动安全线程';&#125; 错误类型 1》用户名密码不正确 Warning: mysqli_connect(): (HY000/1045): Access denied for user ‘root‘@’localhost’(using password: YES) in G:\maizi\PHPAdvance\MySQLi\2-mysqli_connect.php on line 5bool(false) 2》MySQL服务器没有开启 ERROR 2003 (HY000): Can’t connect to MySQL server on ‘localhost’ (10061)Warning: mysqli_connect(): in G:\maizi\PHPAdvance\MySQLi\2-mysqli_connect.php on line 13bool(false) 抑制错误： @mysqli_connect(‘localhost’, ‘root’, ‘root’, ‘mysqli’,’8889’) or die(‘数据库连接失败ERROR’.mysqli_connect_errno().’:’.mysqli_connect_error()); 12//mysqli_connect_errno():连接产生的错误编号//mysqli_connect_error():连接产生的错误信息 二、设置字符集 命令：SET NAMES GBK mysqli_set_charset($link, ‘UTF8’); mysqli_query($link, ‘SET NAMES UTF8’); print_r(mysqli_character_set_name($link)); // 默认 print_r(mysqli_get_charset($link)); // 获取 三、打开指定数据库$res = mysqli_select_db($link,&apos;mysqli&apos;); # or die(&apos;指定数据库不存在&lt;\br&gt;&apos;.mysqli__errno($link).&apos;:&apos;.mysqli__error($link)); var_dump($res); 执行SQL查询 SQL直接Query创建和插入 123456789101112131415161718执行SQL查询 mysqli_query()执行SQL查询//创建test2数据库// $sql="CREATE DATABASE IF NOT EXISTS test2 DEFAULT CHARACTER SET 'utf8'";// $sql="DROP DATABASE IF EXISTS test2";// mysqli_query($link,$sql);/*mysqli_query($link,$sql):执行SQL查询1》只能执行一条SQL语句，SQL语句可以没有分号 2》mysqli_query()执行SELECT/SHOW/EXPLAIN/DESC/DESCRIBE这样关键字的SQL语句，执行成功返回的是mysqli_result结果集，执行失败返回false；执行其他SQL语句，执行成功返回true，失败返回false */$sql=&lt;&lt;&lt;EOFINSERT user(username,password,age,regTime)VALUES('king1','king1',123,'123123');EOF;$res=mysqli_query($link,$sql);var_dump($res); SQL-Query插入和查询 123456789101112131415161718192021执行SQL查询// $sql='INSERT user(username,password,age,regTime) VALUES("maizi1","maizi1",3,"1234123")';// $sql="INSERT user1(id,username,password,age,regTime) VALUES(8,'queen','queen',14,'123123123')";$sql=&lt;&lt;&lt;EOFINSERT user(username,password,age,regTime) VALUES('maizi11','maizi11',3,'123123'),('maizi12','maizi12',3,'123123'),('maizi13','maizi13',3,'123123'),('maizi14','maizi14',3,'123123'),('maizi15','maizi15',3,'123123');EOF;$res=mysqli_query($link,$sql);if($res)&#123; // mysqli_insert_id($link)：得到上一步插入操作产生的自增长(AUTO_INCREMENT)值,如果表中没有自增长，返回0 $lastInsertId=mysqli_insert_id($link); echo '恭喜您注册成功，您是网站的第'.$lastInsertId.'位用户&lt;br/&gt;'; //mysqli_affected_rows($link):得到上一步操作产生的受影响的记录数 $affectRows=mysqli_affected_rows($link); echo 'Query Ok, '.$affectRows.' Rows Affected';&#125;else&#123; echo 'Insert Error '.mysqli_errno($link).':'.mysqli_error($link);&#125; mysqli_affected_rows 123456789101112执行SQL查询// $sql="INSERT user(username,password,age,regTime) VALUES('AA','AA',12,'123123')";// $sql="UPDATE user SET age=78 WHERE id&lt;=5";$sql="DELETE FROM user324234 WHERE id=9";$res=mysqli_query($link,$sql);echo '受影响的记录数为：'.mysqli_affected_rows($link).'&lt;br/&gt;';/* mysqli_affected_rows($link):得到上一步操作产生的受影响的记录数 大于0的：受影响的记录数 等于0：没有记录被影响 等于-1：代表的SQL语句有问题 */ mysqli_fetch 123456789101112131415161718192021222324252627282930313233343536执行SQL查询$sql="SELECT * FROM user";// $sql="SHOW DATABASES;";// $sql="DESC user";// $sql="DESCRIBE user";// $sql="EXPLAIN SELECT * FROM user WHERE id=12";$result=mysqli_query($link,$sql);//得到结果集中的记录条数echo '结果集中记录条数为：'.mysqli_num_rows($result).'&lt;br/&gt;';echo '上一步操作产生的受影响的记录条数为：'.mysqli_affected_rows($link).'&lt;br/&gt;';echo '结果集中字段数为：'.mysqli_num_fields($result).'&lt;br/&gt;';echo '获得最近一次查询所得到的列数：'.mysqli_field_count($link).'&lt;br/&gt;';echo '&lt;hr color="red"/&gt;';//取得结果集中的记录// mysqli_fetch_row($result):取得结果集中的一条记录作为索引数组返回echo '&lt;pre&gt;';$row=mysqli_fetch_row($result);print_r($row);//mysqli_fetch_assoc($result):取得结果集中的一条记录作为关联数组返回$row=mysqli_fetch_assoc($result);print_r($row);//mysqli_fetch_array($result,$result_type):取得结果集中的一条记录作为关联数组或者索引数组或者二者都有的数组来返回$row=mysqli_fetch_array($result, MYSQLI_ASSOC);/* $result_type的值为： MYSQLI_BOTH:关联+索引 MYSQLI_ASSOC:关联 MYSQLI_NUM:索引 */print_r($row);// mysqli_fetch_object($result):作为对象返回$row=mysqli_fetch_object($result);print_r($row);echo '&lt;hr color="red"/&gt;';var_dump(mysqli_fetch_assoc($result)); 查询并显示用户列表数据 mysqli_fetch 1234567891011121314151617181920212223242526272829执行SQL查询$sql="SELECT * FROM user";//5.得到所有记录$result=mysqli_query($link,$sql);//是结果集，并且结果集中有记录// if($result &amp;&amp; mysqli_num_rows($result)&gt;0)&#123;// while($row=mysqli_fetch_assoc($result))&#123;// $rows[]=$row;// &#125;// &#125;else&#123;// echo '没有记录&lt;br/&gt;';// &#125;// print_r($rows);// if($result &amp;&amp; mysqli_num_rows($result)&gt;0)&#123;// // $rows=mysqli_fetch_all($result);// $rows=mysqli_fetch_all($result,MYSQLI_BOTH);// &#125;// print_r($rows);$string=join('',array_merge(range('a','z'),range('A','Z')));for($i=1;$i&lt;=100;$i++)&#123; $username=substr(str_shuffle($string),0,5); $password=md5($username); $age=mt_rand(1,99); $regTime=time()+10*$i; $sql="INSERT user(username,password,age,regTime) VALUES('&#123;$username&#125;','&#123;$password&#125;','&#123;$age&#125;','&#123;$regTime&#125;')"; mysqli_query($link,$sql);&#125; user_list 1234567891011121314151617181920212223242526272829303132333435执行SQL查询$sql="SELECT id,username,age,regTime FROM user";//5.得到所有记录$result=mysqli_query($link,$sql);if($result &amp;&amp; mysqli_num_rows($result)&gt;0)&#123; $rows=mysqli_fetch_all($result,MYSQLI_ASSOC);&#125;?&gt;&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;用户列表&lt;/h3&gt;&lt;table border='1' cellpadding='0' cellspacing='0' bgcolor='#ABCDEF' width='80%'&gt; &lt;tr&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;注册时间&lt;/td&gt; &lt;/tr&gt; &lt;?php $i=1; foreach($rows as $user):?&gt; &lt;tr&gt; &lt;td&gt;&lt;?php echo $i++;?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $user['username'];?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $user['age'];?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo date("Y-m-d H:i:s",$user['regTime']);?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;?php endforeach;?&gt;&lt;/table&gt; &lt;/body&gt;&lt;/html&gt; mysqli_data_seek 12345678910111213141516171819202122232425262728$sql="SELECT * FROM user";$result=mysqli_query($link, $sql);echo '&lt;pre&gt;';// $row=mysqli_fetch_assoc($result);// print_r($row);// $row=mysqli_fetch_assoc($result);// print_r($row);// $row=mysqli_fetch_assoc($result);// print_r($row);// echo '&lt;hr/&gt;';// //mysqli_data_seek($result,$offset):将结果集的指针移动到指定位置// mysqli_data_seek($result, 0);// $row=mysqli_fetch_assoc($result);// print_r($row);$rows=mysqli_fetch_all($result,MYSQLI_ASSOC);print_r($rows);echo '&lt;hr color="red"/&gt;';mysqli_data_seek($result, 0);$row=mysqli_fetch_assoc($result);print_r($row);echo '&lt;hr color="pink"/&gt;';//释放结果集mysqli_free_result($result);//关闭连接mysqli_close($link);mysqli_set_charset($link,'utf8'); mysqli_field 123456789101112131415161718$sql="SELECT * FROM user";$result=mysqli_query($link, $sql);echo '结果集中字段数：'.mysqli_num_fields($result).'&lt;br/&gt;';echo mysqli_field_count($link).'&lt;br/&gt;';echo '&lt;hr/&gt;';echo '&lt;pre&gt;';// $fieldInfo=mysqli_fetch_field($result);// print_r($fieldInfo);// $fieldInfo=mysqli_fetch_field($result);// print_r($fieldInfo);// $fieldsInfo=mysqli_fetch_fields($result);// print_r($fieldsInfo);echo '当前指针所在位置：'.mysqli_field_tell($result).'&lt;br/&gt;';print_r(mysqli_fetch_field_direct($result, 0)).'&lt;br/&gt;';echo '&lt;hr/&gt;';mysqli_field_seek($result, 3);echo '当前指针所在位置：'.mysqli_field_tell($result).'&lt;br/&gt;'; mysqli_multi_query 1234567//执行多条SQL语句,每条SQL语句一定要以分号结尾，否则就会失败//如果多条SQL语句中有一条失败了，整个都会失败$sql="DELETE FROM user WHERE id=3;";$sql.="INSERT user(username,password,age,regTime) VALUES('AAAA1','AAAAA1',99,'1234123');";$sql.="UPDATE user123 SET age=5 WHERE id=1;";$res=mysqli_multi_query($link,$sql);var_dump($res); mysqli_multi_result 12345678910111213141516$sql ="SELECT id,username,age,regTime FROM user limit 5;";$sql.="SELECT VERSION() AS mysql_version;";$sql.="SELECT NOW() AS time_now;";$sql.="SELECT * FROM mysql.user;";$res=mysqli_multi_query($link, $sql);//mysqli_store_result():传输上一次产生的结果集//mysqli_more_results():判读是否有更多的结果集//mysqli_next_result():将结果集的指针向下移动一位if($res)&#123; do&#123; if($result=mysqli_store_result($link))&#123; $rows[]=mysqli_fetch_all($result,MYSQLI_ASSOC); &#125; &#125;while(mysqli_more_results($link)&amp;&amp;mysqli_next_result($link));&#125;print_r($rows); mysqli_prepare 1234567891011121314151617181920212223242526require_once 'conn.php';$sql="INSERT user(username,password,age,regTime) VALUES(?,?,?,?)";$stmt=mysqli_prepare($link, $sql);//准备要执行的SQL语句// print_r($stmt);$username='maizi123412';$password='maizi123412';$age=3;$regTime=time();@mysqli_stmt_bind_param($stmt, 'ssii',$username,$password,$age);$res=mysqli_stmt_execute($stmt);if(!$res)&#123; die ("ERROR ".mysqli_stmt_errno($stmt).':'.mysqli_stmt_error($stmt));&#125;$username='maizi1234567';$password='maizi1234567';$age=35;$regTime=time();mysqli_stmt_execute($stmt);echo '受影响的记录条数为：'.mysqli_stmt_affected_rows($stmt).'&lt;br/&gt;';echo '得到AUTO_INCREMENT的之为：'.mysqli_stmt_insert_id($stmt).'&lt;br/&gt;';mysqli_stmt_close($stmt);mysqli_close($link); mysqli_stmt_bind_result 1234567891011121314151617require_once 'conn.php';$sql="SELECT id,username,age FROM user WHERE id&lt;=?";if($stmt=mysqli_prepare($link, $sql))&#123; echo mysqli_stmt_param_count($stmt).'个参数&lt;br/&gt;'; $id=143; mysqli_stmt_bind_param($stmt, 'i',$id); mysqli_stmt_execute($stmt); mysqli_stmt_bind_result($stmt,$res_id,$res_username,$res_age);// mysqli_stmt_fetch($stmt);// printf('我的编号为：'.$res_id.'--我的名字为：'.$res_username.'--我的年龄为：'.$res_age); while(mysqli_stmt_fetch($stmt))&#123; printf('我的编号为：'.$res_id.'--我的名字为：'.$res_username.'--我的年龄为：'.$res_age); echo '&lt;hr/&gt;'; &#125; echo '&lt;hr color="red"/&gt;'; &#125; mysqli_stmt_data_seek 1234567891011121314151617require_once 'conn.php';$sql="SELECT id,username,age FROM user WHERE id&lt;=30";if($stmt=mysqli_prepare($link, $sql))&#123; mysqli_execute($stmt); mysqli_stmt_store_result($stmt); echo '受影响的记录条数为：'.mysqli_stmt_affected_rows($stmt).'&lt;br/&gt;'; echo '结果集中的记录条数为：'.mysqli_stmt_num_rows($stmt).'&lt;br/&gt;'; mysqli_stmt_bind_result($stmt,$id,$username,$age); while(mysqli_stmt_fetch($stmt))&#123; echo '编号：'.$id.'--'.'用户名：'.$username.'--年龄：'.$age."&lt;hr/&gt;"; &#125; echo '&lt;hr color="red"/&gt;'; mysqli_stmt_data_seek($stmt, 1); mysqli_stmt_bind_result($stmt,$id,$username,$age); mysqli_stmt_fetch($stmt); echo '编号：'.$id.'--'.'用户名：'.$username.'--年龄：'.$age."&lt;hr/&gt;";&#125; mysqli_commit 1234567891011121314require_once 'conn.php';//关闭自动提交mysqli_autocommit($link, FALSE);$sql="UPDATE account SET money=money-2000 WHERE username='maizi'";$res=mysqli_query($link, $sql);$sql='UPDATE account123 SET money=money+2000 WHERE username="king"';$res1=mysqli_query($link,$sql);if($res &amp;&amp; $res1)&#123; mysqli_commit($link);//提交 mysqli_autocommit($link, TRUE);&#125;else&#123; mysqli_rollback($link);//回滚&#125; reg 12345678910111213141516171819202122232425262728&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;注册页面&lt;/h3&gt;&lt;form action="doAction.php?act=reg" method='post'&gt;&lt;table border='1' width='80%' cellpadding='0' cellspacing='0' bgcolor='#ABCDEF' &gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="username" id="" placeholder='请输入合法用户名'/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type="password" name="password" id="" placeholder='密码不能为空' /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan='2'&gt; &lt;input type="submit" value="注册" /&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/form&gt; &lt;/body&gt;&lt;/html&gt; testFunction 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051header('content-type:text/html;charset=utf-8');require_once 'functions/mysql.func.php';require_once 'config/config.php';// $host='localhost';// $user='root';// $password='root';// $charset='utf8';// $database='test1';// $link=connect1($host, $user, $password, $charset, $database);// var_dump($link);// $link=connect2($config);// var_dump($link);$link=connect3();// var_dump($link);// $array=[// 'username'=&gt;'queen1',// 'password'=&gt;md5('queen1'),// 'age'=&gt;22,// 'regTime'=&gt;time()// ];$table='user';// if(insert($link, $array, $table))&#123;// echo '注册成功';// &#125;else&#123;// echo '注册失败';// &#125;// $array=['age'=&gt;'12'];// // $res=update($link, $array, $table);// $res=update($link,$array,$table,'id=2');// if($res)&#123;// echo '更新成功';// &#125;else&#123;// echo '更新失败';// &#125;// $res=delete($link, $table,'id=3');// if($res)&#123;// echo '删除成功';// &#125;else&#123;// echo '删除失败';// &#125;$query="SELECT id,username,age FROM user WHERE id=1";$row=fetchOne($link, $query);print_r($row);echo '&lt;hr/&gt;';$query="SELECT id,username,age FROM user WHERE id&gt;=1";$rows=fetchAll($link, $query);print_r($rows);echo '&lt;hr/&gt;';echo getTotalRows($link,'user1'); 释放结果集关闭连接MySQLi常见函数连接连接 mysqli_connect() 作用 打开一个到MySQL服务器的新的连接 语法 mysqli mysqli_connect ([ string $host = ini_get(“mysqli.default_host”) [, string $username = ini_get(“mysqli.default_user”) [, string $passwd = ini_get(“mysqli.default_pw”) [, string $dbname = “” [, int $port = ini_get(“mysqli.default_port”) [, string $socket = ini_get(“mysqli.default_socket”) ]]]]]] ) mysqli_real_connect() 作用 建立一个 MySQL 服务器连接 语法 bool mysqli_real_connect ( mysqli $link [, string $host [, string $username [, string $passwd [, string $dbname [, int $port [, string $socket [, int $flags ]]]]]]] ) 注意 mysqli_real_connect() 需要一个有效的对象，这个对象由 mysqli_init() 创建 可以使用 mysqli_options() 设置各种连接设置 提供 flags 参数 mysqli_init() 作用 初始化mysqli并且返回一个由mysqli_real_connect使用的资源类型。 语法 mysqli mysqli_init ( void ) mysqli_options() 作用 设置选项 语法 bool mysqli_options ( mysqli $link , int $option , mixed $value ) 注意 常用选项 mysqli_ping() 作用 ping一个服务器连接，或者如果那个连接断了尝试重连 语法 bool mysqli_ping ( mysqli $link ) 错误 mysqli_connect_errno() 作用 返回最后一次连接调用的错误代码 mysqli_connect_error() 作用 返回一个字符串描述的最后一次连接调用的错误代码 mysqli_errno() 作用 返回最近的函数调用产生的错误代码 语法 int mysqli_errno ( mysqli $link ) mysqli_error() 作用 返回字符串描述的最近一次函数调用产生的错误代码 语法 string mysqli_error ( mysqli $link ) 字符集 mysqli_character_set_name() 作用 返回数据库连接的默认字符集 mysqli_get_charset() 作用 返回对象的字符集 语法 object mysqli_get_charset ( mysqli $link ) mysqli_set_charset() 作用 设置默认的客户端字符集 语法 bool mysqli_set_charset ( mysqli $link , string $charset ) 信息相关 mysqli_get_client_info() 作用 返回字符串类型的Mysql客户端版本信息 语法 string mysqli_get_client_info ( mysqli $link )mysqli_get_client_version() 作用 将 MySQL 客户端库版本作为整数返回 语法 int mysqli_get_client_version ( mysqli $link ) mysqli_get_server_info() 作用 返回MySQL服务器的版本号 语法 string mysqli_get_server_info ( mysqli $link )mysqli_get_server_version() 作用 作为一个整数返回MySQL服务器的版本 语法 int mysqli_get_server_version ( mysqli $link ) mysqli_get_host_info() 作用 返回 MySQL 服务器主机名和连接类型。 语法 string mysqli_get_host_info ( mysqli $link ) mysqli_get_proto_info() 作用 返回使用的Mysql协议的版本信息 语法 int mysqli_get_proto_info ( mysqli $link ) mysqli_stat() 作用 获取当前系统状态 语法 string mysqli_stat ( mysqli $link ) mysqli_thread_id() 作用 返回当前连接的线程ID 语法 int mysqli_thread_id ( mysqli $link ) mysqli_thread_safe() 作用 返回是否设定了线程安全 语法 bool mysqli_thread_safe ( void ) 数据操作数据库 mysqli_select_db() 作用 为数据库查询选择默认数据库 语法 bool mysqli_select_db ( mysqli $link , string $dbname ) 数据 mysqli_query() 作用 执行SQL查询 语法 mixed mysqli_query ( mysqli $link , string $query [, int $resultmode = MYSQLI_STORE_RESULT ] ) 注意 $resultmode值 MYSQLI_USE_RESULT,检索大数据量 MYSQLI_STORE_RESULT,默认值 执行其它查询，成功返回true，失败返回false mysqli_real_query() 作用 执行一个mysql查询 语法 bool mysqli_real_query ( mysqli $link , string $query ) 注意 执行一个单条数据库查询, 其结果可以使用mysqli_store_result()或mysqli_use_result()检索或存储. 可以通过mysqli_field_count()得到结果集的数量 mysqli_multi_query() 作用 在数据库上执行一个多语句查询 mysqli_affected_rows() 作用 得到上一次MySQL操作影响的记录数 语法 int mysqli_affected_rows ( mysqli $link ) mysqli_insert_id() 作用 返回上一插入操作产生的AUTO_INCREMENT的值 语法 mixed mysqli_insert_id ( mysqli $link ) 预处理操作 mysqli_prepare() 作用 准备一个用于执行的SQL语句 语法 mysqli_stmt mysqli_prepare ( mysqli $link , string $query ) mysqli_stmt_bind_param() 作用 将一个变量作为参数绑定到prepared语句上 语法 bool mysqli_stmt_bind_param ( mysqli_stmt $stmt , string $types , mixed &amp;$var1 [, mixed &amp;$… ] ) 注意 $types的值 mysqli_stmt_bind_result() 作用 将一个变量绑定到一个prepared语句上用于结果存储 语法 bool mysqli_stmt_bind_result ( mysqli_stmt $stmt , mixed &amp;$var1 [, mixed &amp;$… ] )mysqli_stmt_execute() 作用 执行一个prepared查询 语法 bool mysqli_stmt_execute ( mysqli_stmt $stmt ) mysqli_stmt_affected_rows() 作用 返回最后一条倍执行的语句改变，删除或插入的总行数 语法 int mysqli_stmt_affected_rows ( mysqli_stmt $stmt ) mysqli_stmt_insert_id() 作用 获取前一个INSERT操作生成的ID 语法 mixed mysqli_stmt_insert_id ( mysqli_stmt $stmt ) mysqli_stmt_errno() 作用 返回最近一次语句调用的错误代码 语法 int mysqli_stmt_errno ( mysqli_stmt $stmt ) mysqli_stmt_error() 作用 返回最后一条语句错误的字符串描述 语法 string mysqli_stmt_error ( mysqli_stmt $stmt ) mysqli_stmt_num_rows() 作用 返回语句结果集中的行数 语法 int mysqli_stmt_num_rows ( mysqli_stmt $stmt ) mysqli_stmt_param_count() 作用 返回给定语句中参数数量 语法 int mysqli_stmt_param_count ( mysqli_stmt $stmt ) mysqli_stmt_data_seek() 作用 查看语句结果集中的任意行 语法 void mysqli_stmt_data_seek ( mysqli_stmt $stmt , int $offset ) mysqli_stmt_fetch() 作用 从一个prepared语句中抓取结果到指定变量中 语法 bool mysqli_stmt_fetch ( mysqli_stmt $stmt ) mysqli_stmt_free_result() 作用 释放给定语句处理存储的结果集所占内存 语法 void mysqli_stmt_free_result ( mysqli_stmt $stmt ) mysqli_stmt_num_rows() 作用 返回结果集中记录的条数 语法 int mysqli_stmt_num_rows ( mysqli_stmt $stmt ) mysqli_stmt_store_result() 作用 从一个prepared语句中传输一个结果集 语法 bool mysqli_stmt_store_result ( mysqli_stmt $stmt ) 结果集 mysqli_use_result() 作用 初始化一个结果集的取回 语法 mysqli_result mysqli_use_result ( mysqli $link ) mysqli_more_results() 作用 检查一个多语句查询是否还有其他查询结果集 语法 bool mysqli_more_results ( mysqli $link ) mysqli_next_result() 作用 从multi_query中准备下一个结果集 语法 bool mysqli_next_result ( mysqli $link ) mysqli_num_rows() 作用 获取结果集中记录条数 语法 int mysqli_num_rows ( mysqli_result $result ) mysqli_fetch_all() 作用 抓取所有的结果行并且以关联数据，数值索引数组，或者两者皆有的方式返回结果集。仅可用于 mysqlnd。 语法 mixed mysqli_fetch_all ( mysqli_result $result [, int $resulttype = MYSQLI_NUM ] ) mysqli_fetch_array() 作用 以一个关联数组，数值索引数组，或者两者皆有的方式抓取一行结果 语法 mixed mysqli_fetch_array ( mysqli_result $result [, int $resulttype = MYSQLI_BOTH ] ) mysqli_fetch_assoc() 作用 以一个关联数组方式抓取一行结果 语法 array mysqli_fetch_assoc ( mysqli_result $result ) mysqli_fetch_row() 作用 以索引数组返回结果集中的一行 语法 mixed mysqli_fetch_row ( mysqli_result $result ) mysqli_fetch_object() 作用 以一个对象的方式返回一个结果集中的当前行 语法 object mysqli_fetch_object ( mysqli_result $result [, string $class_name = “stdClass” [, array $params ]] ) mysqli_data_seek() 作用 将结果中的结果指针调整到任意行 语法 将结果中的结果指针调整到任意行 mysqli_field_count() 作用 返回最近一次查询获取到的列的数目 语法 int mysqli_field_count ( mysqli $link ) mysqli_num_fields() 作用 获取结果中字段数量 语法 int mysqli_num_fields ( mysqli_result $result ) mysqli_fetch_field() 作用 从结果集中取得下一字段（列），并作为对象返回 语法 mysqli_fetch_field(result); mysqli_fetch_fields() 作用 返回一个代表结果集字段的对象数组 语法 array mysqli_fetch_fields ( mysqli_result $result ) mysqli_field_seek() 作用 设置结果指针到特定的字段开始位置 语法 bool mysqli_field_seek ( mysqli_result $result , int $fieldnr ) mysqli_field_tell() 作用 获取当前字段在结果集指针中的开始位置 语法 int mysqli_field_tell ( mysqli_result $result ) mysqli_fetch_field_direct() 作用 抓取一个单字段的元数据 语法 object mysqli_fetch_field_direct ( mysqli_result $result , int $fieldnr ) 事务 mysqli_autocommit() 作用 打开或关闭数据库的自动提交功能 语法 bool mysqli_autocommit ( mysqli $link , bool $mode ) mysqli_commit() 作用 提交当前事务 语法 bool mysqli_commit ( mysqli $link ) mysqli_rollback() 作用 回滚当前事务 语法 bool mysqli_rollback ( mysqli $link )]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux软件管理]]></title>
    <url>%2F2016%2F09%2F07%2FLinux%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[包管理工具上，影响最大的两个系列，就是debian的dpkg包和Red Hat的rpm包两大系列。 dpkg系的前端工具是apt，用于Debian系统及其衍生系统如Ubuntu系统，以及Ubuntu的衍生系统如LinuxMint。 rpm系的影响更广，主要有两大分支： zypper：用于OpenSUSE系统。OpenSUSE上还有强大的yast2工具 yum：用于CentOS系统。 dnf：由于yum很久不维护，所以Fedora使用了yum的一个新的分支dnf 【1】软件包管理在系统管理中，软件包的管理是最重要的，是系统管理的基础的基础，只有我们学会软件包的管理才能谈得上其它的应用。 RPMRPM是软件管理程序，提供软件的安装、升级、查询、反安装的功能。 优点： a、安装方便，软件中所有数据都经过编译和打包 b、查询、升级、反安装方便 缺点： a、缺乏灵活性 b、存在相依属性 用法： rpm 参数 软件包 指令选项 -i：安装。 -U：升级安装，如果不存在也安装。 -F：更新安装，如果不存在不安装。 -v：查看信息。 -h：有进度条。 --replacepkgs：强制覆盖安装。 --nodeps：不考虑相依属性。 -q &lt;软件名&gt;：查询。 -qa：查询所有。 -ql &lt;软件名&gt;：列出软件的文件清单。 -qi &lt;软件名&gt;：列出软件信息。 -qf &lt;文件名&gt;：查询文件所属软件。 -e &lt;软件名&gt;：删除软件。 例子： rpm -ivh bind-9.3.6-4.P1.el5_4.2.i386.rpm#安装 rpm -Uvh/Fvh bind-9.3.6-4.P1.el5_4.2.i386.rpm #升级安装 rpm -e bind-9.3.6-4.P1.el5_4.2.i386 #删除软件包 rpm -qpi *.rpm #查看软件包里的内容 rpm -qpl *.rpm #查看软件包将会在系统里安装哪些部分 rpm –qa #列出所有被安装的rpm 软件包 【2】YUMyum = Yellow dog Updater, Modified主要功能是更方便的添加/删除/更新RPM包.它能自动解决包的倚赖性问题. 它能便于管理大量系统的更新问题 yum特点 可以同时配置多个资源库(Repository) 简洁的配置文件(/etc/yum.conf) 自动解决增加或删除rpm包时遇到的倚赖性问题 使用方便 保持与RPM数据库的一致性 yum配置挂载光盘文件到硬盘 mkdir –p /mnt/cdrom chmod 777 /mnt mount -t iso9660 /dev/cdrom /mnt/cdrom 配置/etc/yum.repos.d/server.repo [cdrom] name=cdrom baseurl=file:///mnt/cdrom enabled=1 清除原有的yum信息 [root@localhost ~]# yum clean all 查看yum 信息 [root@localhost ~]# yum list 创建本地YUM仓库 ① 新建一个目录——该目录作为软件仓库，将光盘中的rpm包（位于Packages文件夹）保存到该目录下。 ② 对该目录内的rpm软件包建立索引：createrepo -v /rpm-directory，创建该目录下的rpm包索引，索引创建完成后，会在该文件夹下出现一个repodata目录，里面保存了仓库索引信息。 注：第②步中的createrepo工具在默认情况下是没有安装的，需要自己手动安装（Packages中已包含createrepo安装包），安装方法如下：rpm -ivh createrepo-…….rpm。安装createrepo需要手动解决依赖关系。（createrepo工具主要用于收集目录中RPM包文件的头信息，以创建repodata软件仓库数据（经gzip压缩的xml文件）） ③在/etc/yum.repos.d目录下 新建一个.repo文件，其中baseurl = file:///rpm-directory 绝对路径 ④清理一下yum缓存yum clean all，列出所有的软件包yum list all，查看是否成功。 yum管理软件yum install –y software #安装软件 yum update -y software #更新软件 yum remove -y software #删除软件 yum list #列出资源库中特定的可以安装或更新以及已经安装的rpm包 yum grouplist # 累出所有软件包群组 yum groupinstall ‘包群组名’ # 安装软件包群组 yum groupremove ‘包群组名 yum info 包名 #查看软件包信息 yum search 包名 # 搜索 yum clean all #清除缓存 yum添加163源地址： http://mirrors.163.com/.help/centos.html 下载方式： wget http://mirrors.163.com/.help/CentOS6-Base-163.repo 【3】apt-get用Linux apt-get命令的第一步就是引入必需的软件库，Debian的软件库也就是所有Debian软件包的集合，它们存在互联网上的一些公共站点上。把它们的地址加入，apt-get就能搜索到我们想要的软件。/etc/apt/sources.list是存放这些地址列表的配置文件，其格式如下： deb [web或ftp地址] [发行版名字][main/contrib/non-free] 我们常用的Ubuntu就是一个基于Debian的发行 命令： apt-get update：在修改/etc/apt/sources.list或者/etc/apt/preferences之后运行该命令。此外您需要定期运行这一命令以确保您的软件包列表是最新的。 apt-get install packagename：安装一个新软件包 apt-get remove packagename：卸载一个已安装的软件包（保留配置文件） apt-get –purge remove packagename：卸载一个已安装的软件包（删除配置文件） apt-get autoclean apt：会把已装或已卸的软件都备份在硬盘上，所以如果需要空间的话，可以让这个命令来删除你已经删掉的软件 apt-get clean：这个命令会把安装的软件的备份也删除，不过这样不会影响软件的使用的。 apt-get upgrade：更新所有已安装的软件包 apt-get dist-upgrade：将系统升级到新版本 apt-get autoclean：定期运行这个命令来清除那些已经卸载的软件包的.deb文件。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP中常用设计模式记录]]></title>
    <url>%2F2016%2F09%2F02%2FPHP%E4%B8%AD%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[单例模式 不通过构造方法获取实例 有一个静态属性保存自身 暴露一个公共方法来获取实例（判断是否有实例，没有就new，有就直接返回） 12345678910111213141516class SingleTon &#123; private static $instance; private function __construct() &#123; &#125; public function getInstance() &#123; if(!self::$instance instanceof self) &#123; self::$instance = new self(); &#125; return self::$instance; &#125; &#125; 工厂模式 通过不同的参数来返回不同的对象实例 被返回的实例通常是同一功能的不同实现 123456789101112131415161718192021222324252627282930313233343536interface Login &#123; function verify();&#125;require_once &apos;./IFactory.php&apos;;class PasswordLogin implements Login &#123; public function verify() &#123; // 密码登录 &#125;&#125;require_once &apos;./DomainLogin.php&apos;;require_once &apos;./PasswordLogin.php&apos;;class LoginFactory &#123; public static function getLoginFactory($type) &#123; if($type == &apos;domain&apos;) &#123; return new DomainLogin(); &#125;else if($type == &apos;pass&apos;) &#123; return new PasswordLogin(); &#125;else &#123; throw new Exception(&apos;class not found&apos;); &#125; &#125;&#125;require_once &apos;./IFactory.php&apos;;class DomainLogin implements Login &#123; public function verify() &#123; // 域名验证登录 &#125;&#125; 命令链模式以松散耦合主题为基础，发送消息、命令和请求，或通过一组处理程序发送任意内容。 每个处理程序都会自行判断自己能否处理请求。如果可以，该请求被处理，进程停止。 我们可以为系统添加或移除处理程序，而不影响其他处理程序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445interface ICommand &#123; function onCommand($name, $args);&#125;class CommandChain &#123; private $_commands = []; public function addCommand($cmd) &#123; $this-&gt;_commands = $cmd; &#125; public function runCommand($name, $args) &#123; foreach($this-&gt;_commands as $command) &#123; if($command-&gt;onCommand($name, $args)) &#123; return; &#125; &#125; &#125;&#125;class UserCommand implements ICommand &#123; public function onCommand($name, $args) &#123; if($name != &apos;addUser&apos;) return false; echo &quot;user handind! \n&quot;; return true; &#125;&#125;class MailCommond implements ICommand &#123; public function onCommand($name, $args) &#123; if($name != &apos;addMail&apos;) return false; echo &quot;mail handind! \n&quot;; return true; &#125;&#125;$chain = new CommandChain();$chain-&gt;addCommand(new UserCommand());$chain-&gt;addCommand(new MailCommond());$chain-&gt;runCommand(&apos;addUser&apos;, null);$chain-&gt;runCommand(&apos;addMail&apos;, null); 观察者模式： 一个对象通过添加一个方法（该方法允许另一个对象，即观察者 注册自己）使本身变得可观察。 当可观察的对象更改时，它会将消息发送到已注册的观察者。这些观察者使用该信息执行的操作与可观察的对象无关。 结果是对象可以相互对话，而不必了解原因。 123456789101112131415161718192021222324252627282930313233interface IObserver &#123; function onChange($sender, $args);&#125;interface IObservable &#123; function addObserver($observer);&#125;class UserList implements IObservable &#123; private $_obervers = []; public function addCustomer($name) &#123; foreach($this-&gt;_obervers as $oberver) &#123; $oberver-&gt;onChange($this, $name); &#125; &#125; public function addObserver($observers) &#123; $this-&gt;_obervers = $observers; &#125;&#125;class UserListLogger implements IObserver &#123; public function onChange($sender, $args) &#123; echo &quot;&#123;$args&#125; added to user list \n&quot;; &#125;&#125;$ul = new UserList();$ul-&gt;addObserver(new UserListLogger());$ul-&gt;addCustomer(&quot;haobin&quot;);]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第二十八篇——接口设计规范]]></title>
    <url>%2F2016%2F08%2F25%2FPHP%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AB%E7%AF%87%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[任何事情都有规律可行，也有一定的规范性，但是认识或的，规范是死的，能够灵活应用就够了。比如iOS，Android，前段等等一些开发过程中都会有一些规范可寻，按照一定的规范写出来的东西能够更容易迭代与修复问题，更容易给后面的人接手…… 接口设计规范这里大概整理了一下APP开发接口的一些规范，我们可以根据实际开发，实际需求做相应的调整。 1.制定规范开发前一定要定好一个规范，比如要定好数据返回的通用参数和格式。 关于数据格式，用的比较多的有xml和json，我建议用json，因为json比xml的好处更多。 2.精简的返回数据接口数据因符合需要什么返回什么的原则，比如要查询某个用户的余额和注册时间，网页里面的做法可能是select * from user where uid=1，但是接口一定要select balance,regtime from user where uid=1。 因为接口返回数据是要有开销的，要流量的，能少返回数据就尽量少返回，这样可以大大的提高性能。 3.数据类型要严格要注意数据的类型，整数类型的数据一定要转为int， 因为app客户端开发的java、object-c语言对数据类型比较严格，类型不对会照成app闪退。 4.要写接口文档一定要写好接口文档，并按照模块写，而且还要书写规范，最好的格式是： 接口请求地址； 请求参数（包括参数名、类型、是否必填）； 测试参数举例；返回参数（参数名，并注明每个参数的含义）。 这样哪怕以后项目很大，以不会照成维护困难的问题。 5.保证代码正确性要验证保证代码正确无误，而且生成环境中要屏蔽掉错误，避免头部有额外的输出，照成返回的json等数据解析失败而导致app闪退等。 6.要优化代码的性能app要求响应迅速，这样才能给用户比较好的体验感。所以移动接口端在处理业务逻辑的时候，要避免不要执行太复杂的sql语句，或者含有大量的循环，能做成缓存的尽量做缓存，比如将首页的热点模块信息可以存到redis缓存中。 在不考虑网速的情况下，比较理想的接口响应时间应该是200毫秒以内。 7.不要随意更改旧接口app不像网页，app一旦发布，有人使用之后，接口就不要乱修改了。 以后升级也是，修改要在保证接口原有结构之上进行额外的扩展，否则会导致调用旧版接口的app出现bug。 8. 注意接口的安全安全高于一切，必须要保证接口的安全。 电话号码等敏感信息在传输的过程中一定要加密，否则可能会被别人抓包到。 拿取用户信息的接口一定要验证权限，以防止接口被恶意调用，泄密用户信息，甚至篡改信息。 处于安全考虑，应当在传值的时候加个验证字段，比如…?token=wedwdwfwf,将token值进行判断后再决定是否给予返回值，你还可以参考一下微信的借口，给用户提供了一个appid和appkey，token值需要根据这两个值去获取，并且获取到的token2小时的有效期，从很大程度上提高了安全性。 希望对你实际开发中有用！！！]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第二十七篇——服务器500错误总结]]></title>
    <url>%2F2016%2F08%2F20%2FPHP%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E7%AF%87%E2%80%94%E2%80%94%E6%9C%8D%E5%8A%A1%E5%99%A8500%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[之前做客户端开发的时候，经常出现500错误，当时能做的就是告诉后台：某某api出现了500，然后没有几分钟就好了。而且一个项目下来出现最多次数的也就是500…… 500错误接触了服务器开发之后，自己在写一些简单接口的时候，也总是发现500，而且几乎所有的500都不是一样原因导致，所以就找了一些教程，并请教了有些大神，自己在接口开发中也掌握了不少相关了技巧。 如果你在学习或者开发中也遇到了，比较奇葩500错误，可以联系我，我们一起交流讨论，一并整理出来。 出现500错误的原因是很多的，一般来说，如果程序出错，那么在浏览器内会返回给用户一个友好的错误提示，统一称之为服务器500错误。 解决的方法就是您必须在http中能够正确的获得错误信息，方法为：请打开浏览器，选择工具，internet选项，高级，在高级中的浏览项目里面有一个\&quot;显示http友好错误提示\&quot;的复选框，请取消该复选框，这样您可以获得正确的错误提示。 在获得正确的错误提示之后，您就可以根据该错误提示检查您具体的出错原因了 HTTP 500错误一定是你的PHP代码有错误，PHP解释器执行不了。两个方法找错误 1) 用有语法检查提示的编辑器，比如Eclipse打开你的文件看看有没有错误提示，注意require里面的文件也要检查 2) 加error_log(&quot;error_message&quot;, 3, &quot;log.txt&quot;);在你想输出信息的地方，用这种方式找代码哪句有问题。 当我我们一定时常注意log的日志，因为大部分错误或者异常在log都能清楚，或者通过分析找到问题所在并解决 1 先看nginx error.log 指定的错误日记文件路径 找到这个日记文件看 里面信息 2 再看 php-fpm.conf 里面指定的PHP错误日记的路径 具体如下php_flag[display_errors] = off php_admin_flag[log_errors] = on php_admin_value[error_log] = /data/logs/fpm-php.log 在网上找到一段话，这是在windows上开发的时候出现的问题及解决方案，当然Mac上也差不多1、运行的用户数过多，对服务器造成的压力过大，服务器无法响应，则报HTTP500错误。减小用户数或者场景持续时间，问题得到解决。 2、该做关联的地方没有去做关联，则报HTTP500错误。进行手工或者自动关联，问题得到解决。 3、录制时请求的页面、图片等，在回放的时候服务器找不到，则报HTTP500错误，若该页面无关紧要，则可以在脚本中注释掉，问题将会得到解决。例如：有验证码的情况下，尽管测试时已经屏蔽了，但是录制的时候提交了请求，但回放的时候不存在响应。 4、参数化时的取值有问题，则报HTTP500错误。可将参数化列表中的数值，拿到实际应用系统中进行测试，可排除问题。 5、更换了应用服务器（中间件的更换，如tomcat、websphere、jboss等），还是利用原先录制的脚本去运行，则很可能报HTTP500错误。因为各种应用服务器处理的机制不一样，所录制的脚本也不一样，解决办法只有重新录制脚本。 6、Windowsxp2 与ISS组件不兼容，则有可能导致HTTP500错误。对ISS组件进行调整后问题解决。 7、系统开发程序写的有问题，则报HTTP500错误。例如有些指针问题没有处理好的，有空指针情况的存在。修改程序后问题解决。 8、如果测试中所进行的操作涉及到数据库，如插入数据操作，若大数据量的情况下导致数据库中表空间已满，或者数据库连接池较小无法满足数据的存取等，都有可能导致HTTP500错误。调整数据库、修改连接池大小，问题解决。 下面是某教程网站上在Nginx上出现的一个棘手的500错误。。原文地址：https://www.phpxy.com/article/109.html 产生原因：恢复aliyun阿里云的镜像，发现不论如何访问服务器都提示500 出现了问500错误，第一件事情要处理的是查看日志。1. 日志系统是否记录了日志 2. 发现日志系统未记录日志，所以说不好去发现问题。 3. 解决nginx未记录日志的问题，在/usr/local/nginx/conf/vhost/ uluqu.com.conf下增加error_log选项指定至目录 4. 发现nginx无法启动，错误提示 /var/log/nginx 目录未存在 5.使用mkdir 创建/var/log/nginx 目录 6. 重新启动nginx,php-fpm等，发现解决成功 7. 打开错误日志目录，发现日志已生成 8.访问 www.uluqu.com/index.php 和phpinfo.php 页面，查看日志中记录的两项错误 9. 错误提醒分别为php parse error define错误，第二个是发现 memory allowed limit 类的错误。分析原因是内存不足或者未合理管理内存造的。 10. 清理服务器内存 free -m 然后执行echo 1 &gt; /proc/sys/vm/drop_caches 11. 再次判断可能因为php.ini文件出错，解决办法：修改php.ini中的memroy_limit参数 12. 经查发现memroy_limit 这个参数写的是512而不是512M。修改参数，重启相关服务。 13. 访问地址问题解决 在运行PHP程序，通常会遇到“Fatal Error： Allowed memory size of xxxxxx bytes exhausted”的错误， 这个意味着PHP脚本使用了过多的内存，并超出了系统对其设置的允许最大内存。 解决这个问题，首先需要查看你的程序是否分配了过多的内存，在程序没有问题的情况下，你可以通过一下方法来增加PHP的内存限制（memory_limit）。 检查php的内存限制值为了查看这个值，你需要建立一个空的php文件，比如view-php-info.php。然后将一下代码贴到里面。 memory_limit应该设为多少？这个完全依赖于你的应用的要求。比如Wordpress，运行起核心代码需要32MB。Drupal 6则要求这个值最小为16MB，并推荐设置为32MB。如果你又安装不少的插件（plugins），尤其是那些要进行图像处理的模块，那么你可能需要128MB或更高的内存。 方法1： php.ini最简单或常用的方法是修改php.ini 1.首先找到对你的网站生效的php.ini文件 由于有多个地方都可以设置php的参数，找到正确的配置文件，并进行更改是首先要做的一步。对于Linux用户，你可以通过执行“php -i | grep Loaded Configuration File”来找到对应的配置文件。而Windows用户，你可以尝试修改你的php安装目录下的php.ini。 2.编辑php.ini 在php.ini中，找到“memory_limit”这一项，如果没有，你可以在文件的尾部自己增加这个参数。以下是一些设置范例memory_limit = 128M ; 可以将128M改为任何你想设置的值,保存文件 3.重启web 服务器 如果是web服务器使用Apache， 则执行：httpd restart 有些情况下，你可能不被允许私修改php.ini。比如如果你购买了虚拟主机服务，但是你的服务商确禁止你修改这个文件。那么，你可以需要考虑用其他方法来增加memory_limit的值。 方法2： .htaccess说明： 这种方法只有在php以Apache模块来执行时才生效。 在你的网站的根目录下找到“.htaccess”文件，如果没有，可以自己创建一个。然后把以下配置放入其中 php_value memory_limit 128M ; 可以将128M改为任何你想设置的值 方法3： 运行时修改php的内存设置在你的php代码中增加以下命令行即可。ini_set(&apos;memory_limit&apos;,&apos;128M&apos;); memory_limit修改失败如果你使用虚拟主机，有可能会出现memory_limit的值修改失败。这个需要联系你的服务商看怎么处理，通常他们限制了可以设置的最大值或者根本就不允许你修改。如果他们的环境真的无法满足你的要求，那么你可能要考虑换一个主机服务商。 生产环境下故障处理一例现象说明：生产环境下，storage服务器上没有安装任何服务（如apache，nginx，IIS等）现在是纯命令行执行PHP跑PHP脚本，在脚本的执行过程中发现（脚本内容含每次取5000个文件然后执行其它操作）速度奇慢，在本地测试时分分钟内搞定的事，在线上要执行2个多小时，经过排查排除掉服务器负载问题、数据库问题、服务器网络问题后，认为可能是php.ini配置文件中的资源限制所引起，于是修改了一下memory_limit将默认值128M修改为1024M后再次执行原脚本，速度得到大幅度提升，现把此参数的含义说明一下。 修改后需不需要重启？因为PHP没有守护进程一说，理论上你只要修改过以后，就会立即使用新的配置文件。 此值设置多大为好？建议根据应用需求来设置。物理服务器，如果内存够大的话建议限制内存较大一些如512M，1024M都可，如果是VPS之类的可能限制在128（默认）64M或者以下是比较合适的，特别是有web服务器的时候，一旦开启多个php的fast-cgi，估计服务器都卡的不动了。 参数语法memory_limit integer 本指令设定了一个脚本所能够申请到的最大内存字节数。 指令作用这有助于防止写得不好的脚本消耗光服务器上的可用内存。 在phpchina的论坛上，有人这样说：memory_limit是设置PHP使用内存时空间，一般设置为内存的四分之一，应该就差不多了。如512M内存设置128M,1G内存设置256M。 设置太大会影响系统速度，因为系统和数据库及其他程序同样需要内存空间，一般系统和数据库内存空间是自己分配的。 附三种修改方法可能是分词程序的问题。只要搜索的字段达到十个汉字以上，就会出现诸如以下的错误 Fatal error: Allowed memory size of 2345643 bytes exhausted 上网找了方法。有3种办法。 1.直接修改PHP.INImemory_limit = 16M ; 但是我修改了没有用。据说是要重启服务器的。但是很显然。我的 是虚拟主机。所以有独立主机的可以这样修改。 2.修改.htaccessphp_value memory_limit 16M 修改后直接出现500错误。可能是主机商限制 3.直接在程序页面上修改。ini_set(’memory_limit’, ‘16M‘);]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第二十六篇——APP接口是怎么来的？]]></title>
    <url>%2F2016%2F08%2F08%2FPHP%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AD%E7%AF%87%E2%80%94%E2%80%94APP%E6%8E%A5%E5%8F%A3%E6%98%AF%E6%80%8E%E4%B9%88%E6%9D%A5%E7%9A%84%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[学了差不多一个月的PHP，总想找个机会试试手，因为工作的原因每天能抽出来的时间真心少，这两天就开始在进行真正的PHP接口开发学习了，到今天为止，我终于知道我做iOS开发的时候发送请求返回的数据是这么来的…… APP接口PHP开发APP接口 APP接口开发 APP接口简介 封装通讯接口方法 核心技术 APP接口实例 接口请求流程 客户端-发送GET/POST请求-服务端-数据库/缓存-调用APP接口-客户端 APP接口简介 接口地址(url) ==== 函数名 GET或POST数据 ==== 函数的参数 这个接口输出的数据 ===== 函数的返回值 API概述 1、API 比开发 WEB 更简洁，但可能逻辑更复杂，API 只返回结果，也就是只完成数据输出，不呈现页面， 2、WEB 开发，更多的是 GET 和 POST 请求，API 还有 PUT、DELETE 请求 3、和 WEB 开发一样，首先需要一些相关的参数，这些参数，都会由客户端传过来，也许是 GET 也许是 POST，这个需要开发团队相互之间约定好，或者制定统一规范 4、有了参数，根据应用需求，完成数据处理，例如：获取用户信息、发朋友圈、发消息、一局游戏结束数据提交等等 5、数据逻辑处理完之后，返回客户端所需要用到的相关数据，例如：用户信息数组、朋友圈列表、消息状态、游戏结果数据等等，那数据是怎么返给客户端呢？常见有XML、JSON，设置相应的header并把要返回的数据直接打印出来即可 6、客户端获取到你返回的数据后，在客户端本地和用户进行交互 APP接口介绍首先要区别去面向对象中的接口 面向对象中的接口是一个抽象类，如PHP或者java中使用interface，iOS中使用的@interface，这里起到的是一个标准或者规范，适合多人开发使用。 APP中的接口：是指数据接口 APP发送HTTP请求，服务器根据请求的参数返回对应的接口数据，客户端解析数据并显示，客户端并不需要关心接口数据是这么实现的，这么返回的，只要发送请求根据返回的数据解析使用就可以！ 接口：包括接口地址，接口文件，接口数据 如何进行通讯 -&gt;需要有一个客户端APP -&gt;触发客户端APP的时候 -&gt;发送HTTP对应的地址GET/POST请求 -&gt;发送给服务端 -&gt;服务端收到接口请求之后会做相应的处理 -&gt;比如从数据库/缓存读取对应的数据 -&gt;返回给客户端 -&gt;客户端收到服务器返回的数据 -&gt;开始解析成自己想要的格式（XML、JSON） -&gt;显示到界面上 通讯格式区别JSON的定义 一种轻量级的数据交换格式，具有良好的可读和便于快速编写的特性。业内主流技术为其提供了完整的解决方案（有点类似于正则表达式 ，获得了当今大部分语言的支持），从而可以在不同平台间进行数据交换。JSON采用兼容性很高的文本格式，同时也具备类似于C语言体系的行为。 XML的定义 扩展标记语言 (Extensible Markup Language,XML) ，用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。 XML是标准通用标记语言 (SGML) 的子集，非常适合 Web 传输。XML 提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据。 XML优缺点 缺点 1. 格式统一, 符合标准 2. 容易与其他系统进行远程交互, 数据共享比较方便 缺点: 1. XML文件格式文件庞大, 格式复杂, 传输占用带宽 2. 服务器端和客户端都需要花费大量代码来解析XML, 不论服务器端和客户端代码变的异常复杂和不容易维护 3. 客户端不同浏览器之间解析XML的方式不一致, 需要重复编写很多代码 4. 服务器端和客户端解析XML花费资源和时间 JSON优缺点 那么除了XML格式, 还有没有其他格式, 有一种叫做JSON(JavaScript Object Notation) 的轻量级数据交换格式能够替代XML的工作. 优点: 1. 数据格式比较简单, 易于读写, 格式都是压缩的, 占用带宽小 2. 易于解析这种语言, 客户端JavaScript可以简单的通过eval_r()进行JSON数据的读取 3. 支持多种语言, 包括ActionScript, C, C#, ColdFusion, Java,JavaScript, Perl, PHP, Python, Ruby等语言服务器端语言, 便于服务器端的解析 4. 在PHP世界, 已经有PHP-JSON和JSON-PHP出现了, 便于PHP序列化后的程序直接调用. PHP服务器端的对象、数组等能够直接生JSON格式, 便于客户端的访问提取. 5. 因为JSON格式能够直接为服务器端代码使用, 大大简化了服务器端和客户端的代码开发量, 但是完成的任务不变, 且易于维护 缺点: 1. 没有XML格式这么推广的深入人心和使用广泛, 没有XML那么通用性 2. JSON格式目前在Web Service中推广还属于初级阶段 JSON 和 XML 优缺点的比较 1. 在可读性方面，JSON和XML的数据可读性基本相同。JSON和XML的可读性可谓不相上下，一边是建议的语法，一边是规范的标签形式，很难分出胜负。 2. 在可扩展性方面，XML天生有很好的扩展性，JSON当然也有，没有什么是XML能扩展，JSON不能的。 3. 在编码难度方面，XML有丰富的编码工具，比如Dom4j、JDom等，JSON也有json.org提供的工具，但是JSON的编码明显比XML容易许多，即使不借助工具也能写出JSON的代码，可是要写好XML就不太容易了。 4. 在解码难度方面，XML的解析得考虑子节点父节点，让人头昏眼花，而JSON的解析难度几乎为0。这一点XML输的真是没话说。 5. 在流行度方面，XML已经被业界广泛的使用，而JSON才刚刚开始，但是在Ajax这个特定的领域，未来的发展一定是XML让位于JSON。到时Ajax应该变成Ajaj(AsynchronousJavascript and JSON)了。 6. JSON和XML同样拥有丰富的解析手段。 7. JSON相对于XML来讲，数据的体积小。 8. JSON与JavaScript的交互更加方便。 9. JSON对数据的描述性比XML较差。 10. JSON的速度要远远快于XML。 protocol buffer 现在还有一种据说是比较流行，但是目前还没有PHP的API，叫做protocol buffer protocol buffer是google的一个开源项目,它是用于结构化数据串行化的灵活、高效、自动的方法，例如XML，不过它比xml更小、更快、也更简单。你可以定义自己的数据结构，然后使用代码生成器生成的代码来读写这个数据结构。你甚至可以在无需重新部署程序的情况下更新数据结构。 对于protocol buffer网上确实有不少好评，但是目前只有C++，java，python的API，希望以后有机会能试一试效果。 APP接口做的那些事获取数据：从数据库中或者缓存中获取数据，然后通过接口数据返回给客户端提交数据：通过接口提交数据给服务器。然后服务器入库处理，或者其他处理 获取数据：GET请求 界面显示数据，首页，广场，用户信息...... 提交数据：POST请求 提交反馈，注册登录，修改用户信息...... 封装通讯接口方法JSON方式封装通讯接口一. 生成JSON数据——数组方式 首先必须知道PHP生成接口数据的方法是json_encode($value),这个方法只能接口UTF-8编码数据，其他格式数据会返回null 首先我们定义一个简单的数组，然后使用json_encode方法将数组转成json数据 $arrayName = array( &apos;id&apos; =&gt; 1, &apos;name&apos; =&gt; &apos;iCocos&apos; ); echo $arrayName; echo json_encode($arrayName); 浏览器输入对应的链接地址，答应结果 Array Array{&quot;id&quot;:1,&quot;name&quot;:&quot;iCocos&quot;} 当然如果你不是UTF8编码数据，可以使用字符编码之间转换函数iconv()，将对应的编码转成自己想要的编码 iconv(&apos;原始编码&apos;,&apos;目标编码&apos;,&apos;数据变量&apos;) 二. 通讯数据的标准格式 一般来说规范一点的后台开发人员都会有一套自己的标准 code 状态吗（2XX-成功, 3XX重定向, 4XX客户端错误, 5XX服务器错误） message 提示信息 data 返回数据 id : 1 name : iCocos 如果你是做移动端的，到公司发现你们后台返回连这种标准都没有，哪怕是类似的，那么不用多说，建议还是闪人吧！ 三. 下面我们简单的实战一下 首先定义一个工具类，用来把传递进来的数据和相应的信息转换成json，然后输出 定义一个PHPResponse.php文件，并且定义一个PHPResponse类，在类里面定义一个静态方法，并且简单的实现一些逻辑处理就进行转换输出 &lt;?php /** * 相应类 */ class PHPResponse { //返回JSON数据方法 public static function jsonData($code, $message = &apos;&apos;, $data = array()) { //如果code不是数字 if (!is_numeric($code)) { # code... return &apos;&apos;; } $res = array( &apos;code&apos; =&gt; $code, &apos;message&apos; =&gt; $message, &apos;data&apos; =&gt; $data ); echo var_dump($res); //echo json_encode($res); exit(); //exit; } } 因为这里只是简单的测试，所以在index.php中引入对应的文件，然后传递数据和对应的参数进上面的方法 require_once(&apos;./PHPResponse.php&apos;); $arrRes = array( &apos;id&apos; =&gt; 1, &apos;name&apos; = &apos;iCocos&apos; ); PHPResponse::jsonData(200, &apos;成功&apos;, $arrRes); 浏览器输入对应的路径，就能看到真实的数据返回 array(3) { [&quot;code&quot;]=&gt; int(200) [&quot;message&quot;]=&gt; string(6) &quot;成功&quot; [&quot;data&quot;]=&gt; array(2) { [&quot;id&quot;]=&gt; int(1) [&quot;name&quot;]=&gt; string(6) &quot;iCocos&quot; } } 生成XML数据 组装字符串 使用系统类 DomDocument XMLWrite SimpleXML 这里使用字符串的方式，其实在学习iOS的时候就有了解过这一点： public static function xmlToEncode($data) { $xml = &quot;&lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos;?&gt;\n&quot;; $xml = &quot;&lt;root&gt;\n&quot;; $xml = &quot;&lt;code&gt;200&lt;/code&gt;\n&quot;; $xml = &quot;&lt;message&gt;返回成功&lt;/message&gt;\n&quot;; $xml = &quot;&lt;data&gt;\n&quot;; $xml = &quot;&lt;id&gt;1&lt;/id&gt;\n&quot;; $xml = &quot;&lt;name&gt;iCocos&lt;name&gt;\n&quot;; $xml = &quot;&lt;/data&gt;\n&quot;; $xml = &quot;&lt;/root&gt;\n&quot;; echo $xml; } 注意：xml节点不能使用数字 浏览器输入后测试显示就是平时我们看到的xml数据格式 &lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos;?&gt; &lt;root&gt; &lt;code&gt;200&lt;/code&gt; &lt;message&gt;返回成功&lt;/message&gt; &lt;data&gt; &lt;id&gt;1&lt;/id&gt; &lt;name&gt;iCocos&lt;name&gt; &lt;/data&gt; &lt;/root&gt; 当然可能你直接看到的是这样的，这是因为浏览器自动帮我们解析,属于来说就是Content-Type:text/html,而我们需要显示的是Content-Type:text/xml，只要右键查看源码就可以查看 200 返回成功 1 iCocos 如果想要显示的时候就自动解析成xml，只要调用对应的php方法就可以 heaer(&quot;Content-Type:text/xml&quot;); XML方式封装通讯数据方法：响应的格式和json是一样的XML方式其实现在来讲的话使用并不高，我经历了几家公司都使用的json，但是作为php开发也是必须要会。 首先定义一个工具类，用来把传递进来的数据和相应的信息转换成xml，然后输出 定义一个PHPResponse.php文件，并且定义一个PHPResponse类，在类里面定义一个静态方法，并且简单的实现一些逻辑处理就进行转换输出 /** * 按xml方式输出通信数据 * @param integer $code 状态码 * @param string $message 提示信息 * @param array $data 数据 * return string */ public static function xmlEncode($code, $message, $data = array()) { if(!is_numeric($code)) { return &apos;&apos;; } $result = array( &apos;code&apos; =&gt; $code, &apos;message&apos; =&gt; $message, &apos;data&apos; =&gt; $data, ); header(&quot;Content-Type:text/xml&quot;); $xml = &quot;&lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos;?&gt;\n&quot;; $xml .= &quot;&lt;root&gt;\n&quot;; $xml .= self::xmlToEncode($result); $xml .= &quot;&lt;/root&gt;&quot;; echo $xml; } 解析数组，返回xml数据 public static function xmlToEncode($data) { $xml = $attr = &quot;&quot;; foreach($data as $key =&gt; $value) { if(is_numeric($key)) { $attr = &quot; id=&apos;{$key}&apos;&quot;; $key = &quot;item&quot;; } $xml .= &quot;&lt;{$key}{$attr}&gt;&quot;; $xml .= is_array($value) ? self::xmlToEncode($value) : $value; //如果value是数组就循环便利执行这个方法 $xml .= &quot;&lt;/{$key}&gt;\n&quot;; } return $xml; } 调用 $arrayName = array( &apos;id&apos; =&gt; 1, &apos;name&apos; =&gt; &apos;iCocos&apos; ); PHPResponse::xmlEncode(200,’success’,$arrayName); 输入浏览器测试地址可以看到 &lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos;?&gt; &lt;root&gt; &lt;code&gt;200&lt;/code&gt; &lt;message&gt;返回成功&lt;/message&gt; &lt;data&gt; &lt;id&gt;1&lt;/id&gt; &lt;name&gt;iCocos&lt;name&gt; &lt;/data&gt; &lt;/root&gt; 这里如果实际开发坑定没有这么简单，但是复杂的地方也就是数组比较多数组，或分层 到上面位置就可以实现平时开发中最最最简单的接口数据。 综合方式封装通讯数据方法一：定义一个通用的接口文件，并且定义一个基类 &lt;?php /** * 定义API抽象类 */ abstract class Api { const JSON = &apos;Json&apos;; const XML = &apos;Xml&apos;; const ARR = &apos;Array&apos;; /** * 定义工厂方法 * param string $type 返回数据类型 */ public static function factory($type = self::JSON) { $type = isset($_GET[&apos;format&apos;]) ? $_GET[&apos;format&apos;] : $type; $resultClass = ucwords($type); require_once(&apos;./Response/&apos; . $type . &apos;.php&apos;); return new $resultClass(); } abstract function response($code, $message, $data); } 二：XML数据解析与响应方法，继承自API &lt;?php /** * @author by singwa * @date */ class Xml extends Api { public function response($code, $message = &apos;&apos;, $data = array()) { if(!is_numeric($code)) { return &apos;&apos;; } $result = array( &apos;code&apos; =&gt; $code, &apos;message&apos; =&gt; $message, &apos;data&apos; =&gt; $data ); header(&apos;Content-Type:text/xml&apos;); $xml = &quot;&lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos;?&gt;\n&quot;; $xml .= &quot;&lt;root&gt;&quot;; $xml .= self::xmlToEncode($result); $xml .= &quot;&lt;/root&gt;&quot;; echo $xml; } public static function xmlToEncode($result) { $xml = $attr = &apos;&apos;; foreach($result as $key =&gt; $value) { if(is_numeric($key)) { $attr = &quot; id=&apos;&quot; . $key . &quot;&apos;&quot;; $key = &quot;item&quot;; } $xml .= &quot;&lt;{$key}{$attr}&gt;&quot;; $xml .= is_array($value) ? self::xmlToEncode($value) : $value; $xml .= &quot;&lt;/{$key}&gt;\n&quot;; } return $xml; } } 三：JSON数据解析与响应方法，继承自API &lt;?php /** * 按xml方式输出通信数据 */ class Json extends Api { public function response($code, $message = &apos;&apos;, $data = array()) { if(!(is_numeric($code))) { return &apos;&apos;; } $result = array( &apos;code&apos; =&gt; $code, &apos;message&apos; =&gt; $message, &apos;data&apos; =&gt; $data ); echo json_encode($result); exit; } } 是不是感觉json比xml简单很多，这也是为什么很多公司都使用的是json的原因。 四：然后就是入口文件，通过入口文件调用方法，根据传入的类型解析成对应的格式，这也是前面讲到的面向对象的特性 &lt;?php class Response { const JSON = &quot;json&quot;; /** * 按综合方式输出通信数据 * @param integer $code 状态码 * @param string $message 提示信息 * @param array $data 数据 * @param string $type 数据类型 * return string */ public static function show($code, $message = &apos;&apos;, $data = array(), $type = self::JSON) { if(!is_numeric($code)) { return &apos;&apos;; } $type = isset($_GET[&apos;format&apos;]) ? $_GET[&apos;format&apos;] : self::JSON; $result = array( &apos;code&apos; =&gt; $code, &apos;message&apos; =&gt; $message, &apos;data&apos; =&gt; $data, ); if($type == &apos;json&apos;) { self::json($code, $message, $data); exit; } elseif($type == &apos;array&apos;) { var_dump($result); } elseif($type == &apos;xml&apos;) { self::xmlEncode($code, $message, $data); exit; } else { // TODO } } /** * 按json方式输出通信数据 * @param integer $code 状态码 * @param string $message 提示信息 * @param array $data 数据 * return string */ public static function json($code, $message = &apos;&apos;, $data = array()) { if(!is_numeric($code)) { return &apos;&apos;; } $result = array( &apos;code&apos; =&gt; $code, &apos;message&apos; =&gt; $message, &apos;data&apos; =&gt; $data ); echo json_encode($result); exit; } /** * 按xml方式输出通信数据 * @param integer $code 状态码 * @param string $message 提示信息 * @param array $data 数据 * return string */ public static function xmlEncode($code, $message, $data = array()) { if(!is_numeric($code)) { return &apos;&apos;; } $result = array( &apos;code&apos; =&gt; $code, &apos;message&apos; =&gt; $message, &apos;data&apos; =&gt; $data, ); header(&quot;Content-Type:text/xml&quot;); $xml = &quot;&lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos;?&gt;\n&quot;; $xml .= &quot;&lt;root&gt;\n&quot;; $xml .= self::xmlToEncode($result); $xml .= &quot;&lt;/root&gt;&quot;; echo $xml; } public static function xmlToEncode($data) { $xml = $attr = &quot;&quot;; foreach($data as $key =&gt; $value) { if(is_numeric($key)) { $attr = &quot; id=&apos;{$key}&apos;&quot;; $key = &quot;item&quot;; } $xml .= &quot;&lt;{$key}{$attr}&gt;&quot;; $xml .= is_array($value) ? self::xmlToEncode($value) : $value; $xml .= &quot;&lt;/{$key}&gt;\n&quot;; } return $xml; } } 五：最后就可以在浏览器输入对应的接口地址，传入对应的参数，就能得到想要的格式的数据 说在最后，实际项目中，我们在开发 API 时应该注意的几个点（仅供参考）1、单文件实现多接口的形式有很多种，例如：if..elseif.. 或 switch 或 很多框架里用到的统一入口通过调用类函数的形式实现 2、数据输出建议使用json，json具有很强的跨平台性，大多编程语言都支持json解析，json正在逐步取代xml，成为网络数据的通用格式 3、为了保证接口安全，一定要加入鉴权体系 4、对于线上的API，务必关闭所有错误显示，可以把错误写到日志里，PHP中，可以通过 error_reporting(0) 屏蔽所有错误这样做的目的，一方面是保护接口安全，防止输出不该打印的错误信息 另一方面是保证输出的是正确的数据格式，如json，假如不是标准的json格式，客户端在解析时就会出错，由此影响客户端的正常运转 PS：我们平时在使用手机APP时，手机会闪退，多半是这个原因，即接口调用异常 5、开发 API 和 WEB 有一定的区别，如果是 WEB 的话，如果程序写的有问题，比如有个notice 或 warning 级别的错误，在 WEB 里可能不会有什么问题，也许就只是导致 WEB 的某个部分错位或乱码。但如果是 API，就会严重调用的客户端了，如果是手机APP，那闪推啥的，是必然的，如果同样也是Web调用，也可能会出现 Server Error 了 6、一定要重点考虑稳定性和响应速度，因为我们在使用手机APP时，都不希望APP经常闪推、而且希望应用很流畅 7、不要随便使用一些 PHP 开源框架，原因概括起来有两点： 1）如6所述，客户端一般对 API 响应速度有极高要求，目前PHP领域的开源框架非常多，根据笔者的了解，目前比较流行的框架，普遍做的比较重，而且基本都是为WEB而生，因此，框架多了很多 API 用不到的东西，框架在加载和执行冗余文件时，实际是在消耗你的性能 2）如4和5所述，框架对于WEB开发，是件很幸福的事，但对于 API 而言，你实在不敢想象它会给你出什么岔子，因为很多框架并没有全面的考虑到 API 场景]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第二十五篇——核心技术之缓存]]></title>
    <url>%2F2016%2F07%2F28%2FPHP%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E7%AF%87%E2%80%94%E2%80%94%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B9%8B%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[缓存在所有开发里面可是说是有着具足其中的作用，或者对平时开发中并不显见，但是为了考虑性能，考虑实际应用，考虑用户的顾虑，那么缓存就不得不慎重考虑，PHP中也是同样…… APP接口首先在这之前推荐一篇文章： PHP9大缓存技术 核心技术静态缓存保存在磁盘上的静态文件，用PHP生成数据放入静态文件中 一：操作缓存 生成 获取 删除 实现案例 &lt;?php class File { private $_dir; const EXT = &apos;.txt&apos;; public function __construct() { $this-&gt;_dir = dirname(__FILE__) . &apos;/files/&apos;; } public function cacheData($key, $value = &apos;&apos;, $cacheTime = 0) { $filename = $this-&gt;_dir . $key . self::EXT; if($value !== &apos;&apos;) { // 将value值写入缓存 if(is_null($value)) { return @unlink($filename); } $dir = dirname($filename); if(!is_dir($dir)) { mkdir($dir, 0777); } $cacheTime = sprintf(&apos;%011d&apos;, $cacheTime); return file_put_contents($filename,$cacheTime . json_encode($value)); } if(!is_file($filename)) { return FALSE; } $contents = file_get_contents($filename); $cacheTime = (int)substr($contents, 0 ,11); $value = substr($contents, 11); if($cacheTime !=0 &amp;&amp; ($cacheTime + filemtime($filename) &lt; time())) { unlink($filename); return FALSE; } return json_decode($value, true); } } $file = new File(); echo $file-&gt;cacheData(&apos;test1&apos;); Memcache和Redis缓存技术简单总结 1、 Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等。2、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。3、虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘4、过期策略–memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通过例如expire 设定，例如expire name 105、分布式–设定memcache集群，利用magent做一主多从;redis可以做一主多从。都可以一主一从6、存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）7、灾难恢复–memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复8、Redis支持数据的备份，即master-slave模式的数据备份。 分类总结 （1）数据结构：Memcache只支持key value存储方式，Redis支持更多的数据类型，比如Key value，hash，list，set，zset； （2）多线程：Memcache支持多线程，redis支持单线程；CPU利用方面Memcache优于redis； （3）持久化：Memcache不支持持久化，Redis支持持久化； （4）内存利用率：memcache高，redis低（采用压缩的情况下比memcache高）； （5）过期策略：memcache过期后，不删除缓存，会导致下次取数据数据的问题，Redis有专门线程，清除缓存数据； 整体性对比 1）性能对比：由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起 Memcached，还是稍有逊色。 2）内存使用效率对比：使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。 3）Redis支持服务器端的数据操作：Redis相比Memcached来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在Memcached 里，你需要将数据拿到客户端来进行类似的修改再set回去。这大大增加了网络IO的次数和数据体积。在Redis中，这些复杂的操作通常和一般的 GET/SET一样高效。所以，如果需要缓存能够支持更复杂的结构和操作，那么Redis会是不错的选择。 后面会有专门的文章介绍Memcache与Redis原理，使用与总结 设置缓存操作 获取缓存操作 删除缓存操作 分别以命令和PHP的方式]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第二十四篇——文件上传下载原理与配置]]></title>
    <url>%2F2016%2F07%2F24%2FPHP%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E7%AF%87%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[关于PHP上传和下载的原理一句话总结就是：将客户端文件上传到服务器端，再将服务器端的文件（临时文件）移动到指定目录即可。…… 文件上传下载原理与配置一、上传原理与配置1.1 原理将客户端文件上传到服务器端，再将服务器端的文件（临时文件）移动到指定目录即可。 1.2 客户端配置所需：表单页面（选择上传文件）； 具体而言：发送方式为POST，添加enctype=”multipart/form-data”属性，两者缺一不可（但是，优缺点并存，这里也限定了上传的方式和上传的文件之后的调用等方面，后面会说到） &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;doAction.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 请选择您要上传的文件： &lt;input type=&quot;file&quot; name=&quot;myFile&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt; &lt;/form&gt; &lt;?php ?&gt; &lt;/body&gt; &lt;/html&gt; 先是表单页面（请自动忽略前端问题。。。），关键就是form的属性；另外就是input 中用到了type=”file”这一点（体现到php的强大的拓展等等）。 然后是doAction &lt;?php //$_FILES:文件上传变量 //print_r($_FILES); $filename=$_FILES[&apos;myFile&apos;][&apos;name&apos;]; $type=$_FILES[&apos;myFile&apos;][&apos;type&apos;]; $tmp_name=$_FILES[&apos;myFile&apos;][&apos;tmp_name&apos;]; $size=$_FILES[&apos;myFile&apos;][&apos;size&apos;]; $error=$_FILES[&apos;myFile&apos;][&apos;error&apos;]; //将服务器上的临时文件移动到指定位置 //方法一move_upload_file($tmp_name,$destination) //move_uploaded_file($tmp_name, &quot;uploads/&quot;.$filename);//文件夹应提前建立好，不然报错 //方法二copy($src,$des) //以上两个函数都是成功返回真，否则返回false //copy($tmp_name, &quot;copies/&quot;.$filename); //注意，不能两个方法都对临时文件进行操作，临时文件似乎操作完就没了，我们试试反过来 copy($tmp_name, &quot;copies/&quot;.$filename); move_uploaded_file($tmp_name, &quot;uploads/&quot;.$filename); //能够实现，说明move那个函数基本上相当于剪切；copy就是copy，临时文件还在 //另外，错误信息也是不一样的，遇到错误可以查看或者直接报告给用户 if ($error==0) { echo &quot;上传成功！&quot;; }else{ switch ($error){ case 1: echo &quot;超过了上传文件的最大值，请上传2M以下文件&quot;; break; case 2: echo &quot;上传文件过多，请一次上传20个及以下文件！&quot;; break; case 3: echo &quot;文件并未完全上传，请再次尝试！&quot;; break; case 4: echo &quot;未选择上传文件！&quot;; break; case 5: echo &quot;上传文件为0&quot;; break; } } 先把print_r($_FILES)这个信息看一下 Array ( [myFile] =&gt; Array ( [name] =&gt; 梁博_简历.doc [type] =&gt; application/msword [tmp_name] =&gt; D:\wamp\tmp\php1D78.tmp [error] =&gt; 0 [size] =&gt; 75776 ) ) 所以得到的是个二维数组，该怎么用，都是基本的东西（其实我喜欢降维再用）； 基本是一眼就懂的东西，不罗嗦，关键有两个：tmp_name临时文件名；error报错信息（代号，后面可以利用）； 然后这里看一下doAction后面一部分，利用报错信息来反馈给用户，需要说明的是为什么报错，和报错信息是什么都； 1.3 关于报错–报错原因 基本上都是超过或者不符合服务器关于上传文件的配置，那么服务器端配置有哪些呢？ 先考虑上传我们用了什么？POST，upload 所以在php.ini中找这么几项： file_upload:On upload_tmp_dir=——临时文件保存目录； upload_max_filesize=2M max_file_uploads=20——允许一次上传的最大文件数量（注意和上面那个的区别，有没有size，别乱想） post_max_size=8M——post方式发送数据的最大值 其他相关配置 max_exectuion_time=-1——最大执行时间，避免程序不好占用服务器资源； max_input_time=60 max_input_nesting_level=64——输入嵌套深度； memory_limit=128M——最大单线程的独立内存使用量 总之都是有关资源的配置。 –错误号 以下（偷懒）引自http://blog.sina.com.cn/s/blog_3cdfaea201008utf.html UPLOAD_ERR_OK 值：0; 没有错误发生，文件上传成功。 UPLOAD_ERR_INI_SIZE 值：1; 上传的文件超过了 php.ini 中 upload_max_filesize 选项限制的值。 UPLOAD_ERR_FORM_SIZE 值：2; 上传文件的大小超过了 HTML 表单中 MAX_FILE_SIZE 选项指定的值。 UPLOAD_ERR_PARTIAL 值：3; 文件只有部分被上传。 UPLOAD_ERR_NO_FILE 值：4; 没有文件被上传。 注意：这个错误信息是第一步上传的信息，也就是上传到临时文件夹的情况，而不是move或者copy的情况。 二、上传相关限制2.1 客户端限制&lt;form action=&quot;doAction2.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;MAX_FILE_SIZE&quot; value=&quot;101321&quot; /&gt; 请选择您要上传的文件： &lt;input type=&quot;file&quot; name=&quot;myFile&quot; accept=&quot;image/jpeg,image/gif,text/html&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt; &lt;/form&gt; 这里用input的属性对上传文件的大小和类型进行了限制，但是个人感觉：一，html代码是“可见的”；二，常不起作用（没找到原因，但因为第一个我也想放弃它，知道就好。 2.2 服务器端限制 主要限制大小和类型，再有就是方式。 &lt;?php header(&apos;content-type:text/html;charset=utf-8&apos;); //接受文件，临时文件信息 $fileinfo=$_FILES[&quot;myFile&quot;];//降维操作 $filename=$fileinfo[&quot;name&quot;]; $tmp_name=$fileinfo[&quot;tmp_name&quot;]; $size=$fileinfo[&quot;size&quot;]; $error=$fileinfo[&quot;error&quot;]; $type=$fileinfo[&quot;type&quot;]; //服务器端设定限制 $maxsize=10485760;//10M,10*1024*1024 $allowExt=array(&apos;jpeg&apos;,&apos;jpg&apos;,&apos;png&apos;,&apos;tif&apos;);//允许上传的文件类型（拓展名 $ext=pathinfo($filename,PATHINFO_EXTENSION);//提取上传文件的拓展名 //目的信息 $path=&quot;uploads&quot;; if (!file_exists($path)) { //当目录不存在，就创建目录 mkdir($path,0777,true); chmod($path, 0777); } //$destination=$path.&quot;/&quot;.$filename; //得到唯一的文件名！防止因为文件名相同而产生覆盖 $uniName=md5(uniqid(microtime(true),true)).$ext;//md5加密，uniqid产生唯一id，microtime做前缀 if ($error==0) { if ($size&gt;$maxsize) { exit(&quot;上传文件过大！&quot;); } if (!in_array($ext, $allowExt)) { exit(&quot;非法文件类型&quot;); } if (!is_uploaded_file($tmp_name)) { exit(&quot;上传方式有误，请使用post方式&quot;); } if (@move_uploaded_file($tmp_name, $uniName)) {//@错误抑制符，不让用户看到警告 echo &quot;文件&quot;.$filename.&quot;上传成功!&quot;; }else{ echo &quot;文件&quot;.$filename.&quot;上传失败!&quot;; } //判断是否为真实图片（防止伪装成图片的病毒一类的 if (!getimagesize($tmp_name)) {//getimagesize真实返回数组，否则返回false exit(&quot;不是真正的图片类型&quot;); } }else{ switch ($error){ case 1: echo &quot;超过了上传文件的最大值，请上传2M以下文件&quot;; break; case 2: echo &quot;上传文件过多，请一次上传20个及以下文件！&quot;; break; case 3: echo &quot;文件并未完全上传，请再次尝试！&quot;; break; case 4: echo &quot;未选择上传文件！&quot;; break; case 7: echo &quot;没有临时文件夹&quot;; break; } } 这里，具体实现都有注释，每一步其实都可以自己试试的，很有趣。 2.3 封装函数 &lt;?php function uploadFile($fileInfo,$path,$allowExt,$maxSize){ $filename=$fileInfo[&quot;name&quot;]; $tmp_name=$fileInfo[&quot;tmp_name&quot;]; $size=$fileInfo[&quot;size&quot;]; $error=$fileInfo[&quot;error&quot;]; $type=$fileInfo[&quot;type&quot;]; //服务器端设定限制 $ext=pathinfo($filename,PATHINFO_EXTENSION); //目的信息 if (!file_exists($path)) { mkdir($path,0777,true); chmod($path, 0777); } $uniName=md5(uniqid(microtime(true),true)).&apos;.&apos;.$ext; $destination=$path.&quot;/&quot;.$uniName; if ($error==0) { if ($size&gt;$maxSize) { exit(&quot;上传文件过大！&quot;); } if (!in_array($ext, $allowExt)) { exit(&quot;非法文件类型&quot;); } if (!is_uploaded_file($tmp_name)) { exit(&quot;上传方式有误，请使用post方式&quot;); } //判断是否为真实图片（防止伪装成图片的病毒一类的 if (!getimagesize($tmp_name)) {//getimagesize真实返回数组，否则返回false exit(&quot;不是真正的图片类型&quot;); } if (@move_uploaded_file($tmp_name, $destination)) {//@错误抑制符，不让用户看到警告 echo &quot;文件&quot;.$filename.&quot;上传成功!&quot;; }else{ echo &quot;文件&quot;.$filename.&quot;上传失败!&quot;; } }else{ switch ($error){ case 1: echo &quot;超过了上传文件的最大值，请上传2M以下文件&quot;; break; case 2: echo &quot;上传文件过多，请一次上传20个及以下文件！&quot;; break; case 3: echo &quot;文件并未完全上传，请再次尝试！&quot;; break; case 4: echo &quot;未选择上传文件！&quot;; break; case 7: echo &quot;没有临时文件夹&quot;; break; } } return $destination; } 调用 &lt;?php header(&apos;content-type:text/html;charset=utf-8&apos;); $fileInfo=$_FILES[&quot;myFile&quot;]; $maxSize=10485760;//10M,10*1024*1024 $allowExt=array(&apos;jpeg&apos;,&apos;jpg&apos;,&apos;png&apos;,&apos;tif&apos;); $path=&quot;uploads&quot;; include_once &apos;upFunc.php&apos;; uploadFile($fileInfo, $path, $allowExt, $maxSize); 三、多文件的上传实现3.1 利用单文件封装&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;doAction5.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 请选择您要上传的文件：&lt;input type=&quot;file&quot; name=&quot;myFile1&quot; /&gt;&lt;br/&gt; 请选择您要上传的文件：&lt;input type=&quot;file&quot; name=&quot;myFile2&quot; /&gt;&lt;br/&gt; 请选择您要上传的文件：&lt;input type=&quot;file&quot; name=&quot;myFile3&quot; /&gt;&lt;br/&gt; 请选择您要上传的文件：&lt;input type=&quot;file&quot; name=&quot;myFile4&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; &lt;?php //print_r($_FILES); header(&apos;content-type:text/html;charset=utf-8&apos;); include_once &apos;upFunc.php&apos;; foreach ($_FILES as $fileInfo){ $file[]=uploadFile($fileInfo); } 这里的思路，从print_r($_FILES)中去找，打印出来看到是个二维数组，很简单，遍历去用就好了！ 上面那个function的定义改一下，给定一些默认值 function uploadFile($fileInfo,$path=&quot;uploads&quot;,$allowExt=array(&apos;jpeg&apos;,&apos;jpg&apos;,&apos;png&apos;,&apos;tif&apos;),$maxSize=10485760){ 这样子，简单是简单，但遇到一些问题。 正常的上传4个图片是没问题，但要是中间激活了函数中的exit，就会立即停止，导致其他图片也无法上传。 3.2 升级版封装旨在实现针对多个或单个文件上传的封装 首先这样子写个静态文件 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;doAction5.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 请选择您要上传的文件：&lt;input type=&quot;file&quot; name=&quot;myFile[]&quot; /&gt;&lt;br/&gt; 请选择您要上传的文件：&lt;input type=&quot;file&quot; name=&quot;myFile[]&quot; /&gt;&lt;br/&gt; 请选择您要上传的文件：&lt;input type=&quot;file&quot; name=&quot;myFile[]&quot; /&gt;&lt;br/&gt; 请选择您要上传的文件：&lt;input type=&quot;file&quot; name=&quot;myFile[]&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 打印一下$_FILES Array ( [myFile] =&gt; Array ( [name] =&gt; Array ( [0] =&gt; test32.png [1] =&gt; test32.png [2] =&gt; 333.png [3] =&gt; test41.png ) [type] =&gt; Array ( [0] =&gt; image/png [1] =&gt; image/png [2] =&gt; image/png [3] =&gt; image/png ) [tmp_name] =&gt; Array ( [0] =&gt; D:\wamp\tmp\php831C.tmp [1] =&gt; D:\wamp\tmp\php834C.tmp [2] =&gt; D:\wamp\tmp\php837C.tmp [3] =&gt; D:\wamp\tmp\php83BB.tmp ) [error] =&gt; Array ( [0] =&gt; 0 [1] =&gt; 0 [2] =&gt; 0 [3] =&gt; 0 ) [size] =&gt; Array ( [0] =&gt; 46174 [1] =&gt; 46174 [2] =&gt; 34196 [3] =&gt; 38514 ) ) ) 可以得到一个三维数组。 复杂是复杂了，但复杂的有规律，各项数值都在一起了，很方便我们取值！！ 所以先得到文件信息，变成单文件处理那种信息 function getFiles(){ $i=0; foreach($_FILES as $file){ if(is_string($file[&apos;name&apos;])){ //单文件判定 $files[$i]=$file; $i++; }elseif(is_array($file[&apos;name&apos;])){ foreach($file[&apos;name&apos;] as $key=&gt;$val){ //我的天，这个$key用的diao $files[$i][&apos;name&apos;]=$file[&apos;name&apos;][$key]; $files[$i][&apos;type&apos;]=$file[&apos;type&apos;][$key]; $files[$i][&apos;tmp_name&apos;]=$file[&apos;tmp_name&apos;][$key]; $files[$i][&apos;error&apos;]=$file[&apos;error&apos;][$key]; $files[$i][&apos;size&apos;]=$file[&apos;size&apos;][$key]; $i++; } } } return $files; } 然后之前的那种exit错误，就把exit改一下就好了，这里用res function uploadFile($fileInfo,$path=&apos;./uploads&apos;,$flag=true,$maxSize=1048576,$allowExt=array(&apos;jpeg&apos;,&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;)){ //$flag=true; //$allowExt=array(&apos;jpeg&apos;,&apos;jpg&apos;,&apos;gif&apos;,&apos;png&apos;); //$maxSize=1048576;//1M //判断错误号 $res=array(); if($fileInfo[&apos;error&apos;]===UPLOAD_ERR_OK){ //检测上传得到小 if($fileInfo[&apos;size&apos;]&gt;$maxSize){ $res[&apos;mes&apos;]=$fileInfo[&apos;name&apos;].&apos;上传文件过大&apos;; } $ext=getExt($fileInfo[&apos;name&apos;]); //检测上传文件的文件类型 if(!in_array($ext,$allowExt)){ $res[&apos;mes&apos;]=$fileInfo[&apos;name&apos;].&apos;非法文件类型&apos;; } //检测是否是真实的图片类型 if($flag){ if(!getimagesize($fileInfo[&apos;tmp_name&apos;])){ $res[&apos;mes&apos;]=$fileInfo[&apos;name&apos;].&apos;不是真实图片类型&apos;; } } //检测文件是否是通过HTTP POST上传上来的 if(!is_uploaded_file($fileInfo[&apos;tmp_name&apos;])){ $res[&apos;mes&apos;]=$fileInfo[&apos;name&apos;].&apos;文件不是通过HTTP POST方式上传上来的&apos;; } if($res) return $res; //$path=&apos;./uploads&apos;; if(!file_exists($path)){ mkdir($path,0777,true); chmod($path,0777); } $uniName=getUniName(); $destination=$path.&apos;/&apos;.$uniName.&apos;.&apos;.$ext; if(!move_uploaded_file($fileInfo[&apos;tmp_name&apos;],$destination)){ $res[&apos;mes&apos;]=$fileInfo[&apos;name&apos;].&apos;文件移动失败&apos;; } $res[&apos;mes&apos;]=$fileInfo[&apos;name&apos;].&apos;上传成功&apos;; $res[&apos;dest&apos;]=$destination; return $res; }else{ //匹配错误信息 switch ($fileInfo [&apos;error&apos;]) { case 1 : $res[&apos;mes&apos;] = &apos;上传文件超过了PHP配置文件中upload_max_filesize选项的值&apos;; break; case 2 : $res[&apos;mes&apos;] = &apos;超过了表单MAX_FILE_SIZE限制的大小&apos;; break; case 3 : $res[&apos;mes&apos;] = &apos;文件部分被上传&apos;; break; case 4 : $res[&apos;mes&apos;] = &apos;没有选择上传文件&apos;; break; case 6 : $res[&apos;mes&apos;] = &apos;没有找到临时目录&apos;; break; case 7 : case 8 : $res[&apos;mes&apos;] = &apos;系统错误&apos;; break; } return $res; } } 里面封装了两个小的 function getExt($filename){ return strtolower(pathinfo($filename,PATHINFO_EXTENSION)); } /** * 产生唯一字符串 * @return string */ function getUniName(){ return md5(uniqid(microtime(true),true)); } 然后静态中，用multiple属性实现多个文件的输入； &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;doAction6.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; 请选择您要上传的文件：&lt;input type=&quot;file&quot; name=&quot;myFile[]&quot; multiple=&apos;multiple&apos; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; doAction6 &lt;?php //print_r($_FILES); header(&quot;content-type:text/html;charset=utf-8&quot;); require_once &apos;upFunc2.php&apos;; require_once &apos;common.func.php&apos;; $files=getFiles(); // print_r($files); foreach($files as $fileInfo){ $res=uploadFile($fileInfo); echo $res[&apos;mes&apos;],&apos;&lt;br/&gt;&apos;; $uploadFiles[]=@$res[&apos;dest&apos;]; } $uploadFiles=array_values(array_filter($uploadFiles)); //print_r($uploadFiles); 这样子的几个文件，就实现比较强大的面向过程的上传文件的功能（学的叫一个心酸。。。）； 四、面向对象的文件上传（不是很写的动了。。。先粘过来，再说吧。。。 &lt;?php class upload{ protected $fileName; protected $maxSize; protected $allowMime; protected $allowExt; protected $uploadPath; protected $imgFlag; protected $fileInfo; protected $error; protected $ext; /** * @param string $fileName * @param string $uploadPath * @param string $imgFlag * @param number $maxSize * @param array $allowExt * @param array $allowMime */ public function __construct($fileName=&apos;myFile&apos;,$uploadPath=&apos;./uploads&apos;,$imgFlag=true,$maxSize=5242880,$allowExt=array(&apos;jpeg&apos;,&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;),$allowMime=array(&apos;image/jpeg&apos;,&apos;image/png&apos;,&apos;image/gif&apos;)){ $this-&gt;fileName=$fileName; $this-&gt;maxSize=$maxSize; $this-&gt;allowMime=$allowMime; $this-&gt;allowExt=$allowExt; $this-&gt;uploadPath=$uploadPath; $this-&gt;imgFlag=$imgFlag; $this-&gt;fileInfo=$_FILES[$this-&gt;fileName]; } /** * 检测上传文件是否出错 * @return boolean */ protected function checkError(){ if(!is_null($this-&gt;fileInfo)){ if($this-&gt;fileInfo[&apos;error&apos;]&gt;0){ switch($this-&gt;fileInfo[&apos;error&apos;]){ case 1: $this-&gt;error=&apos;超过了PHP配置文件中upload_max_filesize选项的值&apos;; break; case 2: $this-&gt;error=&apos;超过了表单中MAX_FILE_SIZE设置的值&apos;; break; case 3: $this-&gt;error=&apos;文件部分被上传&apos;; break; case 4: $this-&gt;error=&apos;没有选择上传文件&apos;; break; case 6: $this-&gt;error=&apos;没有找到临时目录&apos;; break; case 7: $this-&gt;error=&apos;文件不可写&apos;; break; case 8: $this-&gt;error=&apos;由于PHP的扩展程序中断文件上传&apos;; break; } return false; }else{ return true; } }else{ $this-&gt;error=&apos;文件上传出错&apos;; return false; } } /** * 检测上传文件的大小 * @return boolean */ protected function checkSize(){ if($this-&gt;fileInfo[&apos;size&apos;]&gt;$this-&gt;maxSize){ $this-&gt;error=&apos;上传文件过大&apos;; return false; } return true; } /** * 检测扩展名 * @return boolean */ protected function checkExt(){ $this-&gt;ext=strtolower(pathinfo($this-&gt;fileInfo[&apos;name&apos;],PATHINFO_EXTENSION)); if(!in_array($this-&gt;ext,$this-&gt;allowExt)){ $this-&gt;error=&apos;不允许的扩展名&apos;; return false; } return true; } /** * 检测文件的类型 * @return boolean */ protected function checkMime(){ if(!in_array($this-&gt;fileInfo[&apos;type&apos;],$this-&gt;allowMime)){ $this-&gt;error=&apos;不允许的文件类型&apos;; return false; } return true; } /** * 检测是否是真实图片 * @return boolean */ protected function checkTrueImg(){ if($this-&gt;imgFlag){ if(!@getimagesize($this-&gt;fileInfo[&apos;tmp_name&apos;])){ $this-&gt;error=&apos;不是真实图片&apos;; return false; } return true; } } /** * 检测是否通过HTTP POST方式上传上来的 * @return boolean */ protected function checkHTTPPost(){ if(!is_uploaded_file($this-&gt;fileInfo[&apos;tmp_name&apos;])){ $this-&gt;error=&apos;文件不是通过HTTP POST方式上传上来的&apos;; return false; } return true; } /** *显示错误 */ protected function showError(){ exit(&apos;&lt;span style=&quot;color:red&quot;&gt;&apos;.$this-&gt;error.&apos;&lt;/span&gt;&apos;); } /** * 检测目录不存在则创建 */ protected function checkUploadPath(){ if(!file_exists($this-&gt;uploadPath)){ mkdir($this-&gt;uploadPath,0777,true); } } /** * 产生唯一字符串 * @return string */ protected function getUniName(){ return md5(uniqid(microtime(true),true)); } /** * 上传文件 * @return string */ public function uploadFile(){ if($this-&gt;checkError()&amp;&amp;$this-&gt;checkSize()&amp;&amp;$this-&gt;checkExt()&amp;&amp;$this-&gt;checkMime()&amp;&amp;$this-&gt;checkTrueImg()&amp;&amp;$this-&gt;checkHTTPPost()){ $this-&gt;checkUploadPath(); $this-&gt;uniName=$this-&gt;getUniName(); $this-&gt;destination=$this-&gt;uploadPath.&apos;/&apos;.$this-&gt;uniName.&apos;.&apos;.$this-&gt;ext; if(@move_uploaded_file($this-&gt;fileInfo[&apos;tmp_name&apos;], $this-&gt;destination)){ return $this-&gt;destination; }else{ $this-&gt;error=&apos;文件移动失败&apos;; $this-&gt;showError(); } }else{ $this-&gt;showError(); } } } &lt;?php header(&apos;content-type:text/html;charset=utf-8&apos;); require_once &apos;upload.class.php&apos;; $upload=new upload(&apos;myFile1&apos;,&apos;imooc&apos;); $dest=$upload-&gt;uploadFile(); echo $dest; 五、下载对于浏览器不识别的，可以直接下载，但对于能识别的，需要多一两步 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;1.rar&quot;&gt;下载1.rar&lt;/a&gt; &lt;br /&gt; &lt;a href=&quot;1.jpg&quot;&gt;下载1.jpg&lt;/a&gt; &lt;br /&gt; &lt;a href=&quot;doDownload.php?filename=1.jpg&quot;&gt;通过程序下载1.jpg&lt;/a&gt; &lt;br /&gt; &lt;a href=&quot;doDownload.php?filename=../upload/nv.jpg&quot;&gt;下载nv.jpg&lt;/a&gt; &lt;?php ?&gt; &lt;/body&gt; &lt;/html&gt; &lt;?php $filename=$_GET[&apos;filename&apos;]; header(&apos;content-disposition:attachment;filename=&apos;.basename($filename)); header(&apos;content-length:&apos;.filesize($filename)); readfile($filename); ——————总结———————– 二维数组的降维处理； $_FILES变量 move_upload_file();copy(); tmp_name临时文件； 拓展名的提取； 真实图片的验证； 唯一文件名的生成； 函数封装以及调用； 利用单个文件函数实现多文件上传； 小功能的封装； 多文件的遍历； 面向对象的开发过程；]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第二十三篇——文件上传下载实战]]></title>
    <url>%2F2016%2F07%2F19%2FPHP%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E7%AF%87%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[既然涉及到PHP开发APP接口，文件上传和下载是在所难免的，也许有些人会考虑第三方的，比如七牛，但是学习和使用终究还是要会的，所以，所以…… 文件上传下载实战以前一直在做iOS，最近转行去搞php开发，总觉得力不从心。这几天有个需求，是关于php的文件上传和下载的。给大家分享下自己的学习资料。 1.先来个请求页面upload.html&lt;html&gt; &lt;head&gt; &lt;title&gt;Administration - upload new files&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Upload new news files&lt;/h1&gt; &lt;form enctype=&quot;multipart/form-data&quot; action=&quot;upload.php&quot; method=post&gt; &lt;input type=&quot;hidden&quot; name=&quot;MAX_FILE_SIZE&quot; value=&quot;1000000&quot;&gt; Upload this file: &lt;input name=&quot;userfile&quot; type=&quot;file&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Send File&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 2.php处理客户端请求的数据upload.html&lt;html&gt; &lt;head&gt; &lt;title&gt;Uploading...&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Uploading file...&lt;/h1&gt; &lt;?php //Check to see if an error code was generated on the upload attempt if ($_FILES[&apos;userfile&apos;][&apos;error&apos;] &gt; 0) { echo &apos;Problem: &apos;; switch ($_FILES[&apos;userfile&apos;][&apos;error&apos;]) { case 1: echo &apos;File exceeded upload_max_filesize&apos;; break; case 2: echo &apos;File exceeded max_file_size&apos;; break; case 3: echo &apos;File only partially uploaded&apos;; break; case 4: echo &apos;No file uploaded&apos;; break; case 6: echo &apos;Cannot upload file: No temp directory specified.&apos;; break; case 7: echo &apos;Upload failed: Cannot write to disk.&apos;; break; } exit; } // Does the file have the right MIME type? if ($_FILES[&apos;userfile&apos;][&apos;type&apos;] != &apos;text/plain&apos;) { echo &apos;Problem: file is not plain text&apos;; exit; } // put the file where we&apos;d like it $upfile = &apos;/uploads/&apos;.$_FILES[&apos;userfile&apos;][&apos;name&apos;]; if (is_uploaded_file($_FILES[&apos;userfile&apos;][&apos;tmp_name&apos;])) { if (!move_uploaded_file($_FILES[&apos;userfile&apos;][&apos;tmp_name&apos;], $upfile)) { echo &apos;Problem: Could not move file to destination directory&apos;; exit; } } else { echo &apos;Problem: Possible file upload attack. Filename: &apos;; echo $_FILES[&apos;userfile&apos;][&apos;name&apos;]; exit; } echo &apos;File uploaded successfully&lt;br&gt;&lt;br&gt;&apos;; // reformat the file contents $fp = fopen($upfile, &apos;r&apos;); $contents = fread ($fp, filesize ($upfile)); fclose ($fp); $contents = strip_tags($contents); $fp = fopen($upfile, &apos;w&apos;); fwrite($fp, $contents); fclose($fp); // show what was uploaded echo &apos;Preview of uploaded file contents:&lt;br&gt;&lt;hr&gt;&apos;; echo $contents; echo &apos;&lt;br&gt;&lt;hr&gt;&apos;; ?&gt; &lt;/body&gt; &lt;/html&gt; 3.php文件下载&lt;?php $filePath = &quot;template/&quot;;//此处给出你下载的文件在服务器的什么地方 $fileName = &quot;template.xls&quot;; //此处给出你下载的文件名 $file = fopen($filePath . $fileName, &quot;r&quot;); // 打开文件 //输入文件标签 Header(&quot;Content-type:application/octet-stream &quot;); Header(&quot;Accept-Ranges:bytes &quot;); Header(&quot;Accept-Length: &quot; . filesize($filePath . $fileName)); Header(&quot;Content-Disposition: attachment; filename= &quot; . $fileName); // 输出文件内容 echo fread($file, filesize($filePath . $fileName)); fclose($file); exit; ?&gt; 总的来说，上面的3个代码段只是简单介绍了php文件的上传下载，还有很多问题要解决，就例如上传大文件的时候怎么处理，批量上传、大文件下载等等问题。当然跟java一样，php也有很多框架可以解决这方面。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第二十二篇——数据库优化的八种方式]]></title>
    <url>%2F2016%2F07%2F15%2FPHP%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E7%AF%87%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E7%9A%84%E5%85%AB%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[数据库优化的八种方式引言：关于数据库优化，网上有不少资料和方法，但是不少质量参差不齐，有些总结的不够到位，内容冗杂偶尔发现了这篇文章，总结得很经典，文章流量也很大，所以拿到自己的总结文集中，积累优质文章，提升个人能力，希望对大家今后开发中也有帮助 选取最适用的字段属性MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。 例如，在定义邮政编码这个字段时，如果将其设置为CHAR(255),显然给数据库增加了不必要的空间，甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段。 另外一个提高效率的方法是在可能的情况下，应该尽量把字段设置为NOTNULL，这样在将来执行查询的时候，数据库不用去比较NULL值。 对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。 使用连接（JOIN）来代替子查询(Sub-Queries)MySQL从4.1开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。例如，我们要将客户基本信息表中没有任何订单的客户删除掉，就可以利用子查询先从销售信息表中将所有发出订单的客户ID取出来，然后将结果传递给主查询，如下所示： DELETEFROMcustomerinfo WHERECustomerIDNOTin(SELECTCustomerIDFROMsalesinfo) 使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接（JOIN）..替代。例如，假设我们要将所有没有订单记录的用户取出来，可以用下面这个查询完成： SELECT*FROMcustomerinfo WHERECustomerIDNOTin(SELECTCustomerIDFROMsalesinfo) 如果使用连接（JOIN）..来完成这个查询工作，速度将会快很多。尤其是当salesinfo表中对CustomerID建有索引的话，性能将会更好，查询如下： SELECT*FROMcustomerinfo LEFTJOINsalesinfoONcustomerinfo.CustomerID=salesinfo.CustomerID WHEREsalesinfo.CustomerIDISNULL 连接（JOIN）..之所以更有效率一些，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。 使用联合(UNION)来代替手动创建的临时表MySQL从4.0的版本开始支持union查询，它可以把需要使用临时表的两条或更多的select查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。使用union来创建查询的时候，我们只需要用UNION作为关键字把多个select语句连接起来就可以了，要注意的是所有select语句中的字段数目要想同。下面的例子就演示了一个使用UNION的查询。 SELECTName,PhoneFROMclientUNION SELECTName,BirthDateFROMauthorUNION SELECTName,SupplierFROMproduct 事务尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条SQL语句就可以完成的。更多的时候是需要用到一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来。设想一下，要把某个数据同时插入两个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，造成第二个表中的操作没有完成，这样，就会造成数据的不完整，甚至会破坏数据库中的数据。要避免这种情况，就应该使用事务，它的作用是：要么语句块中每条语句都操作成功，要么都失败。换句话说，就是可以保持数据库中数据的一致性和完整性。事物以BEGIN关键字开始，COMMIT关键字结束。在这之间的一条SQL操作失败，那么，ROLLBACK命令就可以把数据库恢复到BEGIN开始之前的状态。 BEGIN; INSERTINTOsalesinfoSETCustomerID=14;UPDATEinventorySETQuantity=11WHEREitem=&apos;book&apos;;COMMIT; 事务的另一个重要作用是当多个用户同时使用相同的数据源时，它可以利用锁定数据库的方法来为用户提供一种安全的访问方式，这样可以保证用户的操作不被其它的用户所干扰。 锁定表尽管事务是维护数据库完整性的一个非常好的方法，但却因为它的独占性，有时会影响数据库的性能，尤其是在很大的应用系统中。由于在事务执行的过程中，数据库将会被锁定，因此其它的用户请求只能暂时等待直到该事务结束。如果一个数据库系统只有少数几个用户来使用，事务造成的影响不会成为一个太大的问题；但假设有成千上万的用户同时访问一个数据库系统，例如访问一个电子商务网站，就会产生比较严重的响应延迟。 其实，有些情况下我们可以通过锁定表的方法来获得更好的性能。下面的例子就用锁定表的方法来完成前面一个例子中事务的功能。 LOCKTABLEinventoryWRITESELECTQuantityFROMinventoryWHEREItem=&apos;book&apos;; ... UPDATEinventorySETQuantity=11WHEREItem=&apos;book&apos;;UNLOCKTABLES 这里，我们用一个select语句取出初始数据，通过一些计算，用update语句将新值更新到表中。包含有WRITE关键字的LOCKTABLE语句可以保证在UNLOCKTABLES命令被执行之前，不会有其它的访问来对inventory进行插入、更新或者删除的操作。 使用外键锁定表的方法可以维护数据的完整性，但是它却不能保证数据的关联性。这个时候我们就可以使用外键。 例如，外键可以保证每一条销售记录都指向某一个存在的客户。在这里，外键可以把customerinfo表中的CustomerID映射到salesinfo表中CustomerID，任何一条没有合法CustomerID的记录都不会被更新或插入到salesinfo中。 CREATETABLEcustomerinfo( CustomerIDINTNOTNULL,PRIMARYKEY(CustomerID))TYPE=INNODB; CREATETABLEsalesinfo( SalesIDINTNOTNULL,CustomerIDINTNOTNULL, PRIMARYKEY(CustomerID,SalesID), FOREIGNKEY(CustomerID)REFERENCEScustomerinfo(CustomerID)ONDELETECASCADE)TYPE=INNODB; 注意例子中的参数“ONDELETECASCADE”。该参数保证当customerinfo表中的一条客户记录被删除的时候，salesinfo表中所有与该客户相关的记录也会被自动删除。如果要在MySQL中使用外键，一定要记住在创建表的时候将表的类型定义为事务安全表InnoDB类型。该类型不是MySQL表的默认类型。定义的方法是在CREATETABLE语句中加上TYPE=INNODB。如例中所示。 使用索引索引是提高数据库性能的常用方法，它可以令数据库服务器以比没有索引快得多的速度检索特定的行，尤其是在查询语句当中包含有MAX(),MIN()和ORDERBY这些命令的时候，性能提高更为明显。 那该对哪些字段建立索引呢？ 一般说来，索引应建立在那些将用于JOIN,WHERE判断和ORDERBY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。对于一个ENUM类型的字段来说，出现大量重复值是很有可能的情况 例如customerinfo中的“province”..字段，在这样的字段上建立索引将不会有什么帮助；相反，还有可能降低数据库的性能。我们在创建表的时候可以同时创建合适的索引，也可以使用ALTERTABLE或CREATEINDEX在以后创建索引。此外，MySQL从版本3.23.23开始支持全文索引和搜索。全文索引在MySQL中是一个FULLTEXT类型索引，但仅能用于MyISAM类型的表。对于一个大的数据库，将数据装载到一个没有FULLTEXT索引的表中，然后再使用ALTERTABLE或CREATEINDEX创建索引，将是非常快的。但如果将数据装载到一个已经有FULLTEXT索引的表中，执行过程将会非常慢。 优化的查询语句绝大多数情况下，使用索引可以提高查询的速度，但如果SQL语句使用不恰当的话，索引将无法发挥它应有的作用。 下面是应该注意的几个方面。 首先，最好是在相同类型的字段间进行比较的操作。 在MySQL3.23版之前，这甚至是一个必须的条件。例如不能将一个建有索引的INT字段和BIGINT字段进行比较；但是作为特殊的情况，在CHAR类型的字段和VARCHAR类型字段的字段大小相同的时候，可以将它们进行比较。 其次，在建有索引的字段上尽量不要使用函数进行操作。 例如，在一个DATE类型的字段上使用YEAE()函数时，将会使索引不能发挥应有的作用。所以，下面的两个查询虽然返回的结果一样，但后者要比前者快得多。 第三，在搜索字符型字段时，我们有时会使用LIKE关键字和通配符，这种做法虽然简单，但却也是以牺牲系统性能为代价的。 例如下面的查询将会比较表中的每一条记录。 SELECT*FROMbooks WHEREnamelike&quot;MySQL%&quot; 但是如果换用下面的查询，返回的结果一样，但速度就要快上很多： SELECT*FROMbooks WHEREname＞=&quot;MySQL&quot;andname＜&quot;MySQM&quot; 最后，应该注意避免在查询中让MySQL进行自动类型转换，因为转换过程也会使索引变得不起作用。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第二十一篇——数据库操作]]></title>
    <url>%2F2016%2F07%2F09%2FPHP%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E7%AF%87%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[关于数据库操作，在PHP开发中可谓是重中之重，其他开发想iOS，Android如果只是做一个简单的App可以不用对数据库操作，但是PHP开发中没有数据库操作就等于一尊雕塑，PHP中数据库首选MYSql，不用问为什么，因为他们是天合之作，谁用谁知道…… 数据库操作PHP支持的数据库PHP通过安装相应的扩展来实现数据库操作，现代应用程序的设计离不开数据库的应用，当前主流的数据库有MsSQL，MySQL，Sybase，Db2，Oracle，PostgreSQL，Access等，这些数据库PHP都能够安装扩展来支持，一般情况下常说的LAMP架构指的是：Linux、Apache、Mysql、PHP，因此Mysql数据库在PHP中的应用非常广泛，我们会在本章中简单的了解Mysql的操作方法。 数据库拓展PHP中一个数据库可能有一个或者多个扩展，其中既有官方的，也有第三方提供的。像Mysql常用的扩展有原生的mysql库，也可以使用增强版的mysqli扩展，还可以使用PDO进行连接与操作。 不同的扩展提供基本相近的操作方法，不同的是可能具备一些新特性，以及操作性能可能会有所不同。 mysql扩展进行数据库连接的方法： $link = mysql_connect(&apos;mysql_host&apos;, &apos;mysql_user&apos;, &apos;mysql_password&apos;); mysqli扩展： $link = mysqli_connect(&apos;mysql_host&apos;, &apos;mysql_user&apos;, &apos;mysql_password&apos;); PDO扩展 $dsn = &apos;mysql:dbname=testdb;host=127.0.0.1&apos;; $user = &apos;dbuser&apos;; $password = &apos;dbpass&apos;; $dbh = new PDO($dsn, $user, $password); 链接数据库PHP要对数据库进行操作，首先要做的是与数据库建立连接，通常我们使用mysql_connect函数进行数据库连接，该函数需要指定数据库的地址，用户名及密码。 $host = &apos;localhost&apos;; $user = &apos;code1&apos;; $pass = &apos;&apos;; $link = mysql_connect($host, $user, $pass); PHP连接数据库的方式类似于直接在命令行下通过进行连接，类似：mysql -hlocalhost -ucode1 -p，当连接成功以后，我们需要选择一个操作的数据库，通过mysql_select_db函数来选择数据库。 mysql_select_db(&apos;code1&apos;); 通常我们会先设置一下当前连接使用的字符编码，一般的我们会使用utf8编码。 mysql_query(&quot;set names &apos;utf8&apos;&quot;); 通过上面的步骤，我们就与数据库建立了连接，可以进行数据操作了。 查询数据库在数据库建立连接以后就可以进行查询，采用mysql_query加sql语句的形式向数据库发送查询指令。 $res = mysql_query(&apos;select * from user limit 1&apos;); 对于查询类的语句会返回一个资源句柄（resource），可以通过该资源获取查询结果集中的数据。 $row = mysql_fetch_array($res); var_dump($row); 默认的，PHP使用最近的数据库连接执行查询，但如果存在多个连接的情况，则可以通过参数指令从那个连接中进行查询。 $link1 = mysql_connect(&apos;127.0.0.1&apos;, &apos;code1&apos;, &apos;&apos;); $link2 = mysql_connect(&apos;127.0.0.1&apos;, &apos;code1&apos;, &apos;&apos;, true); //开启一个新的连接 $res = mysql_query(&apos;select * from user limit 1&apos;, $link1); //从第一个连接中查询数据 插入数据库当我们了解了如何使用mysql_query进行数据查询以后，那么类似的，插入数据其实也是通过执行一个sql语句来实现，例如： $sql = &quot;insert into user(name, age, class) values(&apos;李四&apos;, 18, &apos;高三一班&apos;)&quot;; mysql_query($sql); //执行插入语句 通常数据都是存储在变量或者数组中，因此sql语句需要先进行字符串拼接得到。 $name = &apos;李四&apos;; $age = 18; $class = &apos;高三一班&apos;; $sql = &quot;insert into user(name, age, class) values(&apos;$name&apos;, &apos;$age&apos;, &apos;$class&apos;)&quot;; mysql_query($sql); //执行插入语句 在mysql中，执行插入语句以后，可以得到自增的主键id,通过PHP的mysql_insert_id函数可以获取该id。 $uid = mysql_insert_id(); 这个id的作用非常大，通常可以用来判断是否插入成功，或者作为关联ID进行其他的数据操作。 获取查询结果通过前面的章节，我们发现PHP操作数据库跟MySql客户端上操作极为相似，先进行连接，然后执行sql语句，再然后获取我们想要的结果集。 PHP有多个函数可以获取数据集中的一行数据，最常用的是mysql_fetch_array，可以通过设定参数来更改行数据的下标，默认的会包含数字索引的下标以及字段名的关联索引下标。 $sql = &quot;select * from user limit 1&quot;; $result = mysql_query($sql); $row = mysql_fetch_array($result); 可以通过设定参数MYSQL_NUM只获取数字索引数组，等同于mysql_fetch_row函数，如果设定参数为MYSQL_ASSOC则只获取关联索引数组，等同于mysql_fetch_assoc函数。 $row = mysql_fetch_row($result); $row = mysql_fetch_array($result, MYSQL_NUM); //这两个方法获取的数据是一样的 $row = mysql_fetch_assoc($result); $row = mysql_fetch_array($result, MYSQL_ASSOC); 如果要获取数据集中的所有数据，我们通过循环来遍历整个结果集。 $data = array(); while ($row = mysql_fetch_array($result)) { $data[] = $row; } 分页查询上一节中，我们了解到通过循环可以获取一个查询的所有数据，在实际应用中，我们并不希望一次性获取数据表中的所有数据，那样性能会非常的低，因此会使用翻页功能，每页仅显示10条或者20条数据。 通过mysql的limit可以很容易的实现分页，limit m,n表示从m行后取n行数据，在PHP中我们需要构造m与n来实现获取某一页的所有数据。 假定当前页为$page，每页显示$n条数据，那么m为当前页前面所有的数据，既$m = ($page-1) * $n，在知道了翻页原理以后，那么我们很容易通过构造SQL语句在PHP中实现数据翻页。 $page = 2; $n = 2; $m = ($page - 1) * $n; $sql = &quot;select * from user limit $m, $n&quot;; $result = mysql_query($sql); //循环获取当前页的数据 $data = array(); while ($row = mysql_fetch_assoc($result)) { $data[] = $row; } 在上面的例子中，我们使用了$m与$n变量来表示偏移量与每页数据条数，但我们推荐使用更有意义的变量名来表示，比如$pagesize, $start, $offset等，这样更容易理解，有助于团队协作开发。 更新与删除数据的更新与删除相对比较简单，只需要构建好相应的sql语句，然后调用mysql_query执行就能完成相应的更新与删除操作。 $sql = &quot;update user set name = &apos;曹操&apos; where id=2 limit 1&quot;; if (mysql_query($sql)) { echo &apos;更新成功&apos;; } 同样的删除可以使用类似以下的代码： $sql = &quot;delete from user where id=2 limit 1&quot;; if (mysql_query($sql)) { echo &apos;删除成功&apos;; } 对于删除与更新操作，可以通过mysql_affected_rows函数来获取更新过的数据行数，如果数据没有变化，则结果为0。 $sql = &quot;update user set name = &apos;曹操&apos; where id=2 limit 1&quot;; if (mysql_query($sql)) { echo mysql_affected_rows(); } 关闭数据库当数据库操作完成以后，可以使用mysql_close关闭数据库连接，默认的，当PHP执行完毕以后，会自动的关闭数据库连接。 mysql_close(); 虽然PHP会自动关闭数据库连接，一般情况下已经满足需求，但是在对性能要求比较高的情况下，可以在进行完数据库操作之后尽快关闭数据库连接，以节省资源，提高性能。 在存在多个数据库连接的情况下，可以设定连接资源参数来关闭指定的数据库连接。 $link = mysql_connect($host, $user, $pass); mysql_close($link); 关于数据库的操作这里只是简单的整理一下，后期或抽出专门的时间，使用专门的章节详细介绍使用与实战数据库的操作。 数据库封装&lt;?php class mysql{ /** * 报错函数 * * @param string $error */ function err($error){ die(&quot;对不起，您的操作有误，错误原因为：&quot;.$error);//die有两种作用 输出 和 终止 相当于 echo 和 exit 的组合 } /** * 连接数据库 * * @param string $dbhost 主机名 * @param string $dbuser 用户名 * @param string $dbpsw 密码 * @param string $dbname 数据库名 * @param string $dbcharset 字符集/编码 * @return bool 连接成功或不成功 **/ function connect($config){ extract($config); if(!($con = mysql_connect($dbhost,$dbuser,$dbpsw))){//mysql_connect连接数据库函数 $this-&gt;err(mysql_error()); } if(!mysql_select_db($dbname,$con)){//mysql_select_db选择库的函数 $this-&gt;err(mysql_error()); } mysql_query(&quot;set names &quot;.$dbcharset);//使用mysql_query 设置编码 格式：mysql_query(&quot;set names utf8&quot;) } /** * 执行sql语句 * * @param string $sql * @return bool 返回执行成功、资源或执行失败 */ function query($sql){ if(!($query = mysql_query($sql))){//使用mysql_query函数执行sql语句 $this-&gt;err($sql.&quot;&lt;br /&gt;&quot;.mysql_error());//mysql_error 报错 }else{ return $query; } } /** *列表 * *@param source $query sql语句通过mysql_query 执行出来的资源 *@return array 返回列表数组 **/ function findAll($query){ while($rs=mysql_fetch_array($query, MYSQL_ASSOC)){//mysql_fetch_array函数把资源转换为数组，一次转换出一行出来 $list[]=$rs; } return isset($list)?$list:&quot;&quot;; } /** *单条 * *@param source $query sql语句通过mysql_query执行出的来的资源 *return array 返回单条信息数组 **/ function findOne($query){ $rs = mysql_fetch_array($query, MYSQL_ASSOC); return $rs; } /** *指定行的指定字段的值 * *@param source $query sql语句通过mysql_query执行出的来的资源 *return array 返回指定行的指定字段的值 **/ function findResult($query, $row = 0, $filed = 0){ $rs = mysql_result($query, $row, $filed); return $rs; } /** * 添加函数 * * @param string $table 表名 * @param array $arr 添加数组（包含字段和值的一维数组） * */ function insert($table,$arr){ //$sql = &quot;insert into 表名(多个字段) values(多个值)&quot;; foreach($arr as $key=&gt;$value){//foreach循环数组 $value = mysql_real_escape_string($value); $keyArr[] = &quot;`&quot;.$key.&quot;`&quot;;//把$arr数组当中的键名保存到$keyArr数组当中 $valueArr[] = &quot;&apos;&quot;.$value.&quot;&apos;&quot;;//把$arr数组当中的键值保存到$valueArr当中，因为值多为字符串，而sql语句里面insert当中如果值是字符串的话要加单引号，所以这个地方要加上单引号 } $keys = implode(&quot;,&quot;,$keyArr);//implode函数是把数组组合成字符串 implode(分隔符，数组) $values = implode(&quot;,&quot;,$valueArr); $sql = &quot;insert into &quot;.$table.&quot;(&quot;.$keys.&quot;) values(&quot;.$values.&quot;)&quot;;//sql的插入语句 格式：insert into 表(多个字段)values(多个值) $this-&gt;query($sql);//调用类自身的query(执行)方法执行这条sql语句 注：$this指代自身 return mysql_insert_id(); } /** *修改函数 * *@param string $table 表名 *@param array $arr 修改数组（包含字段和值的一维数组） *@param string $where 条件 **/ function update($table,$arr,$where){ //update 表名 set 字段=字段值 where …… foreach($arr as $key=&gt;$value){ $value = mysql_real_escape_string($value); $keyAndvalueArr[] = &quot;`&quot;.$key.&quot;`=&apos;&quot;.$value.&quot;&apos;&quot;; } $keyAndvalues = implode(&quot;,&quot;,$keyAndvalueArr); $sql = &quot;update &quot;.$table.&quot; set &quot;.$keyAndvalues.&quot; where &quot;.$where;//修改操作 格式 update 表名 set 字段=值 where 条件 $this-&gt;query($sql); } /** *删除函数 * *@param string $table 表名 *@param string $where 条件 **/ function del($table,$where){ $sql = &quot;delete from &quot;.$table.&quot; where &quot;.$where;//删除sql语句 格式：delete from 表名 where 条件 $this-&gt;query($sql); } }]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第二十篇——session和cookie]]></title>
    <url>%2F2016%2F07%2F05%2FPHP%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AF%87%E2%80%94%E2%80%94session%E5%92%8Ccookie%2F</url>
    <content type="text"><![CDATA[关于session和cookie之前做iOS开发的时候听过，也试着去了解过，但是因为项目中并没有实际应用就没有研究过了，但是PHP开发的话必须了解并熟悉他们的使用，我目前的理解就是。cookie数据保存在客户端,session数据保存在服务器端…… session和cookiecookie简介Cookie是存储在客户端浏览器中的数据，我们通过Cookie来跟踪与存储用户数据。一般情况下，Cookie通过HTTP headers从服务端返回到客户端。多数web程序都支持Cookie的操作，因为Cookie是存在于HTTP的标头之中，所以必须在其他信息输出以前进行设置，类似于header函数的使用限制。 PHP通过setcookie函数进行Cookie的设置，任何从浏览器发回的Cookie，PHP都会自动的将他存储在$_COOKIE的全局变量之中，因此我们可以通过$_COOKIE[‘key’]的形式来读取某个Cookie值。 PHP中的Cookie具有非常广泛的使用，经常用来存储用户的登录信息，购物车等，且在使用会话Session时通常使用Cookie来存储会话id来识别用户，Cookie具备有效期，当有效期结束之后，Cookie会自动的从客户端删除。同时为了进行安全控制，Cookie还可以设置域跟路径，我们会在稍后的章节中详细的讲解他们。 官方文档的介绍PHP 透明地支持 HTTP cookie。cookie 是一种在远程浏览器端储存数据并以此来跟踪和识别用户的机制。可以用 setcookie() 或 setrawcookie() 函数来设置 cookie。cookie 是 HTTP 标头的一部分，因此 setcookie() 函数必须在其它信息被输出到浏览器前调用，这和对 header() 函数的限制类似。可以使用输出缓冲函数来延迟脚本的输出，直到按需要设置好了所有的 cookie 或者其它 HTTP 标头。 如果 variables_order 中包括“C”，则任何从客户端发送的 cookie 都会被自动包括进 $_COOKIE 自动全局数组。如果希望对一个 cookie 变量设置多个值，则需在 cookie 的名称后加 [] 符号。 根据 register_globals 的设置，可以从 cookie 建立普通的 PHP 变量。但是不推荐依赖于此特性，因为出于安全原因此选项通常是关闭的。在早期的 PHP 版本中，当 track_vars 配置选项打开时（此选项自 PHP 4.0.3 后总是打开的），系统还会设定 $HTTP_COOKIE_VARS。 会话机制（Session）在 PHP 中用于保存并发访问中的一些数据。这使可以帮助创建更为人性化的程序，增加站点的吸引力。关于会话机制的更多信息，请参见会话处理函数一章。 设置cookiePHP设置Cookie最常用的方法就是使用setcookie函数，setcookie具有7个可选参数，我们常用到的为前5个： name（ Cookie名）可以通过$_COOKIE[&apos;name&apos;] 进行访问 value（Cookie的值） expire（过期时间）Unix时间戳格式，默认为0，表示浏览器关闭即失效 path（有效路径）如果路径设置为&apos;/&apos;，则整个网站都有效 domain（有效域）默认整个域名都有效，如果设置了&apos;www.imooc.com&apos;,则只在www子域中有效 使用案例 $value = &apos;test&apos;; setcookie(&quot;TestCookie&quot;, $value); setcookie(&quot;TestCookie&quot;, $value, time()+3600); //有效期一小时 setcookie(&quot;TestCookie&quot;, $value, time()+3600, &quot;/path/&quot;, &quot;imooc.com&quot;); //设置路径与域 PHP中还有一个设置Cookie的函数setrawcookie，setrawcookie跟setcookie基本一样，唯一的不同就是value值不会自动的进行urlencode，因此在需要的时候要手动的进行urlencode。 setrawcookie(&apos;cookie_name&apos;, rawurlencode($value), time()+60*60*24*365); 因为Cookie是通过HTTP标头进行设置的，所以也可以直接使用header方法进行设置。 header(&quot;Set-Cookie:cookie_name=value&quot;); cookie的删除与过期时间通过前面的章节，我们了解了设置cookie的函数，但是我们却发现php中没有删除Cookie的函数，在PHP中删除cookie也是采用setcookie函数来实现。 setcookie(&apos;test&apos;, &apos;&apos;, time()-1); 可以看到将cookie的过期时间设置到当前时间之前，则该cookie会自动失效，也就达到了删除cookie的目的。之所以这么设计是因为cookie是通过HTTP的标头来传递的，客户端根据服务端返回的Set-Cookie段来进行cookie的设置，如果删除cookie需要使用新的Del-Cookie来实现，则HTTP头就会变得复杂，实际上仅通过Set-Cookie就可以简单明了的实现Cookie的设置、更新与删除。 了解原理以后，我们也可以直接通过header来删除cookie。 header(&quot;Set-Cookie:test=1393832059; expires=&quot;.gmdate(&apos;D, d M Y H:i:s \G\M\T&apos;, time()-1)); 这里用到了gmdate，用来生成格林威治标准时间，以便排除时差的影响。 cookie的有效路径cookie中的路径用来控制设置的cookie在哪个路径下有效，默认为’/‘，在所有路径下都有，当设定了其他路径之后，则只在设定的路径以及子路径下有效，例如： setcookie(&apos;test&apos;, time(), 0, &apos;/path&apos;); 上面的设置会使test在/path以及子路径/path/abc下都有效，但是在根目录下就读取不到test的cookie值。 一般情况下，大多是使用所有路径的，只有在极少数有特殊需求的时候，会设置路径，这种情况下只在指定的路径中才会传递cookie值，可以节省数据的传输，增强安全性以及提高性能。 当我们设置了有效路径的时候，不在当前路径的时候则看不到当前cookie。 setcookie(&apos;test&apos;, &apos;1&apos;,0, &apos;/path&apos;); var_dump($_COOKIE[&apos;test&apos;]); session与cookie的异同cookie将数据存储在客户端，建立起用户与服务器之间的联系，通常可以解决很多问题，但是cookie仍然具有一些局限： cookie相对不是太安全，容易被盗用导致cookie欺骗 单个cookie的值最大只能存储4k 每次请求都要进行网络传输，占用带宽 session是将用户的会话数据存储在服务端，没有大小限制，通过一个session_id进行用户识别，PHP默认情况下session id是通过cookie来保存的，因此从某种程度上来说，seesion依赖于cookie。但这不是绝对的，session id也可以通过参数来实现，只要能将session id传递到服务端进行识别的机制都可以使用session。 &lt;?php //开始使用session session_start(); //设置一个session $_SESSION[&apos;test&apos;] = time(); //显示当前的session_id echo &quot;session_id:&quot;.session_id(); echo &quot;&lt;br&gt;&quot;; //读取session值 echo $_SESSION[&apos;test&apos;]; //销毁一个session unset($_SESSION[&apos;test&apos;]); echo &quot;&lt;br&gt;&quot;; var_dump($_SESSION); session的一些配置:123456789101112131415161718session.auto_start //是否自动开启sessionsesson.cookie_domain // 存储session_id的cookie有效域session.cookie_lifetime // session_id的cookie有效的时间session.cookie_path // 保存的路径session.name // session_id 的名字session.save_path // session存储到服务器哪个文件session.use_cookies // 是否使用cookie在客户端保存session_id，默认为1session.save_handler // session存储的方式，默认是filesession.gc_probability = 1session.gc_divisor = 100定义在每次初始化会话时，启动垃圾回收程序的概率。计算公式如下：session.gc_probability/session.gc_divisor，比如1/100，表示有1%的概率启动启动垃圾回收程序，对会话页面访问越频繁，概率就应当越小。建议值为1/1000~5000。session.gc_maxlifetime = 1440设定保存的session文件生存期，超过此参数设定秒数后，保存的数据将被视为’垃圾’并由垃圾回收程序清理。 使用session在PHP中使用session非常简单，先执行session_start方法开启session，然后通过全局变量$_SESSION进行session的读写。 session_start(); $_SESSION[&apos;test&apos;] = time(); var_dump($_SESSION); session会自动的对要设置的值进行encode与decode，因此session可以支持任意数据类型，包括数据与对象等。 session_start(); $_SESSION[&apos;ary&apos;] = array(&apos;name&apos; =&gt; &apos;jobs&apos;); $_SESSION[&apos;obj&apos;] = new stdClass(); var_dump($_SESSION); 默认情况下，session是以文件形式存储在服务器上的，因此当一个页面开启了session之后，会独占这个session文件，这样会导致当前用户的其他并发访问无法执行而等待。可以采用缓存或者数据库的形式存储来解决这个问题，这个我们会在一些高级的课程中讲到。 删除与销毁session删除某个session值可以使用PHP的unset函数，删除后就会从全局变量$_SESSION中去除，无法访问。 session_start(); $_SESSION[&apos;name&apos;] = &apos;jobs&apos;; unset($_SESSION[&apos;name&apos;]); echo $_SESSION[&apos;name&apos;]; //提示name不存在 如果要删除所有的session，可以使用session_destroy函数销毁当前session，session_destroy会删除所有数据，但是session_id仍然存在。 session_start(); $_SESSION[&apos;name&apos;] = &apos;jobs&apos;; $_SESSION[&apos;time&apos;] = time(); session_destroy(); 值得注意的是，session_destroy并不会立即的销毁全局变量$_SESSION中的值，只有当下次再访问的时候，$_SESSION才为空，因此如果需要立即销毁$_SESSION，可以使用unset函数。 session_start(); $_SESSION[&apos;name&apos;] = &apos;jobs&apos;; $_SESSION[&apos;time&apos;] = time(); unset($_SESSION); session_destroy(); var_dump($_SESSION); //此时已为空 如果需要同时销毁cookie中的session_id，通常在用户退出的时候可能会用到，则还需要显式的调用setcookie方法删除session_id的cookie值。 session实战-登录session可以用来存储多种类型的数据，因此具有很多的用途，常用来存储用户的登录信息，购物车数据，或者一些临时使用的暂存数据等。 用户在登录成功以后，通常可以将用户的信息存储在session中，一般的会单独的将一些重要的字段单独存储，然后所有的用户信息独立存储。 $_SESSION[&apos;uid&apos;] = $userinfo[&apos;uid&apos;]; $_SESSION[&apos;userinfo&apos;] = $userinfo; 一般来说，登录信息既可以存储在sessioin中，也可以存储在cookie中，他们之间的差别在于session可以方便的存取多种数据类型，而cookie只支持字符串类型，同时对于一些安全性比较高的数据，cookie需要进行格式化与加密存储，而session存储在服务端则安全性较高。 &lt;?php session_start(); //假设用户登录成功获得了以下用户数据 $userinfo = array( &apos;uid&apos; =&gt; 10000, &apos;name&apos; =&gt; &apos;spark&apos;, &apos;email&apos; =&gt; &apos;spark@imooc.com&apos;, &apos;sex&apos; =&gt; &apos;man&apos;, &apos;age&apos; =&gt; &apos;18&apos; ); header(&quot;content-type:text/html; charset=utf-8&quot;); /* 将用户信息保存到session中 */ $_SESSION[&apos;uid&apos;] = $userinfo[&apos;uid&apos;]; $_SESSION[&apos;name&apos;] = $userinfo[&apos;name&apos;]; $_SESSION[&apos;userinfo&apos;] = $userinfo; //* 将用户数据保存到cookie中的一个简单方法 */ $secureKey = &apos;imooc&apos;; //加密密钥 $str = serialize($userinfo); //将用户信息序列化 //用户信息加密前 $str = base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, md5($secureKey), $str, MCRYPT_MODE_ECB)); //用户信息加密后 //将加密后的用户数据存储到cookie中 setcookie(&apos;userinfo&apos;, $str); //当需要使用时进行解密 $str = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, md5($secureKey), base64_decode($str), MCRYPT_MODE_ECB); $uinfo = unserialize($str); echo &quot;解密后的用户信息：&lt;br&gt;&quot;; print_r($uinfo); 当cookie被禁用时，传递session_id。123456&lt;a href=&quot;1.php?&lt;?php echo session_name().&apos;=&apos;.session_id()?&gt;&quot;&gt;下一页&lt;/a&gt;或者:&lt;a href=&quot;1.php?&lt;?= SID?&gt;&quot;&gt;下一页&lt;/a&gt;SID这个常量是session_name()和session_id()的拼接，并且如果开启cookie这个SID就是空。相较于上一种方法会智能一些 多台服务器session同步，一般是存在redis（mysql等也可以)。redis会自动用一种结构存储session，mysql需要建立对应的数据表]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第十九篇——GET/POST方式总结]]></title>
    <url>%2F2016%2F07%2F01%2FPHP%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AF%87%E2%80%94%E2%80%94GET-POST%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[关于PHP开发中大部分使用的是GET和POST的方式，这是HTTP的请求方式，当然还有其他的方式，有机会可以了解一下…… GET/POST方式总结HTTP协议中共定义了八种方法或者叫“动作”来表明对Request-URI指定的资源的不同操作方式，具体介绍如下： OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送&apos;*&apos;的请求来测试服务器的功能性。 HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 GET：向特定的资源发出请求。 POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。 PUT：向指定资源位置上传其最新内容。 DELETE：请求服务器删除Request-URI所标识的资源。 TRACE：回显服务器收到的请求，主要用于测试或诊断。 CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 虽然HTTP的请求方式有8种，但是我们在实际应用中常用的也就是get和post，其他请求方式也都可以通过这两种方式间接的来实现。 这里主要说其中最重要的两种：GET 和 POST在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。 GET - 从指定的资源请求数据。 POST - 向指定的资源提交要被处理的数据 GET 方法 请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的： /test/demo_form.asp?name1=value1&amp;name2=value2 有关 GET 请求的其他一些注释： GET 请求可被缓存 GET 请求保留在浏览器历史记录中 GET 请求可被收藏为书签 GET 请求不应在处理敏感数据时使用 GET 请求有长度限制 GET 请求只应当用于取回数据 POST 方法请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的： POST /test/demo_form.asp HTTP/1.1 Host: w3schools.com name1=value1&amp;name2=value2 有关 POST 请求的其他一些注释： POST 请求不会被缓存 POST 请求不会保留在浏览器历史记录中 POST 不能被收藏为书签 POST 请求对数据长度没有要求 下面的表格比较了两种 HTTP 方法：GET 和 POST。 区别 GET POST 后退按钮/刷新 无害 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。 书签 可收藏为书签 不可收藏为书签 缓存 能被缓存 不能缓存 编码类型 application/x-www-form-urlencoded application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 历史 参数保留在浏览器历史中。 参数不会保存在浏览器历史中。 对数据长度的限制 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 无限制。 对数据类型的限制 只允许 ASCII 字符。 没有限制。也允许二进制数据。 安全性 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。 在发送密码或其他敏感信息时绝不要使用 GET ！ POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 可见性 数据在 URL 中对所有人都是可见的。 数据不会显示在 URL 中。 PHP之GET/POST方式总结（六种）方法1: 用file_get_contents 以get方式获取内容：123456&lt;?php$url='http://www.jb51.net/';$html = file_get_contents($url);echo $html;?&gt; 方法2: 用fopen打开url, 以get方式获取内容：12345678910&lt;?php$fp = fopen($url, ‘r');stream_get_meta_data($fp);while(!feof($fp)) &#123;$result .= fgets($fp, 1024);&#125;echo “url body: $result”;fclose($fp);?&gt; 方法3：用file_get_contents函数,以post方式获取url1234567891011121314151617181920&lt;?php$data = array (‘foo' =&gt; ‘bar');$data = http_build_query($data);$opts = array (‘http' =&gt; array (‘method' =&gt; ‘POST',‘header'=&gt; “Content-type: application/x-www-form-urlencodedrn” .“Content-Length: ” . strlen($data) . “rn”,‘content' =&gt; $data));$context = stream_context_create($opts);$html = file_get_contents(‘http://localhost/e/admin/test.html', false, $context);echo $html;?&gt; 方法4：用fsockopen函数打开url，以get方式获取完整的数据，包括header和body,fsockopen需要 PHP.ini 中 allow_url_fopen 选项开启1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpfunction get_url ($url,$cookie=false)&#123;$url = parse_url($url);$query = $url[path].”?”.$url[query];echo “Query:”.$query;$fp = fsockopen( $url[host], $url[port]?$url[port]:80 , $errno, $errstr, 30);if (!$fp) &#123;return false;&#125; else &#123;$request = “GET $query HTTP/1.1rn”;$request .= “Host: $url[host]rn”;$request .= “Connection: Closern”;if($cookie) $request.=”Cookie: $cookien”;$request.=”rn”;fwrite($fp,$request);while(!@feof($fp)) &#123;$result .= @fgets($fp, 1024);&#125;fclose($fp);return $result;&#125;&#125;//获取url的html部分，去掉headerfunction GetUrlHTML($url,$cookie=false)&#123;$rowdata = get_url($url,$cookie);if($rowdata)&#123;$body= stristr($rowdata,”rnrn”);$body=substr($body,4,strlen($body));return $body;&#125;return false;&#125;?&gt; 方法5：用fsockopen函数打开url，以POST方式获取完整的数据，包括header和body12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpfunction HTTP_Post($URL,$data,$cookie, $referrer=”")&#123;// parsing the given URL$URL_Info=parse_url($URL);// Building referrerif($referrer==”") // if not given use this script as referrer$referrer=”111″;// making string from $dataforeach($data as $key=&gt;$value)$values[]=”$key=”.urlencode($value);$data_string=implode(“&amp;”,$values);// Find out which port is needed – if not given use standard (=80)if(!isset($URL_Info["port"]))$URL_Info["port"]=80;// building POST-request:$request.=”POST “.$URL_Info["path"].” HTTP/1.1n”;$request.=”Host: “.$URL_Info["host"].”n”;$request.=”Referer: $referern”;$request.=”Content-type: application/x-www-form-urlencodedn”;$request.=”Content-length: “.strlen($data_string).”n”;$request.=”Connection: closen”;$request.=”Cookie: $cookien”;$request.=”n”;$request.=$data_string.”n”;$fp = fsockopen($URL_Info["host"],$URL_Info["port"]);fputs($fp, $request);while(!feof($fp)) &#123;$result .= fgets($fp, 1024);&#125;fclose($fp);return $result;&#125;?&gt; 方法6:使用curl库，使用curl库之前，可能需要查看一下php.ini是否已经打开了curl扩展123456789101112&lt;?php$ch = curl_init();$timeout = 5;curl_setopt ($ch, CURLOPT_URL, ‘http://www.jb51.net/');curl_setopt ($ch, CURLOPT_RETURNTRANSFER, 1);curl_setopt ($ch, CURLOPT_CONNECTTIMEOUT, $timeout);$file_contents = curl_exec($ch);curl_close($ch);echo $file_contents;?&gt;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第十八篇——CURL初探]]></title>
    <url>%2F2016%2F06%2F26%2FPHP%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AF%87%E2%80%94%E2%80%94CURL%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[cURL 是一个利用URL语法规定来传输文件和数据的工具，支持很多协议，如HTTP、FTP、TELNET等。最爽的是，PHP也支持 cURL 库。本文将介绍 cURL 的一些高级特性，以及在PHP中如何运用它…… CURL初探1.cURL介绍 cURL 是一个利用URL语法规定来传输文件和数据的工具，支持很多协议，如HTTP、FTP、TELNET等。最爽的是，PHP也支持 cURL 库。本文将介绍 cURL 的一些高级特性，以及在PHP中如何运用它。 2.基本结构在学习更为复杂的功能之前，先来看一下在PHP中建立cURL请求的基本步骤： （1）初始化 curl_init() （2）设置变量 curl_setopt() 。最为重要，一切玄妙均在此。有一长串cURL参数可供设置，它们能指定URL请求的各个细节。要一次性全部看完并理解可能比较困难，所以今天我们只试一下那些更常用也更有用的选项。 （3）执行并获取结果 curl_exec() （4）释放cURL句柄 curl_close() 3.cURL实现Get和Post3.1 Get方式实现 //初始化 $ch = curl_init(); //设置选项，包括URL curl_setopt($ch, CURLOPT_URL, &quot;http://www.jb51.net&quot;); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, 0); //执行并获取HTML文档内容 $output = curl_exec($ch); //释放curl句柄 curl_close($ch); //打印获得的数据 print_r($output); 3.2 Post方式实现 $url = &quot;http://localhost/web_services.php&quot;; $post_data = array (&quot;username&quot; =&gt; &quot;bob&quot;,&quot;key&quot; =&gt; &quot;12345&quot;); $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); // post数据 curl_setopt($ch, CURLOPT_POST, 1); // post的变量 curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data); $output = curl_exec($ch); curl_close($ch); //打印获得的数据 print_r($output); 以上方式获取到的数据是json格式的，使用json_decode函数解释成数组。 $output_array = json_decode($output,true); 如果使用json_decode($output)解析的话，将会得到object类型的数据。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第十七篇——分页与实现]]></title>
    <url>%2F2016%2F06%2F20%2FPHP%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AF%87%E2%80%94%E2%80%94%E5%88%86%E9%A1%B5%E4%B8%8E%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[经常在网上看到分页的出现，最近没事。看看公司的后台代码，对这个小模块进行封装。制作成一个函数。现在将自己的这个思考过程，写下来。 分页与实现逻辑准备 实现分页，我们需要获取准备以下属性和方法 属性{ 数据总条数 每一页显示的条数 计算出总页数 获取当前是第几页 显示上一页 显示下一页 显示首页 显示尾页 每一页的url 数据限制limit } 方法{ 构造函数 计算总页数 获取当前页 获取上一页 获取下一页 获取首页 获取尾页 获取当前页面url 获取上一页url 获取下一页url 获取首页url 获取尾页irl 生成limit记录 重新生成url地址 显示分页链接，显示分页情况 } 根据上面的逻辑，下一步将文字转换为代码 首先，我们先声明一个Page类，按照逻辑进行属性声明,并且进行初始化 class Page { //记录总条数 protected $total; //每页显示几条 protected $nums; //总页数 protected $totalPages; //当前页码 protected $currentPage; //上一页页码 protected $prevPage; //下一页页码 protected $nextPage; //首页页码 protected $firstPage; //尾页页码 protected $endPage; //url protected $url; //limit,传到数据库的limit protected $limit; //构造函数，初始化 public function __construct($total, $nums) { $this-&gt;total = $total; $this-&gt;nums = $nums; $this-&gt;totalPages = $this-&gt;getTotalPages(); $this-&gt;currentPage = $this-&gt;getCurrentPage(); $this-&gt;getPrevPage(); $this-&gt;getNextPage(); $this-&gt;getFirstPage(); $this-&gt;getEndPage(); $this-&gt;getUrl(); } } 接下来我们开始完善方法 计算总页数 protected funciton getTotalPages() { return ceil($this-&gt;total / $this-&gt;$nums); } 获取当前页码 protected function getCurentPage() { //判断如果存在page参数并且page大于0，返回实际值，否则返回1 if(isset($_GET[&apos;page&apos;]) &amp;&amp; intval($_GET[&apos;page&apos;]) &gt; 0) { $this-&gt;currentPage = intval($_GET[&apos;page&apos;]); } else { $this-&gt;currentPage = 1; } return $this-&gt;currentPage; } 获取上一页 protected function getPrevPage() { $this-&gt;prevPage = $this-&gt;currentPage - 1; if($this-&gt;prevPage &lt; １) { $this-&gt;prevPage = 1; } return $this-&gt;prevPage; } 获取下一页 protected function getNextPage() { $this-&gt;nextPage = $this-&gt;currentPage + 1; return $this-&gt;nextPage; } 获取首页 protected function getFirstPage() { $this-&gt;firstPage = 1; return $this-&gt;firstPage; } 获取尾页 protected function getEndPage() { $this-&gt;endPage = $this-&gt;totalPages; return $this-&gt;endPage; } 接下来开始拼接每个页码的url 获取当前页的url protected function getCurrentUrl() { return $this-&gt;url.&apos;$page=&apos;.$this-&gt;currentPage; } 获取前一页的url protected function getPrevUrl() { return $this-&gt;url.&apos;&amp;page=&apos;.$this-&gt;prevPage; } 获取下一页的url protected function getNextUrl() { return $this-&gt;url.&apos;&amp;page=&apos;.$this-&gt;nextPage; } 获取首页的url protected function getFirstUrl() { return $this-&gt;url.&apos;&amp;page=&apos;.$this-&gt;firstPage; } 获取尾页的url protected function getEndUrl() { return $this-&gt;url.&apos;&amp;page=&apos;.$this-&gt;endPage; } 生成limit记录 public function limit() { return ($this-&gt;currentPage - 1) * $this-&gt;nums.&apos;,&apos;.$this-&gt;nums; } 生成url地址 public function getUrl() { //获取当前页面的文件位置 $url = $_SERVER[&apos;REQUEST_URI&apos;]; //将url参数解析成数组 $parse = parse_url($url); //获得域名地址 $path = $parse[&apos;path&apos;]; //获取参数 $query = isset($parse[&apos;query&apos;]) ? $parse[&apos;query&apos;] : false; //如果有参数，把page这个参数先给干掉，因为我们要重新拼接 if($query) { parse_str($query,$query); //干掉page参数，保留其他参数 unset($query[&apos;page&apos;]); //http_build_query拼将参数拼接成请求 $uri = $parse[&apos;path&apos;].&apos;?&apos;.http_build_query($query); } else { $uri = rtrim($parse[&apos;path&apos;],&apos;?&apos;).&apos;?&apos;; } //智能识别https和http协议和端口号 $protocal = (isset($_SERVER[&apos;SERVER_PORT&apos;]) &amp;&amp; $_SERVER[&apos;SERVER_PORT&apos;] == 443) ? &apos;https://&apos; : &apos;http://&apos;; switch ($_SERVER[&apos;SERVER_PORT&apos;]) { case 80: case 443: $uri = $protocal.$_SERVER[&apos;SERVER_NAME&apos;].$uri; break; default: $uri = $protocal.$_SERVER[&apos;SERVER_NAME&apos;].&apos;:&apos;.$_SERVER[&apos;SERVER_PORT&apos;].$uri; break; } $this-&gt;url = $uri; } 到此所有的逻辑方面都已经处理完啦，接下来的render()函数用来显示分页的链接 public function render() { return array( [&apos;first&apos; =&gt; $this-&gt;getFirstUrl()], [&apos;prev&apos; =&gt; $this-&gt;getPrevUrl()], [&apos;current&apos; =&gt; $this-&gt;getCurrentUrl()], [&apos;next&apos; =&gt; $this-&gt;getNextUrl()], [&apos;end&apos; =&gt; $this-&gt;getEndUrl()] ); } 哦也，就这么愉快的结束啦, 使用方法如下 //new一个对象 $page = new Page(102,10); //打印出来上页/下页/首页/尾页……的url var_dump($page-&gt;render()); 后记 $url = http://www.zhyunfe.com/OOP/Page.class.php?page=1 parse_url($url):将url的文件路径和参数分开并保存到数组中 .......................................... . array (size=2) . &apos;path&apos; =&gt; string &apos;/OOP/Page.class.php&apos; (length=36) . &apos;query&apos; =&gt; string &apos;page=1&apos; (length=6) .......................................... ... $query = &quot;page=1&amp;num=2&amp;sex=男&quot; parse_str($query,$query):将带参数的字符串解析成数组 .......................................... . array . &apos;page&apos; =&gt; 1 . &apos;num&apos; =&gt; 2 . &apos;sex&apos; =&gt; &apos;男&apos; .......................................... ... $query = [&apos;num&apos;=&gt;1,&apos;sex&apos;=&gt;&apos;男&apos;] http_build_query($query):使用给出的关联（或下标）数组生成一个经过 URL-encode 的请求字符串。 ......................................... . string . &quot;num=1&amp;&amp;sex=&apos;男&apos;&quot; ......................................... ... $_SERVER[&apos;SERVER_PORT&apos;] 获取端口号 $_SERVER[&apos;SERVER_NAME&apos;] 当前运行脚本所在的服务器的主机名。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第十六篇——正则表达式]]></title>
    <url>%2F2016%2F06%2F13%2FPHP%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AF%87%E2%80%94%E2%80%94%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[也许你之前听过，也许你之前用过，当然或许你之前没有听过或者没有接触过，说实话，做了这么久iOS开发，我也就用过两次，不知道是个人原因还是什么，但是其实正则表达式是几乎所有编程里面都有的，如果真的要说，估计要几个月，而且还说不完….. 字符串操作首先，如果你对正则感兴趣，我相信下面比较适合你的需求，不管是不是开始PHP开发，其他都是一样的，只是结合具体语言和语法实现想要的功能。 正则表达式30分钟入门教程 什么是正则表达式正则表达式是对字符串进行操作的一种逻辑公式，就是用一些特定的字符组合成一个规则字符串，称之为正则匹配模式。 $p = &apos;/apple/&apos;; $str = &quot;apple banna&quot;; if (preg_match($p, $str)) { echo &apos;matched&apos;; } 其中字符串’/apple/‘就是一个正则表达式，他用来匹配源字符串中是否存在apple字符串。 PHP中使用PCRE库函数进行正则匹配，比如上例中的preg_match用于执行一个正则匹配，常用来判断一类字符模式是否存在。 正则表达式基本语法PCRE库函数中，正则匹配模式使用分隔符与元字符组成，分隔符可以是非数字、非反斜线、非空格的任意字符。经常使用的分隔符是正斜线(/)、hash符号(#) 以及取反符号(~)，例如： /foo bar/ #^[^0-9]$# ~php~ 如果模式中包含分隔符，则分隔符需要使用反斜杠（\）进行转义。 /http:\/\// 如果模式中包含较多的分割字符，建议更换其他的字符作为分隔符，也可以采用preg_quote进行转义。 $p = &apos;http://&apos;; $p = &apos;/&apos;.preg_quote($p, &apos;/&apos;).&apos;/&apos;; echo $p; 分隔符后面可以使用模式修饰符，模式修饰符包括：i, m, s, x等，例如使用i修饰符可以忽略大小写匹配： $str = &quot;Http://www.imooc.com/&quot;; if (preg_match(&apos;/http/i&apos;, $str)) { echo &apos;匹配成功&apos;; } 元字符与转义正则表达式中具有特殊含义的字符称之为元字符，常用的元字符有： \ 一般用于转义字符 ^ 断言目标的开始位置(或在多行模式下是行首) $ 断言目标的结束位置(或在多行模式下是行尾) . 匹配除换行符外的任何字符(默认) [ 开始字符类定义 ] 结束字符类定义 | 开始一个可选分支 ( 子组的开始标记 ) 子组的结束标记 ? 作为量词，表示 0 次或 1 次匹配。位于量词后面用于改变量词的贪婪特性。 (查阅量词) * 量词，0 次或多次匹配 + 量词，1 次或多次匹配 { 自定义量词开始标记 } 自定义量词结束标记 使用案例 //下面的\s匹配任意的空白符，包括空格，制表符，换行符。[^\s]代表非空白符。[^\s]+表示一次或多次匹配非空白符。 $p = &apos;/^我[^\s]+(苹果|香蕉)$/&apos;; $str = &quot;我喜欢吃苹果&quot;; if (preg_match($p, $str)) { echo &apos;匹配成功&apos;; } 元字符具有两种使用场景，一种是可以在任何地方都能使用，另一种是只能在方括号内使用，在方括号内使用的有： \ 转义字符 ^ 仅在作为第一个字符(方括号内)时，表明字符类取反 - 标记字符范围 其中^在反括号外面，表示断言目标的开始位置，但在方括号内部则代表字符类取反，方括号内的减号-可以标记字符范围，例如0-9表示0到9之间的所有数字。 //下面的\w匹配字母或数字或下划线。 $p = &apos;/[\w\.\-]+@[a-z0-9\-]+\.(com|cn)/&apos;; $str = &quot;我的邮箱是Spark.eric@imooc.com&quot;; preg_match($p, $str, $match); echo $match[0]; 两种常见模式：贪婪与懒惰正则表达式中每个元字符匹配一个字符，当使用+之后将会变的贪婪，它将匹配尽可能多的字符，但使用问号?字符时，它将尽可能少的匹配字符，既是懒惰模式。 贪婪模式：在可匹配与可不匹配的时候，优先匹配 //下面的\d表示匹配数字 $p = &apos;/\d+\-\d+/&apos;; $str = &quot;我的电话是010-12345678&quot;; preg_match($p, $str, $match); echo $match[0]; //结果为：010-12345678 懒惰模式：在可匹配与可不匹配的时候，优先不匹配 $p = &apos;/\d?\-\d?/&apos;; $str = &quot;我的电话是010-12345678&quot;; preg_match($p, $str, $match); echo $match[0]; //结果为：0-1 当我们确切的知道所匹配的字符长度的时候，可以使用{}指定匹配字符数 $p = &apos;/\d{3}\-\d{8}/&apos;; $str = &quot;我的电话是010-12345678&quot;; preg_match($p, $str, $match); echo $match[0]; //结果为：010-12345678 正则匹配使用正则表达式的目的是为了实现比字符串处理函数更加灵活的处理方式，因此跟字符串处理函数一样，其主要用来判断子字符串是否存在、字符串替换、分割字符串、获取模式子串等。 PHP使用PCRE库函数来进行正则处理，通过设定好模式，然后调用相关的处理函数来取得匹配结果。 preg_match用来执行一个匹配，可以简单的用来判断模式是否匹配成功，或者取得一个匹配结果，他的返回值是匹配成功的次数0或者1，在匹配到1次以后就会停止搜索。 $subject = &quot;abcdef&quot;; $pattern = &apos;/def/&apos;; preg_match($pattern, $subject, $matches); print_r($matches); //结果为：Array ( [0] =&gt; def ) 上面的代码简单的执行了一个匹配，简单的判断def是否能匹配成功，但是正则表达式的强大的地方是进行模式匹配，因此更多的时候，会使用模式： $subject = &quot;abcdef&quot;; $pattern = &apos;/a(.*?)d/&apos;; preg_match($pattern, $subject, $matches); print_r($matches); //结果为：Array ( [0] =&gt; abcd [1] =&gt; bc ) 通过正则表达式可以匹配一个模式，得到更多的有用的数据。 查找匹配结果preg_match只能匹配一次结果，但很多时候我们需要匹配所有的结果，preg_match_all可以循环获取一个列表的匹配结果数组。 $p = &quot;|&lt;[^&gt;]+&gt;(.*?)&lt;/[^&gt;]+&gt;|i&quot;; $str = &quot;&lt;b&gt;example: &lt;/b&gt;&lt;div align=left&gt;this is a test&lt;/div&gt;&quot;; preg_match_all($p, $str, $matches); print_r($matches); 可以使用preg_match_all匹配一个表格中的数据： $p = &quot;/&lt;tr&gt;&lt;td&gt;(.*?)&lt;\/td&gt;\s*&lt;td&gt;(.*?)&lt;\/td&gt;\s*&lt;\/tr&gt;/i&quot;; $str = &quot;&lt;table&gt; &lt;tr&gt;&lt;td&gt;Eric&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;John&lt;/td&gt;&lt;td&gt;26&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt;&quot;; preg_match_all($p, $str, $matches); print_r($matches); $matches结果排序为$matches[0]保存完整模式的所有匹配, $matches[1] 保存第一个子组的所有匹配，以此类推 正则搜索与替换正则表达式的搜索与替换在某些方面具有重要用途，比如调整目标字符串的格式，改变目标字符串中匹配字符串的顺序等。 例如我们可以简单的调整字符串的日期格式： $string = &apos;April 15, 2014&apos;; $pattern = &apos;/(\w+) (\d+), (\d+)/i&apos;; $replacement = &apos;$3, ${1} $2&apos;; echo preg_replace($pattern, $replacement, $string); //结果为：2014, April 15 其中${1}与$1的写法是等效的，表示第一个匹配的字串，$2代表第二个匹配的。 通过复杂的模式，我们可以更加精确的替换目标字符串的内容。 $patterns = array (&apos;/(19|20)(\d{2})-(\d{1,2})-(\d{1,2})/&apos;, &apos;/^\s*{(\w+)}\s*=/&apos;); $replace = array (&apos;\3/\4/\1\2&apos;, &apos;$\1 =&apos;);//\3等效于$3,\4等效于$4，依次类推 echo preg_replace($patterns, $replace, &apos;{startDate} = 1999-5-27&apos;); //结果为：$startDate = 5/27/1999 //详细解释下结果：(19|20)表示取19或者20中任意一个数字，(\d{2})表示两个数字，(\d{1,2})表示1个或2个数字，(\d{1,2})表示1个或2个数字。^\s*{(\w+)\s*=}表示以任意空格开头的，并且包含在{}中的字符，并且以任意空格结尾的，最后有个=号的。 用正则替换来去掉多余的空格与字符： $str = &apos;one two&apos;; $str = preg_replace(&apos;/\s+/&apos;, &apos; &apos;, $str); echo $str; // 结果改变为&apos;one two&apos; 常见案例正则匹配常用在表单验证上，一些字段会有一定的格式要求，比如用户名一般都要求必须是字母、数字或下划线组成，邮箱、电话等也都有自己的规则，因此使用正则表达式可以很好的对这些字段进行验证。 &lt;?php $user = array( &apos;name&apos; =&gt; &apos;spark1985&apos;, &apos;email&apos; =&gt; &apos;spark@imooc.com&apos;, &apos;mobile&apos; =&gt; &apos;13312345678&apos; ); //进行一般性验证 if (empty($user)) { die(&apos;用户信息不能为空&apos;); } if (strlen($user[&apos;name&apos;]) &lt; 6) { die(&apos;用户名长度最少为6位&apos;); } //用户名必须为字母、数字与下划线 if (!preg_match(&apos;/^\w+$/i&apos;, $user[&apos;name&apos;])) { die(&apos;用户名不合法&apos;); } //验证邮箱格式是否正确 if (!preg_match(&apos;/^[\w\.]+@\w+\.\w+$/i&apos;, $user[&apos;email&apos;])) { die(&apos;邮箱不合法&apos;); } //手机号必须为11位数字，且为1开头 if (!preg_match(&apos;/^1\d{10}$/i&apos;, $user[&apos;mobile&apos;])) { die(&apos;手机号不合法&apos;); } echo &apos;用户信息验证成功&apos;;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第十五篇——异常处理]]></title>
    <url>%2F2016%2F06%2F09%2FPHP%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AF%87%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[关于异常处理和了解，我相信是任何一门语言或者做任何开发的程序员都应该知道的东西，如果你没用过可以理解，但是如果你说没有听过，那么对不起，请绕道…… 异常处理抛出一个异常从PHP5开始，PHP支持异常处理，异常处理是面向对象一个重要特性，PHP代码中的异常通过throw抛出，异常抛出之后，后面的代码将不会再被执行。 既然抛出异常会中断程序执行，那么为什么还需要使用异常处理？ 异常抛出被用于在遇到未知错误，或者不符合预先设定的条件时，通知客户程序，以便进行其他相关处理，不至于使程序直接报错中断。 当代码中使用了try catch的时候，抛出的异常会在catch中捕获，否则会直接中断。 基本语法try{ //可能出现错误或异常的代码 //catch表示捕获，Exception是php已定义好的异常类 } catch(Exception $e){ //对异常处理，方法： //1、自己处理 //2、不处理，将其再次抛出 } 处理处理程序应当包括：Try - 使用异常的函数应该位于 “try” 代码块内。如果没有触发异常，则代码将照常继续执行。但是如果异常被触发，会抛出一个异常。Throw - 这里规定如何触发异常。注意：每一个 “throw” 必须对应至少一个 “catch”，当然可以对应多个”catch”Catch - “catch” 代码块会捕获异常，并创建一个包含异常信息的对象。 //创建可抛出一个异常的函数 function checkNum($number){ if($number&gt;1){ throw new Exception(&quot;异常提示-数字必须小于等于1&quot;); } return true; } //在 &quot;try&quot; 代码块中触发异常 try{ checkNum(2); //如果异常被抛出，那么下面一行代码将不会被输出 echo &apos;如果能看到这个提示，说明你的数字小于等于1&apos;; }catch(Exception $e){ //捕获异常 echo &apos;捕获异常: &apos; .$e-&gt;getMessage(); } 上面代码将获得类似这样一个错误： 捕获异常:: 异常提示-数字必须小于等于1 例子解释： 上面的代码抛出了一个异常，并捕获了它： 创建 checkNum() 函数。它检测数字是否大于 1。如果是，则抛出一个异常。 在 &quot;try&quot; 代码块中调用 checkNum() 函数。 checkNum() 函数中的异常被抛出 &quot;catch&quot; 代码块接收到该异常，并创建一个包含异常信息的对象 ($e)。 通过从这个 exception 对象调用 $e-&gt;getMessage()，输出来自该异常的错误消息 异常类与异常处理PHP具有很多异常处理类，其中Exception是所有异常处理的基类。 Exception具有几个基本属性与方法，其中包括了： message 异常消息内容 code 异常代码 file 抛出异常的文件名 line 抛出异常在该文件的行数 其中常用的方法有： getTrace 获取异常追踪信息 getTraceAsString 获取异常追踪信息的字符串 getMessage 获取出错信息 如果必要的话，可以通过继承Exception类来建立自定义的异常处理类。 //自定义的异常类，继承了PHP的异常基类Exception class MyException extends Exception { function getInfo() { return &apos;自定义错误信息&apos;; } } try { //使用异常的函数应该位于 &quot;try&quot; 代码块内。如果没有触发异常，则代码将照常继续执行。但是如果异常被触发，会抛出一个异常。 throw new MyException(&apos;error&apos;);//这里规定如何触发异常。注意：每一个 &quot;throw&quot; 必须对应至少一个 &quot;catch&quot;，当然可以对应多个&quot;catch&quot; } catch(Exception $e) {//&quot;catch&quot; 代码块会捕获异常，并创建一个包含异常信息的对象 echo $e-&gt;getInfo();//获取自定义的异常信息 echo $e-&gt;getMessage();//获取继承自基类的getMessage信息 } 捕捉异常信息在了解了异常处理的基本原理之后，我们可以通过try catch来捕获异常，我们将执行的代码放在try代码块中，一旦其中的代码抛出异常，就能在catch中捕获。 这里我们只是通过案例来了解try catch的机制以及异常捕获的方法，在实际应用中，不会轻易的抛出异常，只有在极端情况或者非常重要的情况下，才会抛出异常，抛出异常，可以保障程序的正确性与安全，避免导致不可预知的bug。 一般的异常处理流程代码为： try { throw new Exception(&apos;wrong&apos;); } catch(Exception $ex) { echo &apos;Error:&apos;.$ex-&gt;getMessage().&apos;&lt;br&gt;&apos;; echo $ex-&gt;getTraceAsString().&apos;&lt;br&gt;&apos;; } echo &apos;异常处理后，继续执行其他代码&apos;; 获取错误发生所在位置在异常被捕获之后，我们可以通过异常处理对象获取其中的异常信息，前面我们已经了解捕获方式，以及获取基本的错误信息。 在实际应用中，我们通常会获取足够多的异常信息，然后写入到错误日志中。 通过我们需要将报错的文件名、行号、错误信息、异常追踪信息等记录到日志中，以便调试与修复问题 &lt;?php try { throw new Exception(&apos;wrong&apos;); } catch(Exception $ex) { $msg = &apos;Error:&apos;.$ex-&gt;getMessage().&quot;\n&quot;; $msg.= $ex-&gt;getTraceAsString().&quot;\n&quot;; $msg.= &apos;异常行号：&apos;.$ex-&gt;getLine().&quot;\n&quot;; $msg.= &apos;所在文件：&apos;.$ex-&gt;getFile().&quot;\n&quot;; //将异常信息记录到日志中 PHP异常处理之 file_put_contents(&apos;error.log&apos;, $msg); }]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第十四篇——图像与图像操作]]></title>
    <url>%2F2016%2F06%2F07%2FPHP%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AF%87%E2%80%94%E2%80%94%E5%9B%BE%E5%83%8F%E4%B8%8E%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[PHP关于图像处理其实还是挺重要的，只是如果你只是做API开发的话，其实根本用不到，但是做Web的话可算是一个比较重要的技术，既然看到这里我们就简单了解一下…… 图像与图像操作GD库简介GD指的是Graphic Device，PHP的GD库是用来处理图形的扩展库，通过GD库提供的一系列API，可以对图像进行处理或者直接生成新的图片。 PHP除了能进行文本处理以外，通过GD库，可以对JPG、PNG、GIF、SWF等图片进行处理。GD库常用在图片加水印，验证码生成等方面。 PHP默认已经集成了GD库，只需要在安装的时候开启就行。 header(&quot;content-type: image/png&quot;); $img=imagecreatetruecolor(100, 100); $red=imagecolorallocate($img, 0xFF, 0x00, 0x00); imagefill($img, 0, 0, $red); imagepng($img); imagedestroy($img); 绘制线条要对图形进行操作，首先要新建一个画布，通过imagecreatetruecolor函数可以创建一个真彩色的空白图片： $img = imagecreatetruecolor(100, 100); GD库中对于画笔所用的颜色，需要通过imagecolorallocate函数进行分配，通过参数设定RGB的颜色值来确定画笔的颜色： $red = imagecolorallocate($img, 0xFF, 0x00, 0x00); 然后我们通过调用绘制线段函数imageline进行线条的绘制，通过指定起点跟终点来最终得到线条。 imageline($img, 0, 0, 100, 100, $red); 线条绘制好以后，通过header与imagepng进行图像的输出。 header(&quot;content-type: image/png&quot;); imagepng($img); 最后可以调用imagedestroy释放该图片占用的内存。 imagedestroy($img); 通过上面的步骤，可以发现PHP绘制图形非常的简单，但很多时候我们不只是需要输出图片，可能我们还需要得到一个图片文件，可以通过imagepng函数指定文件名将绘制后的图像保存到文件中。 imagepng($img, &apos;img.png&apos;); 绘制文字GD库可以进行多种图形的基本操作，常用的有绘制线条，背景填充，画矩形，绘制文字等。 跟绘制线条类似，首先需要新建一个图片与初始化颜色。 $img = imagecreatetruecolor(100, 100); $red = imagecolorallocate($img, 0xFF, 0x00, 0x00); 然后使用imagestring函数来进行文字的绘制，这个函数的参数很多：imagestring ( resource $image , int $font , int $x , int $y , string $s , int $col )，可以通过$font来设置字体的大小，x,y设置文字显示的位置，$s是要绘制的文字,$col是文字的颜色。 imagestring($img, 5, 0, 0, &quot;Hello world&quot;, $red); header(&quot;content-type: image/png&quot;); imagepng($img); imagedestroy($img); 输出图形文件前面我们已经了解到，通过imagepng可以直接输出图像到浏览器，但是很多时候，我们希望将处理好的图像保存到文件，以便可以多次使用。通过指定路径参数将图像保存到文件中。 $filename = &apos;img.png&apos;; imagepng($img, $filename); 使用imagepng可以将图像保存成png格式，如果要保存成其他格式需要使用不同的函数，使用imagejpeg将图片保存成jpeg格式，imagegif将图片保存成gif格式，需要说明的是，imagejpeg会对图片进行压缩，因此还可以设置一个质量参数。 $filename = &apos;img.jpg&apos;; ​imagejpeg($img, $filename, 80); 生成图形验证码简单的验证码其实就是在图片中输出了几个字符，通过我们前面章节讲到的imagestring函数就能实现。 但是在处理上，为了使验证码更加的安全，防止其他程序自动识别，因此常常需要对验证码进行一些干扰处理，通常会采用绘制一些噪点，干扰线段，对输出的字符进行倾斜、扭曲等操作。 可以使用imagesetpixel绘制点来实现噪点干扰，但是只绘制一个点的作用不大，因此这里常常会使用循环进行随机绘制。 for($i=0;$i&lt;50;$i++) { imagesetpixel($im, rand(0, 100) , rand(0, 100) , $black); imagesetpixel($im, rand(0, 100) , rand(0, 100) , $green); } 实例 &lt;?php $img = imagecreatetruecolor(100, 40); $black = imagecolorallocate($img, 0x00, 0x00, 0x00); $green = imagecolorallocate($img, 0x00, 0xFF, 0x00); $white = imagecolorallocate($img, 0xFF, 0xFF, 0xFF); imagefill($img,0,0,$white); //生成随机的验证码 $code = &apos;&apos;; for($i = 0; $i &lt; 4; $i++) { $code .= rand(0, 9); } imagestring($img, 5, 10, 10, $code, $black); //加入噪点干扰 for($i=0;$i&lt;50;$i++) { imagesetpixel($img, rand(0, 100) , rand(0, 100) , $black); imagesetpixel($img, rand(0, 100) , rand(0, 100) , $green); } //输出验证码 header(&quot;content-type: image/png&quot;); imagepng($img); imagedestroy($img); 加水印给图片添加水印的方法一般有两种，一种是在图片上面加上一个字符串，另一种是在图片上加上一个logo或者其他的图片。 因为这里处理的是已经存在的图片，所以可以直接从已存在的图片建立画布，通过imagecreatefromjpeg可以直接从图片文件创建图像。 $im = imagecreatefromjpeg($filename); 创建图像对象以后，我们就可以通过前面的GD函数，绘制字符串到图像上。如果要加的水印是一个logo图片，那么就需要再建立一个图像对象，然后通过GD函数imagecopy将logo的图像复制到源图像中。 $logo = imagecreatefrompng($filename); imagecopy($im, $logo, 15, 15, 0, 0, $width, $height); 当将logo图片复制到原图片上以后，将加水印后的图片输出保存就完成了加水印处理。 imagejpeg($im, $filename); 使用案例 &lt;?php //这里仅仅是为了案例需要准备一些素材图片 $url = &apos;http://www.iyi8.com/uploadfile/2014/0521/20140521105216901.jpg&apos;; $content = file_get_contents($url); $filename = &apos;tmp.jpg&apos;; file_put_contents($filename, $content); $url = &apos;http://wiki.ubuntu.org.cn/images/3/3b/Qref_Edubuntu_Logo.png&apos;; file_put_contents(&apos;logo.png&apos;, file_get_contents($url)); //开始添加水印操作 $im = imagecreatefromjpeg($filename); $logo = imagecreatefrompng(&apos;logo.png&apos;); $size = getimagesize(&apos;logo.png&apos;); imagecopy($im, $logo, 15, 15, 0, 0, $size[0], $size[1]); header(&quot;content-type: image/jpeg&quot;); imagejpeg($im);]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第十三篇——文件处理]]></title>
    <url>%2F2016%2F06%2F02%2FPHP%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AF%87%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[文件处理在PHP开发中也是比较常见的，或者你使用的是缓存，但是毕竟根据需求总有用到文件的地方，所以….. 文件处理读取文件内容PHP具有丰富的文件操作函数，最简单的读取文件的函数为file_get_contents，可以将整个文件全部读取到一个字符串中。 $content = file_get_contents(&apos;./test.txt&apos;); file_get_contents也可以通过参数控制读取内容的开始点以及长度。 $content = file_get_contents(&apos;./test.txt&apos;, null, null, 100, 500); PHP也提供类似于C语言操作文件的方法，使用fopen，fgets，fread等方法，fgets可以从文件指针中读取一行，freads可以读取指定长度的字符串。 $fp = fopen(&apos;./text.txt&apos;, &apos;rb&apos;); while(!feof($fp)) { echo fgets($fp); //读取一行 } fclose($fp); $fp = fopen(&apos;./text.txt&apos;, &apos;rb&apos;); $contents = &apos;&apos;; while(!feof($fp)) { $contents .= fread($fp, 4096); //一次读取4096个字符 } fclose($fp); 使用fopen打开的文件，最好使用fclose关闭文件指针，以避免文件句柄被占用。 判断文件是否存在一般情况下在对文件进行操作的时候需要先判断文件是否存在，PHP中常用来判断文件存在的函数有两个is_file与file_exists. $filename = &apos;./test.txt&apos;; if (file_exists($filename)) { echo file_get_contents($filename); } 如果只是判断文件存在，使用file_exists就行，file_exists不仅可以判断文件是否存在，同时也可以判断目录是否存在，从函数名可以看出，is_file是确切的判断给定的路径是否是一个文件。 $filename = &apos;./test.txt&apos;; if (is_file($filename)) { echo file_get_contents($filename); } 更加精确的可以使用is_readable与is_writeable在文件是否存在的基础上，判断文件是否可读与可写。 $filename = &apos;./test.txt&apos;; if (is_writeable($filename)) { file_put_contents($filename, &apos;test&apos;); } if (is_readable($filename)) { echo file_get_contents($filename); } 获取修改时间文件有很多元属性，包括：文件的所有者、创建时间、修改时间、最后的访问时间等。 fileowner：获得文件的所有者 filectime：获取文件的创建时间 filemtime：获取文件的修改时间 fileatime：获取文件的访问时间 其中最常用的是文件的修改时间，通过文件的修改时间，可以判断文件的时效性，经常用在静态文件或者缓存数据的更新。 $mtime = filemtime($filename); echo &apos;修改时间：&apos;.date(&apos;Y-m-d H:i:s&apos;, filemtime($filename)); 使用案例 &lt;?php $filename = &apos;/data/webroot/usercode/code/resource/test.txt&apos;; echo &apos;所有者：&apos;.fileowner($filename).&apos;&lt;br&gt;&apos;; echo &apos;创建时间：&apos;.filectime($filename).&apos;&lt;br&gt;&apos;; echo &apos;修改时间：&apos;.filemtime($filename).&apos;&lt;br&gt;&apos;; echo &apos;最后访问时间：&apos;.fileatime($filename).&apos;&lt;br&gt;&apos;; //给$mtime赋值为文件的修改时间 $mtime = time(); //通过计算时间差 来判断文件内容是否有效 if (time() - $mtime &gt; 3600) { echo &apos;&lt;br&gt;缓存已过期&apos;; } else { echo file_get_contents($filename); } 获取文件大小通过filesize函数可以取得文件的大小，文件大小是以字节数表示的。 $filename = &apos;/data/webroot/usercode/resource/test.txt&apos;; $size = filesize($filename); 如果要转换文件大小的单位，可以自己定义函数来实现。 function getsize($size, $format = &apos;kb&apos;) { $p = 0; if ($format == &apos;kb&apos;) { $p = 1; } elseif ($format == &apos;mb&apos;) { $p = 2; } elseif ($format == &apos;gb&apos;) { $p = 3; } $size /= pow(1024, $p); return number_format($size, 3); } $filename = &apos;/data/webroot/usercode/code/resource/test.txt&apos;; $size = filesize($filename); $size = getsize($size, &apos;kb&apos;); //进行单位转换 echo $size.&apos;kb&apos;; 值得注意的是，没法通过简单的函数来取得目录的大小，目录的大小是该目录下所有子目录以及文件大小的总和，因此需要通过递归的方法来循环计算目录的大小。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第十二篇——时间与日期处理]]></title>
    <url>%2F2016%2F05%2F29%2FPHP%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AF%87%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E4%B8%8E%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[关于时间与日期的处理，根据这么多年iOS开发的经验，我觉得在PHP中可以说是无处不在，只是可能如果你做的比较好的话，处理一次或者抽好了就可以通用…… 时间与日期处理首先我们需要知道PHP中关于时间的处理时间戳应该算是最好的方案，一个字：快！ 获取当前时间戳UNIX 时间戳（英文叫做：timestamp）是 PHP 中关于时间与日期的一个很重要的概念，它表示从 1970年1月1日 00:00:00 到当前时间的秒数之和。 PHP提供了内置函数 time() 来取得服务器当前时间的时间戳。那么获取当前的UNIX时间戳就很简单了。 $time = time(); echo $time;//1396193923，这个数字表示从1970年1月1日 00:00:00 到我输出这个脚本时经历了1396193923秒 获取当前日期php内置了date()函数，来取得当前的日期。 函数说明：date(时间戳的格式, 规定时间戳【默认是当前的日期和时间，可选】) 返回值：函数日期和时间 例子： //date函数，第二个参数取默认值的情况 echo date(&quot;Y-m-d&quot;);//2014-03-30 //date函数，第二个参数有值的情况 echo date(&quot;Y-m-d&quot;,&apos;1396193923&apos;);//2014-03-30,1396193923表示2014-03-30的unix时间戳 获取日期对应的时间戳UNIX 时间戳（英文叫做：timestamp）是 PHP 中关于时间与日期的一个很重要的概念，它表示从 1970年1月1日 00:00:00 到当前时间的秒数之和。 PHP提供了内置函数strtotime实现功能：获取某个日期的时间戳，或获取某个时间的时间戳。例如： echo strtotime(&apos;2014-04-29&apos;);//1398700800，这个数字表示从1970年1月1日 00:00:00 到2014年4月29号经历了1398700800秒 echo strtotime(&apos;2014-04-29 00:00:01&apos;);//1398700801，这个数字表示从1970年1月1日 00:00:00 到2014-04-29 00:00:01时经历了1398700801秒 大家发现上面的规律了吗，其实strtotime(‘2014-04-29’)相当于strtotime(‘2014-04-29 00:00:00’) 格式化日期strtotime函数预期接受一个包含美国英语日期格式的字符串并尝试将其解析为 Unix 时间戳。 函数说明：strtotime(要解析的时间字符串, 计算返回值的时间戳【默认是当前的时间，可选】) 返回值：成功则返回时间戳，否则返回 FALSE 比如 echo strtotime(&quot;now&quot;);//相当于将英文单词now直接等于现在的日期和时间，并把这个日期时间转化为unix时间戳。这个效果跟echo time();一样。 echo strtotime(&quot;+1 seconds&quot;);//相当于将现在的日期和时间加上了1秒，并把这个日期时间转化为unix时间戳。这个效果跟echo time()+1;一样。 echo strtotime(&quot;+1 day&quot;);//相当于将现在的日期和时间加上了1天。 echo strtotime(&quot;+1 week&quot;);//相当于将现在的日期和时间加上了1周。 echo strtotime(&quot;+1 week 3 days 7 hours 5 seconds&quot;);//相当于将现在的日期和时间加上了1周3天7小时5秒。 格式化格林威治时间gmdate 函数能格式化一个GMT的日期和时间，返回的是格林威治标准时（GMT）。 举个例子，我们现在所在的中国时区是东八区，领先格林威治时间8个小时，有时候也叫GMT+8，那么服务器运行以下脚本返回的时间应该是这样的：当前时间假定是2014-05-01 15:15:22 echo date(&apos;Y-m-d H:i:s&apos;, time()); //输出为：2014-05-01 15:15:22 echo gmdate(&apos;Y-m-d H:i:s&apos;, time()); //输出为：2014-05-01 07:15:22 因为格林威治时间是现在中国时区的时间减去8个小时，所以相对于现在时间要少8个小时]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第十一篇——万物皆对象]]></title>
    <url>%2F2016%2F05%2F27%2FPHP%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AF%87%E2%80%94%E2%80%94%E4%B8%87%E7%89%A9%E7%9A%86%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[所谓万物皆对象，我相信做过面向对象开发的人应该都知道这个到底，但是真正理解开发中的面向对应只有真实动手开发并且慢慢总结才能知道里面的含义，iOS可谓是纯面向对象的语言，当然还有很多其他的…. 万物皆对象类与对象通常定义一个汽车类的方法为： class Car { //定义一个Car类 $name = &apos;汽车&apos;; //属性 function getName() { //方法 return $this-&gt;name; //返回 } } 方法内部可以使用$this伪变量调用对象的属性或者方法 类是一类东西的结构描述，而对象则是一类东西的一个具体实例，例如汽车这个名词可以理解为汽车的总类，但这辆汽车则是一个具体的汽车对象。 对象通过new关键字进行实例化： $car = new Car(); //实例化一个对象 或者可以这样： $className = &apos;Car&apos;; $car = new $className(); echo $car-&gt;getName(); //调用对象的方法 类与对象看起来比较相似，但实际上有本质的区别，类是抽象的概念，对象是具体的实例。类可以使程序具有可重用性。 属性在类中定义的变量称之为属性，通常属性跟数据库中的字段有一定的关联，因此也可以称作“字段”。属性声明是由关键字 public，protected 或者 private 开头，后面跟一个普通的变量声明来组成。属性的变量可以设置初始化的默认值，默认值必须是常量。 访问控制的关键字代表的意义为： public：公开的protected：受保护的private：私有的 class Car { //定义公共属性 public $name = &apos;汽车&apos;; //定义受保护的属性 protected $corlor = &apos;白色&apos;; //定义私有属性 private $price = &apos;100000&apos;; } 默认都为public，外部可以访问。一般通过-&gt;对象操作符来访问对象的属性或者方法，对于静态属性则使用::双冒号进行访问。当在类成员方法内部调用的时候，可以使用$this伪变量调用当前对象的属性。 $car = new Car(); echo $car-&gt;name; //调用对象的属性 echo $car-&gt;color; //错误 受保护的属性不允许外部调用 echo $car-&gt;price; //错误 私有属性不允许外部调用 受保护的属性与私有属性不允许外部调用，在类的成员方法内部是可以调用的。 class Car{ private $price = &apos;1000&apos;; public function getPrice() { return $this-&gt;price; //内部访问私有属性 ​ } } 方法方法就是在类中的function，很多时候我们分不清方法与函数有什么差别，在面向过程的程序设计中function叫做函数，在面向对象中function则被称之为方法 同属性一样，类的方法也具有public，protected 以及 private 的访问控制。 访问控制的关键字代表的意义为：public：公开的protected：受保护的private：私有的 实例方法 class Car { public function getName() { return &apos;汽车&apos;; } ​} $car = new Car(); echo $car-&gt;getName(); 类方法 使用关键字static修饰的，称之为静态方法，静态方法不需要实例化对象，可以通过类名直接调用，操作符为双冒号::。 class Car { public static function getName() { return &apos;汽车&apos;; } ​} echo Car::getName(); //结果为“汽车” 构造函数和析构函数PHP5可以在类中使用__construct()定义一个构造函数，具有构造函数的类，会在每次对象创建的时候调用该函数，因此常用来在对象创建的时候进行一些初始化工作。 class Car { function __construct() { print &quot;构造函数被调用\n&quot;; //进行一些初始化工作 } } $car = new Car(); //实例化的时候 会自动调用构造函数__construct，这里会输出一个字符串 在子类中如果定义了construct则不会调用父类的construct，如果需要同时调用父类的构造函数，需要使用parent::__construct()显式的调用。 class Car { function __construct() { print &quot;父类构造函数被调用\n&quot;; } } class Truck extends Car { function __construct() { print &quot;子类构造函数被调用\n&quot;; parent::__construct(); } } $car = new Truck(); 同样，PHP5支持析构函数，使用__destruct()进行定义，析构函数指的是当某个对象的所有引用被删除，或者对象被显式的销毁时会执行的函数。 class Car { function __construct() { print &quot;构造函数被调用 \n&quot;; } function __destruct() { print &quot;析构函数被调用 \n&quot;; } } $car = new Car(); //实例化时会调用构造函数 echo &apos;使用后，准备销毁car对象 \n&apos;; unset($car); //销毁时会调用析构函数 当PHP代码执行完毕以后，会自动回收与销毁对象，因此一般情况下不需要显式的去销毁对象。 Static静态关键字静态属性与方法可以在不实例化类的情况下调用，直接使用类名::方法名的方式进行调用。静态属性不允许对象使用-&gt;操作符调用。 class Car { private static $speed = 10; public static function getSpeed() { return self::$speed; } } echo Car::getSpeed(); //调用静态方法 静态方法也可以通过变量来进行动态调用 $func = &apos;getSpeed&apos;; $className = &apos;Car&apos;; echo $className::$func(); //动态调用静态方法 静态方法中，$this伪变量不允许使用。可以使用self，parent，static在内部调用静态方法与属性。 class Car { private static $speed = 10; public static function getSpeed() { return self::$speed; } public static function speedUp() { return self::$speed+=10; } } class BigCar extends Car { public static function start() { parent::speedUp(); } } BigCar::start(); echo BigCar::getSpeed(); 访问控制被定义为公有的类成员可以在任何地方被访问。 被定义为受保护的类成员则可以被其自身以及其子类和父类访问。 被定义为私有的类成员则只能被其定义所在的类访问 类属性必须定义为公有、受保护、私有之一。为兼容PHP5以前的版本，如果采用 var 定义，则被视为公有。 class Car { $speed = 10; //错误 属性必须定义访问控制 public $name; //定义共有属性 } 类中的方法可以被定义为公有、私有或受保护。如果没有设置这些关键字，则该方法默认为公有。 class Car { ​ //默认为共有方法 function turnLeft() { } } 如果构造函数定义成了私有方法，则不允许直接实例化对象了，这时候一般通过静态方法进行实例化，在设计模式中会经常使用这样的方法来控制对象的创建，比如单例模式只允许有一个全局唯一的对象。 class Car { private function __construct() { echo &apos;object create&apos;; } private static $_object = null; public static function getInstance() { if (empty(self::$_object)) { self::$_object = new Car(); //内部方法可以调用私有方法，因此这里可以创建对象 } return self::$_object; } } //$car = new Car(); //这里不允许直接实例化对象 $car = Car::getInstance(); //通过静态方法来获得一个实例 对象继承继承是面向对象程序设计中常用的一个特性，汽车是一个比较大的类，我们也可以称之为基类，除此之外，汽车还分为卡车、轿车、东风、宝马等，因为这些子类具有很多相同的属性和方法，可以采用继承汽车类来共享这些属性与方法，实现代码的复用。 &lt;?php class Car { public $speed = 0; //汽车的起始速度是0 public function speedUp() { $this-&gt;speed += 10; return $this-&gt;speed; } } //定义继承于Car的Truck类 class Truck extends Car { public function speedUp() { parent::speedUp(); $this-&gt;speed += 50; return $this-&gt;speed; } } $car = new Truck(); $car-&gt;speedUp(); echo $car-&gt;speed; 重载PHP中的重载指的是动态的创建属性与方法，是通过魔术方法来实现的。属性的重载通过set，get，isset，unset来分别实现对不存在属性的赋值、读取、判断属性是否设置、销毁属性。 class Car { private $ary = array(); public function __set($key, $val) { $this-&gt;ary[$key] = $val; } public function __get($key) { if (isset($this-&gt;ary[$key])) { return $this-&gt;ary[$key]; } return null; } public function __isset($key) { if (isset($this-&gt;ary[$key])) { return true; } return false; } public function __unset($key) { unset($this-&gt;ary[$key]); } } $car = new Car(); $car-&gt;name = &apos;汽车&apos;; //name属性动态创建并赋值 echo $car-&gt;name; 方法的重载通过call来实现，当调用不存在的方法的时候，将会转为参数调用call方法，当调用不存在的静态方法时会使用__callStatic重载。 class Car { public $speed = 0; public function __call($name, $args) { if ($name == &apos;speedUp&apos;) { $this-&gt;speed += 10; } } } $car = new Car(); $car-&gt;speedUp(); //调用不存在的方法会使用重载 echo $car-&gt;speed; 高级特性对象比较，当同一个类的两个实例的所有属性都相等时，可以使用比较运算符==进行判断，当需要判断两个变量是否为同一个对象的引用时，可以使用全等运算符===进行判断。 class Car { } $a = new Car(); $b = new Car(); if ($a == $b) echo &apos;==&apos;; //true if ($a === $b) echo &apos;===&apos;; //false 对象复制，在一些特殊情况下，可以通过关键字clone来复制一个对象，这时__clone方法会被调用，通过这个魔术方法来设置属性的值。 class Car { public $name = &apos;car&apos;; public function __clone() { $obj = new Car(); $obj-&gt;name = $this-&gt;name; } } $a = new Car(); $a-&gt;name = &apos;new car&apos;; $b = clone $a; var_dump($b); 对象序列化，可以通过serialize方法将对象序列化为字符串，用于存储或者传递数据，然后在需要的时候通过unserialize将字符串反序列化成对象进行使用。 class Car { public $name = &apos;car&apos;; } $a = new Car(); $str = serialize($a); //对象序列化成字符串 echo $str.&apos;&lt;br&gt;&apos;; $b = unserialize($str); //反序列化为对象 var_dump($b);]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第十篇——字符串操作]]></title>
    <url>%2F2016%2F05%2F23%2FPHP%E7%AC%AC%E5%8D%81%E7%AF%87%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[关于PHP中字符串操作前面的总结中也有一少部分，但是相对真实开发这还是远远不够的。结合iOS开发中对字符串操作的频率，我们其实大概就可以知道，任何开发中字符串操作是我们平时使用最频繁的！ 字符串操作字符串介绍字符串变量用于包含字符串的值。 定义方式：前面有介绍到1、单引号 $hello = &apos;hello world&apos;; 2、双引号 $hello = &quot;hello world&quot;; 3、heredoc语法结构 $hello = &lt;&lt;&lt;TAG hello world TAG; 单引号和双引号到底有啥区别？PHP允许我们在双引号串中直接包含字串变量。而单引号串中的内容总被认为是普通字符。 $str=&apos;hello&apos;; echo &quot;str is $str&quot;; //运行结果: str is hello echo &apos;str is $str&apos;; //运行结果: str is $str PHP中用英文的点号.来连接两个字符串这里就不多介绍。去除字符串首尾的空格PHP中有三个函数可以去掉字符串的空格 trim去除一个字符串两端空格。rtrim是去除一个字符串右部空格，其中的r是right的缩写。ltrim是去除一个字符串左部空格，其中的l是left的缩写。 echo trim(&quot; 空格 &quot;).&quot;&lt;br&gt;&quot;; echo rtrim(&quot; 空格 &quot;).&quot;&lt;br&gt;&quot;; echo ltrim(&quot; 空格 &quot;).&quot;&lt;br&gt;&quot;; 获取字符串的长度php中有一个神奇的函数，可以直接获取字符串的长度，这个函数就是strlen()。 $str = &apos;hello&apos;; $len = strlen($str); echo $len;//输出结果是5 如果有中文汉字，可以使用mb_strlen()函数获取字符串中中文长度。 $str = &quot;我爱你&quot;; echo mb_strlen($str,&quot;UTF8&quot;);//结果：3，此处的UTF8表示中文编码是UTF8格式，中文一般采用UTF8编码 字符串的截取英文字符串的截取函数substr()函数说明：substr(字符串变量,开始截取的位置，截取个数） $str=&apos;i love you&apos;; //截取love这几个字母 echo substr($str, 2, 4);//为什么开始位置是2呢，因为substr函数计算字符串位置是从0开始的，也就是0的位置是i,1的位置是空格，l的位置是2。从位置2开始取4个字符，就是love。 中文字符串的截取函数mb_substr()函数说明：mb_substr(字符串变量,开始截取的位置，截取个数, 网页编码） $str=&apos;我爱你，中国&apos;; //截取中国两个字 echo mb_substr($str, 4, 2, &apos;utf8&apos;);//为什么开始位置是4呢，和上一个例子一样，因为mb_substr函数计算汉字位置是从0开始的，也就是0的位置是我,1的位置是爱，4的位置是中。从位置4开始取2个汉字，就是中国。中文编码一般是utf8格式 查找字符串如果有一个字符串$str = ‘I want to study at imooc’;，怎么样找到其中的imooc在哪个位置呢？查找字符串，我们需要用到PHP的查找字符串函数strpos(); $str = &apos;I want to study at imooc&apos;; $pos = strpos($str, &apos;imooc&apos;); echo $pos;//结果显示19，表示从位置0开始，imooc在第19个位置开始出现 函数说明：strpos(要处理的字符串, 要定位的字符串, 定位的起始位置[可选]) 字符串替换替换字符串，我们需要用到PHP的替换函数str_replace() $str = &apos;I want to learn js&apos;; $replace = str_replace(&apos;js&apos;, &apos;php&apos;, $str); echo $replace;//结果显示I want to learn php 函数说明：str_replace(要查找的字符串, 要替换的字符串, 被搜索的字符串, 替换进行计数[可选]) 字符串格式化PHP的格式化字符串函数sprintf() $str = &apos;99.9&apos;; $result = sprintf(&apos;%01.2f&apos;, $str); echo $result;//结果显示99.90 函数说明：sprintf(格式, 要转化的字符串)返回：格式化好的字符串 函数注释 1、这个 % 符号是开始的意思，写在最前面表示指定格式开始了。 也就是 &quot;起始字符&quot;, 直到出现 &quot;转换字符&quot; 为止，就算格式终止。 2、跟在 % 符号后面的是 0， 是 &quot;填空字元&quot; ，表示如果位置空着就用0来填满。 3、在 0 后面的是1，这个 1 是规定整个所有的字符串占位要有1位以上(小数点也算一个占位)。 如果把 1 改成 6，则 $result的值将为 099.90 因为，在小数点后面必须是两位，99.90一共5个占位，现在需要6个占位，所以用0来填满。 4、在 %01 后面的 .2 （点2） 就很好理解了，它的意思是，小数点后的数字必须占2位。 如果这时候，$str 的值为9.234,则 $result的值将为9.23. 为什么4 不见了呢？ 因为在小数点后面，按照上面的规定，必须且仅能占2位。 可是 $str 的值中，小数点后面占了3位，所以，尾数4被去掉了，只剩下 23。 5、最后，以 f &quot;转换字符&quot; 结尾。 字符串的合并与分割php字符串合并函数implode()$arr = array(&apos;Hello&apos;, &apos;World!&apos;); $result = implode(&apos;&apos;, $arr); print_r($result);//结果显示Hello World! 函数说明：implode(分隔符[可选], 数组)返回值：把数组元素组合为一个字符串 php字符串分隔函数explode()$str = &apos;apple,banana&apos;; $result = explode(&apos;,&apos;, $str); print_r($result);//结果显示array(&apos;apple&apos;,&apos;banana&apos;) 函数说明：explode(分隔符[可选], 字符串) 返回值：函数返回由字符串组成的数组 字符串的转义php字符串转义函数addslashes() $str = &quot;what&apos;s your name?&quot;; echo addslashes($str);//输出：what\&apos;s your name? 函数说明：用于对特殊字符加上转义字符，返回一个字符串返回值：一个经过转义后的字符串]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第九篇——魔术方法]]></title>
    <url>%2F2016%2F05%2F21%2FPHP%E7%AC%AC%E4%B9%9D%E7%AF%87%E2%80%94%E2%80%94%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[PHP中把以两个下划线__开头的方法称为魔术方法，这些方法在PHP中充当了举足轻重的作用。 魔术方法包括： __construct()，类的构造函数 __destruct()，类的析构函数 __call()，在对象中调用一个不可访问方法时调用 __callStatic()，用静态方式中调用一个不可访问方法时调用 __get()，获得一个类的成员变量时调用 __set()，设置一个类的成员变量时调用 __isset()，当对不可访问属性调用isset()或empty()时调用 __unset()，当对不可访问属性调用unset()时被调用。 __sleep()，执行serialize()时，先会调用这个函数 __wakeup()，执行unserialize()时，先会调用这个函数 __toString()，类被当成字符串时的回应方法 __invoke()，调用函数的方式调用一个对象时的回应方法 __set_state()，调用var_export()导出类时，此静态方法会被调用。 __clone()，当对象复制完成时调用 魔术方法__get($name)–触发时机：当调用一个不访问的成员属性的时候，会自动触发，可以利用这个方法来完成对不可调用的属性进行调用，但是不能设置值 ___set($name,value)–触发时机：当给一个不可访问的成员属性赋值的时候，会自动触发这个方法，可以利用这个方法完成对不可以访问的属性进行赋值 __isset($name)—触发时机：当使用isset()函数来判断一个对象的属性的时候，如果这个属性不存在或者不能被访问的时候会触发这个魔术方法 __call($method,args)—触发时机:当调用一个不存在的成员方法或者是不可访问的成员访问的时候会被触发 __callStatic($method,args)–触发时机：当调用一个不存在的成员方法或者是不可访问的成员访问的时候会被触发 __unset()—触发时机：当要销毁一个不可访问的或者不存在的成员属性的时候会被调用 __sleep()—触发时机：当使用serialize把对象进行序列化的时候会被触发 php public function __sleep() { return array(&apos;xxx&apos;);//指定可以被序列化的属性 } __wakeup()触发时机：当使用unserialize的反序列化的时候会被自动触发 1234public function __wakeup()&#123;&#125; __toString()触发时机：在echo一个对象的时候会被触发 PHP public function __toString() { return &apos;小可爱&apos;; } __clone()对象复制可以通过 clone 关键字来完成（如果可能，这将调用对象的 __clone() 方法]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——Objective-C与Swift优缺点对比]]></title>
    <url>%2F2016%2F05%2F19%2FiOS%E2%80%94%E2%80%94Objective-C%E4%B8%8ESwift%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[最近有个朋友（同事）在找工作，一起讨论关于面试过程中的面试题，有不少关于Objective-C的技术问题，尤其是关于一些技术的底层实现，当然这个在之前的文章中有整理. 其中有一个问题就是关于Objective-C和Swift区别，与优缺点的对比，由于我刚使用Swift实战开发并不久，过去三年多都都是搞Objective-C，所以对Swift和Objective-C优缺点还真没有多少简介，虽然网上也有不少相关的资料和回答，但是想想这个问题以后再很多打算或者还没有开始使用Swift的公司会被经常问到，所以就花了点时间整理一下………. 简介Swift，苹果于2014年WWDC（苹果开发者大会）发布的新开发语言（已开源），可与Objective-C*共同运行于Mac OS和iOS平台，用于搭建基于苹果平台的应用程序。 动态性Swift 是一种强类型语言。类型静态，也就是说 Swift 的默认类型是非常安全的。 Swift 当中存在有这两个修饰符@objc和@dynamic，此外我们同样还可以访问NSObject。 @objc将您的 Swift API 暴露给 Objective-C 运行时，但是它仍然不能保证编译器会尝试对其进行优化。 如果您真的想使用动态功能的话，就需要使用@dynamic。一旦您使用了@dynamic修饰符之后，就不需要添加@objc了，因为它已经隐含在其中。 Swift比Objective-C有什么优势？ Swift容易阅读，语法和文件结构简易化。 Swift更易于维护，文件分离后结构更清晰。 Swift更加安全，它是类型安全的语言。 Swift代码更少，简洁的语法，可以省去大量冗余代码 Swift速度更快，运算性能更高。 Swift目前存在的缺点 版本不稳定，之前升级Swift3大动刀，苦了好多人，swift4目前还未知 使用人数比例偏低，目前还是OC的天下 社区的开源项目偏少，毕竟OC独大好多年，很多优秀的类库都不支持Swift，不过这种状况正在改变，现在有好多优秀的Swift的开源类库了 公司使用的比例不高，很多公司以稳为主，还是在使用OC开发，很少一些在进行混合开发，更少一些是纯Swift开发。 偶尔开发中遇到的一些问题，很难查找到相关资料，这是一个弊端。 纯Swift的运行时和OC有本质区别，一些OC中运行时的强大功能，在纯Swift中变无效了。 对于不支持Swift的一些第三方类库，如果非得使用，只能混合编程，利用桥接文件实现。 整体总结 String： Swift中String操作已经甩OC三百万条街 泛型： Swift泛用性还是不够强，如果项目不止涉及常用的http啊xmpp啊之类的协议，而是要做一些SIP啊FFMPEG啊之类的干活，那明显是OC成熟得多 Discriminated Union swift里的enum. 是静态语言独有的特性. 安全： 由于swift的strong static type system，编译器可帮你检查出更多问题，而不是在运行时突然boom，还有一个很牛逼的安全特性就是OptionalType。 快速： 静态相对来说语言本身速度更快，swift编译期就能生成vtable，确定具体要调用的方法，比起oc的动态派发自然是更快，当然处理到与oc之间桥接部分，可能不一定比oc快 细节使用区别 在 Swift 中没有了 main.m，@UIApplicationMain 是程序入口 swift不分.h和.m文件 ，一个类只有.swift一个文件，所以整体的文件数量比起OC有一定减少。 swift句尾不需要分号 ，除非你想在一行中写三行代码就加分号隔开。 在 Swift 中，一个类就是用一对 { } 括起的，没有 @implementation 和 @end swift数据类型都会自动判断 ， 只区分变量var 和常量let 强制类型转换格式不同 OC强转：(int)a Swift强转：Int(a) 关于BOOL类型更加严格 ，Swift不再是OC的非0就是真，而是true才是真false才是假 swift的 循环语句中必须加{}就算只有一行代码也必须要加 swift的switch语句后面可以跟各种数据类型了 ，如Int、字符串都行，并且里面不用写break（OC好像不能字符串） swift if后的括号可以省略: if a&gt;b {}，而OC里 if后面必须写括号。 swift打印 用print(&quot;&quot;) 打印变量时可以 print(&quot;\(value)&quot;)，不用像OC那样记很多%@，d%等。 Swift3的【Any】可以代表任何类型的值，无论是类、枚举、结构体还是任何其他Swift类型，这个对应OC中的【id】类型。 在 OC 中 alloc / init 对应( ) 在 OC 中 alloc / initWithXXX 对应 (XXX: ) 在 OC 中的类函数调用，在 Swift 中，直接使用 . 在 Swift 中，绝大多数可以省略 self.，建议一般不写，可以提高对语境的理解（闭包时会体会到） 在 OC 中的 枚举类型使用 UIButtonTypeContactAdd，而 Swift 中分开了，操作热键：回车-&gt; 向右 -&gt;. Swift 中，枚举类型的前缀可以省略，如：.ContactAdd，但是：很多时候没有智能提示 监听方法，直接使用字符串引起 循环引用问题Objective-C中循环引用也是遇到比较多的，一不小心就会导致循环引用，甚至导致内存问题 Swift [weak self] self是可选项，如果self已经被释放，则为nil [unowned self] self不是可选项，如果self已经被释放，则出现野指针访问 Objective-C __weak typeof(self) weakSelf; 如果self已经被释放，则为nil __unsafe_unretained typeof(self) weakSelf; 如果self已经被释放，则出现野指针访问 参考：推荐几个Objective-C的框架 FBRetainCycleDetector PLeakSniffer MLeaksFinder]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS——Objective-C与Swift优缺点对比</tag>
        <tag>iOS</tag>
        <tag>Objective-C与Swift优缺点对比</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第八篇——函数篇]]></title>
    <url>%2F2016%2F05%2F19%2FPHP%E7%AC%AC%E5%85%AB%E7%AF%87%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E7%AF%87%2F</url>
    <content type="text"><![CDATA[PHP内置了超过1000个函数，因此函数使得PHP成为一门非常强大的语言。大多数时候我们使用系统的内置函数就可以满足需求，但是自定义函数通过将一组代码封装起来，使代码进行复用，程序结构与逻辑更加清晰。 函数篇函数定义PHP函数的定义方式：（和JS很像） 1.使用关键字“function”开始2.函数名可以是字母或下划线开头：function name()3.在大括号中编写函数体： function name() { echo &apos;Eric&apos;; } 调用直接是函数名+参数 name(); 函数参数PHP的函数可以没有参数，也可以有若干个参数，多个参数称之为参数列表，采用逗号进行分割，参数类似于一个变量，调用时用来传递数据到函数体中。通过传递参数可以使函数实现对参数的运算，得到我们想要的结果。 &lt;?php function sum($a, $b) { echo $a + $b; } //在这里调用函数计算1+2的值 sum(1, 2); 函数返回值使用return关键字可以使函数返回值，可以返回包括数组和对象的任意类型，如果省略了 return，则默认返回值为 NULL。 function add($a) { return $a+1; } $b = add(1); 注意： 返回语句会立即中止函数的运行，并且将控制权交回调用该函数的代码行 函数不能返回多个值，但可以通过返回一个数组来得到类似的效果 可变函数所谓可变函数，即通过变量的值来调用函数，因为变量的值是可变的，所以可以通过改变一个变量的值来实现调用不同的函数。经常会用在回调函数、函数列表，或者根据动态参数来调用不同的函数 变函数的调用方法为变量名加括号。 function name() { echo &apos;jobs&apos;; } $func = &apos;name&apos;; $func(); //调用可变函数 可变函数也可以用在对象的方法调用上。 class book { function getName() { return &apos;bookname&apos;; } } $func = &apos;getName&apos;; $book = new book(); $book-&gt;$func(); 内置函数内置函数指的是PHP默认支持的函数，PHP内置了很多标准的常用的处理函数，包括字符串处理、数组函数、文件处理、session与cookie处理等。 例如：通过内置函数str_replace可以实现字符串的替换 $str = &apos;i am jobs.&apos;; $str = str_replace(&apos;jobs&apos;, &apos;steven jobs&apos;, $str); echo $str; //结果为“i am steven jobs” 另外一些函数是通过其他扩展来支持的，比如mysql数据库处理函数，GD图像处理函数，邮件处理函数等，PHP默认加载了一些常用的扩展库，我们可以安装或者加载其他扩展库来增加PHP的处理函数。 函数检测当我们创建了自定义函数，并且了解了可变函数的用法，为了确保程序调用的函数是存在的，经常会先使用function_exists判断一下函数是否存在。 同样的method_exists可以用来检测类的方法是否存在。 function func() { } if (function_exists(&apos;func&apos;)){ echo &apos;exists&apos;; } 类是否定义可以使用class_exists。 class MyClass{ } // 使用前检查类是否存在 if (class_exists(&apos;MyClass&apos;)) { $myclass = new MyClass(); } PHP中有很多这类的检查方法，例如文件是否存在file_exists等。 $filename = &apos;test.txt&apos;; if (!file_exists($filename)) { echo $filename . &apos; not exists.&apos;; }]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第七篇——数组篇]]></title>
    <url>%2F2016%2F05%2F17%2FPHP%E7%AC%AC%E4%B8%83%E7%AF%87%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E7%AF%87%2F</url>
    <content type="text"><![CDATA[什么是数组？数组就是被命名的用来存储一系列数值的地方。数组array是非常重要的数据类型。相对于其他的数据类型，它更像是一种结构，而这种结果构可以存储一系列数值。数组能够在单一变量名中存储许多值，并且能够通过引用下标号来访问某个值。 在 PHP 中，有三种数组类型： 索引数组 - 带有数字索引的数组 关联数组 - 带有指定键的数组 多维数组 - 包含一个或多个数组的数组 数组篇PHP数组定义数组就是一个键值对组成的语言结构，键类似于酒店的房间号，值类似于酒店房间里存储的东西。 其实在PHP中数组感觉更像iOS中的字典，但也有iOS中的数组相似点，只是数组通过索引，字典是通过键值对。 创建数组（空） $arr = array(); PHP有两种数组：索引数组、关联数组。索引和关联两个词都是针对数组的键而言的。 PHP索引数组–iOS中的数组先介绍下索引数组，索引数组是指数组的键是整数的数组，并且键的整数顺序是从0开始，依次类推。 创建索引数组$arrIndex = array(&quot;iCocos&quot;, &quot;iOS&quot;, &quot;苹果&quot;); 注意数组的键是从0开始的。可以使用print_r($arr);语句输出数组键及对应的值。 赋值方式第一种：用数组变量的名字后面跟一个中括号的方式赋值，当然，索引数组中，中括号内的键一定是整数。比如，$arr[0]=&apos;iCocos&apos;; 第二种：用array()创建一个空数组，使用=&gt;符号来分隔键和值，左侧表示键，右侧表示值。当然，索引数组中，键一定是整数。比如，array(&apos;0&apos;=&gt;&apos;iCocos&apos;); 第三种：用array()创建一个空数组，直接在数组里用英文的单引号&apos;或者英文的双引号&quot;赋值，数组会默认建立从0开始的整数的键。比如array(&apos;iCocos&apos;);这个数组相当于array(&apos;0&apos;=&gt;&apos;iCocos&apos;); 读取内容用数组变量的名字后跟的中括号中的键，来访问数组中的值。 $arr = array(&apos;iCocos&apos;,&apos;iOS&apos;); $arr0 = $arr[&apos;0&apos;]; print_r($arr0);//结果为iCocos 遍历数组（开发中最常用的操作）–&gt;for$arr=array(&apos;iCocos&apos;,&apos;iOS&apos;,&apos;苹果&apos;); for($i=0; $i&lt;3; $i++){ echo &apos;&lt;br&gt;数组第&apos;.$i.&apos;值是：&apos;.$arr[$i]; } 遍历数组（开发中最常用的操作）–&gt;foreach$arr=array(&apos;iCocos&apos;,&apos;iOS&apos;,&apos;苹果&apos;); foreach($arr as $k=&gt;$v){ echo &apos;&lt;br&gt;第&apos;.$k.&apos;值是：&apos;.$v; } PHP关联数组–iOS中的字典关联数组是指数组的键是字符串的数组。 创建关联数组$arr = array( &apos;apple&apos;=&gt;&quot;iCocos&quot;, &apos;banana&apos;=&gt;&quot;iOS&quot;, &apos;pineapple&apos;=&gt;&quot;苹果&quot; ); 赋值方式第一种：用数组变量的名字后面跟一个中括号的方式赋值，当然，关联数组中，中括号内的键一定是字符串。比如，$arr[&apos;apple&apos;]=&apos;iCocos&apos;; 第二种：用array()创建一个空数组，使用=&gt;符号来分隔键和值，左侧表示键，右侧表示值。当然，关联数组中，键一定是字符串。比如，array(&apos;apple&apos;=&gt;&apos;iCocos&apos;); 读取内容用数组变量的名字后跟中括号+键的方式来访问数组中的值，键使用单引号或者双引号括起来。 $arr = array(&apos;apple&apos;=&gt;&quot;iCocos&quot;,&apos;banana&apos;=&gt;&quot;iOS&quot;,&apos;pineapple&apos;=&gt;&quot;苹果&quot;); $arr0 = $arr[&apos;banana&apos;]; print_r($arr0); 遍历数组（开发中最常用的操作）–&gt;foreach$arr=array(&apos;apple&apos;=&gt;&quot;iCocos&quot;,&apos;banana&apos;=&gt;&quot;iOS&quot;,&apos;pineapple&apos;=&gt;&quot;苹果&quot;); foreach($arr as $k=&gt;$v){ echo &apos;&lt;br&gt;水果的英文键名：&apos;.$k.&apos;，对应的值是：&apos;.$v; } 常用函数array_filter(*array*,*callbackfunction*); array_intersect_uassoc(*array1*,*array2*,*array3*...,*myfunction*) array_intersect_ukey(*array1*,*array2*,*array3*...,*myfunction*) array_reduce(*array*,*myfunction*,*initial*) array_walk(*array*,*myfunction*,*userdata*...) …… 其他常用技巧总结多维数组array(array(),array()) 二维数组 数组长度$arr = array(&quot;百度&quot;,&quot;阿里&quot;,&quot;腾讯&quot;); echo count($arr); 增加删除数组的元素在数组元素的尾部增加array_push(array,value1,value2…) 函数向第一个参数的数组尾部添加一个或多个元素（入栈），然后返回新数组的长度。该函数等于多次调用 $array[] = $value。 &lt;?php $arr = array(&quot;百度&quot;,&quot;阿里&quot;,&quot;腾讯&quot;); array_push($arr,&quot;知乎&quot;,&quot;微博&quot;); echo &quot;&lt;pre&gt;&quot;; //换行显示 print_r($arr); 打印结果显示： Array ( [0] =&gt; 百度 [1] =&gt; 阿里 [2] =&gt; 腾讯 [3] =&gt; 知乎 [4] =&gt; 微博 ) 在数组元素的开始增加array_unshift(array,value1,value2,value3…) 函数用于向数组插入新元素。新数组的值将被插入到数组的开头。 &lt;?php $arr = array(&quot;百度&quot;,&quot;阿里&quot;,&quot;腾讯&quot;); array_unshift($arr,&quot;知乎&quot;,&quot;微博&quot;); echo &quot;&lt;pre&gt;&quot;; //换行显示 print_r($arr); 打印结果显示： Array ( [0] =&gt; 知乎 [1] =&gt; 微博 [2] =&gt; 百度 [3] =&gt; 阿里 [4] =&gt; 腾讯 ) 在数组元素的尾部删除array_pop(array) 函数删除数组中的最后一个元素。 &lt;?php $arr = array(&quot;百度&quot;,&quot;阿里&quot;,&quot;腾讯&quot;); array_pop($arr); echo &quot;&lt;pre&gt;&quot;; //换行显示 print_r($arr); 打印结果显示： Array ( [0] =&gt; 百度 [1] =&gt; 阿里 ) 在数组元素的开始删除array_shift(array) 函数删除数组中第一个元素 并可以返回被删除元素的值。 &lt;?php $arr = array(&quot;百度&quot;,&quot;阿里&quot;,&quot;腾讯&quot;); array_shift($arr); echo &quot;&lt;pre&gt;&quot;; //换行显示 print_r($arr); 打印结果显示： Array ( [0] =&gt; 阿里 [1] =&gt; 腾讯 ) 移除数组中重复的值array_unique(array) 函数移除数组中的重复的值，并返回结果数组。 &lt;?php $arr = array(&quot;百度&quot;,&quot;阿里&quot;,&quot;腾讯&quot;,&quot;百度&quot;,&quot;微博&quot;); $data = array_unique($arr); echo &quot;&lt;pre&gt;&quot;; print_r($data); 打印结果显示： Array ( [0] =&gt; 百度 [1] =&gt; 阿里 [2] =&gt; 腾讯 [4] =&gt; 微博 ) 数组合并、拆分、比较array_merge()函数将数组合并到一起，返回一个联合的数组。所得到的数组以第一个输入数组参数开始，按后面数组参数出现的顺序依次追加。 &lt;?php $arr1 = array(&quot;百度&quot;,&quot;阿里&quot;,&quot;腾讯&quot;); $arr2 = array(&quot;知乎&quot;,&quot;微博&quot;); $data = array_merge($arr1,$arr2); echo &quot;&lt;pre&gt;&quot;; print_r($data); 打印结果显示： Array ( [0] =&gt; 百度 [1] =&gt; 阿里 [2] =&gt; 腾讯 [3] =&gt; 知乎 [4] =&gt; 微博 ) 递归追加数组array_merge_recursive()函数与array_merge()相同，可以将两个或多个数组合并到一起，形成一个联合的数组。两者之间的区别在于，当某个输入数组中的某个键已经存在于结果数组中时该函数会采取不同的处理方法。array_merge()会覆盖前面存在的键/值对，将其替换为当前输入数组中的键/值对，而array_merge_recursive()将两个值合并在一起，形成一个新的数组并以原有的键作为数组名。其形式为： $arr= array(&apos;one&apos;=&gt;&apos;C&apos;, &apos;one&apos;=&gt;&apos;B&apos;); $arr1= array(&apos;three&apos;=&gt;&apos;1&apos;, &apos;one&apos;=&gt;&apos;2&apos;); $arr2= array_merge_recursive($arr, $arr1); echo &quot;&lt;pre&gt;&quot;; print_r($arr2); 打印结果显示： Array ( [one] =&gt; Array ( [0] =&gt; B [1] =&gt; 2 ) [three] =&gt; 1 ) 合并两个数组array_combine()函数会生成一个新数组，这个数组由一组提交的键和对应的值组成，其形式为： $arr= array(&apos;A&apos;, &apos;B&apos;); $arr1= array(&apos;1&apos;, &apos;2&apos;); $arr2= array_combine($arr, $arr1); echo &quot;&lt;pre&gt;&quot;; print_r($arr2); 打印结果显示： Array ( [A] =&gt; 1 [B] =&gt; 2 ) 求数组的交集array_intersect()函数返回一个保留了键的数组，这个数组只由第一个数组中出现的且在其他每个输入数组中都出现的值组成。其形式如下： $arr= array(&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;); $arr1= array(&apos;A&apos;, &apos;B&apos;, &apos;E&apos;); $arr2= array(&apos;A&apos;, &apos;F&apos;, &apos;D&apos;); $arr3= array_intersect($arr, $arr1, $arr2); echo &quot;&lt;pre&gt;&quot;; print_r($arr3); 打印结果显示： Array ( [0] =&gt; A ) 注意：只有在两个元素有相同的数据类型时，array_intersect()才会认为它们相等。 求关联数组的交集array_intersect_assoc()与array_intersect()基本相同，只不过它在比较中还考虑了数组的键。因此，只有在第一个数组中出现，且在所有其他输入数组中也出现的键/值对才被返回到结果数组中。其形式如下： $arr= array(&apos;a&apos;=&gt;&apos;A&apos;, &apos;b&apos;=&gt;&apos;B&apos;, &apos;c&apos;=&gt;&apos;C&apos;, &apos;d&apos;=&gt;&apos;D&apos;); $arr1= array(&apos;a&apos;=&gt;&apos;A&apos;, &apos;c&apos;=&gt;&apos;B&apos;, &apos;E&apos;); $arr2= array(&apos;a&apos;=&gt;&apos;A&apos;, &apos;b&apos;=&gt;&apos;F&apos;, &apos;d&apos;=&gt;&apos;B&apos;); $arr3= array_intersect_assoc($arr, $arr1, $arr2); echo &quot;&lt;pre&gt;&quot;; print_r($arr3); 打印结果显示： Array ( [a] =&gt; A ) 求关联数组的差集函数array_diff_assoc()与array_diff()基本相同，只是它在比较时还考虑了数组的键，因此，只在第一个数组中出现而不在其他输入数组中出现的键/值对才会被返回到结果数组中。其形式如下： $arr= array(&apos;a&apos;=&gt;&apos;A&apos;, &apos;b&apos;=&gt;&apos;B&apos;, &apos;c&apos;=&gt;&apos;C&apos;, &apos;d&apos;=&gt;&apos;D&apos;); $arr1= array(&apos;a&apos;=&gt;&apos;A&apos;, &apos;b&apos;=&gt;&apos;B&apos;, &apos;e&apos;=&gt;&apos;E&apos;); $arr3= array_diff_assoc($arr, $arr1); echo &quot;&lt;pre&gt;&quot;; print_r($arr3); 打印结果显示： Array ( [c] =&gt; C [d] =&gt; D ) 其他有用的数组函数返回一组随机的键 array_rand()函数将返回数组中的一个或多个键。其形式为： $arr= array(&apos;a&apos;=&gt;&apos;A&apos;, &apos;b&apos;=&gt;&apos;B&apos;, &apos;c&apos;=&gt;&apos;C&apos;, &apos;d&apos;=&gt;&apos;D&apos;); $arr1= array_rand($arr, 2); echo &quot;&lt;pre&gt;&quot;; print_r($arr1); 打印结果显示： Array ( [0] =&gt; c [1] =&gt; d ) //每次刷新显示的结果都不一样 对数组中的值求和array_sum()函数将数组内的所有值加在一起，返回最终的和，其形式如下： $arr= array(&apos;A&apos;, 32, 12, &apos;B&apos;); $count= array_sum($arr); echo &quot;&lt;pre&gt;&quot;; print_r($count); 打印结果显示： 44 如果数组中包含其他数据类型(例如字符串)，这些值将被忽略。 划分数组array_chunk()函数将数组分解为一个多维数组，这个多维数组由多个包含size个元素的数组所组成。其形式如下： $arr= array(&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;); $arr1= array_chunk($arr, 2); echo &quot;&lt;pre&gt;&quot;; print_r($arr1); 打印结果显示： Array ( [0] =&gt; Array ( [0] =&gt; A [1] =&gt; B ) [1] =&gt; Array ( [0] =&gt; C [1] =&gt; D ) )]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第六篇——PHP底层机制]]></title>
    <url>%2F2016%2F05%2F15%2FPHP%E7%AC%AC%E5%85%AD%E7%AF%87%E2%80%94%E2%80%94PHP%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[最新开始打算学习新的东西，我选择了PHP，这里先说一下为什么是PHP。 1. 因为有人说PHP是世界上最好的语言 2. 因为我经历的几家大部分都是用PHP写的后台 3. 因为大学学习过java，就是因为对java不敢兴趣，所以才选择iOS 。。。。。。。 PHP底层机制先来了解与一下PHP能做什么，为什么需要学习PHP为什么要学习PHP？“我可以用JavaScript来实现程序编写。”但JavaScript的能力是有限的，JavaScript通常运行在浏览器（客户端），它可以制作网页上面的特效：鼠标滑过背景改变颜色，还有网页上常见的鼠标滑过弹出菜单。但如果要让JavaScript实现显示“访问网站的总人数”，它就无能为力了，因为它只能获得客户端的信息，而“访问网站的总人数”是存储在服务器端的。所以就需要另外一种可以在服务器端运行的编程语言，PHP语言就是其中的一种，因为它可以运行在Web服务器端。 在学习PHP之前让我们来认识一下PHP及其功能。1、运行在服务器端：学会了PHP，就可以指挥服务器给你干活，甚至是搞破坏^_^（千万不能真这么做咯），WEB网站的大部分数据都是存储在服务器端的，PHP就是用来处理这些存储在服务器的数据的（功能强大吧）。 2、跨平台：服务器可以是多种平台的服务器，比如Linux、Windows、Unix，你都可以指挥（不用怕只能指挥一种服务器啦吧）。 3、脚本语言：它是通过编写脚本，也就是一行行的计算机指令（也可以理解为特定的英文单词），来指挥服务器来工作的，因此，在编写PHP的过程其实就是与老外（服务器成老外啦）交流的过程，交流的语言就是PHP。 4、免费：免费使用（天下还真有免费的午餐）。 PHP的底层实现+运行机制PHP说简单，但是要精通也不是一件简单的事。我们除了会使用之外，还得知道它底层的工作原理。 因为有了学习iOS的时候喜欢挖底层的习惯，所以在真正学习PHP之前，我想先从PHP的底层开始研究。其实学习任何一门语言都必须学习并熟悉他的底层原理或者运行机制，不然永远是个初级或者基础的程序员。 + PHP是一种适用于web开发的动态语言。具体点说，就是一个用C语言实现包含大量组件的软件框架。更狭义点看，可以把它认为是一个强大的UI框架。 了解PHP底层实现的目的是什么？动态语言要像用好首先得了解它，内存管理、框架模型值得我们借鉴，通过扩展开发实现更多更强大的功能，优化我们程序的性能。 1. PHP的设计理念及特点多进程模型：由于PHP是多进程模型，不同请求间互不干涉，这样保证了一个请求挂掉不会对全盘服务造成影响，当然，随着时代发展，PHP也早已支持多线程模型。 弱类型语言：和C/C++、Java、C#等语言不同，PHP是一门弱类型语言。一个变量的类型并不是一开始就确定不变，运行中才会确定并可能发生隐式或显式的类型转换，这种机制的灵活性在web开发中非常方便、高效，具体会在后面PHP变量中详述。 引擎(Zend)+组件(ext)的模式降低内部耦合。 中间层(sapi)隔绝web server和PHP。 语法简单灵活，没有太多规范。缺点导致风格混杂，但再差的程序员也不会写出太离谱危害全局的程序。 2. PHP的四层体系PHP从下到上是一个4层体系： 2.1 Zend引擎：Zend整体用纯C实现，是PHP的内核部分，它将PHP代码翻译（词法、语法解析等一系列编译过程）为可执行opcode的处理并实现相应的处理方法、实现了基本的数据结构（如hashtable、oo）、内存分配及管理、提供了相应的api方法供外部调用，是一切的核心，所有的外围功能均围绕Zend实现。 2.2 Extensions：围绕着Zend引擎，extensions通过组件式的方式提供各种基础服务，我们常见的各种内置函数（如array系列）、标准库等都是通过extension来实现，用户也可以根据需要实现自己的extension以达到功能扩展、性能优化等目的（如贴吧正在使用的PHP中间层、富文本解析就是extension的典型应用）。 2.3 Sapi：Sapi全称是Server Application Programming Interface，也就是服务端应用编程接口，Sapi通过一系列钩子函数，使得PHP可以和外围交互数据，这是PHP非常优雅和成功的一个设计，通过sapi成功的将PHP本身和上层应用解耦隔离，PHP可以不再考虑如何针对不同应用进行兼容，而应用本身也可以针对自己的特点实现不同的处理方式。 2.4上层应用：这就是我们平时编写的PHP程序，通过不同的sapi方式得到各种各样的应用模式，如通过webserver实现web应用、在命令行下以脚本方式运行等等。 如果PHP是一辆车，那么车的框架就是PHP本身，Zend是车的引擎（发动机），Ext下面的各种组件就是车的轮子，Sapi可以看做是公路，车可以跑在不同类型的公路上，而一次PHP程序的执行就是汽车跑在公路上。因此，我们需要：性能优异的引擎+合适的车轮+正确的跑道。 3. Sapi如前所述，Sapi通过通过一系列的接口，使得外部应用可以和PHP交换数据并可以根据不同应用特点实现特定的处理方法，我们常见的一些sapi有： apache2handler：这是以apache作为webserver，采用mod_PHP模式运行时候的处理方式，也是现在应用最广泛的一种。 cgi：这是webserver和PHP直接的另一种交互方式，也就是大名鼎鼎的fastcgi协议，在最近今年fastcgi+PHP得到越来越多的应用，也是异步webserver所唯一支持的方式。 cli：命令行调用的应用模式 4. PHP的执行流程&amp;opcode我们先来看看PHP代码的执行所经过的流程。 PHP实现了一个典型的动态语言执行过程：拿到一段代码后，经过词法解析、语法解析等阶段后，源程序会被翻译成一个个指令(opcodes)，然后ZEND虚拟机顺次执行这些指令完成操作。PHP本身是用C实现的，因此最终调用的也都是C的函数，实际上，我们可以把PHP看做是一个C开发的软件。 4.1 PHP的执行的核心是翻译出来的一条一条指令，也即opcode。Opcode是PHP程序执行的最基本单位。一个opcode由两个参数(op1,op2)、返回值和处理函数组成。PHP程序最终被翻译为一组opcode处理函数的顺序执行。 4.2 常见的几个处理函数：ZEND_ASSIGN_SPEC_CV_CV_HANDLER : 变量分配 （$a=$b） ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER：函数调用 ZEND_CONCAT_SPEC_CV_CV_HANDLER：字符串拼接 $a.$b ZEND_ADD_SPEC_CV_CONST_HANDLER: 加法运算 $a+2 ZEND_IS_EQUAL_SPEC_CV_CONST：判断相等 $a==1 ZEND_IS_IDENTICAL_SPEC_CV_CONST：判断相等 $a===1 5. HashTable — 核心数据结构HashTable是zend的核心数据结构，在PHP里面几乎并用来实现所有常见功能，我们知道的PHP数组即是其典型应用，此外，在zend内部，如函数符号表、全局变量等也都是基于hash table来实现。 PHP的hash table具有如下特点： 支持典型的key-&gt;value查询 可以当做数组使用 添加、删除节点是O（1）复杂度 key支持混合类型：同时存在关联数组合索引数组 Value支持混合类型：array (“string”,2332) 支持线性遍历：如foreach Zend hash table实现了典型的hash表散列结构，同时通过附加一个双向链表，提供了正向、反向遍历数组的功能。 在hash table中既有key-&gt;value形式的散列结构，也有双向链表模式，使得它能够非常方便的支持快速查找和线性遍历。 5.1 散列结构：Zend的散列结构是典型的hash表模型，通过链表的方式来解决冲突。需要注意的是zend的hash table是一个自增长的数据结构，当hash表数目满了之后，其本身会动态以2倍的方式扩容并重新元素位置。初始大小均为8。另外，在进行key-&gt;value快速查找时候，zend本身还做了一些优化，通过空间换时间的方式加快速度。比如在每个元素中都会用一个变量nKeyLength标识key的长度以作快速判定。 5.2 双向链表：Zend hash table通过一个链表结构，实现了元素的线性遍历。理论上，做遍历使用单向链表就够了，之所以使用双向链表，主要目的是为了快速删除，避免遍历。Zend hash table是一种复合型的结构，作为数组使用时，即支持常见的关联数组也能够作为顺序索引数字来使用，甚至允许2者的混合。 5.3 PHP关联数组：关联数组是典型的hash_table应用。一次查询过程经过如下几步（从代码可以看出，这是一个常见的hash查询过程并增加一些快速判定加速查找。）： 来看看源码 getKeyHashValue h; index = n &amp; nTableMask; Bucket *p = arBucket[index]; while (p) { if ((p-&gt;h == h) &amp; (p-&gt;nKeyLength == nKeyLength)) { RETURN p-&gt;data; } p=p-&gt;next; } RETURN FALTURE; 5.4 PHP索引数组：索引数组就是我们常见的数组，通过下标访问。例如 $arr[0]，Zend HashTable内部进行了归一化处理，对于index类型key同样分配了hash值和nKeyLength(为0)。内部成员变量nNextFreeElement就是当前分配到的最大id，每次push后自动加一。正是这种归一化处理，PHP才能够实现关联和非关联的混合。由于push操作的特殊性，索引key在PHP数组中先后顺序并不是通过下标大小来决定，而是由push的先后决定。例如 $arr[1] = 2; $arr[2] = 3;对于double类型的key，Zend HashTable会将他当做索引key处理 6 PHP变量PHP是一门弱类型语言，本身不严格区分变量的类型。PHP在变量申明的时候不需要指定类型。PHP在程序运行期间可能进行变量类型的隐示转换。和其他强类型语言一样，程序中也可以进行显示的类型转换。PHP变量可以分为简单类型(int、string、bool)、集合类型(array resource object)和常量(const)。以上所有的变量在底层都是同一种结构 zval。 Zval是zend中另一个非常重要的数据结构，用来标识并实现PHP变量. Zval主要由三部分组成：type：指定了变量所述的类型（整数、字符串、数组等） refcount&amp;is_ref：用来实现引用计数(后面具体介绍) value：核心部分，存储了变量的实际数据 Zvalue是用来保存一个变量的实际数据。因为要存储多种类型，所以zvalue是一个union，也由此实现了弱类型。 PHP变量类型和其实际存储对应关系如下： IS_LONG -&gt; lvalue IS_DOUBLE -&gt; dvalue IS_ARRAY -&gt; ht IS_STRING -&gt; str IS_RESOURCE -&gt; lvalue 引用计数在内存回收、字符串操作等地方使用非常广泛。PHP中的变量就是引用计数的典型应用。Zval的引用计数通过成员变量is_ref和ref_count实现，通过引用计数，多个变量可以共享同一份数据。避免频繁拷贝带来的大量消耗。 在进行赋值操作时，zend将变量指向相同的zval同时ref_count++，在unset操作时，对应的ref_count-1。只有ref_count减为0时才会真正执行销毁操作。如果是引用赋值，则zend会修改is_ref为1。 PHP变量通过引用计数实现变量共享数据，那如果改变其中一个变量值呢？当试图写入一个变量时，Zend若发现该变量指向的zval被多个变量共享，则为其复制一份ref_count为1的zval，并递减原zval的refcount，这个过程称为“zval分离”。可见，只有在有写操作发生时zend才进行拷贝操作，因此也叫copy-on-write(写时拷贝) + 对于引用型变量，其要求和非引用型相反，引用赋值的变量间必须是捆绑的，修改一个变量就修改了所有捆绑变量。 + 整数、浮点数是PHP中的基础类型之一，也是一个简单型变量。对于整数和浮点数，在zvalue中直接存储对应的值。其类型分别是long和double。 - 从zvalue结构中可以看出，对于整数类型，和c等强类型语言不同，PHP是不区分int、unsigned int、long、long long等类型的，对它来说，整数只有一种类型也就是long。由此，可以看出，在PHP里面，整数的取值范围是由编译器位数来决定而不是固定不变的。 + 对于浮点数，类似整数，它也不区分float和double而是统一只有double一种类型。 - 在PHP中，如果整数范围越界了怎么办？这种情况下会自动转换为double类型，这个一定要小心，很多trick都是由此产生。 + 和整数一样，字符变量也是PHP中的基础类型和简单型变量。通过zvalue结构可以看出，在PHP中，字符串是由由指向实际数据的指针和长度结构体组成，这点和c++中的string比较类似。由于通过一个实际变量表示长度，和c不同，它的字符串可以是2进制数据（包含），同时在PHP中，求字符串长度strlen是O(1)操作。 在新增、修改、追加字符串操作时，PHP都会重新分配内存生成新的字符串。最后，出于安全考虑，PHP在生成一个字符串时末尾仍然会添加 常见的字符串拼接方式及速度比较： 假设有如下4个变量：$strA=‘123’; $strB = ‘456’; $intA=123; intB=456; 现在对如下的几种字符串拼接方式做一个比较和说明： $res = $strA.$strB和$res = “$strA$strB”这种情况下，zend会重新malloc一块内存并进行相应处理，其速度一般$strA = $strA.$strB这种是速度最快的，zend会在当前strA基础上直接relloc，避免重复拷贝$res = $intA.$intB这种速度较慢，因为需要做隐式的格式转换，实际编写程序中也应该注意尽量避免$strA = sprintf (“%s%s”,$strA.$strB);这会是最慢的一种方式，因为sprintf在PHP中并不是一个语言结构，本身对于格式识别和处理就需要耗费比较多时间，另外本身机制也是malloc。不过sprintf的方式最具可读性，实际中可以根据具体情况灵活选择。 PHP的数组通过Zend HashTable来天然实现。foreach操作如何实现？对一个数组的foreach就是通过遍历hashtable中的双向链表完成。对于索引数组，通过foreach遍历效率比for高很多，省去了key-&gt;value的查找。count操作直接调用HashTable-&gt;NumOfElements，O(1)操作。对于’123’这样的字符串，zend会转换为其整数形式。$arr[‘123’]和$arr[123]是等价的 资源类型变量是PHP中最复杂的一种变量，也是一种复合型结构。PHP的zval可以表示广泛的数据类型，但是对于自定义的数据类型却很难充分描述。由于没有有效的方式描绘这些复合结构，因此也没有办法对它们使用传统的操作符。要解决这个问题，只需要通过一个本质上任意的标识符（label）引用指针，这种方式被称为资源。 在zval中，对于resource，lval作为指针来使用，直接指向资源所在的地址。Resource可以是任意的复合结构，我们熟悉的mysqli、fsock、memcached等都是资源。 如何使用资源：注册：对于一个自定义的数据类型，要想将它作为资源。首先需要进行注册，zend会为它分配全局唯一标示。获取一个资源变量：对于资源，zend维护了一个id-&gt;实际数据的hash_tale。对于一个resource，在zval中只记录了它的id。fetch的时候通过id在hash_table中找到具体的值返回。资源销毁：资源的数据类型是多种多样的。Zend本身没有办法销毁它。因此需要用户在注册资源的时候提供销毁函数。当unset资源时，zend调用相应的函数完成析构。同时从全局资源表中删除它。 资源可以长期驻留，不只是在所有引用它的变量超出作用域之后，甚至是在一个请求结束了并且新的请求产生之后。这些资源称为持久资源，因为它们贯通SAPI的整个生命周期持续存在，除非特意销毁。很多情况下，持久化资源可以在一定程度上提高性能。比如我们常见的mysql_pconnect ,持久化资源通过pemalloc分配内存，这样在请求结束的时候不会释放。对zend来说，对两者本身并不区分。 PHP中的局部变量和全局变量是如何实现的？对于一个请求，任意时刻PHP都可以看到两个符号表(symbol_table和active_symbol_table)，其中前者用来维护全局变量。后者是一个指针，指向当前活动的变量符号表，当程序进入到某个函数中时，zend就会为它分配一个符号表x同时将active_symbol_table指向a。通过这样的方式实现全局、局部变量的区分。 获取变量值：PHP的符号表是通过hash_table实现的，对于每个变量都分配唯一标识，获取的时候根据标识从表中找到相应zval返回。 函数中使用全局变量：在函数中，我们可以通过显式申明global来使用全局变量。在active_symbol_table中创建symbol_table中同名变量的引用，如果symbol_table中没有同名变量则会先创建。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第五篇——学习笔记整理]]></title>
    <url>%2F2016%2F05%2F10%2FPHP%E7%AC%AC%E4%BA%94%E7%AF%87%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[学习笔记，日志记录…… GET &amp;&amp; POST GET POST 不关心请求数据的来源，用超全局变量 $_REQUEST 内置函数strpos 在一个字符串中搜索另外一个字符串,返回相对于开头的位置或者FALSE。 strtoupper — 将字符串转化为大写strlen — 获取字符串长度 旧的 $HTTP_*_VARS 数组从 PHP 5.4.0 开始将不再有效。 PHP » 4.1.0 版本引入了如下超全局数组变量： $_GET、$_POST、$_COOKIE、 $_SERVER、$_FILES、$_ENV、 $_REQUEST 以及 $_SESSION。 外部变量不再被默认注册为全局变量。也就是说，从 PHP » 4.2.0 版开始，php.ini 中的设置选项 register_globals 默认值变成了 off。 建议用以上提到的超全局数组变量来访问这些值。但可能老的脚本、书籍以及教程都可能建立在该设置为 on 的基础上。如果该选项被设置为 on，则可以在 URL http://www.example.com/foo.php?id=42 中直接使用变量 $id。但不管被设置为 on 还是 off，$_GET[‘id’] 一直有效。 HTML混合12345678910111213&lt;?php if (strpos($_SERVER['HPPT_USER_AGENT'], 'MSIE') !== false) &#123;?&gt;&lt;h3&gt;strpos() 肯定没有返回假 (FALSE)&lt;/h3&gt;&lt;p&gt;正在使用 Internet Explorer&lt;/p&gt;&lt;?php &#125; else &#123;?&gt;&lt;h3&gt;strpos() 肯定返回假 (FALSE)&lt;/h3&gt;&lt;center&gt;&lt;b&gt;没有使用 Internet Explorer&lt;/b&gt;&lt;/center&gt;&lt;?php &#125;?&gt; 表单123456789101112131415161718html&lt;form action="index.php" method="post"&gt;&lt;p&gt;姓名: &lt;input type="text" name="name" /&gt;&lt;/p&gt;&lt;p&gt;年龄: &lt;input type="text" name="age" /&gt;&lt;/p&gt;&lt;p&gt;&lt;input type="submit" /&gt;&lt;/p&gt;&lt;/form&gt;php你好, &lt;?php // htmlspecialchars() 使得 HTML 之中的特殊字符被正确的编码，从而不会被使用者在页面注入 HTML 标签或者 Javascript 代码echo htmlspecialchars($_POST['name']);?&gt;。你&lt;?php echo (int)$_POST['age'];?&gt; 岁了。 数组12345678910$arr1 = [1,'b' =&gt;2,3];$arr2 = array('a' =&gt; 10);var_dump($arr1);$arr3 = ['a' =&gt; 1, 'b' =&gt; 2, 'c' =&gt; 3];$arr3['d'] = 4; // 增$arr3['b'] = 22; // 改unset($arr3['c']); // 删echo $arr3['d']; // 查var_dump($arr3);]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——App启动优化分析与总结]]></title>
    <url>%2F2016%2F05%2F03%2FiOS%E2%80%94%E2%80%94App%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[随着人们对App性能与实用要求越来越高，也随着大量iOS开发中的涌入，现如今已经不再是几年前会做简单App，然后开始开发，能写出一个可用功能的产品就可以了，于是，很多公司和开发者也开始关注和实战启动优化，因为App除了桌面Log，启动是也是夺得用户喜好最首要的条件，如果一个App每次启动都要几十秒甚至几分钟，你觉得你还会继续使用吗…… 如果你对iOS开发中App的整个启动过程干兴趣，那么可以先看我之前分享的一个主题iOS——App整个启动过程分析 当然关于启动优化，上面只是简单的提了一下，本文结合那篇文章进行详细分析 启动优化准备APP启动时间： t(App总启动时间) = t1(main()之前的加载时间) + t2(main()之后的加载时间)。 t1 = 系统dylib(动态链接库)和自身App可执行文件的加载； t2 = main方法执行之后到AppDelegate类中的didFinishLaunchingWithOptions方法执行结束前这段时间，主要是构建第一个界面，并完成渲染展示。 前面我们分析了，Main之前和之后的加载过程这里我们先简单介绍一下，之前没有详细说明的一些其中关联的技术： App开始启动后，系统首先加载可执行文件（自身App的所有.o文件的集合），然后加载动态链接库dyld，dyld是一个专门用来加载动态链接库的库。执行从dyld开始，dyld从可执行文件的依赖开始, 递归加载所有的依赖动态链接库。 其实无论对于系统的动态链接库还是对于App本身的可执行文件而言，他们都算是image（镜像），而每个App都是以image(镜像)为单位进行加载的 什么是image 1.executable可执行文件 比如.o文件。 2.dylib 动态链接库 framework就是动态链接库和相应资源包含在一起的一个文件夹结构。 3.bundle 资源文件 只能用dlopen加载，不推荐使用这种方式加载。 注意：除了我们App本身的可行性文件，系统中所有的framework比如UIKit、Foundation等都是以动态链接库的方式集成进App中的。 不同进程之间共用系统dylib的_TEXT区，但是各自维护对应的_DATA区。 所有动态链接库和我们App中的静态库.a和所有类文件编译后的.o文件最终都是由dyld(the dynamic link editor)，Apple的动态链接器来加载到内存中。每个image都是由一个叫做ImageLoader的类来负责加载（一一对应） 是ImageLoader image 表示一个二进制文件(可执行文件或 so 文件)，里面是被编译过的符号、代码等， ImageLoader 作用是将这些文件加载进内存，且每一个文件对应一个ImageLoader实例来负责加载。 ImageLoader加载步骤分两步走： 在程序运行时它先将动态链接的 image 递归加载 (也就是上面测试栈中一串的递归调用的时刻)。 再从可执行文件 image 递归加载所有符号。 真正的启动优化：Main之前：检测方式：Apple提供了一种测量方法，在 Xcode 中 Edit scheme -&gt; Run -&gt; Auguments 将环境变量DYLD_PRINT_STATISTICS 设为1 pre-main阶段 1.1. 加载应用的可执行文件 1.2. 加载动态链接库加载器dyld（dynamic loader） 1.3. dyld递归加载应用所有依赖的dylib（dynamic library 动态链接库） 动态链接库的加载步骤具体分为5步： load dylibs image 读取库镜像文件 Rebase image Bind image Objc setup initializers load dylibs image在每个动态库的加载过程中， dyld需要： 分析所依赖的动态库 找到动态库的mach-o文件 打开文件 验证文件 在系统核心注册文件签名 对动态库的每一个segment调用mmap() 通常的，一个App需要加载100到400个dylibs， 但是其中的系统库被优化，可以很快的加载。 ######&gt; 针对这一步骤的优化有： 减少非系统库的依赖 尽量不使用内嵌（embedded）的dylib，加载内嵌dylib性能开销较大 合并已有的dylib和使用静态库（static archives），减少dylib的使用个数 使用静态资源，比如把代码加入主程序 懒加载dylib，但是要注意dlopen()可能造成一些问题，且实际上懒加载做的工作会更多 rebase/bind由于ASLR(address space layout randomization)的存在，可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不固定，所以需要这2步来修复镜像中的资源指针，来指向正确的地址。 rebase修复的是指向当前镜像内部的资源指针； 而bind指向的是镜像外部的资源指针。rebase步骤先进行，需要把镜像读入内存，并以page为单位进行加密验证，保证不会被篡改，所以这一步的瓶颈在IO。bind在其后进行，由于要查询符号表，来指向跨镜像的资源，加上在rebase阶段，镜像已被读入和加密验证，所以这一步的瓶颈在于CPU计算。 通过命令行可以查看相关的资源指针: xcrun dyldinfo -rebase -bind -lazy_bind myApp.App/myApp 优化该阶段的关键在于减少__DATA segment中的指针数量。 ######&gt; 我们可以优化的点有： 减少ObjC类（class）、方法（selector）、分类（category）的数量 减少C++虚函数数量（创建虚函数表有开销） 转而使用swift stuct（其实本质上就是为了减少符号的数量） Objc setup这一步主要工作是: 注册Objc类 (class registration) 把category的定义插入方法列表 (category registration) 保证每一个selector唯一 (selctor uniquing) 由于之前2步骤的优化，这一步实际上没有什么可做的。 initializers以上三步属于静态调整(fix-up)，都是在修改__DATA segment中的内容，而这里则开始动态调整，开始在堆和堆栈中写入内容。 在这里的工作有： Objc的+load()函数 C++的构造函数属性函数 形如attribute((constructor)) void DoSomeInitializationWork() 非基本类型的C++静态全局变量的创建(通常是类或结构体)(non-trivial initializer) 比如一个全局静态结构体的构建，如果在构造函数中有繁重的工作，那么会拖慢启动速度 Objc的load函数和C++的静态构造函数采用由底向上的方式执行，来保证每个执行的方法，都可以找到所依赖的动态库。 +load方法断点的调用堆栈和顺序： dyld 开始将程序二进制文件初始化 交由 ImageLoader 读取 image，其中包含了我们的类、方法等各种符号 由于 runtime 向 dyld 绑定了回调，当 image 加载到内存后，dyld 会通知 runtime 进行处理 runtime 接手后调用 mapimages 做解析和处理，接下来 loadimages 中调用 callloadmethods 方法，遍历所有加载进来的 Class，按继承层级依次调用 Class 的 +load 方法和其 Category 的 +load 方法 ######&gt; 我们可以做的优化有： 少在类的+load方法里做事情，尽量把这些事情推迟到+initiailize 减少构造器函数个数，在构造器函数里少做些事情 减少C++静态全局变量的个数 至此，可执行文件中和动态库所有的符号(Class，Protocol，Selector，IMP，…)都已经按格式成功加载到内存中，被 runtime 所管理，再这之后，runtime 的那些方法(动态添加 Class、swizzle 等等才能生效)。 到这里整个过程： 整个事件由 dyld 主导，完成运行环境的初始化后，配合 ImageLoader 将二进制文件按格式加载到内存， 动态链接依赖库，并由 runtime 负责加载成 objc 定义的结构，所有初始化工作结束后，dyld 调用真正的 main 函数。 总结优化点： 减少不必要的framework，因为动态链接比较耗时 check framework应当设为optional和required，如果该framework在当前App支持的所有iOS系统版本都存在，那么就设为required，否则就设为optional，因为optional会有些额外的检查 合并或者删减一些OC类，关于清理项目中没用到的类，使用工具AppCode代码检查功能，查到当前项目中没有用到的类如下： 删减一些无用的静态变量 删减没有被调用到或者已经废弃的方法 将不必须在+load方法中做的事情延迟到+initialize中 尽量不要用C++虚函数(创建虚函数表有开销) Main之后：检测方式：测量main()函数开始执行到didFinishLaunchingWithOptions执行结束的耗时，自己插入代码到工程。 main()阶段 2.1. dyld调用main() 2.2. 调用UIApplicationMain() 2.3. 调用applicationWillFinishLaunching 2.4. 调用didFinishLaunchingWithOptions 在main()被调用之后，App的主要工作就是初始化必要的服务，显示首页内容等。而我们的优化也是围绕如何能够快速展现首页来开展。App通常在AppDelegate类中的didFinishLaunchingWithOptions方法中创建首页需要展示的view，然后在当前runloop的末尾，主动调用CA::Transaction::commit完成视图的渲染。 而视图的渲染主要涉及三个阶段： 准备阶段 这里主要是图片的解码 布局阶段 首页所有UIView的- (void)layoutSubViews()运行 绘制阶段 首页所有UIView的- (void)drawRect:(CGRect)rect运行 再加上启动之后必要服务的启动、必要数据的创建和读取，这些就是我们可以尝试优化的地方 因此，对于main()函数调用之前我们可以优化的点有： 不使用xib，直接视用代码加载首页视图 NSUserDefaults实际上是在Library文件夹下会生产一个plist文件，如果文件太大的话一次能读取到内存中可能很耗时，这个影响需要评估，如果耗时很大的话需要拆分(需考虑老版本覆盖安装兼容问题) 每次用NSLog方式打印会隐式的创建一个Calendar，因此需要删减启动时各业务方打的log，或者仅仅针对内测版输出log 梳理应用启动时发送的所有网络请求，是否可以统一在异步线程请求 梳理各个二方/三方库，找到可以延迟加载的库，做延迟加载处理，比如放到首页控制器的viewDidAppear方法里。 梳理业务逻辑，把可以延迟执行的逻辑，做延迟执行处理。比如检查新版本、注册推送通知等逻辑。 避免复杂/多余的计算。 避免在首页控制器的viewDidLoad和viewWillAppear做太多事情，这2个方法执行完，首页控制器才能显示，部分可以延迟创建的视图应做延迟创建/懒加载处理。 采用性能更好的API。 首页控制器用纯代码方式来构建。 总结：具体优化点 纯代码方式而不是storyboard加载首页UI。 对didFinishLaunching里的函数考虑能否挖掘可以延迟加载或者懒加载，需要与各个业务方pm和rd共同check 对于一些已经下线的业务，删减冗余代码。 对于一些与UI展示无关的业务，如微博认证过期检查、图片最大缓存空间设置等做延迟加载 对实现了+load()方法的类进行分析，尽量将load里的代码延后调用。 上面统计数据显示展示feed的导航控制器页面(NewsListViewController)比较耗时，对于viewDidLoad以及viewWillAppear方法中尽量去尝试少做，晚做，不做 到这里之后其实已经差不多了，相信你应该有哪么写成就与收获。 除了这些，我们还可以喂项目做一些缓存优化 ccache 等缓存方案 优化 Xcode 配置 加钱堆硬件 以上优化方案出发点都是基础优化编译耗时来解决的。 哪有没有一个办法可以做到不编译就执行修改后的代码呢？ 答案肯定是：有的 基于 Objective-C 的动态特性，是完全可以做到这一点的，这也是各种热修复框架的支撑原理之一。那么如果需要做到不编译就执行修改后的代码，我们可以这样做： 获取本地修改后代码 -&gt; 转 JavaScript 或 Lua -&gt; 模拟器执行修改后的脚本。 获取本地修改代码 这里也有许多方法，可以手动复制，也可以自动获取。这里我是选择利用 Xcode Editor Extension 来获取到你选中的修改代码的。 Objective-C 转 JavaScript 由于整个流程我是基于 JSPatch 来开发的，所以是需要转为 JS 的脚本。这里我是写了个 node.js 的脚本来实现，转换算法是利用 https://github.com/bang590/JSPatchConvertor 中的开源代码。 模拟器执行修改后的脚本 由于已经有 JSPatch 完整的框架做支撑，这里只需要利用其中的方法 -[JPEngine evaluateScriptWithPath:] 去执行修改后的脚本即可。 当然这种有一定的缺陷，不管是针对苹果审核，还是学习成本，或者是其他意向不到的问题 使用之前还是慎重考虑，可以适当的使用作为部分模块的优化，或者作为学习。 至于后续的步骤就是，写好代码，逻辑，界面，优化…… 性能优化推荐：iOS应用性能调优的25个建议和技巧]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS——App启动优化分析与总结</tag>
        <tag>App启动优化分析与总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第四篇——入门基础总结]]></title>
    <url>%2F2016%2F05%2F01%2FPHP%E7%AC%AC%E5%9B%9B%E7%AF%87%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[接触PHP已经有一周了，说没有收获也有一点收获，说有收获却不知道收获了什么，可能只是对语法的了解吧，因为工作的原因，项目进度的原因，只能每天晚上熬夜回来学习，或者公司偶尔休息一下的时候，看两篇文章，这样进度确实蛮，不过我一定会每天抽一定的时间来学好它，就跟当初学习iOS一样。 这一周，主要是在学习和总结之前了解过的东西，比如PHP语法，常见的一些区别或者注意点，所以整理了一下，既能了解自己的学习进度，又方便以后回过头来查阅，毕竟自己的东西比网上找100片文章都有用。 并没有对这一周所有学习的东西整理，只是一小部分，或者突然想到了就记录下来的，有错误或者可以优化的地方欢迎指出，我们一起讨论，本人一直做iOS开发，对学习东西有一定的要求，PHP目前还是小白，希望不要喷我😂😉 PHP入门基础总结“”&amp;’’一般情况下两者是通用的.但双引号内部变量会解析,单引号则不解析. 所以如果内部只有纯字符串的时候,用单引号(速度快),内部有别的东西(如变量)的时候,用双号引更好点. 可以这么理解 当双引号中包含变量时，变量会与双引号中的内容连接在一起； 当单引号中包含变量时，变量会被当做字符串输出。 echo&amp;printecho可以输出多个字符串 print只能输出一个字符串，它可以表现得像一个函数 echo的效率相对比较快！ 总结： echo 命令和print命令相同，没有区别 echo 函数和print函数有区别。 echo() 无返回值，与echo命令相同 print() 有返回值，成功，返1，false,返0. printf() 和sprintf()类似，均为格式化输出，不同的是前者输出到标准输出，后者输出到变量 var_dump()&amp;print_r()var_dump():此函数显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。 print_r():显示关于一个变量的易于理解的信息。如果给出的是 string、integer 或 float，将打印变量值本身。如果给出的是 array，将会按照一定格式显示键和元素。object 与数组类似。 记住，print_r() 将把数组的指针移到最后边。 print_r和var_dump都能输出数组和对象，但print_r对布尔型的输出不太明显；var_dump输出比较详细，一般调试时用得多。 注意：PHP区分大小写，但是是一种弱类型的语言 获取消耗内存：memory_get_usage() 数据类型1.标量数据类型:BOOL型,整型，浮点型，字符串型。 注意1：BOOL值非零就是真，PHP中返回1，如果是假的话什么也不输出。 注意2：字符串中字符和字节一样。字符串型可以用三种方法定义：单引号形式、双引号形式和Heredoc结构形式:&lt;&lt;&lt;iCocos 长字符串 iCocos; 2.复合变量：array（数组）和 object（对象） 数组是一组数据的集合，他把一系列数据组成起来，形成一个可以操作的整体。数组中可以包括很多数据，例如：标量数据、数组，对象、资源以及 PHP支持的其他数据类型。 元素：数组成每一个数据成为元素；索引：每一个元素对应的唯一编码。索引只能由数字或字符串组成。 在编程语言中用到的方法有：面向对象 和 面向过程。在PHP中，用户可以自由使用这两种方法。在PHP中可以自由使用这两种方式。 3.特殊数据类型：resource（资源）和 null（空值） 资源是由专门的函数来建立和使用的，它是一种特殊的数据类型，并由程序员分配。在使用资源时，要及时的释放不需要的资源，如果忘记释放资源，系统自动启动垃圾回收机制，避免内存消耗殆尽。 控制顾名思义，表示没有为该变量设置任何值。另外，空值（null）不区分大小写，null 和 NULL 效果是一样的：没有赋值，被赋值为 null，被 unset() 函数处理过的变量 文件操作：fopen()-&gt;feof()-&gt;fgets()-&gt;fclose(); 系统常量：（1）__FILE__ :php程序文件名。它可以帮助我们获取当前文件在服务器的物理位置。 （2）__LINE__ :PHP程序文件行数。它可以告诉我们，当前代码在第几行。 （3）PHP_VERSION:当前解析器的版本号。它可以告诉我们当前PHP解析器的版本号，我们可以提前知道我们的PHP代码是否可被该PHP解析器解析。 （4）PHP_OS：执行当前PHP版本的操作系统名称。它可以告诉我们服务器所用的操作系统名称，我们可以根据该操作系统优化我们的代码。 取常量值：直接使用常量名字define(&quot;name&quot;,value),constant(&quot;name&quot;) 判断是否被定义：defined(); 错误控制@() 遍历方式1.只取值，不取下标 foreach (数组 as 值){ //执行的任务 } 2.同时取下标和值 foreach (数组 as 下标 =&gt; 值){ //执行的任务 } 好了，在写就天亮了，至于关于PHP语法其他的基础其实跟iOS中的Objective-C大同小异，不是有句话编程的相同的嘛？还是语法是相通的，这句话其实只有真正体验一次才知道其中的含义。 下面的文章我将一步步学习并整理1.数组 2.函数 3.类与对象 4.字符串操作相关 5.正则表达式 6.会话控制 7.文件系统 8.日期与实践 9.图形图像操作 10.异常处理 11.数据操作 12.JSON和XML区别，应用与总结 13.Get和POST区别，应用于总结 14.PHP结合JavaScript 15.PHP中的框架介绍与简单使用：ThinkPHP，Yii，laravel。。。 或许有遗漏，或者中间会加入其它个人觉得直接记录的东西，但是学习的路线是不变的！]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——App整个启动过程分析]]></title>
    <url>%2F2016%2F04%2F28%2FiOS%E2%80%94%E2%80%94App%E6%95%B4%E4%B8%AA%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[你想知道App是怎么显示到我们眼前的吗？你想知道点击Run之后发生了什么吗？你想知道在Main函数之前都还有那些你不知道操作吗？你想知道在Objective-C和Swift混编的时候这么处理AppDelegate吗？你想知道UIApplication都干了撒吗？你想知道怎么优化App启动过程吗？你想知道…..你撒都想知道，那还等什么？ 前言 本文的起因： 前段时间在研究App启动相关内容，还有启动优化相关的东西，网上寻找了一下相关的资料并试着在整理，也自己试着去验证了其中的一些步骤。 公司项目是Objective-C版本的，大部分相关类都已经使用Swift重写了，后期新增的功能都使用的Swift混合开发。但是由于项目庞大又复杂，没有时间也没有精力去完全使用Swift重写。 因为从Swift一出来我就在学习，但是并没有在实际项目中应用到Swift，从1.0到2.0，再到3.0都有了解和学习相关的语法。但是近四年来一直都在使用OC和学习各种技术，以致于Swift其实该忘的也忘得差不多了。网上有句话：Swift从入门到入门。相信你既然都能看到这里，肯定明白其中的原因。所以我又开始重写学了一遍Swift，这一次是Swift3.1开始学，其实Swift4已经出来了，但是和3.1并没有太大的变化。 因为公司每个星期都有一个技术分享，所以我觉得去试一次，希望能把我知道的东西通过口述的方式分享出来。（不过分享的结果很差，毕竟是第一次，所以导致最后连我自己都不知道自己在说什么），同时这也是我在公司内部做的第一次技术分享的主题。 这一次，我希望能彻底从OC转到Swift进行实际开发。 资料地址： iOS——App整个启动过程分析。如果你觉得有用希望能给个star，或者有什么疑问欢迎issuse也欢迎联系我，谢谢！首先申明，本文大部分会以理论和实际分析，不会涉及的太多的代码实战，也不会涉及到太多相关术语的解释，当然部分会给出链接地址，但是力求从下面几个问题并结合实际App的启动过程，让你了解代码之前所干的事情和处理实际开发中遇到的相关问题…. 点击Run之后发生了什么,以致App能够显示在我们的眼前？ Main函数之前苹果还为我们的App做了哪些操作？ OC项目中怎么使用Swift重写AppDelagate？ UIApplication&amp;UIApplicationMain背后做了什么？ 如何优化App启动过程？…… 本文篇幅会比较长，但是如果你能完全掌握里面的内容和应用，足以让你有一个质的提升，当然这是在你不了解上面我提到的情况下。 好了，废话说太多没有什么意思……开干！ 2016 WWDC（苹果提供的启动优化方案） https://developer.apple.com/videos/play/wwdc2016/406/ 优化 App 的启动时间（各个阶段优化与处理） http://ios.jobbole.com/90331/ iOS 程序 main 函数之前发生了什么 http://blog.sunnyxx.com/2014/08/30/objc-pre-main/ 点击 Run 之后发生了什么？（Build类似） http://www.jianshu.com/p/d5cf01424e92 Xcode编译性能优化（各个阶段优化实战与对比） http://blog.csdn.net/qq_25131687/article/details/52194034]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS——App整个启动过程分析</tag>
        <tag>App整个启动过程分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——CocoaPods私有化组件]]></title>
    <url>%2F2016%2F04%2F25%2FiOS%E2%80%94%E2%80%94CocoaPods%E7%A7%81%E6%9C%89%E5%8C%96%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[相信你能看到这里，就一定用过cocoapods，cocoapods是什么呢？怎么用？算了吧，都是本文的范围，这里只介绍怎么将自己的项目组件进行私有化，其实严格来说不算什么私有化，只是，想自己写好的框架放到github或者其他平台上让他支持cocoapods管理。这类文章网上已经随处可见，但是由于打算开始写自己的框架，就记录了一下….. 首推荐 用CocoaPods做iOS程序的依赖管理 深入理解 CocoaPods CocoaPods 都做了什么? 如果你还不知道sm是CocoaPods，或者想对CocoaPods了解更深入一点的，可以先看看上面的推荐 1. 在github创建仓库完成，然后将仓库检出到本地注意创建事项： LICENSE(许可证)文件不可缺少，否则检测spec文件时，会有警告（选择MIT就OK） 不要使用中文，最好和库名字直接对应 其实也可以在其他平台，不一定是github 2. 将写好开源框架/库的Demo或者Example放到Git仓库下，还要将要开源的文件夹也放入到git仓库中（该文件夹在后面会被用到） 3. 项目发布到github后，我们在工程根目录中初始化一个Podspec文件：创建自己项目的Podspec描述文件: pod spec create iCocos 4. 编辑修改iCocos.podspec对应信息 可以直接参照我的内容进行修改 具体内容不介绍 s.name：名称，pod search 搜索的关键词,注意这里一定要和.podspec的名称一样,否则报错 s.version：版本号 s.ios.deployment_target:支持的pod最低版本 s.summary: 简介 s.homepage:项目主页地址 s.license:许可证 s.author:作者 s.social_media_url:社交网址,这里我写的微博默认是Twitter,如果你写Twitter的话,你的podspec发布成功后会@你 s.source:项目的地址 s.source = { :git =&gt; “https://github.com/al1020119/iCocos.git&quot;, :commit =&gt; “68defea” } s.source = { :git =&gt; “https://github.com/al1020119/iCocos.git&quot;, :tag =&gt; 1.0.0 } s.source = { :git =&gt; “https://github.com/al1020119/iCocos.git&quot;, :tag =&gt; s.version } commit =&gt; “68defea” 表示将这个Pod版本与Git仓库中某个commit绑定 tag =&gt; 1.0.0 表示将这个Pod版本与Git仓库中某个版本的comit绑定 tag =&gt; s.version 表示将这个Pod版本与Git仓库中相同版本的comit绑定 s.source_files:需要包含的源文件 s.resources: 资源文件 s.requires_arc: 是否支持ARC s.dependency：依赖库，不能依赖未发布的库，如 s.dependency = ‘AFNetworking’ s.dependency：依赖库，如有多个可以这样写。我这里是托管在github上,所以这里将地址copy过来就行了。 source_files: 核心代码的文件地址。 这里是经常出错的地方！—如果使用的是这种方式来显示核心代码地址而不是下面的模块化的话， 需要将代码文件必须以仓库名命名（也就意味着最多只有两个文件.h和.m文件了，可以有一个.h文件，把它作为头文件就行），这种方式检验podspec文件有点严格，否则就会报错。 source_files:写法及含义建议大家写第一种或者第二种 &quot;YJSettingTableView/* &quot;&quot;YJSettingTableView/YJSettingTableView/*.{h,m}&quot; &quot;YJSettingTableView/**/*.h&quot; “*” 表示匹配所有文件 “*.{h,m}” 表示匹配所有以.h和.m结尾的文件 “**” 表示匹配所有子目录 5. 设置tag号，提交修改（注：只要spec文件被修改，就必须重新执行如下命令）因为cocoapods是依赖tag版本的,所以必须打tag,以后再次更新只需要把你的项目打一个tag然后修改.podspec文件中的版本接着提交到cocoapods官方就可以了,提交命令请看下面 git commit -m “Release 1.0.0” (先提交当前修改) git tag “v1.0.0” (添加tag) //为git打tag, 第一次需要在前面加一个v git push –tags (推送tag到远程) git push origin master (推送到远程到代码仓库) 或许可能有些没有加入的（执行 git add . 就可以） 6. 提交之前先验证.podspec文件是否合法 pod spec lint iCocos.podspec –verbose pod spec lint iCocos.podspec –allow-warnings (忽略警告) 我这边在验证的时候出现了下面错误 LiudeMacBook:iCocos a115$ pod spec lint iCocos.podspec –verbose -&gt; iCocos (1.0.0) - ERROR | license: Sample license type. - ERROR | description: The description is empty. - ERROR | [iOS] unknown: Encountered an unknown error (The `iCocos` pod failed to validate due to 2 errors. [!] The validator for Swift projects uses Swift 3.0 by default, if you are using a different version of swift you can use a `.swift-version` file to set the version for your Pod. For example to use Swift 2.3, run: `echo &quot;2.3&quot; &gt; .swift-version`: - ERROR | license: Sample license type. - ERROR | description: The description is empty. ) during validation. Analyzed 1 podspec. [!] The spec did not pass validation, due to 3 errors. [!] The validator for Swift projects uses Swift 3.0 by default, if you are using a different version of swift you can use a `.swift-version` file to set the version for your Pod. For example to use Swift 2.3, run: `echo &quot;2.3&quot; &gt; .swift-version`. 根据上面提示了三个错误（due to 3 errors），其实是两个，1，3是一个 1. description is empty这里原始description是这样的 `s.description = &lt;&lt;-DESC` `DESC` 需要改成一段属于自己的描述，其他信息类型修改 关于swift-version 这里直接执行echo &quot;2.3&quot; &gt; .swift-version就正常的 但是据需验证又出现如下错误： LiudeMacBook:iCocos a115$ pod spec lint iCocos.podspec -&gt; iCocos (1.0.0) - ERROR | [iOS] unknown: Encountered an unknown error ([!] /usr/bin/git clone https://github.com/al1020119/iCocos.git /var/folders/4z/d12mnyfx7c37vg91t8h0941h0000gp/T/d20171025-8857-1oau87 --template= --single-branch --depth 1 --branch 1.0.0 Cloning into &apos;/var/folders/4z/d12mnyfx7c37vg91t8h0941h0000gp/T/d20171025-8857-1oau87&apos;... warning: Could not find remote branch 1.0.0 to clone. fatal: Remote branch 1.0.0 not found in upstream origin ) during validation. Analyzed 1 podspec. [!] The spec did not pass validation, due to 1 error. 这里其实不是错误，是没有更新处理，前面说了： （注：只要spec文件被修改，就必须重新执行如下命令） git commit -m &quot;Release 1.0.0&quot; (先提交当前修改) git tag 1.0.0 (添加tag) git push --tags (推送tag到远程) git push origin master (推送到远程到代码仓库) 或许可能有些没有加入的（执行 git add . 就可以） 7. 然后再次验证就会成功 LiudeMacBook:iCocos a115$ pod spec lint iCocos.podspec –verbose -&gt; iCocos (1.0.0) Analyzed 1 podspec. iCocos.podspec passed validation. 或许你还可能遇到下面的错误，不过不要慌，直接按照下面操作就可以 先删除tag // 删除本地tag git tag -d 1.0.0 // 删除远程tag git push origin -d tag 1.0.0 修改spec文件（必须修改相应的version和source）重新执行–&gt;设置tag号，提交修改的步骤 8. trunk推送podspec文件podspec文件验证成功，通过trunk推送podspec文件 pod trunk push iCocos.podspec 如果你是第一次，并且没有帐号你会看到下面一段 LiudeMacBook:iCocos a115$ pod trunk push iCocos.podspec [!] You need to register a session first. Usage: $ pod trunk push [PATH] Publish the podspec at `PATH` to make it available to all users of the ‘master’ spec-repo. If `PATH` is not provided, defaults to the current directory. Before pushing the podspec to cocoapods.org, this will perform a local lint of the podspec, including a build of the library. However, it remains *your* responsibility to ensure that the published podspec will actually work for your users. Thus it is recommended that you *first* try to use the podspec to integrate the library into your demo and/or real application. If this is the first time you publish a spec for this pod, you will automatically be registered as the ‘owner’ of this pod. (Note that ‘owner’ in this case implies a person that is allowed to publish new versions and add other ‘owners’, not necessarily the library author.) Options: --allow-warnings Allows push even if there are lint warnings --use-libraries Linter uses static libraries to install the spec --swift-version=VERSION The SWIFT_VERSION that should be used to lint the spec. This takes precedence over a .swift-version file. --skip-import-validation Lint skips validating that the pod can be imported --skip-tests Lint skips building and running tests during validation --silent Show nothing --verbose Show more debugging information --no-ansi Show output without ANSI codes --help Show help banner of specified command 根据上面的提示是告诉你：需要你用邮箱注册一个trunk 9. 我们直接使用终端注册pod trunk register al10201119@163.com &quot;iCocos&quot; --description=&quot;iCocos&quot; 之后会有一封带有验证链接的邮件发送到你输入的邮箱，点击验证后就可以回来终端继续提交操作了。 已经注册过的不需要注册,怎么看自己有没有注册 pod trunk me 10. 发布代码到cocoapodspod trunk push iCocos.podspec --verbose pod trunk push iCocos.podspec --allow-warnings 发布时会验证 Pod 的有效性，如果你在手动验证 Pod 时使用了 –use-libraries 或 –allow-warnings 等修饰符，那么发布的时候也应该使用相同的字段修饰，否则出现相同的报错。 pod trunk push iCocos.podspec –verbose 一段很长的描述，然后你会看到下面的成功提示 11. 如果提交到cocoapods还有可能遇到下面错误：Updating spec repo &apos;master&apos; warning: inexact rename detection was skipped due to too many files. warning: you may want yo set your diff.renameLimit variable to at least 3080 an retry the command ... [!] There was an error pushing a new version to trunk: execution expired 这里有解决方案：http://www.sw33tcode.com/?p=31 git config merge.renameLimit 999999 git config --unset merge.renameLimit 12. 然后开始去搜索我的库了但是发现既然没有，各种排查，最后发现由于延时的问题，不过如果还是不出现的，网上找到了相应的方案： 删除~/Library/Caches/CocoaPods目录下的search_index.json文件 pod setup成功后会生成~/Library/Caches/CocoaPods/search_index.json文件。 终端输入rm ~/Library/Caches/CocoaPods/search_index.json 删除成功后再执行pod search 稍等片刻，然后pod search就会出现你所要搜的类库了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS——CocoaPods私有化组件</tag>
        <tag>CocoaPods私有化组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第三篇——语法概括]]></title>
    <url>%2F2016%2F04%2F22%2FPHP%E7%AC%AC%E4%B8%89%E7%AF%87%E2%80%94%E2%80%94%E8%AF%AD%E6%B3%95%E6%A6%82%E6%8B%AC%2F</url>
    <content type="text"><![CDATA[简单了解PHP底层之后，第一件事肯定是开始多研究PHP的语法，和实现的问题。 PHP语法概括PHP 总结PHP 代表 PHP: Hypertext Preprocessor PHP 文件可包含文本、HTML、JavaScript代码和 PHP 代码 PHP 代码在服务器上执行，结果以纯 HTML 形式返回给浏览器 PHP 文件的默认文件扩展名是 &quot;.php&quot; PHP能做什么PHP 可以生成动态页面内容 PHP 可以创建、打开、读取、写入、关闭服务器上的文件 PHP 可以收集表单数据 PHP 可以发送和接收 cookies PHP 可以添加、删除、修改您的数据库中的数据 PHP 可以限制用户访问您的网站上的一些页面 PHP 可以加密数据 安装如果您的服务器不支持 PHP，您必须： 安装 Web 服务器 安装 PHP 安装数据库，比如 MySQL 官方 PHP 网站（PHP.net）有 PHP 的安装说明： http://php.net/manual/en/install.php 集成开发环境推荐 WAMP：http://www.wampserver.com/ PHP基本语法PHP 脚本可以放在文档中的任何位置。 PHP 脚本以 &lt;?php 开始，以 ?&gt; 结束： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h1&gt;我的第一个 PHP 页面&lt;/h1&gt; &lt;?php echo &quot;Hello World!&quot;; // 这是一行注释 /* 这是 多行 注释 */ ?&gt; &lt;/body&gt; &lt;/html&gt; PHP 中的每个代码行都必须以分号结束 两种在浏览器输出文本的基础指令：echo 和 print。 PHP变量变量以 $ 符号开始，后面跟着变量的名称 PHP 没有声明变量的命令。 变量在您第一次赋值给它的时候被创建： PHP 是一门弱类型语言PHP 会根据变量的值，自动把变量转换为正确的数据类型。 在强类型的编程语言中，我们必须在使用变量前先声明（定义）变量的类型和名称。 PHP变量的作用域PHP 有四种不同的变量作用域： local global static parameter 局部和全局作用域在所有函数外部定义的变量，拥有全局作用域。除了函数外，全局变量可以被脚本中的任何部分访问，要在一个函数中访问一个全局变量，需要使用 global 关键字。 在 PHP 函数内部声明的变量是局部变量，仅能在函数内部访问： &lt;?php $x=5; // 全局变量 function myTest() { $y=10; // 局部变量 echo &quot;&lt;p&gt;测试变量在函数内部:&lt;p&gt;&quot;; echo &quot;变量 x 为: $x&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;变量 y 为: $y&quot;; } myTest(); echo &quot;&lt;p&gt;测试变量在函数外部:&lt;p&gt;&quot;; echo &quot;变量 x 为: $x&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;变量 y 为: $y&quot;; ?&gt; 在函数内调用函数外定义的全局变量，我们需要在函数中的变量前加上 global 关键字： &lt;?php $x=5; $y=10; function myTest() { global $x,$y; $y=$x+$y; } myTest(); echo $y; // 输出 15 ?&gt; PHP 将所有全局变量存储在一个名为 $GLOBALS[index] 的数组中。 index 保存变量的名称。这个数组可以在函数内部访问，也可以直接用来更新全局变量。 &lt;?php $x=5; $y=10; function myTest() { $GLOBALS[&apos;y&apos;]=$GLOBALS[&apos;x&apos;]+$GLOBALS[&apos;y&apos;]; } myTest(); echo $y; ?&gt; Static 作用域当一个函数完成时，它的所有变量通常都会被删除。然而，有时候您希望某个局部变量不要被删除,可以使用 static关键字 &lt;?php function myTest() { static $x=0; echo $x; $x++; } myTest(); myTest(); myTest(); ?&gt; 参数作用域参数是通过调用代码将值传递给函数的局部变量。 参数是在参数列表中声明的，作为函数声明的一部分： &lt;?php function myTest($x) { echo $x; } myTest(5); ?&gt; PHP echo 和 print 语句echo - 可以输出一个或多个字符串 print - 只允许输出一个字符串，返回值总为 1 提示：echo 输出的速度比 print 快， echo 没有返回值，print有返回值1。echo 和 print 都是一个语言结构，使用的时候可以不用加括号，也可以加上括号： echo 或 echo() print print()。 &lt;?php echo &quot;&lt;h2&gt;PHP is fun!&lt;/h2&gt;&quot;; echo &quot;Hello world!&lt;br&gt;&quot;; echo &quot;I&apos;m about to learn PHP!&lt;br&gt;&quot;; echo &quot;This&quot;, &quot; string&quot;, &quot; was&quot;, &quot; made&quot;, &quot; with multiple parameters.&quot;; print &quot;&lt;h2&gt;PHP is fun!&lt;/h2&gt;&quot;; print &quot;Hello world!&lt;br&gt;&quot;; print &quot;I&apos;m about to learn PHP!&quot;; ?&gt; 下面的实例演示了如何使用 echo 命令输出变量和字符串： &lt;?php $txt1=&quot;Learn PHP&quot;; $txt2=&quot;w3cschool.cc&quot;; $cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;); echo $txt1; echo &quot;&lt;br&gt;&quot;; echo &quot;Study PHP at $txt2&quot;; //php 双引号内部可包含变量 echo &quot;My car is a {$cars[0]}&quot;; //用大括号 显式的指定这是变量 $txt1=&quot;Learn PHP&quot;; $txt2=&quot;w3cschool.cc&quot;; $cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;); print $txt1; print &quot;&lt;br&gt;&quot;; print &quot;Study PHP at $txt2&quot;; print &quot;My car is a {$cars[0]}&quot;; ?&gt; PHP5数据类型String（字符串）, Integer（整型）, Float（浮点型）, Boolean（布尔型）, Array（数组）, Object（对象）, NULL（空值）。 字符串你可以将任何文本放在单引号和双引号中： &lt;?php $x = &quot;Hello world!&quot;; echo $x; echo &quot;&lt;br&gt;&quot;; $x = &apos;Hello world!&apos;; //单引号 包括字符串字面量 双引号包含的字符串 可包含变量 echo $x; ?&gt; 整型在以下实例中我们将测试不同的数字。 PHP var_dump() 函数返回变量的数据类型和值： ?php $x = 5985; var_dump($x); echo &quot;&lt;br&gt;&quot;; $x = -345; // 负数 var_dump($x); echo &quot;&lt;br&gt;&quot;; $x = 0x8C; // 十六进制数 var_dump($x); echo &quot;&lt;br&gt;&quot;; $x = 047; // 八进制数 var_dump($x); ?&gt; 浮点型&lt;?php $x = 10.365; var_dump($x); echo &quot;&lt;br&gt;&quot;; $x = 2.4e3; var_dump($x); echo &quot;&lt;br&gt;&quot;; $x = 8E-5; var_dump($x); ?&gt; 布尔型布尔型可以是 TRUE 或 FALSE。 数组数组可以在一个变量中存储多个值 &lt;?php $cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;); var_dump($cars); ?&gt; 对象在 PHP 中，对象必须声明。 首先，你必须使用class关键字声明类对象。类是可以包含属性和方法的结构。然后我们在类中定义数据类型，然后在实例化的类中使用数据类型： &lt;?php class Car { var $color; function Car($color=&quot;green&quot;) { $this-&gt;color = $color; } function what_color() { return $this-&gt;color; } } function print_vars($obj) { foreach (get_object_vars($obj) as $prop =&gt; $val) { echo &quot;\t$prop = $val\n&quot;; } } // instantiate one object $herbie = new Car(&quot;white&quot;); // show herbie properties echo &quot;\herbie: Properties\n&quot;; print_vars($herbie); ?&gt; NULL 值NULL 值表示变量没有值。NULL 是数据类型为 NULL 的值。 &lt;?php $x=&quot;Hello world!&quot;; $x=null; var_dump($x); ?&gt; 常量常量是一个简单值的标识符。该值在脚本中不能改变。 (常量名不需要加 $ 修饰符)。 注意： 常量在整个脚本中都可以使用。 设置常量，使用 define() 函数，函数语法如下： define(string constant_name, mixed value, case_sensitive = true)该函数有三个参数: constant_name：必选参数，常量名称，即标志符。value：必选参数，常量的值。case_sensitive：可选参数，指定是否大小写敏感，设定为 true 表示不敏感。 以下实例我们创建一个 区分大小写的常量, 常量值为 “Welcome to W3CSchool.cc!”： &lt;?php define(&quot;GREETING&quot;, &quot;Welcome to W3CSchool.cc!&quot;); echo GREETING; ?&gt; 字符串函数和字符串连接&lt;?php $txt1=&quot;Hello world!&quot;; $txt2=&quot;What a nice day!&quot;; echo $txt1 . &quot; &quot; . $txt2; // 字符串连接运算符 . echo strlen(&quot;Hello world!&quot;); //获取字符串长度 echo strpos(&quot;Hello world!&quot;,&quot;world&quot;); //获取子串位置 //字符串中第一个字符的位置是 0 ?&gt; 运算符&lt;?php //其他运算符略.. //逻辑运算符 ! &amp;&amp; || and or xor //数组运算符 合并: + 比较：== != === !== $x = array(&quot;a&quot; =&gt; &quot;red&quot;, &quot;b&quot; =&gt; &quot;green&quot;); $y = array(&quot;c&quot; =&gt; &quot;blue&quot;, &quot;d&quot; =&gt; &quot;yellow&quot;); $z = $x + $y; // $x 和 $y 数组合并 var_dump($z); var_dump($x == $y); var_dump($x === $y); var_dump($x != $y); var_dump($x &lt;&gt; $y); var_dump($x !== $y); ?&gt; 流程控制语句 同js&lt;?php $t=date(&quot;H&quot;); if ($t&lt;&quot;20&quot;) { echo &quot;Have a good day!&quot;; } $t=date(&quot;H&quot;); if ($t&lt;&quot;20&quot;) { echo &quot;Have a good day!&quot;; } else { echo &quot;Have a good night!&quot;; } $t=date(&quot;H&quot;); if ($t&lt;&quot;10&quot;) { echo &quot;Have a good morning!&quot;; } else if ($t&lt;&quot;20&quot;) { echo &quot;Have a good day!&quot;; } else { echo &quot;Have a good night!&quot;; } $favcolor=&quot;red&quot;; switch ($favcolor) { case &quot;red&quot;: echo &quot;Your favorite color is red!&quot;; break; case &quot;blue&quot;: echo &quot;Your favorite color is blue!&quot;; break; case &quot;green&quot;: echo &quot;Your favorite color is green!&quot;; break; default: echo &quot;Your favorite color is neither red, blue, or green!&quot;; } //循环 $i=1; while($i&lt;=5) { echo &quot;The number is &quot; . $i . &quot;&lt;br&gt;&quot;; $i++; } $i=1; do { $i++; echo &quot;The number is &quot; . $i . &quot;&lt;br&gt;&quot;; } while ($i&lt;=5); for ($i=1; $i&lt;=5; $i++) { echo &quot;The number is &quot; . $i . &quot;&lt;br&gt;&quot;; } $x=array(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;); foreach ($x as $value) { echo $value . &quot;&lt;br&gt;&quot;; } ?&gt; 数组&lt;?php $cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;); //数组定义 数值数组 echo &quot;I like &quot; . $cars[0] . &quot;, &quot; . $cars[1] . &quot; and &quot; . $cars[2] . &quot;.&quot;; //访问数组元素 //数组长度count() $cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;); echo count($cars); //count() 函数用于返回数组的长度 //遍历数值数组 $cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;); $arrlength=count($cars); for($x=0;$x&lt;$arrlength;$x++) { echo $cars[$x]; echo &quot;&lt;br&gt;&quot;; } $age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);//定义关联数组 echo &quot;Peter is &quot; . $age[&apos;Peter&apos;] . &quot; years old.&quot;; //遍历关联数组 $age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;); foreach($age as $x=&gt;$x_value) { echo &quot;Key=&quot; . $x . &quot;, Value=&quot; . $x_value; echo &quot;&lt;br&gt;&quot;; } ?&gt; 数组排序PHP - 数组排序函数 sort() - 对数组进行升序排列rsort() - 对数组进行降序排列asort() - 根据关联数组的值，对数组进行升序排列ksort() - 根据关联数组的键，对数组进行升序排列arsort() - 根据关联数组的值，对数组进行降序排列krsort() - 根据关联数组的键，对数组进行降序排列 //sort() $cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;); sort($cars); $clength=count($cars); for($x=0;$x&lt;$clength;$x++) { echo $cars[$x]; echo &quot;&lt;br&gt;&quot;; } //rsort() $cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;); rsort($cars); //asort() arsort() 关联数组排序 value $age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;); asort($age); arsort($age); //ksort() krsort() 关联数组排序 key $age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;); ksort($age); krsort($age); ?&gt; 超级全局变量PHP中预定义了几个超级全局变量（superglobals） ，这意味着它们在一个脚本的全部作用域中都可用。 $GLOBALS $_SERVER $_REQUEST $_POST $_GET $_COOKIE $_FILES $_ENV $_SESSION $GLOBAL 是一个包含了全部变量的全局组合数组。变量的名字就是数组的键。 &lt;?php $x = 75; $y = 25; function addition() { $GLOBALS[&apos;z&apos;] = $GLOBALS[&apos;x&apos;] + $GLOBALS[&apos;y&apos;]; } addition(); echo $z; ?&gt; $_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目； &lt;?php echo $_SERVER[&apos;PHP_SELF&apos;]; // /try/demo_source/demo_global_server.php echo &quot;&lt;br&gt;&quot;; echo $_SERVER[&apos;SERVER_NAME&apos;]; // w3cschool.cc echo &quot;&lt;br&gt;&quot;; echo $_SERVER[&apos;HTTP_HOST&apos;]; // www.w3cschool.cc echo &quot;&lt;br&gt;&quot;; echo $_SERVER[&apos;HTTP_REFERER&apos;]; //来由 echo &quot;&lt;br&gt;&quot;; echo $_SERVER[&apos;HTTP_USER_AGENT&apos;]; //浏览器 echo &quot;&lt;br&gt;&quot;; echo $_SERVER[&apos;SCRIPT_NAME&apos;]; // /try/demo_source/demo_global_server.php //另外$_SERVER对象还包括 SERVER_ADDR, SERVER_PROTOCOL ,REQUEST_METHOD..等属性 ?&gt; $_REQUEST 用于收集HTML表单提交的数据。 &lt;html&gt; &lt;body&gt; &lt;form method=&quot;post&quot; action=&quot;&lt;?php echo $_SERVER[&apos;PHP_SELF&apos;];?&gt;&quot;&gt; Name: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;?php $name = $_REQUEST[&apos;fname&apos;]; echo $name; ?&gt; &lt;/body&gt; &lt;/html&gt; $_POST 被广泛应用于收集表单数据，在HTML form标签的指定该属性：”method=”post” &lt;html&gt; &lt;body&gt; &lt;!--页面post给自己--&gt; &lt;form method=&quot;post&quot; action=&quot;&lt;?php echo $_SERVER[&apos;PHP_SELF&apos;];?&gt;&quot;&gt; Name: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;?php $name = $_POST[&apos;fname&apos;]; echo $name; ?&gt; &lt;/body&gt; &lt;/html&gt; $_GET 同样被广泛应用于收集表单数据，在HTML form标签的指定该属性：”method=”get”。 $_GET 也可以收集URL中发送的数据。 &lt;html&gt; &lt;body&gt; &lt;a href=&quot;test_get.php?subject=PHP&amp;web=w3cschool.cc&quot;&gt;Test $GET&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; //test_get.php &lt;html&gt; &lt;body&gt; &lt;?php echo &quot;Study &quot; . $_GET[&apos;subject&apos;] . &quot; at &quot; . $_GET[&apos;web&apos;]; ?&gt; &lt;/body&gt; &lt;/html&gt; PHP 函数PHP 的真正威力源自于它的函数。 在 PHP 中，提供了超过 1000 个内建的函数。 &lt;html&gt; &lt;body&gt; &lt;?php function writeName() { echo &quot;Kai Jim Refsnes&quot;; } echo &quot;My name is &quot;; writeName(); //函数传参 function writeName($fname,$punctuation) { echo $fname . &quot; Refsnes&quot; . $punctuation . &quot;&lt;br&gt;&quot;; } echo &quot;My name is &quot;; writeName(&quot;Kai Jim&quot;,&quot;.&quot;); echo &quot;My sister&apos;s name is &quot;; //函数返回值 function add($x,$y) { $total=$x+$y; return $total; } echo &quot;1 + 16 = &quot; . add(1,16); ?&gt; &lt;/body&gt; &lt;/html&gt; 魔术变量有八个魔术常量它们的值随着它们在代码中的位置改变而改变。 _LINE__ 文件中的当前行号。FILE 文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。DIR 文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。FUNCTION 函数名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。 简单使用 &lt;?php function test() { echo &apos;函数名为：&apos; . __FUNCTION__ ; } test(); ?&gt; CLASS 类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。 在 PHP 4 中该值总是小写字母的。类名包括其被声明的作用区域（例如 Foo\Bar）。注意自 PHP 5.4 起 CLASS 对 trait 也起作用。当用在 trait 方法中时，CLASS 是调用 trait 方法的类的名字。 &lt;?php class test { function _print() { echo &apos;类名为：&apos; . __CLASS__ . &quot;&lt;br&gt;&quot;; echo &apos;函数名为：&apos; . __FUNCTION__ ; } } $t = new test(); $t-&gt;_print(); ?&gt; TRAIT Trait 的名字（PHP 5.4.0 新加）。自 PHP 5.4.0 起，PHP 实现了代码复用的一个方法，称为 traits。 Trait 名包括其被声明的作用区域（例如 Foo\Bar）。 从基类继承的成员被插入的 SayWorld Trait 中的 MyHelloWorld 方法所覆盖。其行为 MyHelloWorld 类中定义的方法一致。优先顺序是当前类中的方法会覆盖 trait 方法，而 trait 方法又覆盖了基类中的方法。 &lt;?php class Base { public function sayHello() { echo &apos;Hello &apos;; } } trait SayWorld { public function sayHello() { parent::sayHello(); echo &apos;World!&apos;; } } class MyHelloWorld extends Base { use SayWorld; } $o = new MyHelloWorld(); $o-&gt;sayHello(); ?&gt; METHOD 类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写） &lt;?php function test() { echo &apos;函数名为：&apos; . __METHOD__ ; } test(); ?&gt; NAMESPACE 当前命名空间的名称（区分大小写）。此常量是在编译时定义的（PHP 5.3.0 新增）。 &lt;?php namespace MyProject; echo &apos;命名空间为：&quot;&apos;, __NAMESPACE__, &apos;&quot;&apos;; // 输出 &quot;MyProject&quot; ?&gt; 命名空间PHP 命名空间(namespace)是在PHP 5.3中加入的，如果你学过C#和Java，那命名空间就不算什么新事物。 不过在PHP当中还是有着相当重要的意义。 PHP 命名空间可以解决以下两类问题： 用户代码与PHP内部的类/函数/常量之间的名字冲突。 创建别名（或简短）的名称，提高源代码的可读性。 默认情况下，所有常量、类和函数名都放在全局空间下，就和PHP支持命名空间之前一样。如果一个文件中包含命名空间，它必须在其它所有代码之前声明命名空间 &lt; ?php // 定义代码在 &apos;MyProject&apos; 命名空间中 namespace MyProject; // ... 代码 ... //也可以在同一个文件中定义不同的命名空间代码 namespace MyProject1; // MyProject1 命名空间中的PHP代码 namespace MyProject2; // MyProject2 命名空间中的PHP代码 // 另一种语法 namespace MyProject3 { // MyProject3 命名空间中的PHP代码 } ?&gt; 在声明命名空间之前唯一合法的代码是用于定义源文件编码方式的 declare 语句。所有非 PHP 代码包括空白符都不能出现在命名空间的声明之前。 &lt;?php declare(encoding=&apos;UTF-8&apos;); //定义多个命名空间和不包含在命名空间中的代码 namespace MyProject { const CONNECT_OK = 1; class Connection { /* ... */ } function connect() { /* ... */ } } namespace { // 全局代码 session_start(); $a = MyProject\connect(); echo MyProject\Connection::start(); } ?&gt; 以下代码会出现语法错误： &lt;html&gt; &lt;?php namespace MyProject; // 命名空间前出现了“&lt;html&gt;” 会致命错误 - 命名空间必须是程序脚本的第一条语句 ?&gt; 子命名空间&lt;?php namespace MyProject\Sub\Level; //声明分层次的单个命名空间 //创建了常量 MyProject\Sub\Level\CONNECT_OK， //类 MyProject\Sub\Level\Connection //和函数 MyProject\Sub\Level\Connect。 const CONNECT_OK = 1; class Connection { /* ... */ } function Connect() { /* ... */ } ?&gt; 命名空间使用PHP 命名空间中的类名可以通过三种方式引用： 非限定名称，或不包含前缀的类名称，例如 $a=new foo(); 或 foo::staticmethod();。如果当前命名空间是 currentnamespace，foo 将被解析为 currentnamespace\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，则 foo 会被解析为foo。 警告：如果命名空间中的函数或常量未定义，则该非限定的函数名称或常量名称会被解析为全局函数名称或常量名称。~~无命名空间前缀的引用，默认在当前命名空间查找，然后到全局命名空间找 限定名称,或包含前缀的名称，例如 $a = new subnamespace\foo(); 或 subnamespace\foo::staticmethod();。如果当前的命名空间是 currentnamespace，则 foo 会被解析为 currentnamespace\subnamespace\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，foo 会被解析为subnamespace\foo。 ~~带相对命名空间前缀的(类似相对路径)引用，自动在开头添加调用代码所处的命名空间 完全限定名称，或包含了全局前缀操作符的名称，例如， $a = new \currentnamespace\foo(); 或 \currentnamespace\foo::staticmethod();。在这种情况下，foo 总是被解析为代码中的文字名(literal name)currentnamespace\foo。~~带绝对命名空间前缀的引用(类似绝对路径) 引用路径已明确 不用查找 file1.php &lt;?php namespace Foo\Bar\subnamespace; const FOO = 1; function foo() {} class foo { static function staticmethod() {} } ?&gt; file2.php &lt;?php namespace Foo\Bar; include &apos;file1.php&apos;; const FOO = 2; function foo() {} class foo { static function staticmethod() {} } /* 非限定名称 */ foo(); // 解析为函数 Foo\Bar\foo foo::staticmethod(); // 解析为类 Foo\Bar\foo的静态方法staticmethod。 echo FOO; // resolves to constant Foo\Bar\FOO /* 限定名称 */ subnamespace\foo(); // 解析为函数 Foo\Bar\subnamespace\foo subnamespace\foo::staticmethod(); // 解析为类 Foo\Bar\subnamespace\foo, // 以及类的方法 staticmethod echo subnamespace\FOO; // 解析为常量 Foo\Bar\subnamespace\FOO /* 完全限定名称 */ \Foo\Bar\foo(); // 解析为函数 Foo\Bar\foo \Foo\Bar\foo::staticmethod(); // 解析为类 Foo\Bar\foo, 以及类的方法 staticmethod echo \Foo\Bar\FOO; // 解析为常量 Foo\Bar\FOO ?&gt; 在命名空间内部访问全局类、函数和常量： &lt;?php namespace Foo; function strlen() {} const INI_ALL = 3; class Exception {} $a = \strlen(&apos;hi&apos;); // 调用全局函数strlen $b = \INI_ALL; // 访问全局常量 INI_ALL $c = new \Exception(&apos;error&apos;); // 实例化全局类 Exception ?&gt; 命名空间和动态语言特征PHP 命名空间的实现受到其语言自身的动态特征的影响。因此，如果要将下面的代码转换到命名空间中，动态访问元素。 //example.php &lt;?php class classname { function __construct() { echo __METHOD__,&quot;\n&quot;; } } function funcname() { echo __FUNCTION__,&quot;\n&quot;; } const constname = &quot;global&quot;; $a = &apos;classname&apos;; $obj = new $a; // prints classname::__construct $b = &apos;funcname&apos;; $b(); // prints funcname echo constant(&apos;constname&apos;), &quot;\n&quot;; // prints global ?&gt; &lt;?php namespace namespacename; class classname { function __construct() { echo __METHOD__,&quot;\n&quot;; } } function funcname() { echo __FUNCTION__,&quot;\n&quot;; } const constname = &quot;namespaced&quot;; include &apos;example1.php&apos;;//全局命名空间和某个命名空间有相同类 函数 和 常量 分别区别访问 $a = &apos;classname&apos;; $obj = new $a; // prints classname::__construct $b = &apos;funcname&apos;; $b(); // prints funcname echo constant(&apos;constname&apos;), &quot;\n&quot;; // prints global /* note that if using double quotes, &quot;\\namespacename\\classname&quot; must be used */ $a = &apos;\namespacename\classname&apos;; $obj = new $a; // prints namespacename\classname::__construct $a = &apos;namespacename\classname&apos;; $obj = new $a; // also prints namespacename\classname::__construct $b = &apos;namespacename\funcname&apos;; $b(); // prints namespacename\funcname $b = &apos;\namespacename\funcname&apos;; $b(); // also prints namespacename\funcname echo constant(&apos;\namespacename\constname&apos;), &quot;\n&quot;; // prints namespaced echo constant(&apos;namespacename\constname&apos;), &quot;\n&quot;; // also prints namespaced ?&gt; namespace关键字和NAMESPACE常量&lt;?php namespace MyProject; echo &apos;&quot;&apos;, __NAMESPACE__, &apos;&quot;&apos;; // 输出 &quot;MyProject&quot; ?&gt; &lt;?php echo &apos;&quot;&apos;, __NAMESPACE__, &apos;&quot;&apos;; // 输出 &quot;&quot; ?&gt; 使用NAMESPACE动态创建名称 &lt;?php namespace MyProject; function get($classname) { $a = __NAMESPACE__ . &apos;\\&apos; . $classname; return new $a; } ?&gt; 关键字 namespace 可用来显式访问当前命名空间或子命名空间中的元素。它等价于类中的 self 操作符。 &lt;?php namespace MyProject; use blah\blah as mine; // see &quot;Using namespaces: importing/aliasing&quot; blah\mine(); // calls function blah\blah\mine() namespace\blah\mine(); // calls function MyProject\blah\mine() namespace\func(); // calls function MyProject\func() namespace\sub\func(); // calls function MyProject\sub\func() namespace\cname::method(); // calls static method &quot;method&quot; of class MyProject\cname $a = new namespace\sub\cname(); // instantiates object of class MyProject\sub\cname $b = namespace\CONSTANT; // assigns value of constant MyProject\CONSTANT to $b ?&gt; 在PHP中，别名是通过操作符 use 来实现的. 下面是一个使用所有可能的三种导入方式的例子： 使用use操作符导入/使用别名 &lt;?php namespace foo; use My\Full\Classname as Another; // 下面的例子与 use My\Full\NSname as NSname 相同 use My\Full\NSname; // 导入一个全局类 use \ArrayObject; $obj = new namespace\Another; // 实例化 foo\Another 对象 $obj = new Another; // 实例化 My\Full\Classname 对象 NSname\subns\func(); // 调用函数 My\Full\NSname\subns\func $a = new ArrayObject(array(1)); // 实例化 ArrayObject 对象 // 如果不使用 &quot;use \ArrayObject&quot; ，则实例化一个 foo\ArrayObject 对象 ?&gt; 一行中包含多个use语句 &lt;?php use My\Full\Classname as Another, My\Full\NSname; $obj = new Another; // 实例化 My\Full\Classname 对象 NSname\subns\func(); // 调用函数 My\Full\NSname\subns\func ?&gt; &lt;p&gt;导入操作是在编译执行的，但动态的类名称、函数名称或常量名称则不是。&lt;/p&gt; &lt;ol&gt; &lt;li&gt;导入和动态名称&lt;/li&gt; &lt;/ol&gt; &lt;pre&gt; &lt;?php use My\Full\Classname as Another, My\Full\NSname; $obj = new Another; // 实例化一个 My\Full\Classname 对象 $a = &apos;Another&apos;; $obj = new $a; // 实际化一个 Another 对象 ?&gt; 导入和动态名称 &lt;?php use My\Full\Classname as Another, My\Full\NSname; $obj = new Another; // 实例化一个 My\Full\Classname 对象 $a = &apos;Another&apos;; $obj = new $a; // 实际化一个 Another 对象 ?&gt; 另外，导入操作只影响非限定名称和限定名称。完全限定名称由于是确定的，故不受导入的影响。 导入和完全限定名称 &lt;?php use My\Full\Classname as Another, My\Full\NSname; $obj = new Another; // instantiates object of class My\Full\Classname $obj = new \Another; // instantiates object of class Another $obj = new Another\thing; // instantiates object of class My\Full\Classname\thing $obj = new \Another\thing; // instantiates object of class Another\thing ?&gt; 使用命名空间：后备全局函数/常量在一个命名空间中，当 PHP 遇到一个非限定的类、函数或常量名称时，它使用不同的优先策略来解析该名称。 类名称总是解析到当前命名空间中的名称(找不到就报错咯)。因此在访问系统内部或不包含在命名空间中的类名称时，必须使用完全限定名称函数和常量来说，如果当前命名空间中不存在该函数或常量，PHP 会退而使用全局空间中的函数或常量。 &lt;?php namespace A\B\C; class Exception extends \Exception {} $a = new Exception(&apos;hi&apos;); // $a 是类 A\B\C\Exception 的一个对象 $b = new \Exception(&apos;hi&apos;); // $b 是类 Exception 的一个对象 $c = new ArrayObject; // 致命错误, 找不到 A\B\C\ArrayObject 类 ?&gt; 全局空间如果没有定义任何命名空间，所有的类与函数的定义都是在全局空间，与 PHP 引入命名空间概念前一样。在名称前加上前缀 \ 表示该名称是全局空间中的名称，即使该名称位于其它的命名空间中时也是如此。 &lt;?php namespace A\B\C; /* 这个函数是 A\B\C\fopen */ function fopen() { /* ... */ $f = \fopen(...); // 调用全局的fopen函数 return $f; } ?&gt; 命名空间的顺序 略.. PHP文件处理打开文件 $file = fopen($fname, mode) //文件的名称, 打开模式 r 只读。在文件的开头开始。 r+ 读/写。在文件的开头开始。 w 只写。打开并清空文件的内容；如果文件不存在，则创建新文件。 w+ 读/写。打开并清空文件的内容；如果文件不存在，则创建新文件。 a 追加。打开并向文件末尾进行写操作，如果文件不存在，则创建新文件。 a+ 读/追加。通过向文件末尾写内容，来保持文件内容。 x 只写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。 x+ 读/写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。 注释：如果 fopen() 函数无法打开指定文件，则返回 0 (false)。 &lt;?php //打开文件 $file = fopen(&quot;welcome.txt&quot;, &quot;r&quot;) or exit(&quot;Unable to open file!&quot;); //Output a line of the file until the end is reached //是否到达文件末尾 while(!feof($file)) { echo fgets($file). &quot;&lt;br&gt;&quot;; //逐行读取文件 //echo fgetc($file); //逐字符读取 } //关闭文件 fclose($file); ?&gt; Filesystem 函数basename() 返回路径中的文件名部分。 chgrp() 改变文件组。 chmod() 改变文件模式。 chown() 改变文件所有者。 clearstatcache() 清除文件状态缓存。 copy() 复制文件。 delete() 参见 unlink() 或 unset() dirname() 返回路径中的目录名称部分。 disk_free_space() 返回目录的可用空间。 disk_total_space() 返回一个目录的磁盘总容量。 diskfreespace() disk_free_space() 的别名。 fclose() 关闭打开的文件。 feof() 测试文件指针是否到了文件末尾。 fflush() 向打开的文件刷新缓冲输出。 fgetc() 从打开的文件中返回字符。 fgetcsv() 从打开的文件中解析一行，校验 CSV 字段。 fgets() 从打开的文件中返回一行。 fgetss() 从打开的文件中返回一行，并过滤掉 HTML 和 PHP 标签。 file() 把文件读入一个数组中。 file_exists() 检查文件或目录是否存在。 file_get_contents() 把文件读入字符串。~~获取文件内容 file_put_contents() 把字符串写入文件。~~写入文件内容 fileatime() 返回文件的上次访问时间。 filectime() 返回文件的上次修改时间。 filegroup() 返回文件的组 ID。 fileinode() 返回文件的 inode 编号。 filemtime() 返回文件内容的上次修改时间。 fileowner() 返回文件的用户 ID （所有者）。 fileperms() 返回文件的权限。 filesize() 返回文件大小。 filetype() 返回文件类型。 flock() 锁定或释放文件。 fnmatch() 根据指定的模式来匹配文件名或字符串。 fopen() 打开一个文件或 URL。 fpassthru() 从打开的文件中读数据，直到文件末尾（EOF），并向输出缓冲写结果。 fputcsv() 把行格式化为 CSV 并写入一个打开的文件中。 fputs() fwrite() 的别名。 fread() 读取打开的文件。 fscanf() 根据指定的格式对输入进行解析。 fseek() 在打开的文件中定位。 fstat() 返回关于一个打开的文件的信息。 ftell() 返回在打开文件中的当前位置。 ftruncate() 把打开文件截断到指定的长度。 fwrite() 写入打开的文件。 glob() 返回一个包含匹配指定模式的文件名/目录的数组。 is_dir() 判断文件是否是一个目录。 is_executable() 判断文件是否可执行。 is_file() 判断文件是否是常规的文件。 is_link() 判断文件是否是连接。 is_readable() 判断文件是否可读。 is_uploaded_file() 判断文件是否是通过 HTTP POST 上传的。 is_writable() 判断文件是否可写。 is_writeable() is_writable() 的别名。 lchgrp() 改变符号连接的组所有权。 lchown() 改变符号连接的用户所有权。 link() 创建一个硬连接。 linkinfo() 返回有关一个硬连接的信息。 lstat() 返回关于文件或符号连接的信息。 mkdir() 创建目录。 move_uploaded_file() 把上传的文件移动到新位置。 parse_ini_file() 解析一个配置文件。 parse_ini_string() 解析一个配置字符串。 pathinfo() 返回关于文件路径的信息。 pclose() 关闭由 popen() 打开的进程。 popen() 打开一个进程。 readfile() 读取一个文件，并写入到输出缓冲。 readlink() 返回符号连接的目标。 realpath() 返回绝对路径名。 realpath_cache_get() 返回高速缓存条目。 realpath_cache_size() 返回高速缓存大小。 rename() 重命名文件或目录。 rewind() 倒回文件指针的位置。 rmdir() 删除空的目录。 set_file_buffer() 设置已打开文件的缓冲大小。 stat() 返回关于文件的信息。 symlink() 创建符号连接。 tempnam() 创建唯一的临时文件。 tmpfile() 创建唯一的临时文件。 touch() 设置文件的访问和修改时间。 umask() 改变文件的文件权限。 unlink() 删除文件。 PHP JSONjson_encode 对变量进行 JSON 编码 json_decode 对 JSON 格式的字符串进行解码，转换为 PHP 变量 json_last_error 返回最后发生的错误 string json_encode ( $value [, $options = 0 ] ) 参数value: 要编码的值。该函数只对 UTF-8 编码的数据有效。options:由以下常量组成的二进制掩码：JSON_HEX_QUOT, JSON_HEX_TAG, JSON_HEX_AMP, JSON_HEX_APOS, JSON_NUMERIC_CHECK,JSON_PRETTY_PRINT, JSON_UNESCAPED_SLASHES, JSON_FORCE_OBJECT &lt;?php $arr = array(&apos;a&apos; =&gt; 1, &apos;b&apos; =&gt; 2, &apos;c&apos; =&gt; 3, &apos;d&apos; =&gt; 4, &apos;e&apos; =&gt; 5); echo json_encode($arr); class Emp { public $name = &quot;&quot;; public $hobbies = &quot;&quot;; public $birthdate = &quot;&quot;; } $e = new Emp(); $e-&gt;name = &quot;sachin&quot;; $e-&gt;hobbies = &quot;sports&quot;; $e-&gt;birthdate = date(&apos;m/d/Y h:i:s a&apos;, &quot;8/5/1974 12:20:03 p&quot;); $e-&gt;birthdate = date(&apos;m/d/Y h:i:s a&apos;, strtotime(&quot;8/5/1974 12:20:03&quot;)); echo json_encode($e); ?&gt; mixed json_decode ($json [,$assoc = false [, $depth = 512 [, $options = 0 ]]]) 参数json_string: 待解码的 JSON 字符串，必须是 UTF-8 编码数据 assoc: 当该参数为 TRUE 时，将返回数组，FALSE 时返回对象。 depth: 整数类型的参数，它指定递归深度 options: 二进制掩码，目前只支持 JSON_BIGINT_AS_STRING 。 &lt;?php $json = &apos;{&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:4,&quot;e&quot;:5}&apos;; var_dump(json_decode($json)); var_dump(json_decode($json, true)); ?&gt;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——奇葩需求QQ号与QQ群添加与跳转]]></title>
    <url>%2F2016%2F04%2F18%2FiOS%E2%80%94%E2%80%94%E5%A5%87%E8%91%A9%E9%9C%80%E6%B1%82QQ%E5%8F%B7%E4%B8%8EQQ%E7%BE%A4%E6%B7%BB%E5%8A%A0%E4%B8%8E%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[最近在做一个新的二次元游戏App，说真的第一次做游戏一开始有点压力，但是后面了解到用到的技术其实跟游戏没有太多关系，就巴拉巴拉的开始写了，但是由于只有一个人，项目赶着上线，再加上之前需求的不明确和中途的调整，导致期间也浪费了不少时间，最近在实现最后一个功能的时候遇到了点问题，一开始是我想的太复杂了，后面群里一问，网上一了解，发现：MMP，这么简单，说多了都是尿，于是记录了这一切…….. 前言 本文的起因： 新项目，一个人纯swift开发，有个小功能第一次遇到，就是在用户中心有一行显示（群号+点击加群）文案，点击这一行拉起QQ App，如果QQ APP所登录的QQ已经加入了QQ号就直接到群聊页面，如果没有就跳到加群页面，可以点击申请加群。 注意： 这里其实是打开QQ后，使用QQ来去打开了一个网页。下面上代码： 一下是朋友提供的OC代码- (NSURL*)getQQQunUrl { NSString *qq_number = @&quot;??&quot; NSString* urlStr = [NSString stringWithFormat:@&quot;mqqapi://card/show_pslcard?src_type=internal&amp;version=1&amp;uin=%@&amp;key=%@&amp;card_type=group&amp;source=external&quot;, qq_number, @&quot;44a6e01f2dab126f87ecd2ec7b7e66ae259b30535fd0c2c25776271e8c0ac08f&quot;]; return [NSURL URLWithString:urlStr]; } 调用方式：NSURL* url = [self getQQqunUrl]; if ([[UIApplication sharedApplication] canOpenURL:url]) { [[UIApplication sharedApplication] openURL:url]; } 这是我最终Swift的实现方式func getQQQunUrl() -&gt; String { let qq_number = &quot;??&quot; let url_str = &quot;mqqapi://card/show_pslcard?src_type=internal&amp;version=1&amp;uin=\(qq_number)&amp;key=44a6e01f2dab126f87ecd2ec7b7e66ae259b30535fd0c2c25776271e8c0ac08f&amp;card_type=group&amp;source=external&quot; return url_str } 调用方式：let urlString = self.getQQQunUrl() if let url = URL(string: urlString) { //根据iOS系统版本，分别处理 if #available(iOS 10, *) { UIApplication.shared.open(url, options: [:], completionHandler: { (success) in }) } else { UIApplication.shared.openURL(url) } } 只要替换以上QQ好就可以，看着代码是不是很简单，算了不说了，我都想静一静…… 来看看效果图： 加群之前的效果 加群之后的效果 QQ号调整最近又有一个新的需求，由于需求比较相似，于是我直接在这里追加了。 需要处理QQ号的跳转，点击直接打开QQ调用网页版加号或者聊天页面 其实功能并没有任何难度在，其实寻找对应的链接，替换内部信息就可以。 一下只提供OC和Swift的关键代码： OC的实现方式//qqNumber就是你要打开的QQ号码， 也就是你的客服号码。 NSString *qqNumber=@&quot;QQ号&quot;; if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;mqq://&quot;]]) { UIWebView *webView = [[UIWebView alloc] initWithFrame:CGRectZero]; NSURL * url=[NSURL URLWithString:[NSString stringWithFormat:@&quot;mqq://im/chat?chat_type=wpa&amp;uin=%@&amp;version=1&amp;src_type=web&quot;,qqNumber]]; NSURLRequest *request = [NSURLRequest requestWithURL:url]; webView.delegate = self; [webView loadRequest:request]; [self.view addSubview:webView]; } Swift的实现方式// 打开Url class func openOuterUrl(_ url: String) { if let url = URL(string: url) { //根据iOS系统版本，分别处理 if UIApplication.shared.canOpenURL(url) { //根据iOS系统版本，分别处理 if #available(iOS 10, *) { UIApplication.shared.open(url, options: [:], completionHandler: { (success) in }) } else { UIApplication.shared.openURL(url) } } } } class func getQQUrl() -&gt; String { let url_str = &quot;mqq://im/chat?chat_type=wpa&amp;uin=\(self.getQQ())&amp;version=1&amp;src_type=web&quot; return url_str } 参考链接iOS调用QQ客户端,发起临时会话IOS APP中打开指定qq聊天界面]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS——奇葩需求QQ号与QQ群添加与跳转</tag>
        <tag>QQ号与QQ群添加与调整功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第二篇——理论常识：HTTP-HTTPS]]></title>
    <url>%2F2016%2F04%2F15%2FPHP%E7%AC%AC%E4%BA%8C%E7%AF%87%E2%80%94%E2%80%94%E7%90%86%E8%AE%BA%E5%B8%B8%E8%AF%86%EF%BC%9AHTTP-HTTPS%2F</url>
    <content type="text"><![CDATA[简介 超文本传输协议（HTTP，HyperText Transfer Protocol) 是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。 HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer） 是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 HTTPS句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。 TCP/IPHTTP是一个基于TCP的协议,而TCP是一种可靠的传输层协议. TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP/IP做传输层协议将它发到网络上。 HTTPS HTTP+加密+认证+完整性保护=HTTPS 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 HTTPS协议的主要作用可以分为两种： 一种是建立一个信息安全通道，来保证数据传输的安全； 另一种就是确认网站的真实性。 HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。 SSL/TLS SSL：（Secure Socket Layer，安全套接字层） 位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。 TLS：（Transport Layer Security，传输层安全协议） 用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。 SSL是Netscape开发的专门用于保护Web通讯的，目前版本为3.0.最新版本的TLS 1.0是IETE（工程任务组）指定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本。两者差别极小，可以理解为SSL 3.1，它是写入了RFC的。 SSL的作用 （1）、认证用户和服务器，确保数据发送到正确的客户机和服务器； （2）、加密数据以防止数据中途被窃取； （3）、维护数据的完整性，确保数据在传输过程中不被改变。 而SSL证书指的是在SSL通信中验证通信双方身份的数字文件，一般分为服务器证书和客户端证书，我们通常说的SSL证书主要指服务器证书，SSL证书由受信任的数字证书颁发机构CA（如VeriSign，GlobalSign，WoSign等），在验证服务器身份后颁发，具有服务器身份验证和数据传输加密功能，分为扩展验证型(EV)SSL证书、组织验证型(OV)SSL证书、和域名验证型（DV）SSL证书。 CA证书 CA（Certificate Authority）是负责管理和签发证书的第三方权威机构，是所有行业和公众都信任的、认可的。 CA证书，就是CA颁发的证书，可用于验证网站是否可信（针对HTTPS）、验证某文件是否可信（是否被篡改）等，也可以用一个证书来证明另一个证书是真实可信，最顶级的证书称为根证书。除了根证书（自己证明自己是可靠），其它证书都要依靠上一级的证书，来证明自己。 HTTP&amp;HTTPS区别：简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。 https协议需要到ca申请证书或自制证书。 http的信息是明文传输，https则是具有安全性的ssl加密。 http是直接与TCP进行数据传输，而https是经过一层SSL（OSI表示层），用的端口也不一样，前者是80（需要国内备案），后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 HTTP&amp;HTTPS综合区别：https://blog.csdn.net/hanjianqiang2468/article/details/52605849 注意: https加密是在传输层 https报文在被包装成tcp报文的时候完成加密的过程，无论是https的header域也好，body域也罢都是会被加密的。 当使用tcpdump或者wireshark之类的tcp层工具抓包，获取是加密的内容，而如果用应用层抓包，使用Charels(Mac)、Fildder(Windows)抓包工具，那当然看到是明文的。 握手过程HTTP三次握手 HTTP（HyperText Transfer Protocol)超文本传输协议是互联网上应用最为广泛的一种网络协议。由于信息是明文传输，所以被认为是不安全的。而关于HTTP的三次握手，其实就是使用三次TCP握手确认建立一个HTTP连接。 SYN（synchronous）是TCP/IP建立连接时使用的握手信号、Sequence number（序列号）、Acknowledge number（确认号码），三个箭头指向就代表三次握手，完成三次握手，客户端与服务器开始传送数据。 第一次握手： 客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手： 服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手： 客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 建立TCP连接时会发生:三次握手(three-way handshake) firefox &gt; nginx [SYN] 在么 nginx &gt; firefox [SYN, ACK] 在 firefox &gt; nginx [ACK] 知道了 为什么断开需要四次握手:关于四次握手的详细过程这里就不过多介绍，请自行百度，这里简单说一下需要执行的步骤，和为什么连接是三次，二断开时四次 关闭TCP连接时会发生:四次挥手(four-way handshake) firefox &gt; nginx [FIN] 我要关闭连接了 nginx &gt; firefox [ACK] 知道了,等我发完包先 nginx &gt; firefox [FIN] 我也关闭连接了 firefox &gt; nginx [ACK] 好的,知道了 解释原因： TCP建立连接要进行3次握手,而断开连接要进行4次,这是由于TCP的半关闭造成的,因为TCP连接是全双工的( 即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭,这个单方向的关闭就叫半关闭. 关闭的方法是一方完成它的数据传输后,就发送一个FIN来向另一方通告将要终止这个方向的连接.当一端收到一个FIN,它必须 通知应用层TCP连接已终止了这个方向的数据传送,发送FIN通常是应用层进行关闭的结果. 另一种解释： 这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。 补充 SYN: synchronization(同步) ACK: acknowledgement(确认:告知已收到) FIN: finish(结束) HTTPS握手： HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。具体是如何进行加密，解密，验证的，且看下图，下面的称为一次握手。 1.客户端发起HTTPS请求 2.服务端的配置 采用HTTPS协议的服务器必须要有一套数字证书，可以是自己制作或者CA证书。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用CA证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。公钥给别人加密使用，私钥给自己解密使用。 3.传送证书 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等。 4.客户端解析证书 这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值，然后用证书对该随机值进行加密。 5.传送加密信息 这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 6.服务段解密信息 服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。 7.传输加密后的信息 这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。 8.客户端解密信息 客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。 注意: HTTPS中整个握手过程第三方即使监听到了数据，也束手无策。 为什么HTTPS是安全的？ 在HTTPS握手的第四步中，如果站点的证书是不受信任的，会显示出现下面确认界面，确认了网站的真实性。另外第六和八步，使用客户端私钥加密解密，保证了数据传输的安全。 补充app与后台通信完整流程 1.建立连接：前台后台建立连接。 2.发送请求：打开连接后，app向后台发送请求。 3.发送响应：后台处理完请求后，要向app发送响应消息。 后台通过关键词：路径映射，Dispatcher分发机制等方式处理app的请求 4.断开连接：以上交互完成后可以断开连接了。 浏览器执行过程 1.首先嘛，你得在浏览器里输入要网址: 2.浏览器查找域名的IP地址 3.浏览器给web服务器发送一个HTTP请求 4.facebook服务的永久重定向响应.服务器给浏览器响应一个301永久重定向响应，这样浏览器就会问“http://www.facebook.com/” 而非“http://facebook.com/”。 5.浏览器跟踪重定向地址.浏览器知道了“http://www.facebook.com/”才是要访问的正确地址，所以它会发送另一个获取请求： 6.服务器“处理”请求.服务器接收到获取请求，然后处理并返回一个响应。 7.服务器发回一个HTML响应. 8.浏览器开始显示HTML. 9.浏览器发送获取嵌入在HTML中的对象。在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。 10.浏览器发送异步（AJAX）请求。 TCP， UDP，Socket TCP :Transmission Control Protocol，传输控制协议,是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂,但也是最安全的。 UDP : User Data Protocol，用户数据报协议。传输数据之前源端和终端不建立连接，发送端直接把数据发送到网络，接收端把消息段放在队列中，应用程序每次从队列中读一个消息段。 Socket,俗称网络套接字，本身并不是协议，而是一个调用接口，是对TCP/IP协议的封装和应用,提供了一系列方法方便开发者进行网络通讯。 TCP/IP协议是使用最早的通讯协议，它是传输层协议，主要解决数据如何在网络中传输。 Socket中又分为流模式、数据报模式、原始套接字三种模式，即Socket_STREAM,Socket_DREAME,SOCL_RAW方式。 原始套接字(SOCK_RAW)：原始套接字与标准套接字（标准套接字指的是前面介绍的流套接字和数据报套接字）的区别在于: 原始套接字可以读写内核没有处理的IP数据包， 流套接字: 只能读取TCP协议的数据， 数据报套接字: 只能读取UDP协议的数据。 因此，如果要访问其他协议发送数据必须使用原始套接字。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第一篇——工具集选]]></title>
    <url>%2F2016%2F04%2F12%2FPHP%E7%AC%AC%E4%B8%80%E7%AF%87%E2%80%94%E2%80%94%E5%B7%A5%E5%85%B7%E9%9B%86%E9%80%89%2F</url>
    <content type="text"><![CDATA[关于PHP环境搭建，我相信网上到处一大丢，而且都将的很不错，只是要细心按步骤来，这里就不介绍了 Windows：123http://www.cnblogs.com/pharen/archive/2012/02/06/2340628.htmlhttp://www.cnblogs.com/HD/p/4531342.html MAC：123http://www.jellythink.com/archives/783https://my.oschina.net/joanfen/blog/171109 PHP工具集选 欢迎您的到来，希望有所收获，如果您有什么疑问或者建议，欢迎一起讨论，也可以直接给我留言或者直接联系我！微信：clpaial10201119(183**7821) / QQ：2211523682github博文（如果你对iOS常用技术，基础，底层感兴趣请猛戳这里）：http://al1020119.github.io/github：https://github.com/al1020119 集成环境 XAMPP WAMP LAMP MAMP XAMPP12345678XAMPP（Apache+MySQL+PHP+PERL）是一个功能强大的建 XAMPP 软件站集成软件包。这个软件包原来的名字是 LAMPP，但是为了避免误解，最新的几个版本就改名为 XAMPP 了。它可以在Windows、Linux、Solaris、Mac OS X 等多种操作系统下安装使用。支持多语言：英文、简体中文、繁体中文、韩文、俄文、日文等。 许多人通过他们自己的经验认识到安装 Apache 服务器是件不容易的事儿。如果您想添加 MySQL、PHP 和 Perl，那就更难了。XAMPP 是一个易于安装且包含 MySQL、PHP 和 Perl 的 Apache 发行版。XAMPP 的确非常容易安装和使用：只需下载，解压缩，启动即可。 WAMP123456789101112Windows下的Apache+Mysql/MariaDB+Perl/PHP/Python，一组常用来搭建动态网站或者服务器的开源软件，本身都是各自独立的程序，但是因为常被放在一起使用，拥有了越来越高的兼容度，共同组成了一个强大的Web应用程序平台。随着开源潮流的蓬勃发展，开放源代码的LAMP已经与J2EE和.Net商业软件形成三足鼎立之势，并且该软件开发的项目在软件方面的投资成本较低，因此受到整个IT界的关注。LAMP是基于Linux，Apache，MySQL/MariaDB和PHP的开放资源网络开发平台，PHP是一种有时候用Perl或Python可代替的编程语言。这个术语来自欧洲，在那里这些程序常用来作为一种标准开发环境。名字来源于每个程序的第一个字母。每个程序在所有权里都符合开放源代码标准：Linux是开放系统；Apache是最通用的网络服务器；mySQL是带有基于网络管理附加工具的关系数据库；PHP是流行的对象脚本语言，它包含了多数其它语言的优秀特征来使得它的网络开发更加有效。开发者在Windows操作系统下使用这些Linux环境里的工具称为使用WAMP。 LAMP12345LAMP是一个缩写，它指一组通常一起使用来运行动态网站或者服务器的自由软件：Linux，操作系统；Apache，网页服务器；MySQL，数据库管理系统（或者数据库服务器）；PHP 和有时Perl 或 Python，脚本语言。 MAMP123456MAMP PRO是专业级版本的经典本地服务器环境的os x软件。MAMP这几个首字母代表苹果的OSX系统上的Macintosh、Apache、MySQL和PHP，顾名思义，你应该知道MAMP的强大功能 啦！MAMP 内含 Apache 服务器、PHP 安装套件以及MySQL安装套件。只要轻松点选就能安装架站/讨论区/论坛必备的元件。透过Web界面稍作设定，在苹果电脑上架设自己专属的网站，就是这 么简单又开心的事情和windows下的XAMPP，Linux下的LAMP一样。都是Apache+Mysql+PHP的集成环境 上面的我都在不同的环境简单的使用了一下，因为我一直使用的都是Mac，所以最后首选MAMPP Pro，具体具体为什么活着但是到底好不好用，我相信你用了就知道了！ 关于IDE： PhpStorm netbeans … PhpStorm，个人认为是最好的php开发ide，自带各种差价，ftp、svn、git、sql等都可以无缝使用netbeans:很强大不适合新手其他：zendSudio, php100。。。 PHPStorm吸引我的特点： 1234567891011121314跨平台，我在 Windows, Linux, Mac 下都可以使用它，完全一致的界面和功能，省着折腾了UI 还算好看，我用的是 Darcula 这个主题可以很方便地调试位于各种地方的 PHP 脚本，比如本地的，远程的，GAE 上的，还自带一个 RESTful 客户端，方便调试 API, 只是不大好用...可以真正地读懂源代码，进行重构，比如给函数/类改名，拆分函数或类，自动完成 PHPDoc, 标识语法错误等等的，对PHP新的标准和语法支持比较及时。虽然这一条看上去很多 IDE 都能做到，但 IDEA 做得真心更好可以直接在 IDE 里浏览数据库，浏览远程服务器上的文件，自动上传到远程服务器，IDE 内支持多种版本控制系统，总是可以在 IDE 里完成几乎所有事情。插件比较多，通过插件可以支持更多语言的开发支持前端开发，对 JS 的支持很好 数据库：1必须MYSQL：天生一对，不用问为什么！ 数据库工具：12345678910111213141516phpMyAdmin：phpMyAdmin 是一个以PHP为基础，以Web-Base方式架构在网站主机上的MySQL的数据库管理工具，让管理者可用Web接口管理MySQL数据库Navicat：Navicat是一套快速、可靠并价格相当便宜的数据库管理工具，专为简化数据库的管理及降低系统管理成本而设。它的设计符合数据库管理员、开发人员及中小企业的需要。Navicat 是以直觉化的图形用户界面而建的，让你可以以安全并且简单的方式创建、组织、访问并共用信息。现在官方就有中文版，我买的App Store内的，包含Navicat的会员（多人合作用）也才和官方价格一样。SQL Manager：SQL管理器，实现远程连接数据服务器；对数据库进行备份/恢复/日志文件清除；提取多个表的结构，并可保存；可以把表中记录直接生成“Insert、Delete、Update”等语句，便于使用；可以直接提取表中记录值；可以对多表进行备份；可以直接在此运行SQL语句。 这里我首选的是Navicat因为之前iOS使用SQLite3的时候一直也是使用的他，非常不错的一个软件。 服务器123456789Apache ：Apache HTTP Server（简称Apache）是Apache软件基金会的一个开放源码的网页服务器，可以在大多数计算机操作系统中运行，由于其多平台和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩展，将Perl/Python等解释器编译到服务器中。[2] Apache HTTP服务器是一个模块化的服务器，源于NCSAhttpd服务器，经过多次修改，成为世界使用排名第一的Web服务器软件。Nginx 可以在大多数 UnixLinux OS 上编译运行，并有 Windows 移植版。Nginx 的1.4.0稳定版已经于2013年4月24日发布，一般情况下，对于新建站点，建议使用最新稳定版作为生产版本，已有站点的升级急迫性不高。Nginx 的源代码使用 2-clause BSD-like license。 因为之前用过一段时间Apache，相对来说比较熟悉，所以还是先首选Apache吧，当然后面肯定会试试Nginx的强大之处！ 1最终我选的方案是：MAMPP（Macintosh/Apache/MySQL/PHP）+ Navicat + PHPStorm 当然或许你还有其他更好的方式也可以联系我，我们一起分享交流！ 下载完上面需要的东西，我们就可以开始码代码了……]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode Server完整教程]]></title>
    <url>%2F2016%2F04%2F11%2FXcode-Server%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[由于公司项目的需要，以及同事和测试人员的反馈，我们的打包服务器挂了，貌似之前经常挂（因为我桌旁的就是装有打包服务器的垃圾桶，在领用Mac之前，我都是用那个开发的）。其实之前我也一直想找个机会搞一下Xcode Server，记得还专门写过一篇总结，但是由于工作的原因，也由于帐号的原因就没去搞了，这一次刚好有这个机会，于是我专门放下手上所有的活，打算把这个东西弄好来……… 如果你对CI和CD已经足够了解，仅仅想知道怎么搞好Xcode Server，那么你可以直接从准备开始… 背景：之前项目使用的是Jenkins，但是由于Jenkins的各种问题，配置，后面被换到了Xcode Server（当然除了他们我还可以选择Fantlane）。自从老大走了以后Xcode Server经常挂，导致测试人员不发打包测试，从而影响整体进度。而且这一次好像是彻底挂了，根本都进不去了….. 常识：这里简单介绍一下Xcode Server和常用的持续交付与继承工具（CI&amp;CD）。 xcodebuild - 由Apple开发，主要用于Xcode的构建和测试，有时可能难以想起，但可配置程度很高。 fastlane - 实际上并不是一个工具，而是一组可用于构建、测试、上传至iTunes Connect、供应配置文件管理、屏幕截图创建、dsym上传/下载至主要崩溃报告平台的一系列工具。 xctool和其他 - “其他”是指诸如nomad tools等工具，这些工具或者被弃用，或者逐渐缺少支持，或者即将被废弃。尽管Facebook在使用某种工具，但并不意味着这个工具依然可以得到妥善的维护。 服务器方面主要的选择包括： TravisCI/CircleCI - 托管式服务器，可免费用于开源项目，可随处访问，极为强大。相比Jenkins可配置的选项较少，仅支持与Github集成。用于私有代码库的价格高昂。 Xcode Server - 能与Xcode高度集成，实际上也是唯一可用于Xcode的服务器，由Apple开发，最有可能只需要少量配置即可投入使用。 Jenkins - CI服务器领域曾经的王者，有大量插件可用，可与各种其他产品集成，需要一定的配置和维护，但是非常强大。 需求一般项目到了一定程度，或者公司和成员到了一定规模都会考虑自动化，当然也包括那些喜欢导致或者懒惰想一键打包发布的程序员。因此结合公司，项目或者个人的情况我们可以将整个过程进行拆分。 构建并签署我们的所有不同特性的应用； 将我们的应用商店首选项上传至iTunes Connect； 将IPA、dSYM，以及变更日志上传至HockeyApp； 针对发布和开发分支持续不断地运行单元测试和UI测试； 构建每次合并请求（MR）并汇报测试结果； 进行持续不断地构建和签署，以确保没有引入新的问题。 由于时间的原因，也由于目前需求的原因，我们目前只需要进行打包发布相关操作，至于，分析，测试… 看完上面之后，相信你知道我接下来要说的是什么， 准备OS X工具下载 下载 OS X Server（付费开发者免费使用） 下载 Xcode 这里就不多废话了，直接到苹果商店搜索就可以 帐号与代码仓库地址 开发者帐号（相关证书与描述文件） git源代码仓库地址 装备完了上面所需要的东西之后我们就可以开始配置和使用OS X Server了 配置Xcode打开OS X Server，根据提示点击一步一步操作即可 1 选择服务器主机：一般选自身，也可以指定IP 2 选择Xcode服务，开启服务（右上角） 老版配置页面 这里需要注意，之前的配置方案是直接有 权限和版本号：自己考虑，我这里默认设置不改了； 开发团队：使用自己的apple ID添加； 开发设备：需要用设备连接服务器后才能搜索到，初次连接，可能还需要在Status选项里面点击【Add to Teams】（比如设备不是你上面apple ID 的就需要） 查看Bot：会打开网页（Bot管理页面，默认127.0.01）,可以直接静态分析测试打包等，当然需要后面配置成功才能使用。 新版配置页面 最新版本不知道为什么没有了对应的信息，根据提示信息应该的Xcode兼容性问题（因为：点击选择Xcode，选择指定Xcode之后提示是说版本不兼容） 此时界面只有一个选择Xcode的按钮，点击进去就会直接进入到Server &amp; Bots 你会看到下面的界面 这里也可以直接在Xcode Preferences中打开， 解锁后点击OFF&amp;ON进行开启服务，然后会提示Select Integration User（选择集成用户） 这里我们一般都会新建一个用户，而不是直接使用服务器账户，然后填写对应的信息（帐号密码），这里要记住后面会有用 点击创建之后就会执行一系列操作，对Xcode进行配置 具体执行操作有 Saveing version information Enableing developer model Configuring SSL certificates Starting Redis initializing database Starting API Server Starting Apache Starting control daemon Starting Builder Upgrading Xcode Server Data Saveing version information 完成后你会看到，一个提示新用户登录的提示，为了更好的进行测试和验证，我们都会先登录用户 直接登录就可以，并且一步一步确认进入到子账户，子账户会提示： 这里先不用管，切回到服务器账户就可以，这个时候，你就可以看到刚刚创建的账户已经出现了，并且处于登录状态，我们可以点击直接切换到对应账户，或者选择和重新创建多个账户，控制超时时间。 登录账户在Xcode Preferences中选择Account，点击右下角添加账户，分别登录Apple ID，GitHub，Xcode Server Apple ID：对应开发者帐号，要和本地证书与描述文件对应 GitHub 注意:Source Control 需要打开才能使用！具体下面的各种自动自己考虑勾选； Xcode Server（如果使用Xcode 9.1最新版本，这一步已经不需要了，也就是说Xcode 9.1已经自带了Bots功能） 注意：Accounts 添加 Servers，一般默认自己主机，也可以选择指定IP地址，按服务器配置时对应选择；需要填写用户名，密码，自己搞定； 完成帐号登录以后，可以适当下载更新一下证书文件 配置Xcode Server（如果使用Xcode 9.1最新版本，这一步已经不需要了，也就是说Xcode 9.1已经自带了Bots功能）再次打开Xcode Server，进入Xcode服务页面，点击打开Xcode，会直接打开Xcode Preferences中的Server &amp; Bots并开启对应账户，这里和前面操作一样，如果没有就根据提示直接确定或者输入对应的账号信息就可以（如果没有登录帐号的话） 创建Bots 注意：自己的项目必须是个git文件夹，比如github上clone下来的项目，或者是本地服务器git来的，总之需要git文件夹；（官方文档使用Xcode的Source Control 方式搞定，具体可以看官方指南。我直接用了第三方软件SourceTree管理的） 这里由于我们是直接使用GitLab的，所以我直接从GitLab克隆了一分项目源码到本地文件夹。 打开Xcode，保证项目编译正常的情况下创建Bots（这里可以直接点击Products-&gt;Create Bots） 1 Bot命名与服务器选择，基本默认不改；2 选择项目内容，后面的master，可选其他分支，比如develop；3 Bot 操作配置Scheme：默认项目本身Actions：1分析；2单元测试（测试项目没开单元测试所有没的选）；3打包；Cleaning：可以选择，因为是自己的电脑做服务器的，所以选择了一周清理一次；Configuation：项目配置；4 环境变量？没用过，sorry；5 添加脚本，比如完成后发送个邮件通知；6 create！注意 需要一次验证 git 的用户名和密码！不是之前设置的用户名与密码。7 成功；各种信息以及完成的打包等；通过IP地址也可以实时整合并下载； 当你看到一个类型这样的界面，说明已经配置并且创建Bots完成，具体是否正确，需要进行打包验证或者根据日志进行查找具体问题 注意： 如果在使用Xcode Server对应的分析，测试功能，还需要额外进行一些配置，由于时间的问题，这里我们暂时只使用打包功能。 打包配置需要选择InHouse 打包验证输入网址或者点击Xcode Perferences中的Account，点击Xcode Server对应的地址链接，进入网址（这里是icocos.local对应ip是10.0.6.7），这里可以在当前服务器进行操作，也可以在配置Xcode的时候创建的那个帐号进行操作，同意可以在内网的其他端系统或者浏览器进行操作 然后就会有一打包的进度…… 错误总结错误问题一： 问题原因： 因为没有登录对应的Git帐号或者没有打包对应项目的workspace 错误问题二： 问题原因： 同样是因为没有登录对应的Git帐号 错误问题三： 问题原因： 同样是因为没有登录对应的Git帐号 错误问题四： 问题原因： 这里是由于创建Bots进行配置的时候，只需要打包功能就行了，那些什么分析,测试不需要,还有打包配置要选InHouse，不然打不了的 错误问题五： 问题原因： 由于升级了Xcode 9.1，和对应的Xcode Server不兼容，这里需要输入xcsd密码（也不知道是sm鬼），根据2017@swift大会的朋友经验： 备份/Library/Developer/XcodeServer，然后删除XcodeServer文件夹内容，重新前面的步骤就正常了。 错误问题六： 问题原因： 这其实不是sm错误 ，只是一个安全警告，解决方案：点击显示详细信息-&gt;继续访问网址，就可以了 错误问题七： 问题原因： 此问题困扰了很久，由于加入了GZIP库，但是…. 错误问题八： 问题原因： 此问题困扰了很久，由于加入了GZIP库，但是…. 其他问题 这些问题目前没有找到好的解决方案，根据提示查找发现，证书，前面都没有问题…… 总结一最后根据最新经验总结，最新版本Xcode 9.1配置其实非常简单了 配置Xcode Perferences中Server &amp; Bots 创建并登录帐号 Xcode Perferences登录git，app，server帐号 Clone远程Git源代码，并打开保证正常编译 Create Bots并配置 重启相关服务，Server，Bots，Xcode，开始打包 注意： 关于代码提交，不管使用Xcode还是其他方式，是没有关系的，Xcode服务指向的是master或者其他分支的服务器资源；关于打包，项目配置里就做好证书等配置文件的选择；内测的ipa包，可以结合蒲公英等平台作分发也是很方便的；考虑是不是可以搞个脚本上传。 打包过程中 通过 Xcode 中的 Integrate 查看进度我们不难发现，其实整个过程和我们手动打包的过程是一样的 打包完成 但是这样可能享受不到OS X Server那样多而且好用的服务，不过如果只是需要简单的进行打包，配合测试进行验证，简单的发布引用还是可以满足的…….. 推荐想了解更过关于Xcode Server配置与使用的，可以参考与学习下面的文章，笔者也是从下面的文章中一点一点学习的，并结合了朋友指点进行实战。 3个官方文档： 官方配置教程 苹果开发指南 OS X Server 帮助 简书教程： OS X Server 之 Xcode服务 手动打包流程 iOS App打包上架超详细流程]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Xcode Server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——重整iOS技术（Fastlane完整打包流程）]]></title>
    <url>%2F2016%2F04%2F09%2FiOS%E2%80%94%E2%80%94%E9%87%8D%E6%95%B4iOS%E6%8A%80%E6%9C%AF%EF%BC%88Fastlane%E5%AE%8C%E6%95%B4%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[自从去年中旬电脑被我整挂了之后，大部分插件和脚本配置都失效了，重新安装也试了好几次，最近上班要上线了，不得不重新整理和配置一下，还好没有遇到什么坑…… 前言 项目即将进入阶段，每次都要点击那么多，频繁的打包脑子都要晕了，习惯了之前一行命令就搞定的我，只能花一个晚上加班整回之前的Fastlane。 本文采用的方案是：Fastlane + 蒲公英 + ……。 关于具体发布状态可以在这里（app-store, package, ad-hoc, enterprise, development）改，当然后面会结合App store发布最近本文内容，同时支持jenkins或者其他持续集成系统. Fastlane安装Fastlane是一套使用Ruby写的自动化工具集，用于iOS和Android的自动化打包、发布等工作，可以节省大量的时间。 安装过程如下： 1.检查Ruby版本，需要2.0及以上版本。在终端输入以下命令确认：ruby -v 需要注意的是需要将gem的source改为https://gems.ruby-china.org/。如何检查?在终端输入以下命令: gem sources 结果应为： *** CURRENT SOURCES *** https://gems.ruby-china.org/ 2.检查Xcode命令行工具是否安装。在终端输入以下命令：xcode-select --install 如果没有安装会进行安装。如果已经安装了则会提示： xcode-select: error: command line tools are already installed, use &quot;Software Update&quot; to install updates 3.安装Fastlanesudo gem install fastlane --verbose 如果出现以下错误： ERROR: While executing gem ... (Errno::EPERM) Operation not permitted - /usr/bin/rougify 则输入以下命令： sudo gem install -n /usr/local/bin fastlane 4.检查Fastlane是否正确安装。输入以下命令：fastlane --version 可以看到Fastlane版本信息，我的是2.85.0。 蒲公英的Fastlane插件安装打开终端，进入你的项目工程的根目录，输入以下命令： fastlane add_plugin pgyer 出现 Plugin &apos;fastlane-plugin-pgyer&apos; was added to &apos;./fastlane/Pluginfile&apos; It looks like fastlane plugins are not yet set up for this project. fastlane will create a new Gemfile at path &apos;Gemfile&apos; This change is necessary for fastlane plugins to work Should fastlane modify the Gemfile at path &apos;Gemfile&apos; for you? (y/n) 输入y按回车，出现 Installing plugin dependencies... Successfully installed plugins 便是安装成功了。 Fastlane配置1.打开终端，进入你的项目工程的根目录，输入以下命令：fastlane init 中间会让你输入苹果开发者账号的账号和密码，之后会在你项目工程的目录下生成一个fastlane文件夹，里面有Fastlane的配置文件，一个是Appfile文件，一个是Fastfile文件(如果要上传AppStore的话还有Deliverfile文件)。Appfile保存苹果开发者的相关信息、项目的相关信息等。Fastfile是运行脚本。 2.编辑Fastfile文件有时候一天需要打好几个包，为了区分，我们这里实现一个递增build号的功能。 (1)修改项目工程配置 修改Build Settings中的Versioning配置，Current Project Version随便填一个，Versioning System选择Apple Generic。 修改Info.plist File路径 (2)定义一个递增build号的函数，添加到Fastfile中def updateProjectBuildNumber currentTime = Time.new.strftime(&quot;%Y%m%d&quot;) build = get_build_number() if build.include?&quot;#{currentTime}.&quot; # =&gt; 为当天版本 计算迭代版本号 lastStr = build[build.length-2..build.length-1] lastNum = lastStr.to_i lastNum = lastNum + 1 lastStr = lastNum.to_s if lastNum &lt; 10 lastStr = lastStr.insert(0,&quot;0&quot;) end build = &quot;#{currentTime}.#{lastStr}&quot; else # =&gt; 非当天版本 build 号重置 build = &quot;#{currentTime}.01&quot; end puts(&quot;*************| 更新build #{build} |*************&quot;) # =&gt; 更改项目 build 号 increment_build_number( build_number: &quot;#{build}&quot; ) end 实现自动打包的完整Fastfile如下：可以直接拷贝修改# 定义fastlane版本号 ---- 修改 fastlane_version &quot;2.85.0&quot; # 定义打包平台 default_platform :ios def updateProjectBuildNumber currentTime = Time.new.strftime(&quot;%Y%m%d&quot;) build = get_build_number() if build.include?&quot;#{currentTime}.&quot; # =&gt; 为当天版本 计算迭代版本号 lastStr = build[build.length-2..build.length-1] lastNum = lastStr.to_i lastNum = lastNum + 1 lastStr = lastNum.to_s if lastNum &lt; 10 lastStr = lastStr.insert(0,&quot;0&quot;) end build = &quot;#{currentTime}.#{lastStr}&quot; else # =&gt; 非当天版本 build 号重置 build = &quot;#{currentTime}.01&quot; end puts(&quot;*************| 更新build #{build} |*************&quot;) # =&gt; 更改项目 build 号 increment_build_number( build_number: &quot;#{build}&quot; ) end #指定项目的scheme名称 ---- 修改 scheme=&quot;Fiction_iOS&quot; #蒲公英api_key和user_key ---- 修改 api_key=&quot;264c007c340157969a5e4da77637e60f&quot; user_key=&quot;3fdffa475f545097333473b980765ce1&quot; # 任务脚本 platform :ios do lane :development_build do|options| branch = options[:branch] puts &quot;开始打development ipa&quot; updateProjectBuildNumber #更改项目build号 # 开始打包 gym( #输出的ipa名称 output_name:&quot;#{scheme}_#{get_build_number()}&quot;, # 是否清空以前的编译信息 true：是 clean:true, # 指定打包方式，Release 或者 Debug configuration:&quot;Release&quot;, # 指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, development export_method:&quot;development&quot;, # 指定输出文件夹 output_directory:&quot;./fastlane/build&quot;, ) puts &quot;开始上传蒲公英&quot; # 开始上传蒲公英 pgyer(api_key: &quot;#{api_key}&quot;, user_key: &quot;#{user_key}&quot;) end end 注意：蒲公英的 api_key 和 user_key，开发者在自己账号下的 账号设置-API信息 中可以找到。打其它类型的包的方法与development类似，可自定义一个新的lane实现。 打包发布 在终端输入 fastlane development_build 便会进行自动打包并上传蒲公英了。 下面以执行流程 下面以执行结果 再来三张：入口，选项与结果]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS——重整iOS技术（Fastlane完整打包流程）</tag>
        <tag>重整iOS技术（Fastlane完整打包流程）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——自动打包上传]]></title>
    <url>%2F2016%2F04%2F04%2FiOS%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[为了不去每次都做这些繁琐的操作，我们只能做一个懒得程序狗，也就是将整个过程进行脚本化…… 之前写过一篇关于自动打包上传代码的教程，最近又开始需要上线APP，发现新版的Mac对之前的教程不支持了，就换了一种方式，这次试用fir. http://al1020119.github.io/blog/2016/12/26/ios-daobao/ 工作中一般两种情况，1.打包Ad-Hoc给测试人员，或者内部人员测试 2.打包product发布到App Store 所以，为了不去每次都做这些繁琐的操作，我们只能做一个懒得程序狗，也就是将整个过程进行脚本化 大概的步骤是写个bash脚本，执行自动打包iOS版本，到指定的目录 （有条件的公司，可以自己搭个小服务器，这样谁都可以随时随地的打包） 将打包好的文件上传到fir.im (当然上传到自己公司的服务器或者任何地方都行，只是fir.im我一直用，觉得比较方便) 开发一个内部使用的类似APPStore，上面放着自己公司的所有APP,每次有更新的时候，测试童鞋直接通过这个自己下载新APP就可以了 主要命令编译workspacexcodebuild -workspace workspacename -scheme schemename -configuration [-configuration configurationname] clean build SYMROOT=(SYMROOT) 编译projectxcodebuild -target targetname -configuration [-configuration configurationname] clean build SYMROOT=(SYMROOT) 查看配置信息xcodebuild -list xcrun打包ipaxcrun -sdk iphoneos PackageApplication -v projectName.app -o ipaName.ipa 其他在终端输入：xcodebuild –help 或 –h查看具体的选项 显示xcodebuildversion：xcodebuild –version 显示当前系统安装的sdk：xcodebuild –showsdks 显示当前目录下project Information：xcodebuild –list xcodebuild&amp;xcrunxcodebuild-&gt;Build xcrun-&gt;Api 终端查看对应版本iCocosdeiMac:115科技 iCocos$ xcrun --version xcrun version 31. iCocosdeiMac:115科技 iCocos$ xcodebuild -version Xcode 8.2.1 Build version 8C1002 xcodebuild 是苹果提供的打包项目或者工程的命令需要在包含 name.xcodeproj 的目录下执行 xcodebuild 命令，且如果该目录下有多个 projects，那么需要使用 -project 指定需要 build 的项目。 在不指定 build 的 target 的时候，默认情况下会 build project 下的第一个 target 当 build workspace 时，需要同时指定 -workspace 和 -scheme 参数，scheme 参数控制了哪些 targets 会被 build 以及以怎样的方式 build。 有一些诸如 -list, -showBuildSettings, -showsdks 的参数可以查看项目或者工程的信息，不会对 build action 造成任何影响，放心使用。 使用xcodebuild和xcrun打包签名我这里就使用公司项目作为测试，方便查找问题和后续打包上传 1. 终端输入xcodebuild -project T 115科技.xcodeproj -target 115科技 -configuration Release xcodebuild -project T 曹理鹏(iCocos)-梦工厂.xcodeproj -target 曹理鹏(iCocos)-梦工厂 -configuration Debug 这是骚等所有走完之后就能看到对应的信息，表示build成功Signing Identity: &quot;iPhone Developer: xxx(59xxxxxx)&quot; Provisioning Profile: &quot;iOS Team Provisioning Profile: *&quot; 且在该目录下会多出一个 build 目录，该目录下有 Release-iphoneos 和 曹理鹏(iCocos)-梦工厂.build 文件，根据我们 build -configuration 配置的参数不同，Release-iphoneos 的文件名会不同。在 Release-iphoneos 文件夹下，有我们需要的曹理鹏(iCocos)-梦工厂.app文件，但是要安装到真机上，我们需要将该文件导出为ipa文件，这里使用 xcrun 命令。 xcrun -sdk iphoneos -v PackageApplication ./build/Release-iphoneos/曹理鹏(iCocos)-梦工厂.app -o ~/Desktop/曹理鹏(iCocos)-梦工厂.ipa 这个时候桌面上就会出现一个曹理鹏(iCocos)-梦工厂.ipa文件，这就是我们平时Archive之后的问题，也正是我们所需要的ipa包 但是xcodebuild期间我出现了一个这样的错误ld: library not found for -lAFNetworking clang: error: linker command failed with exit code 1 (use -v to see invocation) ** BUILD FAILED ** The following build commands failed: Ld build/曹理鹏(iCocos)-梦工厂.build/Release-iphoneos/曹理鹏(iCocos)-梦工厂.build/Objects-normal/armv7/曹理鹏(iCocos)-梦工厂 normal armv7 Ld build/曹理鹏(iCocos)-梦工厂.build/Release-iphoneos/曹理鹏(iCocos)-梦工厂.build/Objects-normal/arm64/曹理鹏(iCocos)-梦工厂 normal arm64 (2 failures) 貌似是linker command failed with exit code 1经典错误，但是然并卵，于是看了一下pingpong从零开始写个自动打包IPA脚本中的build方式，也有类似的问题。多谢pingpong帮我解决了这个问题。iCocosdeiMac ios (develop) $ xcodebuild 2016-05-02 13:05:04.623 xcodebuild[1015:16272] [MT] PluginLoading: Required plug-in compatibility UUID ACA8656B-FEA8-4B6D-8E4A-93F4C95C362C for plug-in at path &apos;~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/XcodeColors.xcplugin&apos; not present in DVTPlugInCompatibilityUUIDs 2016-05-02 13:05:04.625 xcodebuild[1015:16272] [MT] PluginLoading: Required plug-in compatibility UUID ACA8656B-FEA8-4B6D-8E4A-93F4C95C362C for plug-in at path &apos;~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/OMColorSense.xcplugin&apos; not present in DVTPlugInCompatibilityUUIDs === BUILD TARGET xxx OF PROJECT xxx WITH THE DEFAULT CONFIGURATION (Release) === Check dependencies Write auxiliary files write-file /Users/iCocos/Documents/code/xxx/ios/build/xxx.build/Release-iphoneos/xxx.build/xxx.hmap write-file /Users/iCocos/Documents/code/xxx/ios/build/xxx.build/Release-iphoneos/xxx.build/xxx-own-target-headers.hmap write-file /Users/iCocos/Documents/code/xxx/ios/build/xxx.build/Release-iphoneos/xxx.build/Script-492B764475E022A63FB67F55.sh 解决方案是：执行xcodebuild需要指定你所需要对应的workspace和schemexcodebuild -workspace /Users/iCocos/Desktop/MBA/最新Git源代码/曹理鹏(iCocos)-梦工厂/曹理鹏(iCocos)-梦工厂.xcworkspace -scheme 曹理鹏(iCocos)-梦工厂 执行前，先查看下-list,这个可以知道xcodebuild命令下对应的参数需要填写的内容iCocosdeiMac ios (develop) $ xcodebuild -list 2016-05-02 15:24:26.656 xcodebuild[16535:154176] [MT] PluginLoading: Required plug-in compatibility UUID ACA8656B-FEA8-4B6D-8E4A-93F4C95C362C for plug-in at path &apos;~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/XcodeColors.xcplugin&apos; not present in DVTPlugInCompatibilityUUIDs 2016-05-02 15:24:26.661 xcodebuild[16535:154176] [MT] PluginLoading: Required plug-in compatibility UUID ACA8656B-FEA8-4B6D-8E4A-93F4C95C362C for plug-in at path &apos;~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/OMColorSense.xcplugin&apos; not present in DVTPlugInCompatibilityUUIDs Information about project &quot;xxx&quot;: Targets: xxx xxxTests Build Configurations: Debug Release If no build configuration is specified and -scheme is not passed then &quot;Release&quot; is used. Schemes: xxx 然后，成功了,如下：Entitlements: { &quot;application-identifier&quot; = &quot;L64TE3S9T9.com.曹理鹏(iCocos)-梦工厂.shaoshang&quot;; &quot;aps-environment&quot; = development; &quot;com.apple.developer.pass-type-identifiers&quot; = ( &quot;L64TE3S9T9.*&quot; ); &quot;com.apple.developer.team-identifier&quot; = L64TE3S9T9; &quot;get-task-allow&quot; = 1; } builtin-productPackagingUtility -entitlements -format xml -o /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Intermediates/曹理鹏(iCocos)-梦工厂.build/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.build/曹理鹏(iCocos)-梦工厂.app.xcent CodeSign /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Products/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.app cd /Users/iCocos/Desktop/MBA/最新Git源代码/曹理鹏(iCocos)-梦工厂 export CODESIGN_ALLOCATE=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/codesign_allocate export PATH=&quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/Users/iCocos/.rvm/gems/ruby-2.3.0/bin:/Users/iCocos/.rvm/gems/ruby-2.3.0@global/bin:/Users/iCocos/.rvm/rubies/ruby-2.3.0/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/iCocos/.rvm/bin:/usr/local/mysql/bin/mysql&quot; Signing Identity: &quot;iPhone Developer: Songbai He (73N6HPPJDP)&quot; Provisioning Profile: &quot;iOS Team Provisioning Profile: com.曹理鹏(iCocos)-梦工厂.shaoshang&quot; (34c1d23b-ade5-4d0f-9329-7b16009b30c2) /usr/bin/codesign --force --sign F8BAED0C84DB84AAA84769FED9FEAA9E80825C29 --entitlements /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Intermediates/曹理鹏(iCocos)-梦工厂.build/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.build/曹理鹏(iCocos)-梦工厂.app.xcent --timestamp=none /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Products/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.app Validate /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Products/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.app cd /Users/iCocos/Desktop/MBA/最新Git源代码/曹理鹏(iCocos)-梦工厂 export PATH=&quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/Users/iCocos/.rvm/gems/ruby-2.3.0/bin:/Users/iCocos/.rvm/gems/ruby-2.3.0@global/bin:/Users/iCocos/.rvm/rubies/ruby-2.3.0/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/iCocos/.rvm/bin:/usr/local/mysql/bin/mysql&quot; export PRODUCT_TYPE=com.apple.product-type.application builtin-validationUtility /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Products/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.app ** BUILD SUCCEEDED ** 下面就是验证你全栈的时候到了，其实也没有那么难，就是一点脚本而已先git 指令，pull到最新的分支# git update git checkout $BRANCHNAME if [ $? -ne 0 ]; then exit 1 fi git pull #pod update --verbose --no-repo-update if [ $? -ne 0 ]; then exit 1 fi 成功之后你同意会看到提示信息logout Saving session... ...copying shared history... ...saving history...truncating history files... ...completed. Deleting expired sessions...118 completed. xcodebuild进行编译xcodebuild \ -workspace $SORCEPATH/曹理鹏(iCocos)-梦工厂.xcworkspace \ -scheme $SCHEMENAMEPLQ \ -configuration Debug \ CODE_SIGN_IDENTITY=&quot;iPhone Developer: Songbai He(73N6HPPJDP)” \ PROVISIONING_PROFILE=&quot;com.曹理鹏(iCocos)-梦工厂.shaoshang&quot; \ clean \ build \ -derivedDataPath $IPAPATH/$BRANCHNAME/$DATE 测试与发布只需要更改对应的参数即可-configuration Debug -configuration Release 用xcrun打包成ipa包xcrun -sdk iphoneos PackageApplication \ -v $IPAPATH/Build/Products/Debug-iphoneos/$SCHEMENAME.app \ -o $IPAPATH/$IPANAME 生成ipa包，上传到fir.im一：1.注册fir.拿到tokenfir.im官网：https://fir.im 注册号账号，点击右上角个人信息，进入API token 拿到token，并保存 二：安装fir-clifir-cli 使用 Ruby 构建, 无需编译, 只要安装相应 gem 即可. $ ruby -v # &gt; 1.9.3 $ gem install fir-cli 三：Mac新版之后可能由于源的问题导致无法安装（由于10.11引入了 rootless, 无法直接安装 fir-cli）一般都是这么安装的：使用 Homebrew 及 RVM 安装 Ruby, 再安装 fir-cli Install Homebrew: $ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; Install RVM: $ \curl -sSL https://get.rvm.io | bash -s stable --ruby Install fir-cli: $ gem install fir-cli 四：在终端登录并查看信息 $ fir login 按照提示输入token,然后 iCocosdeiMac:曹理鹏(iCocos)-梦工厂 iCocos$ fir login Please enter your fir.im API Token: 849ad212b94683b4c3087248d422d124 I, [2017-04-18T13:58:01.184043 #14531] INFO -- : Login succeed, previous user&apos;s email: al10201119@163.com I, [2017-04-18T13:58:01.185131 #14531] INFO -- : Login succeed, current user&apos;s email: al10201119@163.com I, [2017-04-18T13:58:01.185223 #14531] INFO -- : $fir me 登录成功,就会显示用户信息 I, [2017-04-18T13:58:21.876164 #14545] INFO – : Login succeed, current user’s email: al10201119@163.com I, [2017-04-18T13:58:21.876246 #14545] INFO – : Login succeed, current user’s name: al10201119 I, [2017-04-18T13:58:21.876261 #14545] INFO – : 使用fir指令，上传我们的ipa包 fir login -T c525718a775b954882xxxxxxxx # fir.im token fir publish $IPAPATH/Develop/xxx.ipa 最后你会看到 恭喜！！！上传fir.im成功！ 也可以直接使用执行脚本#author iCocos #注意：脚本目录和xxxx.xcodeproj要在同一个目录，如果放到其他目录，请自行修改脚本。 #工程名字(Target名字) Project_Name=&quot;Target名字，系统默认和工程名字一样&quot; #配置环境，Release或者Debug Configuration=&quot;Release&quot; #AdHoc版本的Bundle ID AdHocBundleID=&quot;com.xxx&quot; #AppStore版本的Bundle ID AppStoreBundleID=&quot;com.xxx&quot; #enterprise的Bundle ID EnterpriseBundleID=&quot;com.xxx&quot; # ADHOC #证书名#描述文件 ADHOCCODE_SIGN_IDENTITY=&quot;iPhone Distribution: xxxx&quot; ADHOCPROVISIONING_PROFILE_NAME=&quot;xxxx-xxxx-xxxx-xxxx&quot; #AppStore证书名#描述文件 APPSTORECODE_SIGN_IDENTITY=&quot;iPhone Distribution: xxxx&quot; APPSTOREROVISIONING_PROFILE_NAME=&quot;xxxx-xxxx-xxxx-xxxx&quot; #企业(enterprise)证书名#描述文件 ENTERPRISECODE_SIGN_IDENTITY=&quot;iPhone Distribution: xxxxx&quot; ENTERPRISEROVISIONING_PROFILE_NAME=&quot;xxxx-xxxx-xxxx-xxxx&quot; #加载各个版本的plist文件 ADHOCExportOptionsPlist=./ADHOCExportOptionsPlist.plist AppStoreExportOptionsPlist=./AppStoreExportOptionsPlist.plist EnterpriseExportOptionsPlist=./EnterpriseExportOptionsPlist.plist ADHOCExportOptionsPlist=${ADHOCExportOptionsPlist} AppStoreExportOptionsPlist=${AppStoreExportOptionsPlist} EnterpriseExportOptionsPlist=${EnterpriseExportOptionsPlist} echo &quot;~~~~~~~~~~~~选择打包方式(输入序号)~~~~~~~~~~~~~~~&quot; echo &quot; 1 appstore&quot; echo &quot; 2 adhoc&quot; echo &quot; 3 enterprise&quot; # 读取用户输入并存到变量里 read parameter sleep 0.5 method=&quot;$parameter&quot; # 判读用户是否有输入 if [ -n &quot;$method&quot; ] then #clean下 xcodebuild clean -xcodeproj ./$Project_Name/$Project_Name.xcodeproj -configuration $Configuration -alltargets if [ &quot;$method&quot; = &quot;1&quot; ] then #appstore脚本 xcodebuild -project $Project_Name.xcodeproj -scheme $Project_Name -configuration $Configuration -archivePath build/$Project_Name-appstore.xcarchive clean archive build CODE_SIGN_IDENTITY=&quot;${APPSTORECODE_SIGN_IDENTITY}&quot; PROVISIONING_PROFILE=&quot;${APPSTOREROVISIONING_PROFILE_NAME}&quot; PRODUCT_BUNDLE_IDENTIFIER=&quot;${AppStoreBundleID}&quot; xcodebuild -exportArchive -archivePath build/$Project_Name-appstore.xcarchive -exportOptionsPlist $AppStoreExportOptionsPlist -exportPath ~/Desktop/$Project_Name-appstore.ipa elif [ &quot;$method&quot; = &quot;2&quot; ] then #adhoc脚本 xcodebuild -project $Project_Name.xcodeproj -scheme $Project_Name -configuration $Configuration -archivePath build/$Project_Name-adhoc.xcarchive clean archive build CODE_SIGN_IDENTITY=&quot;${ADHOCCODE_SIGN_IDENTITY}&quot; PROVISIONING_PROFILE=&quot;${ADHOCPROVISIONING_PROFILE_NAME}&quot; PRODUCT_BUNDLE_IDENTIFIER=&quot;${AdHocBundleID}&quot; xcodebuild -exportArchive -archivePath build/$Project_Name-adhoc.xcarchive -exportOptionsPlist $ADHOCExportOptionsPlist -exportPath ~/Desktop/$Project_Name-adhoc.ipa elif [ &quot;$method&quot; = &quot;3&quot; ] then #企业打包脚本 xcodebuild -project $Project_Name.xcodeproj -scheme $Project_Name -configuration $Configuration -archivePath build/$Project_Name-enterprise.xcarchive clean archive build CODE_SIGN_IDENTITY=&quot;${ENTERPRISECODE_SIGN_IDENTITY}&quot; PROVISIONING_PROFILE=&quot;${ENTERPRISEROVISIONING_PROFILE_NAME}&quot; PRODUCT_BUNDLE_IDENTIFIER=&quot;${EnterpriseBundleID}&quot; xcodebuild -exportArchive -archivePath build/$Project_Name-enterprise.xcarchive -exportOptionsPlist $EnterpriseExportOptionsPlist -exportPath ~/Desktop/$Project_Name-enterprise.ipa else echo &quot;参数无效....&quot; exit 1 fi fi 这里还有一个大神使用PHP干了一票，虽然还在学习PHP中，但是有机会也要试一下 这里目前只是实现了Ad-Hoc打包上传，关于App Store其实也就是更改参数，和对应的地址，后续会退出相应的文章界面具体实战……]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS——自动打包上传</tag>
        <tag>自动打包上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带你简单理解block和__block的实现？]]></title>
    <url>%2F2016%2F03%2F25%2F%E5%B8%A6%E4%BD%A0%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3block%E5%92%8C-block%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[其实类似block和__block的实现网上随便一搜就能找到无数篇，有些分析的确实非常不错，但是或许有些人刚好就没有那个耐心去看完，有些人就算最后看完也没有理解，甚至还是没能理解其中的核心,所以这里我就根据个人的理解和网上资料的整理，简单的总结一下…… block1.Block其实是闭包 2.Block是基于C语言的拓展 3.Block是基于指针和函数指针实现的， 4.同时他也是一种匿名函数，而且你会发现他和函数其实有很多相似的地方 5.通过打印我们可以知道他其实是一种的结构体 block的实现Block是被设为_NSConcreteStackBlock，在栈上生成。当我们把Block作为全局变量使用时，对应生成的Block将被设为_NSConcreteGlobalBlock Block属性这里还有一点关于block类型的ARC属性。上文也说明了，ARC会自动帮strong类型且捕获外部变量的block进行copy，所以在定义block类型的属性时也可以使用strong，不一定使用copy。也就是以下代码： /** 假如有栈block赋给以下两个属性 **/ // 这里因为ARC，当栈block中会捕获外部变量时，这个block会被copy进堆中 // 如果没有捕获外部变量，这个block会变为全局类型 // 不管怎么样，它都脱离了栈生命周期的约束 @property (strong, nonatomic) Block *strongBlock; // 这里都会被copy进堆中 @property (copy, nonatomic) Block *copyBlock; __blockBlock不允许修改外部变量的值，这里所说的外部变量的值，指的是栈中指针的内存地址。__block 所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。 总结就是：__block对象在block中是可以被修改、重新赋值的。 __block的实现__block其实是堆栈的拷贝， 首先block修饰的变量会变成block_bref_val_0的结构体，它包含实例变量本身__forwarding(用于访问局部变量val)。 block拷贝到堆上的时候： _val_0也会拷贝到堆上，局部变量销毁，block任然能对堆上的局部变量操作 __forwarding替换为堆上的__block变量的地址 栈上的_val_0结构体中的__forwarding指针也会指向堆上的结构体 main函数或者blcok释放的时候，只是释放了栈上的东西，所有对局部变量的操作都已经移到了对上。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带你简单理解weak和__weak的实现？]]></title>
    <url>%2F2016%2F03%2F21%2F%E5%B8%A6%E4%BD%A0%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3weak%E5%92%8C-weak%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[其实类似weak和__weak的实现网上随便一搜就能找到无数篇，有些分析的确实非常不错，但是或许有些人刚好就没有那个耐心去看完，有些人就算最后看完也没有理解，甚至还是没能理解其中的核心,所以这里我就根据个人的理解和网上资料的整理，简单的总结一下…… weak字面含义就是弱引用,Objective-C中默认都是强引用的（strong） weak的实现Runtime维护了一个weak表，用于存储指向某个对象的所有weak指针。weak表其实是一个hash（哈希）表，Key是所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象的地址）数组。 weak 的实现原理可以概括一下三步：1、初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。 2、添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。 3、释放时，调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。 __weak__weak修饰符的对象，作用等同于定义为weak的property。他并不会导致循环引用问题（通过苹果文档我们可以得出这样的结论），当原对象没有任何强引用的时候，弱引用指针也会被设置为nil。 __weak的实现简单来说，系统有一个全局的 CFMutableDictionary 实例，来保存每个对象的 weak 指针列表，因为每个对象可能有多个 weak 指针，所以这个实例的值是 CFMutableSet（Array） 类型。 剩下我们要做的，就是在引用计数变成 0 的时候，去这个全局的字典里面，找到所有的 weak 指针，将其值设置成 nil。如何做到这一点呢？Friday QA 上介绍了一种类似 KVO 实现的方式。当对象存在 weak 指针时，我们可以将这个实例指向一个新创建的子类，然后修改这个子类的 release 方法，在 release 方法中，去从全局的 CFMutableDictionary 字典中找到所有的 weak 对象，并且设置成 nil。我摘抄了 Friday QA 上的实现的核心代码，如下： Class subclass = objc_allocateClassPair(class, newNameC, 0); Method release = class_getInstanceMethod(class, @selector(release)); Method dealloc = class_getInstanceMethod(class, @selector(dealloc)); class_addMethod(subclass, @selector(release), (IMP)CustomSubclassRelease, method_getTypeEncoding(release)); class_addMethod(subclass, @selector(dealloc), (IMP)CustomSubclassDealloc, method_getTypeEncoding(dealloc)); objc_registerClassPair(subclass); 总结一句就是：一个通俗的解释就是，在Objective-C的运行时环境中，维护了一种weak表，这张哈希表用对象的首地址作为键，将由若干个weak修饰的指针自身的地址组成的数组作为值。当一个Objective-C对象被释放后，通过这个对象的起始地址来找到所有指向它的weak指针，并将它们指向nil。 __weak的作用在Objective-C中，用__weak修饰的指针，会在所指向的那个Objective-C对象被释放后，自动指向nil。 使用__weak来修饰指针，相比于__unsafe_unretained，可以帮助程序员减小访问野指针的风险，方便了程序员对内存的管理。 block和weak的区别前面提到了block，也大概说了一下其简单实现，所以这里总结一下block和__weak修饰符的区别： 1.__block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型。 2.__weak只能在ARC模式下使用，也只能修饰对象（NSString），不能修饰基本数据类型（int）。 3.__block对象可以在block中被重新赋值，__weak不可以。 4.__block对象在ARC下可能会导致循环引用，非ARC下会避免循环引用，__weak只在ARC下使用，可以避免循环引用。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>带你简单理解weak和__weak的实现？</tag>
        <tag>底层分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分类能添加属性吗？成员变量呢？为什么？]]></title>
    <url>%2F2016%2F03%2F18%2F%E5%88%86%E7%B1%BB%E8%83%BD%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E5%90%97%EF%BC%9F%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%91%A2%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[在iOS开发中，如果你要在不改变原来的类内容的基础上，为类增加一些方法，那么苹果提供了一个很好机制，那就是分类，当然我们平时可能比较多的是直接给他添加方法，并且我们清楚一点的是，我们还能给一个分类添加属性（使用关联对象），但是并不能添加成员变量，可是为什么刚好成员变量就不能连接呢…… 分类概念： Category 分类是OC特有的语言，依赖于类。 分类的作用： 在不改变原来的类内容的基础上，为类增加一些方法。 分类增加属性和方法属性方法 这里其实就不用做过多介绍了，只需要知道分类增加方法其实就和一个类增加一个方法一样。 属性 至于分类增加属性，只要使用到的就是Objective-C里面比较底层的一个技术Runtime，Runtime里面有个里面有个关联对象的概念，具体请查看官方或者相关资料，很简单。 成员变量NO，NO，NO，分类是不能增加属性的，一定没办法，如果你有可以来找我，哈哈…. 为什么不能增加成员变量呢？首先我们不能混淆了成员变量和属性的概念.Property是Property，Ivar是Ivar。 分类里面不能添加Ivar是因为分类本身并不是一个真正的类（Objective-C中真正的类是有一个isa存在的），但是分类并没有自己的ISA . 类最开始生成了很多基本属性，比如IvarList，MethodList，分类只会将自己的method attach到主类，并不会影响到主类的IvarList。 这就是为什么分类里面不能增加成员变量的原因” 类和分类的初始化1.当程序启动时，就会加载项目中所有的类和分类，而且加载后会调用每个类和分类的+load方法，只会调用一次； 2.当第一次使用某个类时，就会调用当前类的+initialize方法； 3.先加载父类，再加载子类（先调用父类的+load方法，再调用子类的+load方法，最后调用分类的+load方法），先初始化父类，再初始化子类（先调用父类的+initialize方法，再调用子类的+initialize方法）。 4.注意：在初始化的时候，如果在分类中重写了+initialize方法，则会覆盖掉父类的。 5.重写+initialize方法可以监听类的使用情况。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么调用nil的任何方法都不会崩溃？]]></title>
    <url>%2F2016%2F03%2F15%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B0%83%E7%94%A8nil%E7%9A%84%E4%BB%BB%E4%BD%95%E6%96%B9%E6%B3%95%E9%83%BD%E4%B8%8D%E4%BC%9A%E5%B4%A9%E6%BA%83%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[我们知道，在Objective-C消息和转发机制的背后有这样一个说法：调用没有实现或者不存在的方法，会导致App崩溃，但是如果你比较细心或者专门研究过消息和转发机制那么你应该听过这样的结论： Objective-C中调用nil的任何方法都不会崩溃，但是，为什么就不会崩溃呢？这里就简单分析一下具体的原因和底层的实现方式…… 访问了一个已经被释放的对象我们知道在不使用 ARC 的时候，内存要自己管理，这时重复或过早释放都有可能导致 Crash。 NSObject * aObj = [[NSObject alloc] init]; [aObj release]; NSLog(@&quot;%@&quot;, aObj); 原因aObj 这个对象已经被释放，但是指针没有置空，这时访问这个指针指向的内存就会 Crash。 解决办法使用前要判断非空，释放后要置空。正确的释放应该是: [aObj release]; aObj = nil; 由于ObjC的特性，调用 nil 指针的任何方法相当于无作用，所以即使有人在使用这个指针时没有判断至少还不会挂掉。 那么这里就有一个问题？为什么调用nil的任何方法都不会崩溃呢？ 首先在Objective-C里，nil对象被设计来跟NULL空指针关联的。他们的区别就是nil是一个对象，而NULL只是一个值。而且我们对于nil调用方法，不会产生crash或者抛出异常。这个技术被framework通过多种不同的方式使用。 最主要的就是我们现在在调用方法之前根本无须去检查这个对象是否是nil。假如我们调了nil对象的一个有返回值的方法，那么我们会得到一个nil返回值。 我们先来看看这断代码： - (void) dealloc { self.caption = nil; self.photographer = nil; [super dealloc]; } 具体原因 之所以可以这么做是因为我们给把nil对象设给了一个成员变量，setter就会retain nil对象(当然了这个时候nil对象啥事情也不会做)然后release旧的对象。这个方式来释放对象其实更好，因为这样做的话，成员变量连指向随机数据的机会都没有，而通过别的方式，出现指向随机数据的情形机会不可避免。 注意到我们调用的self.VAR这样的语法，这表示我们正在用setter，而且不会引起任何内存问题。假如我们直接去设值的话，就会有内存溢出： // incorrect. causes a memory leak. // use self.caption to Go through setter caption = nil; 这里进入提到了崩溃，那么就大概整理一下开发中常见的崩溃问题和类型，方便提前预防和部分相关处理一、访问了一个已经被释放的对象：nil，autorelease 二、访问数组类对象越界或插入了空对象：分类或者runtime替换 三、访问了不存在的方法：判断是否有，runtime修改 四、字节对齐：使用 memcpy 来作内存拷贝，而不是直接对指针赋值 五、堆栈溢出（过多的递归会导致栈溢出，过多的 alloc 变量会导致堆溢出。） 六、多线程并发操作：加锁 ，原子，Operation Objects, GCD, Idle-time notifications, Asynchronous functions, Timers, Separate processes。 七、Repeating NSTimer：写了个宏用来释放Timer]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生命之源-RunLoop]]></title>
    <url>%2F2016%2F03%2F09%2F%E7%94%9F%E5%91%BD%E4%B9%8B%E6%BA%90-RunLoop%2F</url>
    <content type="text"><![CDATA[iOS一切的生命之源都需要RunLoop的支持，关于RunLoop的界面和相关知识，网上想你一一搜一天也看不完，所以这里只为总结Runloop相关技术，适用于底层，面试，简单实战了解！ 前言：1+ 一个线程只能执行一个任务，任务执行完之后，线程就会退出，但是主线程不会退出，因为我们需要让主线程等待接收事件 介绍123456+ 运行循环（do-while）：不断处理各种事件+ 一个线程（唯一）对应一个RunLoop（可以嵌套子runloops），主线程默认启动，子线程手动启动（run）：获取RunLoop对象的时候，就会创建RunLoop+ RunLoop有多个Model，Model有多个timer（array）/source（set）/observer（array）。+ 每次启动只能启动一个，切换需要先推出在指定（分隔不同time/source/observer）+ 当前Model没有任何timer/source/observer就会推出（mode只能添加不能删除）+ 第一次获取创建，线程结束销毁 runloop退出的条件：1app退出；线程关闭；设置最大时间到期；modeItem为空； Ref12345+ CFRunLoopTimerRef，基于时间触发（NSTimer），受Model影响，GCD不受Model影响+ CFRunLoopSourceRef，事件源，source0（非Port），source1（Port），跟Port密切联系source0：event事件，只含有回调，需要标记待处理（signal），然后手动将runloop唤醒（wakeup）；source1 ：包含一个 mach_port 和一个回调，被用于通过内核和其他线程发送的消息，能主动唤醒runloop。 Runloop本质：mach port和mach_msg()。123Mach是XNU的内核，进程、线程和虚拟内存等对象通过端口发消息进行通信，Runloop通过mach_msg()函数发送消息，如果没有port 消息，内核会将线程置于等待状态 mach_msg_trap() 。如果有消息，判断消息类型处理事件，并通过modeItem的callback回调(处理事件的具体执行是在DoBlock里还是在回调里目前我还不太明白？？？)。Runloop有两个关键判断点，一个是通过msg决定Runloop是否等待，一个是通过判断退出条件来决定Runloop是否循环 定时源，输入源12+ 定时源，同步消息，特定或者一定时间间隔发生+ 输入源，来自起来线程或者程序 应用1+ NSTimer，ImageView显示，PerformSelector，常驻线程，自动释放池，界面刷新，手势识别，GCD任务，timer：（与CADisplayLink），网络请求： autorrelease释放时机：12+ 手动干预释放：指定autorreleasepool,当前作用域大括号结束立即释放+ 系统自动释放：不指定，aut对象在当前RunLoop迭代结束释放 自动释放池12自动释放池寄生于Runloop：程序启动后，主线程注册了两个Observer监听runloop的进出与睡觉。一个最高优先级OB监测Entry状态；一个最低优先级OB监听BeforeWaiting状态和Exit状态。线程(创建)--&gt;runloop将进入--&gt;最高优先级OB创建释放池--&gt;runloop将睡--&gt;最低优先级OB销毁旧池创建新池--&gt;runloop将退出--&gt;最低优先级OB销毁新池--&gt;线程(销毁) Timer注意121、如果是在主线程中运行timer，想要timer在某界面有视图滚动时，依然能正常运转，那么将timer添加到RunLoop中时，就需要设置mode 为NSRunLoopCommonModes。2、如果是在子线程中运行timer,那么将timer添加到RunLoop中后，Mode设置为NSDefaultRunLoopMode或NSRunLoopCommonModes均可，但是需要保证RunLoop在运行，且其中有任务。 runloop:121、（要让马儿跑）通过do-while死循环让程序持续运行：接收用户输入，调度处理事件时间。2、（要让马儿少吃草）通过mach_msg()让runloop没事时进入trap状态，节省CPU资源。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>生命之源-RunLoop</tag>
        <tag>RunLoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前世-内存管理]]></title>
    <url>%2F2016%2F03%2F03%2F%E5%89%8D%E4%B8%96-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[最近越来越发觉，自己做了这么久iOS开发，似乎都是在瞎玩，回望这一路写的App，写的代码，以及上线的App，又有几个自己真的非常满意的？ 说道这里，不得不提的是：我相信不止我一个人有这种感触，代码写久了，自己都不知道自己在写撒，就连上线都是个意外。 这一路走来我一直在总结，也在回望，到底自己哪里出了问题，终于发现：终究是自己不敢面对而已，底层不了解，只知道敲。 因为换了电脑，换了工作，换了新的环境，也换了一个不一样的心情重新开始探索之路，所以之前的博客地址也停止更新了，如果你对iOS相关知识感兴趣或者有什么疑问和建议可以联系我，或者直接在下面评论， 本来打算这个博客中不会再写iOS的东西，但是最近一直上班，也找了一段时间公司，总之感触不少，现在这个行情，大家都懂的。 前段时间也整理了一些东西，我相信值得一看。 1原则：没有强指针指向对象，对象就会被释放。 MRC-ARC123ARC：LLVM3.0（iOS5，Xcode4）前段编译器：方法内创建对象，末尾自动插入release销毁。类拥有对象，在dealloc内释放。更底层的C语言实现。objc_release,objc_retain优化调用过程ARC优化器：负责移除多余的插入，和一些引用的优化。包括运行期组件。 关于循环12345weak：循环引用，自身强引用，IBOutlet。非拥有，不保留也不释放，置nil，weak必须用于OC对象，assign非OC对象for循环：只有当自动释放器被release，池中的表示autorrelease对象才会被释放===内存耗尽，没有释放-&gt;内存泄露1.i比较大：使用@autorreleasepool&#123;&#125;，在for外面，循环结束，销毁创建对象，解决占据栈内存问题。2.i玩命大：一次循环都会自动释放池满，@autorreleasepool&#123;&#125;放在for里面，每次循环前将上一次对象release。 关于内存12内存布局：没有多继承，所以布局简单最前面isa，指向类。父类实例变量在子类实例变量之前。 关于线程123456789界面线程维护自己的线程池。自己创建的线程数据，需要创建线程的内存池。autorreleasepool实现：objc_autorreleasepool=Push,Pop,objc_autorrelease每次RunLoop完成一个循环的时候，都会检测对象的retainCount，为0则没有使用，释放。内存管理的范围：集成自NSObject对象，基本数据类型无效。因为存储空间不同，基本数据存在栈区。对象在堆中，代码块结束，涉及局部变量弹栈清空，指向对象指针回收，对象没有指针指向，但是还在堆中，所以内存泄露了。unowned（unsafe_unretained）：对象销毁不会为空，但是更快，因为weak需要unwrap。 常见状态管理1234567野指针:指针变量没有初始化，指向的空间被释放。调用方法报异常，崩溃。release后，地址nil，OC中没有空指针异常内存泄露：对象提前赋值nil，导致release不起作用。没有配对释放或者清空。栈区释放了，堆区没有释放。最终导致内存溢出内存溢出：容量超出使用限制僵尸对象：堆中已经被释放的对象count=0空指针：指针赋值为nil判断对象销毁：dealloc（需要super一下），已经释放的对象无法复活 对象关系123集成：组合：（包含关系），确保成员连边不被提前释放，重写set方法，retain一下。成员变量在dealloc中配对释放。内存泄露：1.set没有retain对象，2.没有release旧对象，3.没有判断set方法传入是否是同一对象依赖：（对象作为方法参数传递） autorrelease（pool）/垃圾回收机制1234autorrelease：把该对象放入自动释放池，自动释放池释放时，内部对象引用计数-1。NSAutorreleasePool：通过接受对象向他发送的release消息，记录该对象的release消息，自动释放池销毁时，向池中记录release的对象发送release消息。 垃圾回收机制：autorrelease只是延迟释放，GC是每隔一段时间询问程序，是否有无指针指向的对象，没有就释放 自动释放池123456自动释放池： 1.存储多想对象类型的指针变量（可以嵌套） 2.作用：将对象与自动释放池建议关系，池子内调用autorrelease，在自动释放池销毁时销毁对象，延迟release销毁时间 3.对池内对象作用：存入池中的对象，池销毁，全部对象release一次 4.调用autorrelease将对象加入自动释放池，多次调用导致野指针异常 5.释放时机：简单：autorrelease的&#125;执行完后。实际：Autorrelease对象是在当前RunLoop迭代结束时释放，原因是：系统在每个RunLoop迭代中加入了自动释放池Push，Pop 关键字12345block中多次使用weakSelf（延迟操作，导致取不到弱指针），可以block种先使用strongSelf，防止执行是weakSelf意外释放，对于非ARCweak改为block就可以release和drain：ARC中一样，GC中release无效操作，所以无论是否为GC使用drain没有问题。copy：OC对象类型如果有mutable，深拷贝，新对象为count=1，没有为浅拷贝，count+1. 其他总结1234567891011通过Observer监听RunLoop状态，一旦监听到RunLoop即将进入休眠等状态，就释放自动释放池。FIFO：新访问的数据插入队列尾部，数据在队列中移动，淘汰头部数据。LRU（FIFO相反），LFU循环引用：定时器（timer作为类的成员变量，self-target,不使用记得invalidate），Blcok（block在copy时对内部对象强引用（ARC）或者引用计数+1（MRC）），代理：（assign（MRC），weak（ARC））通知：多对多，主要跨层传值。对象加入到通知中心后，对象被销毁前没有将对象从通知中心移除，当再次发送通知的时候，会崩溃。默认关键字：基本数据类型（atomic，readwrite，assign），OC对象类型（atomic，readwrite，strong）TableView代理用assign：控制器对内部的View进行了一次retain，TableView对代理控制器也retain一次就会循环引用。 其实知道了这个并不证明就能写出好的代码，还需要时间的沉淀，不断的尝试，不断的思考与总结。感谢你能看到最后，希望对你有用，我们下次再见！]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[温馨提示]]></title>
    <url>%2F2016%2F03%2F01%2F%E6%B8%A9%E9%A6%A8%E6%8F%90%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[嗨，欢迎来到梦工厂，我是曹理鹏 (@iCocos)，一名 PHP开发工程师，前iOS(+游戏)/ 前端 开发者，希望做点有意义的事情。现居广州，正在修行，探求创意之源。。 1234微信：clpaial10201119 / QQ：2211523682博客(前后端)：https://icocos.github.io/github：https://github.com/al1020119个人网站：http://www.icocos.cn/ 由于学习，技术方向的原因，本人之前github博客将会停止更新，之前所有文章偏向技术，并且主要针对iOS基础，底层，面试与实战，此后将会停止更新此博客，并将所有新发布文章，更新至当前博客地址，届时会不定时在公众号，和微博发布相关动态。 此博客将会保函以下内容： iOS实战经验(+游戏) 前端开发相关技术 后端开发实战/架构/优化 读书笔记与后感 个人业余爱好 其他原创杂文 如果你想了解更多关于作者，或者关于PHP后端开发，iOS/前后端，和个人关注内容，请关注我的个人公众号，也可以通过微信，QQ，Github联系我，也可以直接在这里评论留言。 同时，如果对我的文章有一些意见或者建议，也欢迎联系我，我们一起共进退！]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>温馨提示</tag>
        <tag>iCocos</tag>
        <tag>提示</tag>
      </tags>
  </entry>
</search>
