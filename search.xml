<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>架构篇——MySQL高可用集群(PXC)详解</title>
      <link href="/2019/06/11/%E6%9E%B6%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4-PXC-%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/06/11/%E6%9E%B6%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4-PXC-%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h5 id="在介绍PXC之前，先来看一个相关的技术：MyCat"><a href="#在介绍PXC之前，先来看一个相关的技术：MyCat" class="headerlink" title="在介绍PXC之前，先来看一个相关的技术：MyCat"></a>在介绍PXC之前，先来看一个相关的技术：MyCat</h5><h3 id="MyCat简介"><a href="#MyCat简介" class="headerlink" title="MyCat简介"></a>MyCat简介</h3><p>MyCat是阿里开源的分布式数据库分库分表中间件</p><blockquote><p>MyCat是一个开源的分布式数据库系统，是一个实现了MySQL协议的服务器，前端用户可以把它看作是一个数据库代理，用MySQL客户端工具和命令行访问，而其后端可以用MySQL原生协议与多个MySQL服务器通信，也可以用JDBC协议与大多数主流数据库服务器通信</p></blockquote><h4 id="MyCat功能"><a href="#MyCat功能" class="headerlink" title="MyCat功能:"></a>MyCat功能:</h4><ul><li>数据库读写分离(写操作在主,读操作在从数据库)</li><li>读的负载均衡(一主多从)</li><li>垂直拆分(将表分开为多个数据库)</li><li>水平拆分(对表取模拆分)</li></ul><a id="more"></a><blockquote><p>MyCAT是mysql中间件，前身是阿里大名鼎鼎的Cobar，Cobar在开源了一段时间后，不了了之。于是MyCAT扛起了这面大旗，在大数据时代，其重要性愈发彰显。这篇文章主要是MyCAT的入门部署。</p></blockquote><ul><li>更多相关可以参考这里：<a href="https://www.jianshu.com/p/c6e29d724fca" target="_blank" rel="noopener">https://www.jianshu.com/p/c6e29d724fca</a></li></ul><p>下面是MyCat结合PXC的架构图</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2019/phps/pxc.png"></p><h3 id="PXC简介"><a href="#PXC简介" class="headerlink" title="PXC简介"></a>PXC简介</h3><p>PXC是percona公司的percona  xtraDB  cluster，简称PXC。它是基于Galera协议的高可用集群方案。可以实现多个节点间的数据同步复制以及读写，并且可保障数据库的服务高可用及数据强一致性。</p><blockquote><p>PXC就属于一套近乎完美的MySQL高可用集群架构方案；</p></blockquote><h5 id="主要特点是：-读写强一致性-牺牲性能"><a href="#主要特点是：-读写强一致性-牺牲性能" class="headerlink" title="主要特点是： 读写强一致性(牺牲性能)"></a>主要特点是： 读写强一致性(牺牲性能)</h5><h5 id="PXC特性"><a href="#PXC特性" class="headerlink" title="PXC特性"></a>PXC特性</h5><ul><li>1）同步复制，事务要么在所有节点提交或不提交。</li><li>2）多主复制，可以在任意节点进行写操作。</li><li>3）在从服务器上并行应用事件，真正意义上的并行复制。</li><li>4）节点自动配置，数据一致性，不再是异步复制。</li></ul><p>PXC最大的优势：强一致性、无同步延迟</p><ul><li><p>优点总结：</p><ul><li>服务高可用</li><li>可以达到时时同步(并发复制)，无延迟现象发生</li><li>完全兼容MySQL</li><li>对于集群中新节点的加入(自动部署)，维护起来很简单</li><li>数据的强一致性</li><li>多个可同时读写节点，可实现写扩展，不过最好事先进行分库分表，让各个节点分别写不同的表或者库，避免让galera解决数据冲突；</li></ul></li><li><p>不足之处总结：</p><ul><li>只支持Innodb存储引擎</li><li>存在多节点update更新问题，也就是写放大问题</li><li>在线DDL语句，锁表问题</li><li>sst针对新节点加入的传输代价过高的问题</li><li>所有表都要有主键；</li><li>不支持LOCK TABLE等显式锁操作；</li><li>锁冲突、死锁问题相对更多；</li><li>不支持XA；</li></ul></li></ul><p>事实上，采用PXC的主要目的是解决数据的一致性问题，高可用是顺带实现的。因为PXC存在写扩大以及短板效应，并发效率会有较大损失，类似semi sync replication机制。</p><pre><code>网络说明基于Galere协议的高可用方案：pxc+ Galera是Codership提供的多主数据同步复制机制，可以实现多个节点间的数据同步复制以及读写，并且+ 可保障数据库的服务高可用及数据一致性。+ 基于Galera的高可用方案主要有MariaDB Galera Cluster和Percona XtraDB Cluster（简称PXC），目前PXC用的会比较多一些。+ mariadb的集群原理跟PXC一样,maridb-cluster其实就是PXC，两者原理是一样的。</code></pre><h3 id="PXC原理"><a href="#PXC原理" class="headerlink" title="PXC原理"></a>PXC原理</h3><p>Percona XtraDB Cluster（简称PXC集群）提供了MySQL高可用的一种实现方法。</p><ul><li>1）集群是有节点组成的，推荐配置至少3个节点，但是也可以运行在2个节点上。</li><li>2）每个节点都是普通的mysql/percona服务器，可以将现有的数据库服务器组成集群，反之，也可以将集群拆分成单独的服务器。</li><li>3）每个节点都包含完整的数据副本。</li></ul><p>PXC集群主要由两部分组成：Percona Server with XtraDB和Write Set Replication patches（使用了Galera library，一个通用的用于事务型应用的同步、多主复制插件）。</p><p>PXC会使用大概是4个端口号</p><ul><li>3306 数据库对外服务的端口号</li><li>4444 请求SST SST: 指数据一个镜象传输 xtrabackup , rsync ,mysqldump </li><li>4567 : 组成员之间进行沟通的一个端口号</li><li>4568 : 传输IST用的。相对于SST来说的一个增量。</li></ul><blockquote><p>注：安装PXC过程中， iptables 禁掉 ，selinux 也禁掉</p></blockquote><h3 id="PXC的操作流程："><a href="#PXC的操作流程：" class="headerlink" title="PXC的操作流程："></a>PXC的操作流程：</h3><ul><li>首先客户端先发起一个事务，该事务先在本地执行，执行完成之后就要发起对事务的提交操作了。</li><li>在提交之前需要将产生的复制写集广播出去，然后获取到一个全局的事务ID号，一并传送到另一个节点上面。</li><li>通过合并数据之后，发现没有冲突数据，执行apply_cd和commit_cb动作，否则就需要取消此次事务的操作。</li><li>当前server节点通过验证之后，执行提交操作，并返回OK，如果验证没通过，则执行回滚。</li><li>在生产中至少要有3个节点的集群环境，如果其中一个节点没有验证通过，出现了数据冲突，那么此时采取的方式就是讲出现不一致的节点踢出集群环境，而且它自己会执行shutdown命令，自动关机。</li></ul><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>部署环境： CentOS7.X</p><h5 id="1、执行-命令-vi-etc-selinux-config"><a href="#1、执行-命令-vi-etc-selinux-config" class="headerlink" title="1、执行 命令   vi /etc/selinux/config"></a>1、执行 命令   vi /etc/selinux/config</h5><pre><code>SELINUX=disabled   #修改该项为disabled</code></pre><h5 id="2、执行命令-setenforce-0"><a href="#2、执行命令-setenforce-0" class="headerlink" title="2、执行命令   setenforce 0"></a>2、执行命令   setenforce 0</h5><h5 id="3、查看防火墙是否开启-systemctl-status-firewalld"><a href="#3、查看防火墙是否开启-systemctl-status-firewalld" class="headerlink" title="3、查看防火墙是否开启     systemctl status firewalld"></a>3、查看防火墙是否开启     systemctl status firewalld</h5><p>如果防火墙是开启状态，则开放端口 3306 、4444、4567、4568</p><pre><code>firewall-cmd --add-port=3306/tcp --permanent     #开放了3306端口</code></pre><p>开放完4个端口后，重新加载防火墙规则</p><pre><code>firewall-cmd --reload</code></pre><h5 id="4、安装Persona仓库"><a href="#4、安装Persona仓库" class="headerlink" title="4、安装Persona仓库"></a>4、安装Persona仓库</h5><pre><code>yum install http://www.percona.com/downloads/percona-release/redhat/0.1-4/percona-release-0.1-4.noarch.rpm</code></pre><h5 id="5、安装PXC（保证服务器没有装MySQL）卸载MySQL-参考链接：https-blog-csdn-net-tjcyjd-article-details-52189182"><a href="#5、安装PXC（保证服务器没有装MySQL）卸载MySQL-参考链接：https-blog-csdn-net-tjcyjd-article-details-52189182" class="headerlink" title="5、安装PXC（保证服务器没有装MySQL）卸载MySQL 参考链接：https://blog.csdn.net/tjcyjd/article/details/52189182"></a>5、安装PXC（保证服务器没有装MySQL）卸载MySQL 参考链接：<a href="https://blog.csdn.net/tjcyjd/article/details/52189182" target="_blank" rel="noopener">https://blog.csdn.net/tjcyjd/article/details/52189182</a></h5><pre><code>yum install Percona-XtraDB-Cluster-57</code></pre><h5 id="6、开启PXC服务"><a href="#6、开启PXC服务" class="headerlink" title="6、开启PXC服务"></a>6、开启PXC服务</h5><pre><code>service mysql start</code></pre><h5 id="7、查看安装数据库的临时密码并记住"><a href="#7、查看安装数据库的临时密码并记住" class="headerlink" title="7、查看安装数据库的临时密码并记住"></a>7、查看安装数据库的临时密码并记住</h5><pre><code>grep &apos;temporary password&apos; /var/log/mysqld.log</code></pre><h5 id="8、登录MySQL数据库"><a href="#8、登录MySQL数据库" class="headerlink" title="8、登录MySQL数据库"></a>8、登录MySQL数据库</h5><pre><code>mysql -u root -p</code></pre><p>输入临时密码, 登录成功后修改密码</p><pre><code>ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;你的密码&apos;;</code></pre><h5 id="9、停止MySQL服务"><a href="#9、停止MySQL服务" class="headerlink" title="9、停止MySQL服务"></a>9、停止MySQL服务</h5><pre><code>service mysql stop   （某些版本使用mysqld）</code></pre><h5 id="10、配置节点"><a href="#10、配置节点" class="headerlink" title="10、配置节点"></a>10、配置节点</h5><pre><code>vi  /etc/percona-xtradb-cluster.conf.d/wsrep.cnf</code></pre><p>修改配置文件</p><pre><code># Cluster connection URL contains IPs of nodes#If no IP is found, this implies that a new cluster needs to be created,#in order to do that you need to bootstrap this node#集群中节点的IP地址（本机填最后）wsrep_cluster_address=gcomm://ip地址,IP地址,IP地址（用,号隔开）# In order for Galera to work correctly binlog format should be ROWbinlog_format=ROW# MyISAM storage engine has only experimental supportdefault_storage_engine=InnoDB# Slave thread to usewsrep_slave_threads= 8wsrep_log_conflicts# This changes how InnoDB autoincrement locks are managed and is a requirement for Galerainnodb_autoinc_lock_mode=2# Node IP address#当前节点IPwsrep_node_address=IP地址# Cluster name#集群名称wsrep_cluster_name=pxc-cluster#If wsrep_node_name is not specified,  then system hostname will be used#当前节点名称wsrep_node_name=pxc-cluster-node-1#pxc_strict_mode allowed values: DISABLED,PERMISSIVE,ENFORCING,MASTER#不使用实验功能pxc_strict_mode=ENFORCING# SST method#状态快照传输（sst）方法，官方建议wsrep_sst_method=xtrabackup-v2#Authentication for SST method#用户凭证（mysql的用户名和密码）wsrep_sst_auth=&quot;用户名:密码&quot;</code></pre><p>剩下的节点修改当前节点名、当前节点IP、集群中的节点IP，其他相同</p><blockquote><p>注：1—10步骤  每个节点都要配置一次</p></blockquote><h5 id="11、初始化集群节点"><a href="#11、初始化集群节点" class="headerlink" title="11、初始化集群节点"></a>11、初始化集群节点</h5><p>其中一个节点使用 systemctl start <a href="mailto:mysql@bootstrap.service" target="_blank" rel="noopener">mysql@bootstrap.service</a> 启动</p><h6 id="登录mysql"><a href="#登录mysql" class="headerlink" title="登录mysql"></a>登录mysql</h6><pre><code>mysql -u root -p</code></pre><p>开启 wsrep_causal_reads</p><pre><code>set wsrep_causal_reads =1;</code></pre><h5 id="12、创建配置文件中对应的用户"><a href="#12、创建配置文件中对应的用户" class="headerlink" title="12、创建配置文件中对应的用户"></a>12、创建配置文件中对应的用户</h5><blockquote><p>所有节点的IP都要创建</p></blockquote><p>创建用户：    </p><pre><code>CREATE USER &apos;用户名&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;密码&apos;;  </code></pre><p>刷新权限：   </p><pre><code>GRANT all privileges ON *.* TO &apos;用户名&apos;@&apos;localhost&apos; ;FLUSH PRIVILEGES;</code></pre><p>创建用户：</p><pre><code>CREATE USER &apos;用户名&apos;@&apos;当前需要访问数据库的IP地址&apos; IDENTIFIED BY &apos;密码&apos;;  </code></pre><p>刷新权限：</p><pre><code>GRANT all privileges ON *.* TO &apos;用户名&apos;@&apos;当前节点IP地址&apos; ;FLUSH PRIVILEGES;</code></pre><h5 id="13、其他节点使用-service-mysql-start-启动-，登录mysql，配置wsrep-causal-reds，set-wsrep-causal-reads-1"><a href="#13、其他节点使用-service-mysql-start-启动-，登录mysql，配置wsrep-causal-reds，set-wsrep-causal-reads-1" class="headerlink" title="13、其他节点使用   service mysql start  启动 ，登录mysql，配置wsrep_causal_reds，set wsrep_causal_reads =1;"></a>13、其他节点使用   service mysql start  启动 ，登录mysql，配置wsrep_causal_reds，set wsrep_causal_reads =1;</h5><h5 id="14、其他节点启动成功后在引导节点（使用-systemctl-start-mysql-bootstrap-service-命令启动的节点）"><a href="#14、其他节点启动成功后在引导节点（使用-systemctl-start-mysql-bootstrap-service-命令启动的节点）" class="headerlink" title="14、其他节点启动成功后在引导节点（使用 systemctl start mysql@bootstrap.service 命令启动的节点）"></a>14、其他节点启动成功后在引导节点（使用 systemctl start <a href="mailto:mysql@bootstrap.service" target="_blank" rel="noopener">mysql@bootstrap.service</a> 命令启动的节点）</h5><p>验证集群：</p><pre><code>show status like &apos;wsrep%&apos;;  </code></pre><h5 id="15、节点数据同步验证"><a href="#15、节点数据同步验证" class="headerlink" title="15、节点数据同步验证"></a>15、节点数据同步验证</h5><p>在当前节点创建一个数据库 </p><pre><code>CREATE DATABASE percona;</code></pre><p>启动其他节点的数据库服务，进去后会发现新建的数据库，同理 其他节点创建的数据  当前节点也能看到</p><p>注意：服务的启动和停止要对应</p><pre><code>service mysql stop   ------&gt;  启动时用service mysql start</code></pre><p>或者 </p><pre><code>systemctl stop mysql@bootstrap.service   -----&gt;  启用是用 systemctl start mysql@bootstrap.service </code></pre><ul><li>更多相关实战配置可以参考这里：<a href="https://www.jianshu.com/p/0b7c050dfab6" target="_blank" rel="noopener">https://www.jianshu.com/p/0b7c050dfab6</a></li></ul><h5 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h5><ul><li>带你玩转Mysql高可用方案–PXC<ul><li><a href="https://blog.csdn.net/zisefeizhu/article/details/81873466" target="_blank" rel="noopener">https://blog.csdn.net/zisefeizhu/article/details/81873466</a></li></ul></li><li><p>Docker搭建PXC集群</p><ul><li><a href="https://blog.csdn.net/weixin_41141219/article/details/82767832" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41141219/article/details/82767832</a></li></ul></li><li><p>MySQL高可用方案－PXC环境部署记录: 详细教程</p><ul><li><a href="http://www.cnblogs.com/kevingrace/p/5685371.html" target="_blank" rel="noopener">http://www.cnblogs.com/kevingrace/p/5685371.html</a></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> MySQL </tag>
            
            <tag> PXC集群 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>架构篇——MySQL主从复制(Master-Slave)详解</title>
      <link href="/2019/06/09/%E6%9E%B6%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-Master-Slave-%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/06/09/%E6%9E%B6%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-Master-Slave-%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h3><p>Mysql主从又叫Replication、AB复制(不同于PXC)。简单讲就是A与B两台机器做主从后，在A上写数据，另外一台B也会跟着写数据，实现数据实时同步</p><blockquote><p>mysql主从是基于binlog，主上需开启binlog才能进行主从</p></blockquote><h5 id="主从过程大概有3个步骤"><a href="#主从过程大概有3个步骤" class="headerlink" title="主从过程大概有3个步骤"></a>主从过程大概有3个步骤</h5><ul><li>主将更改操作记录到binlog里</li><li>从将主的binlog事件（sql语句） 同步本机上并记录在relaylog里</li><li>从根据relaylog里面的sql语句按顺序执行</li></ul><a id="more"></a><h4 id="主从作用"><a href="#主从作用" class="headerlink" title="主从作用"></a>主从作用</h4><pre><code>实时灾备，用于故障切换读写分离，提供查询服务备份，避免影响业务</code></pre><h4 id="主从形式"><a href="#主从形式" class="headerlink" title="主从形式"></a>主从形式</h4><ul><li>一主一从</li><li>主主复制</li><li>一主多从—扩展系统读取的性能，因为读是在从库读取的</li><li>多主一从—5.7版本开始支持</li><li>联级复制</li></ul><p>MySQL数据库自身提供的主从复制功能可以方便的实现数据的多处自动备份，实现数据库的拓展。多个数据备份不仅可以加强数据的安全性，通过实现读写分离还能进一步提升数据库的负载性能。</p><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><blockquote><p>MySQL之间数据复制的基础是二进制日志文件（binary log file）。一台MySQL数据库一旦启用二进制日志后，其作为master，它的数据库中所有操作都会以“事件”的方式记录在二进制日志中，其他数据库作为slave通过一个I/O线程与主服务器保持通信，并监控master的二进制日志文件的变化，如果发现master二进制日志文件发生变化，则会把变化复制到自己的中继日志中，然后slave的一个SQL线程会把相关的“事件”执行到自己的数据库中，以此实现从数据库和主数据库的一致性，也就实现了主从复制。</p></blockquote><ul><li>主库将所有的写操作记录在binlog日志中，并生成log dump线程，将binlog日志传给从库的I/O线程</li><li>从库生成两个线程，一个是I/O线程，另一个是SQL线程</li><li>I/O线程去请求主库的binlog日志，并将binlog日志中的文件写入relay log（中继日志）中</li><li>SQL线程会读取relay loy中的内容，并解析成具体的操作，来实现主从的操作一致，达到最终数据一致的目的</li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>实现MySQL主从复制需要进行的配置：</p><ul><li><p>主服务器：</p><ul><li>开启二进制日志</li><li>配置唯一的server-id</li><li>获得master二进制日志文件名及位置</li><li>创建一个用于slave和master通信的用户账号</li></ul></li><li><p>从服务器：</p><ul><li>配置唯一的server-id</li><li>使用master分配的用户账号读取master二进制日志</li><li>启用slave服务</li></ul></li></ul><h4 id="具体实现过程如下："><a href="#具体实现过程如下：" class="headerlink" title="具体实现过程如下："></a>具体实现过程如下：</h4><p>主从复制配置步骤：</p><ul><li>确保从数据库与主数据库里的数据一致</li><li>在主数据库里创建一个同步账户授权给从数据库使用</li><li>配合主数据库（修改配置文件）</li><li>配置从数据库（修改配置文件）</li></ul><h5 id="一、准备工作："><a href="#一、准备工作：" class="headerlink" title="一、准备工作："></a>一、准备工作：</h5><ol><li>主从数据库版本最好一致</li><li>主从数据库内数据保持一致</li></ol><p>搭建两台MYSQL服务器，一台作为主服务器，一台作为从服务器，主服务器进行写操作，从服务器进行读操作</p><pre><code>+ 主数据库：192.168.0.1 /Linux-MySQL+ 从数据库：192.168.0.2 /Linux-MySQL</code></pre><h5 id="二、主数据库master修改："><a href="#二、主数据库master修改：" class="headerlink" title="二、主数据库master修改："></a>二、主数据库master修改：</h5><p>1.修改mysql配置</p><p>找到主数据库的配置文件my.cnf(或者my.ini)，我的在/etc/mysql/my.cnf,在[mysqld]部分插入如下两行：</p><pre><code>[mysqld]log-bin=mysql-bin #开启二进制日志server-id=1 #设置server-id</code></pre><p>2.重启mysql，创建用于同步的用户账号</p><p>打开mysql会话shell</p><pre><code>mysql -hlocalhost -uname -ppassword</code></pre><p>创建用户：用户：rel1密码：slavepass</p><p>3.授权</p><p>主服务器授权从服务器特定账号登录</p><pre><code>mysql&gt; CREATE USER &apos;repl&apos;@&apos;192.168.0.2&apos; IDENTIFIED BY &apos;slavepass&apos;;#创建用户mysql&gt; GRANT REPLICATION SLAVE ON *.* TO &apos;repl&apos;@&apos;192.168.0.2&apos;;#分配权限mysql&gt;flush privileges;   #刷新权限</code></pre><p>4.查看master状态，记录二进制文件名(mysql-bin.000003)和位置(73)：</p><pre><code>mysql &gt; SHOW MASTER STATUS;+------------------+----------+--------------+------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |+------------------+----------+--------------+------------------+| mysql-bin.000003 | 73       | test         | manual,mysql     |+------------------+----------+--------------+------------------+</code></pre><h5 id="三、从服务器slave修改："><a href="#三、从服务器slave修改：" class="headerlink" title="三、从服务器slave修改："></a>三、从服务器slave修改：</h5><p>1.修改mysql配置</p><p>同样找到my.cnf配置文件，添加server-id</p><pre><code>[mysqld]server-id=2 #设置server-id，必须唯一</code></pre><p>2.重启mysql，打开mysql会话，执行同步SQL语句(需要主服务器主机名，登陆凭据，二进制文件的名称和位置)：<br>复制代码</p><pre><code>mysql&gt; CHANGE MASTER TO    -&gt;     MASTER_HOST=&apos;192.168.0.1&apos;,    -&gt;     MASTER_USER=&apos;rep1&apos;,    -&gt;     MASTER_PASSWORD=&apos;slavepass&apos;,    -&gt;     MASTER_LOG_FILE=&apos;mysql-bin.000003&apos;,    -&gt;     MASTER_LOG_POS=73;</code></pre><p>3.启动slave同步进程：</p><pre><code>mysql&gt;start slave;</code></pre><p>4.查看slave状态：</p><pre><code>mysql&gt; show slave status\G;*************************** 1. row ***************************               Slave_IO_State: Waiting for master to send event                  Master_Host: 192.168.0.1                  Master_User: rep1                  Master_Port: 3306                Connect_Retry: 60              Master_Log_File: mysql-bin.000013          Read_Master_Log_Pos: 11662               Relay_Log_File: mysqld-relay-bin.000022                Relay_Log_Pos: 11765        Relay_Master_Log_File: mysql-bin.000013             Slave_IO_Running: Yes            Slave_SQL_Running: Yes              Replicate_Do_DB:           Replicate_Ignore_DB:         ...</code></pre><p>当Slave_IO_Running和Slave_SQL_Running都为YES的时候就表示主从同步设置成功了。</p><p>接下来就可以进行一些验证了，比如在主master数据库的test数据库的一张表中插入一条数据，在slave的test库的相同数据表中查看是否有新增的数据即可验证主从复制功能是否有效，还可以关闭slave（mysql&gt;stop slave;）,然后再修改master，看slave是否也相应修改（停止slave后，master的修改不会同步到slave），就可以完成主从复制功能的验证了。</p><p>还可以用到的其他相关参数：</p><blockquote><p>master开启二进制日志后默认记录所有库所有表的操作，可以通过配置来指定只记录指定的数据库甚至指定的表的操作，具体在mysql配置文件的[mysqld]可添加修改如下选项：</p></blockquote><pre><code># 不同步哪些数据库  binlog-ignore-db = mysql  binlog-ignore-db = test  binlog-ignore-db = information_schema  # 只同步哪些数据库，除此之外，其他不同步  binlog-do-db = game  </code></pre><blockquote><p>如之前查看master状态时就可以看到只记录了test库，忽略了manual和mysql库。</p></blockquote><h3 id="操作流程汇总"><a href="#操作流程汇总" class="headerlink" title="操作流程汇总"></a>操作流程汇总</h3><h5 id="关闭防火墙以SELINUX"><a href="#关闭防火墙以SELINUX" class="headerlink" title="关闭防火墙以SELINUX"></a>关闭防火墙以SELINUX</h5><pre><code>[root@icocos ~]# systemctl stop firewalld[root@icocos ~]# systemctl disable firewalld[root@icocos ~]#  sed -ri &apos;s/(SELINUX=).*/\1disabled/g&apos; /etc/selinux/config[root@icocos ~]# setenforce 0</code></pre><h5 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h5><pre><code>安装依赖包[root@icocos ~]# yum -y install ncurses-devel openssl-devel openssl cmake mariadb-devel</code></pre><h5 id="创建用户和组"><a href="#创建用户和组" class="headerlink" title="创建用户和组"></a>创建用户和组</h5><pre><code>[root@icocos ~]# groupadd -r -g 306 mysql[root@icocos ~]# useradd -M -s /sbin/nologin -g 306 -u 306 mysql</code></pre><h5 id="下载二进制格式的mysql软件包"><a href="#下载二进制格式的mysql软件包" class="headerlink" title="下载二进制格式的mysql软件包"></a>下载二进制格式的mysql软件包</h5><pre><code>[root@icocos ~]# cd /usr/src/[root@icocos src]#wget https://downloads.mysql.com/archives/get/file/mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz</code></pre><h5 id="解压软件至-usr-local"><a href="#解压软件至-usr-local" class="headerlink" title="解压软件至/usr/local/"></a>解压软件至/usr/local/</h5><pre><code>[root@icocos src]# lsdebug  kernels  mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz[root@icocos src]# tar xf mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz -C /usr/local/[root@icocos src]#  ls  /usr/local/bin  etc  games  include  lib  lib64  libexec  mysql-5.7.22-linux-glibc2.12-x86_64  sbin  share  src[root@icocos src]#  cd  /usr/local/[root@icocos local]# ln -sv mysql-5.7.22-linux-glibc2.12-x86_64/ mysql&quot;mysql&quot; -&gt; &quot;mysql-5.7.22-linux-glibc2.12-x86_64/&quot;[root@icocos local]# ll总用量 0drwxr-xr-x. 2 root root   6 11月  5 2016 bindrwxr-xr-x. 2 root root   6 11月  5 2016 etcdrwxr-xr-x. 2 root root   6 11月  5 2016 gamesdrwxr-xr-x. 2 root root   6 11月  5 2016 includedrwxr-xr-x. 2 root root   6 11月  5 2016 libdrwxr-xr-x. 2 root root   6 11月  5 2016 lib64drwxr-xr-x. 2 root root   6 11月  5 2016 libexeclrwxrwxrwx. 1 root root  36 9月   7 22:20 mysql -&gt; mysql-5.7.22-linux-glibc2.12-x86_64/drwxr-xr-x. 9 root root 129 9月   7 22:19 mysql-5.7.22-linux-glibc2.12-x86_64drwxr-xr-x. 2 root root   6 11月  5 2016 sbindrwxr-xr-x. 5 root root  49 9月   3 23:02 sharedrwxr-xr-x. 2 root root   6 11月  5 2016 src</code></pre><h5 id="修改目录-usr-locaal-mysql的属主属组"><a href="#修改目录-usr-locaal-mysql的属主属组" class="headerlink" title="修改目录/usr/locaal/mysql的属主属组"></a>修改目录/usr/locaal/mysql的属主属组</h5><pre><code>[root@icocos local]# chown -R mysql.mysql /usr/local/mysql[root@icocos local]#  ll /usr/local/mysql -dlrwxrwxrwx. 1 mysql mysql 36 9月   7 22:20 /usr/local/mysql -&gt; mysql-5.7.22-linux-glibc2.12-x86_64/</code></pre><h5 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h5><pre><code>[root@icocos local]# ls /usr/local/mysqlbin  COPYING  docs  include  lib  man  README  share  support-files[root@icocos local]# cd[root@icocos ~]# echo &apos;export PATH=/usr/local/mysql/bin:$PATH&apos; &gt; /etc/profile.d/mysql.sh[root@icocos ~]# . /etc/profile.d/mysql.sh[root@icocos ~]# echo $PATH/usr/local/mysql/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</code></pre><h5 id="建立数据存放目录"><a href="#建立数据存放目录" class="headerlink" title="建立数据存放目录"></a>建立数据存放目录</h5><pre><code>[root@icocos ~]# cd /usr/local/mysql[root@icocos mysql]# mkdir /opt/data[root@icocos mysql]#  chown -R mysql.mysql /opt/data/[root@icocos mysql]#  ll /opt/总用量 0drwxr-xr-x. 2 mysql mysql 6 9月   7 22:25 data</code></pre><h5 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h5><pre><code>[root@icocos mysql]# /usr/local/mysql/bin/mysqld --initialize --user=mysql --datadir=/opt/data///这个命令的最后会生成一个临时密码，此处密码是1EbNA-k*BtKo</code></pre><h5 id="配置mysql"><a href="#配置mysql" class="headerlink" title="配置mysql"></a>配置mysql</h5><pre><code>[root@icocos ~]# ln -sv /usr/local/mysql/include/ /usr/local/include/mysql&quot;/usr/local/include/mysql&quot; -&gt; &quot;/usr/local/mysql/include/&quot;[root@icocos ~]# echo &apos;/usr/local/mysql/lib&apos; &gt; /etc/ld.so.conf.d/mysql.conf[root@icocos ~]#  ldconfig -v</code></pre><h5 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h5><pre><code>[root@icocos ~]# cat &gt; /etc/my.cnf &lt;&lt;EOF&gt; [mysqld]&gt; basedir = /usr/local/mysql&gt; datadir = /opt/data&gt; socket = /tmp/mysql.sock&gt; port = 3306&gt; pid-file = /opt/data/mysql.pid&gt; user = mysql&gt; skip-name-resolve&gt; EOF</code></pre><h5 id="配置服务启动脚本"><a href="#配置服务启动脚本" class="headerlink" title="配置服务启动脚本"></a>配置服务启动脚本</h5><pre><code>[root@icocos ~]# cp -a /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld[root@icocos ~]#  sed -ri &apos;s#^(basedir=).*#\1/usr/local/mysql#g&apos; /etc/init.d/mysqld[root@icocos ~]# sed -ri &apos;s#^(datadir=).*#\1/opt/data#g&apos; /etc/init.d/mysqld</code></pre><h5 id="启动mysql"><a href="#启动mysql" class="headerlink" title="启动mysql"></a>启动mysql</h5><pre><code>[root@icocos ~]#  service mysqld startStarting MySQL.Logging to &apos;/opt/data/icocos.err&apos;... SUCCESS![root@icocos ~]#  ps -ef|grep mysqlroot       4897      1  0 22:38 pts/2    00:00:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/opt/data --pid-file=/opt/data/mysql.pidmysql      5075   4897  6 22:38 pts/2    00:00:01 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/opt/data --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=icocos.err --pid-file=/opt/data/mysql.pid --socket=/tmp/mysql.sock --port=3306root       5109   4668  0 22:38 pts/2    00:00:00 grep --color=auto mysql[root@icocos ~]# ss -antlState       Recv-Q Send-Q                     Local Address:Port                                    Peer Address:Port              LISTEN      0      128                                    *:22                                                 *:*                  LISTEN      0      100                            127.0.0.1:25                                                 *:*                  LISTEN      0      128                                   :::22                                                :::*                  LISTEN      0      100                                  ::1:25                                                :::*                  LISTEN      0      80                                    :::3306                                              :::*                  </code></pre><h5 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h5><p>使用临时密码修改</p><pre><code>[root@icocos ~]# mysql -uroot -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.7.22Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; set password = password(&apos;123456&apos;);Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; quitBye</code></pre><h5 id="mysql主从配置"><a href="#mysql主从配置" class="headerlink" title="mysql主从配置"></a>mysql主从配置</h5><p>确保从数据库与主数据库的数据一样先在主数据库创建所需要同步的库和表</p><pre><code>[root@icocos ~]# mysql -uroot -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 4Server version: 5.7.22 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. AlOracle is a registered trademark of Oracle Corporation andaffiliates. Other names may be trademarks of their respectowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the currmysql&gt; create database yan;Query OK, 1 row affected (0.00 sec)mysql&gt; create database lisi;Query OK, 1 row affected (0.00 sec)mysql&gt; create database wangwu;Query OK, 1 row affected (0.00 sec)mysql&gt; use yan;Database changedmysql&gt; create table tom (id int not null,name varchar(100)not null ,age tinyint);Query OK, 0 rows affected (11.83 sec)mysql&gt; insert tom (id,name,age) values(1,&apos;zhangshan&apos;,20),(2,&apos;wangwu&apos;,7),(3,&apos;lisi&apos;,23);Query OK, 3 rows affected (0.07 sec)Records: 3  Duplicates: 0  Warnings: 0mysql&gt; select * from tom;+----+-----------+------+| id | name      | age  |+----+-----------+------+|  1 | zhangshan |   20 ||  2 | wangwu    |    7 ||  3 | lisi      |   23 |+----+-----------+------+3 rows in set (0.00 sec)</code></pre><h5 id="备份主库"><a href="#备份主库" class="headerlink" title="备份主库"></a>备份主库</h5><p>备份主库时需要另开一个终端，给数据库上读锁，避免在备份期间有其他人在写入导致数据同步的不一致</p><pre><code>[root@icocos ~]# mysql -uroot -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 5Server version: 5.7.22 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; flush tables with read lock;Query OK, 0 rows affected (0.76 sec)</code></pre><p>此锁表的终端必须在备份完成以后才能退出（退出锁表失效）</p><h5 id="备份主库并将备份文件传送到从库"><a href="#备份主库并将备份文件传送到从库" class="headerlink" title="备份主库并将备份文件传送到从库"></a>备份主库并将备份文件传送到从库</h5><pre><code>[root@icocos ~]# mysqldump -uroot -p123456 --all-databases &gt; /opt/all-20180907.sqlmysqldump: [Warning] Using a password on the command line interface can be insecure.[root@icocos ~]# ls /opt/all-20180907.sql  data[root@icocos ~]# scp /opt/all-20180907.sql root@192.168.0.2:/opt/The authenticity of host &apos;192.168.0.2 (192.168.0.2)&apos; can&apos;t be established.ECDSA key fingerprint is SHA256:7mLj77SFk7sPkhjpMPfdK3nZ98hOuyP4OKzjXeijSJ0.ECDSA key fingerprint is MD5:a0:1b:eb:7f:f0:b6:7b:73:97:91:4c:f3:b1:89:d8:ea.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;192.168.0.2&apos; (ECDSA) to the list of known hosts.root@192.168.0.2&apos;s password:all-20180907.sql       100%  784KB 783.3KB/s   00:01    </code></pre><h5 id="解除主库的锁表状态，直接退出交互式界面即可"><a href="#解除主库的锁表状态，直接退出交互式界面即可" class="headerlink" title="解除主库的锁表状态，直接退出交互式界面即可"></a>解除主库的锁表状态，直接退出交互式界面即可</h5><pre><code>mysql&gt; quitBye</code></pre><h5 id="在从库上恢复主库的备份并查看是否与主库的数据保持一致"><a href="#在从库上恢复主库的备份并查看是否与主库的数据保持一致" class="headerlink" title="在从库上恢复主库的备份并查看是否与主库的数据保持一致"></a>在从库上恢复主库的备份并查看是否与主库的数据保持一致</h5><pre><code>[root@icocos ~]# mysql -uroot -p123456 &lt; /opt/all-20180907.sqlmysql: [Warning] Using a password on the command line interface can be insecure.[root@icocos ~]# mysql -uroot -p123456mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 4Server version: 5.7.22 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || lisi               || mysql              || performance_schema || sys                || wangwu             || yan                |+--------------------+7 rows in set (0.18 sec)mysql&gt; use yan;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; select * from tom;+----+-----------+------+| id | name      | age  |+----+-----------+------+|  1 | zhangshan |   20 ||  2 | wangwu    |    7 ||  3 | lisi      |   23 |+----+-----------+------+3 rows in set (0.06 sec)</code></pre><h5 id="在主数据库创建一个同步账户授权给从数据使用"><a href="#在主数据库创建一个同步账户授权给从数据使用" class="headerlink" title="在主数据库创建一个同步账户授权给从数据使用"></a>在主数据库创建一个同步账户授权给从数据使用</h5><pre><code>[root@icocos ~]# mysql -uroot -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 7Server version: 5.7.22 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; create user &apos;repl&apos;@&apos;192.168.0.2&apos; identified by &apos;123456&apos;;Query OK, 0 rows affected (5.50 sec)mysql&gt; grant replication slave on *.* to &apos;repl&apos;@&apos;192.168.0.2&apos;;Query OK, 0 rows affected (0.04 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.09 sec)</code></pre><h5 id="配置主数据库编辑配置文件"><a href="#配置主数据库编辑配置文件" class="headerlink" title="配置主数据库编辑配置文件"></a>配置主数据库编辑配置文件</h5><pre><code>[root@icocos ~]# vim /etc/my.cnf[root@icocos ~]# cat /etc/my.cnf[mysqld]basedir = /usr/local/mysqldatadir = /opt/datasocket = /tmp/mysql.sockport = 3306pid-file = /opt/data/mysql.piduser = mysqlskip-name-resolve//添加以下内容log-bin=mysql-bin //启用binlog日志server-id=1 //主数据库服务器唯一标识符 主的必须必从大log-error=/opt/data/mysql.log</code></pre><h5 id="重启mysql服务"><a href="#重启mysql服务" class="headerlink" title="重启mysql服务"></a>重启mysql服务</h5><pre><code>[root@icocos ~]# service mysqld restartShutting down MySQL..... SUCCESS!Starting MySQL.Logging to &apos;/opt/data/mysql.log&apos;................................ SUCCESS![root@icocos ~]# ss -antlState       Recv-Q Send-Q Local Address:Port               Peer Address:Port              LISTEN      0      128     *:22                  *:*                  LISTEN      0      100    127.0.0.1:25                  *:*                  LISTEN      0      128    :::22                 :::*                  LISTEN      0      100       ::1:25                 :::*                  LISTEN      0      80     :::3306               :::*</code></pre><h5 id="查看主库的状态"><a href="#查看主库的状态" class="headerlink" title="查看主库的状态"></a>查看主库的状态</h5><pre><code>mysql&gt; show master status;+------------------+----------+--------------+------------------+-------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+------------------+----------+--------------+------------------+-------------------+| mysql-bin.000001 |      154 |              |                  |                   |+------------------+----------+--------------+------------------+-------------------+1 row in set (0.00 sec)</code></pre><h5 id="配置从数据库"><a href="#配置从数据库" class="headerlink" title="配置从数据库"></a>配置从数据库</h5><p>编辑配置文件</p><pre><code>[root@icocos ~]# cat /etc/my.cnf[mysqld]basedir = /usr/local/mysqldatadir = /opt/datasocket = /tmp/mysql.sockport = 3306pid-file = /opt/data/mysql.piduser = mysqlskip-name-resolve//添加以下内容：server-id=2 //设置从库的唯一标识符 从的必须比主小relay-log=mysql-relay-bin //启用中继日志relay logerror-log=/opt/data/mysql.log</code></pre><h5 id="重启从库的mysql服务"><a href="#重启从库的mysql服务" class="headerlink" title="重启从库的mysql服务"></a>重启从库的mysql服务</h5><pre><code>[root@icocos ~]# service mysqld restartShutting down MySQL.. SUCCESS!Starting MySQL.. SUCCESS![root@icocos ~]# ss -antlState       Recv-Q Send-Q Local Address:Port               Peer Address:Port              LISTEN      0      128     *:22                  *:*                  LISTEN      0      100    127.0.0.1:25                  *:*                  LISTEN      0      128    :::22                 :::*                  LISTEN      0      100       ::1:25                 :::*                  LISTEN      0      80     :::3306               :::*                  </code></pre><h5 id="配置并启动主从复制"><a href="#配置并启动主从复制" class="headerlink" title="配置并启动主从复制"></a>配置并启动主从复制</h5><pre><code>mysql&gt; change master to    -&gt; master_host=&apos;192.168.0.1&apos;,    -&gt; master_user=&apos;repl&apos;,    -&gt; master_password=&apos;123456&apos;,    -&gt; master_log_file=&apos;mysql-bin.000001&apos;,    -&gt; master_log_pos=154;Query OK, 0 rows affected, 2 warnings (0.28 sec)</code></pre><h5 id="查看从服务器状态"><a href="#查看从服务器状态" class="headerlink" title="查看从服务器状态"></a>查看从服务器状态</h5><pre><code>mysql&gt; show slave status\G;*************************** 1. row ***************************               Slave_IO_State: Waiting for master to send event                  Master_Host: 192.168.0.1                  Master_User: repl                  Master_Port: 3306                Connect_Retry: 60              Master_Log_File: mysql-bin.000001          Read_Master_Log_Pos: 154               Relay_Log_File: mysql-relay-bin.000003                Relay_Log_Pos: 320        Relay_Master_Log_File: mysql-bin.000001             Slave_IO_Running: Yes                                     //此处必须是yes            Slave_SQL_Running: Yes                                    //此处必须是yes                     Replicate_Do_DB:          Replicate_Ignore_DB:           Replicate_Do_Table:       Replicate_Ignore_Table:      Replicate_Wild_Do_Table:  Replicate_Wild_Ignore_Table:                   Last_Errno: 0                   Last_Error:                 Skip_Counter: 0          Exec_Master_Log_Pos: 154              Relay_Log_Space: 527              Until_Condition: None               Until_Log_File:                Until_Log_Pos: 0           Master_SSL_Allowed: No           Master_SSL_CA_File:           Master_SSL_CA_Path:              Master_SSL_Cert:            Master_SSL_Cipher:               Master_SSL_Key:        Seconds_Behind_Master: 0Master_SSL_Verify_Server_Cert: No                Last_IO_Errno: 0                Last_IO_Error:               Last_SQL_Errno: 0               Last_SQL_Error:  Replicate_Ignore_Server_Ids:             Master_Server_Id: 1                  Master_UUID: 5abf1791-b2af-11e8-b6ad-000c2980fbb4             Master_Info_File: /opt/data/master.info                    SQL_Delay: 0          SQL_Remaining_Delay: NULL      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates           Master_Retry_Count: 86400                  Master_Bind:      Last_IO_Error_Timestamp:     Last_SQL_Error_Timestamp:               Master_SSL_Crl:           Master_SSL_Crlpath:           Retrieved_Gtid_Set:            Executed_Gtid_Set:                Auto_Position: 0         Replicate_Rewrite_DB:                 Channel_Name:           Master_TLS_Version:1 row in set (0.00 sec)ERROR:No query specified</code></pre><h5 id="测试验证在主服务器的yan库的tom表插入数据"><a href="#测试验证在主服务器的yan库的tom表插入数据" class="headerlink" title="测试验证在主服务器的yan库的tom表插入数据:"></a>测试验证在主服务器的yan库的tom表插入数据:</h5><pre><code>mysql&gt; use yan;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; select * from tom;+----+-----------+------+| id | name      | age  |+----+-----------+------+|  1 | zhangshan |   20 ||  2 | wangwu    |    7 ||  3 | lisi      |   23 |+----+-----------+------+3 rows in set (0.09 sec)mysql&gt; insert tom(id,name,age) value (4,&quot;yyl&quot;,18);Query OK, 1 row affected (0.14 sec)mysql&gt; select * from tom;+----+-----------+------+| id | name      | age  |+----+-----------+------+|  1 | zhangshan |   20 ||  2 | wangwu    |    7 ||  3 | lisi      |   23 ||  4 | yyl       |   18 |+----+-----------+------+4 rows in set (0.00 sec)</code></pre><h5 id="在从数据库查看是否数据同步"><a href="#在从数据库查看是否数据同步" class="headerlink" title="在从数据库查看是否数据同步"></a>在从数据库查看是否数据同步</h5><pre><code>mysql&gt; use yan;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; select * from tom;+----+-----------+------+| id | name      | age  |+----+-----------+------+|  1 | zhangshan |   20 ||  2 | wangwu    |    7 ||  3 | lisi      |   23 ||  4 | yyl       |   18 |+----+-----------+------+4 rows in set (0.00 sec)</code></pre>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> MySQL </tag>
            
            <tag> 主从复制 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL锁机制和PHP锁机制</title>
      <link href="/2019/06/06/MySQL%E9%94%81%E6%9C%BA%E5%88%B6%E5%92%8CPHP%E9%94%81%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/06/06/MySQL%E9%94%81%E6%9C%BA%E5%88%B6%E5%92%8CPHP%E9%94%81%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h3 id="PHP中的文件锁-（锁的是文件，不是表）"><a href="#PHP中的文件锁-（锁的是文件，不是表）" class="headerlink" title="PHP中的文件锁 （锁的是文件，不是表）"></a>PHP中的文件锁 （锁的是文件，不是表）</h3><p>文件锁的文件与表有什么关系？：一点关系也没有，与令牌相似，谁拿到谁操作。所以表根本没锁。<br>测试时，有个文件就行，叫什么名无所谓</p><p>bool flock ( int handle, int operation [, int &amp;wouldblock] );<br>flock() 操作的 handle 必须是一个已经打开的文件指针。operation 可以是以下值之一：</p><ul><li>要取得共享锁定（读取程序），将 operation 设为 LOCK_SH（PHP 4.0.1 以前的版本设置为 1）</li><li>要取得独占锁定（写入程序），将 operation 设为 LOCK_EX（PHP 4.0.1 以前的版本中设置为 2）</li><li>要释放锁定（无论共享或独占），将 operation 设为 LOCK_UN（PHP 4.0.1 以前的版本中设置为 3）</li><li>如果你不希望 flock() 在锁定时堵塞，则给 operation 加上 LOCK_NB（PHP 4.0.1 以前的版本中设置为4）</li></ul><a id="more"></a><h4 id="建两个文件"><a href="#建两个文件" class="headerlink" title="建两个文件"></a>建两个文件</h4><!--more--><h5 id="1-a-php"><a href="#1-a-php" class="headerlink" title="(1) a.php"></a>(1) a.php</h5><pre><code>$file = &quot;temp.txt&quot;;   $fp = fopen($file , &apos;w&apos;);   if(flock($fp , LOCK_EX)){        fwrite($fp , &quot;abc\n&quot;);        sleep(10);        fwrite($fp , &quot;123\n&quot;);       flock($fp , LOCK_UN);   }   fclose($fp);  </code></pre><h5 id="2-b-php"><a href="#2-b-php" class="headerlink" title="(2) b.php"></a>(2) b.php</h5><pre><code>$file = &quot;temp.txt&quot;;   $fp = fopen($file , &apos;r&apos;);   echo fread($fp , 100);   fclose($fp);  </code></pre><p>运行 a.php 后，马上运行 b.php ，可以看到输出：</p><pre><code>abc</code></pre><p>等 a.php 运行完后运行 b.php ，可以看到输出：</p><pre><code>abc123</code></pre><p>显然，当 a.php 写文件时数据太大，导致时间比较长时，这时 b.php 读取数据不完整</p><p>修改 b.php 为：</p><pre><code>$file = &quot;temp.txt&quot;;   $fp = fopen($file , &apos;r&apos;);   if(flock($fp , LOCK_EX)){       echo fread($fp , 100);       flock($fp , LOCK_UN);   } else{       echo &quot;Lock file failed...\n&quot;;   }   fclose($fp);  </code></pre><p>运行 a.php 后，马上运行 b.php ，可以发现 b.php 会等到 a.php 运行完成后(即 10 秒后)才显示：</p><pre><code>abc123</code></pre><p>读取数据完整，但时间过长，他要等待写锁释放。</p><p>修改 b.php 为：</p><pre><code>$file = &quot;temp.txt&quot;;   $fp = fopen($file , &apos;r&apos;);   if(flock($fp , LOCK_SH | LOCK_NB)){       echo fread($fp , 100);       flock($fp , LOCK_UN);   } else{       echo &quot;Lock file failed...\n&quot;;   }   fclose($fp);  </code></pre><p>运行 a.php 后，马上运行 b.php ，可以看到输出：<br>    Lock file failed…</p><p>证明可以返回锁文件失败状态，而不是向上面一样要等很久。</p><h5 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h5><blockquote><p>建议作文件缓存时，选好相关的锁，不然可能导致读取数据不完整，或重复写入数据。<br>file_get_contents 好像选择不了锁，不知道他默认用的什么锁，反正和不锁得到的输出一样，是不完整的数据。</p></blockquote><p>我是要做文件缓存，所以只需要知道是否有写锁存在即可，有的话就查数据库就可以了。<br>测试环境：Linux(Ubuntu 6) , PHP 5.1.2 , Apache 2</p><h5 id="再转："><a href="#再转：" class="headerlink" title="再转："></a>再转：</h5><p>文件锁有两种：共享锁和排他锁，也就是读锁(LOCK_SH)和写锁(LOCK_EX)<br>文件的锁一般这么使用：</p><pre><code>$fp = fopen(&quot;filename&quot;, &quot;a&quot;);   flock($fp, LOCK_SH) or die(&quot;lock error&quot;)   $str = fread($fp, 1024);   flock($fp, LOCK_UN);   fclose($fp);  </code></pre><blockquote><p>注意fwrite之后，文件立即就被更新了，而不是等fwrite然后fclose之后文件才会更新，这个可以通过在fwrite之后fclose之前读取这个文件进行检查 </p></blockquote><p>但是什么时候使用lock_ex什么时候使用lock_sh呢？ </p><h5 id="读的时候："><a href="#读的时候：" class="headerlink" title="读的时候："></a>读的时候：</h5><p>如果不想出现dirty数据，那么最好使用lock_sh共享锁。可以考虑以下三种情况： </p><ol><li>如果读的时候没有加共享锁，那么其他程序要写的话（不管这个写是加锁还是不加锁）都会立即写成功。如果正好读了一半，然后被其他程序给写了，那么读的后一半就有可能跟前一半对不上（前一半是修改前的，后一半是修改后的） </li><li>如果读的时候加上了共享锁（因为只是读，没有必要使用排他锁），这个时候，其他程序开始写，这个写程序没有使用锁，那么写程序会直接修改这个文件，也会导致前面一样的问题 </li><li>最理想的情况是，读的时候加锁(lock_sh),写的时候也进行加锁(lock_ex),这样写程序会等着读程序完成之后才进行操作，而不会出现贸然操作的情况 </li></ol><h5 id="写的时候："><a href="#写的时候：" class="headerlink" title="写的时候："></a>写的时候：</h5><p>如果多个写程序不加锁同时对文件进行操作，那么最后的数据有可能一部分是a程序写的，一部分是b程序写的<br>如果写的时候加锁了，这个时候有其他的程序来读，那么他会读到什么东西呢？ </p><ol><li>如果读程序没有申请共享锁，那么他会读到dirty的数据。比如写程序要写a,b,c三部分，写完a,这时候读读到的是a，继续写b，这时候读读到的是ab，然后写c，这时候读到的是abc. </li><li>如果读程序在之前申请了共享锁，那么读程序会等写程序将abc写完并释放锁之后才进行读。</li></ol><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>项目中应该只使用PHP中的文件锁，尽量避免锁表，因为如果表被锁定了，那么整个网站中所有和这个表相关的功能都被拖慢了（例如：前台很多用户一直下订单，商品表mysql锁表，其他与商品表相关的操作一直处于阻塞状态【读不出来商品表】，因为一个功能把整个网站速度拖慢）。</p><blockquote><p> 比如在一个O2O外卖项目中，中午12-2点，晚上6点都是订单高并发时，这种情况下，MySQL锁显然是不考虑的，用户体验太差。其实根据实际的需求，外卖可以不用设计库存量的，当然除了秒杀活动模块还是需要php文件锁的。</p></blockquote><p>应用场景：</p><ol><li>高并发下单时，减库存量时要加锁</li><li>高并发抢单、抢票时要使用</li></ol><p>MySQL锁示例代码：</p><pre><code>&lt;?php /**模拟秒杀活动-- 商品100件CREATE TABLE a(    id int comment &apos;模拟100件活动商品的数量&apos;);INSERT INTO a VALUES(100);模仿：以10的并发量访问这个脚本！    使用apache自带的ab.exe软件 */ error_reporting(0); mysql_connect(&apos;localhost&apos;,&apos;root&apos;,&apos;admin123&apos;); mysql_select_db(&apos;test&apos;); # mysql 锁 mysql_query(&apos;LOCK TABLE a WRITE&apos;);// 只有一个客户端可以锁定表，其他客户端阻塞在这 $rs = mysql_query(&apos;SELECT id FROM a&apos;); $id = mysql_result($rs, 0, 0); if($id &gt; 0) {     --$id;     mysql_query(&apos;UPDATE a SET id=&apos;.$id); } # mysql 解锁 mysql_query(&apos;UNLOCK TABLES&apos;);</code></pre><p>PHP文件锁示例代码：</p><pre><code>&lt;?php /**模拟秒杀活动-- 商品100件CREATE TABLE a(    id int comment &apos;模拟100件活动商品的数量&apos;);INSERT INTO a VALUES(100);模仿：以10的并发量访问这个脚本！    使用apache自带的ab.exe软件 */ error_reporting(0); mysql_connect(&apos;localhost&apos;,&apos;root&apos;,&apos;admin123&apos;); mysql_select_db(&apos;test&apos;); # php中的文件锁 $fp = fopen(&apos;./a.lock&apos;, &apos;r&apos;); // php的文件锁和表没关系，随便一个文件即可 flock($fp, LOCK_EX);// 排他锁 $rs = mysql_query(&apos;SELECT id FROM a&apos;); $id = mysql_result($rs, 0, 0); if($id &gt; 0) {     --$id;     mysql_query(&apos;UPDATE a SET id=&apos;.$id); } # php的文件锁，释放锁 flock($fp, LOCK_UN); fclose($fp);</code></pre><h3 id="MYSQL中的锁："><a href="#MYSQL中的锁：" class="headerlink" title="MYSQL中的锁："></a>MYSQL中的锁：</h3><p>语法 ：<br>LOCK TABLE 表名1 READ|WRITE, 表名2 READ|WRITE ……………… 【锁表】<br>UNLOCK TABLES  【释放表】</p><ul><li>Read:读锁|共享锁 ： 所有的客户端只能读这个表不能写这个表</li><li>Write:写锁|排它锁： 所有当前锁定客户端可以操作这个表，其他客户端只能阻塞</li></ul><blockquote><p>注意：在锁表的过程中只能操作被锁定的表，如果要操作其他表，必须把所有要操作的表都锁定起来！</p></blockquote><h5 id="1-表级锁定（table-level）"><a href="#1-表级锁定（table-level）" class="headerlink" title="1.表级锁定（table-level）"></a>1.表级锁定（table-level）</h5><p>表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并大度大打折扣。使用表级锁定的主要是MyISAM等一些非事务性存储引擎。</p><h5 id="2-行级锁定（row-level）"><a href="#2-行级锁定（row-level）" class="headerlink" title="2.行级锁定（row-level）"></a>2.行级锁定（row-level）</h5><p>行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。<br>虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。使用行级锁定的主要是InnoDB存储引擎。</p><h5 id="3-页级锁定（page-level）"><a href="#3-页级锁定（page-level）" class="headerlink" title="3.页级锁定（page-level）"></a>3.页级锁定（page-level）</h5><p>页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。<br>在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。</p><h5 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h5><ul><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；  </li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；    </li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。  </li></ul><p>适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</p><h3 id="二、表级锁定"><a href="#二、表级锁定" class="headerlink" title="二、表级锁定"></a>二、表级锁定</h3><p>在mysql中，MyISAM引擎使用的锁定机制完全是mysql的表级锁定，下面将以MYISAM引擎作为示例</p><h5 id="1-MySQL表级锁的模式"><a href="#1-MySQL表级锁的模式" class="headerlink" title="1.MySQL表级锁的模式"></a>1.MySQL表级锁的模式</h5><blockquote><p>MySQL的表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。  </p></blockquote><ul><li>兼容性：  <ul><li>对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；  </li><li>对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；  </li><li>MyISAM表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。</li></ul></li></ul><h5 id="2-加锁"><a href="#2-加锁" class="headerlink" title="2.加锁"></a>2.加锁</h5><blockquote><p>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。</p></blockquote><h5 id="3-MyISAM锁的优化"><a href="#3-MyISAM锁的优化" class="headerlink" title="3.MyISAM锁的优化"></a>3.MyISAM锁的优化</h5><blockquote><p>对于MyISAM存储引擎，虽然使用表级锁定在锁定实现的过程中比实现行级锁定或者页级锁所带来的附加成本都要小，锁定本身所消耗的资源也是最少。但是由于锁定的颗粒度比较到，所以造成锁定资源的争用情况也会比其他的锁定级别都要多，从而在较大程度上会降低并发处理能力。所以，在优化MyISAM存储引擎锁定问题的时候，最关键的就是如何让其提高并发度。由于锁定级别是不可能改变的了，所以我们首先需要尽可能让锁定的时间变短，然后就是让可能并发进行的操作尽可能的并发。</p></blockquote><ul><li>（1）查询表锁争用情况</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like &apos;table%&apos;;</span><br><span class="line">+----------------------------+---------+</span><br><span class="line">| Variable_name              | Value   |</span><br><span class="line">+----------------------------+---------+</span><br><span class="line">| Table_locks_immediate      | 100     |</span><br><span class="line">| Table_locks_waited         | 11      |</span><br><span class="line">+----------------------------+---------+</span><br></pre></td></tr></table></figure><p>这里有两个状态变量记录MySQL内部表级锁定的情况，两个变量说明如下：</p><ul><li>Table_locks_immediate：产生表级锁定的次数;  </li><li>Table_locks_waited：出现表级锁定争用而发生等待的次数；</li></ul><p>两个状态值都是从系统启动后开始记录，出现一次对应的事件则数量加1。如果这里的Table_locks_waited状态值比较高，那么说明系统中表级锁定争用现象比较严重，就需要进一步分析为什么会有较多的锁定资源争用了</p><ul><li>（2）缩短锁定时间</li></ul><p>如何让锁定时间尽可能的短呢？唯一的办法就是让我们的Query执行时间尽可能的短。</p><pre><code>+ a)尽两减少大的复杂Query，将复杂Query分拆成几个小的Query分布进行；  + b)尽可能的建立足够高效的索引，让数据检索更迅速；  + c)尽量让MyISAM存储引擎的表只存放必要的信息，控制字段类型；  + d)利用合适的机会优化MyISAM表数据文件</code></pre><ul><li>(3)分离并行的操作</li></ul>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL两种存储引擎- MyISAM和InnoDB 简单总结</title>
      <link href="/2019/05/03/MySQL%E4%B8%A4%E7%A7%8D%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%20MyISAM%E5%92%8CInnoDB%20%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
      <url>/2019/05/03/MySQL%E4%B8%A4%E7%A7%8D%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%20MyISAM%E5%92%8CInnoDB%20%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<ul><li><p>MyISAM是MySQL的默认数据库引擎（5.5版之前），由早期的ISAM（Indexed Sequential Access Method：有索引的顺序访问方法）所改良。虽然性能极佳，但却有一个缺点：不支持事务处理（transaction）。不过，在这几年的发展下，MySQL也导入了InnoDB（另一种数据库引擎），以强化参考完整性与并发违规处理机制，后来就逐渐取代MyISAM。</p></li><li><p>InnoDB，是MySQL的数据库引擎之一，为MySQL AB发布binary的标准之一。InnoDB由Innobase Oy公司所开发，2006年五月时由甲骨文公司并购。与传统的ISAM与MyISAM相比，InnoDB的最大特色就是支持了ACID兼容的事务（Transaction）功能，类似于PostgreSQL。目前InnoDB采用双轨制授权，一是GPL授权，另一是专有软件授权。</p></li></ul><a id="more"></a><p>MyISAM和InnoDB两者之间有着明显区别，简单梳理如下:</p><h5 id="1-事务支持"><a href="#1-事务支持" class="headerlink" title="1) 事务支持"></a>1) 事务支持</h5><p>MyISAM不支持事务，而InnoDB支持。InnoDB的AUTOCOMMIT默认是打开的，即每条SQL语句会默认被封装成一个事务，自动提交，这样会影响速度，所以最好是把多条SQL语句显示放在begin和commit之间，组成一个事务去提交。</p><p>MyISAM是非事务安全型的，而InnoDB是事务安全型的，默认开启自动提交，宜合并事务，一同提交，减小数据库多次提交导致的开销，大大提高性能。</p><h5 id="2-存储结构"><a href="#2-存储结构" class="headerlink" title="2) 存储结构"></a>2) 存储结构</h5><p>MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。</p><p>InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</p><h5 id="3-存储空间"><a href="#3-存储空间" class="headerlink" title="3) 存储空间"></a>3) 存储空间</h5><p>MyISAM：可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。</p><p>InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。</p><h5 id="4-可移植性、备份及恢复"><a href="#4-可移植性、备份及恢复" class="headerlink" title="4) 可移植性、备份及恢复"></a>4) 可移植性、备份及恢复</h5><p>MyISAM：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。</p><p>InnoDB：免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。</p><h5 id="5-事务支持"><a href="#5-事务支持" class="headerlink" title="5) 事务支持"></a>5) 事务支持</h5><p>MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。</p><p>InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</p><h5 id="6-AUTO-INCREMENT"><a href="#6-AUTO-INCREMENT" class="headerlink" title="6) AUTO_INCREMENT"></a>6) AUTO_INCREMENT</h5><p>MyISAM：可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。</p><p>InnoDB：InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。</p><h5 id="7-表锁差异"><a href="#7-表锁差异" class="headerlink" title="7) 表锁差异"></a>7) 表锁差异</h5><p>MyISAM：只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。</p><p>InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</p><p>MyISAM锁的粒度是表级，而InnoDB支持行级锁定。简单来说就是, InnoDB支持数据行锁定，而MyISAM不支持行锁定，只支持锁定整个表。即MyISAM同一个表上的读锁和写锁是互斥的，MyISAM并发读写时如果等待队列中既有读请求又有写请求，默认写请求的优先级高，即使读请求先到，所以MyISAM不适合于有大量查询和修改并存的情况，那样查询进程会长时间阻塞。因为MyISAM是锁表，所以某项读操作比较耗时会使其他写进程饿死。</p><h5 id="8-全文索引"><a href="#8-全文索引" class="headerlink" title="8) 全文索引"></a>8) 全文索引</h5><p>MyISAM：支持(FULLTEXT类型的)全文索引</p><p>InnoDB：不支持(FULLTEXT类型的)全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。</p><p>全文索引是指对char、varchar和text中的每个词（停用词除外）建立倒排序索引。MyISAM的全文索引其实没啥用，因为它不支持中文分词，必须由使用者分词后加入空格再写到数据表里，而且少于4个汉字的词会和停用词一样被忽略掉。</p><blockquote><p>另外，MyIsam索引和数据分离，InnoDB在一起，MyIsam天生非聚簇索引，最多有一个unique的性质，InnoDB的数据文件本身就是主键索引文件，这样的索引被称为“聚簇索引”</p></blockquote><h5 id="9-表主键"><a href="#9-表主键" class="headerlink" title="9) 表主键"></a>9) 表主键</h5><p>MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。</p><p>InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。InnoDB的主键范围更大，最大是MyISAM的2倍。</p><h5 id="10-表的具体行数"><a href="#10-表的具体行数" class="headerlink" title="10) 表的具体行数"></a>10) 表的具体行数</h5><p>MyISAM：保存有表的总行数，如果select count(*) from table;会直接取出出该值。</p><p>InnoDB：没有保存表的总行数(只能遍历)，如果使用select count(*) from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。</p><h5 id="11-CURD操作"><a href="#11-CURD操作" class="headerlink" title="11) CURD操作"></a>11) CURD操作</h5><p>MyISAM：如果执行大量的SELECT，MyISAM是更好的选择。</p><p>InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。</p><h5 id="12-外键"><a href="#12-外键" class="headerlink" title="12) 外键"></a>12) 外键</h5><p>MyISAM：不支持</p><p>InnoDB：支持</p><h5 id="13-查询效率"><a href="#13-查询效率" class="headerlink" title="13) 查询效率"></a>13) 查询效率</h5><p>没有where的count(<em>)使用MyISAM要比InnoDB快得多。因为MyISAM内置了一个计数器，count(</em>)时它直接从计数器中读，而InnoDB必须扫描全表。所以在InnoDB上执行count(<em>)时一般要伴随where，且where中要包含主键以外的索引列。为什么这里特别强调“主键以外”？因为InnoDB中primary index是和raw data存放在一起的，而secondary index则是单独存放，然后有个指针指向primary key。所以只是count(</em>)的话使用secondary index扫描更快，而primary key则主要在扫描索引同时要返回raw data时的作用较大。MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM。</p><p>通过上述的分析，基本上可以考虑使用InnoDB来替代MyISAM引擎了，原因是InnoDB自身很多良好的特点，比如事务支持、存储 过程、视图、行级锁定等等，在并发很多的情况下，相信InnoDB的表现肯定要比MyISAM强很多。另外，任何一种表都不是万能的，只用恰当的针对业务类型来选择合适的表类型，才能最大的发挥MySQL的性能优势。如果不是很复杂的Web应用，非关键应用，还是可以继续考虑MyISAM的，这个具体情况可以自己斟酌。</p><h3 id="MyISAM和InnoDB两者的应用场景："><a href="#MyISAM和InnoDB两者的应用场景：" class="headerlink" title="MyISAM和InnoDB两者的应用场景："></a>MyISAM和InnoDB两者的应用场景：</h3><ul><li><p>1) MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。</p></li><li><p>2) InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。</p></li></ul><p>但是实际场景中，针对具体问题需要具体分析，一般而言可以遵循以下几个问题：</p><ul><li>数据库是否有外键？</li><li>是否需要事务支持？</li><li>是否需要全文索引？</li><li>数据库经常使用什么样的查询模式？在写多读少的应用中还是Innodb插入性能更稳定，在并发情况下也能基本，如果是对读取速度要求比较快的应用还是选MyISAM。</li><li>数据库的数据有多大？ 大尺寸倾向于innodb，因为事务日志，故障恢复。</li></ul>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL索引优化策略与笔记</title>
      <link href="/2019/04/29/MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5%E4%B8%8E%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/04/29/MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5%E4%B8%8E%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>面试知识，数据库索引优化</p><h4 id="什么问题？"><a href="#什么问题？" class="headerlink" title="什么问题？"></a>什么问题？</h4><pre><code>索引有什么代价？哪些场景下你需要建索引？或者有时候反过来问，哪些场景下不推荐建索引。建好索引之后，怎么才能最高效地利用索引？或者反过来问，请说出一个无法有效利用已建索引的案例。</code></pre><h4 id="索引的好处？"><a href="#索引的好处？" class="headerlink" title="索引的好处？"></a>索引的好处？</h4><blockquote><p>快速查询数据。</p></blockquote><a id="more"></a><h4 id="代价是什么？"><a href="#代价是什么？" class="headerlink" title="代价是什么？"></a>代价是什么？</h4><pre><code>索引需要占硬盘空间，这是空间方面的代价。一旦插入新的数据，就需要重新建索引，这是时间上的代价。</code></pre><h4 id="不同场景，不同对待。"><a href="#不同场景，不同对待。" class="headerlink" title="不同场景，不同对待。"></a>不同场景，不同对待。</h4><h5 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h5><blockquote><p>数据表规模不大，就几千行，即使不建索引，查询语句的返回时间也不长，这时建索引的意义就不大。当然，若就几千行，索引所占的空间也不多，所以这种情况下，顶多属于“性价比”不高。</p></blockquote><h4 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h4><blockquote><p> 某个商品表里有几百万条商品信息，同时每天会在一个时间点，往其中更新大概十万条左右的商品信息，现在用where语句查询特定商品时（比如where name = ‘XXX’）速度很慢。为了提升查询效率可以建索引，但当每天更新数据时，又会重建索引，这是要耗费时间的。这时就需要综合考虑，甚至可以在更新前删除索引，更新后再重建。</p></blockquote><h4 id="场景三"><a href="#场景三" class="headerlink" title="场景三"></a>场景三</h4><blockquote><p>因为在数据表里ID值都不相同，所以索引能发挥出比较大的作用。相反，如果某个字段重复率很高，如性别字段，或者某个字段大多数值是空（null），那么不建议对该字段建索引。</p></blockquote><h3 id="建立索引原则"><a href="#建立索引原则" class="headerlink" title="建立索引原则"></a>建立索引原则</h3><p>一定是有业务需求了才会建索引。比如在一个商品表里，我们经常要根据name做查询，如果没有索引，查询速度会很慢，这时就需要建索引。但在项目开发中，如果不经常根据商品编号查询，那么就没必要对编号建索引。</p><p>最后再强调一次，建索引是要付出代价的，没事别乱建着玩，同时在一个表上也不能建太多的索引。<br>具体的例子来看索引的正确用法</p><pre><code>语句一：select name from 商品表。不会用到索引，因为没有where语句。语句二：select * from 商品表 where name = ‘Java书’，会用到索引，如果项目里经常用到name来查询，且商品表的数据量很大，而name值的重复率又不高，那么建议建索引。语句三：select * from 商品表 where name like ‘Java%’ 这是个模糊查询，会用到索引，请大家记住，用like进行模糊查询时，如果第一个就是模糊的匹配符，比如where name like ‘%java’，那么在查询时不会走索引。在其他情况下，不论用了多少个%，也不论%的位置，只要不出现在第一个位置，那么都能用到索引。</code></pre><p>学生成绩表里有两个字段：姓名和成绩。现在对成绩这个整数类型的字段建索引。</p><pre><code>第一种情况，当数字型字段遇到非等值操作符时，无法用到索引。比如：</code></pre><p>​ select name from 学生成绩表 where 成绩&gt;95 , 一旦出现大于符号，就不能用到索引，为了用到索引，我们应该改一下SQL语句里的where从句：where 成绩 in (96,97,98,99,100)</p><pre><code>第二种情况，如果对索引字段进行了某种左值操作，那么无法用到索引。</code></pre><p>​ 能用到索引的写法：select name from 学生成绩表 where 成绩 = 60</p><p>​ 不能用到索引的写法：select name from 学生成绩表 where 成绩+40 = 100</p><pre><code>第三种情况，如果对索引字段进行了函数操作，那么无法用到索引。</code></pre><p>​ 比如SQL语句：select * from 商品表 where substr(name) = ‘J’，我们希望查询商品名首字母是J的记录，可一旦针对name使用函数，即使name字段上有索引，也无法用到。<br>​ </p><blockquote><p>非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据。</p></blockquote><p>不管以任何方式查询表， 最终都会利用主键通过聚集索引来定位到数据， 聚集索引（主键）是通往真实数据所在的唯一路径。</p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何处理负载、高并发问题</title>
      <link href="/2019/04/27/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%B4%9F%E8%BD%BD%E3%80%81%E9%AB%98%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/"/>
      <url>/2019/04/27/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%B4%9F%E8%BD%BD%E3%80%81%E9%AB%98%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>从低成本、高性能和高扩张性的角度来说有如下处理方案：</p><h5 id="1、HTML静态化"><a href="#1、HTML静态化" class="headerlink" title="1、HTML静态化"></a>1、HTML静态化</h5><p>其实大家都知道，效率最高、消耗最小的就是纯静态化的html页面，所以我们尽可能使我们的  网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。</p><h5 id="2、图片服务器分离"><a href="#2、图片服务器分离" class="headerlink" title="2、图片服务器分离"></a>2、图片服务器分离</h5><p>​    把图片单独存储，尽量减少图片等大流量的开销，可以放在一些相关的平台上，如骑牛等</p><a id="more"></a><h5 id="3、数据库集群和库表散列及缓存"><a href="#3、数据库集群和库表散列及缓存" class="headerlink" title="3、数据库集群和库表散列及缓存"></a>3、数据库集群和库表散列及缓存</h5><p>数据库的并发连接为100，一台数据库远远不够，可以从读写分离、主从复制，数据库集群方面来着手。另外尽量减少数据库的访问，可以使用缓存数据库如memcache、redis。</p><h5 id="4、镜像："><a href="#4、镜像：" class="headerlink" title="4、镜像："></a>4、镜像：</h5><p>   尽量减少下载，可以把不同的请求分发到多个镜像端。</p><h5 id="5、负载均衡："><a href="#5、负载均衡：" class="headerlink" title="5、负载均衡："></a>5、负载均衡：</h5><p>   Apache的最大并发连接为1500，只能增加服务器，可以从硬件上着手，如F5服务器。当然硬件的成本比较高，我们往往从软件方面着手。</p><p>   负载均衡 （Load Balancing） 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力，同时能够提高网络的灵活性和可用性。目前使用最为广泛的负载均衡软件是Nginx、LVS、HAProxy。我分别来说下三种的优缺点:</p><h5 id="Nginx的优点是："><a href="#Nginx的优点是：" class="headerlink" title="Nginx的优点是："></a>Nginx的优点是：</h5><ol><li><p>工作在网络的7层之上，可以针对http应用做一些分流的策略，比如针对域名、目录结构，它的正则规则比HAProxy更为强大和灵活，这也是它目前广泛流行的主要原因之一，Nginx单凭这点可利用的场合就远多于LVS了。 </p></li><li><p>Nginx对网络稳定性的依赖非常小，理论上能ping通就就能进行负载功能，这个也是它的优势之一；相反LVS对网络稳定性依赖比较大，这点本人深有体会； </p></li><li><p>Nginx安装和配置比较简单，测试起来比较方便，它基本能把错误用日志打印出来。LVS的配置、测试就要花比较长的时间了，LVS对网络依赖比较大。 </p></li><li><p>可以承担高负载压力且稳定，在硬件不差的情况下一般能支撑几万次的并发量，负载度比LVS相对小些。 </p></li><li><p>Nginx可以通过端口检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点，不过其中缺点就是不支持url来检测。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而不满。 </p></li><li><p>Nginx不仅仅是一款优秀的负载均衡器/反向代理软件，它同时也是功能强大的Web应用服务器。LNMP也是近几年非常流行的web架构，在高流量的环境中稳定性也很好。 </p></li><li><p>Nginx现在作为Web反向加速缓存越来越成熟了，速度比传统的Squid服务器更快，可以考虑用其作为反向代理加速器。 </p></li><li><p>Nginx可作为中层反向代理使用，这一层面Nginx基本上无对手，唯一可以对比Nginx的就只有 lighttpd了，不过 lighttpd目前还没有做到Nginx完全的功能，配置也不那么清晰易读，社区资料也远远没Nginx活跃。 </p></li><li><p>Nginx也可作为静态网页和图片服务器，这方面的性能也无对手。还有Nginx社区非常活跃，第三方模块也很多。</p></li></ol><h5 id="Nginx的缺点是："><a href="#Nginx的缺点是：" class="headerlink" title="Nginx的缺点是："></a>Nginx的缺点是：</h5><ol><li>Nginx仅能支持http、https和Email协议，这样就在适用范围上面小些，这个是它的缺点。</li><li>对后端服务器的健康检查，只支持通过端口来检测，不支持通过url来检测。不支持Session的直接保持，但能通过ip_hash来解决。</li></ol><h4 id="LVS：使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability-、可靠性（Reliability-和可管理性（Manageability-。"><a href="#LVS：使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability-、可靠性（Reliability-和可管理性（Manageability-。" class="headerlink" title="LVS：使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability)、可靠性（Reliability)和可管理性（Manageability)。"></a>LVS：使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability)、可靠性（Reliability)和可管理性（Manageability)。</h4><h5 id="LVS的优点是："><a href="#LVS的优点是：" class="headerlink" title="LVS的优点是："></a>LVS的优点是：</h5><ol><li>抗负载能力强、是工作在网络4层之上仅作分发之用，没有流量的产生，这个特点也决定了它在负载均衡软件里的性能最强的，对内存和cpu资源消耗比较低。</li><li>配置性比较低，这是一个缺点也是一个优点，因为没有可太多配置的东西，所以并不需要太多接触，大大减少了人为出错的几率。</li><li>工作稳定，因为其本身抗负载能力很强，自身有完整的双机热备方案，如LVS+Keepalived，不过我们在项目实施中用得最多的还是LVS/DR+Keepalived。</li><li>无流量，LVS只分发请求，而流量并不从它本身出去，这点保证了均衡器IO的性能不会受到大流量的影响。</li><li>应用范围比较广，因为LVS工作在4层，所以它几乎可以对所有应用做负载均衡，包括http、数据库、在线聊天室等等。</li></ol><h5 id="LVS的缺点是："><a href="#LVS的缺点是：" class="headerlink" title="LVS的缺点是："></a>LVS的缺点是：</h5><ol><li>软件本身不支持正则表达式处理，不能做动静分离；而现在许多网站在这方面都有较强的需求，这个是Nginx/HAProxy+Keepalived的优势所在。</li><li>如果是网站应用比较庞大的话，LVS/DR+Keepalived实施起来就比较复杂了，特别后面有 Windows Server的机器的话，如果实施及配置还有维护过程就比较复杂了，相对而言，Nginx/HAProxy+Keepalived就简单多了。</li></ol><h5 id="HAProxy的特点是："><a href="#HAProxy的特点是：" class="headerlink" title="HAProxy的特点是："></a>HAProxy的特点是：</h5><ol><li>HAProxy也是支持虚拟主机的。</li><li>HAProxy的优点能够补充Nginx的一些缺点，比如支持Session的保持，Cookie的引导；同时支持通过获取指定的url来检测后端服务器的状态。</li><li>HAProxy跟LVS类似，本身就只是一款负载均衡软件；单纯从效率上来讲HAProxy会比Nginx有更出色的负载均衡速度，在并发处理上也是优于Nginx的。</li><li>HAProxy支持TCP协议的负载均衡转发，可以对MySQL读进行负载均衡，对后端的MySQL节点进行检测和负载均衡，大家可以用LVS+Keepalived对MySQL主从做负载均衡。</li><li>HAProxy负载均衡策略非常多，HAProxy的负载均衡算法现在具体有如下8种：</li></ol><p>① roundrobin，表示简单的轮询，这个不多说，这个是负载均衡基本都具备的；<br>② static-rr，表示根据权重，建议关注；<br>③ leastconn，表示最少连接者先处理，建议关注；<br>④ source，表示根据请求源IP，这个跟Nginx的IP_hash机制类似，我们用其作为解决session问题的一种方法，建议关注；<br>⑤ ri，表示根据请求的URI；<br>⑥ rl_param，表示根据请求的URl参数’balance url_param’ requires an URL parametername；<br>⑦ hdr(name)，表示根据HTTP请求头来锁定每一次HTTP请求；<br>⑧ rdp-cookie(name)，表示根据据cookie(name)来锁定并哈希每一次TCP请求。</p><h5 id="Nginx和LVS对比的总结："><a href="#Nginx和LVS对比的总结：" class="headerlink" title="Nginx和LVS对比的总结："></a>Nginx和LVS对比的总结：</h5><ol><li><p>Nginx工作在网络的7层，所以它可以针对http应用本身来做分流策略，比如针对域名、目录结构等，相比之下LVS并不具备这样的功能，所以Nginx单凭这点可利用的场合就远多于LVS了；但Nginx有用的这些功能使其可调整度要高于LVS，所以经常要去触碰触碰，触碰多了，人为出问题的几率也就会大。   </p></li><li><p>Nginx对网络稳定性的依赖较小，理论上只要ping得通，网页访问正常，Nginx就能连得通，这是Nginx的一大优势！Nginx同时还能区分内外网，如果是同时拥有内外网的节点，就相当于单机拥有了备份线路；LVS就比较依赖于网络环境，目前来看服务器在同一网段内并且LVS使用direct方式分流，效果较能得到保证。另外注意，LVS需要向托管商至少申请多一个ip来做Visual IP，貌似是不能用本身的IP来做VIP的。要做好LVS管理员，确实得跟进学习很多有关网络通信方面的知识，就不再是一个HTTP那么简单了。</p></li><li><p>Nginx安装和配置比较简单，测试起来也很方便，因为它基本能把错误用日志打印出来。LVS的安装和配置、测试就要花比较长的时间了；LVS对网络依赖比较大，很多时候不能配置成功都是因为网络问题而不是配置问题，出了问题要解决也相应的会麻烦得多。 </p></li><li><p>Nginx也同样能承受很高负载且稳定，但负载度和稳定度差LVS还有几个等级：Nginx处理所有流量所以受限于机器IO和配置；本身的bug也还是难以避免的。 </p></li><li><p>Nginx可以检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点。目前LVS中 ldirectd也能支持针对服务器内部的情况来监控，但LVS的原理使其不能重发请求。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而恼火。 </p></li><li><p>Nginx对请求的异步处理可以帮助节点服务器减轻负载，假如使用 apache直接对外服务，那么出现很多的窄带链接时apache服务器将会占用大量内存而不能释放，使用多一个Nginx做apache代理的话，这些窄带链接会被Nginx挡住，apache上就不会堆积过多的请求，这样就减少了相当多的资源占用。这点使用squid也有相同的作用，即使squid本身配置为不缓存，对apache还是有很大帮助的。 </p></li><li><p>Nginx能支持http、https和email（email的功能比较少用），LVS所支持的应用在这点上会比Nginx更多。在使用上，一般最前端所采取的策略应是LVS，也就是DNS的指向应为LVS均衡器，LVS的优点令它非常适合做这个任务。重要的ip地址，最好交由LVS托管，比如数据库的 ip、webservice服务器的ip等等，这些ip地址随着时间推移，使用面会越来越大，如果更换ip则故障会接踵而至。所以将这些重要ip交给 LVS托管是最为稳妥的，这样做的唯一缺点是需要的VIP数量会比较多。Nginx可作为LVS节点机器使用，一是可以利用Nginx的功能，二是可以利用Nginx的性能。当然这一层面也可以直接使用squid，squid的功能方面就比Nginx弱不少了，性能上也有所逊色于Nginx。Nginx也可作为中层代理使用，这一层面Nginx基本上无对手，唯一可以撼动Nginx的就只有lighttpd了，不过lighttpd目前还没有能做到 Nginx完全的功能，配置也不那么清晰易读。另外，中层代理的IP也是重要的，所以中层代理也拥有一个VIP和LVS是最完美的方案了。具体的应用还得具体分析，如果是比较小的网站（日PV小于1000万），用Nginx就完全可以了，如果机器也不少，可以用DNS轮询，LVS所耗费的机器还是比较多的；大型网站或者重要的服务，机器不发愁的时候，要多多考虑利用LVS。</p></li></ol>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 高负载 </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MYSQL 事务处理常见有两种方法</title>
      <link href="/2019/04/26/MYSQL%20%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%B8%B8%E8%A7%81%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2019/04/26/MYSQL%20%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%B8%B8%E8%A7%81%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p> MYSQL在操作大量的数据或者比较重要的数据的时候，事务处理很重要，比如银行的转账，支付，等等，作为开发人员事务是必须的一步。</p><h5 id="1、用-BEGIN-ROLLBACK-COMMIT来实现"><a href="#1、用-BEGIN-ROLLBACK-COMMIT来实现" class="headerlink" title="1、用 BEGIN, ROLLBACK, COMMIT来实现"></a>1、用 BEGIN, ROLLBACK, COMMIT来实现</h5><ul><li>BEGIN 开始一个事务</li><li>ROLLBACK 事务回滚</li><li>COMMIT 事务确认</li></ul><a id="more"></a><h5 id="2、直接用-SET-来改变-MySQL-的自动提交模式"><a href="#2、直接用-SET-来改变-MySQL-的自动提交模式" class="headerlink" title="2、直接用 SET 来改变 MySQL 的自动提交模式:"></a>2、直接用 SET 来改变 MySQL 的自动提交模式:</h5><ul><li>SET AUTOCOMMIT=0 禁止自动提交</li><li>SET AUTOCOMMIT=1 开启自动提交</li></ul><blockquote><p>注意的是，在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</p></blockquote><p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p><h3 id="一、php事务处理概述："><a href="#一、php事务处理概述：" class="headerlink" title="一、php事务处理概述："></a>一、php事务处理概述：</h3><ul><li><p>事务:是若干事件的集合</p></li><li><p>事务处理:当所有事件执行成功,事务才执行;若有任何一个事件不能成功执行,事务的其它事件也不被执行。</p></li></ul><p>只要你的MySQL版本支持BDB或InnoDB表类型，那么你的MySQL就具有事务处理的能力。这里面，又以InnoDB表类型用的最多，虽然后来发生了诸如Oracle收购InnoDB等令MySQL不爽的事情，但是这类商业事件与技术无关，下面就以InnoDB表类型为例简单说一下MySQL中的事务处理。</p><h3 id="二、php事务处理代码："><a href="#二、php事务处理代码：" class="headerlink" title="二、php事务处理代码："></a>二、php事务处理代码：</h3><pre><code>&lt;?phptry{$pdo=new PDO(&quot;mysql:host=localhost;dbname=psp&quot;,&quot;root&quot;,&quot;&quot;);$pdo-&gt;exec(&quot;set names utf8&quot;);$pdo-&gt;setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_EXCEPTION);//设置异常处理模式$pdo-&gt;setAttribute(PDO::ATTR_AUTOCOMMIT,0);//关闭自动提交}catch(PDOException $e){echo &quot;数据库连接失败&quot;;exit;}try{$age=10;$pdo-&gt;beginTransaction();//开始事务$affected_rows1=$pdo-&gt;exec(&quot;update kfry set k_age=k_age+{$age} where k_name=&apos;user1&apos;&quot;);$affected_rows2=$pdo-&gt;exec(&quot;update kfry set k_age=k_age-{$age} where k_name=&apos;user2&apos;&quot;);//随意更改使之执行成功或失败/* if($affected_rows1&amp;&amp;$affected_rows2){$pdo-&gt;commit();echo &quot;操作成功&quot;;}else{$pdo-&gt;rollback();} */if(!$affected_rows1)throw new PDOException(&quot;加入错误&quot;);if(!$affected_rows2)throw new PDOException(&quot;减少错误&quot;);echo &quot;操作成功&quot;;$pdo-&gt;commit();//如果执行到此处前面两个更新sql语句执行成功，整个事务执行成功}catch(PDOException $e){echo &quot;操作失败：&quot;.$e-&gt;getMessage();$pdo-&gt;rollback();//执行事务中的语句出了问题，整个事务全部撤销}$pdo-&gt;setAttribute(PDO::ATTR_AUTOCOMMIT,1);//测试是否成功echo &quot;\n操作结果为:\n&quot;;$sql=&quot;select * from kfry&quot;;$result=$pdo-&gt;query($sql);foreach($result as $v){echo $v[&apos;k_name&apos;].&quot; &quot;.$v[&apos;k_age&apos;].&quot;\n&quot;;}?&gt;</code></pre><p>以上就是php 事务处理详解的详细内容，更多请关注php中文网其它相关文章！</p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Web安全的一次探讨</title>
      <link href="/2019/03/13/Web%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%80%E6%AC%A1%E6%8E%A2%E8%AE%A8/"/>
      <url>/2019/03/13/Web%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%80%E6%AC%A1%E6%8E%A2%E8%AE%A8/</url>
      <content type="html"><![CDATA[<h3 id="一、SQL注入攻击-SQL-Injection"><a href="#一、SQL注入攻击-SQL-Injection" class="headerlink" title="一、SQL注入攻击(SQL Injection)"></a>一、SQL注入攻击(SQL Injection)</h3><p>攻击者把sql命令插入到web表单的输入域或页面请求的字符串，欺骗服务器执行恶意的sql命令。常见的sql注入攻击类似：</p><h5 id="登录页面中输入内容直接用来构造动态的sql语句，例如："><a href="#登录页面中输入内容直接用来构造动态的sql语句，例如：" class="headerlink" title="登录页面中输入内容直接用来构造动态的sql语句，例如："></a>登录页面中输入内容直接用来构造动态的sql语句，例如：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$query = &apos;select * from users where login = &apos;. $username. &apos;and password = &apos;. $password;</span><br></pre></td></tr></table></figure><a id="more"></a><p>攻击者如果在用户名或者密码框输入<code>or &#39;1&#39; =1</code>，这样我们执行的sql语句就变成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where login = &apos;&apos; or &apos;1&apos; = 1 and ...</span><br></pre></td></tr></table></figure><p>这样就绕过了我们的登录验证。类似的还有很多，用户通过输入恶意的sql命令来绕过我们的验证，欺骗我们的系统。</p><h5 id="防范的方法："><a href="#防范的方法：" class="headerlink" title="防范的方法："></a>防范的方法：</h5><ol><li>检查变量数据类型和格式</li><li>过滤特殊的符号</li><li>绑定变量，使用预处理语句（当我们绑定变量的时候，就算有特殊字符sql也会认为是个变量而不是sql命令）</li></ol><h3 id="二、跨站脚本攻击-Cross-Site-Scripting-XSS；因为CSS被用了所以叫XSS"><a href="#二、跨站脚本攻击-Cross-Site-Scripting-XSS；因为CSS被用了所以叫XSS" class="headerlink" title="二、跨站脚本攻击(Cross Site Scripting, XSS；因为CSS被用了所以叫XSS)"></a>二、跨站脚本攻击(Cross Site Scripting, XSS；因为CSS被用了所以叫XSS)</h3><p>攻击者将恶意代码注入到网页上，其他用户在加载网页时就会执行代码，攻击者可能会得到各种私密的信息，如cookie等。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    echo &apos;你好！&apos;.$_GET[&apos;name&apos;];</span><br></pre></td></tr></table></figure><p>如果用户传入一段脚本<code>&lt;script&gt;[code]&lt;/script&gt;</code>，那么脚本也会执行，如果code的内容是获取到cookie并发送到某个指定的位置，获取了敏感的信息。亦或是利用用户的身份去执行一些不正当的操作。</p><h5 id="防范的方法：-1"><a href="#防范的方法：-1" class="headerlink" title="防范的方法："></a>防范的方法：</h5><ol><li>输出的时候过滤特殊的字符，转换成html编码，过滤输出的变量（PHP可以使用htmlspecialchars）</li></ol><h3 id="三、跨站请求伪造攻击-Cross-Site-Request-Forgeries-CSRF"><a href="#三、跨站请求伪造攻击-Cross-Site-Request-Forgeries-CSRF" class="headerlink" title="三、跨站请求伪造攻击(Cross Site Request Forgeries, CSRF)"></a>三、跨站请求伪造攻击(Cross Site Request Forgeries, CSRF)</h3><p>攻击者伪造目标用户的HTTP请求，然后此请求发送到有CSRF漏洞的网站，网站执行此请求后，引发跨站请求伪造攻击。攻击者利用隐蔽的HTTP连接，让目标用户在不注意的情况下单击这个链接，由于是用户自己点击的，而他又是合法用户拥有合法权限，所以目标用户能够在网站内执行特定的HTTP链接，从而达到攻击者的目的。  </p><blockquote><p>  用户刚刚登陆了银行A网站，建立了会话，A网站可以进行转账操作<code>http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000</code>在没有退出的情况下去访问危险网站B网站，B网站有一个图片是这样的<code>&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;</code>，不小心点了B网站，用户发现账上少了1000块。  </p></blockquote><p>可能有人会说，修改操作并不会用get请求。那么假设银行A网站的表单如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;Transfer.php&quot; method=&quot;POST&quot;&gt;</span><br><span class="line">    &lt;p&gt;ToBankId: &lt;input type=&quot;text&quot; name=&quot;toBankId&quot; /&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;Money: &lt;input type=&quot;text&quot; name=&quot;money&quot; /&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Transfer&quot; /&gt;&lt;/p&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>后台处理页面如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">session_start();</span><br><span class="line">if (isset($_REQUEST[&apos;toBankId&apos;] &amp;&amp; isset($_POST[&apos;money&apos;]))</span><br><span class="line">&#123;</span><br><span class="line">    buy_stocks($_REQUEST[&apos;toBankId&apos;],$_REQUEST[&apos;money&apos;]);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>B网站这时候也相应的改了代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">　　　　&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">　　　　　　function steal()</span><br><span class="line">　　　　　　&#123;</span><br><span class="line">          　　　　 iframe = document.frames[&quot;steal&quot;];</span><br><span class="line">　　     　　      iframe.document.Submit(&quot;transfer&quot;);</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&lt;/script&gt;</span><br><span class="line">　　&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">　　&lt;body onload=&quot;steal()&quot;&gt;</span><br><span class="line">　　　　&lt;iframe name=&quot;steal&quot; display=&quot;none&quot;&gt;</span><br><span class="line">　　　　　　&lt;form method=&quot;POST&quot; name=&quot;transfer&quot;　action=&quot;http://www.myBank.com/Transfer.php&quot;&gt;</span><br><span class="line">　　　　　　　　&lt;input type=&quot;hidden&quot; name=&quot;toBankId&quot; value=&quot;11&quot;&gt;</span><br><span class="line">　　　　　　　　&lt;input type=&quot;hidden&quot; name=&quot;money&quot; value=&quot;1000&quot;&gt;</span><br><span class="line">　　　　　　&lt;/form&gt;</span><br><span class="line">　　　　&lt;/iframe&gt;</span><br><span class="line">　　&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>用户一点到B网站，发现又少了1000块…….</p><h5 id="防范方法："><a href="#防范方法：" class="headerlink" title="防范方法："></a>防范方法：</h5><ul><li>对表单进行cookie hash校验，将一个随机值的hash写入cookie，每次提交表单，都在服务端对这个hash进行校验（建立在用户的cookie没有被盗取）</li></ul><h3 id="四、Session固定攻击-Session-Fixation"><a href="#四、Session固定攻击-Session-Fixation" class="headerlink" title="四、Session固定攻击(Session Fixation)"></a>四、Session固定攻击(Session Fixation)</h3><p>攻击者预先设定session id，让合法用户使用这个session id来访问被攻击的应用程序，一旦用户的会话ID被成功固定，攻击者就可以通过此session id来冒充用户访问应用程序。例如：  </p><ol><li>攻击者先访问目标网站，获得了自己的session_id，如SID=123</li><li>攻击者给目标用户发送链接，并带上了自己的session_id，如<code>http:///www.bank.com/?SID=123</code>，</li><li>目标用户点击了<code>http:///www.bank.com/?SID=123</code>，输入用户名密码登录，由于session_id不会变更，那么攻击者就可以通过访问<code>http:///www.bank.com/?SID=123</code>来获取目标用户的身份。</li></ol><h5 id="防范方法：-1"><a href="#防范方法：-1" class="headerlink" title="防范方法："></a>防范方法：</h5><ol><li>定期更改session_id</li><li>更改session_id的名字</li></ol><h3 id="五、Session劫持-Session-Hijacking"><a href="#五、Session劫持-Session-Hijacking" class="headerlink" title="五、Session劫持(Session Hijacking)"></a>五、Session劫持(Session Hijacking)</h3><p>攻击者利用各种手段来获取目标用户的session id。一旦获取到session id，那么攻击者可以利用目标用户的身份来登录网站，获取目标用户的操作权限。</p><h5 id="攻击者获取目标用户session-id的方法"><a href="#攻击者获取目标用户session-id的方法" class="headerlink" title="攻击者获取目标用户session id的方法:"></a>攻击者获取目标用户session id的方法:</h5><ol><li>暴力破解:尝试各种session id，直到破解为止;</li><li>计算:如果session id使用非随机的方式产生，那么就有可能计算出来;</li><li>窃取:使用网络截获，xss攻击等方法获得<br>防范方法：</li><li>定期更改session id</li><li>更改session的名称</li><li>关闭透明化session id</li><li>设置HttpOnly。通过设置Cookie的HttpOnly为true，可以防止客户端脚本访问这个Cookie，从而有效的防止XSS攻击。</li></ol><h3 id="六、文件上传漏洞-File-Upload-Attack"><a href="#六、文件上传漏洞-File-Upload-Attack" class="headerlink" title="六、文件上传漏洞(File Upload Attack)"></a>六、文件上传漏洞(File Upload Attack)</h3><p>攻击者利用程序缺陷绕过系统对文件的验证与处理策略将恶意代码上传到服务器并获得执行服务器端命令的能力。  </p><h5 id="常用的攻击手段有："><a href="#常用的攻击手段有：" class="headerlink" title="常用的攻击手段有："></a>常用的攻击手段有：</h5><ol><li>上传Web脚本代码，Web容器解释执行上传的恶意脚本；</li><li>上传Flash跨域策略文件crossdomain.xml，修改访问权限(其他策略文件利用方式类似)；</li><li>上传病毒、木马文件，诱骗用户和管理员下载执行；</li><li>上传包含脚本的图片，某些浏览器的低级版本会执行该脚本，用于钓鱼和欺诈。<br>总的来说，利用的上传文件要么具备可执行能力(恶意代码)，要么具备影响服务器行为的能力(配置文件)。<br>防范方法：  </li><li>文件上传的目录设置为不可执行；</li><li>判断文件类型，设置白名单。对于图片的处理，可以使用压缩函数或者resize函数，在处理图片的同时破坏图片中可能包含的HTML代码；</li><li>使用随机数改写文件名和文件路径：一个是上传后无法访问；再来就是像shell、.php 、.rar和crossdomain.xml这种文件，都将因为重命名而无法攻击；</li><li>单独设置文件服务器的域名：由于浏览器同源策略的关系，一系列客户端攻击将失效，比如上传crossdomain.xml、上传包含Javascript的XSS利用等问题将得到解决。</li></ol><h3 id="MYSQL安全"><a href="#MYSQL安全" class="headerlink" title="MYSQL安全"></a>MYSQL安全</h3><ol><li>使用预处理语句防止sql注入</li><li>写入数据库的数据要进行特殊字符转义</li><li>查询的错误信息不要返回给用户，将错误记录到日志   </li><li>定期做数据库备份</li><li>不给查询用户root权限，合理分配权限</li><li>关闭远程访问数据库的权限</li></ol>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于mysql最左前缀原则</title>
      <link href="/2019/03/01/%E5%85%B3%E4%BA%8Emysql%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99/"/>
      <url>/2019/03/01/%E5%85%B3%E4%BA%8Emysql%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99/</url>
      <content type="html"><![CDATA[<h4 id="背景知识："><a href="#背景知识：" class="headerlink" title="背景知识："></a>背景知识：</h4><ol><li>mysql中可以使用explain关键字来查看sql语句的执行计划。</li><li>最左前缀原则主要使用在联合索引中</li><li>数据库版本Mysql5.5.53</li></ol><a id="more"></a><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>mysql建立多列索引（联合索引）有最左前缀的原则，即最左优先，如：</p><ul><li>如果有一个2列的索引(col1,col2),则已经对(col1)、(col1,col2)上建立了索引；</li><li>如果有一个3列索引(col1,col2,col3)，则已经对(col1)、(col1,col2)、(col1,col2,col3)上建立了索引；</li></ul><p>1、b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+树是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道第一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。</p><p>2、比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。（这种情况无法用到联合索引）</p><p>关于最左前缀的使用，有下面两条说明：</p><ul><li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a  = 1 and b = 2 and c &gt; 3 and d = 4  如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li><li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li></ul><p>联合索引有一个最左前缀原则，所以建立联合索引的时候，这个联合索引的字段顺序非常重要</p><p>下面写了例子说明这个：</p><pre><code>CREATE TABLE `test_myisam` (`id` int(11) NOT NULL AUTO_INCREMENT,`conference_id` varchar(200) NOT NULL,`account` varchar(100) DEFAULT NULL,`status` int(2) DEFAULT NULL COMMENT &apos;0:invite,  1:cancel_invite,  2:decline,  3:connect&apos;,`duration` bigint(20) unsigned DEFAULT NULL,`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,PRIMARY KEY (`id`)) ENGINE=myisam AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</code></pre><p>以上表结构，我想通过三列进行查询 account ,status,create_time进行查询统计。</p><h5 id="如何建立索引？"><a href="#如何建立索引？" class="headerlink" title="如何建立索引？"></a>如何建立索引？</h5><p>因为我们有可能按照acccount单独统计，或者按照account status，或者是account，status，create_time进行统计，如何建立索引？？？</p><p>下面是建立索引前后的对比600万数据</p><p>如何生成：执行如下脚本，account和日期不同还有status不同，分别生成一百万。</p><pre><code>CREATE  PROCEDURE `add_data_myisam_cp_27`()begindeclare v_rows int(10) default 1000000;declare v_count int(10) default 0;id_loop:LOOPinsert into test_myisam values(null,round(rand()*1000000000),&apos;cloudp&apos;,round(rand()*3),round(rand()*100000),&apos;2016-07-27 00:00:22&apos;);set v_count= v_count + 1;if v_count&gt;v_rows thenleave id_loop;end if;end loop id_loop;end;</code></pre><p>测试结果利用建立的索引性能提高了三倍：</p><pre><code>MariaDB [prf]&gt; select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and date(create_time)=&apos;2016-07-27&apos;;+----------+| count(1) |+----------+|   167400 |+----------+1 row in set (1.28 sec)MariaDB [prf]&gt; create index as_index on test_myisam(account,status,create_time);Query OK, 6000006 rows affected (31.60 sec)Records: 6000006  Duplicates: 0  Warnings: 0MariaDB [prf]&gt; select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and date(create_time)=&apos;2016-07-27&apos;;+----------+| count(1) |+----------+|   167400 |+----------+1 row in set (0.42 sec)MariaDB [prf]&gt; explain select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and date(create_time)=&apos;2016-07-27&apos;;+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+| id   | select_type | table       | type | possible_keys | key      | key_len | ref         | rows   | Extra                    |+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+|    1 | SIMPLE      | test_myisam | ref  | as_index      | as_index | 308     | const,const | 520216 | Using where; Using index |+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+1 row in set (0.00 sec)</code></pre><p>从1.28秒下降到0.42秒<br>但是这个date(create_time)会对每一列都会转换后对比，这里会比较消耗性能；</p><h5 id="如何利用上索引？？"><a href="#如何利用上索引？？" class="headerlink" title="如何利用上索引？？"></a>如何利用上索引？？</h5><p>修改为：</p><pre><code>MariaDB [prf]&gt; explain select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and date(create_time)=&apos;2016-07-27&apos;;+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+| id   | select_type | table       | type | possible_keys | key      | key_len | ref         | rows   | Extra                    |+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+|    1 | SIMPLE      | test_myisam | ref  | as_index      | as_index | 308     | const,const | 520216 | Using where; Using index |+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+1 row in set (0.00 sec)MariaDB [prf]&gt; select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and create_time  between &apos;2016-07-27&apos; and &apos;2016-07-28&apos;;+----------+| count(1) |+----------+|   167400 |+----------+1 row in set (0.15 sec)MariaDB [prf]&gt; explain select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and create_time  between &apos;2016-07-27&apos; and &apos;2016-07-28&apos;;+------+-------------+-------------+-------+---------------+----------+---------+------+--------+--------------------------+| id   | select_type | table       | type  | possible_keys | key      | key_len | ref  | rows   | Extra                    |+------+-------------+-------------+-------+---------------+----------+---------+------+--------+--------------------------+|    1 | SIMPLE      | test_myisam | range | as_index      | as_index | 312     | NULL | 174152 | Using where; Using index |+------+-------------+-------------+-------+---------------+----------+---------+------+--------+--------------------------+1 row in set (0.00 sec)</code></pre><p>如上效率又提高了三倍，是因为扫描的数据行数减少了，最后一个create_time如果不用索引需要扫描52016行，如果使用了索引扫描174152行，命中的行数为：167400行，命中率非常高了。</p><h5 id="这里有个疑问："><a href="#这里有个疑问：" class="headerlink" title="这里有个疑问："></a>这里有个疑问：</h5><blockquote><p> 如果按照天进行统计，create_time作为联合索引的第一列，如何使用上这个索引呢？？？？</p></blockquote><p>至今没有想清楚，如果这一列是date类型可以直接用上索引，如果在oracle中可以date(create_time)建立函数式索引。但是mysql貌似不支持函数式索引。</p><h5 id="一个解决方式是："><a href="#一个解决方式是：" class="headerlink" title="一个解决方式是："></a>一个解决方式是：</h5><blockquote><p>create_time定义为 date类型，在每一列存入的时候，通过触发器自动把这一行修改为date类型。</p></blockquote><p>如果有好的注意欢迎留言探讨，目前没有好的方式加上create_time，可以从业务上解决，就是每天的统计计算完成以后，直接把数据推到历史表中，统计结果单独存放。</p><h5 id="最后说一下关于索引失效的问题："><a href="#最后说一下关于索引失效的问题：" class="headerlink" title="最后说一下关于索引失效的问题："></a>最后说一下关于索引失效的问题：</h5><ol><li>如果条件中有or，即使其中有条件带索引也不会使用(<strong>这也是为什么尽量少用or的原因</strong>)。<strong>注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引</strong></li><li>对于多列索引，不是使用的第一部分，则不会使用索引（即不符合最左前缀原则）</li><li>like查询是以%开头</li><li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引</li><li>如果mysql估计使用全表扫描要比使用索引快,则不使用索引</li></ol><h6 id="此外，查看索引的使用情况"><a href="#此外，查看索引的使用情况" class="headerlink" title="此外，查看索引的使用情况"></a>此外，查看索引的使用情况</h6><ul><li><p>show status like ‘Handler_read%’;</p></li><li><p>handler_read_key:这个值越高越好，越高表示使用索引查询到的次数</p></li><li>handler_read_rnd_next:这个值越高，说明查询低效</li></ul>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 最佳左前缀 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>高并发大流解决量方案</title>
      <link href="/2019/02/17/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%A4%A7%E6%B5%81%E8%A7%A3%E5%86%B3%E9%87%8F%E6%96%B9%E6%A1%88/"/>
      <url>/2019/02/17/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%A4%A7%E6%B5%81%E8%A7%A3%E5%86%B3%E9%87%8F%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><ul><li>QPS:每秒钟请求或者查询的数量，通常是指每秒相应请求数（http）<ul><li>QPS不等于并发连接数，QPS是每秒的HTTP请求数量，并发连接数是指系统同时处理的请求数量  </li><li>峰值的每秒请求数（QPS）= (总PV数 <em> 80%)/(6小时秒数 </em> 20%)  </li><li>峰值QPS的计算规律主要是80%的访问量集中在20%的访问时间</li></ul></li><li>吞吐量：单位时间内处理请求的数量</li><li>响应时间：从请求发出到收到响应花费的时间</li><li>PV(page view)综合浏览量，即页面点击数。通常日PV在千万级就是高并发的网站</li><li>UV(unique visitor)独立访客，一定时间内相同访客访问网站，只计算为1个独立访客</li></ul><a id="more"></a><ul><li><p>带宽：计算带宽大小，我们需要关注两个指标，峰值流量和平均大小</p><blockquote><p>日网站的带宽 = PV/统计时间（秒） <em> 平均页面大小（KB） </em> 8  </p></blockquote></li><li><p>压力测试</p><ul><li>1.测试能承受的最大并发  </li><li>2.测试最大承受QPS值  </li></ul></li></ul><h5 id="ab-apache-benchmark-工具使用"><a href="#ab-apache-benchmark-工具使用" class="headerlink" title="ab(apache benchmark)工具使用:"></a>ab(apache benchmark)工具使用:</h5><p>ab会创建多个并发访问线程，模拟多个访问者同时对一个URL地址进行访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ab的基本使用</span><br><span class="line">ab -c 100 -n 5000 url</span><br><span class="line">并发请求100次，总共5000次</span><br><span class="line"></span><br><span class="line">测试时注意被测试机器的CPU、内存、网络都不超过最高限度的75%</span><br></pre></td></tr></table></figure><p>此处介绍一些QPS的数值：</p><ol><li>50：小型网站，一般服务器即可应付</li><li>100：假设数据库每次请求都在0.01秒内完成，单个页面只有一个sql，100QPS意味着1秒钟要完成100次请求，但是我们数据库不一定能完成100次查询。此时优化方案为：数据库缓存、数据库负载均衡</li><li>800：假设网站有百兆带宽，意味着实际出口的带宽为8M左右，如果每个页面只有10K，在这个QPS下，带宽已经吃完。此时的方案：CDN加速，负载均衡</li><li>1000： 假设使用nosql来缓存数据库查询（memcache或redis），每个页面对nosql的请求远大于直接对DB的请求</li><li>2000： 业务分离，做分布式存储</li></ol><h3 id="二、优化方案"><a href="#二、优化方案" class="headerlink" title="二、优化方案"></a>二、优化方案</h3><ul><li>流量优化：  </li></ul><ol><li>防盗链处理 </li><li>减少前端http请求（合并css、js等静态资源）</li><li>添加异步请求，减少http请求的并发量</li><li>启用浏览器的缓存和使用文件压缩</li><li>CDN加速，减轻服务器压力和带宽压力<ul><li>服务端优化  </li></ul><ol><li>页面静态化</li><li>并发处理</li></ol><ul><li>数据库优化  </li></ul><ol><li>数据库缓存</li><li>分库分表，分区操作</li><li>读写分离</li><li>负载均衡</li></ol><ul><li>web服务器优化  </li></ul><ol><li>负载均衡</li></ol></li></ol>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入理解PHP之：Nginx 与 FPM 的工作机制</title>
      <link href="/2019/02/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E4%B9%8B%EF%BC%9ANginx-%E4%B8%8E-FPM-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/02/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E4%B9%8B%EF%BC%9ANginx-%E4%B8%8E-FPM-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>网络上有很多关于如何配置 Nginx + FPM 的文章，但它们更多从操作的角度出发，告诉我们怎么做，但却没有告诉我们为什么要这么做，本文从 Nginx 与 FPM 的工作机制出发，探讨配置背后的原理，让我们真正理解 Nginx 与 PHP 是如何协同工作的。</p><h4 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h4><p>要说 Nginx 与 PHP 是如何协同工作的，首先得说 CGI (Common Gateway Interface) 和 FastCGI 这两个协议。</p><a id="more"></a><blockquote><p>CGI 是 Web Server 与后台语言交互的协议，有了这个协议，开发者可以使用任何语言处理 Web Server 发来的请求，动态的生成内容。但 CGI 有一个致命的缺点，那就是每处理一个请求都需要 fork 一个全新的进程，随着 Web 的兴起，高并发越来越成为常态，这样低效的方式明显不能满足需求。就这样，FastCGI 诞生了，CGI 很快就退出了历史的舞台。FastCGI，顾名思义为更快的 CGI，它允许在一个进程内处理多个请求，而不是一个请求处理完毕就直接结束进程，性能上有了很大的提高。</p></blockquote><p>FPM (FastCGI Process Manager)，它是 FastCGI 的实现，任何实现了 FastCGI 协议的 Web Server 都能够与之通信。FPM 之于标准的 FastCGI，也提供了一些增强功能，具体可以参考官方文档：PHP: FPM Installation。</p><pre><code>FPM 是一个 PHP 进程管理器，包含 master 进程和 worker 进程两种进程：master 进程只有一个，负责监听端口，接收来自 Web Server 的请求，而 worker 进程则一般有多个 (具体数量根据实际需要配置)，每个进程内部都嵌入了一个 PHP 解释器，是 PHP 代码真正执行的地方，下图是我本机上 fpm 的进程情况，1一个 master 进程，3个 worker 进程：</code></pre><p><img src="http://img0.ph.126.net/WMv1Zu5I-rlmKMoUTc68-Q==/6631597730303787300.png" alt="fpm进程"></p><p>从 FPM 接收到请求，到处理完毕，其具体的流程如下：</p><pre><code>1. FPM 的 master 进程接收到请求2. master 进程根据配置指派特定的 worker进程进行请求处理，如果没有可用进程，返回错误，这也是我们配合 Nginx 遇到502错误比较多的原因。3. worker 进程处理请求，如果超时，返回504错误4. 请求处理结束，返回结果</code></pre><p>FPM 从接收到处理请求的流程就是这样了，那么 Nginx 又是如何发送请求给 fpm 的呢？这就需要从 Nginx 层面来说明了。</p><p>Nginx 不仅仅是一个 Web 服务器，也是一个功能强大的 Proxy 服务器，除了进行 http 请求的代理，也可以进行许多其他协议请求的代理，包括本文与 fpm 相关的 fastcgi 协议。为了能够使 Nginx 理解 fastcgi 协议，Nginx 提供了 fastcgi 模块来将 http 请求映射为对应的 fastcgi 请求。</p><blockquote><p>Nginx 的 fastcgi 模块提供了 fastcgi_param 指令来主要处理这些映射关系，下面 Ubuntu 下 Nginx 的一个配置文件，其主要完成的工作是将 Nginx 中的变量翻译成 PHP 中能够理解的变量。</p></blockquote><p><img src="http://img2.ph.126.net/QWqq90MIXEcQnTA7ft1WVg==/6631819831652599451.jpg" alt="fastcgi_param"></p><p>除此之外，非常重要的就是 fastcgi_pass 指令了，这个指令用于指定 fpm 进程监听的地址，Nginx 会把所有的 php 请求翻译成 fastcgi 请求之后再发送到这个地址。下面一个简单的可以工作的 Nginx 配置文件：</p><p><img src="http://img0.ph.126.net/tLal8xnxIanLB_mfp2dHUQ==/6631751661931678563.jpg" alt="nginx配置"></p><p>在这个配置文件中，我们新建了一个虚拟主机，监听在 80 端口，Web 根目录为 /home/rf/projects/wordpress。然后我们通过 location 指令，将所有的以 .php 结尾的请求都交给 fastcgi 模块处理，从而把所有的 php 请求都交给了 fpm 处理，从而完成 Nginx 到 fpm 的闭环。</p><p>如此以来，Nginx 与 FPM 通信的整个流程应该比较清晰了吧。</p><ol><li>nginx是web服务器，提供http服务。</li><li>php代码需要php解析器解析。所以这里要有个nginx和php解析器通信的问题。就出现了一个fastcgi的协议来解决通信问题。</li></ol>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Nginx </tag>
            
            <tag> FPM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LVS负载均衡（LVS简介、三种工作模式、十种调度算法）</title>
      <link href="/2019/01/25/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%88LVS%E7%AE%80%E4%BB%8B%E3%80%81%E4%B8%89%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E3%80%81%E5%8D%81%E7%A7%8D%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%89/"/>
      <url>/2019/01/25/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%88LVS%E7%AE%80%E4%BB%8B%E3%80%81%E4%B8%89%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E3%80%81%E5%8D%81%E7%A7%8D%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="一、LVS简介"><a href="#一、LVS简介" class="headerlink" title="一、LVS简介"></a>一、LVS简介</h3><p>LVS（Linux Virtual Server）即Linux虚拟服务器，是由章文嵩博士主导的开源负载均衡项目，目前LVS已经被集成到Linux内核模块中。</p><p>该项目在Linux内核中实现了基于IP的数据请求负载均衡调度方案，终端互联网用户从外部访问公司的外部负载均衡服务器，终端用户的Web请求会发送给LVS调度器，调度器根据自己预设的算法决定将该请求发送给后端的某台Web服务器，比如，轮询算法可以将外部的请求平均分发给后端的所有服务器，终端用户访问LVS调度器虽然会被转发到后端真实的服务器，但如果真实服务器连接的是相同的存储，提供的服务也是相同的服务，最终用户不管是访问哪台真实服务器，得到的服务内容都是一样的，整个集群对用户而言都是透明的。</p><a id="more"></a><blockquote><p> 最后根据LVS工作模式的不同，真实服务器会选择不同的方式将用户需要的数据发送到终端用户，LVS工作模式分为NAT模式、TUN模式、以及DR模式。</p></blockquote><h3 id="二、三种工作模式的解析。"><a href="#二、三种工作模式的解析。" class="headerlink" title="二、三种工作模式的解析。"></a>二、三种工作模式的解析。</h3><h5 id="1、基于NAT的LVS模式负载均衡"><a href="#1、基于NAT的LVS模式负载均衡" class="headerlink" title="1、基于NAT的LVS模式负载均衡"></a>1、基于NAT的LVS模式负载均衡</h5><p> NAT（Network Address Translation）即网络地址转换，其作用是通过数据报头的修改，使得位于企业内部的私有IP地址可以访问外网，以及外部用用户可以访问位于公司内部的私有IP主机。VS/NAT工作模式拓扑结构如图2所示，LVS负载调度器可以使用两块网卡配置不同的IP地址，eth0设置为私钥IP与内部网络通过交换设备相互连接，eth1设备为外网IP与外部网络联通。</p><ul><li>第一步，用户通过互联网DNS服务器解析到公司负载均衡设备上面的外网地址，相对于真实服务器而言，LVS外网IP又称VIP（Virtual IP Address），用户通过访问VIP，即可连接后端的真实服务器（Real Server），而这一切对用户而言都是透明的，用户以为自己访问的就是真实服务器，但他并不知道自己访问的VIP仅仅是一个调度器，也不清楚后端的真实服务器到底在哪里、有多少真实服务器。</li><li>第二步，用户将请求发送至124.126.147.168，此时LVS将根据预设的算法选择后端的一台真实服务器（192.168.0.1~192.168.0.3），将数据请求包转发给真实服务器，并且在转发之前LVS会修改数据包中的目标地址以及目标端口，目标地址与目标端口将被修改为选出的真实服务器IP地址以及相应的端口。</li><li>第三步，真实的服务器将响应数据包返回给LVS调度器，调度器在得到响应的数据包后会将源地址和源端口修改为VIP及调度器相应的端口，修改完成后，由调度器将响应数据包发送回终端用户，另外，由于LVS调度器有一个连接Hash表，该表中会记录连接请求及转发信息，当同一个连接的下一个数据包发送给调度器时，从该Hash表中可以直接找到之前的连接记录，并根据记录信息选出相同的真实服务器及端口信息。</li></ul><h5 id="2、基于TUN的LVS负载均衡"><a href="#2、基于TUN的LVS负载均衡" class="headerlink" title="2、基于TUN的LVS负载均衡"></a>2、基于TUN的LVS负载均衡</h5><p>在LVS（NAT）模式的集群环境中，由于所有的数据请求及响应的数据包都需要经过LVS调度器转发，如果后端服务器的数量大于10台，则调度器就会成为整个集群环境的瓶颈。我们知道，数据请求包往往远小于响应数据包的大小。因为响应数据包中包含有客户需要的具体数据，所以LVS（TUN）的思路就是将请求与响应数据分离，让调度器仅处理数据请求，而让真实服务器响应数据包直接返回给客户端。</p><p>VS/TUN工作模式拓扑结构如图3所示。其中，IP隧道（IP tunning）是一种数据包封装技术，它可以将原始数据包封装并添加新的包头（内容包括新的源地址及端口、目标地址及端口），从而实现将一个目标为调度器的VIP地址的数据包封装，通过隧道转发给后端的真实服务器（Real Server），通过将客户端发往调度器的原始数据包封装，并在其基础上添加新的数据包头（修改目标地址为调度器选择出来的真实服务器的IP地址及对应端口），LVS（TUN）模式要求真实服务器可以直接与外部网络连接，真实服务器在收到请求数据包后直接给客户端主机响应数据。</p><h5 id="3、基于DR的LVS负载均衡"><a href="#3、基于DR的LVS负载均衡" class="headerlink" title="3、基于DR的LVS负载均衡"></a>3、基于DR的LVS负载均衡</h5><p>在LVS（TUN）模式下，由于需要在LVS调度器与真实服务器之间创建隧道连接，这同样会增加服务器的负担。与LVS（TUN）类似，DR模式也叫直接路由模式，其体系结构如图4所示，该模式中LVS依然仅承担数据的入站请求以及根据算法选出合理的真实服务器，最终由后端真实服务器负责将响应数据包发送返回给客户端。与隧道模式不同的是，直接路由模式（DR模式）要求调度器与后端服务器必须在同一个局域网内，VIP地址需要在调度器与后端所有的服务器间共享，因为最终的真实服务器给客户端回应数据包时需要设置源IP为VIP地址，目标IP为客户端IP，这样客户端访问的是调度器的VIP地址，回应的源地址也依然是该VIP地址（真实服务器上的VIP），客户端是感觉不到后端服务器存在的。由于多台计算机都设置了同样一个VIP地址，所以在直接路由模式中要求调度器的VIP地址是对外可见的，客户端需要将请求数据包发送到调度器主机，而所有的真实服务器的VIP地址必须配置在Non-ARP的网络设备上，也就是该网络设备并不会向外广播自己的MAC及对应的IP地址，真实服务器的VIP对外界是不可见的，但真实服务器却可以接受目标地址VIP的网络请求，并在回应数据包时将源地址设置为该VIP地址。调度器根据算法在选出真实服务器后，在不修改数据报文的情况下，将数据帧的MAC地址修改为选出的真实服务器的MAC地址，通过交换机将该数据帧发给真实服务器。整个过程中，真实服务器的VIP不需要对外界可见。</p><h3 id="三、LVS负载均衡调度算法"><a href="#三、LVS负载均衡调度算法" class="headerlink" title="三、LVS负载均衡调度算法"></a>三、LVS负载均衡调度算法</h3><p>根据前面的介绍，我们了解了LVS的三种工作模式，但不管实际环境中采用的是哪种模式，调度算法进行调度的策略与算法都是LVS的核心技术，LVS在内核中主要实现了一下十种调度算法。</p><h5 id="1-轮询调度"><a href="#1-轮询调度" class="headerlink" title="1.轮询调度"></a>1.轮询调度</h5><p>轮询调度（Round Robin 简称’RR’）算法就是按依次循环的方式将请求调度到不同的服务器上，该算法最大的特点就是实现简单。轮询算法假设所有的服务器处理请求的能力都一样的，调度器会将所有的请求平均分配给每个真实服务器。</p><h5 id="2-加权轮询调度"><a href="#2-加权轮询调度" class="headerlink" title="2.加权轮询调度"></a>2.加权轮询调度</h5><p>加权轮询（Weight Round Robin 简称’WRR’）算法主要是对轮询算法的一种优化与补充，LVS会考虑每台服务器的性能，并给每台服务器添加一个权值，如果服务器A的权值为1，服务器B的权值为2，则调度器调度到服务器B的请求会是服务器A的两倍。权值越高的服务器，处理的请求越多。</p><h5 id="3-最小连接调度"><a href="#3-最小连接调度" class="headerlink" title="3.最小连接调度"></a>3.最小连接调度</h5><p>最小连接调度（Least Connections 简称’LC’）算法是把新的连接请求分配到当前连接数最小的服务器。最小连接调度是一种动态的调度算法，它通过服务器当前活跃的连接数来估计服务器的情况。调度器需要记录各个服务器已建立连接的数目，当一个请求被调度到某台服务器，其连接数加1；当连接中断或者超时，其连接数减1。</p><p>（集群系统的真实服务器具有相近的系统性能，采用最小连接调度算法可以比较好地均衡负载。)</p><h5 id="4-加权最小连接调度"><a href="#4-加权最小连接调度" class="headerlink" title="4.加权最小连接调度"></a>4.加权最小连接调度</h5><p>加权最少连接（Weight Least Connections 简称’WLC’）算法是最小连接调度的超集，各个服务器相应的权值表示其处理性能。服务器的缺省权值为1，系统管理员可以动态地设置服务器的权值。加权最小连接调度在调度新连接时尽可能使服务器的已建立连接数和其权值成比例。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。</p><h5 id="5-基于局部的最少连接"><a href="#5-基于局部的最少连接" class="headerlink" title="5.基于局部的最少连接"></a>5.基于局部的最少连接</h5><p>基于局部的最少连接调度（Locality-Based Least Connections 简称’LBLC’）算法是针对请求报文的目标IP地址的 负载均衡调度，目前主要用于Cache集群系统，因为在Cache集群客户请求报文的目标IP地址是变化的。这里假设任何后端服务器都可以处理任一请求，算法的设计目标是在服务器的负载基本平衡情况下，将相同目标IP地址的请求调度到同一台服务器，来提高各台服务器的访问局部性和Cache命中率，从而提升整个集群系统的处理能力。LBLC调度算法先根据请求的目标IP地址找出该目标IP地址最近使用的服务器，若该服务器是可用的且没有超载，将请求发送到该服务器；若服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则使用’最少连接’的原则选出一个可用的服务器，将请求发送到服务器。</p><h5 id="6-带复制的基于局部性的最少连接"><a href="#6-带复制的基于局部性的最少连接" class="headerlink" title="6.带复制的基于局部性的最少连接"></a>6.带复制的基于局部性的最少连接</h5><p>带复制的基于局部性的最少连接（Locality-Based Least Connections with Replication  简称’LBLCR’）算法也是针对目标IP地址的负载均衡，目前主要用于Cache集群系统，它与LBLC算法不同之处是它要维护从一个目标IP地址到一组服务器的映射，而LBLC算法维护从一个目标IP地址到一台服务器的映射。按’最小连接’原则从该服务器组中选出一一台服务器，若服务器没有超载，将请求发送到该服务器；若服务器超载，则按’最小连接’原则从整个集群中选出一台服务器，将该服务器加入到这个服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。</p><h5 id="7-目标地址散列调度"><a href="#7-目标地址散列调度" class="headerlink" title="7.目标地址散列调度"></a>7.目标地址散列调度</h5><p>目标地址散列调度（Destination Hashing 简称’DH’）算法先根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且并未超载，将请求发送到该服务器，否则返回空。</p><h5 id="8-源地址散列调度U"><a href="#8-源地址散列调度U" class="headerlink" title="8.源地址散列调度U"></a>8.源地址散列调度U</h5><p>源地址散列调度（Source Hashing  简称’SH’）算法先根据请求的源IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且并未超载，将请求发送到该服务器，否则返回空。它采用的散列函数与目标地址散列调度算法的相同，它的算法流程与目标地址散列调度算法的基本相似。</p><h5 id="9-最短的期望的延迟"><a href="#9-最短的期望的延迟" class="headerlink" title="9.最短的期望的延迟"></a>9.最短的期望的延迟</h5><p>最短的期望的延迟调度（Shortest Expected Delay 简称’SED’）算法基于WLC算法。举个例子吧，ABC三台服务器的权重分别为1、2、3 。那么如果使用WLC算法的话一个新请求进入时它可能会分给ABC中的任意一个。使用SED算法后会进行一个运算</p><p>A：（1+1）/1=2   B：（1+2）/2=3/2   C：（1+3）/3=4/3   就把请求交给得出运算结果最小的服务器。</p><h5 id="10-最少队列调度"><a href="#10-最少队列调度" class="headerlink" title="10.最少队列调度"></a>10.最少队列调度</h5><p>最少队列调度（Never Queue 简称’NQ’）算法，无需队列。如果有realserver的连接数等于0就直接分配过去，不需要在进行SED运算。</p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于流量优化方案</title>
      <link href="/2019/01/11/%E5%85%B3%E4%BA%8E%E6%B5%81%E9%87%8F%E4%BC%98%E5%8C%96/"/>
      <url>/2019/01/11/%E5%85%B3%E4%BA%8E%E6%B5%81%E9%87%8F%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h3 id="一、防盗链"><a href="#一、防盗链" class="headerlink" title="一、防盗链"></a>一、防盗链</h3><h5 id="盗链"><a href="#盗链" class="headerlink" title="盗链"></a>盗链</h5><blockquote><p>在自己的页面上展示一些并不在自己服务器上的内容。<br>获取他人服务器上的资源地址，绕过别人的资源展示页面，直接在自己的页面上向用户输出<br>防盗链则是防止别人通过技术手段盗取本站的资源，让不是本站展示的资源链接失效</p></blockquote><a id="more"></a><h5 id="防盗链原理："><a href="#防盗链原理：" class="headerlink" title="防盗链原理："></a>防盗链原理：</h5><p>通过referer或者签名（在资源地址后面带上一串签名，每次收到请求验证签名），网站可以检测目标访问的来源网页，如果是资源文件，则可以跟踪到他显示的网页地址。一旦检测到来源不是本站则进行组织或者返回指定页面。</p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><blockquote><p>Referer</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Nginx模块 ngx_http_referer_module 用来阻挡来源非法的域名请求</span><br><span class="line">Nginx指令 valid_referers 全局变量$invalid_referer</span><br><span class="line"></span><br><span class="line">valid_referers none|blocked|server_names|string....;</span><br><span class="line">none: referer 来源头部为空</span><br><span class="line">blocked: referer不为空，但是里面的值被代理或者防火墙删除了，这些值并不以http：//或者https://开头</span><br><span class="line">server_names: referer来源头部包含当前的server_names</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">location ~ .*\.(gif|jpeg|png|flv|swf|rar|zip)$</span><br><span class="line">&#123;</span><br><span class="line">    valid_referer none blocked haobin.com *.haobin.com;</span><br><span class="line">    if($invalid_referer)</span><br><span class="line">    &#123;</span><br><span class="line">        #return 403;</span><br><span class="line">        rewrite ^/http://www.haobin.com/403.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="如果有人伪造referer，可以通过签名的方法解决"><a href="#如果有人伪造referer，可以通过签名的方法解决" class="headerlink" title="如果有人伪造referer，可以通过签名的方法解决"></a>如果有人伪造referer，可以通过签名的方法解决</h5><blockquote><p>加密签名</p></blockquote><p>通过第三方模块HttpAccessKeyModule实现Nginx防盗链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">首先安装这个模块</span><br><span class="line">accesskey on|off    模块开关</span><br><span class="line">accesskey_hashmethod md5 | sha-1    指定签名加密方式</span><br><span class="line">accesskey_arg    GET参数的名称</span><br><span class="line">accesskey_signature     加密规则</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">location ~ .*\.(gif|jpeg|png|flv|swf|zip|rar)$</span><br><span class="line">&#123;</span><br><span class="line">    accesskey on;</span><br><span class="line">    accesskey_hashmethod md5;</span><br><span class="line">    accesskey_arg &quot;key&quot;;</span><br><span class="line">    accesskey_signature &quot;sign$remote_addr&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、减少HTTP请求"><a href="#二、减少HTTP请求" class="headerlink" title="二、减少HTTP请求"></a>二、减少HTTP请求</h3><h5 id="性能黄金法则："><a href="#性能黄金法则：" class="headerlink" title="性能黄金法则："></a>性能黄金法则：</h5><p>只有10%-20%的最终用户响应时间花在接受请求的HTML文档上，剩下的80%-90%时间花在HTML文档所引用的组件（图片、css、script等）进行的http请求上</p><h5 id="1-图片地图：允许在一个图片上关联多个url，目标的url选择取决于用户单击了图片上的哪个位置。"><a href="#1-图片地图：允许在一个图片上关联多个url，目标的url选择取决于用户单击了图片上的哪个位置。" class="headerlink" title="1.图片地图：允许在一个图片上关联多个url，目标的url选择取决于用户单击了图片上的哪个位置。"></a>1.图片地图：允许在一个图片上关联多个url，目标的url选择取决于用户单击了图片上的哪个位置。</h5><p>例如有五张图片，每张图片对应一个超链接。此时就产生了五个http请求，我们将五张图片合成为一张图片，然后以图片的位置定位超链接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">实现</span><br><span class="line">&lt;map&gt;</span><br><span class="line">    &lt;area&gt;&lt;/area&gt;</span><br><span class="line">    &lt;area&gt;&lt;/area&gt;</span><br><span class="line">    &lt;area&gt;&lt;/area&gt;</span><br><span class="line">    ........</span><br><span class="line">&lt;/map&gt;</span><br></pre></td></tr></table></figure><h5 id="2-CSS-Sprites（CSS-精灵）"><a href="#2-CSS-Sprites（CSS-精灵）" class="headerlink" title="2.CSS Sprites（CSS 精灵）"></a>2.CSS Sprites（CSS 精灵）</h5><p>通过使用合并图片，指定css的background-image和background-position来显示元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background-position属性</span><br><span class="line">background-position:x,y; x和y可以写正值也可以写负值，我们可以想象图片左上方(0,0)，以(0,0)坐标向右的是负数的x轴，以(0,0)坐标向下的是负数的y轴</span><br></pre></td></tr></table></figure><h5 id="3-合并脚本和样式表"><a href="#3-合并脚本和样式表" class="headerlink" title="3.合并脚本和样式表"></a>3.合并脚本和样式表</h5><h5 id="4-图片使用base64编码减少页面请求数"><a href="#4-图片使用base64编码减少页面请求数" class="headerlink" title="4.图片使用base64编码减少页面请求数"></a>4.图片使用base64编码减少页面请求数</h5><blockquote><p>采用Base64编码直接将图片嵌入网页当中</p></blockquote><h3 id="三、浏览器缓存和压缩技术"><a href="#三、浏览器缓存和压缩技术" class="headerlink" title="三、浏览器缓存和压缩技术"></a>三、浏览器缓存和压缩技术</h3><h5 id="1-HTTP缓存分类"><a href="#1-HTTP缓存分类" class="headerlink" title="1.HTTP缓存分类"></a>1.HTTP缓存分类</h5><blockquote><p>http缓存类型中，请求成功会有三种情况：</p></blockquote><pre><code>200 from cache：直接从本地缓存中获取相应，最快速，最省流量（network的size字段）  304 not modify： 协商缓存，浏览器在没有命中的情况下请求头中发送一定的校验数据到服务端，如果服务端没有改变，浏览器从本地缓存相应，返回304。 该方式，只返回一些基本的头信息，不发送实际的相应体200 ok： 以上两种缓存失败，服务器返回完整的相应。 该方式没有用到缓存，是最慢的。</code></pre><h5 id="2-本地缓存"><a href="#2-本地缓存" class="headerlink" title="2.本地缓存"></a>2.本地缓存</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Pragma： HTTP1.0的属性，该字段设置为no-cache，会告知浏览器禁用本地缓存</span><br><span class="line"></span><br><span class="line">Expires: HTTP1.0的属性，用来启用本地缓存。expires的值对应为一个类似</span><br><span class="line">Thu, 31 Dec 2017 20:11:20 GMT的格林威治时间，告诉浏览器如果还没有到该时间，则缓存有效，无须发送请求。这个时间是服务器返回的，是以服务器的时间为基准，如果服务器和客户端的时间不一致就可能产生差错。</span><br><span class="line"></span><br><span class="line">Cache-Control: 告知浏览器缓存过期的时间间隔。</span><br><span class="line">no-store: 禁止浏览器缓存</span><br><span class="line">no-cache: 不允许直接使用本地缓存，先发起请求和服务器协商</span><br><span class="line">max-age=delta-seconds: 告知浏览器响应本地缓存的最长期限，以秒为单位</span><br><span class="line"></span><br><span class="line">优先级：Pragrma &gt; Cache-Control &gt; Expires</span><br></pre></td></tr></table></figure><h5 id="3-协商缓存"><a href="#3-协商缓存" class="headerlink" title="3.协商缓存"></a>3.协商缓存</h5><blockquote><p>浏览器没有命中本地缓存，如果本地缓存过期或者响应不允许直接使用本地缓存，那么浏览器会发起服务端请求，服务端会验证数据是否被修改，如果没有被修改就通知浏览器使用本地缓存</p></blockquote><p>相关的Header：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: 通知浏览器资源的最后修改时间（一个格林威治时间）</span><br><span class="line">If-Modified-Since: 得到资源最后修改时间后，会将这个If-Modified-Since（Last-Modified的值）提交到服务器做检查，如果没有修改，就返回304</span><br><span class="line"></span><br><span class="line">ETag: HTTP1.1属性，指纹标识符，如果文件发生更改，指纹会改变</span><br><span class="line">If-None_Match: 本地缓存失效，会携带此值（ETage 的值）去请求服务端，服务端判断资源是否改变，如果没有改变，直接使用本地缓存，返回304</span><br></pre></td></tr></table></figure><h5 id="4-缓存对象的选择"><a href="#4-缓存对象的选择" class="headerlink" title="4.缓存对象的选择"></a>4.缓存对象的选择</h5><ul><li>不变的内容适合本地缓存：图像，js，css，可下载的媒体文件等</li><li>适合协商缓存的文件：HTML文件，经常替换的图片，经常修改的js、css等文件</li></ul><h5 id="5-Nginx配置缓存策略"><a href="#5-Nginx配置缓存策略" class="headerlink" title="5.Nginx配置缓存策略"></a>5.Nginx配置缓存策略</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*****通过PHP模拟Last-Modified-&gt;If-Modified-Since模式******</span><br><span class="line">// 读取上一次修改时间</span><br><span class="line">$since = $_SERVER[&apos;HTTP_IF_MODIFIED-SINCE&apos;];</span><br><span class="line">$lifetime = 3600; // 模拟缓存一分钟</span><br><span class="line">// 如果没过期就返回304</span><br><span class="line">if(strtotime($since) + $lifetiem &gt; time())&#123;</span><br><span class="line">    header(&apos;HTTP/1.1 304 NOT MODIFIED&apos;);</span><br><span class="line">    exit;</span><br><span class="line">&#125;</span><br><span class="line">// 返回Last-Modified相应头</span><br><span class="line">header(&apos;Last-Modified: &apos;.gmdate(&apos;D, d M Y H:i:s&apos;, time())). &apos;GMT&apos;);</span><br></pre></td></tr></table></figure><h5 id="Nginx缓存配置："><a href="#Nginx缓存配置：" class="headerlink" title="Nginx缓存配置："></a>Nginx缓存配置：</h5><blockquote><p>本地缓存配置指令：  </p></blockquote><pre><code>add_header： 添加状态码为2XX和3XX的响应头  add_header name value \[always]; 语法格式  可以通过该指令来设置Pragma/Expires/Cache-Control</code></pre><blockquote><p>expires指令： 通知浏览器过期时长  </p></blockquote><pre><code>expires time;  语法格式  为负值表示Cache-Control: no-cache   为正直表示Cache-Control:max-age=指定时间 </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Nginx缓存配置：</span><br><span class="line"># 遇到图片等资源就缓存30天</span><br><span class="line">location ~ .*\.(gif|jpeg|png|flv|swf|zip|rar)$</span><br><span class="line">&#123;</span><br><span class="line">    expires     30d;</span><br><span class="line">&#125;</span><br><span class="line">$ 遇到js/css等资源就缓存12小时</span><br><span class="line">location ~ .*\.(js|css)?$</span><br><span class="line">&#123;</span><br><span class="line">    expires     12h;</span><br><span class="line">&#125;</span><br><span class="line"># expires   max; 代表设置十年的缓存</span><br></pre></td></tr></table></figure><blockquote><p>Nginx协商缓存配置：  </p></blockquote><ul><li>ETage指令： 指定签名 </li><li>etage: on|off; 开关，默认是on</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.(gif|jpeg|png|flv|swf|zip|rar)$</span><br><span class="line">&#123;</span><br><span class="line">    # 默认是开启的</span><br><span class="line">    etag     off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-前端代码和资源的压缩"><a href="#6-前端代码和资源的压缩" class="headerlink" title="6.前端代码和资源的压缩"></a>6.前端代码和资源的压缩</h5><ul><li>JavaScript压缩：去掉多余的空格和回车，替换长变量名，简写代码等</li><li>CSS压缩： 同样是去掉空白符、注释并且优化CSS语义规则</li><li>图片压缩： 借助压缩工具压缩（tinypng、jpegMini、imageoption等）</li><li>Gzip压缩</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Nginx配置:</span><br><span class="line">gizp on|off;    #是否开启gzip</span><br><span class="line">gzip_buffers 32 4K|16 8k #缓冲（在内存中有几块 每块多大）</span><br><span class="line">gzip_comp_level [1-9] #压缩级别（推荐使用6） 级别越高，压缩越小，越占用CPU资源</span><br><span class="line">gzip_disable #正则表达式匹配UA 什么样的uri不进行gzip </span><br><span class="line">gzip_min_length 200 #开始压缩的最小长度</span><br><span class="line">gzip_http_version 1.0|1.1 #开始压缩的http版本协议</span><br><span class="line">gzip_types text/plain application/xml #对那些类型进行压缩，如text、css、html等</span><br></pre></td></tr></table></figure><p>现在前端有很多工具可以对资源进行压缩，打包等。如grunt、webpack等已经很流行了。比较流行的前端框架也有相应的脚手架来帮助打包：vue-cli、angular-cli等</p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> 流量 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分区、分表、分库、分片入门</title>
      <link href="/2018/12/23/%E5%88%86%E5%8C%BA%E3%80%81%E5%88%86%E8%A1%A8%E3%80%81%E5%88%86%E5%BA%93%E3%80%81%E5%88%86%E7%89%87%E5%85%A5%E9%97%A8/"/>
      <url>/2018/12/23/%E5%88%86%E5%8C%BA%E3%80%81%E5%88%86%E8%A1%A8%E3%80%81%E5%88%86%E5%BA%93%E3%80%81%E5%88%86%E7%89%87%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h3 id="一、分区的概念"><a href="#一、分区的概念" class="headerlink" title="一、分区的概念"></a>一、分区的概念</h3><p>数据分区是一种物理数据库的设计技术，它的目的是为了在特定的SQL操作中减少数据读写的总量以缩减响应时间。</p><p>分区并不是生成新的数据表，而是将表的数据均衡分摊到不同的硬盘，系统或是不同服务器存储介子中，实际上还是一张表。另外，分区可以做到将表的数据均衡到不同的地方，提高数据检索的效率，降低数据库的频繁IO压力值，分区的优点如下：</p><a id="more"></a><ul><li>1、相对于单个文件系统或是硬盘，分区可以存储更多的数据；</li><li>2、数据管理比较方便，比如要清理或废弃某年的数据，就可以直接删除该日期的分区数据即可；</li><li>3、精准定位分区查询数据，不需要全表扫描查询，大大提高数据检索效率；</li><li>4、可跨多个分区磁盘查询，来提高查询的吞吐量；</li><li>5、在涉及聚合函数查询时，可以很容易进行数据的合并；</li></ul><h3 id="二、分类-（row-行-，column-列）"><a href="#二、分类-（row-行-，column-列）" class="headerlink" title="二、分类 （row 行 ，column 列）"></a>二、分类 （row 行 ，column 列）</h3><ul><li>1、水平分区</li></ul><p>这种形式分区是对表的行进行分区，通过这样的方式不同分组里面的物理列分割的数据集得以组合，从而进行个体分割（单分区）或集体分割（1个或多个分区）。所有在表中定义的列在每个数据集中都能找到，所以表的特性依然得以保持。</p><blockquote><p>举个简单例子：一个包含十年发票记录的表可以被分区为十个不同的分区，每个分区包含的是其中一年的记录。（朋奕注：这里具体使用的分区方式我们后面再说，可以先说一点，一定要通过某个属性列来分割，譬如这里使用的列就是年份）</p></blockquote><ul><li>2、垂直分区</li></ul><p>这种分区方式一般来说是通过对表的垂直划分来减少目标表的宽度，使某些特定的列被划分到特定的分区，每个分区都包含了其中的列所对应的行。</p><blockquote><p>举个简单例子：一个包含了大text和BLOB列的表，这些text和BLOB列又不经常被访问，这时候就要把这些不经常使用的text和BLOB了划分到另一个分区，在保证它们数据相关性的同时还能提高访问速度。</p></blockquote><p>在数据库供应商开始在他们的数据库引擎中建立分区（主要是水平分区）时，DBA和建模者必须设计好表的物理分区结构，不要保存冗余的数据（不同表中同时都包含父表中的数据）或相互联结成一个逻辑父对象（通常是视图）。这种做法会使水平分区的大部分功能失效，有时候也会对垂直分区产生影响。</p><h3 id="三、分片、分区、分表、分库的详细理解"><a href="#三、分片、分区、分表、分库的详细理解" class="headerlink" title="三、分片、分区、分表、分库的详细理解"></a>三、分片、分区、分表、分库的详细理解</h3><h5 id="一、什么是分片、分区、分表、分库"><a href="#一、什么是分片、分区、分表、分库" class="headerlink" title="一、什么是分片、分区、分表、分库"></a>一、什么是分片、分区、分表、分库</h5><ul><li>分片</li></ul><p>当数据库数据达到上亿级别时，数据库压力会很大，存不下，可以考虑使用数据库分片。</p><ul><li>分区</li></ul><p>就是把一张表的数据分成N个区块，在逻辑上看最终只是一张表，但底层是由N个物理区块组成的</p><ul><li>分表</li></ul><p>就是把一张表按一定的规则分解成N个具有独立存储空间的实体表。系统读写时需要根据定义好的规则得到对应的字表明，然后操作它。</p><ul><li>分库</li></ul><p>一旦分表，一个库中的表会越来越多</p><blockquote><p>将整个数据库比作图书馆，一张表就是一本书。当要在一本书中查找某项内容时，如果不分章节，查找的效率将会下降。而同理，在数据库中就是分区。</p></blockquote><h5 id="常用的单机数据库的瓶颈"><a href="#常用的单机数据库的瓶颈" class="headerlink" title="常用的单机数据库的瓶颈"></a>常用的单机数据库的瓶颈</h5><ul><li>问题描述<ul><li>单个表数据量越大，读写锁，插入操作重新建立索引效率越低。</li><li>单个库数据量太大（一个数据库数据量到1T-2T就是极限）</li><li>单个数据库服务器压力过大</li><li>读写速度遇到瓶颈（并发量几百）</li></ul></li></ul><h3 id="二、分片"><a href="#二、分片" class="headerlink" title="二、分片"></a>二、分片</h3><p>不同的表放到不同的 数据库中—垂直切割。</p><pre><code>数据量小，查询性能会提高。 不同数据库位于不同服务器上时，会减小服务器压力。</code></pre><p>单张表数据量也很大，如用户量大产生操作量也会很大。单独查询时，压力也会很大。此时垂直分割也无济于事。可以考虑–水平分割。</p><pre><code>一张表放到不同数据库中。用户表，放到不同数据库，每个数据库存储部分数据，单表数据量不大。</code></pre><h3 id="三、分区"><a href="#三、分区" class="headerlink" title="三、分区"></a>三、分区</h3><h5 id="什么时候考虑使用分区？"><a href="#什么时候考虑使用分区？" class="headerlink" title="什么时候考虑使用分区？"></a>什么时候考虑使用分区？</h5><ul><li>一张表的查询速度已经慢到影响使用的时候。</li><li>sql经过优化</li><li>数据量大</li><li>表中的数据是分段的</li><li>对数据的操作往往只涉及一部分数据，而不是所有的数据</li></ul><h5 id="分区解决的问题"><a href="#分区解决的问题" class="headerlink" title="分区解决的问题"></a>分区解决的问题</h5><p>​    </p><p>​    主要可以提升查询效率</p><h5 id="分区的实现方式（简单）"><a href="#分区的实现方式（简单）" class="headerlink" title="分区的实现方式（简单）"></a>分区的实现方式（简单）</h5><p>mysql5 开始支持分区功能</p><pre><code>CREATE TABLE sales (id INT AUTO_INCREMENT,amount DOUBLE NOT NULL,order_day DATETIME NOT NULL,PRIMARY KEY(id, order_day)) ENGINE=Innodb PARTITION BY RANGE(YEAR(order_day)) (PARTITION p_2010 VALUES LESS THAN (2010),PARTITION p_2011 VALUES LESS THAN (2011),PARTITION p_2012 VALUES LESS THAN (2012),PARTITION p_catchall VALUES LESS THAN MAXVALUE);</code></pre><blockquote><p> MySQL5.1提供的分区(Partition)功能确实可以实现表的分区，但是这种分区是局限在单个数据库范围里的，它不能跨越服务器的限制。</p></blockquote><p>如果能够保证数据量很难超过现有数据库服务器的物理承载量，那么只需利用MySQL5.1提供的分区(Partition)功能来改善数据库性能即可；否则，还是考虑应用Sharding理念吧，spider  storage engine就是一个不错的选择。</p><h5 id="Sharding与数据库分区-Partition-的区别"><a href="#Sharding与数据库分区-Partition-的区别" class="headerlink" title="Sharding与数据库分区(Partition)的区别　　"></a>Sharding与数据库分区(Partition)的区别　　</h5><blockquote><p> 有的时候，Sharding 也被近似等同于水平分区(Horizontal Partitioning)，网上很多地方也用水平分区来指代  Sharding，但我个人认为二者之间实际上还是有区别的。的确，Sharding  的思想是从分区的思想而来，但数据库分区基本上是数据对象级别的处理，比如表和索引的分区，每个子数据集上能够有不同的物理存储属性，还是单个数据库范围内的操作，而 Sharding 是能够跨数据库，甚至跨越物理机器的。</p></blockquote><h3 id="四、分表"><a href="#四、分表" class="headerlink" title="四、分表"></a>四、分表</h3><h5 id="什么时候考虑分表？"><a href="#什么时候考虑分表？" class="headerlink" title="什么时候考虑分表？"></a>什么时候考虑分表？</h5><ul><li>一张表的查询速度已经慢到影响使用的时候。</li><li>sql经过优化</li><li>数据量大</li><li>当频繁插入或者联合查询时，速度变慢</li></ul><h5 id="分表解决的问题"><a href="#分表解决的问题" class="headerlink" title="分表解决的问题"></a>分表解决的问题</h5><p>分表后，单表的并发能力提高了，磁盘I/O性能也提高了，写操作效率提高了</p><ul><li>查询一次的时间短了</li><li>数据分布在不同的文件，磁盘I/O性能提高</li><li>读写锁影响的数据量变小</li><li>插入数据库需要重新建立索引的数据减少</li></ul><h5 id="分表的实现方式（复杂）"><a href="#分表的实现方式（复杂）" class="headerlink" title="分表的实现方式（复杂）"></a>分表的实现方式（复杂）</h5><p>​    需要业务系统配合迁移升级，工作量较大</p><p>#####分区和分表的区别与联系</p><ul><li>分区和分表的目的都是减少数据库的负担，提高表的增删改查效率。</li><li>分区只是一张表中的数据的存储位置发生改变，分表是将一张表分成多张表。</li><li>当访问量大，且表数据比较大时，两种方式可以互相配合使用。</li><li>当访问量不大，但表数据比较多时，可以只进行分区。</li></ul><h5 id="常见分区分表的规则策略（类似）"><a href="#常见分区分表的规则策略（类似）" class="headerlink" title="常见分区分表的规则策略（类似）"></a>常见分区分表的规则策略（类似）</h5><ul><li>Range（范围）</li><li>Hash（哈希）</li><li>List（链表）</li><li>按照时间拆分</li><li>Hash之后按照分表个数取模</li><li>在认证库中保存数据库配置，就是建立一个DB，这个DB单独保存user_id到DB的映射关系</li></ul><h3 id="五、分库"><a href="#五、分库" class="headerlink" title="五、分库"></a>五、分库</h3><h5 id="什么时候考虑使用分库？"><a href="#什么时候考虑使用分库？" class="headerlink" title="什么时候考虑使用分库？"></a>什么时候考虑使用分库？</h5><ul><li>单台DB的存储空间不够</li><li>随着查询量的增加单台数据库服务器已经没办法支撑</li></ul><h5 id="分库解决的问题"><a href="#分库解决的问题" class="headerlink" title="分库解决的问题"></a>分库解决的问题</h5><p>​    其主要目的是为突破单节点数据库服务器的 I/O 能力限制，解决数据库扩展性问题。 </p><h5 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h5><p>将系统中不存在关联关系或者需要join的表可以放在不同的数据库不同的服务器中。</p><blockquote><p>按照业务垂直划分。比如：可以按照业务分为资金、会员、订单三个数据库。</p></blockquote><p>需要解决的问题：跨数据库的事务、jion查询等问题。</p><h5 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h5><p>例如，大部分的站点。数据都是和用户有关，那么可以根据用户，将数据按照用户水平拆分。</p><blockquote><p>按照规则划分，一般水平分库是在垂直分库之后的。比如每天处理的订单数量是海量的，可以按照一定的规则水平划分。需要解决的问题：数据路由、组装。</p></blockquote><h5 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h5><p>对于时效性不高的数据，可以通过读写分离缓解数据库压力。需要解决的问题：在业务上区分哪些业务上是允许一定时间延迟的，以及数据同步问题。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><blockquote><p>垂直分库–&gt;水平分库–&gt;读写分离</p></blockquote><h3 id="六、拆分之后面临新的问题"><a href="#六、拆分之后面临新的问题" class="headerlink" title="六、拆分之后面临新的问题"></a>六、拆分之后面临新的问题</h3><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ul><li>事务的支持，分库分表，就变成了分布式事务</li><li>join时跨库，跨表的问题</li><li>分库分表，读写分离使用了分布式，分布式为了保证强一致性，必然带来延迟，导致性能降低，系统的复杂度变高。</li></ul><h5 id="常用的解决方案："><a href="#常用的解决方案：" class="headerlink" title="常用的解决方案："></a>常用的解决方案：</h5><p>对于不同的方式之间没有严格的界限，特点不同，侧重点不同。需要根据实际情况，结合每种方式的特点来进行处理。</p><p>选用第三方的数据库中间件（Atlas，Mycat，TDDL，DRDS），同时业务系统需要配合数据存储的升级。</p><h3 id="七、数据存储的演进"><a href="#七、数据存储的演进" class="headerlink" title="七、数据存储的演进"></a>七、数据存储的演进</h3><h5 id="单库单表"><a href="#单库单表" class="headerlink" title="单库单表"></a>单库单表</h5><p>单库单表是最常见的数据库设计，例如，有一张用户(user)表放在数据库db中，所有的用户都可以在db库中的user表中查到。</p><h5 id="单库多表"><a href="#单库多表" class="headerlink" title="单库多表"></a>单库多表</h5><p>随着用户数量的增加，user表的数据量会越来越大，当数据量达到一定程度的时候对user表的查询会渐渐的变慢，从而影响整个DB的性能。如果使用mysql, 还有一个更严重的问题是，当需要添加一列的时候，mysql会锁表，期间所有的读写操作只能等待。</p><blockquote><p> 可以通过某种方式将user进行水平的切分，产生两个表结构完全一样的user_0000,user_0001等表，user_0000 + user_0001 + …的数据刚好是一份完整的数据。</p></blockquote><h5 id="多库多表"><a href="#多库多表" class="headerlink" title="多库多表"></a>多库多表</h5><p>随着数据量增加也许单台DB的存储空间不够，随着查询量的增加单台数据库服务器已经没办法支撑。这个时候可以再对数据库进行水平拆分。</p><h3 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h3><p>总的来说，优先考虑分区。当分区不能满足需求时，开始考虑分表，合理的分表对效率的提升会优于分区。</p><h5 id="基础数据存储"><a href="#基础数据存储" class="headerlink" title="基础数据存储"></a>基础数据存储</h5><p>Mysql：只存储非文本的基础信息。包括：评论状态，用户，时间等基础数据。以及图片，标签，点赞等附加信息。数据组织形式（不同的数据又可选择不同的库表拆分方案）：</p><ul><li>评论基础数据按用户ID进行拆库并拆表</li><li>图片及标签处于同一数据库下，根据商品编号分别进行拆表</li><li>其它的扩展信息数据，因数据量不大、访问量不高，处理于同一库下且不做分表即可</li></ul><h5 id="文本存储"><a href="#文本存储" class="headerlink" title="文本存储"></a>文本存储</h5><p>文本存储（评论的内容）使用了mongodb、hbase</p><ul><li>选择nosql而非mysql</li><li>减轻了mysql存储压力，释放msyql，庞大的存储也有了可靠的保障</li><li>nosql的高性能读写大大提升了系统的吞吐量并降低了延迟</li></ul>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 拓展 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JWT（JSON Web Token]）入门简介</title>
      <link href="/2018/12/16/JWT%EF%BC%88JSON-Web-Token-%EF%BC%89%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B/"/>
      <url>/2018/12/16/JWT%EF%BC%88JSON-Web-Token-%EF%BC%89%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="Jwt"><a href="#Jwt" class="headerlink" title="Jwt"></a>Jwt</h1><p><code>JWT</code>是（JSON Web Token]）的缩写，主要用来做用户身份验证的。</p><p>随着当前分布式应用、前后端分离的技术广泛使用，早年通过session管理用户状态的成本越来越高，session共享问题以及之后出现的token认证基本都是通过如Redis之类的中间件实现的。</p><blockquote><p>JWT通过将数据保存在客户端，每次请求时将token发送至服务端校验，服务端无需存储token，实现完全无状态化。</p></blockquote><a id="more"></a><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul><li>客户端登录请求认证</li><li>服务端认证通过后，生成包含数据的<code>JSON</code>对象，并将此对象进行签名生成<code>token</code></li><li>服务端将<code>token</code>返回客户端，客户端存储在本地，如cookie或localStorage</li><li>客户端下次请求时携带<code>token</code>到服务端，常用的是放在 HTTP 请求的头的Authorization字段中，<code>Authorization: Bearer &lt;token&gt;</code></li><li>服务端验证<code>token</code>有效性</li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><code>Token</code>是一个使用<code>.</code>分割的三部分组成的长字符串，<code>Header.Payload.Signature</code></p><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header是一个Base64URL之后的json对象，<code>{&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;}</code>，<code>alg</code>表示签名的算法（algorithm），默认是 <code>HMAC SHA256</code>（HS256），<code>typ</code>表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。</p><h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><p>Payload 也是一个Base64URL之后的JSON对象，用来存放传递的数据。JWT 规定了7个官方字段可用：</p><ul><li>iss (issuer)：签发人</li><li>iat (Issued At)：签发时间</li><li>exp (expiration time)：过期时间</li><li>nbf (Not Before)：生效时间</li><li>jti (JWT ID)：编号</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li></ul><p>除了官方字段，还可以在这个部分定义私有字段，比如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sub"</span>: <span class="string">"101"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"ruesin"</span>,</span><br><span class="line">  <span class="attr">"LoginToken"</span>:<span class="string">"abcd123"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为默认是Base64URL编码不加密的，所以客户端是可以解码读取这些数据，不要把秘密信息放在这个部分。</p><h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><blockquote><p>Signature 是对前两部分的签名，校验tonken的有效性，防止数据篡改。</p></blockquote><p>签名是通过服务端指定的密钥（secret）及Header中指定的签名算法产生的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nginx配置文件(nginx.conf)详解</title>
      <link href="/2018/11/16/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-nginx-conf-%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/11/16/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-nginx-conf-%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>Nginx 总的 配置文件 位置 /usr/local/nginx/conf/nginx.conf<br>nginx 正则匹配</p><h3 id="一．正则表达式匹配，其中："><a href="#一．正则表达式匹配，其中：" class="headerlink" title="一．正则表达式匹配，其中："></a>一．正则表达式匹配，其中：</h3><ol><li>~ 为区分大小写匹配</li><li>~* 为不区分大小写匹配</li><li>!~和!~*分别为区分大小写不匹配及不区分大小写不匹配</li></ol><a id="more"></a><h3 id="二．文件及目录匹配，其中："><a href="#二．文件及目录匹配，其中：" class="headerlink" title="二．文件及目录匹配，其中："></a>二．文件及目录匹配，其中：</h3><ol><li>-f和!-f用来判断是否存在文件</li><li>-d和!-d用来判断是否存在目录</li><li>-e和!-e用来判断是否存在文件或目录</li><li>-x和!-x用来判断文件是否可执行</li></ol><h3 id="三．rewrite指令的最后一项参数为flag标记，flag标记有："><a href="#三．rewrite指令的最后一项参数为flag标记，flag标记有：" class="headerlink" title="三．rewrite指令的最后一项参数为flag标记，flag标记有："></a>三．rewrite指令的最后一项参数为flag标记，flag标记有：</h3><ol><li>last    相当于apache里面的[L]标记，表示rewrite。</li><li>break本条规则匹配完成后，终止匹配，不再匹配后面的规则。</li><li>redirect  返回302临时重定向，浏览器地址会显示跳转后的URL地址。</li><li>permanent  返回301永久重定向，浏览器地址会显示跳转后的URL地址。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用last和break实现URI重写，浏览器地址栏不变。</span><br><span class="line">使用alias指令必须用last标记;</span><br><span class="line">使用proxy_pass指令时，需要使用break标记。</span><br><span class="line">Last标记在本条rewrite规则执行完毕后，会对其所在server&#123;......&#125;标签重新发起请求</span><br><span class="line">break标记则在本条规则匹配完成后，终止匹配。</span><br></pre></td></tr></table></figure><h3 id="四．NginxRewrite-规则相关指令"><a href="#四．NginxRewrite-规则相关指令" class="headerlink" title="四．NginxRewrite 规则相关指令"></a>四．NginxRewrite 规则相关指令</h3><h5 id="1-break指令"><a href="#1-break指令" class="headerlink" title="1. break指令"></a>1. break指令</h5><ul><li>使用环境：server,location,if;</li><li>该指令的作用是完成当前的规则集，不再处理rewrite指令。</li></ul><h5 id="2-if指令"><a href="#2-if指令" class="headerlink" title="2.if指令"></a>2.if指令</h5><ul><li>使用环境：server,location</li><li>该指令用于检查一个条件是否符合，如果条件符合，则执行大括号内的语句。If指令不支持嵌套，不支持多个条件&amp;&amp;和||处理。</li></ul><h5 id="3-return指令"><a href="#3-return指令" class="headerlink" title="3.return指令"></a>3.return指令</h5><ul><li>语法：return code ;</li><li>使用环境：server,location,if;</li></ul><p>该指令用于结束规则的执行并返回状态码给客户端。<br>示例：如果访问的URL以”.sh”或”.bash”结尾，则返回403状态码</p><pre><code>location ~ .*\.(sh|bash)?${　　　　return 403;}</code></pre><h5 id="4-rewrite-指令"><a href="#4-rewrite-指令" class="headerlink" title="4.rewrite 指令"></a>4.rewrite 指令</h5><ul><li>语法：rewriteregex replacement flag</li><li>使用环境：server,location,if</li></ul><p>该指令根据表达式来重定向URI，或者修改字符串。指令根据配置文件中的顺序来执行。注意重写表达式只对相对路径有效。如果你想配对主机名，你应该使用if语句，示例如下：</p><pre><code>if ( $host ~* www\.(.*) ){　　　　set  $host_without_www $1;　　　　rewrite  ^(.*)$   http://$host_without_www$1 permanent;}</code></pre><h5 id="5-Set指令"><a href="#5-Set指令" class="headerlink" title="5.Set指令"></a>5.Set指令</h5><ul><li>语法：setvariable value ; 默认值:none; 使用环境：server,location,if;</li><li>该指令用于定义一个变量，并给变量赋值。变量的值可以为文本、变量以及文本变量的联合。<br>　<br>示例：set $varname “hello world”;</li></ul><h5 id="6-Uninitialized-variable-warn指令"><a href="#6-Uninitialized-variable-warn指令" class="headerlink" title="6.Uninitialized_variable_warn指令"></a>6.Uninitialized_variable_warn指令</h5><ul><li>语法：uninitialized_variable_warnon|off</li><li>使用环境：http,server,location,if</li></ul><p>该指令用于开启和关闭未初始化变量的警告信息，默认值为开启。</p><h3 id="五．Nginx的Rewrite规则编写实例"><a href="#五．Nginx的Rewrite规则编写实例" class="headerlink" title="五．Nginx的Rewrite规则编写实例"></a>五．Nginx的Rewrite规则编写实例</h3><h5 id="1-当访问的文件和目录不存在时，重定向到某个php文件"><a href="#1-当访问的文件和目录不存在时，重定向到某个php文件" class="headerlink" title="1.当访问的文件和目录不存在时，重定向到某个php文件"></a>1.当访问的文件和目录不存在时，重定向到某个php文件</h5><pre><code>if ( !-e $request_filename ){    Rewrite ^/(.*)$ index.php last;}</code></pre><h5 id="2-目录对换-123456-xxxx-gt-xxxx-id-123456"><a href="#2-目录对换-123456-xxxx-gt-xxxx-id-123456" class="headerlink" title="2.目录对换 /123456/xxxx  ====&gt;  /xxxx?id=123456"></a>2.目录对换 /123456/xxxx  ====&gt;  /xxxx?id=123456</h5><pre><code>rewrite ^/(\d+)/(.+)/  /$2?id=$1 last;</code></pre><h5 id="3-如果客户端使用的是IE浏览器，则重定向到-ie目录下"><a href="#3-如果客户端使用的是IE浏览器，则重定向到-ie目录下" class="headerlink" title="3.如果客户端使用的是IE浏览器，则重定向到/ie目录下"></a>3.如果客户端使用的是IE浏览器，则重定向到/ie目录下</h5><pre><code>if( $http_user_agent  ~ MSIE){</code></pre><p>Rewrite ^(.*)$ /ie/$1 break;<br>    }</p><h5 id="4-禁止访问多个目录"><a href="#4-禁止访问多个目录" class="headerlink" title="4.禁止访问多个目录"></a>4.禁止访问多个目录</h5><pre><code>location ~ ^/(cron|templates)/{    deny all;    break;}</code></pre><h5 id="5-禁止访问以-data开头的文件"><a href="#5-禁止访问以-data开头的文件" class="headerlink" title="5.禁止访问以/data开头的文件"></a>5.禁止访问以/data开头的文件</h5><pre><code>location ~ ^/data{    deny all;}</code></pre><h5 id="6-禁止访问以-sh-flv-mp3为文件后缀名的文件"><a href="#6-禁止访问以-sh-flv-mp3为文件后缀名的文件" class="headerlink" title="6.禁止访问以.sh,.flv,.mp3为文件后缀名的文件"></a>6.禁止访问以.sh,.flv,.mp3为文件后缀名的文件</h5><pre><code>location ~ .*\.(sh|flv|mp3)${    return 403;}</code></pre><h5 id="7-设置某些类型文件的浏览器缓存时间"><a href="#7-设置某些类型文件的浏览器缓存时间" class="headerlink" title="7.设置某些类型文件的浏览器缓存时间"></a>7.设置某些类型文件的浏览器缓存时间</h5><pre><code>location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)${    expires 30d;}location ~ .*\.(js|css)${    expires 1h;}</code></pre><h5 id="8-给favicon-ico和robots-txt设置过期时间"><a href="#8-给favicon-ico和robots-txt设置过期时间" class="headerlink" title="8.给favicon.ico和robots.txt设置过期时间;"></a>8.给favicon.ico和robots.txt设置过期时间;</h5><p>这里为favicon.ico为99天,robots.txt为7天并不记录404错误日志</p><pre><code>location ~(favicon.ico){    log_not_found off;    expires 99d;    break;}location ~(robots.txt) {    log_not_found off;    expires 7d;    break;}</code></pre><h5 id="9-设定某个文件的过期时间-这里为600秒，并不记录访问日志"><a href="#9-设定某个文件的过期时间-这里为600秒，并不记录访问日志" class="headerlink" title="9.设定某个文件的过期时间;这里为600秒，并不记录访问日志"></a>9.设定某个文件的过期时间;这里为600秒，并不记录访问日志</h5><pre><code>location ^~ /html/scripts/loadhead_1.js {    access_log  off;    root /opt/lampp/htdocs/web;    expires 600;    break;}</code></pre><h5 id="10-文件反盗链并设置过期时间"><a href="#10-文件反盗链并设置过期时间" class="headerlink" title="10.文件反盗链并设置过期时间"></a>10.文件反盗链并设置过期时间</h5><p>　<br>这里的return412 为自定义的http状态码，默认为403，方便找出正确的盗链的请求</p><pre><code>“rewrite ^/ http://img.linuxidc.net/leech.gif;” 显示一张防盗链图片“access_log off;” 不记录访问日志，减轻压力“expires 3d”  所有文件3天的浏览器缓存location ~*^.+\.(jpg|jpeg|gif|png|swf|rar|zip|css|js)$ {    valid_referers none blocked *.linuxidc.com*.linuxidc.net localhost 208.97.167.194;    if ($invalid_referer)     {　　　　　　rewrite ^/ http://img.linuxidc.net/leech.gif;　　　　　　return 412;　　　　　　break;    }    access_log  off;    root /opt/lampp/htdocs/web;    expires 3d;    break;}</code></pre><h5 id="11-只允许固定ip访问网站，并加上密码"><a href="#11-只允许固定ip访问网站，并加上密码" class="headerlink" title="11.只允许固定ip访问网站，并加上密码"></a>11.只允许固定ip访问网站，并加上密码</h5><pre><code>root /opt/htdocs/www;allow  208.97.167.194; allow  222.33.1.2; allow  231.152.49.4;deny  all;auth_basic “C1G_ADMIN”;auth_basic_user_file htpasswd;</code></pre><h5 id="12将多级目录下的文件转成一个文件，增强seo效果"><a href="#12将多级目录下的文件转成一个文件，增强seo效果" class="headerlink" title="12将多级目录下的文件转成一个文件，增强seo效果"></a>12将多级目录下的文件转成一个文件，增强seo效果</h5><pre><code>/job-123-456-789.html 指向/job/123/456/789.htmlrewrite ^/job-([0-9]+)-([0-9]+)-([0-9]+)\.html$ /job/$1/$2/jobshow_$3.html last;</code></pre><h5 id="13-文件和目录不存在的时候重定向："><a href="#13-文件和目录不存在的时候重定向：" class="headerlink" title="13.文件和目录不存在的时候重定向："></a>13.文件和目录不存在的时候重定向：</h5><pre><code>if (!-e $request_filename){    proxy_pass http://127.0.0.1;}</code></pre><h5 id="14-将根目录下某个文件夹指向2级目录"><a href="#14-将根目录下某个文件夹指向2级目录" class="headerlink" title="14.将根目录下某个文件夹指向2级目录"></a>14.将根目录下某个文件夹指向2级目录</h5><p>如/shanghaijob/ 指向 /area/shanghai/<br>如果你将last改成permanent，那么浏览器地址栏显是/location/shanghai/</p><pre><code>　　rewrite ^/([0-9a-z]+)job/(.*)$ /area/$1/$2last;</code></pre><p>面例子有个问题是访问/shanghai时将不会匹配</p><pre><code>　　rewrite ^/([0-9a-z]+)job$ /area/$1/ last;</code></pre><p>Rewrite ^/([0-9a-z]+)job/(.*)$ /area/$1/$2last;</p><p>这样/shanghai 也可以访问了，但页面中的相对链接无法使用，</p><blockquote><p>如./list_1.html真实地址是/area/shanghia/list_1.html会变成/list_1.html,导至无法访问。<br>那我加上自动跳转也是不行咯</p></blockquote><pre><code>(-d $request_filename)它有个条件是必需为真实目录，而我的rewrite不是的，所以没有效果if (-d $request_filename){rewrite ^/(.*)([^/])$ http://$host/$1$2/permanent;}</code></pre><p>知道原因后就好办了，让我手动跳转吧</p><pre><code>rewrite ^/([0-9a-z]+)job$ /$1job/permanent;rewrite ^/([0-9a-z]+)job/(.*)$ /area/$1/$2last;</code></pre><h5 id="15-域名跳转"><a href="#15-域名跳转" class="headerlink" title="15.域名跳转"></a>15.域名跳转</h5><pre><code>server{    listen      80;    server_name  jump.linuxidc.com;    index index.html index.htm index.php;    root  /opt/lampp/htdocs/www;    rewrite ^/ http://www.linuxidc.com/;    access_log  off;}</code></pre><h5 id="16-多域名转向"><a href="#16-多域名转向" class="headerlink" title="16.多域名转向"></a>16.多域名转向</h5><pre><code>server_name  www.linuxidc.com www.linuxidc.net;index index.html index.htm index.php;root  /opt/lampp/htdocs;if ($host ~ &quot;linuxidc\.net&quot;) {    rewrite ^(.*) http://www.linuxidc.com$1permanent;}</code></pre><h3 id="六．nginx全局变量"><a href="#六．nginx全局变量" class="headerlink" title="六．nginx全局变量"></a>六．nginx全局变量</h3><pre><code>​arg_PARAMETER    #这个变量包含GET请求中，如果有变量PARAMETER时的值。args                    #这个变量等于请求行中(GET请求)的参数，如：foo=123&amp;bar=blahblah;binary_remote_addr #二进制的客户地址。body_bytes_sent    #响应时送出的body字节数数量。即使连接中断，这个数据也是精确的。content_length    #请求头中的Content-length字段。content_type      #请求头中的Content-Type字段。cookie_COOKIE    #cookie COOKIE变量的值document_root    #当前请求在root指令中指定的值。document_uri      #与uri相同。host                #请求主机头字段，否则为服务器名称。hostname          #Set to themachine’s hostname as returned by gethostnamehttp_HEADERis_args              #如果有args参数，这个变量等于”?”，否则等于”&quot;，空值。http_user_agent    #客户端agent信息http_cookie          #客户端cookie信息limit_rate            #这个变量可以限制连接速率。query_string          #与args相同。request_body_file  #客户端请求主体信息的临时文件名。request_method    #客户端请求的动作，通常为GET或POST。remote_addr          #客户端的IP地址。remote_port          #客户端的端口。remote_user          #已经经过Auth Basic Module验证的用户名。request_completion #如果请求结束，设置为OK. 当请求未结束或如果该请求不是请求链串的最后一个时，为空(Empty)。request_method    #GET或POSTrequest_filename  #当前请求的文件路径，由root或alias指令与URI请求生成。request_uri          #包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。不能修改。scheme                #HTTP方法（如http，https）。server_protocol      #请求使用的协议，通常是HTTP/1.0或HTTP/1.1。server_addr          #服务器地址，在完成一次系统调用后可以确定这个值。server_name        #服务器名称。server_port          #请求到达服务器的端口号。</code></pre><h3 id="七．Apache和Nginx规则的对应关系"><a href="#七．Apache和Nginx规则的对应关系" class="headerlink" title="七．Apache和Nginx规则的对应关系"></a>七．Apache和Nginx规则的对应关系</h3><pre><code>Apache的RewriteCond对应Nginx的ifApache的RewriteRule对应Nginx的rewriteApache的[R]对应Nginx的redirectApache的[P]对应Nginx的lastApache的[R,L]对应Nginx的redirectApache的[P,L]对应Nginx的lastApache的[PT,L]对应Nginx的last</code></pre><p>例如：允许指定的域名访问本站，其他的域名一律转向<a href="http://www.linuxidc.net" target="_blank" rel="noopener">www.linuxidc.net</a></p><h5 id="Apache"><a href="#Apache" class="headerlink" title="Apache:"></a>Apache:</h5><pre><code>RewriteCond %{HTTP_HOST} !^(.*?)\.aaa\.com$[NC]RewriteCond %{HTTP_HOST} !^localhost$ RewriteCond %{HTTP_HOST}!^192\.168\.0\.(.*?)$RewriteRule ^/(.*)$ http://www.linuxidc.net[R,L]</code></pre><h5 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx:"></a>Nginx:</h5><pre><code>if( $host ~* ^(.*)\.aaa\.com$ ){    set $allowHost &apos;1&apos;;}if( $host ~* ^localhost ){    set $allowHost &apos;1&apos;;}if( $host ~* ^192\.168\.1\.(.*?)$ ){    set $allowHost &apos;1&apos;;}if( $allowHost !~ &apos;1&apos; ){    Rewrite ^/(.*)$ http://www.linuxidc.netredirect ;} </code></pre><h5 id="nginx-conf-配置文件"><a href="#nginx-conf-配置文件" class="headerlink" title="nginx conf 配置文件"></a>nginx conf 配置文件</h5><pre><code>nginx进程数，建议设置为等于CPU总核心数.worker_processes 8;全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]error_log /var/log/nginx/error.log info;进程文件pid /var/run/nginx.pid;一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。worker_rlimit_nofile 65535;工作模式与连接数上限events{        #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ];  epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。    　　use epoll;    　　#单个进程最大连接数（最大连接数=连接数*进程数）    　　worker_connections 65535;}设定http服务器http{​    include mime.types; #文件扩展名与文件类型映射表    default_type application/octet-stream; #默认文件类型    #charset utf-8; #默认编码    server_names_hash_bucket_size 128; #服务器名字的hash表大小    client_header_buffer_size 32k; #上传文件大小限制    large_client_header_buffers 4 64k; #设定请求缓    client_max_body_size 8m; #设定请求缓     sendfile on; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为  on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。    autoindex on; #开启目录列表访问，合适下载服务器，默认关闭。    tcp_nopush on; #防止网络阻塞    tcp_nodelay on; #防止网络阻塞    keepalive_timeout 120; #长连接超时时间，单位是秒​    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。    fastcgi_connect_timeout 300;    fastcgi_send_timeout 300;    fastcgi_read_timeout 300;    fastcgi_buffer_size 64k;    fastcgi_buffers 4 64k;    fastcgi_busy_buffers_size 128k;    fastcgi_temp_file_write_size 128k;​    #gzip模块设置    gzip on; #开启gzip压缩输出    gzip_min_length 1k; #最小压缩文件大小    gzip_buffers 4 16k; #压缩缓冲区    gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）    gzip_comp_level 2; #压缩等级    gzip_types text/plain application/x-javascript text/css application/xml;    #压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。    gzip_vary on;    #limit_zone crawler $binary_remote_addr 10m; #开启限制IP连接数的时候需要使用​    upstream blog.ha97.com {        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。        server 192.168.80.121:80 weight=3;        server 192.168.80.122:80 weight=2;        server 192.168.80.123:80 weight=3;    }    虚拟主机的配置    server    {    ​    listen 80;　　　　#监听端口    　　　　server_name aa.cn www.aa.cn ; #server_name end  #域名可以有多个，用空格隔开    ​    index index.html index.htm index.php;  # 设置访问主页    　　　　set $subdomain &apos;&apos;;  # 绑定目录为二级域名 bbb.aa.com  根目录 /bbb  文件夹         　　　　if ( $host ~* &quot;(?:(\w+\.){0,})(\b(?!www\b)\w+)\.\b(?!(com|org|gov|net|cn)\b)\w+\.[a-zA-Z]+&quot; ) { set $subdomain &quot;/$2&quot;; }    root /home/wwwroot/aa.cn/web$subdomain;# 访问域名跟目录      include rewrite/dedecms.conf; #rewrite end   #载入其他配置文件    ​    location ~ .*.(php|php5)?$        {            　　fastcgi_pass 127.0.0.1:9000;            　　fastcgi_index index.php;            　　include fastcgi.conf;        }        #图片缓存时间设置        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$        {            　　expires 10d;        }        #JS和CSS缓存时间设置        location ~ .*.(js|css)?$        {            　　expires 1h;        }    }​    日志格式设定​    log_format access &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;    &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;    &apos;&quot;$http_user_agent&quot; $http_x_forwarded_for&apos;;    #定义本虚拟主机的访问日志    access_log /var/log/nginx/ha97access.log access;​    #对 &quot;/&quot; 启用反向代理    location / {​        proxy_pass http://127.0.0.1:88;        proxy_redirect off;        proxy_set_header X-Real-IP $remote_addr;        #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        #以下是一些反向代理的配置，可选。        proxy_set_header Host $host;        client_max_body_size 10m; #允许客户端请求的最大单文件字节数        client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数，        proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时)        proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时)        proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时)        proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小        proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的设置        proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2）        proxy_temp_file_write_size 64k;        #设定缓存文件夹大小，大于这个值，将从upstream服务器传​    }​        设定查看Nginx状态的地址​    location /NginxStatus {​        stub_status on;        access_log on;        auth_basic &quot;NginxStatus&quot;;        auth_basic_user_file conf/htpasswd;        #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。​    }​    #本地动静分离反向代理配置    #所有jsp的页面均交由tomcat或resin处理    location ~ .(jsp|jspx|do)?$ {​        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_pass http://127.0.0.1:8080;​    }​        #所有静态文件由nginx直接读取不经过tomcat或resin    location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$    {　　 expires 15d;　　 }    location ~ .*.(js|css)?$    { 　　expires 1h;　　 }}</code></pre><h5 id="nginx-在thinkphp-的url-重写"><a href="#nginx-在thinkphp-的url-重写" class="headerlink" title="nginx 在thinkphp  的url 重写"></a>nginx 在thinkphp  的url 重写</h5><p>在/usr/local/nginx/conf/vhost/你的域名配置文件 中添加</p><pre><code>location / {　　if (!-e $request_filename) {　　rewrite ^/(.*)/(.*)/(.*)/*$ /index.php?m=$1&amp;c=$2&amp;a=$3 last;  # thinkphp 的配置文件中 &apos;URL_MODEL&apos; =&gt; 1   PATHINFO模式​       #或者  rewrite  ^(.*)$  /index.php?s=$1  last;　　　　 # thinkphp 的配置文件中 &apos;URL_MODEL&apos; =&gt;3   兼容模式​       #或者  rewrite  /(.*)$  /index.php/$1  last;          # thinkphp 的配置文件中 &apos;URL_MODEL&apos; =&gt; 2  REWRITE模式　　break;　　}} </code></pre><h5 id="路径-pathinfo-模式-thinkphp-添加"><a href="#路径-pathinfo-模式-thinkphp-添加" class="headerlink" title="路径 pathinfo 模式[ thinkphp ] 添加"></a>路径 pathinfo 模式[ thinkphp ] 添加</h5><pre><code>location ~ \.php(.*)$ {　　fastcgi_pass   127.0.0.1:9000;　　fastcgi_index  index.php;　　fastcgi_split_path_info  ^((?U).+\.php)(/?.+)$;　　fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;　　fastcgi_param  PATH_INFO  $fastcgi_path_info;　　fastcgi_param  PATH_TRANSLATED  $document_root$fastcgi_path_info;　　include        fastcgi_params;}</code></pre><h5 id="重写-url-省略index-php"><a href="#重写-url-省略index-php" class="headerlink" title="重写 url +省略index.php"></a>重写 url +省略index.php</h5><pre><code>location / {　　try_files $uri /index.php?$uri;}</code></pre><p>nginx -s reload 或者 /usr/local/nginx/sbin/nginx -s reload 重新加载Nginx配置文件</p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Nginx </tag>
            
            <tag> 配置文件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux命令--查找与统计（grep、awk、sort、uniq、wc）</title>
      <link href="/2018/10/16/linux%E5%91%BD%E4%BB%A4--%E6%9F%A5%E6%89%BE%E4%B8%8E%E7%BB%9F%E8%AE%A1%EF%BC%88grep%E3%80%81awk%E3%80%81sort%E3%80%81uniq%E3%80%81wc%EF%BC%89/"/>
      <url>/2018/10/16/linux%E5%91%BD%E4%BB%A4--%E6%9F%A5%E6%89%BE%E4%B8%8E%E7%BB%9F%E8%AE%A1%EF%BC%88grep%E3%80%81awk%E3%80%81sort%E3%80%81uniq%E3%80%81wc%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>在做日志分析时或者配置分析时，通常会遇到查找出符合某一条件的行，并统计，主要应用的就是grep、awk、sort、uniq、wc五个命令</p><h5 id="1-grep命令"><a href="#1-grep命令" class="headerlink" title="1. grep命令"></a>1. grep命令</h5><p>grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p><a id="more"></a><p>语法格式为：</p><pre><code>grep [option] pattern file //pattern 通常可以为正则表达式</code></pre><p>常见的参数为：</p><p>选项</p><pre><code>-a ：将 binary 文件以 text 文件的方式搜寻数据-c ：计算找到 &apos;搜寻字符串&apos; 的次数-i ：忽略大小写的不同，所以大小写视为相同-n ：顺便输出行号-v ：反向选择，亦即显示出没有 &apos;搜寻字符串&apos; 内容的那一行！--color=auto ：可以将找到的关键词部分加上颜色的显示喔！</code></pre><h5 id="2-awk命令"><a href="#2-awk命令" class="headerlink" title="2.awk命令"></a>2.awk命令</h5><p>  awk命令通常是将所列出的行，根据条件打印出某一列或几列</p><blockquote><p>常用形式为：awk  -F ‘:’  ‘BEGIN {print “name,shell”}  {if($1=”root”) print $1”,”$7} END {print “blue,/bin/nosh”}’  </p></blockquote><h5 id="3-sort命令"><a href="#3-sort命令" class="headerlink" title="3.sort命令"></a>3.sort命令</h5><p>sort排序原则：sort将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。</p><pre><code>sort [optional] filename</code></pre><p>常用参数：</p><pre><code>-u：去除重复行-r：默认是升序排序，-r是改为降序-o：将排序结果写入到源文件-n：默认是通过ASCII码值排序，但是这时会出现10比2小的情况，-n就是说要以数值进行排序-k和-t：-k是指定以哪一列进行排序，-t是指定分隔符</code></pre><p>举例：</p><ul><li><p>（1）sort -n -t “ “ -k 2 -k 3 facebook.txt  //人数相同的按照员工平均工资升序排序</p></li><li><p>（2） sort -n -t ‘ ‘ -k 3r -k 2 facebook.txt //按照员工工资降序排序，如果员工人数相同的，则按照公司人数升序排序</p></li><li><p>（3）sort -t ‘ ‘ -k 1.2 facebook.txt //从公司英文名称的第二个字母开始进行排序</p></li><li><p>（4）sort -t ‘ ‘ -k 1.2,1.2 -k 3,3nr facebook.txt //只针对公司英文名称的第二个字母进行排序，如果相同的按照员工工资进行降序排序</p></li></ul><h5 id="4-uniq命令"><a href="#4-uniq命令" class="headerlink" title="4.uniq命令"></a>4.uniq命令</h5><p>uniq命令可以去除排序过的文件中的重复行，因此uniq经常和sort合用。也就是说，为了使uniq起作用，所有的重复行必须是相邻的。</p><pre><code>-i   ：忽略大小写字符的不同；-c  ：进行计数,即统计该行的重复次数-u  ：显示不存在的行-d：显示存在重复的行</code></pre><h5 id="5-wc-命令"><a href="#5-wc-命令" class="headerlink" title="5.wc  命令"></a>5.wc  命令</h5><p>统计指定文件中的字节数、字数、行数，并将统计结果显示输出。该命令统计指定文件中的字节数、字数、行数。如果没有给出文件名，则从标准输入读取。wc同时也给出所指定文件的总统计数。</p><ul><li>-c 统计字节数。</li><li>-l 统计行数。</li><li>-m 统计字符数。这个标志不能与 -c 标志一起使用。</li><li>-w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。</li><li>-L 打印最长行的长度。</li><li>-help 显示帮助信息</li><li>–version 显示版本信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# wc test.txt</span><br><span class="line">7  8 70 test.txt</span><br></pre></td></tr></table></figure><ul><li>7 表示行数</li><li>8 表示单词数</li><li>70  字节数</li></ul>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS游戏——渠道越狱打包流程</title>
      <link href="/2018/10/09/iOS%E6%B8%B8%E6%88%8F%E2%80%94%E2%80%94%E6%B8%A0%E9%81%93%E8%B6%8A%E7%8B%B1%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/"/>
      <url>/2018/10/09/iOS%E6%B8%B8%E6%88%8F%E2%80%94%E2%80%94%E6%B8%A0%E9%81%93%E8%B6%8A%E7%8B%B1%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>关于iOS普通ipa打包这里就不说了，只要注意苹果的一些协议条款，基本上步骤都是傻瓜式的，如果不知道如何打包iOS普通ipa包，请出门左转，度娘在哪里等你！</p><blockquote><p>那么，如何将app打包成越狱包，越狱iphone在cydia源上下载安装，这样的需求在互联网游戏行业是非常普遍的，尤其是各种马甲包横行的时代！</p></blockquote><h6 id="关于越狱相关内容，请看这里"><a href="#关于越狱相关内容，请看这里" class="headerlink" title="关于越狱相关内容，请看这里"></a>关于越狱相关内容，请看这里</h6><ul><li><a href="https://www.52pojie.cn/thread-683139-1-1.html" target="_blank" rel="noopener">iOS越狱解除工具</a></li><li><a href="https://www.baidu.com/link?url=1tVxiDdLIbOv2qstGpFdZEOf-18kIJHyyGSXt77CmMo8goYBtfcIYXJNkWePH5bR&amp;wd=&amp;eqid=88fc6288000136f6000000065bc81910" target="_blank" rel="noopener">ios越狱原理详解</a></li></ul><a id="more"></a><h3 id="常见deb包打包方式"><a href="#常见deb包打包方式" class="headerlink" title="常见deb包打包方式"></a>常见deb包打包方式</h3><h5 id="1、第一种方式："><a href="#1、第一种方式：" class="headerlink" title="1、第一种方式："></a>1、第一种方式：</h5><p>自定义目录下 如desktop创建文件夹，起名test，test内新建文件夹Payload<br>把xcode Build好的.app（Products目录中）拷到Payload目录中<br>打开终端，cd指令 到test文件目录下，执行 </p><pre><code>zip -r “xxx.ipa” *         注意里面的空格：(zip -r “xxx.ipa”[空格]* )</code></pre><p>ipa包就打好了，可以安装到越狱手机上试试看</p><blockquote><p>注意事项：Debug或Release的Any iOS SDK都设置为正式发布证书，经测试该越狱包可正常接收推送。</p></blockquote><h5 id="2、第二种方式："><a href="#2、第二种方式：" class="headerlink" title="2、第二种方式："></a>2、第二种方式：</h5><p>在xcode中点击Product-&gt;Archive,完成后会弹出Organizer，点右边的Distribute，弹出一个向导对话框，点击“Export as Xcode Archive”，选择位置，会在那个位置生成后缀名是.xcarchive的文件<br>右键“显示包内容”-&gt;”Products”-&gt;”applications” 然后找到那个应用程序，</p><blockquote><p>将其拖到iTunes里面，在itunes的【应用程序】里找到这个文件，然后右键“在Finder 中显示”，便可找到ipa文件了<br>….</p></blockquote><p>ipa包就打好了，可以安装到越狱手机上试试看</p><h3 id="最近发现了一种更好的方式"><a href="#最近发现了一种更好的方式" class="headerlink" title="最近发现了一种更好的方式"></a>最近发现了一种更好的方式</h3><p>致谢： <a href="http://www.zhaoxiaodan.com/" target="_blank" rel="noopener">胖梁的技术笔记</a></p><h5 id="1-修改编译选项重新打包"><a href="#1-修改编译选项重新打包" class="headerlink" title="1.修改编译选项重新打包"></a>1.修改编译选项重新打包</h5><p>在工程的Build Settings -&gt; Code Signing -&gt; Code Signing Identity选项, 将 Debug 和 Release 下的 Any iOS SDK都设置为 Don’t Code Sign然后在重新Archive</p><h5 id="2-准备目录"><a href="#2-准备目录" class="headerlink" title="2.准备目录"></a>2.准备目录</h5><p>创建一个目录用来打包,如tmp,tmp下建DEBIAN和Applications两个目录, DEBIAN下建一个文本文件control tmp目录结构如下:</p><pre><code>-DEBIAN---control-Applications</code></pre><p>control文件就是打包时的配置文件,它也会作为deb包的配置被打包到包中, 文件例子:</p><pre><code>Package: com.sharedream.gameName: 游戏测试Version: 0.1-1Description: 游戏测试游戏,开发中...Section: 游戏Depends: firmware (&gt;= 4.3)Priority: optionalArchitecture: iphoneos-armAuthor: liangwei &lt;http://weibo.com/iamliangwei&gt;Homepage: http://weibo.com/iamliangweiIcon: file:///Applications/game.app/Icon.pngMaintainer: liangwei &lt;http://weibo.com/iamliangwei&gt;</code></pre><p>然后将xcode打包出来的.app文件整个拷贝到Applications目录下, 结构如下:</p><pre><code>-DEBIAN---control-Applications---game.app</code></pre><h5 id="3-打包"><a href="#3-打包" class="headerlink" title="3.打包"></a>3.打包</h5><p>退出至tmp的上层目录</p><pre><code>dpkg-deb -b tmp game.deb</code></pre><p>看到如下几行就是打包完成了</p><pre><code>warning, `com.sull.sample/DEBIAN/control&apos; contains user-defined field `Name&apos;warning, `com.sull.sample/DEBIAN/control&apos; contains user-defined field `Author&apos;warning, `com.sull.sample/DEBIAN/control&apos; contains user-defined field `Sponsor&apos;dpkg-deb: ignoring 3 warnings about the control file(s)</code></pre><p>拷贝到cydia源中, 重新扫描包生成Packages列表文件, 并压缩成Packages.bz2就可以啦</p><pre><code>dpkg-scanpackages -m debs &gt;Packagesbzip2 -zkf Packages</code></pre><blockquote><p>contains ununderstood data member data.tar.xz” 的安装错误</p></blockquote><p>是因为自从1.17.0版本的dpkg-deb开始, 默认使用xz格式来压缩data.tar文件<br>但是,cydia在ios提供的dpkg是1.14版本, 还没有支持xz这种压缩格式<br>所以我们需要设置”-Zgzip”参数给dpkg-deb 进行打包, 类似命令:</p><pre><code>dpkg-deb -Zgzip -b tmp game.deb</code></pre><h6 id="关于iOS普通包打包可以参考这里："><a href="#关于iOS普通包打包可以参考这里：" class="headerlink" title="关于iOS普通包打包可以参考这里："></a>关于iOS普通包打包可以参考这里：</h6><ul><li><a href="https://blog.csdn.net/zhanghow/article/details/60603461?utm_source=blogxgwz8" target="_blank" rel="noopener">https://blog.csdn.net/zhanghow/article/details/60603461?utm_source=blogxgwz8</a></li></ul>]]></content>
      
      <categories>
          
          <category> Games </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS游戏——渠道越狱打包流程 </tag>
            
            <tag> 游戏 </tag>
            
            <tag> 越狱 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL拓展(extend)</title>
      <link href="/2018/07/28/MySQL%E6%8B%93%E5%B1%95(extend)/"/>
      <url>/2018/07/28/MySQL%E6%8B%93%E5%B1%95(extend)/</url>
      <content type="html"><![CDATA[<h3 id="一、分区表的原理"><a href="#一、分区表的原理" class="headerlink" title="一、分区表的原理"></a>一、分区表的原理</h3><blockquote><p>对用户来说，分区表是一个独立的逻辑表，但是底层mysql将其分成了多个物理的子表，这对用户来说是透明的，每一个分区表都会使用一个独立的表文件。  </p></blockquote><h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h5><blockquote><p>创建表的时候通过partition by子句定义每个分区存放的数据，执行查询的时候，优化器会根据分区定义过滤那些没有我们需要数据的分区，这样查询只查询所需的数据所在分区</p></blockquote><p>分区的主要目的是将数据按照一个比较粗的粒度分在不同的表中，这样可以将相关的数据存放在一起，而且要一次删除整个分区也十分方便</p><a id="more"></a><h6 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h6><ol><li>表非常大，无法全部存在内存，或者只在表的最后有热点数据，其他都是历史数据  </li><li>分区表的数据更易维护，可以对独立的分区进行独立的操作  </li><li>分区表的数据可以分布在不同的机器上，从而高效的使用资源</li></ol><h3 id="二、分库分表的原理"><a href="#二、分库分表的原理" class="headerlink" title="二、分库分表的原理"></a>二、分库分表的原理</h3><blockquote><p>通过一些HASH算法或者工具将一张数据表垂直或者水平的进行物理切分</p></blockquote><h6 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h6><ol><li>单表数据达到百万甚至千万的级别</li><li>解决表锁的问题</li></ol><h4 id="水平分割"><a href="#水平分割" class="headerlink" title="水平分割"></a>水平分割</h4><p>此时表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询效率  </p><h6 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h6><ol><li>表中的数据有独立性，例如表中记录各个地区或各个时间段的数据，有些数据常用，有些数据不常用 </li><li>需要把数据存放在多个介质上  </li></ol><h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><ol><li>给应用增加复杂度，通常查询需要多个表名，查询所有的数据都需要union操作</li></ol><h4 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h4><p>将主键和一些列放在一张表，然后把主键和其他列放在另外一张表  </p><h6 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h6><ol><li>表中一些列常用，一些列不常用  </li><li>可以使数据行变小，一个数据页能存储更多的数据，减少查询I/O次数</li></ol><h6 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h6><ol><li>管理冗余列，查询所有的数据都需要join操作</li></ol>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nginx负载均衡入门</title>
      <link href="/2018/07/24/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%85%A5%E9%97%A8/"/>
      <url>/2018/07/24/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>负载均衡（Load Balance）其意思就是分摊到多个操作单元上进行执行，从而共同完成工作任务。通过核心调度者，保证所有后端服务器都将性能充分发挥，从而保持服务器集群的整体性能最优。</p><a id="more"></a><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ol><li><p>[加权]随机算法</p><p> 通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。可以按后端机器的配置设置随机概率的权重。调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</p></li><li><p>[加权]轮询算法</p><p> 将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。可以按后端机器的配置为轮询中的服务器附加一定权重的算法。比如服务器1权重1，服务器2权重2，服务器3权重3，则顺序为1-2-2-3-3-3-1-2-2-3-3-3- ……</p><p> 当服务器群中各服务器的处理能力相同时，且每笔业务处理量差异不大时，最适合使用这种算法。 </p></li><li><p>[加权]最小连接算法</p><p> 在多个服务器中，与处理连接数(会话数)最少的服务器进行通信的算法。由于后端服务器的配置不尽相同，对于请求的处理有快有慢，最小连接数法根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</p><p> 可以事先为每台服务器分配处理连接的数量，并将客户端请求转至连接数最少的服务器上。</p></li><li><p>源地址哈希法</p><p> 根据获取客户端的IP地址，通过哈希函数计算得到一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，相同的IP客户端，如果服务器列表不变，将映射到同一个后台服务器进行访问。</p><p> 当客户端有一系列业务需要处理而必须和一个服务器反复通信时，该算法能够以流(会话)为单位，保证来自相同客户端的通信能够一直在同一服务器中进行处理。</p></li></ol><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># server1</span><br><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    server_name local.load.com;</span><br><span class="line">    index index.html;</span><br><span class="line">    root /home/www;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Load Balance</span><br><span class="line">upstream load.com.conf &#123;</span><br><span class="line">    server 192.168.1.101:80;</span><br><span class="line">    server 192.168.1.102:80;</span><br><span class="line">    server 127.0.0.1:8080;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"># web server</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name local.load.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass              http://load.com.conf;</span><br><span class="line">        #proxy_set_header        Host    $host;</span><br><span class="line">        #proxy_set_header        X-Real-IP       $remotr_addr;</span><br><span class="line">        #proxy_set_header        X-Forwarde-For  $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># server2 192.168.1.101</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name local.load.com;</span><br><span class="line">    root /home/www;</span><br><span class="line">    location / &#123;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># server3 192.168.1.102</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name local.load.com;</span><br><span class="line">    root /home/www;</span><br><span class="line">    location / &#123;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="详细配置"><a href="#详细配置" class="headerlink" title="详细配置"></a>详细配置</h3><p>轮询模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream load.com.conf &#123;</span><br><span class="line">   server 192.168.0.1;</span><br><span class="line">   server 192.168.0.2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加权轮询模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream load.com.conf &#123;</span><br><span class="line">   server 192.168.0.1 weight=3;</span><br><span class="line">   server 192.168.0.2 weight=2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源地址哈希法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream load.com.conf &#123;</span><br><span class="line">   ip_hash;</span><br><span class="line">   server 192.168.0.1 weight=3;</span><br><span class="line">   server 192.168.0.2 weight=2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fair（第三方）：按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream load.com.conf &#123;  </span><br><span class="line">  server server1;  </span><br><span class="line">  server server2;  </span><br><span class="line">  fair;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>url_hash（第三方）：按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</p><p>例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream load.com.conf &#123;  </span><br><span class="line">  server squid1:3128;  </span><br><span class="line">  server squid2:3128;  </span><br><span class="line">  hash $request_uri;  </span><br><span class="line">  hash_method crc32;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">upstream bakend &#123;</span><br><span class="line">  ip_hash;  </span><br><span class="line">  server 127.0.0.1:9090 down;  </span><br><span class="line">  server 127.0.0.1:8080 weight=2;  </span><br><span class="line">  server 127.0.0.1:6060;  </span><br><span class="line">  server 127.0.0.1:7070 backup;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要使用负载均衡的server中增加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_pass http://bakend/;</span><br></pre></td></tr></table></figure><p>每个设备的状态设置为：</p><ul><li>down 表示单前的server暂时不参与负载 </li><li>weight 默认为1.weight越大，负载的权重就越大。 </li><li>max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误 </li><li>fail_timeout:max_fails次失败后，暂停的时间。 </li><li>backup： 其它所有的非backup机器down或者忙的时候，请求backup</li></ul>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Nginx </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL索引与优化(explain)</title>
      <link href="/2018/07/17/MySQL%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BC%98%E5%8C%96(explain)/"/>
      <url>/2018/07/17/MySQL%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BC%98%E5%8C%96(explain)/</url>
      <content type="html"><![CDATA[<h3 id="一、-创建索引"><a href="#一、-创建索引" class="headerlink" title="一、 创建索引"></a>一、 创建索引</h3><h5 id="1-普通索引-最基本的索引，无任何限制"><a href="#1-普通索引-最基本的索引，无任何限制" class="headerlink" title="1.普通索引(最基本的索引，无任何限制)"></a>1.普通索引(最基本的索引，无任何限制)</h5><p>(1)创建索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name ON table(column(length))</span><br></pre></td></tr></table></figure></p><p>(2)删除索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX index_name ON table</span><br></pre></td></tr></table></figure></p><a id="more"></a><h5 id="2-唯一索引（索引列的值必须唯一，但允许有空值）"><a href="#2-唯一索引（索引列的值必须唯一，但允许有空值）" class="headerlink" title="2.唯一索引（索引列的值必须唯一，但允许有空值）"></a>2.唯一索引（索引列的值必须唯一，但允许有空值）</h5><p>创建索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX indexName ON table(column(length))</span><br></pre></td></tr></table></figure></p><h5 id="3-主键索引（一个表的主键）"><a href="#3-主键索引（一个表的主键）" class="headerlink" title="3.主键索引（一个表的主键）"></a>3.主键索引（一个表的主键）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `table` (</span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    `title` char(255) NOT NULL ,</span><br><span class="line">    PRIMARY KEY (`id`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="4-组合索引（将多个列组合在一起创建索引）"><a href="#4-组合索引（将多个列组合在一起创建索引）" class="headerlink" title="4.组合索引（将多个列组合在一起创建索引）"></a>4.组合索引（将多个列组合在一起创建索引）</h5><p>mysql执行查询中，只会使用到一个索引</p><p>最左前缀：意思是使用组合索引的时候，从左到右依次匹配，否则不会使用组合索引。  </p><blockquote><p>例如<code>ALTER TABLE people ADD INDEX lname_fname_age (lame,fname,age);</code>其实我们是建立了三个索引，分别是：单列索引lame，组合索引（lame，fname），组合索引（lame，fname，age），mysql索引的时候只会使用其中一个索引。</p></blockquote><p>所以创建组合索引的时候，尽量把使用频繁的放在左边</p><h3 id="二、索引创建的原则和注意事项"><a href="#二、索引创建的原则和注意事项" class="headerlink" title="二、索引创建的原则和注意事项"></a>二、索引创建的原则和注意事项</h3><ul><li>1.最适合创建索引的是出现在where子句中的列或是出现在连接子句中的列</li><li>2.对字符串类型进行索引的时候，应该指定一个前缀长度，比如索引前多少个字符  </li><li>3.根据业务情况创建组合索引（比如某个业务需要查询两个列）</li><li>4.组合索引遵循前缀原则（最左前缀原则）TODO  </li><li><p>5.like查询，%不能在前，可以使用全文检索引擎</p><ul><li>例如： where name like ‘%wang%’，查询姓名中有wang的，此时索引不会生效，还是会全表扫描，因为前面有个%，如果是like ‘wang%’这样会使用到索引，但是没有前缀匹配了，如果想达到索引的效果，可以使用全文检索引擎，例如es（Elasticsearch）</li></ul></li><li><p>6.如果mysql觉得全表扫描比索引扫描快，他会自动放弃使用索引</p></li><li><p>7.mysql查询只使用一个索引，如果where子句中使用了索引，那么order by中的列是不会使用索引的</p></li><li><p>8.列中包含null值是不会使用索引的，如果column_name is null还是会使用索引，但是建表的时候尽量设置一个非null的默认值。</p></li></ul><h1 id="explain分析sql语句"><a href="#explain分析sql语句" class="headerlink" title="explain分析sql语句"></a>explain分析sql语句</h1><p>现有如下的sql语句<code>EXPLAIN SELECT * FROM inventory WHERE item_id = 16102176;</code><br>打印结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">id: 1  </span><br><span class="line">select_type: SIMPLE  </span><br><span class="line">table: inventory  </span><br><span class="line">type: ref  </span><br><span class="line">possible_keys: item_id  </span><br><span class="line">key: item_id  </span><br><span class="line">key_len: 4  </span><br><span class="line">ref: const  </span><br><span class="line">rows: 1  </span><br><span class="line">Extra: Using where</span><br></pre></td></tr></table></figure><ul><li>1.key: 指出优化器使用的索引。</li><li>2.rows: mysql认为他查询必须要检查的行数，优化器估计值。</li><li>3.possible_keys: 支出优化器为查询选定的索引</li><li>4.key_len: sql语句的连接条件的键的长度</li><li>5.select_type: select使用的类型。  <pre><code>+ simple（简单的select不含union或子查询）、+ primary（最外面的select）、+ union（union中第二个或后面的select）、+ dependent union（union中第二个或后面的select，取决于外面的查询）、+ union result（union的结果）、 + subquery（子查询中第一个select）</code></pre></li><li>6.type： 连接类型。system（表仅有一行）、const（表最多有一个匹配行）、eq_ref(对于每个前面的表的行组合，从该表中读取一行)、ref（对于每个来自于前面表的行组合，所有匹配索引值将从这张表中读取）、index_merge(使用了索引合并优化方法)、all（完整的表扫描）</li><li>7.ref： 显示使用哪个列或常数与key一起从表中选择行</li></ul>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL慢查询机制</title>
      <link href="/2018/07/02/MySQL%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/07/02/MySQL%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>开启慢查询日志，可以让MySQL记录下查询超过指定时间的语句，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。</p><h3 id="二、参数说明"><a href="#二、参数说明" class="headerlink" title="二、参数说明"></a>二、参数说明</h3><ul><li>slow_query_log 慢查询开启状态</li><li>slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）</li><li>long_query_time 查询超过多少秒才记录</li></ul><a id="more"></a><p>###三、设置步骤</p><h5 id="1-查询慢查询相关的参数"><a href="#1-查询慢查询相关的参数" class="headerlink" title="1. 查询慢查询相关的参数"></a>1. 查询慢查询相关的参数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;slow_query%&apos;;</span><br><span class="line">+---------------------------+----------------------------------+</span><br><span class="line">| Variable_name             | Value                            |</span><br><span class="line">+---------------------------+----------------------------------+</span><br><span class="line">| slow_query_log            | OFF                              |</span><br><span class="line">| slow_query_log_file       | /mysql/data/localhost-slow.log   |</span><br><span class="line">+---------------------------+----------------------------------+</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;long_query_time&apos;;</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   | Value     |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| long_query_time | 10.000000 |</span><br><span class="line">+-----------------+-----------+</span><br></pre></td></tr></table></figure><h5 id="2-设置方法"><a href="#2-设置方法" class="headerlink" title="2. 设置方法"></a>2. 设置方法</h5><p>(1)全局变量设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">设置slow_query_log为on</span><br><span class="line">mysql&gt; set global slow_query_log=&apos;ON&apos;; </span><br><span class="line">设置慢查询日志存放位置</span><br><span class="line">mysql&gt; set global slow_query_log_file=&apos;/var/logs/mysql/data/slow.log&apos;;</span><br><span class="line">设置查询时间超过一秒就记录</span><br><span class="line">mysql&gt; set global long_query_time=1;</span><br></pre></td></tr></table></figure><p>(2)修改配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log = ON</span><br><span class="line">slow_query_log_file = /usr/local/mysql/data/slow.log</span><br><span class="line">long_query_time = 1</span><br></pre></td></tr></table></figure><h3 id="四、pt-query-digest分析慢查询日志"><a href="#四、pt-query-digest分析慢查询日志" class="headerlink" title="四、pt-query-digest分析慢查询日志"></a>四、pt-query-digest分析慢查询日志</h3><h5 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h5><p>pt-query-digest是用于分析mysql慢查询的一个工具，它可以分析binlog、General log、slowlog，也可以通过SHOWPROCESSLIST或者通过tcpdump抓取的MySQL协议数据来进行分析。可以把分析结果输出到文件中，分析过程是先对查询语句的条件进行参数化，然后对参数化以后的查询进行分组统计，统计出各查询的执行时间、次数、占比等，可以借助分析结果找出问题进行优化。</p><h5 id="2-安装-官网"><a href="#2-安装-官网" class="headerlink" title="2. 安装 官网"></a>2. 安装 <a href="http://www.cnblogs.com/luyucheng/p/6265873.html" target="_blank" rel="noopener">官网</a></h5><p>(1)安装perl的模块</p><pre><code>yum install -y perl-CPAN perl-Time-HiRes</code></pre><p>(2)安装步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rpm安装：</span><br><span class="line">cd /usr/local/src</span><br><span class="line">wget percona.com/get/percona-toolkit.rpm</span><br><span class="line">yum install -y percona-toolkit.rpm</span><br><span class="line"></span><br><span class="line">源码安装：</span><br><span class="line">cd /usr/local/src</span><br><span class="line">wget percona.com/get/percona-toolkit.tar.gz</span><br><span class="line">tar zxf percona-toolkit.tar.gz</span><br><span class="line">cd percona-toolkit-2.2.19</span><br><span class="line">perl Makefile.PL PREFIX=/usr/local/percona-toolkit</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>(3) <a href="https://www.percona.com/doc/percona-toolkit/2.2/index.html" target="_blank" rel="noopener">用法简介</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.慢查询日志分析</span><br><span class="line">pt-query-digest /var/logs/mysql/data/slow.log</span><br><span class="line">2.服务器摘要</span><br><span class="line">pt-summary</span><br><span class="line">3.服务器磁盘监测</span><br><span class="line">pt-diskstats</span><br><span class="line">4.mysql服务状态摘要</span><br><span class="line">pt-mysql-summary -- --user=root --password=root123</span><br></pre></td></tr></table></figure><h5 id="3-pt-query-digest语法及重要选项"><a href="#3-pt-query-digest语法及重要选项" class="headerlink" title="3. pt-query-digest语法及重要选项"></a>3. pt-query-digest语法及重要选项</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest [OPTIONS] [FILES] [DSN]</span><br><span class="line">--create-review-table  当使用--review参数把分析结果输出到表中时，如果没有表就自动创建。</span><br><span class="line">--create-history-table  当使用--history参数把分析结果输出到表中时，如果没有表就自动创建。</span><br><span class="line">--filter  对输入的慢查询按指定的字符串进行匹配过滤后再进行分析</span><br><span class="line">--limit    限制输出结果百分比或数量，默认值是20,即将最慢的20条语句输出，如果是50%则按总响应时间占比从大到小排序，输出到总和达到50%位置截止。</span><br><span class="line">--host  mysql服务器地址</span><br><span class="line">--user  mysql用户名</span><br><span class="line">--password  mysql用户密码</span><br><span class="line">--history 将分析结果保存到表中，分析结果比较详细，下次再使用--history时，如果存在相同的语句，且查询所在的时间区间和历史表中的不同，则会记录到数据表中，可以通过查询同一CHECKSUM来比较某类型查询的历史变化。</span><br><span class="line">--review 将分析结果保存到表中，这个分析只是对查询条件进行参数化，一个类型的查询一条记录，比较简单。当下次使用--review时，如果存在相同的语句分析，就不会记录到数据表中。</span><br><span class="line">--output 分析结果输出类型，值可以是report(标准分析报告)、slowlog(Mysql slow log)、json、json-anon，一般使用report，以便于阅读。</span><br><span class="line">--since 从什么时间开始分析，值为字符串，可以是指定的某个”yyyy-mm-dd [hh:mm:ss]”格式的时间点，也可以是简单的一个时间值：s(秒)、h(小时)、m(分钟)、d(天)，如12h就表示从12小时前开始统计。</span><br><span class="line">--until 截止时间，配合—since可以分析一段时间内的慢查询。</span><br></pre></td></tr></table></figure><h5 id="4-分析pt-query-digest输出结果"><a href="#4-分析pt-query-digest输出结果" class="headerlink" title="4. 分析pt-query-digest输出结果"></a>4. 分析pt-query-digest输出结果</h5><blockquote><p>第一部分：总体统计结果</p></blockquote><ul><li>Overall：总共有多少条查询</li><li>Time range：查询执行的时间范围</li><li>unique：唯一查询数量，即对查询条件进行参数化以后，总共有多少个不同的查询</li><li>total：总计   min：最小   max：最大  avg：平均</li><li>95%：把所有值从小到大排列，位置位于95%的那个数，这个数一般最具有参考价值</li><li>median：中位数，把所有值从小到大排列，位置位于中间那个数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 该工具执行日志分析的用户时间，系统时间，物理内存占用大小，虚拟内存占用大小</span><br><span class="line"># 340ms user time, 140ms system time, 23.99M rss, 203.11M vsz</span><br><span class="line"># 工具执行时间</span><br><span class="line"># Current date: Fri Nov 25 02:37:18 2016</span><br><span class="line"># 运行分析工具的主机名</span><br><span class="line"># Hostname: localhost.localdomain</span><br><span class="line"># 被分析的文件名</span><br><span class="line"># Files: slow.log</span><br><span class="line"># 语句总数量，唯一的语句数量，QPS，并发数</span><br><span class="line"># Overall: 2 total, 2 unique, 0.01 QPS, 0.01x concurrency ________________</span><br><span class="line"># 日志记录的时间范围</span><br><span class="line"># Time range: 2016-11-22 06:06:18 to 06:11:40</span><br><span class="line"># 属性               总计      最小    最大    平均    95%  标准    中等</span><br><span class="line"># Attribute          total     min     max     avg     95%  stddev  median</span><br><span class="line"># ============     ======= ======= ======= ======= ======= ======= =======</span><br><span class="line"># 语句执行时间</span><br><span class="line"># Exec time             3s   640ms      2s      1s      2s   999ms      1s</span><br><span class="line"># 锁占用时间</span><br><span class="line"># Lock time            1ms       0     1ms   723us     1ms     1ms   723us</span><br><span class="line"># 发送到客户端的行数</span><br><span class="line"># Rows sent              5       1       4    2.50       4    2.12    2.50</span><br><span class="line"># select语句扫描行数</span><br><span class="line"># Rows examine     186.17k       0 186.17k  93.09k 186.17k 131.64k  93.09k</span><br><span class="line"># 查询的字符数</span><br><span class="line"># Query size           455      15     440  227.50     440  300.52  227.50</span><br></pre></td></tr></table></figure><blockquote><p>第二部分：查询分组统计结果</p><ul><li>Rank：所有语句的排名，默认按查询时间降序排列，通过–order-by指定</li><li>Query ID：语句的ID，（去掉多余空格和文本字符，计算hash值）</li><li>Response：总的响应时间</li><li>time：该查询在本次分析中总的时间占比</li><li>calls：执行次数，即本次分析总共有多少条这种类型的查询语句</li><li>R/Call：平均每次执行的响应时间</li><li>V/M：响应时间Variance-to-mean的比率</li><li>Item：查询对象</li></ul></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Profile</span><br><span class="line"># Rank Query ID           Response time Calls R/Call V/M   Item</span><br><span class="line"># ==== ================== ============= ===== ====== ===== ===============</span><br><span class="line">#    1 0xF9A57DD5A41825CA  2.0529 76.2%     1 2.0529  0.00 SELECT</span><br><span class="line">#    2 0x4194D8F83F4F9365  0.6401 23.8%     1 0.6401  0.00 SELECT wx_member_base</span><br></pre></td></tr></table></figure><blockquote><p>第三部分：每一种查询的详细统计结果</p></blockquote><p>由下面查询的详细统计结果，最上面的表格列出了执行次数、最大、最小、平均、95%等各项目的统计。</p><ul><li>ID：查询的ID号，和上图的Query ID对应</li><li>Databases：数据库名</li><li>Users：各个用户执行的次数（占比）</li><li>Query_time distribution ：查询时间分布, 长短体现区间占比，本例中1s-10s之间查询数量是10s以上的两倍。</li><li>Tables：查询中涉及到的表</li><li>Explain：SQL语句</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># Query 1: 0 QPS, 0x concurrency, ID 0xF9A57DD5A41825CA at byte 802 ______</span><br><span class="line"># This item is included in the report because it matches --limit.</span><br><span class="line"># Scores: V/M = 0.00</span><br><span class="line"># Time range: all events occurred at 2016-11-22 06:11:40</span><br><span class="line"># Attribute    pct   total     min     max     avg     95%  stddev  median</span><br><span class="line"># ============ === ======= ======= ======= ======= ======= ======= =======</span><br><span class="line"># Count         50       1</span><br><span class="line"># Exec time     76      2s      2s      2s      2s      2s       0      2s</span><br><span class="line"># Lock time      0       0       0       0       0       0       0       0</span><br><span class="line"># Rows sent     20       1       1       1       1       1       0       1</span><br><span class="line"># Rows examine   0       0       0       0       0       0       0       0</span><br><span class="line"># Query size     3      15      15      15      15      15       0      15</span><br><span class="line"># String:</span><br><span class="line"># Databases    test</span><br><span class="line"># Hosts        192.168.8.1</span><br><span class="line"># Users        mysql</span><br><span class="line"># Query_time distribution</span><br><span class="line">#   1us</span><br><span class="line">#  10us</span><br><span class="line"># 100us</span><br><span class="line">#   1ms</span><br><span class="line">#  10ms</span><br><span class="line"># 100ms</span><br><span class="line">#    1s  ################################################################</span><br><span class="line">#  10s+</span><br><span class="line"># EXPLAIN /*!50100 PARTITIONS*/</span><br><span class="line">select sleep(2)\G</span><br></pre></td></tr></table></figure><h3 id="五、用法"><a href="#五、用法" class="headerlink" title="五、用法"></a>五、用法</h3><h5 id="1-直接分析慢查询文件"><a href="#1-直接分析慢查询文件" class="headerlink" title="1.直接分析慢查询文件"></a>1.直接分析慢查询文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest  slow.log &gt; slow_report.log</span><br></pre></td></tr></table></figure><h5 id="2-分析最近十二小时内的查询"><a href="#2-分析最近十二小时内的查询" class="headerlink" title="2.分析最近十二小时内的查询"></a>2.分析最近十二小时内的查询</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest  --since=12h  slow.log &gt; slow_report2.log</span><br></pre></td></tr></table></figure><h5 id="3-分析指定时间范围内的查询"><a href="#3-分析指定时间范围内的查询" class="headerlink" title="3.分析指定时间范围内的查询**"></a>3.分析指定时间范围内的查询**</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest slow.log --since &apos;2017-01-07 09:30:00&apos; --until &apos;2017-01-07 10:00:00&apos;&gt; &gt; slow_report3.log</span><br></pre></td></tr></table></figure><h5 id="4-分析含有select语句的慢查询"><a href="#4-分析含有select语句的慢查询" class="headerlink" title="4.分析含有select语句的慢查询"></a>4.分析含有select语句的慢查询</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest --filter &apos;$event-&gt;&#123;fingerprint&#125; =~ m/^select/i&apos; slow.log&gt; slow_report4.log</span><br></pre></td></tr></table></figure><h5 id="5-针对某个用户的查询"><a href="#5-针对某个用户的查询" class="headerlink" title="5.针对某个用户的查询"></a>5.针对某个用户的查询</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest --filter &apos;($event-&gt;&#123;user&#125; || &quot;&quot;) =~ m/^root/i&apos; slow.log&gt; slow_report5.log</span><br></pre></td></tr></table></figure><h5 id="6-查询所有-所有的全表扫描或full-join的慢查询"><a href="#6-查询所有-所有的全表扫描或full-join的慢查询" class="headerlink" title="6.查询所有 所有的全表扫描或full join的慢查询"></a>6.查询所有 所有的全表扫描或full join的慢查询</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest --filter &apos;(($event-&gt;&#123;Full_scan&#125; || &quot;&quot;) eq &quot;yes&quot;) ||(($event-&gt;&#123;Full_join&#125; || &quot;&quot;) eq &quot;yes&quot;)&apos; slow.log&gt; slow_report6.log</span><br></pre></td></tr></table></figure><h5 id="7-把查询保存到query-review表"><a href="#7-把查询保存到query-review表" class="headerlink" title="7.把查询保存到query_review表"></a>7.把查询保存到query_review表</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest --user=root –password=abc123 --review  h=localhost,D=test,t=query_review--create-review-table  slow.log</span><br></pre></td></tr></table></figure><h5 id="8-把查询结果保存到query-history表"><a href="#8-把查询结果保存到query-history表" class="headerlink" title="8.把查询结果保存到query_history表"></a>8.把查询结果保存到query_history表</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest  --user=root –password=abc123 --review  h=localhost,D=test,t=query_history--create-review-table  slow.log_0001</span><br><span class="line">pt-query-digest  --user=root –password=abc123 --review  h=localhost,D=test,t=query_history--create-review-table  slow.log_0002</span><br></pre></td></tr></table></figure><h5 id="9-通过tcpdump抓取mysql的tcp协议数据，然后分析"><a href="#9-通过tcpdump抓取mysql的tcp协议数据，然后分析" class="headerlink" title="9.通过tcpdump抓取mysql的tcp协议数据，然后分析"></a>9.通过tcpdump抓取mysql的tcp协议数据，然后分析</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -s 65535 -x -nn -q -tttt -i any -c 1000 port 3306 &gt; mysql.tcp.txt</span><br><span class="line">pt-query-digest --type tcpdump mysql.tcp.txt&gt; slow_report9.log</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>聚簇索引与非聚簇索引的区别</title>
      <link href="/2018/06/17/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/06/17/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>通常情况下，建立索引是加快查询速度的有效手段。但索引不是万能的，靠索 引并不能实现对所有数据的快速存取。事实上，如果索引策略和数据检索需求严重不符的话，建立索引反而会降低查询性能。因此在实际使用当中，应该充分考虑到 索引的开销，包括磁盘空间的开销及处理开销（如资源竞争和加锁）。例如，如果数据频繁的更新或删加，就不宜建立索引。</p><a id="more"></a><p>本文简要讨论一下聚簇索引的特点及其与非聚簇索引的区别。</p><h5 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h5><p>数据库表的索引从数据存储方式上可以分为聚簇索引和非聚簇索引（又叫二级索引）两种。Innodb的聚簇索引在同一个B-Tree中保存了索引列和具体的数据，在聚簇索引中，实际的数据保存在叶子页中，中间的节点页保存指向下一层页面的指针。“聚簇”的意思是数据行被按照一定顺序一个个紧密地排列在一起存储。一个表只能有一个聚簇索引，因为在一个表中数据的存放方式只有一种。</p><blockquote><p>一般来说，将通过主键作为聚簇索引的索引列，也就是通过主键聚集数据。</p></blockquote><h5 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h5><p>非聚簇索引，又叫二级索引。二级索引的叶子节点中保存的不是指向行的物理指针，而是行的主键值。当通过二级索引查找行，存储引擎需要在二级索引中找到相应的叶子节点，获得行的主键值，然后使用主键去聚簇索引中查找数据行，这需要两次B-Tree查找。</p><h5 id="建立索引："><a href="#建立索引：" class="headerlink" title="建立索引："></a>建立索引：</h5><p>在SQL语言中，建立聚簇索引使用CREATE INDEX语句，格式为：CREATE CLUSTER INDEX index_name ON table_name(column_name1,column_name2,…);</p><h5 id="存储特点："><a href="#存储特点：" class="headerlink" title="存储特点："></a>存储特点：</h5><ul><li>聚集索引。表数据按照索引的顺序来存储的，也就是说索引项的顺序与表中记录的物理顺序一致。对于聚集索引，叶子结点即存储了真实的数据行，不再有另外单独的数据页。 在一张表上最多只能创建一个聚集索引，因为真实数据的物理顺序只能有一种。</li><li>非聚集索引。表数据存储顺序与索引顺序无关。对于非聚集索引，叶结点包含索引字段值及指向数据页数据行的逻辑指针，其行数量与数据表行数据量一致。</li></ul><blockquote><p> 总结一下：聚集索引是一种稀疏索引，数据页上一级的索引页存储的是页指针，而不是行指针。而对于非聚集索引，则是密集索引，在数据页的上一级索引页它为每一个数据行存储一条索引记录。</p></blockquote><p>更新表数据</p><ul><li>1、向表中插入新数据行</li></ul><p>​    如果一张表没有聚集索引，那么它被称为“堆集”（Heap）。这样的表中的数据行没有特定的顺序，所有的新行将被添加到表的末尾位置。而建立了聚簇索引的数据表则不同：最简单的情况下，插入操作根据索引找到对应的数据页，然后通过挪动已有的记录为新数据腾出空间，最后插入数据。如果数据页已满，则需要拆分数据页，调整索引指针（且如果表还有非聚集索引，还需要更新这些索引指向新的数据页）。而类似于自增列为聚集索引的，数据库系统可能并不拆分数据页，而只是简单的新添数据页。</p><ul><li>2、从表中删除数据行</li></ul><p>对删除数据行来说：删除行将导致其下方的数据行向上移动以填充删除记录造成的空白。如果删除的行是该数据页中的最后一行，那么该数据页将被回收，相应的索 引页中的记录将被删除。对于数据的删除操作，可能导致索引页中仅有一条记录，这时，该记录可能会被移至邻近的索引页中，原索引页将被回收，即所谓的“索引 合并”。</p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS游戏——关于马甲包与审核</title>
      <link href="/2018/05/26/iOS%E6%B8%B8%E6%88%8F%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8E%E9%A9%AC%E7%94%B2%E5%8C%85%E4%B8%8E%E5%AE%A1%E6%A0%B8/"/>
      <url>/2018/05/26/iOS%E6%B8%B8%E6%88%8F%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8E%E9%A9%AC%E7%94%B2%E5%8C%85%E4%B8%8E%E5%AE%A1%E6%A0%B8/</url>
      <content type="html"><![CDATA[<p>最近因为工作的原因，博客与公众号停了近一个月，网站也没有及时更新，实在抱歉！当初也不知道哪里来的冲动，脑子一热就离开了多年的城市@广州，去了一个鸟都不拉屎的地方@东莞（有点夸张了，老铁！）。</p><p>本以为是一个新的开始，本以为可以进入一个新的台阶，没料想，半年之久就遍体鳞伤的回到的这个梦想最开始的地方，其中的心酸就不便多说了，当然也让我学到了不少东西，认识了不少朋友和牛人……今天我们来聊的话题是：甲包与审核……</p><a id="more"></a><h2 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h2><p>离开东莞之后，来到广州的一家新公司（创业公司），开始从事小说类游戏开发，说来也惭愧，以前不怎么玩游戏，最多偶尔玩一下近期比较火的游戏，也没有从事过任何游戏开发的工作，有几次有朋友看到我的英文名@iCocos都会问我，你之前事做游戏开发吗？当时我也只能无奈的解释一下：</p><blockquote><p>iCocos的含义是 i+ Coco + s = 苹果 + Cocoa Touch + s</p></blockquote><p>取这个名字的原因是，一直以来都是从事iOS开发，而且对这一块比较喜欢，也很喜欢苹果的产品！</p><ul><li>接触iOS行业也有近四年多，第一次有幸进入游戏这个行业，以前很多同行（非游戏行业）朋友，包括我，一听到游戏行业和游戏开发就觉得很可怕。工资高，加班多——这是是很多人对游戏的行业的最初认识。</li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>项目启动不久，就接到公司内部关于游戏马甲包的整个对接与提审任务，后续也会一直负责这个任务，因为之前是由总部的一个多年Android开发并且有过一些iOS开发经验的同事负责，后面我进来之后iOS这一块也就有我对接处理了，当然其实有很多，我处理的只是其中一两个！</p></blockquote><p>因为之前上架过不少次，当时还是挺有自信的，但是经过了解和沟通之后发现其实并不是相信中的那么简单。</p><p>我还专门花时间在网上，群里，各大论坛和学习网站寻找相关的资料，希望能有一点帮忙！</p><ul><li>其中提到最多的就是关于审核的问题，而且这边同事也说了关于马甲包的审核，通过与否基本上靠运气，而且概率非常低！</li></ul><h2 id="关于马甲包"><a href="#关于马甲包" class="headerlink" title="关于马甲包"></a>关于马甲包</h2><h5 id="那么说了这么多，什么是马甲包呢？"><a href="#那么说了这么多，什么是马甲包呢？" class="headerlink" title="那么说了这么多，什么是马甲包呢？"></a>那么说了这么多，什么是马甲包呢？</h5><blockquote><p>马甲APP指的是为了让认识你的人猜不到,在常用的用户名外再注册的其他名字的APP。</p></blockquote><h5 id="马甲APP与真实APP的区别是什么-相同的地方是什么"><a href="#马甲APP与真实APP的区别是什么-相同的地方是什么" class="headerlink" title="马甲APP与真实APP的区别是什么?相同的地方是什么?"></a>马甲APP与真实APP的区别是什么?相同的地方是什么?</h5><ol><li>应用名称不一样。</li><li>关键词不一样。</li><li>应用图标。不一样。</li><li>应用截图。可以一样,也可以不一样,不做要求。</li><li>开屏图片。最好不一样。</li><li>其余的,比如主APP的一些品牌因素,最好去掉。因为马甲是要用来做坏事的,当然不能让人察觉咯。</li></ol><p>以上出自网络：关于为什么要做马甲APP? 马甲APP怎么做? 马甲APP需要事项? 可以查看下面网络来源说明:</p><ul><li><a href="http://www.chinaz.com/manage/2015/1102/465127.shtml" target="_blank" rel="noopener">什么是马甲APP？怎么用马甲APP导流</a></li></ul><h2 id="对接事项"><a href="#对接事项" class="headerlink" title="对接事项"></a>对接事项</h2><h5 id="一直以来我们做的APP一般都是这几种情况："><a href="#一直以来我们做的APP一般都是这几种情况：" class="headerlink" title="一直以来我们做的APP一般都是这几种情况："></a>一直以来我们做的APP一般都是这几种情况：</h5><ol><li>从零开始发一个完整的项目，然后提审上线。</li><li>接手一个已经开发到一部分或者已经上线的迭代项目，然后提审上线。</li><li>接手一个审核被拒，根据苹果给出的条款修改内容，然后提审上线</li><li>有一些外包或者项目和公司比较特殊的情况</li></ol><h5 id="但是正因为是马甲包，所以比较例外，例外在哪里呢？"><a href="#但是正因为是马甲包，所以比较例外，例外在哪里呢？" class="headerlink" title="但是正因为是马甲包，所以比较例外，例外在哪里呢？"></a>但是正因为是马甲包，所以比较例外，例外在哪里呢？</h5><ol><li>我拿不到源码，改不了App内部的任何界面与效果</li><li>我只要修改提审内容信息，然后向渠道回到进度</li><li>审核几率非常低，而且经常要切换Apple账户处理</li><li>……</li></ol><h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><h5 id="所以在处理之前我这边其实大概根据之前的上线经验整理了一下具体的对接事项和具体步骤："><a href="#所以在处理之前我这边其实大概根据之前的上线经验整理了一下具体的对接事项和具体步骤：" class="headerlink" title="所以在处理之前我这边其实大概根据之前的上线经验整理了一下具体的对接事项和具体步骤："></a>所以在处理之前我这边其实大概根据之前的上线经验整理了一下具体的对接事项和具体步骤：</h5><ol><li>使用（或新）apple账号 </li><li>apple developer生成并下载证书（开发与发布）</li><li>apple developer创建一个Bundle ID</li><li>apple developer添加设备ID</li><li>apple developer创建并下载描述文件（开发与发布）</li><li>itnues connect 创建一个对应ID的app</li><li>将证书导入到电脑钥匙串，右健对应证书到处P12</li><li>修改IAP支付信息（这种一般都是根据ID，不然会很麻烦）</li><li>提交或者修改App Icon，宣传图，应用名称,关键词,应用图标,文件等App和公司信息</li><li>将证书，描述文件，P12（+密码）和ID对应版本号ipa提供商</li><li>让他们根据重新出包，并提供新的ipa包</li><li>确认测试通过，并确认提审信息后，重新上传ipa</li><li>提交审核（使用手动发布模式）……</li><li>跟渠道那边及时反馈进度</li><li>审核没通过则重新以上步骤（不用换账号还好，换账号是最虐心的！！！）</li><li>审核通过则先完成以下两个步骤再点击：发布：<ul><li>1、通知CP切换到正式区服</li><li>2、通知我这边让后端把支付方式切换到第三方支付</li></ul></li></ol><blockquote><p>最后注意一点：</p><blockquote><p>有时候可能会涉及到SDK的处理，这个就要母包提前就准备好，并且根据实际需求替换对应的参数就可以<br>由于这里已经涉及到SDK开发与集成的基础，已经不属于马甲包的范围</p></blockquote></blockquote><h2 id="提审信息"><a href="#提审信息" class="headerlink" title="提审信息"></a>提审信息</h2><h4 id="以下是我提供的数据证书与App提审信息"><a href="#以下是我提供的数据证书与App提审信息" class="headerlink" title="以下是我提供的数据证书与App提审信息"></a>以下是我提供的数据证书与App提审信息</h4><h5 id="证书与ipa信息"><a href="#证书与ipa信息" class="headerlink" title="证书与ipa信息"></a>证书与ipa信息</h5><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/JMT/Games/证书与ipa信息.png" alt="曹理鹏(iCocos)-梦工厂"></p><h5 id="App提审信息"><a href="#App提审信息" class="headerlink" title="App提审信息"></a>App提审信息</h5><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/JMT/Games/提审信息.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>其实整个流程差不多就这么写，这里就不每一步网上都有对应的教程，而且很简单（傻瓜式），当然在整个过程也有可能遇到不少问题，这个就要根据个人经验和学习能力临时应变处理了，所以我就不一一介绍了。</p><h2 id="补充：Android流程与注意事项"><a href="#补充：Android流程与注意事项" class="headerlink" title="补充：Android流程与注意事项"></a>补充：Android流程与注意事项</h2><h5 id="以下是Android同事整理的流程与步骤，可能比较简洁，但是实际并没有这么简单，毕竟Android不像苹果那么多限制，仅供参考，具体流程还是要根据实际执行"><a href="#以下是Android同事整理的流程与步骤，可能比较简洁，但是实际并没有这么简单，毕竟Android不像苹果那么多限制，仅供参考，具体流程还是要根据实际执行" class="headerlink" title="以下是Android同事整理的流程与步骤，可能比较简洁，但是实际并没有这么简单，毕竟Android不像苹果那么多限制，仅供参考，具体流程还是要根据实际执行"></a>以下是Android同事整理的流程与步骤，可能比较简洁，但是实际并没有这么简单，毕竟Android不像苹果那么多限制，仅供参考，具体流程还是要根据实际执行</h5><ol><li>反编译 母包 并且 集成了渠道sdk的demo</li><li>打开两者 反编译之后的目录进行资源替换<ul><li>lib里面的so文件</li><li>smali源码</li><li>res的图片、value里面的资源</li><li>manifest的activity、权限等等，包名后面添加对应渠道的名字<blockquote><p>注意：(除了3011,其他的渠道包还要修改appId、clientKey、clientId)</p></blockquote></li></ul></li><li>在eclipse新建一个同包名的项目，</li><li>拷贝修改后母包的res覆盖进去，</li><li>修改冲突ids(游戏母包也要修改)，</li><li>编译得到apk，</li><li>再反编译这个apk，</li><li>拿到包名对应下面的R$xxxx.smail覆盖到母包里面</li></ol><blockquote><p>后面就是提交apk或者发包的内容了</p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><ul><li>那么说了这么多，好像里面学不到什么东西，我为什么还要写这篇文章呢？</li></ul><p>其实一开始不太想写，也确实没有太多有用的东西，但是我觉得写了还是会有一些用的！</p><ol><li>太久没有写博客和公众号了，有点手痒（哈哈！！！）</li><li>个人习惯，几乎接触第一次的领域，项目，技术都会简单记录一下</li><li>方便后面打算或者会负责此类任务的人，了解整个流程，也欢迎交流学习</li><li>最后一点其实也是最重要的，拒审多次，需求有经验的前辈，指点迷津！</li></ol>]]></content>
      
      <categories>
          
          <category> Games </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS游戏——关于马甲包与审核 </tag>
            
            <tag> Games </tag>
            
            <tag> 关于马甲包与审核 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入理解PHP之——LANMP原理详解</title>
      <link href="/2018/05/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E4%B9%8B%E2%80%94%E2%80%94LANMP%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/05/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E4%B9%8B%E2%80%94%E2%80%94LANMP%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id="LNMP的工作原理"><a href="#LNMP的工作原理" class="headerlink" title="LNMP的工作原理"></a>LNMP的工作原理</h3><p>浏览器发送http  request请求到服务器（Nginx）,服务器响应并处理web请求。如果是静态文本直接返回，否则将脚本（PHP）通过接口传输协议（网关协议）PHP-FCGI（fast-cgi）传输给PHP-FPM（进程管理程序）,然后PHP-FPM调用PHP解析器的其中一个进程PHP-CGI来解析php脚本信息。【PHP-FPM在启动时启动了多个PHP-CGI子进程，并发执行。】然后将解析后的脚本返回到PHP-FPM，PHP-FPM再通过fast-cgi的形式将脚本信息传送给Nginx。服务器再通过Http  response的形式传送给浏览器。浏览器再进行解析与渲染然后进行呈现。 </p><h3 id="LAMP的工作原理"><a href="#LAMP的工作原理" class="headerlink" title="LAMP的工作原理"></a>LAMP的工作原理</h3><p>浏览器向服务器发送http请求，服务器 (Apache)  接受请求,由于php作为Apache的组件模块也会一起启动，它们具有相同的生命周期。Apache会将一些静态资源保存，然后调用php去处理模块进行php脚本的处理。脚本处理完后，Apache将处理完的信息通过http  response的方式发送给浏览器，浏览器解析，渲染等一系列操作后呈现整个网页。</p><a id="more"></a><h3 id="LAMP-LNMP差别"><a href="#LAMP-LNMP差别" class="headerlink" title="LAMP LNMP差别"></a>LAMP LNMP差别</h3><ul><li>1、在LNMP中，Nginx本身对脚本不做任何的处理，而是把请求发fast-cgi管理进程处理，fast-cgi管理进程选择cgi子进程处理结果并返回，二者是相互独立的，通过管道进程通信。  </li><li>2、在LAMP中，PHP是Apache的一个模块，具有相同的生命周期。两者通过共享内存的方式通信。</li></ul><p>两者的PHP环境不相互适用<br>相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率</p><pre><code>nginx的的优势作为web服务器处理静态文件，索引文件，自动索引的效率非常高作为代理服务器，可以实现无缓存的反向代理，提高网站运行速度作为负载均衡服务器，可以在内部直接支持rails和php等性能方面，采用epoll模型，可以支持多并发并且占用低内存稳定方面，采取分段资源分配技术，CPU和内存占用率非常低,少量的dos攻击对nginx基本无作用，高可用方面,支持热部署，启动迅速，可以在不间断服务的情况下，直接升级7x24小时不间容灾nginx的模块和工作原理nginx由内核和模块组成，模块结构分为核心模块，基础模块，第三方模块核心模块: http模块，event模块，mail模块基础模块: http fastCGI模块，http proxy模块，http rewrite模块第三方模块: http upstream request hash 模块，notice模块，htttp access key 模块</code></pre><h3 id="Fast-CGI-介绍"><a href="#Fast-CGI-介绍" class="headerlink" title="Fast-CGI 介绍"></a>Fast-CGI 介绍</h3><p>cgi是通用网关接口，是外部应用程序与Web服务器之间的接口标准，cgi是为了保证web server传递过来的数据是标准格式的，方便cgi程序的编写者。</p><p>Fast-CGI是语言无关的、可伸缩架构的CGI开放扩展，其主要行为是将CGI解释器进程保持在内存中并因此获得较高的性能。众所周知，CGI解释器的反复加载是CGI性能低下的主要原因，如果CGI解释器保持在内存中并接受FastCGI进程管理器调度，则可以提供良好的性能、伸缩性、Fail-  Over特性等等。</p><p>Fast-cgi像是一个常驻(long-live)型的cgi，是用来提高cgi程序性能的。</p><blockquote><p>fast-CGI是nginx和php之间的一个通信接口，该接口实际处理过程通过启动php-fpm进程来解析php脚本，即php-fpm相当于一个动态应用服务器，从而实现nginx动态解析php。因此，如果nginx服务器需要支持php解析，需要在nginx.conf中增加php的配置；将php脚本转发到fastCGI进程监听的IP地址和端口（php-fpm.conf中指定）。同时，php安装的时候，需要开启支持fastCGI选项，并且编译安装php-fpm补丁/扩展，同时，需要启动php-fpm进程，才可以解析nginx通过fastCGI转发过来的php脚本。</p></blockquote><h3 id="Fast-CGI的工作原理"><a href="#Fast-CGI的工作原理" class="headerlink" title="Fast-CGI的工作原理"></a>Fast-CGI的工作原理</h3><ol><li>Web Server启动时载入Fast-CGI进程管理器（IIS ISAPI或Apache Module)</li><li>FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可见多个php-cgi)并等待来自Web Server的连接。</li><li>当客户端请求到达Web Server时，Fast-CGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到Fast-CGI子进程php-cgi。</li><li>Fast-CGI子进程完成处理后将标准输出和错误信息从同一连接返回Web  Server。当Fast-CGI子进程关闭连接时，请求便告处理完成。Fast-CGI子进程接着等待并处理来自Fast-CGI进程管理器(运行在Web  Server中)的下一个连接。 在CGI模式中，php-cgi在此便退出了。</li></ol><p>在上述情况中，你可以想象CGI通常有多慢。每一个Web请求PHP都必须重新解析php.ini、重新载入全部扩展并重初始化全部数据结构。使用Fast-CGI，所有这些都只在进程启动时发生一次。一个额外的好处是，持续数据库连接(Persistent  database connection)可以工作。</p><h3 id="Fast-CGI的不足"><a href="#Fast-CGI的不足" class="headerlink" title="Fast-CGI的不足"></a>Fast-CGI的不足</h3><p>因为是多进程，所以比CGI多线程消耗更多的服务器内存，PHP-CGI解释器每进程消耗7至25兆内存，将这个数字乘以50或100就是很大的内存数。</p><blockquote><p>Nginx 0.8.46+PHP  5.2.14(FastCGI)服务器在3万并发连接下，开启的10个Nginx进程消耗150M内存（15M<em>10=150M），开启的64个php-cgi进程消耗1280M内存（20M</em>64=1280M），加上系统自身消耗的内存，总共消耗不到2GB内存。如果服务器内存较小，完全可以只开启25个php-cgi进程，这样php-cgi消耗的总内存数才500M。</p></blockquote><p>上面的数据摘自Nginx 0.8.x + PHP 5.2.13(FastCGI)搭建胜过Apache十倍的Web服务器(第6版)</p><h3 id="PHP-FPM"><a href="#PHP-FPM" class="headerlink" title="PHP-FPM"></a>PHP-FPM</h3><p>PHP-FPM是一个实现了Fastcgi的程序，PHP-FPM的管理对象是php-cgi。被PHP官方收了。<br> 后来PHP内核集成了PHP-FPM之后就方便多了，使用–enalbe-fpm这个编译参数即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、php-fpm是一个完全独立的程序,不依赖php-cgi,也不依赖php。因为php-fpm是一个内置了php解释器的FastCGI服务,启动时能够自行读取php.ini配置和php-fpm.conf配置.</span><br><span class="line">2、一个master进程,支持多个pool,每个pool由master进程监听不同的端口,pool中有多个worker进程.</span><br><span class="line">3、每个worker进程都内置PHP解释器,并且进程常驻后台,支持prefork动态增加.</span><br><span class="line">4、每个worker进程支持在运行时编译脚本并在内存中缓存生成的opcode来提升性能.</span><br><span class="line">5、每个worker进程支持配置响应指定请求数后自动重启,master进程会重启挂掉的worker进程.</span><br><span class="line">6、每个worker进程能保持一个到MySQL/Memcached/Redis的持久连接,实现&quot;连接池&quot;,避免重复建立连接,对程序透明.</span><br><span class="line">7、master进程采用epoll模型异步接收和分发请求,listen监听端口,epoll_wait等待连接,</span><br><span class="line">8、然后分发给对应pool里的worker进程,worker进程accpet请求后poll处理连接,</span><br><span class="line">9、如果worker进程不够用,master进程会prefork更多进程,</span><br><span class="line">A、如果prefork达到了pm.max_children上限,worker进程又全都繁忙,这时master进程会把请求挂起到连接队列backlog里(默认值是511).12345678910</span><br></pre></td></tr></table></figure><h3 id="PHP-CGI"><a href="#PHP-CGI" class="headerlink" title="PHP-CGI"></a>PHP-CGI</h3><p>php-cgi 是解释PHP脚本的程序，只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理</p><h3 id="Nginx-FastCGI运行原理"><a href="#Nginx-FastCGI运行原理" class="headerlink" title="Nginx+FastCGI运行原理　"></a>Nginx+FastCGI运行原理　</h3><p>nginx不支持对外部程序的直接调用或者解析，所有的外部程序（包括PHP）必须通过FastCGI接口来调用。FastCGI接口在Linux下是socket（这个socket可以是文件socket，也可以是ip socket）。</p><blockquote><p>wrapper：  为了调用CGI程序，还需要一个FastCGI的wrapper（wrapper可以理解为用于启动另一个程序的程序），这个wrapper绑定在某个固定socket上，如端口或者文件socket。当Nginx将CGI请求发送给这个socket的时候，通过FastCGI接口，wrapper接收到请求，然后Fork(派生）出一个新的线程，这个线程调用解释器或者外部程序处理脚本并读取返回数据；接着，wrapper再将返回的数据通过FastCGI接口，沿着固定的socket传递给Nginx；最后，Nginx将返回的数据（html页面或者图片）发送给客户端。这就是Nginx+FastCGI的整个运作过程，</p></blockquote><p>所以，我们首先需要一个wrapper，这个wrapper需要完成的工作：</p><pre><code>1、通过调用fastcgi（库）的函数通过socket和ningx通信（读写socket是fastcgi内部实现的功能，对wrapper是非透明的） 2、调度thread，进行fork和kill 3、和application（php）进行通信 </code></pre>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> LNMP </tag>
            
            <tag> LAMP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入理解PHP之——HTTP请求全过程</title>
      <link href="/2018/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E4%B9%8B%E2%80%94%E2%80%94HTTP%E8%AF%B7%E6%B1%82%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E4%B9%8B%E2%80%94%E2%80%94HTTP%E8%AF%B7%E6%B1%82%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h5 id="一个完整的HTTP请求流程"><a href="#一个完整的HTTP请求流程" class="headerlink" title="一个完整的HTTP请求流程"></a>一个完整的HTTP请求流程</h5><blockquote><p>域名解析 —&gt; 与服务器建立连接 —&gt; 发起HTTP请求 —&gt; 服务器响应HTTP请求，浏览器得到html代码 —&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片） —&gt; 浏览器对页面进行渲染呈现给用户</p></blockquote><a id="more"></a><h4 id="1-域名解析"><a href="#1-域名解析" class="headerlink" title="1. 域名解析"></a>1. 域名解析</h4><p>以Chrome浏览器为例：</p><ul><li>① Chrome浏览器 会首先搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否有<a href="https://www.cnblogs.com" target="_blank" rel="noopener">https://www.cnblogs.com</a> 对应的条目，而且没有过期，如果有且没有过期则解析到此结束。</li></ul><p>注：我们怎么查看Chrome自身的缓存？可以使用 chrome://net-internals/#dns 来进行查看</p><ul><li>② 如果浏览器自身的缓存里面没有找到对应的条目，那么Chrome会搜索操作系统自身的DNS缓存,如果找到且没有过期则停止搜索解析到此结束.</li></ul><p>注：怎么查看操作系统自身的DNS缓存，以Windows系统为例，可以在命令行下使用 ipconfig /displaydns 来进行查看</p><ul><li>③ 如果在Windows系统的DNS缓存也没有找到，那么尝试读取hosts文件（位于C:\Windows\System32\drivers\etc），看看这里面有没有该域名对应的IP地址，如果有则解析成功。</li><li>④ 如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），找打根域的DNS地址，就会向其发起请求（请问<a href="http://www.cnblogs.com这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.cnblogs.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.cnblogs.com这个域名的IP地址，但是我知道cnblogs.com这个域的DNS地址，你去找它去，于是运营商的DNS又向cnblogs.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.cnblogs.com这个域名的IP地址是多少？），这个时候cnblogs.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.cnblogs.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.cnblogs.com" target="_blank" rel="noopener">www.cnblogs.com这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.cnblogs.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.cnblogs.com这个域名的IP地址，但是我知道cnblogs.com这个域的DNS地址，你去找它去，于是运营商的DNS又向cnblogs.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.cnblogs.com这个域名的IP地址是多少？），这个时候cnblogs.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.cnblogs.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.cnblogs.com</a> 对应的IP地址，该进行一步的动作了。</li></ul><p>注：一般情况下是不会进行以下步骤的</p><p>如果经过以上的4个步骤，还没有解析成功，那么会进行如下步骤（以下是针对Windows操作系统）：</p><ul><li>⑤ 操作系统就会查找NetBIOS name Cache（NetBIOS名称缓存，就存在客户端电脑中的），那这个缓存有什么东西呢？凡是最近一段时间内和我成功通讯的计算机的计算机名和Ip地址，就都会存在这个缓存里面。什么情况下该步能解析成功呢？就是该名称正好是几分钟前和我成功通信过，那么这一步就可以成功解析。</li><li>⑥ 如果第⑤步也没有成功，那会查询WINS 服务器（是NETBIOS名称和IP地址对应的服务器）</li><li>⑦ 如果第⑥步也没有查询成功，那么客户端就要进行广播查找</li><li>⑧ 如果第⑦步也没有成功，那么客户端就读取LMHOSTS文件（和HOSTS文件同一个目录下，写法也一样）</li></ul><p>如果第八步还没有解析成功，那么就宣告这次解析失败，那就无法跟目标计算机进行通信。只要这八步中有一步可以解析成功，那就可以成功和目标计算机进行通信。</p><h4 id="2-与服务器建立连接"><a href="#2-与服务器建立连接" class="headerlink" title="2. 与服务器建立连接"></a>2. 与服务器建立连接</h4><h5 id="2-1-TCP连接的建立"><a href="#2-1-TCP连接的建立" class="headerlink" title="2.1 TCP连接的建立"></a>2.1 TCP连接的建立</h5><p>客户端的请求到达服务器，首先就是建立TCP连接</p><ol><li><p>Client首先发送一个连接试探，ACK=0 表示确认号无效，SYN = 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，seq = x 表示Client自己的初始序号（seq = 0 就代表这是第0号包），这时候Client进入syn_sent状态，表示客户端等待服务器的回复</p></li><li><p>Server监听到连接请求报文后，如同意建立连接，则向Client发送确认。TCP报文首部中的SYN 和 ACK都置1 ，ack = x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到（ack=1其实是ack=0+1,也就是期望客户端的第1个包），seq = y 表示Server 自己的初始序号（seq=0就代表这是服务器这边发出的第0号包）。这时服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待client的确认。</p></li><li><p>Client收到确认后还需再次发送确认，同时携带要发送给Server的数据。ACK 置1 表示确认号ack= y + 1 有效（代表期望收到服务器的第1个包），Client自己的序号seq= x + 1（表示这就是我的第1个包，相对于第0个包来说的），一旦收到Client的确认之后，这个TCP连接就进入Established状态，就可以发起http请求了。</p></li></ol><h6 id="问题1：TCP-为什么需要3次握手？"><a href="#问题1：TCP-为什么需要3次握手？" class="headerlink" title="问题1：TCP 为什么需要3次握手？"></a>问题1：TCP 为什么需要3次握手？</h6><p>2个计算机通信是靠协议（目前流行的TCP/IP协议）来实现,如果2个计算机使用的协议不一样，那是不能进行通信的，所以这个3次握手就相当于试探一下对方是否遵循TCP/IP协议，协商完成后就可以进行通信了，当然这样理解不是那么准确。</p><h6 id="问题2：为什么HTTP协议要基于TCP来实现？"><a href="#问题2：为什么HTTP协议要基于TCP来实现？" class="headerlink" title="问题2：为什么HTTP协议要基于TCP来实现？"></a>问题2：为什么HTTP协议要基于TCP来实现？</h6><p>目前在Internet中所有的传输都是通过TCP/IP进行的，HTTP协议作为TCP/IP模型中应用层的协议也不例外，TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。</p><h5 id="2-2-常见TCP连接限制"><a href="#2-2-常见TCP连接限制" class="headerlink" title="2.2 常见TCP连接限制"></a>2.2 常见TCP连接限制</h5><ul><li>2.2.1 修改用户进程可打开文件数限制</li></ul><p>在Linux平台上，无论编写客户端程序还是服务端程序，在进行高并发TCP连接处理时，最高的并发数量都要受到系统对用户单一进程同时可打开文件数量的限制(这是因为系统为每个TCP连接都要创建一个socket句柄，每个socket句柄同时也是一个文件句柄)。可使用ulimit命令查看系统允许当前用户进程打开的文件数限制，windows上是256，linux是1024，这个博客的服务器是65535</p><ul><li>2.2.2 修改网络内核对TCP连接的有关限制</li></ul><p>在Linux上编写支持高并发TCP连接的客户端通讯处理程序时，有时会发现尽管已经解除了系统对用户同时打开文件数的限制，但仍会出现并发TCP连接数增加到一定数量时，再也无法成功建立新的TCP连接的现象。出现这种现在的原因有多种。<br>第一种原因可能是因为Linux网络内核对本地端口号范围有限制。此时，进一步分析为什么无法建立TCP连接，会发现问题出在connect()调用返回失败，查看系统错误提示消息是“Can’t assign requestedaddress”。同时，如果在此时用tcpdump工具监视网络，会发现根本没有TCP连接时客户端发SYN包的网络流量。这些情况说明问题在于本地Linux系统内核中有限制。</p><p>其实，问题的根本原因在于Linux内核的TCP/IP协议实现模块对系统中所有的客户端TCP连接对应的本地端口号的范围进行了限制(例如，内核限制本地端口号的范围为1024~32768之间)。当系统中某一时刻同时存在太多的TCP客户端连接时，由于每个TCP客户端连接都要占用一个唯一的本地端口号(此端口号在系统的本地端口号范围限制中)，如果现有的TCP客户端连接已将所有的本地端口号占满，则此时就无法为新的TCP客户端连接分配一个本地端口号了，因此系统会在这种情况下在connect()调用中返回失败，并将错误提示消息设为“Can’t assignrequested address”。</p><h5 id="2-3-TCP四次挥手"><a href="#2-3-TCP四次挥手" class="headerlink" title="2.3 TCP四次挥手"></a>2.3 TCP四次挥手</h5><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。</p><ul><li>第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</li><li>第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</li><li>第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</li><li>第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</li></ul><h6 id="问题1：为什么要四次分手？"><a href="#问题1：为什么要四次分手？" class="headerlink" title="问题1：为什么要四次分手？"></a>问题1：为什么要四次分手？</h6><blockquote><p> TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p></blockquote><h4 id="3-发起HTTP请求"><a href="#3-发起HTTP请求" class="headerlink" title="3. 发起HTTP请求"></a>3. 发起HTTP请求</h4><h5 id="3-1-HTTP协议"><a href="#3-1-HTTP协议" class="headerlink" title="3.1 HTTP协议"></a>3.1 HTTP协议</h5><p>HTTP是一个客户端和服务器端请求和应答的标准（TCP）。客户端是终端用户，服务器端是网站。通过使用Web浏览器、网络爬虫或者其它的工具，客户端发起一个到服务器上指定端口（默认端口为80）的HTTP请求。</p><blockquote><p>通俗来讲，他就是计算机通过网络进行通信的规则，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据。目前任何终端（手机，笔记本电脑。。）之间进行任何一种通信都必须按照Http协议进行，否则无法连接。</p></blockquote><ul><li>3.1.1 四个基于</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请求与响应：客户端发送请求，服务器端响应数据</span><br><span class="line">无状态的：协议对于事务处理没有记忆能力，客户端第一次与服务器建立连接发送请求时需要进行一系列的安全认证匹配等，因此增加页面等待时间，当客户端向服务器端发送请求，服务器端响应完毕后，两者断开连接，也不保存连接状态，一刀两断！恩断义绝！从此路人！下一次客户端向同样的服务器发送请求时，由于他们之前已经遗忘了彼此，所以需要重新建立连接。</span><br><span class="line">应用层： Http是属于应用层的协议，配合TCP/IP使用。</span><br><span class="line">TCP/IP： Http使用TCP作为它的支撑运输协议。HTTP客户机发起一个与服务器的TCP连接，一旦连接建立，浏览器（客户机）和服务器进程就可以通过套接字接口访问TCP。</span><br></pre></td></tr></table></figure><h5 id="3-2-HTTP请求报文"><a href="#3-2-HTTP请求报文" class="headerlink" title="3.2 HTTP请求报文"></a>3.2 HTTP请求报文</h5><p>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成.</p><ul><li>3.2.1 请求行</li></ul><p>请求行分为三个部分：请求方法、请求地址和协议版本</p><h6 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h6><p>HTTP/1.1 定义的请求方法有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。</p><p>最常的两种GET和POST，如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT。</p><pre><code>请求地址URL:统一资源定位符，是一种自愿位置的抽象唯一识别方法。组成：&lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt; 注：端口和路径有时可以省略（HTTP默认端口号是80）https://localhost:8080/index.html?key1=value1&amp;keys2=value2</code></pre><h6 id="协议版本"><a href="#协议版本" class="headerlink" title="协议版本"></a>协议版本</h6><p>协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1</p><ul><li>3.2.2 请求头部</li></ul><p>请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。</p><p>请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。</p><ul><li>3.2.3 请求数据</li></ul><p>可选部分，比如GET请求就没有请求数据。</p><p>下面是一个POST方法的请求报文：</p><pre><code>POST 　/index.php　HTTP/1.1 　　 请求行Host: localhostUser-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2　　请求头Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8Accept-Language: zh-cn,zh;q=0.5Accept-Encoding: gzip, deflateConnection: keep-aliveReferer: http://localhost/Content-Length：25Content-Type：application/x-www-form-urlencoded　　空行username=aa&amp;password=1234　　请求数据</code></pre><h4 id="4-服务器响应HTTP请求，浏览器得到html代码"><a href="#4-服务器响应HTTP请求，浏览器得到html代码" class="headerlink" title="4. 服务器响应HTTP请求，浏览器得到html代码"></a>4. 服务器响应HTTP请求，浏览器得到html代码</h4><h5 id="4-1-负载均衡"><a href="#4-1-负载均衡" class="headerlink" title="4.1 负载均衡"></a>4.1 负载均衡</h5><p>接收到HTTP请求之后，就轮到负载均衡登场了，它位于网站的最前端，把短时间内较高的访问量分摊到不同机器上处理。负载均衡方案有软件、硬件两种</p><ul><li>4.1.1 负载均衡硬件方案</li></ul><p>F5 BIG-IP是著名的硬件方案，但这里不作讨论</p><ul><li>4.1.2 负载均衡软件方案</li></ul><blockquote><p>有LVS HAProxy Nginx等，留作以后补充</p></blockquote><p>在典型的Rails应用部署方案中，Nginx的作用有两个</p><pre><code>处理静态文件请求转发请求给后端的Rails应用这是一个简单的Nginx配置文件</code></pre><p>后端的Rails服务器通过unix socket与Nginx通信，Nginx伺服public文件夹里的静态文件给用户</p><h5 id="4-2-Rails-应用服务器"><a href="#4-2-Rails-应用服务器" class="headerlink" title="4.2 Rails(应用服务器)"></a>4.2 Rails(应用服务器)</h5><h5 id="4-3-数据库（数据库服务器）"><a href="#4-3-数据库（数据库服务器）" class="headerlink" title="4.3 数据库（数据库服务器）"></a>4.3 数据库（数据库服务器）</h5><h5 id="4-4-Redis、Memercache（缓存服务器）"><a href="#4-4-Redis、Memercache（缓存服务器）" class="headerlink" title="4.4 Redis、Memercache（缓存服务器）"></a>4.4 Redis、Memercache（缓存服务器）</h5><h5 id="4-5-消息队列"><a href="#4-5-消息队列" class="headerlink" title="4.5 消息队列"></a>4.5 消息队列</h5><h5 id="4-6-搜索"><a href="#4-6-搜索" class="headerlink" title="4.6 搜索"></a>4.6 搜索</h5><h5 id="4-7-HTTP响应报文"><a href="#4-7-HTTP响应报文" class="headerlink" title="4.7 HTTP响应报文"></a>4.7 HTTP响应报文</h5><p>HTTP响应报文主要由状态行、响应头部、空行以及响应数据组成。</p><ul><li>4.7.1 状态行</li></ul><blockquote><p>由3部分组成，分别为：协议版本，状态码，状态码描述。</p></blockquote><p>其中协议版本与请求报文一致，状态码描述是对状态码的简单描述，所以这里就只介绍状态码。</p><ul><li>4.7.2 状态码</li></ul><p>状态代码为3位数字。</p><pre><code>1xx：指示信息–表示请求已接收，继续处理。2xx：成功–表示请求已被成功接收、理解、接受。3xx：重定向–要完成请求必须进行更进一步的操作。4xx：客户端错误–请求有语法错误或请求无法实现。5xx：服务器端错误–服务器未能实现合法的请求。</code></pre><ul><li>4.7.3 响应头部</li></ul><p>与请求头部类似，为响应报文添加了一些附加信息</p><ul><li>4.7.4 响应数据</li></ul><p>用于存放需要返回给客户端的数据信息。</p><p>下面是一个响应报文的实例：</p><pre><code>HTTP/1.1 200 OK　　状态行Date: Sun, 17 Mar 2013 08:12:54 GMT　　响应头部Server: Apache/2.2.8 (Win32) PHP/5.2.5X-Powered-By: PHP/5.2.5Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/Expires: Thu, 19 Nov 1981 08:52:00 GMTCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0Pragma: no-cacheContent-Length: 4393Keep-Alive: timeout=5, max=100Connection: Keep-AliveContent-Type: text/html; charset=utf-8空行响应数据</code></pre>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> HTTP </tag>
            
            <tag> 请求流程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器配置——内网CentOS7/PHP/Apache/Nginx/SVN/Git/GitLab服务器实战</title>
      <link href="/2018/04/18/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E5%86%85%E7%BD%91CentOS7:PHP:Apache:Nginx:SVN:Git:GitLab%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E6%88%98/"/>
      <url>/2018/04/18/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E5%86%85%E7%BD%91CentOS7:PHP:Apache:Nginx:SVN:Git:GitLab%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E6%88%98/</url>
      <content type="html"><![CDATA[<p>完整实战，验证通过，可用…..</p><p>此文章看着好长，或者逼格好高的样子。其实很简单，只是因为这些是后端开发或者公司负责项目和内部服务器搭建人员必会的！</p><ul><li>适合人群：<ul><li>PHP后端开发</li><li>小团队或部门组负责人</li><li>服务器或相关运营负责人</li><li>想要学习PHP或者转型后端开发</li><li>业务学习，纯属搞着玩</li></ul></li></ul><a id="more"></a><p>这里就不对每一个模块和内容做解释了，只用实战记录，方便后期查阅也希望能得到更多前辈的点评和指点！</p><p>首先分享一份教程，这是慕课网实战阿里云主机(ECS)与CentOS7教程！</p><ul><li><a href="https://pan.baidu.com/s/1u3BPzu2dGXlXYhWpofjsbA" target="_blank" rel="noopener">阿里云主机(ECS)与CentOS7实战</a></li><li>提取码：389j</li></ul><blockquote><p>注：本文部分外部操作基于Mac系统</p></blockquote><h2 id="1-U盘制作Centos系统盘"><a href="#1-U盘制作Centos系统盘" class="headerlink" title="1.U盘制作Centos系统盘"></a>1.U盘制作Centos系统盘</h2><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><ul><li>U盘或者硬盘一个，需要大于8G</li><li>iso系统:(本文基础1708)<ul><li><a href="https://pan.baidu.com/s/1sC8JSuCzPk6BGbfof7vouQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1sC8JSuCzPk6BGbfof7vouQ</a></li><li>提取码: 4df8</li></ul></li><li>HFSExplorer：方面Windows系统访问Mac盘(U/硬盘)</li><li>UltraISO：光盘映像文件制作</li></ul><p>具体制作安装U盘的步骤由于过于简单，这里就过多说明，不知道的请出门左转找度娘。</p><h2 id="2-Centos安装"><a href="#2-Centos安装" class="headerlink" title="2.Centos安装"></a>2.Centos安装</h2><p>只要U盘正确制作，关于网上教程非常多，也是非常简单的！</p><ul><li>这里推荐被参考的比较多的教程：<ul><li><a href="https://www.osyunwei.com/archives/7829.html" target="_blank" rel="noopener">https://www.osyunwei.com/archives/7829.html</a></li></ul></li></ul><p>有些地方需要注意的：</p><ul><li><ol><li>可以的话，最好在安装信息摘要的时候连上网，方便一些相关的更新和下载。</li></ol></li><li><ol start="2"><li>出入学习推荐使用桌面版，当然如果比较喜欢专业或者非入门级的那就使用最小安装，最小安装是基本上很多东西都没有，连网络和相关需求都不支持。</li></ol></li><li><ol start="3"><li>关于分区可以使用自动分区，或者根据教程做相应的分配，建议不要自己随意配，不然后面难免出现问题。</li></ol></li></ul><p>期间遇到了一个问题</p><blockquote><p>/dev/root does not exist, could not boot</p></blockquote><p>网上都说直接修改</p><blockquote><p>vmlinuz initrd=initrd.imginst.stage2=hd:LABEL=CentOS\x207\x20x86_64 rd.live.check quiet </p></blockquote><ul><li>改为：</li></ul><blockquote><p>vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sda4 quite</p></blockquote><p>试了好几次都不行,最后发现是空格的问题，因为我格式化U盘之后直接命名为了Centos 7，导致产生了空格，而无法读取到U盘</p><h5 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h5><ol><li>到windows里面修改U盘名称（例如 ‘Centos7’）</li><li>进入U盘目录 进入 EFI/boot<ul><li>修改grub.cfg文件，CENTOS\x207 全部修改为U盘名称（CENTOS7）</li></ul></li><li>重启安装</li><li>正常安装并显示交互界面</li></ol><blockquote><p>总结：名称强烈不建议出现中文空格,容易出bug</p></blockquote><p>安装完成之后，进入Centos命令行查看IP地址，然后在ssh连接工具上尝试连接，并且进行一些操作</p><ul><li>CentOS7查看ip地址的方式为：<ul><li>ip addr</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/centos/config/install0001.png" alt="曹理鹏(iCocos)-梦工厂"> </p><p>这里有一点需要知道的是，阿里云或腾讯云或者其他说明鬼云，都是提供的最新的相关Linux系统，所以一般系统安装是不需要我们来做的，除非有一些特殊的情况。</p><blockquote><p>Ip地址也是直接对外提供，不需要我们去查的，所以就XXX云来说，我们做的事情就是从这里往后操作的流程。甚至有些会给你一些更完整或者更多的功能支持。</p></blockquote><p>如果有需要需要额外配置其他相关功能和服务，推荐看这里：</p><ul><li><a href="https://blog.csdn.net/myf12/article/details/78086189" target="_blank" rel="noopener">centos7 装机后的基本配置</a></li></ul><h2 id="3-Centos系统配置PHP服务器"><a href="#3-Centos系统配置PHP服务器" class="headerlink" title="3.Centos系统配置PHP服务器"></a>3.Centos系统配置PHP服务器</h2><blockquote><p>注意：以下安装，我都是用的root权限。</p></blockquote><h4 id="一、关闭防火墙"><a href="#一、关闭防火墙" class="headerlink" title="一、关闭防火墙"></a>一、关闭防火墙</h4><p>查了资料，说法是，CentOS7用的是Firewall-cmd，CentOS7之前用的是iptables防火墙；要想让外网能访问到apache主目录，就需要做以下的操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">停止firewall </span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line">禁止firewall开机启动 </span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br><span class="line">/**</span><br><span class="line">Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.                                             </span><br><span class="line">Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service. </span><br><span class="line">*/</span><br><span class="line">查看默认防火墙的状态 </span><br><span class="line">firewall-cmd --state</span><br><span class="line">/**</span><br><span class="line">not running </span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>或者可以这么做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-service=http</span><br><span class="line">firewall-cmd --permanent --zone=public --add-service=https</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h4 id="二、安装Apache"><a href="#二、安装Apache" class="headerlink" title="二、安装Apache"></a>二、安装Apache</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">安装Apache</span><br><span class="line">yum install httpd -y</span><br><span class="line">--- 一下httpd可以直接使用httpd.service --- </span><br><span class="line">启动Apache</span><br><span class="line">systemctl start httpd</span><br><span class="line">停止Apache</span><br><span class="line">systemctl stop httpd</span><br><span class="line">重启Apache</span><br><span class="line">systemctl restart httpd</span><br><span class="line">Apache开机自启 </span><br><span class="line">systemctl <span class="built_in">enable</span> httpd</span><br><span class="line">/**</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/httpd.service to /usr/lib/systemd</span><br><span class="line">/system/httpd.service.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>在本机浏览器中前面ip addr查到的ip地址，如果看到apache默认的页面–有Testing 123…字样，便是成功安装了apache服务</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/centos/config/testip0001.png" alt="曹理鹏(iCocos)-梦工厂"> </p><h4 id="三、安装php"><a href="#三、安装php" class="headerlink" title="三、安装php"></a>三、安装php</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">安装php</span><br><span class="line">yum install php php-devel或者yum -y install php</span><br><span class="line">安装Php扩展</span><br><span class="line">yum install php-mysql php-gd php-imap php-ldap php-odbc php-pear php-xml php-xmlrpc</span><br><span class="line">重启Apache: </span><br><span class="line">systemctl restart httpd或者systemctl restart httpd.service</span><br></pre></td></tr></table></figure><p>然后，你可以写一个php文件在浏览器中运行一下了;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /var/www/html/info.php</span><br><span class="line">&lt;?php phpinfo(); ?&gt;</span><br></pre></td></tr></table></figure><p>然后，在自己电脑浏览器输入 <a href="http://172.20.10.2/info.php" target="_blank" rel="noopener">http://172.20.10.2/info.php</a><br>运行，会出现php的一些信息,如果出现如下界面，说明已经成功了</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/centos/config/infophp.png" alt="曹理鹏(iCocos)-梦工厂"> </p><h4 id="四、安装mysql"><a href="#四、安装mysql" class="headerlink" title="四、安装mysql"></a>四、安装mysql</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">安装MySQL</span><br><span class="line">yum install mariadb mariadb-server -y</span><br><span class="line">启动MariaDB </span><br><span class="line">systemctl start mariadb  </span><br><span class="line">停止MariaDB </span><br><span class="line">systemctl stop mariadb  </span><br><span class="line">重启MariaDB </span><br><span class="line">systemctl restart mariadb</span><br><span class="line">设置开机启动 </span><br><span class="line">systemctl <span class="built_in">enable</span> mariadb</span><br><span class="line">/**</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/mariadb.service to /usr/lib/syste</span><br><span class="line">md/system/mariadb.service.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>设置root帐户的密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql_secure_installation</span><br></pre></td></tr></table></figure><p>然后会出现一串东西，可以仔细读一下，如果你懒得读，就在提示出来的时候，按Enter就好了，让你设置密码的时候，你就输入你想要的密码就行，然后继续在让你选择y/n是，Enter就好了；当一切结束的时候，你可以输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root</span><br></pre></td></tr></table></figure></p><p>验证一下,输入密码，正常连接并可进行mysql操作</p><p>有时候由于安装命令的问题，会出现下面的报错，建议重现使用上面的操作一遍</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR 2002 (HY000): Can<span class="string">'t connect to local MySQL server through socket '</span>/var/run/mysqld/mysqld.sock</span><br><span class="line"><span class="string">' (2)</span></span><br></pre></td></tr></table></figure><h4 id="五、配置Mysql，设置MySQL密码"><a href="#五、配置Mysql，设置MySQL密码" class="headerlink" title="五、配置Mysql，设置MySQL密码"></a>五、配置Mysql，设置MySQL密码</h4><h6 id="1-连接MySQL"><a href="#1-连接MySQL" class="headerlink" title="1.连接MySQL"></a>1.连接MySQL</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root</span><br></pre></td></tr></table></figure><h6 id="2-设置密码"><a href="#2-设置密码" class="headerlink" title="2.设置密码"></a>2.设置密码</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> password <span class="keyword">for</span> <span class="string">'root'</span>@<span class="string">'localhost'</span> = password(<span class="string">'root'</span>);</span><br><span class="line">mysql&gt; <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h6 id="3-远程授权连接mysql"><a href="#3-远程授权连接mysql" class="headerlink" title="3.远程授权连接mysql"></a>3.远程授权连接mysql</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO <span class="string">'root'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'root'</span> WITH GRANT OPTION;</span><br><span class="line">配置生效：FLUSH   PRIVILEGES;</span><br></pre></td></tr></table></figure><h6 id="再次连接线使用："><a href="#再次连接线使用：" class="headerlink" title="再次连接线使用："></a>再次连接线使用：</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><blockquote><p>然后输入上面的root密码</p></blockquote><h4 id="六、将PHP和MySQL关联起来"><a href="#六、将PHP和MySQL关联起来" class="headerlink" title="六、将PHP和MySQL关联起来"></a>六、将PHP和MySQL关联起来</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum search php</span><br></pre></td></tr></table></figure><p>选择你需要的安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install php-mysql</span><br></pre></td></tr></table></figure><h4 id="七、安装常用的PHP模块"><a href="#七、安装常用的PHP模块" class="headerlink" title="七、安装常用的PHP模块"></a>七、安装常用的PHP模块</h4><p>例如，GD库，curl，mbstring,…</p><h6 id="1-安装："><a href="#1-安装：" class="headerlink" title="1.安装："></a>1.安装：</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install php-gd php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-snmp php-soap curl curl-devel</span><br></pre></td></tr></table></figure><h6 id="2-重启apache服务"><a href="#2-重启apache服务" class="headerlink" title="2.重启apache服务"></a>2.重启apache服务</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart httpd.service</span><br></pre></td></tr></table></figure><p>然后，再次在浏览器中运行info.php，你会看到安装的模块的信息；</p><p>至此，LAMP环境就搭建好了……</p><h2 id="4-nginx安装与配置"><a href="#4-nginx安装与配置" class="headerlink" title="4. nginx安装与配置"></a>4. nginx安装与配置</h2><ul><li><a href="https://www.jianshu.com/p/d55aa0bdb280" target="_blank" rel="noopener">Nginx从安装到入门，基础篇</a></li></ul><p>Nginx有三种安装方式</p><ol><li>安装包编译安装(相对麻烦)</li><li>yum源安装</li><li>使用docker安装</li></ol><p>需确认80端口是否开放，如果是阿里云，得在控制台那边设置端口组开放</p><pre><code>#确保防火墙是否开放80端口 如果没有firewall-cmd --permanent --zone=public --add-port=80/tcp #重新加载firewall-cmd --reload#查看列表firewall-cmd --list-all</code></pre><p>这里推荐直接使用yum源安装，因为比较快捷，方便</p><pre><code>#yum安装nginxsudo yum install -y nginx#启动nginxsudo systemctl start nginx.service#设置开机自启动sudo systemctl enable nginx.service#yum安装的nginx配置文件默认存放在 /etc/nginx/nginx.conf 查看vi /etc/nginx/nginx.conf #卸载yum remove nginx</code></pre><p>如果可以你也可以直接使用安装包编译安装</p><pre><code># 下载源码$ wget http://nginx.org/download/nginx-1.13.0.tar.gz# 解压源码$ tar xvf nginx-1.13.0.tar.gz# 进入源码目录$ cd nginx-1.13.0# 配置、编译、安装$ ./configure$ make$ make install</code></pre><p>有时候回遇到，输入网址之后不是官方默认界面，可能是因为</p><blockquote><p>有epel源的时候并且用yum install nginx 安装就会显示Welcome to nginx on Fedora!，因为epel源就是Fedora维护的</p></blockquote><h2 id="5-Centos配置Git服务器"><a href="#5-Centos配置Git服务器" class="headerlink" title="5.Centos配置Git服务器"></a>5.Centos配置Git服务器</h2><h4 id="1、安装Git"><a href="#1、安装Git" class="headerlink" title="1、安装Git"></a>1、安装Git</h4><p>首先需要安装Git，可以使用yum源在线安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y git</span><br></pre></td></tr></table></figure><h4 id="2、用户操作"><a href="#2、用户操作" class="headerlink" title="2、用户操作"></a>2、用户操作</h4><p>创建一个git用户，用来运行git服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adduser git</span><br><span class="line">passwd git</span><br><span class="line">/*输入git用户密码*/</span><br></pre></td></tr></table></figure><h4 id="3、git初始化"><a href="#3、git初始化" class="headerlink" title="3、git初始化"></a>3、git初始化</h4><p>初始化git仓库：这里我们选择/git/icocos.git来作为我们的git仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /git -p</span><br><span class="line"><span class="built_in">cd</span> /git</span><br><span class="line">git init --bare icocos.git  <span class="comment">#初始化仓库</span></span><br></pre></td></tr></table></figure><p>执行以上命令，会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。</p><h4 id="4、然后，把owner改为git"><a href="#4、然后，把owner改为git" class="headerlink" title="4、然后，把owner改为git"></a>4、然后，把owner改为git</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown git:git icocos.git  -R</span><br></pre></td></tr></table></figure><h4 id="5、clone远程仓库"><a href="#5、clone远程仓库" class="headerlink" title="5、clone远程仓库"></a>5、clone远程仓库</h4><p>在这里，Git服务器就已经搭得差不多了。下面我们在客户端clone一下远程仓库。</p><blockquote><p>Mysql可以直接使用命令行，或者使用Tower</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@172.20.10.2:/git/icocos.git</span><br><span class="line">Cloning into <span class="string">'icocos'</span>...</span><br><span class="line">git@172.20.10.2<span class="string">'s password: </span></span><br><span class="line"><span class="string">remote: Counting objects: 6, done.</span></span><br><span class="line"><span class="string">remote: Compressing objects: 100% (6/6), done.</span></span><br><span class="line"><span class="string">remote: Total 6 (delta 0), reused 0 (delta 0)</span></span><br><span class="line"><span class="string">Receiving objects: 100% (6/6), 2.63 MiB | 1.63 MiB/s, done.</span></span><br></pre></td></tr></table></figure><p>输入git账户对应的密码<br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/centos/config/gitconfig.png" alt="曹理鹏(iCocos)-梦工厂"> </p><p>然后就可以根据公司或者具体项目做相应拓展和配置</p><h4 id="Git实战记录总结"><a href="#Git实战记录总结" class="headerlink" title="Git实战记录总结"></a>Git实战记录总结</h4><h6 id="配置与初始化实战流程"><a href="#配置与初始化实战流程" class="headerlink" title="配置与初始化实战流程"></a>配置与初始化实战流程</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@centos /]<span class="comment"># yum install -y git                                                                                                    </span></span><br><span class="line">已加载插件：fastestmirror, langpacks                                                                                                   </span><br><span class="line">Loading mirror speeds from cached hostfile                                                                                             </span><br><span class="line"> * base: mirror.jdcloud.com                                                                                                            </span><br><span class="line"> * extras: mirrors.163.com                                                                                                             </span><br><span class="line"> * updates: mirrors.163.com                                                                                                            </span><br><span class="line">软件包 git-1.8.3.1-20.el7.x86_64 已安装并且是最新版本                                                                                  </span><br><span class="line">无须任何处理                                                                                                                           </span><br><span class="line">[root@centos /]<span class="comment"># adduser git                                                                                                                                                                                                                        </span></span><br><span class="line">[root@centos /]<span class="comment"># passwd git                                                                                                            </span></span><br><span class="line">更改用户 git 的密码 。                                                                                                                 </span><br><span class="line">新的 密码：                                                                                                                            </span><br><span class="line">重新输入新的 密码：                                                                                                                    </span><br><span class="line">passwd：所有的身份验证令牌已经成功更新。                                                                                                </span><br><span class="line">[root@centos /]<span class="comment"># mkdir git                                                                                                    </span></span><br><span class="line">[root@centos /]<span class="comment"># cd git                                                                                                                </span></span><br><span class="line">[root@centos git]<span class="comment"># ls                                                                                                                                                                                                                     </span></span><br><span class="line">[root@centos git]<span class="comment"># mkdir SwiftProject                                                                                                  </span></span><br><span class="line">[root@centos git]<span class="comment"># cd SwiftProject/                                                                                                    </span></span><br><span class="line">[root@centos SwiftProject]<span class="comment"># ls                                                                                                         </span></span><br><span class="line">[root@centos SwiftProject]<span class="comment"># git init --bare SwiftProject.git  #初始化仓库                                                              </span></span><br><span class="line">初始化空的 Git 版本库于 /git/SwiftProject/SwiftProject.git/                                                                            </span><br><span class="line">[root@centos SwiftProject]<span class="comment"># chown git:git SwiftProject.git  -R</span></span><br></pre></td></tr></table></figure><h6 id="内外网访问和Clone"><a href="#内外网访问和Clone" class="headerlink" title="内外网访问和Clone"></a>内外网访问和Clone</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git@172.20.10.2:/git/SwiftProject/SwiftProject.git</span><br></pre></td></tr></table></figure><blockquote><p>然后就是根据需求创建项目提交或拉去代码</p></blockquote><h2 id="6-Centos配置SVN服务器"><a href="#6-Centos配置SVN服务器" class="headerlink" title="6.Centos配置SVN服务器"></a>6.Centos配置SVN服务器</h2><h4 id="1、subversion安装"><a href="#1、subversion安装" class="headerlink" title="1、subversion安装"></a>1、subversion安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos /]<span class="comment"># yum install subversion</span></span><br></pre></td></tr></table></figure><h4 id="2、新建一个目录用于存储SVN目录"><a href="#2、新建一个目录用于存储SVN目录" class="headerlink" title="2、新建一个目录用于存储SVN目录"></a>2、新建一个目录用于存储SVN目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos /]mkdir /svn</span><br></pre></td></tr></table></figure><h4 id="3、SVN方式创建SVN项目目录"><a href="#3、SVN方式创建SVN项目目录" class="headerlink" title="3、SVN方式创建SVN项目目录"></a>3、SVN方式创建SVN项目目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos svn]<span class="comment"># svnadmin create /svn/SwiftProject/</span></span><br></pre></td></tr></table></figure><h4 id="4、SVN项目目录查看内容"><a href="#4、SVN项目目录查看内容" class="headerlink" title="4、SVN项目目录查看内容"></a>4、SVN项目目录查看内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@centos svn]<span class="comment"># ll SwiftProject</span></span><br><span class="line">总用量 8</span><br><span class="line">drwxr-xr-x. 2 root root  54 1月  12 01:09 conf</span><br><span class="line">drwxr-sr-x. 6 root root 233 1月  12 01:09 db</span><br><span class="line">-r--r--r--. 1 root root   2 1月  12 01:09 format</span><br><span class="line">drwxr-xr-x. 2 root root 231 1月  12 01:09 hooks</span><br><span class="line">drwxr-xr-x. 2 root root  41 1月  12 01:09 locks</span><br><span class="line">-rw-r--r--. 1 root root 229 1月  12 01:09 README.txt</span><br></pre></td></tr></table></figure><ul><li>以下关于目录的说明：<ul><li>hooks目录：放置hook脚步文件的目录</li><li>locks目录：用来放置subversion的db锁文件和db_logs锁文件的目录，用来追踪存取文件库的客户端</li><li>format目录：是一个文本文件，里边只放了一个整数，表示当前文件库配置的版本号</li><li>conf目录：是这个仓库配置文件（仓库用户访问账户，权限）</li></ul></li></ul><h4 id="5、SVN配置文件"><a href="#5、SVN配置文件" class="headerlink" title="5、SVN配置文件"></a>5、SVN配置文件</h4><p>cd conf/进入conf目录（该svn版本库配置文件），一共有三个文件</p><ul><li>authz文件是权限控制文件</li><li>passwd是帐号密码文件</li><li>svnserve.conf SVN服务配置文件</li></ul><h6 id="a、编辑用户文件passwd，新增两个用户：svn。"><a href="#a、编辑用户文件passwd，新增两个用户：svn。" class="headerlink" title="a、编辑用户文件passwd，新增两个用户：svn。"></a>a、编辑用户文件passwd，新增两个用户：svn。</h6><blockquote><p>vim conf/passwd</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[users]</span><br><span class="line">svn = svn</span><br></pre></td></tr></table></figure><h6 id="b、编辑权限文件authz，用户admin设置可读写权限，guest设置只读权限。"><a href="#b、编辑权限文件authz，用户admin设置可读写权限，guest设置只读权限。" class="headerlink" title="b、编辑权限文件authz，用户admin设置可读写权限，guest设置只读权限。"></a>b、编辑权限文件authz，用户admin设置可读写权限，guest设置只读权限。</h6><blockquote><p>vim conf/authz</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[/]</span><br><span class="line">svn = rw</span><br></pre></td></tr></table></figure><h6 id="c-进入所建立仓库的配置目录-svn-project-conf修改文件svnserve-conf"><a href="#c-进入所建立仓库的配置目录-svn-project-conf修改文件svnserve-conf" class="headerlink" title="c,进入所建立仓库的配置目录/svn/project/conf修改文件svnserve.conf"></a>c,进入所建立仓库的配置目录/svn/project/conf修改文件svnserve.conf</h6><blockquote><p>vim conf/svnserve.conf</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">anon-access = none     //匿名访问权限</span><br><span class="line">auth-access = write    //认证用户权限</span><br><span class="line">password-db = passwd   //密码配置文件路径，默认为同目录的passwd文件</span><br><span class="line">realm = My First Repository //认证标记而已</span><br></pre></td></tr></table></figure><h4 id="6、启动SVN服务器"><a href="#6、启动SVN服务器" class="headerlink" title="6、启动SVN服务器"></a>6、启动SVN服务器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svnserve -d -r /svn --listen-host 172.20.10.2</span><br></pre></td></tr></table></figure><p>-d表示在后台运行，-r指定了服务器的根目录，这样在SVN客户端就可以用svn://172.20.10.2/SwiftProject来访问SVN服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">svn co svn://172.20.10.2/SwiftProject</span><br><span class="line">Checked out revision 0.</span><br><span class="line">ls</span><br><span class="line">SwiftProject</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/centos/config/svnconfig.png" alt="曹理鹏(iCocos)-梦工厂"> </p><blockquote><p>注意</p><blockquote><p>使用以下命令可以查看正在运行的SVN进程<br>ps -ef | grep svn<br>使用命令 killall svnserve 来停止SVN服务器。</p></blockquote></blockquote><h4 id="SVN实战记录总结"><a href="#SVN实战记录总结" class="headerlink" title="SVN实战记录总结"></a>SVN实战记录总结</h4><h6 id="配置与初始化实战流程-1"><a href="#配置与初始化实战流程-1" class="headerlink" title="配置与初始化实战流程"></a>配置与初始化实战流程</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@centos /]<span class="comment"># yum install subversion                                                                                                </span></span><br><span class="line">已加载插件：fastestmirror, langpacks                                                                                                   </span><br><span class="line">Loading mirror speeds from cached hostfile                                                                                             </span><br><span class="line"> * base: mirror.jdcloud.com                                                                                                            </span><br><span class="line"> * extras: mirrors.163.com                                                                                                             </span><br><span class="line"> * updates: mirrors.163.com                                                                                                            </span><br><span class="line">软件包 subversion-1.7.14-14.el7.x86_64 已安装并且是最新版本                                                                            </span><br><span class="line">无须任何处理                                                                                                                           </span><br><span class="line">[root@centos /]<span class="comment"># svnadmin create /svn/project</span></span><br><span class="line">[root@centos /]<span class="comment"># cd /svn/SwiftProject      </span></span><br><span class="line">[root@centos SwiftProject]<span class="comment"># pwd                                                                                                        </span></span><br><span class="line">/svn/SwiftProject                                                                                                                      </span><br><span class="line">[root@centos SwiftProject]<span class="comment"># ls                                                                                                         </span></span><br><span class="line">conf  db  format  hooks  locks  README.txt                                                                                             </span><br><span class="line">[root@centos SwiftProject]<span class="comment"># cd conf/                                                                                                   </span></span><br><span class="line">[root@centos conf]<span class="comment"># ls                                                                                                                 </span></span><br><span class="line">authz  passwd  svnserve.conf                                                                                                           </span><br><span class="line">[root@centos conf]<span class="comment"># vi svnserve.conf                                                                                                   </span></span><br><span class="line">[root@centos conf]<span class="comment"># vim authz                                                                                                          </span></span><br><span class="line">[root@centos conf]<span class="comment"># vim passwd                                                                                                    </span></span><br><span class="line">[root@centos conf]<span class="comment"># cd /                                                                                                    </span></span><br><span class="line">[root@centos /]<span class="comment"># svnserve -d -r /svn --listen-host 172.20.10.2</span></span><br></pre></td></tr></table></figure><h6 id="内外网访问和Co"><a href="#内外网访问和Co" class="headerlink" title="内外网访问和Co"></a>内外网访问和Co</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn co svn://172.20.10.2/SwiftProject</span><br></pre></td></tr></table></figure><p>然后就是根据需求创建项目提交或拉去代码</p><h2 id="7-Centos配置GitLab服务器"><a href="#7-Centos配置GitLab服务器" class="headerlink" title="7.Centos配置GitLab服务器"></a>7.Centos配置GitLab服务器</h2><ul><li><ol><li>安装依赖软件</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install policycoreutils openssh-server openssh-clients postfix</span><br></pre></td></tr></table></figure><ul><li>2.设置postfix开机自启，并启动，postfix支持gitlab发信功能</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> postfix &amp;&amp; systemctl start postfix</span><br></pre></td></tr></table></figure><ul><li><p>3.下载gitlab安装包，然后安装</p><ul><li><a href="https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el6" target="_blank" rel="noopener">centos 6系统的下载地址</a></li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7" target="_blank" rel="noopener">centos 7系统的下载地址</a></li></ul></li></ul><p>我的是centos7,所以我在<a href="https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7中找了个gitlab8.0.0版本,建议下载一个比较新的版本,我这里选了一个比较旧的版本仅仅是实验" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7中找了个gitlab8.0.0版本,建议下载一个比较新的版本,我这里选了一个比较旧的版本仅仅是实验</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">下载rpm包并安装:</span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/gitlab-ce-8.0.0-ce.0.el7.x86_64.rpm</span><br><span class="line">rpm -i gitlab-ce-8.0.0-ce.0.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><ul><li>4.修改gitlab配置文件指定服务器ip和自定义端口：</li></ul><blockquote><p>vim  /etc/gitlab/gitlab.rb</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Url on which GitLab will be reachable.                                  </span></span><br><span class="line"><span class="comment">## For more details on configuring external_url see:                       </span></span><br><span class="line"><span class="comment">## https://gitlab.com/gitlab-org/omnibus-gitlab/blob/629def0a7a26e7c2326566</span></span><br><span class="line">f0758d4a27857b52a3/README.md<span class="comment">#configuring-the-external-url-for-gitlab       </span></span><br><span class="line">external_url <span class="string">'http://172.20.10.2:8081'</span></span><br></pre></td></tr></table></figure><p>最后，退出并保存</p><blockquote><p>注: 这里设置的端口不能被占用，默认是8080端口，如果8080已经使用，请自定义其它端口，并在防火墙设置开放相对应得端口</p></blockquote><ul><li>5.重置并启动GitLab</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br><span class="line">gitlab-ctl restart</span><br></pre></td></tr></table></figure><p>提示“ok: run:”表示启动成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ok: run: gitlab-git-http-server: (pid 3922) 1s</span><br><span class="line">ok: run: logrotate: (pid 3929) 0s</span><br><span class="line">ok: run: nginx: (pid 3936) 1s</span><br><span class="line">ok: run: postgresql: (pid 3941) 0s</span><br><span class="line">ok: run: redis: (pid 3950) 0s</span><br><span class="line">ok: run: sidekiq: (pid 3955) 0s</span><br><span class="line">ok: run: unicorn: (pid 3961) 1s</span><br></pre></td></tr></table></figure><ul><li>6.访问 GitLab页面</li></ul><p>如果没有域名，直接输入服务器ip和指定端口进行访问,会出现如下页面并提示：You need to sign in before continuing. </p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/centos/config/gitlabcreate.png" alt="曹理鹏(iCocos)-梦工厂"> </p><h5 id="初始账户-root-密码-5iveL-fe"><a href="#初始账户-root-密码-5iveL-fe" class="headerlink" title="初始账户: root 密码: 5iveL!fe"></a>初始账户: root 密码: 5iveL!fe</h5><p>注意，第一次登录最好修改密码</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/centos/config/gitlabcreate1.png" alt="曹理鹏(iCocos)-梦工厂"> </p><p>修改完成之后，就可以创建项目或者根据具体需求创建分组</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/centos/config/gitlabcreate2.png" alt="曹理鹏(iCocos)-梦工厂"> </p><ul><li>7.设置gitlab发信功能，需要注意一点：</li></ul><blockquote><p>发信系统用的默认的postfix，smtp是默认开启的，两个都启用了，两个都不会工作。</p></blockquote><p>我这里设置关闭smtp，开启postfix</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">关闭smtp方法：vim /etc/gitlab/gitlab.rb</span><br><span class="line">找到<span class="comment">#gitlab_rails['smtp_enable'] = true 改为 gitlab_rails['smtp_enable'] = false</span></span><br></pre></td></tr></table></figure><h5 id="修改后执行gitlab-ctl-reconfigure"><a href="#修改后执行gitlab-ctl-reconfigure" class="headerlink" title="修改后执行gitlab-ctl reconfigure"></a>修改后执行gitlab-ctl reconfigure</h5><p>另一种是关闭postfix，设置开启smtp</p><pre><code>+ 相关教程请参考[官网](https://doc.gitlab.cc/omnibus/settings/smtp.html)</code></pre><h4 id="测试是否可以邮件通知："><a href="#测试是否可以邮件通知：" class="headerlink" title="测试是否可以邮件通知："></a>测试是否可以邮件通知：</h4><p>登录并添加一个用户，我这里使用qq邮箱添加一个用户</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/centos/config/gitlabcreate3.png" alt="曹理鹏(iCocos)-梦工厂"> </p><p>创建成功后，就可以去对应的邮箱查看邮件并设置密码</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/centos/config/gitlabcreate4.png" alt="曹理鹏(iCocos)-梦工厂"> </p><p>登录qq邮箱，可以收到邮件通知（如果收不到，请查看垃圾邮箱或者检查邮件是否被拦截并删除，如果有请添加到白名单并删除用户再重新添加用户就可以收到了，否则请检查邮件日志并做好相关设置）</p><blockquote><p>到此，GitLab就基本配置完毕，如果有需要和可以结合GitLab，Jenkins，Fastlane实现CI和CD，当然这些一般的小公司不太会用到……</p></blockquote><h5 id="错误一：报错502"><a href="#错误一：报错502" class="headerlink" title="错误一：报错502"></a>错误一：报错502</h5><blockquote><p>gitlab报502 Whoops, GitLab is taking too much time to respond</p></blockquote><p>配置启动后，访问gitlab，出现：502 ，Whoops, GitLab is taking too much time to respond. 出现这个问题，一般都是你本机的8080端口已经被其他的应用程序占用。</p><ul><li>方法一：</li></ul><blockquote><p>GitLab在使用的过程中，会开启8080端口，但是如果8080端口被其他的应用程序占用，则GitLab的该项服务不能使用，所以访问GitLab会失败。</p></blockquote><ul><li>方法二：</li></ul><blockquote><p>一般是权限问题，解决方法：chmod -R 755 /var/log/gitlab</p></blockquote><p>如果还不行，请检查你的内存，安装使用GitLab需要至少4GB可用内存(RAM + Swap)! 由于操作系统和其他正在运行的应用也会使用内存, 所以安装GitLab前一定要注意当前服务器至少有4GB的可用内存. 少于4GB内存会出现各种诡异的问题, 而且在使用过程中也经常会出现500错误.</p><h5 id="错误二：gitlab-ctl-reconfigure"><a href="#错误二：gitlab-ctl-reconfigure" class="headerlink" title="错误二：gitlab-ctl reconfigure"></a>错误二：gitlab-ctl reconfigure</h5><p> 报错n itdb: could not obtain information about current user: Permission denied</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error executing action `run` on resource <span class="string">'execute[/opt/gitlab/embedded/bin/initdb -D /var/opt/gitlab/postgresql/data -E UTF8]'</span></span><br></pre></td></tr></table></figure><p>根据报错信息大概锁定用户的权限问题,安装gitlab-ce会自动添加用户四个用户:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gitlab-www:x:497:498::/var/opt/gitlab/nginx:/bin/<span class="literal">false</span></span><br><span class="line">git:x:496:497::/var/opt/gitlab:/bin/sh</span><br><span class="line">gitlab-redis:x:495:496::/var/opt/gitlab/redis:/bin/nologin</span><br><span class="line">gitlab-psql:x:494:495::/var/opt/gitlab/postgresql:/bin/sh</span><br></pre></td></tr></table></figure><p>google和百度都搜索不到解决方法,既然出错提示到权限问题，那么按照这个方向去查就不会有问题，后来查了文件/etc/passwd的权限是600,给予644权限后,成功解决报错问题</p><h6 id="改成8081"><a href="#改成8081" class="headerlink" title="改成8081"></a>改成8081</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gitlab-ctl stop </span></span><br><span class="line"><span class="comment"># vi /etc/gitlab/gitlab.rb   (取消注释并修改端口) unicorn['port'] = 8801 </span></span><br><span class="line"><span class="comment"># gitlab-ctl reconfigure  (重新生成配置) </span></span><br><span class="line"><span class="comment"># gitlab-ctl restart </span></span><br><span class="line"><span class="comment"># lsof -i:8081(check whether unicorn has started properly)</span></span><br></pre></td></tr></table></figure><h2 id="8-Centos配置PHP各种拓展-Composer"><a href="#8-Centos配置PHP各种拓展-Composer" class="headerlink" title="8.Centos配置PHP各种拓展: Composer"></a>8.Centos配置PHP各种拓展: Composer</h2><p>推荐composer官方更多教程与配置：<a href="https://www.phpcomposer.com/" target="_blank" rel="noopener">https://www.phpcomposer.com/</a></p><p>需要使用到curl，如果没有的话需要 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum  -y install curl     <span class="comment">###安装</span></span><br></pre></td></tr></table></figure><h5 id="下载composer-phar"><a href="#下载composer-phar" class="headerlink" title="下载composer.phar"></a>下载composer.phar</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sS https://getcomposer.org/installer | php</span><br></pre></td></tr></table></figure><h5 id="把composer-phar移动到环境下让其变成可执行"><a href="#把composer-phar移动到环境下让其变成可执行" class="headerlink" title="把composer.phar移动到环境下让其变成可执行"></a>把composer.phar移动到环境下让其变成可执行</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv composer.phar /usr/<span class="built_in">local</span>/bin/composer</span><br></pre></td></tr></table></figure><h5 id="测试composer"><a href="#测试composer" class="headerlink" title="测试composer"></a>测试composer</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">composer -V </span><br><span class="line">/** 输出：Composer version 1.0-dev (e64470c987fdd6bff03b85eed823eb4b865a4152) 2015-05-28 14:52:12 */</span><br></pre></td></tr></table></figure><h5 id="实战操作"><a href="#实战操作" class="headerlink" title="实战操作"></a>实战操作</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@centos /]<span class="comment"># curl -sS https://getcomposer.org/installer | php</span></span><br><span class="line">All settings correct <span class="keyword">for</span> using Composer                                    </span><br><span class="line">Downloading...</span><br><span class="line"></span><br><span class="line">Composer (version 1.8.0) successfully installed to: //composer.phar</span><br><span class="line">Use it: php composer.phar</span><br><span class="line"></span><br><span class="line">[root@centos /]<span class="comment"># mv composer.phar /usr/local/bin/composer</span></span><br><span class="line">[root@centos ~]<span class="comment"># composer -V </span></span><br><span class="line">Do not run Composer as root/super user! See https://getcomposer.org/root <span class="keyword">for</span> details</span><br><span class="line">Composer version 1.8.0 2018-12-03 10:31:16</span><br></pre></td></tr></table></figure><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><ul><li><a href="http://blog.51cto.com/ixdba/806622" target="_blank" rel="noopener">实战Nginx与PHP（FastCGI）的安装、配置与优化</a></li><li><a href="https://www.cnblogs.com/chensiqiqi/p/9162958.html" target="_blank" rel="noopener">Nginx站点目录及文件URL访问控制</a></li></ul>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器配置——实战验证与补充</title>
      <link href="/2018/03/09/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81%E4%B8%8E%E8%A1%A5%E5%85%85/"/>
      <url>/2018/03/09/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81%E4%B8%8E%E8%A1%A5%E5%85%85/</url>
      <content type="html"><![CDATA[<p> 下面关于之前一些流程（Ngnix，Php，Go，Mysql）安装配置与使用的一些总结，和遇到的一个坑，其中也有关于服务器配置与部署，代码上传与发布相关内容，主要是为了熟悉整个流程……</p><a id="more"></a><blockquote><p>这里补充一下前面没有提到，但是实际操作会用到或者能提升效率的东西</p></blockquote><h2 id="安装ftp"><a href="#安装ftp" class="headerlink" title="安装ftp"></a>安装ftp</h2><p>大家看到了，所有的文件操作在ssh中可以通过vim方法来实现，但是，你知道在windows中用惯了，还是喜欢看图形界面，所以在这里我安装了ftp可以远程来上传修改文件</p><pre><code>软件：winscp（百度下载就好了）</code></pre><h3 id="安装vsftpd"><a href="#安装vsftpd" class="headerlink" title="安装vsftpd"></a>安装vsftpd</h3><pre><code>yum install vsftpd</code></pre><h3 id="启动-重启-关闭vsftpd服务器"><a href="#启动-重启-关闭vsftpd服务器" class="headerlink" title="启动/重启/关闭vsftpd服务器"></a>启动/重启/关闭vsftpd服务器</h3><pre><code>[root@localhost ftp]# /sbin/service vsftpd restartShutting down vsftpd: [ OK ]Starting vsftpd for vsftpd: [ OK ] </code></pre><p>OK表示重启成功了.</p><p>这里现在就可以直接使用root及你的密码来查看了，当然这样的是超级用户，留给自己用的，要配置指定要文件夹的用户，我就在不在这里写了，大家继续百度下吧</p><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><pre><code>sudo apt-get updatesudo apt-get install git</code></pre>]]></content>
      
      <categories>
          
          <category> Server </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Server </tag>
            
            <tag> 服务器配置——实战验证与补充 </tag>
            
            <tag> 实战验证与补充 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器配置——Redis安装，配置，简单使用</title>
      <link href="/2018/03/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94Redis%E5%AE%89%E8%A3%85%EF%BC%8C%E9%85%8D%E7%BD%AE%EF%BC%8C%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/03/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94Redis%E5%AE%89%E8%A3%85%EF%BC%8C%E9%85%8D%E7%BD%AE%EF%BC%8C%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>本文是因为在做API接口开发的时候，要数据每次都需要从数据读取而写，那样太耗性能了，其实类型iOS中的Cache或者NSUserDefault，用法都和NSUserDefault类似….</p><a id="more"></a><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载安装包 redis-3.2.8.tar.gz</p><pre><code>官网地址：http://redis.io/download</code></pre><p>解压：</p><pre><code>tar -zvxf redis-3.2.8.tar.gz  将解压后的文件夹放到 /Users/local目录下</code></pre><p>编译测试:接下来在终端中切换到/Users/local/redis目录下,输入：sudo make test</p><pre><code>编译安装：在终端中输入命令：sudo make install</code></pre><p>启动Redis,输入命令redis-server</p><pre><code>redis-server78407:C 18 Apr 21:32:31.361 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf78407:M 18 Apr 21:32:31.362 * Increased maximum number of open files to 10032 (it was originally set to 256)._._                                                  _.-``__ &apos;&apos;-._                                             _.-``    `.  `_.  &apos;&apos;-._           Redis 3.2.8 (00000000/0) 64 bit.-`` .-```.  ```\/    _.,_ &apos;&apos;-._                                   (    &apos;      ,       .-`  | `,    )     Running in standalone mode|`-._`-...-` __...-.``-._|&apos;` _.-&apos;|     Port: 6379|    `-._   `._    /     _.-&apos;    |     PID: 78407`-._    `-._  `-./  _.-&apos;    _.-&apos;                                   |`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|                                  |    `-._`-._        _.-&apos;_.-&apos;    |           http://redis.io        `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;                                   |`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|                                  |    `-._`-._        _.-&apos;_.-&apos;    |                                  `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;                                   `-._    `-.__.-&apos;    _.-&apos;                                       `-._        _.-&apos;                                           `-.__.-&apos;                                               78407:M 18 Apr 21:32:31.363 # Server started, Redis version 3.2.878407:M 18 Apr 21:32:31.364 * DB loaded from disk: 0.001 seconds78407:M 18 Apr 21:32:31.364 * The server is now ready to accept connections on port 6379</code></pre><p>看到这个界面表示我们已经成功的安装Redis。</p><h2 id="二配置"><a href="#二配置" class="headerlink" title="二配置"></a>二配置</h2><h3 id="1、在-Users-local-redis目录下建立bin，etc，db三个目录"><a href="#1、在-Users-local-redis目录下建立bin，etc，db三个目录" class="headerlink" title="1、在 /Users/local/redis目录下建立bin，etc，db三个目录"></a>1、在 /Users/local/redis目录下建立bin，etc，db三个目录</h3><h3 id="2、把-Users-local-redis-src目录下的mkreleasehdr-sh，redis-benchmark，-redis-cli，-redis-server拷贝到bin目录"><a href="#2、把-Users-local-redis-src目录下的mkreleasehdr-sh，redis-benchmark，-redis-cli，-redis-server拷贝到bin目录" class="headerlink" title="2、把/Users/local/redis/src目录下的mkreleasehdr.sh，redis-benchmark， redis-cli， redis-server拷贝到bin目录"></a>2、把/Users/local/redis/src目录下的mkreleasehdr.sh，redis-benchmark， redis-cli， redis-server拷贝到bin目录</h3><h3 id="3、在etc下，参考原-Users-local-redis目录下的redis-conf，新建一个redis-conf"><a href="#3、在etc下，参考原-Users-local-redis目录下的redis-conf，新建一个redis-conf" class="headerlink" title="3、在etc下，参考原/Users/local/redis目录下的redis.conf，新建一个redis.conf"></a>3、在etc下，参考原/Users/local/redis目录下的redis.conf，新建一个redis.conf</h3><p>修改redis.conf，具体如下：</p><pre><code>#修改为守护模式daemonize yes#设置进程锁文件pidfile /Users/local/redis/redis.pid#端口port 6379#客户端超时时间timeout 300#日志级别loglevel debug#日志文件位置logfile /Users/local/redis/log-redis.log#设置数据库的数量，默认数据库为16，可以使用SELECT 命令在连接上指定数据库iddatabases 16##指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合#save#Redis默认配置文件中提供了三个条件：save 900 1save 300 10save 60 10000#指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，#可以关闭该#选项，但会导致数据库文件变的巨大rdbcompression yes#指定本地数据库文件名dbfilename dump.rdb#指定本地数据库路径dir /Users/local/redis/db/#指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能#会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有#的数据会在一段时间内只存在于内存中appendonly no#指定更新日志条件，共有3个可选值：#no：表示等操作系统进行数据缓存同步到磁盘（快）#always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）#everysec：表示每秒同步一次（折衷，默认值）appendfsync everysec</code></pre><p>其实只需要拷贝，然后修改对应的值就可以</p><h3 id="4、保存后，启动redis：-bin-redis-server-etc-redis-conf"><a href="#4、保存后，启动redis：-bin-redis-server-etc-redis-conf" class="headerlink" title="4、保存后，启动redis：./bin/redis-server etc/redis.conf"></a>4、保存后，启动redis：./bin/redis-server etc/redis.conf</h3><p>注意这里log-redis.log文件需要我自己创建</p><pre><code>iCocosdeMacBook-Pro:redis icocos$ redis-server etc/redis.conf回车之后没有输出说明成功了</code></pre><h3 id="5、查看日志文件：tail-f-log-redis-log"><a href="#5、查看日志文件：tail-f-log-redis-log" class="headerlink" title="5、查看日志文件：tail -f log-redis.log"></a>5、查看日志文件：tail -f log-redis.log</h3><pre><code>|    `-._`-._        _.-&apos;_.-&apos;    |                                  `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;                                   `-._    `-.__.-&apos;    _.-&apos;                                       `-._        _.-&apos;                                           `-.__.-&apos;                                               78584:M 18 Apr 21:48:02.777 # Server started, Redis version 3.2.878584:M 18 Apr 21:48:02.777 * The server is now ready to accept connections on port 637978584:M 18 Apr 21:48:02.779 - 0 clients connected (0 slaves), 957072 bytes in use</code></pre><p>到这里，我们已经完成redis安装和配置。</p><h2 id="三使用"><a href="#三使用" class="headerlink" title="三使用"></a>三使用</h2><h3 id="1、检查是否启动：redis-cli-ping"><a href="#1、检查是否启动：redis-cli-ping" class="headerlink" title="1、检查是否启动：redis-cli ping"></a>1、检查是否启动：redis-cli ping</h3><h3 id="2、redis-cli"><a href="#2、redis-cli" class="headerlink" title="2、redis-cli"></a>2、redis-cli</h3><h3 id="3、ping"><a href="#3、ping" class="headerlink" title="3、ping"></a>3、ping</h3><h3 id="4、redis-cli-跟上命令会将参数发送到本地redis-6379-的端口，下面来看看基本操作："><a href="#4、redis-cli-跟上命令会将参数发送到本地redis-6379-的端口，下面来看看基本操作：" class="headerlink" title="4、redis-cli 跟上命令会将参数发送到本地redis 6379 的端口，下面来看看基本操作："></a>4、redis-cli 跟上命令会将参数发送到本地redis 6379 的端口，下面来看看基本操作：</h3><p>使用方式</p><pre><code>iCocosdeMacBook-Pro:redis icocos$ redis-cli127.0.0.1:6379&gt; pingPONG127.0.0.1:6379&gt; set key1 nameOK127.0.0.1:6379&gt; get key1&quot;name&quot;</code></pre><h3 id="5、关闭命令：redis-cli-shutdown"><a href="#5、关闭命令：redis-cli-shutdown" class="headerlink" title="5、关闭命令：redis-cli shutdown"></a>5、关闭命令：redis-cli shutdown</h3><pre><code>上面我们演示了redis安装与配置，接下来后面的工作在真实上线之前只需要熟练redis的使用就差不多了，注意细节，并应用到实战，没错就这么简单！</code></pre><h2 id="四-服务器配置"><a href="#四-服务器配置" class="headerlink" title="四.服务器配置"></a>四.服务器配置</h2><p>上面只是基本的安装，如果要用到生产环境，得配置一些文件</p><h3 id="1-首先把redis-cli-移动到-Users-local-bin-目录，方便执行，和JAVA-HOME-类似"><a href="#1-首先把redis-cli-移动到-Users-local-bin-目录，方便执行，和JAVA-HOME-类似" class="headerlink" title="1.首先把redis-cli 移动到/Users/local/bin 目录，方便执行，和JAVA_HOME 类似"></a>1.首先把redis-cli 移动到/Users/local/bin 目录，方便执行，和JAVA_HOME 类似</h3><pre><code>默认install 的时候已经有了</code></pre><h3 id="2-创建你存放配置文件和数据文件的目录"><a href="#2-创建你存放配置文件和数据文件的目录" class="headerlink" title="2.创建你存放配置文件和数据文件的目录"></a>2.创建你存放配置文件和数据文件的目录</h3><pre><code>sudomkdir /etc/redissudo mkdir /var/redis</code></pre><h3 id="3-复制初始化脚本到-etc-init-d-目录-建议默认只有这个端口-作开机启动"><a href="#3-复制初始化脚本到-etc-init-d-目录-建议默认只有这个端口-作开机启动" class="headerlink" title="3.复制初始化脚本到/etc/init.d 目录,建议默认只有这个端口,作开机启动"></a>3.复制初始化脚本到/etc/init.d 目录,建议默认只有这个端口,作开机启动</h3><pre><code>$ sudocp utils/redis_init_script /etc/init.d/redis_6379</code></pre><h3 id="4-进入脚本-确保你的REDISPORT-是你正在使用的"><a href="#4-进入脚本-确保你的REDISPORT-是你正在使用的" class="headerlink" title="4.进入脚本,确保你的REDISPORT 是你正在使用的"></a>4.进入脚本,确保你的REDISPORT 是你正在使用的</h3><pre><code>sudovi /etc/init.d/redis_6379</code></pre><h3 id="5-复制redis-conf-和脚本保持一致"><a href="#5-复制redis-conf-和脚本保持一致" class="headerlink" title="5.复制redis.conf ,和脚本保持一致"></a>5.复制redis.conf ,和脚本保持一致</h3><pre><code>sudocp redis.conf /etc/redis/6379.conf</code></pre><h3 id="6-创建一个存放工作数据的目录"><a href="#6-创建一个存放工作数据的目录" class="headerlink" title="6.创建一个存放工作数据的目录"></a>6.创建一个存放工作数据的目录</h3><pre><code>sudomkdir /var/redis/6379</code></pre><p>同时可以对redis.conf配置其他属性</p><pre><code># 来源：http://www.cnblogs.com/shanyou/archive/2012/01/28/2330451.htmldaemonize：是否以后台daemon方式运行pidfile：pid文件位置port：监听的端口号timeout：请求超时时间loglevel：log信息级别logfile：log文件位置databases：开启数据库的数量save **：保存快照的频率，第一个*表示多长时间，第三个*表示执行多少次写操作。在一定时间内执行一定数量的写操作时，自动保存快照。可设置多个条件。rdbcompression：是否使用压缩dbfilename：数据快照文件名（只是文件名，不包括目录）dir：数据快照的保存目录（这个是目录）appendonly：是否开启appendonlylog，开启的话每次写操作会记一条log，这会提高数据抗风险能力，但影响效率。appendfsync：appendonlylog如何同步到磁盘（三个选项，分别是每次写都强制调用fsync、每秒启用一次fsync、不调用fsync等待系统自己同步）</code></pre><h3 id="7-最后将脚本设置默认启动"><a href="#7-最后将脚本设置默认启动" class="headerlink" title="7.最后将脚本设置默认启动"></a>7.最后将脚本设置默认启动</h3><pre><code>sudoupdate-rc.d redis_6379 defaults</code></pre><h3 id="8-现在可以执行脚本了"><a href="#8-现在可以执行脚本了" class="headerlink" title="8.现在可以执行脚本了"></a>8.现在可以执行脚本了</h3><pre><code>/etc/init.d/redis_6379start</code></pre><h2 id="五-MAC-版本差异"><a href="#五-MAC-版本差异" class="headerlink" title="五.MAC 版本差异"></a>五.MAC 版本差异</h2><p>一个不幸的事实是：mac 上是没有init.d 目录的，mac启动脚本是 以.plist 结尾了，</p><p>好吧，我在 ~/Library/LaunchAgents 目录下自己建立一个 redis.plist</p><p>参考：<a href="http://www.js2node.com/redis-io/install-redis-io-2-4-17-on-mac-osx-as-service" target="_blank" rel="noopener">http://www.js2node.com/redis-io/install-redis-io-2-4-17-on-mac-osx-as-service</a></p><pre><code>$ sudovi redis.plist</code></pre><p>然后输入以下内容</p><pre><code>Labelio.redis.redis-serverProgramArguments/Users/local/bin/redis-server/Users/local/etc/redis.confRunAtLoad</code></pre><p>执行命令</p><pre><code>$ sudo launchctlload/Library/LaunchDaemons/io.redis.redis-server.plist</code></pre><p>打开关闭：</p><pre><code>$ sudo launchctlstartio.redis.redis-server$ sudo launchctl stop io.redis.redis-server</code></pre><h2 id="六-brew-进行安装"><a href="#六-brew-进行安装" class="headerlink" title="六.brew 进行安装"></a>六.brew 进行安装</h2><p>下面我用brew来操作，关于brew 的安装我看的：<a href="http://my.oschina.net/liygheart/blog/284668" target="_blank" rel="noopener">http://my.oschina.net/liygheart/blog/284668</a></p><p>安装好了，然后 参考：<a href="https://gist.github.com/tonypujals/9631143" target="_blank" rel="noopener">https://gist.github.com/tonypujals/9631143</a></p><pre><code>$brew info redis</code></pre><p>会有提示，然后输入</p><pre><code>$ln -nfs /Users/local/opt/redis/*.plist ~/Library/LaunchAgents</code></pre><p>和</p><pre><code>$load ~/Library/LaunchAgents/homebrew.mxcl.redis.plist</code></pre><h2 id="网上还找到一种方式，貌似可以成功"><a href="#网上还找到一种方式，貌似可以成功" class="headerlink" title="网上还找到一种方式，貌似可以成功"></a>网上还找到一种方式，貌似可以成功</h2><p>1.获取github中的redis-php扩展代码：<br>    git clone <a href="https://github.com/phpredis/phpredis.git" target="_blank" rel="noopener">https://github.com/phpredis/phpredis.git</a></p><p>2.cd phpredis/</p><p>3.phpize mac os 如果这里有</p><pre><code>Cannot find autoconf. Please check your autoconf installation and the$PHP_AUTOCONF environment variable. Then, rerun this script.的问题，那么：执行：brew install autoconf</code></pre><p>4.之后执行phpize</p><p>5../configure</p><p>6.make &amp;&amp; sudo make install 输入密码就会提示成功</p><pre><code>Password:Installing shared extensions:     /usr/lib/php/extensions/no-debug-non-zts-20131226/</code></pre><p>7.之后在php.ini中加一句 extension=redis.so 就ok了</p><pre><code>路径：/etc/php.ini</code></pre><p>然后重启 apache/nginx 和 php-fpm ，输入命令：php -m |grep redis 或者通过 phpinfo() 输出php信息查看redis是否安装成功。</p><h3 id="期间我在执行install的时候出现这样的问题"><a href="#期间我在执行install的时候出现这样的问题" class="headerlink" title="期间我在执行install的时候出现这样的问题"></a>期间我在执行install的时候出现这样的问题</h3><p>装不了PHP的扩展，make install失败</p><pre><code>RudonMacBook:igbinary-master rudon$ make installInstalling shared extensions:     /usr/lib/php/extensions/no-debug-non-zts-20131226/cp: /usr/lib/php/extensions/no-debug-non-zts-20131226/#INST@12567#: Operation not permittedmake: *** [install-modules] Error 1cp: /usr/lib/php/extensions/no-debug-non-zts-20121212/#INST@17000#: Operation not permitted</code></pre><p>原因是</p><pre><code>原来是OSX 10.11 El Capitan（或更高）新添加了一个新的安全机制叫系统完整性保护System Integrity Protection (SIP)，所以对于目录/System/sbin/usr不包含(/usr/local/)仅仅供系统使用，其它用户或者程序无法直接使用，而我们的/usr/lib/php/extensions/刚好在受保护范围内</code></pre><p>所以解决方法就是禁掉SIP保护机制，步骤是：</p><pre><code>重启系统按住Command + R   （重新亮屏之后就开始按，象征地按几秒再松开，出现苹果标志，ok）菜单“实用工具” ==&gt;&gt; “终端” ==&gt;&gt; 输入csrutil disable；执行后会输出：Successfully disabled System Integrity Protection. Please restart the machine for the changes to take effect.再次重启系统禁止掉SIP后，就可以顺利的安装了，当然装完了以后你可以重新打开SIP，方法同上，只是命令是csrutil enable</code></pre><h2 id="平时使用"><a href="#平时使用" class="headerlink" title="平时使用"></a>平时使用</h2><pre><code>iCocosdeMacBook-Pro:redis icocos$ cd /Users/local/redisiCocosdeMacBook-Pro:redis icocos$ redis-server78728:C 18 Apr 22:00:25.105 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf78728:M 18 Apr 22:00:25.107 * Increased maximum number of open files to 10032 (it was originally set to 256)._._                                                  _.-``__ &apos;&apos;-._                                             _.-``    `.  `_.  &apos;&apos;-._           Redis 3.2.8 (00000000/0) 64 bit.-`` .-```.  ```\/    _.,_ &apos;&apos;-._                                   (    &apos;      ,       .-`  | `,    )     Running in standalone mode|`-._`-...-` __...-.``-._|&apos;` _.-&apos;|     Port: 6379|    `-._   `._    /     _.-&apos;    |     PID: 78728`-._    `-._  `-./  _.-&apos;    _.-&apos;                                   |`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|                                  |    `-._`-._        _.-&apos;_.-&apos;    |           http://redis.io        `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;                                   |`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|                                  |    `-._`-._        _.-&apos;_.-&apos;    |                                  `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;                                   `-._    `-.__.-&apos;    _.-&apos;                                       `-._        _.-&apos;                                           `-.__.-&apos;                                               78728:M 18 Apr 22:00:25.108 # Server started, Redis version 3.2.878728:M 18 Apr 22:00:25.108 * DB loaded from disk: 0.000 seconds78728:M 18 Apr 22:00:25.108 * The server is now ready to accept connections on port 6379^C78728:signal-handler (1492524027) Received SIGINT scheduling shutdown...78728:M 18 Apr 22:00:27.286 # User requested shutdown...78728:M 18 Apr 22:00:27.286 * Saving the final RDB snapshot before exiting.78728:M 18 Apr 22:00:27.288 * DB saved on disk78728:M 18 Apr 22:00:27.288 # Redis is now ready to exit, bye bye...iCocosdeMacBook-Pro:redis icocos$ redis-cli127.0.0.1:6379&gt; pingPONG127.0.0.1:6379&gt; set key1 nameOK127.0.0.1:6379&gt; get key1&quot;name&quot;127.0.0.1:6379&gt; </code></pre><h3 id="PHP中使用的话"><a href="#PHP中使用的话" class="headerlink" title="PHP中使用的话"></a>PHP中使用的话</h3><pre><code>&lt;?php$redis = new Redis();$redis-&gt;connect(&apos;127.0.0.1&apos;, 6379);$redis-&gt;set(&apos;iCocos&apos;,1234);$redis-&gt;get(&apos;iCocos&apos;);</code></pre><p>执行PHP文件，可以直接网页执行，也可以直接命令执行，方法基本上类似.</p><h2 id="Redis基本命令"><a href="#Redis基本命令" class="headerlink" title="Redis基本命令"></a>Redis基本命令</h2><p>Redis数据类型及操作:</p><pre><code>String:指令:{    set    setnx       :如果key已经存在, 返回0    setex       :指定键值对的有效期, setex [key] [expire] [value]   /类似于:set [key] [value] [EX expire]    setrange    :设置key-value值的子字符串,下标从0开始到第i位置,不包含i    mset    msetnx    get    getset    getrange    mget    incr    incrby    decr    decrby    append    strlen}</code></pre><p>Hash:是一个string类型的field-value的映射表,它的添加删除平均都是O(1)的效率</p><pre><code>指令:{    hset    hsetnx    hmset    hget    hmget    hincrby    hexists    hlen    hdel    hkeys    hvals    hgetall}</code></pre><p>List:是一个链表结构, 主要功能是pop,push,获取一个范围的所有值等,key理解为链表的名字<br>list类型其实就是每一个子元素都是string类型的双向链表.</p><pre><code>指令:{    lpush       rpush    linsert   : linsert key [BEFORE|AFTER] [pivot] [value]    在list的特定的值的位置之前或之后添加字符串元素    lset      : lset key [index] [value] 设置list中指定下标的元素值    lrem      : lrem key [count] [value] 从list中删除count个和value相同的元素    count&gt;0,从头删除;    count=0,全部删除;    count&lt;0,从尾删除;    ltrim     : ltrim key [start] [stop] 保留key的值中指定范围内的数据    lpop      : 从list的头部删除元素    rpop      : 从list的尾部删除元素    rpoplpush : rpoplpush [source] [destination], 整个操作是原子的    从source的尾部移除元素,并添加到destination的头部,返回被移除的元素值    lindex    : lindex key [index] 取list中index位置的元素    llen      : 返回key对应list的长度}</code></pre><p>Set: 指令:{}</p><p>键值指令:</p><pre><code>[     keys :返回给定pattern的所有key    exists: 确认一个key是否存在    del : 删除一个key    expire : 设置一个key的过期时间(秒为单位)    ttl : 用于获取key的有效时长    persist : 移除给定key的过期时间    move : 把当前数据库中的key移动到其它库中    rename : 重命名key]</code></pre><p>服务指令:</p><pre><code>[    select :选择数据库存取, redis数据库编号从 0~15 默认16个库    dbsize :获取当前数据库的key    info :  获取服务器的信息和统计,用于说明服务器的基础信息,包括版本启动时间等;    config get: 获取服务器配置信息    flushdb : 删除当前选择数据库中的所有key    flushall : 删除所有库中的所有key]</code></pre><p>主从复制基本配置:</p><pre><code>Redis主从复制中一个主服务可以有多个服务, 一个从服务可以有多个从服务;对应配置,只需要修改redis.conf中的slaveof参数#slaveof &lt;masterip&gt; &lt;masterport&gt;slaveof 127.0.0.1 6379</code></pre><p>启动master</p><pre><code>#redis-server /usr/local/redis/conf/redis_6379.conf#redis-cli启动slave(假设端口3689)#redis-server /usr/local/redis/conf/slave.conf#redis-cli -p 6389</code></pre><p>如果master服务设置有密码,则需要配置masterauth参数</p><pre><code>masterauth &lt;master-password&gt;</code></pre><p>查看redis连接数</p><pre><code>redis-cli info | grep connected</code></pre><p>如果客户端的idle空闲时间太长,连接池维持了太多的连接,则需要把不用的连接及时释放掉;</p><pre><code>redis 127.0.0.1:6379&gt; client listredis 127.0.0.1:6379&gt; CONFIG SET timeout 30</code></pre><p>Cluster集群配置</p><pre><code>cluster-enabled yes 开启</code></pre><p>每一个集群节点有一个集群配置文件;它不是手工创建的,是redis节点创建和更新的;</p><h3 id="确保同一系统上运行的redis集群节点的配置文件名不重叠"><a href="#确保同一系统上运行的redis集群节点的配置文件名不重叠" class="headerlink" title="确保同一系统上运行的redis集群节点的配置文件名不重叠"></a>确保同一系统上运行的redis集群节点的配置文件名不重叠</h3><ol><li><p>redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件,</p><p> 并且在此基础上实现了master-slave(主从)同步</p></li><li><p>pipeline 压缩请求数量</p><p> pipeline机制将多个命令汇聚到一个请求中,可以有效减少请求数量,减少网络延时。</p></li><li><p>script 压缩复杂请求</p><p> script核心思想是在redis命令里嵌入Lua脚本,来实现一些复杂操作。</p></li><li><p>cluster</p><p> Redis 集群不像单机版本的 Redis 那样支持多个数据库，集群只有数据库 0，而且也不支持 SELECT 命令。</p></li></ol><p>学习Redis命令请参考</p><p><a href="http://www.redis.cn/" target="_blank" rel="noopener">http://www.redis.cn/</a><br><a href="http://www.cnblogs.com/woshimrf/p/5198361.html" target="_blank" rel="noopener">http://www.cnblogs.com/woshimrf/p/5198361.html</a></p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器配置——Php安装与配置</title>
      <link href="/2018/02/19/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94Php%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/02/19/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94Php%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p> 由于之前学过一段时间的Php，偶尔看到一个不错的东西也会尝试一下，虽然可能最终结果和意义并不大，但是此次我还是觉决定让服务器支持Php，同时也会适当的更新一些Php的内容（能力有限，都是比较基础的内容）……</p> <a id="more"></a><blockquote><p>说了服务器第一步Ngnix安装与配置之后，就要开始说说关于PHP和Go的安装与配置</p></blockquote><h2 id="配置php-fpm部分"><a href="#配置php-fpm部分" class="headerlink" title="配置php-fpm部分"></a>配置php-fpm部分</h2><p>要让 nginx 能够执行 php 文件，需要去安装一下 php-fpm，它直接包含在了 CentOS 资源库里，所以直接使用 yum 命令可以安装它：</p><pre><code>yum install php-fpm</code></pre><p>完成以后，可以检查一下 php-fpm 的运行状态，使用 service 命令：</p><pre><code>service php-fpm status</code></pre><p>返回：</p><pre><code>php-fpm is stopped（php-fpm 已停止）</code></pre><p>启动 php-fpm 同样可以使用 service 命令：</p><pre><code>service php-fpm start</code></pre><h2 id="让-nginx-可以执行-php"><a href="#让-nginx-可以执行-php" class="headerlink" title="让 nginx 可以执行 php"></a>让 nginx 可以执行 php</h2><p>现在我们应该就可以让 nginx 去执行 php 了。不过你需要修改一下 nginx 的配置文件，之前我们在配置虚拟主机的时候，创建了一个 nginx.ninghao.net.conf 的配置文件，需要去修改下 nginx 的这个配置文件，才能去执行 php 。使用 vim 命令去编辑它：</p><pre><code>vim /etc/nginx/conf.d/nginx.ninghao.net.conf</code></pre><p>注意你的配置文件不一定叫 nginx.ninghao.net.conf，应该是你自己命名的配置文件。打开以后，找到下面这段字样的代码：</p><pre><code># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000##location ~ \.php$ {#    root           html;#    fastcgi_pass   127.0.0.1:9000;#    fastcgi_index  index.php;#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;#    include        fastcgi_params;#}</code></pre><p>这是 nginx 默认给我们的用来执行 php 的配置，从 location 开始取消注释，会让这个配置生效，然后我们还得简单去修改一下：</p><pre><code># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000#location ~ \.php$ {#   root           html;    fastcgi_pass   127.0.0.1:9000;    fastcgi_index  index.php;    fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;    include        fastcgi_params;}</code></pre><p>注意 root 那里仍然是被注释掉的，还有 SCRIPT_FILENAME 后面修改了一下，把 /scripts 换成了 $document_root 。保存并退出。然后重新启动 nginx：</p><pre><code>service nginx restart</code></pre><h2 id="测试是否可以执行-php"><a href="#测试是否可以执行-php" class="headerlink" title="测试是否可以执行 php"></a>测试是否可以执行 php</h2><p>现在，我们已经安装了 php-fpm，并修改了 nginx 的配置文件让它可以去执行 php，下面，我们得去测试一下，可以使用 php 的 phpinfo(); 函数，方法是在你的虚拟主机根目录下面，创建一个 php 文件，命名为 phpinfo.php，然后在这个文件里输入：</p><pre><code>&lt;?php phpinfo(); ?&gt;</code></pre><p>保存文件并退出。在浏览器里打开刚才创建的这个 php 文件。我这里应该是 <code>http://nginx.ninghao.net/phpinfo.php</code>。打开以后，你应该能看到像下面这样的界面，如果能，说明 nginx 已经可以执行 php 了。</p><h2 id="配置扩展"><a href="#配置扩展" class="headerlink" title="配置扩展"></a>配置扩展</h2><blockquote><p>现在，我们有了可以提供 web 服务的 nginx ，并且安装了 php-fpm ，配置了 nginx 可以让它去执行 php ，也安装了数据库管理系统。</p></blockquote><p>不过在运行真正的网站的时候，我们还需要为 php 安装一些额外的扩展，比如 处理 mysql 数据库的 mysql 扩展，缓存功能的 apc 扩展，处理图像的 gd 扩展等等。安装它们同样可以使用 yum 命令。</p><pre><code>yum install php-pecl-apc php-mysql php-gd php-mcrypt php-pear php-mbstring php-xmlrpc php-dom</code></pre><p>上面安装了一些 php 的扩展，如果你发现在安装网站的时候提示需要安装其它的扩展，同样可以使用 yum 命令去安装。安装完成以后，需要重启一下 php-fpm ：</p><pre><code>service php-fpm restart</code></pre>]]></content>
      
      <categories>
          
          <category> Server </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Server </tag>
            
            <tag> 服务器配置——Php安装与配置 </tag>
            
            <tag> Php安装与配置 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器配置——MySql安装与配置</title>
      <link href="/2018/02/05/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94MySql%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/02/05/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94MySql%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>服务器好了之后，首先我们应该从数据库入手，因为一切没有数据交互与存储的服务器和客户端都只是娱乐，这里我们选择大部分人都熟知而且与PHP成为天和之作的Mysql，当然他和Go也一样兼容……</p><a id="more"></a><h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><p>mysql 可以管理网站用到的数据库，WordPress 和 Drupal 也都支持 mysql 数据库。所以我们的 Web 运行环境里，需要安装一个 mysql 。之前我们已经添加了资源库，所以可以直接使用 yum 命令去安装  mysql ：</p><pre><code>yum install mysql-server</code></pre><p>安装完成后，使用 service 命令启动 mysql 服务：</p><pre><code>service mysqld start</code></pre><p>然后我们需要简单配置一下 mysql ，默认安装以后 mysql 的 root 用户是没有密码的，对于生产环境来说，这肯定是不行的.</p><p>另外还有一些安全相关的设置，可以使用下面这行命令去配置一下，它是一个向导，问你一些问题，你要给出答案，比如是否要设置 root 用户的密码， 密码是什么等等。</p><pre><code>mysql_secure_installation</code></pre><p>然后根据实际情况进行配置，也可以看看下面比较常用的配置方案</p><pre><code>Enter current password for root (enter for none):解释：输入当前 root 用户密码，默认为空，直接回车。Set root password? [Y/n]  y解释：要设置 root 密码吗？输入 y 表示愿意。Remove anonymous users? [Y/n]  y解释：要移除掉匿名用户吗？输入 y 表示愿意。Disallow root login remotely? [Y/n]  n解释：不想让 root 远程登陆吗？输入 y 表示愿意。Remove test database and access to it? [Y/n]  y解释：要去掉 test 数据库吗？输入 y 表示愿意。Reload privilege tables now? [Y/n]  y解释：想要重新加载权限吗？输入 y 表示愿意。</code></pre>]]></content>
      
      <categories>
          
          <category> Server </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器配置——MySql安装与配置 </tag>
            
            <tag> Server </tag>
            
            <tag> MySql安装与配置 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器配置——Nginx安装与配置</title>
      <link href="/2018/01/23/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94Nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/01/23/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94Nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p> 配置完阿里控制台之后，首先我们开始配置服务器，我的服务器各种配置都需要自己重新配，这里我现在Ngnix，不要问我为什么选择他，可能是之前用过Apache，对他印象不好吧……</p> <a id="more"></a><p>前面说了关于阿里云主机操作，这里打算开始一步一步搭建和配置服务器，并且开始Go语言和后台学习，并且徐后续更新，直到后面的后台实战开发</p><blockquote><p>关于域名解析，实例，和安全组相关请自行参考阿里官方教程</p></blockquote><h2 id="如何连接服务器执行环境配置"><a href="#如何连接服务器执行环境配置" class="headerlink" title="如何连接服务器执行环境配置"></a>如何连接服务器执行环境配置</h2><blockquote><p>我使用的是centos6.8 64位版本，如果您不是第一次接触linux那一定知道，linux不是一个可视化界面的系统，所以要摒弃windows的操作习惯，我使用的xshell这个软件链接的服务器，连接语句是 ssh root@ip地址</p></blockquote><p>地址处就是写入你的ip地址，然后回车鞋面就会自动连接，弹框提示输入密码</p><ul><li>输入服务器的密码，点击确定即链接上了</li></ul><p>ok，下面就可以开始配置环境了，第一步我们先配置nginx</p><h2 id="nginx安装部分"><a href="#nginx安装部分" class="headerlink" title="nginx安装部分"></a>nginx安装部分</h2><p>想在 CentOS 系统上安装 Nginx ，你得先去添加一个资源库，像这样：</p><pre><code>vim /etc/yum.repos.d/nginx.repo</code></pre><p>使用 vim 命令去打开 <code>/etc/yum.repos.d/nginx.repo</code> ，如果 nginx.repo 不存在，就会去创建一个这样的文件，打开以后按一下小 i 键，进入编辑模式，然后复制粘贴下面这几行代码，完成以后按 esc 键退出，再输入 :wq （保存并退出）</p><pre><code>[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=0enabled=1</code></pre><p>完成以后，我们就可以使用 yum 命令去安装 nginx 了，像这样：</p><pre><code>yum install nginx</code></pre><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/18addimags/servers/ngnix0001.png" alt="HYMBA"></p><p>安装好以后测试一下 nginx 服务：</p><pre><code>service nginx status</code></pre><p>应该会返回：</p><pre><code>nginx is stopped （nginx 已停止）</code></pre><p>再测试一下 nginx 的配置文件：</p><pre><code>nginx -t</code></pre><p>应该会返回：</p><pre><code>nginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful</code></pre><p>… syntax is ok，… test is successful，说明配置文件没问题，同时这个结果里你可以找到 nginx 的配置文件 nginx.conf 所在的位置。</p><h2 id="操纵-nginx-服务"><a href="#操纵-nginx-服务" class="headerlink" title="操纵 nginx 服务"></a>操纵 nginx 服务</h2><p>操纵服务，可以使用使用 service 命令，它可以启动（start），重启（restart），或停止服务（stop），比如要启动 nginx 服务：</p><pre><code>service nginx start</code></pre><p>服务启动以后，你就可以在浏览器上使用服务器的 IP 地址，或者指向这个地址的域名访问服务器指定的目录了。你会看到类似下面的这些文字。</p><pre><code>Welcome to nginx! If you see this page, the nginx web server is successfully installed and working. Further configuration is required. For online documentation and support please refer to nginx.org. Commercial support is available at nginx.com. Thank you for using nginx.</code></pre><h2 id="nginx配置部分"><a href="#nginx配置部分" class="headerlink" title="nginx配置部分"></a>nginx配置部分</h2><p>下面来看一下为 nginx 配置虚拟主机。先进入到 nginx 配置文件目录：</p><pre><code>cd /etc/nginx/conf.d</code></pre><p>复制这个目录里的 default.conf ，复制以后的名字可以使用你的虚拟主机名字。比如创建一个 nginx.ninghao.net 的虚拟主机。复制文件可以使用 cp 命令，像这样：</p><pre><code>cp default.conf nginx.ninghao.net.conf</code></pre><p>再去编辑一下这个复制以后的配置文件，可以使用 vim 命令：</p><pre><code>vim nginx.ninghao.net.conf</code></pre><p>你会看到像这样的代码：</p><pre><code>server { listen 80; server_name localhost; #charset koi8-r; #access_log   /var/log/nginx/log/host.access.log main; location / { root /usr/share/nginx/html; index index.html index.htm;}...}</code></pre><blockquote><p>server_name 就是主机名，也就是跟这个虚拟主机绑定在一块儿的域名，我事先把 nginx.ninghao.net 指向了服务器，这个虚拟主机就是为它准备的，所以，server_name 后面的东西就是 nginx.ninghao.net 。</p><p>紧接着 server_name 下面可以是一个root，就是这个虚拟主机的根目录，也就是网站所在的目录。比如我们要把 nginx.ninghao.net 这个网站的文件放在/home/www/nginx.ninghao.net 下面，那么这个 root 就是这个路径。</p></blockquote><p>然后去掉 location / 里面的 root 这行代码。再在 index 后面加上一种索引文件名，也就是默认打开的文件，这里要加上一个 index.php ，这样访问 nginx.ninghao.net 就可以直接打开 root 目录下面的 index.php 了。稍后我们再去安装 php 。修改之后，看起来像这样：</p><pre><code>server { listen 80; server_name nginx.ninghao.net; root /home/www/nginx.ninghao.net; #charset koi8-r; #access_log /var/log/nginx/log/host.access.log main; location / { index index.php index.html index.htm; }...}</code></pre><p>这个配置文件先修改到这，稍后，我们再回来继续修改一下它。保存一下，按 esc ，输入 :wp（保存并退出）。现在虚拟主机应该就可以使用了。主机的域名是 nginx.ninghao.net，访问它的时候，打开的是 /home/www/nginx.ninghao.net 这个目录里面的东西，你可以在这个目录下放点东西。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/18addimags/servers/ngnix0003.png" alt="HYMBA"></p><p>重启 nginx 或者重新加载 nginx 可以让配置文件生效。</p><pre><code>service nginx reload</code></pre><p>现在，打开浏览器，输入你为虚拟主机设置的域名，看看是否能打开你指定的目录里的东西。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/18addimags/servers/ngnix0002.png" alt="HYMBA"></p>]]></content>
      
      <categories>
          
          <category> Server </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Server </tag>
            
            <tag> 服务器配置——Nginx安装与配置 </tag>
            
            <tag> Nginx安装与配置 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器配置——阿里云主机配置与操作</title>
      <link href="/2018/01/11/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%BB%E6%9C%BA/"/>
      <url>/2018/01/11/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%BB%E6%9C%BA/</url>
      <content type="html"><![CDATA[<p>前几年在阿里买了一个属于自己的个性域名(笔者英文)：<a href="http://www.icocos.cn，虽然是CN，但是这都不是重点，重点是为了更全面的接触后台，更好的学习与实战后台开发与PHP，前天又在阿里买了个主机，打算开发玩弄一番，毕竟第一次，期间可能会遇到不少坑和不对的地方，望谅解与指出一起交流，谢谢....." target="_blank" rel="noopener">www.icocos.cn，虽然是CN，但是这都不是重点，重点是为了更全面的接触后台，更好的学习与实战后台开发与PHP，前天又在阿里买了个主机，打算开发玩弄一番，毕竟第一次，期间可能会遇到不少坑和不对的地方，望谅解与指出一起交流，谢谢.....</a>.</p><a id="more"></a><h2 id="阿里云（先声明我不是来给阿里大广告的，😂😂😂😂😂😂）"><a href="#阿里云（先声明我不是来给阿里大广告的，😂😂😂😂😂😂）" class="headerlink" title="阿里云（先声明我不是来给阿里大广告的，😂😂😂😂😂😂）"></a>阿里云（先声明我不是来给阿里大广告的，😂😂😂😂😂😂）</h2><ol><li>阿里云主机</li><li>域名：<a href="http://www.icocos.cn" target="_blank" rel="noopener">www.icocos.cn</a></li></ol><p>这里关于阿里云主机和域名的购买很简单，准备钱，一路点下去就可以了,具体操作强查看阿里文档……</p><h2 id="备案"><a href="#备案" class="headerlink" title="备案"></a>备案</h2><p>关于备案确实是不少人蛋疼的事情，说麻烦也没有多麻烦，说不麻烦但是搞起来又不是点几下就可以的，所以也有不少人选择了不需要备案的或者国外的主机，我当时也有这种想法，但是后来放弃了，投资嘛，自己都不舍得投资还怎么学东西，怎么提升呢！</p><pre><code>本案分个人备案和企业备案，具体详情阿里也有教程，或者网上也有相关教程</code></pre><h2 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h2><p>在链接之前可能需要做一些配置，但是有些事必须的有些可以后面备案成功之后再做，我就是第一次弄所以一直不懂，以为需要备案以后才能操作的。</p><h3 id="添加安全组织，允许22端口访问"><a href="#添加安全组织，允许22端口访问" class="headerlink" title="添加安全组织，允许22端口访问"></a>添加安全组织，允许22端口访问</h3><p>这里其实就是进入阿里控制台的云服务ECS，找到安全组，添加安全组，配置规则就可以.</p><p>这里只要注意</p><pre><code>端口:22/22授权对象：0.0.0.0/0</code></pre><p>初步的这样就可以了，我是为了方便链接访问</p><blockquote><p>然后就可以链接了</p></blockquote><h2 id="连接，并操作"><a href="#连接，并操作" class="headerlink" title="连接，并操作"></a>连接，并操作</h2><p>连接的话当然首选ssh，不要问我为什么，我也不知道，大家都用它，哈哈！</p><h3 id="关于SSH"><a href="#关于SSH" class="headerlink" title="关于SSH"></a>关于SSH</h3><p>SSH是每一台Linux电脑的标准配置。</p><pre><code>简单说，SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。</code></pre><h3 id="最基本的用法"><a href="#最基本的用法" class="headerlink" title="最基本的用法"></a>最基本的用法</h3><p>SSH主要用于远程登录。假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。</p><p>　　$ ssh user@host</p><p>如果本地用户名与远程用户名一致，登录时可以省略用户名。</p><p>　　$ ssh host</p><p>SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。</p><p>　　$ ssh -p 2222 user@host</p><p>上面这条命令表示，ssh直接连接远程主机的2222端口。</p><h3 id="这里我使用的是SSH-shell这个工具，Windows用什么不知道，网上应该一大堆"><a href="#这里我使用的是SSH-shell这个工具，Windows用什么不知道，网上应该一大堆" class="headerlink" title="这里我使用的是SSH shell这个工具，Windows用什么不知道，网上应该一大堆"></a>这里我使用的是SSH shell这个工具，Windows用什么不知道，网上应该一大堆</h3><p>命令行步骤</p><pre><code>输入 ssh root@ip地址输入yes输入密码</code></pre><p>就可以看到显示</p><pre><code>[root@iZwz92qgus0ln1nx5dftjd2rZ ~]#</code></pre><p>SSH工具使用也很简单，进后点击Add Server输入ip，端口是默认22，输入root用户名，输入后台配置的密码，对了这里的密码是需要在控制台配置的</p><p>一切顺利的话可以看到一个和terminal一样的终端界面，并且已经连接成功的显示</p><pre><code>[root@iZwz92qgus0ln1nx5dftjd2rZ ~]#</code></pre><p>然后就可以使用命令操作主机文件了。</p><h2 id="密码登录：Mac-客户端"><a href="#密码登录：Mac-客户端" class="headerlink" title="密码登录：Mac 客户端"></a>密码登录：Mac 客户端</h2><h3 id="进入-ssh-文件夹，如果没有就创建一个-ssh文件夹"><a href="#进入-ssh-文件夹，如果没有就创建一个-ssh文件夹" class="headerlink" title="进入.ssh 文件夹，如果没有就创建一个.ssh文件夹"></a>进入.ssh 文件夹，如果没有就创建一个.ssh文件夹</h3><pre><code>mkdir ~/.sshcd ~/.ssh/</code></pre><h3 id="生成rsa秘钥：这个相信大部分人都弄过，github就需要"><a href="#生成rsa秘钥：这个相信大部分人都弄过，github就需要" class="headerlink" title="生成rsa秘钥：这个相信大部分人都弄过，github就需要"></a>生成rsa秘钥：这个相信大部分人都弄过，github就需要</h3><pre><code>ssh-keygen -t rsa</code></pre><h3 id="在该文件夹下就会产生三个文件夹：id-rsa-id-rsa-pub-know-hosts。"><a href="#在该文件夹下就会产生三个文件夹：id-rsa-id-rsa-pub-know-hosts。" class="headerlink" title="在该文件夹下就会产生三个文件夹：id_rsa,id_rsa.pub,know_hosts。"></a>在该文件夹下就会产生三个文件夹：id_rsa,id_rsa.pub,know_hosts。</h3><pre><code>id_rsa：存储私钥，记得只能自己看哦。别人那到这个文件就完蛋蛋咯。id_rsa.pub:存储公钥，用来通信加密使用，有了这个人家才能确定这是你。</code></pre><h3 id="公钥拷贝到云主机"><a href="#公钥拷贝到云主机" class="headerlink" title="公钥拷贝到云主机"></a>公钥拷贝到云主机</h3><pre><code>scp id_rsa.pub  root@78.129.23.45:/root/.ssh/id_rsa.pub</code></pre><h3 id="Note-云主机上没有-ssh-文件时，你要自己建立一个。"><a href="#Note-云主机上没有-ssh-文件时，你要自己建立一个。" class="headerlink" title="Note:云主机上没有.ssh/文件时，你要自己建立一个。"></a>Note:云主机上没有.ssh/文件时，你要自己建立一个。</h3><p>终端连接后输入ls只能看到default.pass文件，ls -a发现也是没有.ssh文件夹的，所以需要输入下面命令创建.ssh文件夹</p><pre><code>mkdir .ssh #回车没有提示就成功再次ls -a就可以看到一个蓝色的隐藏文件夹</code></pre><h2 id="登录到云主机"><a href="#登录到云主机" class="headerlink" title="登录到云主机"></a>登录到云主机</h2><h3 id="进入-ssh-文件夹"><a href="#进入-ssh-文件夹" class="headerlink" title="进入.ssh/文件夹"></a>进入.ssh/文件夹</h3><pre><code>cd  /root/.ssh/</code></pre><h3 id="将客户端公钥放入云主机识别keys文件夹中"><a href="#将客户端公钥放入云主机识别keys文件夹中" class="headerlink" title="将客户端公钥放入云主机识别keys文件夹中"></a>将客户端公钥放入云主机识别keys文件夹中</h3><pre><code>cat id_rsa.pub &gt;&gt; authorized_keys</code></pre><h3 id="销毁公钥"><a href="#销毁公钥" class="headerlink" title="销毁公钥"></a>销毁公钥</h3><pre><code>rm id_rsa.pub</code></pre><p>再次输入ssh root@ip地址就可以直接连接了，当然如果你使用工具的话就不用这么麻烦。</p><blockquote><p>到这里就基本上初步，而且是很简单的实现的主机的查看与操作，具体更多操作和命令请查看相关资料，后期也会有一些配置，操作与实战，请期待</p></blockquote>]]></content>
      
      <categories>
          
          <category> Server </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Server </tag>
            
            <tag> 服务器配置——阿里云主机配置与操作 </tag>
            
            <tag> 阿里云主机配置与操作 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Composer实战指南</title>
      <link href="/2017/12/15/Composer%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/"/>
      <url>/2017/12/15/Composer%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<p>Composer 是 PHP 用来管理依赖（dependency）关系的工具。你可以在自己的项目中声明所依赖的外部工具库（libraries），Composer 会帮你安装这些依赖的库文件。</p><p>PHP 开发过程中，难免会使用第三方包或自己的功能吧。那么，很容易出来第三方包之间的包名一样的情况。以及，同一包的不版本与其他包之间的依赖混乱的情况。</p><p>其它的语言也有类似的包依赖管理工具：Java有Maven，Python有pip，Ruby有gem，Nodejs有npm。</p><p>PHP的则是PEAR，不过PEAR坑不少：</p><ul><li>依赖处理容易出问题</li><li>配置非常复杂</li><li>难用的命令行接口</li></ul><a id="more"></a><p>既然有问题，那一定会有人跳出来解决。于是，Composer就出来了。</p><blockquote><p>运行 Composer 需要 PHP 5.3.2+ 以上版本。一些敏感的 PHP 设置和编译标志也是必须的，但对于任何不兼容项安装程序都会抛出警告。</p></blockquote><h2 id="一、Composer在各平台的安装"><a href="#一、Composer在各平台的安装" class="headerlink" title="一、Composer在各平台的安装"></a>一、Composer在各平台的安装</h2><p>事实上只要你使用的系统中已经开启或支持Curl命令或将php可执行文件添加到了系统PATH中。那么，安装composer是相当的简单的。</p><p>在你的客户端运行如下命令安装 composer。默认安装最新版。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sS https://getcomposer.org/installer | php</span><br></pre></td></tr></table></figure><p>如果你的系统没有curl,则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -r "readfile('https://getcomposer.org/installer');" | php</span><br></pre></td></tr></table></figure><p>官方英文安装文档：<a href="https://getcomposer.org/download/" target="_blank" rel="noopener">https://getcomposer.org/download/</a></p><h2 id="二、一些常用的-Composer-命令"><a href="#二、一些常用的-Composer-命令" class="headerlink" title="二、一些常用的 Composer 命令"></a>二、一些常用的 Composer 命令</h2><p>假定你已经有一个新项目对应的文件夹名称是 test 。那么，在 test 项目下你要创建一个composer.json。这样，在之后使用composer.json命令才能成功。</p><h3 id="1）安装扩展包"><a href="#1）安装扩展包" class="headerlink" title="1）安装扩展包"></a>1）安装扩展包</h3><p>以安装 monolog 扩展为例。这个包可以在 packagist.org 搜索得到。可以看到每个包的引入条件。</p><p>在composer.json里面增加引入配置，增加之后composer.json文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;require&quot;: &#123;</span><br><span class="line">        &quot;monolog/monolog&quot;: &quot;1.2.*&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，我们可以在命令行的 test 项目目录下执行如下命令安装它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer install</span><br></pre></td></tr></table></figure><p>这个时候在项目根目录下会生成一个 composer.lock 文件，以及一个 vendor 文件夹。在vendor文件夹下有一个 monolog 文件夹，说明我们已经安装成功。</p><h3 id="2）更新扩展包"><a href="#2）更新扩展包" class="headerlink" title="2）更新扩展包"></a>2）更新扩展包</h3><p>更新扩展包，可以一起更新，也可以单独更新某一个包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer update</span><br></pre></td></tr></table></figure><p>以上命令会将当前扩展包整体更新。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer update monolog/monolog</span><br></pre></td></tr></table></figure><p>以上命令只会更新monolog/monolog扩展包。</p><p>当修改了 composer.json 文件且已经存在composer.lock文件的时候，使用如下命令并不会更新：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer install</span><br></pre></td></tr></table></figure><p>必须使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer update</span><br></pre></td></tr></table></figure><h3 id="3）移除扩展包"><a href="#3）移除扩展包" class="headerlink" title="3）移除扩展包"></a>3）移除扩展包</h3><p>扩展包移动命令会将扩展包在vendor文件夹中彻底删除。命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer remove monolog/monolog</span><br></pre></td></tr></table></figure><h3 id="4）包版本号介绍"><a href="#4）包版本号介绍" class="headerlink" title="4）包版本号介绍"></a>4）包版本号介绍</h3><p>在前面的例子中，我们引入的 monolog 版本指定为 1.0.*。这表示任何从 1.0 开始的开发分支，它将会匹配 1.0.0、1.0.2 或者 1.0.20。</p><p>版本约束可以用几个不同的方法来指定。</p><table><thead><tr><th>名称</th><th>实例</th><th>描述</th></tr></thead><tbody><tr><td>确切的版本号</td><td>1.0.2</td><td>你可以指定包的确切版本。</td></tr><tr><td>范围</td><td>&gt;=1.0 &gt;=1.0,&lt;2.0 &gt;=1.0</td><td>通过使用比较操作符可以指定有效的版本范围。</td></tr><tr><td>有效的运算符：</td><td>&gt;、&gt;=、&lt;、&lt;=、!=。</td><td>你可以定义多个范围，用逗号隔开，这将被视为一个逻辑AND处理。 AND 的优先级高于 OR。</td></tr><tr><td>通配符</td><td>1.0.*</td><td>你可以使用通配符<em>来指定一种模式。1.0.</em>与&gt;=1.0,&lt;1.1是等效的。</td></tr><tr><td>赋值运算符</td><td>~1.2</td><td>这对于遵循语义化版本号的项目非常有用。~1.2相当于&gt;=1.2,&lt;2.0。想要了解更多，请阅读下一小节。</td></tr></tbody></table><h3 id="下一个重要版本（波浪号运算符）"><a href="#下一个重要版本（波浪号运算符）" class="headerlink" title="下一个重要版本（波浪号运算符）"></a>下一个重要版本（波浪号运算符）</h3><p>最好用例子来解释： ~1.2 相当于 &gt;=1.2,&lt;2.0，而 ~1.2.3 相当于 &gt;=1.2.3,&lt;1.3。正如你所看到的这对于遵循 语义化版本号 的项目最有用。一个常见的用法是标记你所依赖的最低版本，像 ~1.2 （允许1.2以上的任何版本，但不包括2.0）。由于理论上直到2.0应该都没有向后兼容性问题，所以效果很好。你还会看到它的另一种用法，使用 ~ 指定最低版本，但允许版本号的最后一位数字上升。</p><blockquote><p>注意： 虽然 2.0-beta.1 严格地说是早于 2.0，但是，根据版本约束条件， 例如 ~1.2 却不会安装这个版本。就像前面所讲的 ~1.2 只意味着 .2 部分可以改变，但是 1. 部分是固定的。</p></blockquote><h3 id="5）稳定性"><a href="#5）稳定性" class="headerlink" title="5）稳定性"></a>5）稳定性</h3><p>默认情况下只有稳定的发行版才会被考虑在内。如果你也想获得 RC、beta、alpha 或 dev 版本，你可以使用 稳定标志。你可以对所有的包做 最小稳定性 设置，而不是每个依赖逐一设置。</p><blockquote><p>稳定性对应 composer.json文件中的 “minimum-stability”: “dev”。</p></blockquote><h3 id="6）composer-lock-锁文件"><a href="#6）composer-lock-锁文件" class="headerlink" title="6）composer.lock - 锁文件"></a>6）composer.lock - 锁文件</h3><p>在安装依赖后，Composer 将把安装时确切的版本号列表写入 composer.lock 文件。这将锁定改项目的特定版本。</p><blockquote><p>请提交你应用程序的 composer.lock （包括 composer.json）到你的版本库中。</p></blockquote><p>这是非常重要的，因为 install 命令将会检查锁文件是否存在，如果存在，它将下载指定的版本（忽略 composer.json 文件中的定义）。</p><blockquote><p>这意味着，任何人建立项目都将下载与指定版本完全相同的依赖。你的持续集成服务器、生产环境、你团队中的其他开发人员、每件事、每个人都使用相同的依赖，从而减轻潜在的错误对部署的影响。即使你独自开发项目，在六个月内重新安装项目时，你也可以放心的继续工作，即使从那时起你的依赖已经发布了许多新的版本。</p></blockquote><p>如果不存在 composer.lock 文件，Composer 将读取 composer.json 并创建锁文件。</p><p>这意味着如果你的依赖更新了新的版本，你将不会获得任何更新。此时要更新你的依赖版本请使用 update 命令。这将获取最新匹配的版本（根据你的 composer.json 文件）并将新版本更新进锁文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php composer.phar update</span><br></pre></td></tr></table></figure><p>如果只想安装或更新一个依赖，你可以白名单它们：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php composer.phar update monolog/monolog [...]</span><br></pre></td></tr></table></figure><blockquote><p>注意： 对于库，并不一定建议提交锁文件 请参考：库的锁文件.</p></blockquote><p>更新文档，请参考：<a href="http://www.phpcomposer.com/" target="_blank" rel="noopener">http://www.phpcomposer.com/</a></p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> PHP面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQL查询优化简介</title>
      <link href="/2017/10/29/SQL%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AE%80%E4%BB%8B/"/>
      <url>/2017/10/29/SQL%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>在了解MySQL查询优化之前，先来看看关于MySQL的执行流程，因为关于数据层优化来说，归根结底还是关于IO的优化，只有知道了关于MySQL的执行流程，我们才能把优化做的更好</p><h3 id="MySQL的流程分析"><a href="#MySQL的流程分析" class="headerlink" title="MySQL的流程分析"></a>MySQL的流程分析</h3><h4 id="1-连接"><a href="#1-连接" class="headerlink" title="1.连接"></a>1.连接</h4><pre><code>1. 客户端发起一条Query请求，监听客户端的‘连接管理模块’接收请求2. 将请求转发到‘连接进/线程模块’3. 调用‘用户模块’来进行授权检查4. 通过检查后，‘连接进/线程模块’从‘线程连接池’中取出空闲的被缓存的连接线程和客户端请求对接，如果失败则创建一个新的连接请求</code></pre><a id="more"></a><h4 id="2-处理"><a href="#2-处理" class="headerlink" title="2.处理"></a>2.处理</h4><pre><code>1. 先查询缓存，检查Query语句是否完全匹配，接着再检查是否具有权限，都成功则直接取数据返回2. 上一步有失败则转交给‘命令解析器’，经过词法分析，语法分析后生成解析树3. 接下来是预处理阶段，处理解析器无法解决的语义，检查权限等，生成新的解析树4. 再转交给对应的模块处理5. 如果是SELECT查询还会经由‘查询优化器’做大量的优化，生成执行计划6. 模块收到请求后，通过‘访问控制模块’检查所连接的用户是否有访问目标表和目标字段的权限7. 有则调用‘表管理模块’，先是查看table cache中是否存在，有则直接对应的表和获取锁，否则重新打开表文件8. 根据表的meta数据，获取表的存储引擎类型等信息，通过接口调用对应的存储引擎处理9. 上述过程中产生数据变化的时候，若打开日志功能，则会记录到相应二进制日志文件中</code></pre><h4 id="3-结果"><a href="#3-结果" class="headerlink" title="3.结果"></a>3.结果</h4><pre><code>1. Query请求完成后，将结果集返回给‘连接进/线程模块’2. 返回的也可以是相应的状态标识，如成功或失败等3. ‘连接进/线程模块’进行后续的清理工作，并继续等待请求或断开与客户端的连接</code></pre><h4 id="4-小结"><a href="#4-小结" class="headerlink" title="4:小结"></a>4:小结</h4><blockquote><p>用户模块校验用户,然后去线程连接池拿线程(连接足够的话),找命令分发器,到查询缓存模块查SQL语句,如果没有,走命令解析器,然后访问控制模块,设定用户的权限,设定好后走表管理模块,获取锁和缓存,然后获取各种信息,存储的方式:存储引擎,从存储引擎获取数据,然后返回</p></blockquote><!--more--><h3 id="一、优化的入手点"><a href="#一、优化的入手点" class="headerlink" title="一、优化的入手点"></a>一、优化的入手点</h3><ul><li><p>查找分析查询慢的原因</p><ul><li>1.记录慢查询日志（慢查询日志的使用以及分析见本章slow_query.md)  </li><li>2.show profile:  <ul><li>set profiling = 1;开启，服务器上执行的所有语句会检测消耗的时间，存到临时表  </li><li>show profiles 查看语句执行消耗的时间  </li><li>show profile for query 临时表ID  查看某个查询的详细消耗  </li></ul></li><li>3.分析单条语句使用explain（explain.md查看explain用法）</li></ul></li><li><p>优化查询中的数据访问</p><ul><li>1.访问数据太多导致查询性能下降，尽量不要使用select *  </li><li>2.确定应用程序逻辑需要的数据量，使用limit返回一部分即可  </li><li>3.确定MySQL是否检索了索引，避免全表扫描  </li><li>4.重复查询相同的数据，可以缓存数据，下次直接读缓存  </li><li>5.是否存在扫描额外的记录（使用explain分析发现需要扫描大量的数据，却只返回少数行）：  </li></ul></li></ul><p>使用索引覆盖扫描，把所用到的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果  </p><ul><li>优化长难语句</li></ul><p>一个复杂的查询和多个简单的查询相比较，mysql每秒可以查询上百万的数据，响应给客户端的速度就要慢得多，所以使用尽可能少的查询是好的，但是有时候把一个大查询分解为多个小的查询也是必要的。因为长时间的sql会产生临时表、锁表、占用数据连接等情况，影响其他的查询。  </p><ul><li>解决方案：  <ul><li>1.切分查询，将一条大的查询切分成多个小的查询，分批次执行  </li><li>2.分解关联查询， 将一个关联语句分解成多个sql来执行，减少锁的竞争，并且在应用层进行关联，以后更容易拆分数据库  </li></ul></li></ul><ul><li>优化特定类型的查询语句<ul><li>1.优化关联查询，确定on的子句有没有索引，避免全表扫描  </li><li>2.确保group by和order by中只有一个表中的列，这样才会使用到索引  </li><li>3.优化子查询，尽量使用关联查询来替代子查询(因为mysql对关联查询会有一些优化器，但是高性能mysql上说了，在mysql5.6以上版本或者MariaDB中，子查询和关联查询的效率是差不多的)  </li><li>4.优化limit分页，当limit偏移量大的时候，查询效率就会很低。此时我们可以记录上次查询的最大id，下次查询时直接根据该id来查询  </li></ul></li></ul><blockquote><p>比如每页需要显示10条数据，到limit 10000,10的时候，其实是查出了10010条结果集，返回了10条。如果我们记住上一次查询的最大id，10000.我们可以使用 where id &gt; 10000 limit 10，这样还是只在10条数据中返回，极大的提升了运行效率</p></blockquote>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>负载均衡和请求转发笔记总结</title>
      <link href="/2017/10/18/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/"/>
      <url>/2017/10/18/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="负载均衡，请求转发"><a href="#负载均衡，请求转发" class="headerlink" title="负载均衡，请求转发"></a>负载均衡，请求转发</h1><h3 id="七层负载均衡的实现"><a href="#七层负载均衡的实现" class="headerlink" title="七层负载均衡的实现"></a>七层负载均衡的实现</h3><blockquote><p>基于URL等应用层信息的负载均衡  </p></blockquote><p>用Nginx的proxy实现七层负载均衡，具有如下特点：</p><ul><li>功能强大，运行稳定  </li><li>配置简单灵活  </li><li>能够自动剔除工作不正常的后端服务器  </li><li>上传文件使用异步模式 </li><li>支持多种分配策略(内置策略，扩展策略)，可以分配权重  </li><li>内置策略：IP Hash 、 加权轮询  </li><li>扩展策略： fair策略、通用hash、一致性hash</li></ul><a id="more"></a><h6 id="加权轮询策略："><a href="#加权轮询策略：" class="headerlink" title="加权轮询策略："></a>加权轮询策略：</h6><blockquote><p>首先将请求都分给权重高的机器，知道机器权重降低到了比其他机器低，在将请求分配给下一个权重高的机器。当所有机器都down掉时，Nginx会将所有机器标志位清成初始状态，以避免所有机器都处在timeout状态</p></blockquote><h6 id="IP-Hash策略："><a href="#IP-Hash策略：" class="headerlink" title="IP Hash策略："></a>IP Hash策略：</h6><blockquote><p>与轮询很类似，只是算法做了一些修改，相当于变向的轮询策略</p></blockquote><h6 id="fair策略："><a href="#fair策略：" class="headerlink" title="fair策略："></a>fair策略：</h6><blockquote><p>根据后端的响应时间来判断负载的情况，从中选出负载最轻的机器，进行分流</p></blockquote><h6 id="通用hash、一致性hash策略："><a href="#通用hash、一致性hash策略：" class="headerlink" title="通用hash、一致性hash策略："></a>通用hash、一致性hash策略：</h6><blockquote><p>通用hash使用Nginx内置的变量key进行hash，一致性hash采用了Nginx内置的一致性hash环，支持memcache</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Nginx配置：</span><br><span class="line">http &#123;</span><br><span class="line">    upstream cluster &#123;</span><br><span class="line">        # ip hash; 指定策略为ip hash</span><br><span class="line">        server svr1; # 配置权重 weight = 10；</span><br><span class="line">        server svr2;</span><br><span class="line">        server svr3;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://cluster;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四层负载均衡的实现"><a href="#四层负载均衡的实现" class="headerlink" title="四层负载均衡的实现"></a>四层负载均衡的实现</h3><blockquote><p>四层负载均衡是通过报文中目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。  </p></blockquote><h5 id="软件-LVS-实现，LVS有三种方式：NAT、DR、TUN"><a href="#软件-LVS-实现，LVS有三种方式：NAT、DR、TUN" class="headerlink" title="软件(LVS)实现，LVS有三种方式：NAT、DR、TUN"></a>软件(LVS)实现，LVS有三种方式：NAT、DR、TUN</h5>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常用负载均衡调度算法实现</title>
      <link href="/2017/10/07/%E5%B8%B8%E7%94%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2017/10/07/%E5%B8%B8%E7%94%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>用 PHP 实现几种负载均衡调度算法，详细见 </p><blockquote><p>在分布式系统中，为了实现负载均衡，必然会涉及到负载调度算法，如 Nginx 和 RPC 服务发现等场景。常见的负载均衡算法有 轮询、源地址 Hash、最少连接数，而 轮询 是最简单且应用最广的算法。</p></blockquote><a id="more"></a><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2019/phps/ngxin-loading.jpg"></p><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>3种常见的轮询调度算法，分别为 简单轮询、加权轮询、平滑加权轮询</p><h5 id="普通轮询（general-Round-Robin"><a href="#普通轮询（general-Round-Robin" class="headerlink" title="普通轮询（general Round Robin)"></a>普通轮询（general Round Robin)</h5><pre><code>namespace Robin;class Robin implements RobinInterface{    private $services = array();    private $total;    private $currentPos = -1;    public function init(array $services)    {        $this-&gt;services = $services;        $this-&gt;total = count($services);    }    public function next()    {        // 已调度完一圈,重置currentPos值为第一个实例位置        $this-&gt;currentPos = ($this-&gt;currentPos + 1) % $this-&gt;total;        return $this-&gt;services[$this-&gt;currentPos];    }}</code></pre><h5 id="加权轮询（Weighted-Round-Robin"><a href="#加权轮询（Weighted-Round-Robin" class="headerlink" title="加权轮询（Weighted Round Robin)"></a>加权轮询（Weighted Round Robin)</h5><pre><code>namespace Robin;class WeightedRobin implements RobinInterface{    private $services = array();    private $total;    private $currentPos = -1;    private $currentWeight;    public function init(array $services)    {        foreach ($services as $ip =&gt; $weight) {            $this-&gt;services[] = [                &apos;ip&apos; =&gt; $ip,                &apos;weight&apos; =&gt; $weight,            ];        }        $this-&gt;total = count($this-&gt;services);    }    public function next()    {        $i = $this-&gt;currentPos;        while (true) {            $i = ($i + 1) % $this-&gt;total;            // 已全部被遍历完一次            if (0 === $i) {                // 减currentWeight                $this-&gt;currentWeight -= $this-&gt;getGcd();                // 赋值currentWeight为0,回归到初始状态                if ($this-&gt;currentWeight &lt;= 0) {                    $this-&gt;currentWeight = $this-&gt;getMaxWeight();                }            }            // 直到当前遍历实例的weight大于或等于currentWeight            if ($this-&gt;services[$i][&apos;weight&apos;] &gt;= $this-&gt;currentWeight) {                $this-&gt;currentPos = $i;                return $this-&gt;services[$this-&gt;currentPos][&apos;ip&apos;];            }        }    }    /**     * 求两数的最大公约数(基于欧几里德算法,可使用gmp_gcd())     *     * @param integer $a     * @param integer $b     *     * @return integer     */    private function gcd($a, $b)    {        $rem = 0;        while ($b) {            $rem = $a % $b;            $a = $b;            $b = $rem;        }        return $a;    }    /**     * 获取最大公约数     *     * @return integer     */    private function getGcd()    {        $gcd = $this-&gt;services[0][&apos;weight&apos;];        for ($i = 0; $i &lt; $this-&gt;total; $i++) {            $gcd = $this-&gt;gcd($gcd, $this-&gt;services[$i][&apos;weight&apos;]);        }        return $gcd;    }    /**     * 获取最大权重值     *     * @return integer     */    private function getMaxWeight()    {        $maxWeight = 0;        foreach ($this-&gt;services as $node) {            if ($node[&apos;weight&apos;] &gt;= $maxWeight) {                $maxWeight = $node[&apos;weight&apos;];            }        }        return $maxWeight;    }}</code></pre><h5 id="平滑加权轮询（Smooth-Weighted-Round-Robin"><a href="#平滑加权轮询（Smooth-Weighted-Round-Robin" class="headerlink" title="平滑加权轮询（Smooth Weighted Round Robin)"></a>平滑加权轮询（Smooth Weighted Round Robin)</h5><pre><code>namespace Robin;class SmoothWeightedRobin implements RobinInterface{    /**     * 服务群组     * @var array     */    private $services = array();    /**     * 同时累加所有peer的effective_weight，保存为total     * @var     */    private $total;    /**     * 后端目前的权重     * @var int     */    private $currentPos = -1;    /**     * 初始化     * @param array $services     */    public function init(array $services)    {        foreach ($services as $ip =&gt; $weight) {            $this-&gt;services[] = [                &apos;ip&apos; =&gt; $ip,                &apos;weight&apos; =&gt; $weight,                &apos;current_weight&apos; =&gt; $weight,            ];        }        $this-&gt;total = count($this-&gt;services);    }    public function next()    {        // 获取最大当前有效权重的实例位置        $this-&gt;currentPos = $this-&gt;getMaxCurrentWeightPos();        // 当前权重减去权重和        $currentWeight = intval($this-&gt;getCurrentWeight($this-&gt;currentPos)) - intval($this-&gt;getSumWeight());        $this-&gt;setCurrentWeight($this-&gt;currentPos, $currentWeight);        // 每个实例的当前有效权重加上配置权重        $this-&gt;recoverCurrentWeight();        return $this-&gt;services[$this-&gt;currentPos][&apos;ip&apos;];    }    /**     * 获取最大当前有效权重实例位置     * @return int     */    public function getMaxCurrentWeightPos()    {        $currentWeight = $pos = 0;        foreach ($this-&gt;services as $index =&gt; $service) {            if ($service[&apos;current_weight&apos;] &gt; $currentWeight) {                $currentWeight = $service[&apos;current_weight&apos;];                $pos = $index;            }        }        return $pos;    }    /**     * 配置权重和，累加所有后端的effective_weight     *     * @return integer     */    public function getSumWeight()    {        $sum = 0;        foreach ($this-&gt;services as $service) {            $sum += intval($service[&apos;weight&apos;]);        }        return $sum;    }    /**     * 设置当前有效权重     * @param integer $pos     * @param integer $weight     */    public function setCurrentWeight($pos, $weight)    {        $this-&gt;services[$pos][&apos;current_weight&apos;] = $weight;    }    /**     * 获取当前有效权重     *     * @param integer $pos     * @return integer     */    public function getCurrentWeight($pos)    {        return $this-&gt;services[$pos][&apos;current_weight&apos;];    }    /**     * 用配置权重调整当前有效权重     */    public function recoverCurrentWeight()    {        foreach ($this-&gt;services as $index =&gt; &amp;$service) {            $service[&apos;current_weight&apos;] += intval($service[&apos;weight&apos;]);        }    }}</code></pre><h5 id="调度算法接口服务"><a href="#调度算法接口服务" class="headerlink" title="调度算法接口服务"></a>调度算法接口服务</h5><pre><code>namespace Robin;interface RobinInterface{    /**     * 初始化服务权重     *     * @param array $services     */    public function init(array $services);    /**     * 获取一个服务     *     * @return string     */    public function next();}</code></pre><blockquote><p>加权轮询 算法虽然通过配置实例权重，解决了 简单轮询 的资源利用问题，但是它还是存在一个比较明显的 缺陷。<br>为了解决加权轮询调度不均匀的缺陷，一些人提出了 平滑加权轮询 调度算法，它会生成的更均匀的调度序列 {a, a, b, a, c, a, a}。对于神秘的平滑加权轮询算法，我将在后续文章中详细介绍它的原理和实现。</p></blockquote><h3 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h3><figure class="highlight plain"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require tinywan/load-balancing</span><br></pre></td></tr></table></figure><h3 id="Basic-Usage"><a href="#Basic-Usage" class="headerlink" title="Basic Usage"></a>Basic Usage</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器数</span></span><br><span class="line">$services = [</span><br><span class="line">    <span class="string">'192.168.10.1'</span> =&gt; <span class="number">6</span>,</span><br><span class="line">    <span class="string">'192.168.10.2'</span> =&gt; <span class="number">2</span>,</span><br><span class="line">    <span class="string">'192.168.10.3'</span> =&gt; <span class="number">1</span>,</span><br><span class="line">    <span class="string">'192.168.10.4'</span> =&gt; <span class="number">1</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"> ------------- <span class="number">1.</span>简单轮询 ------------- </span><br><span class="line"></span><br><span class="line">$robin = <span class="keyword">new</span> \Robin\Robin();</span><br><span class="line">$robin-&gt;init($services);</span><br><span class="line">$nodes = [];</span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= count($services); $i++) &#123;</span><br><span class="line">    $node = $robin-&gt;next();</span><br><span class="line">    $nodes[$i] = $node;</span><br><span class="line">&#125;</span><br><span class="line">var_export($nodes);</span><br><span class="line"></span><br><span class="line"> ------------- <span class="number">2.</span>加权轮询 ------------- </span><br><span class="line"></span><br><span class="line">$robin = <span class="keyword">new</span> \Robin\WeightedRobin();</span><br><span class="line">$robin-&gt;init($services);</span><br><span class="line"></span><br><span class="line">$nodes = [];</span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= <span class="number">10</span>; $i++) &#123;</span><br><span class="line">    $node = $robin-&gt;next();</span><br><span class="line">    $nodes[$i] = $node;</span><br><span class="line">&#125;</span><br><span class="line">var_export($nodes);</span><br><span class="line"></span><br><span class="line"> ------------- <span class="number">3.</span>平滑加权轮询 ------------- </span><br><span class="line"></span><br><span class="line">$robin = <span class="keyword">new</span> \Robin\SmoothWeightedRobin();</span><br><span class="line">$robin-&gt;init($services);</span><br><span class="line"></span><br><span class="line">$nodes = [];</span><br><span class="line">$sumWeight = $robin-&gt;getSumWeight();</span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= $sumWeight; $i++) &#123;</span><br><span class="line">    $node = $robin-&gt;next();</span><br><span class="line">    $nodes[$i] = $node;</span><br><span class="line">&#125;</span><br><span class="line">var_export($nodes);</span><br></pre></td></tr></table></figure><h3 id="Composer管理"><a href="#Composer管理" class="headerlink" title="Composer管理"></a>Composer管理</h3><p>安装提示错误：</p><p><code>Could not find package tinywan/load-polling in a version matching 1.0</code></p><p>尝试改成Packagist的地址 <a href="https://packagist.org" target="_blank" rel="noopener">https://packagist.org</a></p><figure class="highlight plain"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;repositories&quot;: &#123;</span><br><span class="line">    &quot;packagist&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;composer&quot;,</span><br><span class="line">        &quot;url&quot;: &quot;https://packagist.org&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>要使你发布的最新包可以使用，请使用以上的镜像源，为了学习</p></blockquote><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://github.com/fan-haobai/load-balance" target="_blank" rel="noopener">负载均衡算法</a>  </li><li><a href="https://www.fanhaobai.com/2018/11/load-balance-round-robin.html" target="_blank" rel="noopener">负载均衡算法 — 轮询</a>  </li><li><a href="https://www.fanhaobai.com/2018/11/load-balance-smooth-weighted-round-robin.html" target="_blank" rel="noopener">负载均衡算法 — 平滑加权轮询</a>  </li><li><a href="https://blog.csdn.net/zhangskd/article/details/50194069" target="_blank" rel="noopener">Nginx的负载均衡 - 加权轮询 (Weighted Round Robin) 上篇</a>  </li><li><a href="https://blog.csdn.net/zhangskd/article/details/50197929" target="_blank" rel="noopener">Nginx的负载均衡 - 加权轮询 (Weighted Round Robin) 下篇</a>  </li><li><a href="https://www.chenjie.info/1880" target="_blank" rel="noopener">Composer/Packagist包</a>  </li></ul>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入理解PHP——内存管理垃圾回收</title>
      <link href="/2017/07/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2017/07/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      <content type="html"><![CDATA[<h3 id="一、内存管理机制"><a href="#一、内存管理机制" class="headerlink" title="一、内存管理机制"></a>一、内存管理机制</h3><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>1） 操作系统直接管理着内存，所以操作系统也需要进行内存管理，计算机中通常都有内存管理单元(MMU) 用于处理CPU对内存的访问。</li><li>2） 应用程序无法直接调用物理内存， 只能向系统申请内存。<ul><li>向操作系统申请内存空间会引发系统调用。</li><li>系统调用会将CPU从用户态切换到内核。</li><li>为了减少系统调用开销。通常在用户态进行内存管理。 申请大块内存备用。使用完的内存不马上释放，将内存复用，避免多次内存申请和释放所带来性能消耗。</li></ul></li><li>3） PHP不需要显示内存管理，由Zend引擎进行管理。</li></ul><a id="more"></a><h3 id="PHP内存限制"><a href="#PHP内存限制" class="headerlink" title="PHP内存限制"></a>PHP内存限制</h3><ul><li>1）php.ini中的默认32MB<ul><li>memory_limit = 32M</li></ul></li><li>2）动态修改内存<ul><li>ini_set (“memory_limit”, “128M”)</li></ul></li><li>3）获取目前内存占用<ul><li>memory_get_usage()    : 获取PHP脚本所用的内存大小</li><li>memory_get_peak_usage() ：返回当前脚本到目前位置所占用的内存峰值。</li></ul></li></ul><p>先看一段代码：</p><pre><code>&lt;?php//内存管理机制var_dump(memory_get_usage());//获取内存方法，加上true返回实际内存，不加则返回表现内存$a = &quot;laruence&quot;;var_dump(memory_get_usage());unset($a);var_dump(memory_get_usage());//输出(在我的个人电脑上, 可能会因为系统,PHP版本,载入的扩展不同而不同)://int 240552//int 240720//int 240552</code></pre><p>定义变量之后，内存增加，清除变量之后，内存恢复（有些可能不会恢复和以前一样），好像定义变量时申请了一次内存，其实不是这样的，php会预先申请一块内存，不会每次定义变量就申请内存。</p><blockquote><p>首先我们要打破一个思维: PHP不像C语言那样, 只有你显示的调用内存分配相关API才会有内存的分配. 也就是说, 在PHP中, 有很多我们看不到的内存分配过程.</p></blockquote><p>比如对于:</p><pre><code>$a = &quot;laruence&quot;;</code></pre><h5 id="隐式的内存分配点就有"><a href="#隐式的内存分配点就有" class="headerlink" title="隐式的内存分配点就有:"></a>隐式的内存分配点就有:</h5><ul><li>1.1. 为变量名分配内存, 存入符号表</li><li>2.2. 为变量值分配内存</li></ul><p>所以, PHP的unset确实会释放内存, 但这个释放不是C编程意义上的释放, 不是交回给OS.<br>对于PHP来说, 它自身提供了一套和C语言对内存分配相似的内存管理API:　</p><pre><code>emalloc(size_t size);efree(void *ptr);ecalloc(size_t nmemb, size_t size);erealloc(void *ptr, size_t size);estrdup(const char *s);estrndup(const char *s, unsigned int length);</code></pre><blockquote><p>这些API和C的API意义对应, 在PHP内部都是通过这些API来管理内存的.</p></blockquote><p>当我们调用emalloc申请内存的时候, PHP并不是简单的向OS要内存, 而是会像OS要一个大块的内存, 然后把其中的一块分配给申请者, 这样当再有逻辑来申请内存的时候, 就不再需要向OS申请内存了, 避免了频繁的系统调用.</p><p>比如如下的例子:</p><pre><code>var_dump(memory_get_usage(true));//注意获取的是real_size$a = &quot;laruence&quot;;var_dump(memory_get_usage(true));unset($a);var_dump(memory_get_usage(true));//输出//int 262144//int 262144//int 262144</code></pre><p>也就是我们在定义变量$a的时候, PHP并没有向系统申请新内存.同样的, 在我们调用efree释放内存的时候, PHP也不会把内存还给OS, 而会把这块内存, 归入自己维护的空闲内存列表. </p><p>对于小块内存来说, 更可能的是, 把它放到内存缓存列表中去(后记, 某些版本的PHP, 比如我验证过的PHP5.2.4, 5.2.6, 5.2.8, 在调用get_memory_usage()的时候, 不会减去内存缓存列表中的可用内存块大小, 导致看起来, unset以后内存不变).</p><p>$a = “hello”;</p><h5 id="定义变量时，存储两个方面："><a href="#定义变量时，存储两个方面：" class="headerlink" title="定义变量时，存储两个方面："></a>定义变量时，存储两个方面：</h5><ol><li>变量名，存储在符号表</li><li>变量值存储在内存空间</li><li>在删除变量的时候，会将变量值存储的空间释放，而变量名所在的符号表不会减小（只增不减）</li></ol><h4 id="只增不减的数组"><a href="#只增不减的数组" class="headerlink" title="只增不减的数组"></a>只增不减的数组</h4><p>Hashtable是PHP的核心结构, 数组也是用她来表示的, 而符号表也是一种关联数组, 对于如下代码:</p><pre><code>var_dump(memory_get_usage());for($i=0;$i&lt;100;$i++){$a = &quot;test&quot;.$i;$$a = &quot;hello&quot;;    }var_dump(memory_get_usage());for($i=0;$i&lt;100;$i++){$a = &quot;test&quot;.$i;unset($$a);    }var_dump(memory_get_usage());</code></pre><p>我们定义了100个变量, 然后又按个Unset了他们, 来看看输出:</p><pre><code>//int 242104//int 259768//int 242920</code></pre><p>Wow, 怎么少了这么多内存?<br>这是因为对于Hashtable来说, 定义它的时候, 不可能一次性分配足够多的内存块, 来保存未知个数的元素, 所以PHP会在初始化的时候, 只是分配一小部分内存块给HashTable, 当不够用的时候再RESIZE扩容。</p><p>Hashtable, 只能扩容, 不会减少, 对于上面的例子, 当我们存入100个变量的时候, 符号表不够用了, 做了一次扩容, 而当我们依次unset掉这100个变量以后, 变量占用的内存是释放了(118848 – 104448), 但是符号表并没有缩小, 所以这些少的内存是被符号表本身占去了…</p><h3 id="二、垃圾回收机制"><a href="#二、垃圾回收机制" class="headerlink" title="二、垃圾回收机制"></a>二、垃圾回收机制</h3><p>PHP变量存储在一个zval容器里面的</p><ul><li><ol><li>变量类型 </li></ol></li><li><ol start="2"><li>变量值 </li></ol></li><li><ol start="3"><li>is_ref 代表是否有地址引用 </li></ol></li><li><ol start="4"><li>refcount 指向该值的变量数量</li></ol></li></ul><p>变量赋值的时候：is_ref为false， refcount为1</p><pre><code>$a = 1;xdebug_debug_zval(&apos;a&apos;);echo PHP_EOL;//换行符，提高代码的源代码级可移植性</code></pre><p>输出：</p><pre><code>a:(refcount=1, is_ref=0),int1</code></pre><p>将变量a的值赋给变量b，变量b不会立刻去在内存中存储值，而是先指向变量a的值，一直到变量a有任何操作的时候</p><pre><code>$b = $a;xdebug_debug_zval(&apos;a&apos;);echo PHP_EOL;</code></pre><p>输出：</p><pre><code>a:(refcount=2, is_ref=0),int1</code></pre><h6 id="再来看一个"><a href="#再来看一个" class="headerlink" title="再来看一个"></a>再来看一个</h6><pre><code>$c = &amp;$a;xdebug_debug_zval(&apos;a&apos;);echo PHP_EOL;xdebug_debug_zval(&apos;b&apos;);echo PHP_EOL;</code></pre><p>输出：</p><pre><code>a:(refcount=2, is_ref=1),int1b:(refcount=1, is_ref=0),int1</code></pre><p>因为程序又操作了变量a，所以变量b会自己申请一块内存将值放进去。<br>所以变量a的zval容器中refcount会减1变为1，变量c指向a，所以refcount会加1变为2，is_ref变为true</p><h5 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h5><ol><li>在5.2版本或之前版本，PHP会根据refcount值来判断是不是垃圾</li></ol><ul><li>如果refcount值为0，PHP会当做垃圾释放掉</li><li>这种回收机制有缺陷，对于环状引用的变量无法回收</li></ul><h6 id="环状引用："><a href="#环状引用：" class="headerlink" title="环状引用："></a>环状引用：</h6><pre><code>$attr = array(&quot;hello&quot;);$attr[]= &amp;$attr;xdebug_debug_zval(&apos;attr&apos;);echo PHP_EOL;</code></pre><p>输出：</p><pre><code>attr:(refcount=2, is_ref=1),array (size=2)0 =&gt; (refcount=1, is_ref=0),string&apos;hello&apos; (length=5)1 =&gt; (refcount=2, is_ref=1),&amp;array</code></pre><p>2.在5.3之后版本改进了垃圾回收机制</p><ul><li>如果发现一个zval容器中的refcount在增加，说明不是垃圾</li><li>如果发现一个zval容器中的refcount在减少，如果减到了0，直接当做垃圾回收</li><li>如果发现一个zval容器中的refcount在减少，并没有减到0，PHP会把该值放到缓冲区，当做有可能是垃圾的怀疑对象</li><li>当缓冲区达到临界值，PHP会自动调用一个方法取遍历每一个值，如果发现是垃圾就清理</li></ul>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 内存管理 </tag>
            
            <tag> 垃圾回收 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2017@Swift——后感</title>
      <link href="/2017/05/15/2017-Swift%E2%80%94%E2%80%94%E5%90%8E%E6%84%9F/"/>
      <url>/2017/05/15/2017-Swift%E2%80%94%E2%80%94%E5%90%8E%E6%84%9F/</url>
      <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftHome001.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><p>2017@Swift——中国开发者大会（第二站）</p><pre><code>会议时间：2017年5月13日-5月14日，地址：深圳凯宾斯基酒店，人数：400人嘉宾：18人，其中8位国外，8位国内。</code></pre><blockquote><p>第一天所有外国嘉宾的演讲时间，第二天是国内大牛的演讲时间！</p></blockquote><a id="more"></a><p>记得第一站是去年在北京举行，当时项目太赶，就没有去，今年有幸能参加此次大会，并且收获真心不少。因此这里稍微整理了一下这两天最大的感触，和所学到的东西！</p><blockquote><p>当然关于技术的分享，后期会有专门的文章与结合简单的实战整理一并分享出来，敬请期待…….</p></blockquote><p>更多信息请点<a href="http://www.bagevent.com/event/378252" target="_blank" rel="noopener">2017@Swift——中国开发者大会</a>,同时后面也会抽空整理一下会议中讲到的内容，底层，细节与实现，敬请期待！</p><h2 id="2017-Swift——后感"><a href="#2017-Swift——后感" class="headerlink" title="2017@Swift——后感"></a>2017@Swift——后感</h2><blockquote><p>这种收获真不是一两句话或者一两篇文章就能说清楚的，如果你有事吗疑问或者想了解先关内容也可以直接关注我，联系我！</p></blockquote><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftHome002.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><p>第二届 @Swift 中国开发者大会</p><ol><li>英语能力</li><li>交友</li><li>技术</li></ol><h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><p>为什么这里我把英语能力放在最前面，肯定是有原因的。</p><pre><code>1. 开会第一天所有都是老外，所有人都直接用英语讲，几乎听不太懂，所以导致很多东西根本没有听到重点与细节2. 会后交流，与提问，人家都能听懂，甚至都能提出自己的问题与观点，甚至还能通嘉宾进行更多更加升入的交流与讨论，而我却只能翻译或者发呆3. 技术的学习，几乎所有的最好，最新的技术资料都是从英文开始的，当你开始看中文翻译资料或者开始研究的时候，人家已经换了一种技术4. 后期的规划问题，出国旅游，出国发展（有点长远，当然也不是没有可能的），或者有机会接触外国朋友。</code></pre><p>总结：针对程序员，哪怕只有一点基础的，技术这种东西都可以慢慢学，或者在实际项目中提高，如果你英文不好很多事情真的很难进行下去，除非你没有什么长远的目标或者没有自己个人的规划。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftHome003.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftHome004.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h2 id="交友"><a href="#交友" class="headerlink" title="交友"></a>交友</h2><p>经过这次会议之后，看到了很多牛人，也认识了不少牛人之后才知道自己的渺小，才知道自己原来离期望中太远太远。</p><pre><code>1. 最有名的Swift框架RXSwift的作者2. Google工程师3. 腾讯，美团，礼物说，阿里等一些非常厉害的架构师，同时也是技术迷4. 不少技术书籍的作者，其中有一位是我非常喜欢的巧哥@唐巧5. 不同公司的技术主管，开发人员，初入门的程序员6. 两天的会议中认识到了不少来自去全国各地参会者，也结下了不少好友！</code></pre><p>总结：永远不要觉得自己多牛逼，当你真的看到牛人之后你就会发现，其实自己真的很low，哪怕你做过再多项目，写过再多代码，不思考，不提升依然是个菜鸟。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftHome005.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftHome006.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftHome007.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><pre><code>1. 主题就是Swift：iOS，后台肯定是重心2. Swift实现AI，智能，机器学习，树莓派的结合，后期的转行。3. 实现属于自己的东西，小的方向比如小框架，静态或者动态库，大的话其中有人自己写了一个Swift转H5的编译器4. App性能的提升，多线程，锁，MVVM, 自动化（测试，脚本）5. 包括开发，集成，测试，发布，维护需要有一套完成的规范与流程。</code></pre><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftHome008.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftHome009.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><p>总之，程序员是一个需要时刻保持学习的职业，不学你就将被淘汰，不管学习技术，管理，社交，英语或者学习别人成功或失败的经验</p><p>未来的路还很长，希望一路上的坎坷能让我足够强大。</p><p>说说我接下来的规划（我只谈短期1-2年）：</p><pre><code>1. 学习英语，不管是自学还是报班这都是现阶段最最最重要的任务,同时也会长期的坚持下去。2. 着手Swift进行项目实战，对PHP实战后台开发进一步的提升，同时去了解Swift实现后台开发3. iOS深挖：深入解析Max OS X &amp; iOS操作系统4. 学习Python，了解机器学习等技术</code></pre><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftHome010.JPG" alt="曹理鹏(iCocos)-梦工厂"></p>]]></content>
      
      <categories>
          
          <category> 2017@Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 2017@Swift——后感 </tag>
            
            <tag> 大会后感 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2017@Swift——中国开发者大会（第二天）</title>
      <link href="/2017/05/15/2017-Swift%E2%80%94%E2%80%94%E4%B8%AD%E5%9B%BD%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%A4%A9%EF%BC%89/"/>
      <url>/2017/05/15/2017-Swift%E2%80%94%E2%80%94%E4%B8%AD%E5%9B%BD%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%A4%A9%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>首先介绍一下会议信息</p><pre><code>会议时间：2017年5月13日-5月14日，地址：深圳凯宾斯基酒店，人数：400人嘉宾：18人，其中8位国外，8位国内。</code></pre><blockquote><p>第一天所有外国嘉宾的演讲时间，第二天是国内大牛的演讲时间！</p></blockquote><a id="more"></a><p>更多信息请点<a href="http://www.bagevent.com/event/378252" target="_blank" rel="noopener">2017@Swift——中国开发者大会</a>,同时后面也会抽空整理一下会议中讲到的内容，底层，细节与实现，敬请期待！</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftMain000.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftMain001.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><p>=============================================================================</p><h2 id="唐巧（小猿搜题产品技术负责人）"><a href="#唐巧（小猿搜题产品技术负责人）" class="headerlink" title="唐巧（小猿搜题产品技术负责人）"></a>唐巧（小猿搜题产品技术负责人）</h2><p>Richards 和 Deltablue 是衡量语言运算速度的两个主流的评测代码。Swift 在这两个评测中，显示出远超 Objective-C 的性能。特别是 Richards 评测，Swift 比 Objective-C 快了 4 倍。那么，为什么 Swift 这么快呢？本次分享，我将从编译器优化，内存分配优化，引用计数优化，方法调用优化，面向协议编程的实现细节等方面来介绍 Swift 在性能上所做的努力。如果可能，我们也会一起看看编译器处理后的源码，加深我们对于这些优化的理解。</p><p>小猿搜题产品技术负责人，资深 iOS 开发者，曾开发过网易邮箱、网易微博、有道云笔记、猿题库、小猿搜题。喜欢写作和分享，维护着中国关注者最多的iOS领域的微信公众号「iOS开发by唐巧」，产出了超过 100 篇原创的 iOS 技术文章，出版了一本 iOS 进阶读物《iOS开发进阶》。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift100.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift101.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="Swift-为什么这么快"><a href="#Swift-为什么这么快" class="headerlink" title="Swift 为什么这么快"></a>Swift 为什么这么快</h3><pre><code>1. 第二天中，唯一一个使用英文演讲的国内大牛，挑战自我。2. 从不同方便说明为什么swift比OC好：引用数，struct的内存布局，性能优化，编译器、内存、消息转发机制、引用数和protocol。 </code></pre><p>=============================================================================</p><h2 id="戴铭（滴滴出行技术专家）"><a href="#戴铭（滴滴出行技术专家）" class="headerlink" title="戴铭（滴滴出行技术专家）"></a>戴铭（滴滴出行技术专家）</h2><blockquote><p>github.com/ming1016</p></blockquote><p>结合实例介绍如何用 LLVM IR 中间语言和编译前端的语法解析来设计一门简洁易用支持多平台的 DSL 语言，从而提高开发效率。介绍如何使用 Swift 开发一个类似 Clang 并且支持插件的简版编译前端，从而优化代码，提高工程质量。此外还会简单介绍一些有趣的实践。</p><p>微博@戴铭。滴滴出行技术专家，技术上主要负责滴滴出行 iOS 相关的开发工作。时常会将对新技术的深入研究和工作的经验总结发在微博上。对 ReactiveCocoa，RxSwift，软件架构，性能优化和算法有着浓厚的兴趣。最近正在研究iOS编译相关底层技术，用来解决工程优化问题，到时会将成果分享出来。 </p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift200.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift201.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="学习-iOS-编译原理能做哪些有意思的事情"><a href="#学习-iOS-编译原理能做哪些有意思的事情" class="headerlink" title="学习 iOS 编译原理能做哪些有意思的事情"></a>学习 iOS 编译原理能做哪些有意思的事情</h3><pre><code>1. 这哥们可谓是有着一双被编程耽误了的画手，不但主题，技术吸引人，所画出来的作品更是让人回味。2. 先讲了一个关于flexbox布局的web代码，自己使用swift写了一个解析器。3. 结合上面的实现个性化的讲解了一下编译器前后端，及编译的整个过程</code></pre><p>=============================================================================</p><h2 id="柯灵杰（腾讯公司iOS开发）"><a href="#柯灵杰（腾讯公司iOS开发）" class="headerlink" title="柯灵杰（腾讯公司iOS开发）"></a>柯灵杰（腾讯公司iOS开发）</h2><p>图片组件可以说是app开发中使用最多的组件之一，它既简单也不简单，如何设计和开发一个具有高扩展性，高性能的图片组件呢？本次分享将会从架构设计到性能优化等多方面，全面解析一个优秀图片组件的设计和开发原理，以及在性能优化和架构设计方面的一些经验和探索。</p><p>柯灵杰（lingtonke），腾讯公司 iOS 开发。腾讯学院认证讲师，主要讲授课程《设计模式》。曾参加过 QQ、QZone、微云、企鹅 MV、闪咖等的开发。他主导开发的图片组件，在腾讯内被多个项目使用，获得公司内多项优秀组件奖，目前已着手对业内开源。同时他还是数项技术发明专利的发明人，曾参加过程序员 LiveShow《有码的开发哥无码的直播》。目前是腾讯 QZone 团队 iOS 开发。 </p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift300.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift301.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="打造易扩展的高性能图片组件"><a href="#打造易扩展的高性能图片组件" class="headerlink" title="打造易扩展的高性能图片组件"></a>打造易扩展的高性能图片组件</h3><pre><code>1. 如何设计高性能易拓展的图片组件，一步一步的优化。2. 综合分析的不同框架，不同实现方案，不同技术的优缺点。3. 当时我会中问到是否开源，回答是会，并且预计年底会开源。</code></pre><p>=============================================================================</p><h2 id="王文槿（UC资深开发工程师）"><a href="#王文槿（UC资深开发工程师）" class="headerlink" title="王文槿（UC资深开发工程师）"></a>王文槿（UC资深开发工程师）</h2><p>来自 UC 浏览器的 iPhone 组，参与了 UC 浏览器，UC 头条和夸克浏览器相关产品的开发，工作中主要使用 OC 和 Weex 。不过业余是不折不扣的 Swift 爱好者，自诩 Swift 的函数式编程的布道师。曾经先后通过文章&amp;演讲的形式分享了 Swift 异步串行/并行编程以及函数式的设计模式等话题。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift400.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift401.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="一个轻量级-FRP-框架的诞生记"><a href="#一个轻量级-FRP-框架的诞生记" class="headerlink" title="一个轻量级 FRP 框架的诞生记"></a>一个轻量级 FRP 框架的诞生记</h3><pre><code>1. 之前UC面试过一次，可惜挂了2. 主要结合实际以一个很简单的Demo演示了MVVM，并且很清晰的解答了众多为止疑惑的参会者。</code></pre><p>=============================================================================</p><h2 id="赵恩生（美团点评高级工程师）"><a href="#赵恩生（美团点评高级工程师）" class="headerlink" title="赵恩生（美团点评高级工程师）"></a>赵恩生（美团点评高级工程师）</h2><p>随着业务拆分和组件化的完成，美团 iOS 客户端在集成和交付的道路上越发艰难。在业务代码下放后，如何能保证客户端的安全稳定；面对千万用户，如何能快速优雅地组建并交付一个完整的客户端，这一切的一切都值得思考和深究。</p><p>希望通过本次分享，和各位一起探讨如何玩转大业务体量下的众多组件、如何搭建整个客户端的发布流程。</p><p>美团点评高级工程师，曾维护美团 iOS 客户端，现负责 iOS 发布流程相关工作，专业打杂，通过对复杂业务下组件发布集成的踩坑总结，对 CI CD 有一定的认识和理解。闲暇时喜欢捣鼓乱七八糟的东西，自学习得包括疏通下水道，手机贴膜，设备维修在内的一些奇怪技能。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift500.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift501.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="组件-组建-美团-iOS-客户端"><a href="#组件-组建-美团-iOS-客户端" class="headerlink" title="组件 + 组建 = 美团 iOS 客户端"></a>组件 + 组建 = 美团 iOS 客户端</h3><pre><code>1. 美团开发，集成，打包，测试，发布整个流程的工作与注意点。2. 组件式的开发方式，规范性的流程与测试形成一个闭环3. 校验，避错，后期的修复的考虑及解决方案4. CI的基本流程介绍</code></pre><p>=============================================================================</p><h2 id="傅若愚（ThoughtWorks-高级咨询师）"><a href="#傅若愚（ThoughtWorks-高级咨询师）" class="headerlink" title="傅若愚（ThoughtWorks 高级咨询师）"></a>傅若愚（ThoughtWorks 高级咨询师）</h2><p>是的，你一定听说过 Metal，或者你还写过一些 Metal 的 Shader。不过，说实话，喝了两杯啤酒之后，面对 Xcode，我们能做点儿更有趣的东西么？要不要来试试？</p><p>来自 ThoughtWorks，刚睡醒的移动开发者，喝高了的 Tech Lead，SwiftyJSON 的作者（但这家伙已经弃坑……Oh，别担心，其他人还在维护）。业余喜读书，文史哲无所禁忌，爱美食与啤酒（最近爱上了 American Pale Ale），今年大概 17 岁的样子。 </p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift600.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift601.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="一些跟-Metal-有关系，肯定有趣但多半没用的东西"><a href="#一些跟-Metal-有关系，肯定有趣但多半没用的东西" class="headerlink" title="一些跟 Metal 有关系，肯定有趣但多半没用的东西"></a>一些跟 Metal 有关系，肯定有趣但多半没用的东西</h3><pre><code>1. 主要是机器学习，高逼格式的讲解了神经网络2. 输入图片，视频染色然后渲染并输出对应的效果。3. 主要是一些基础的概念，理论知识。</code></pre><p>=============================================================================</p><h2 id="尹航（Google-工程师）"><a href="#尹航（Google-工程师）" class="headerlink" title="尹航（Google 工程师）"></a>尹航（Google 工程师）</h2><p>深度学习总是让人联想到成吨的数据、笨重的服务器。但在移动端，我们能不能利用深度学习做一点有趣的事情呢？本次分享，让我们看看如何在iOS上运行起工业级的深度学习框架TensorFlow吧。</p><p>一个技能树歪掉的开发者。iOS 首个游戏辅助“叉叉助手”作者，也曾经编写《Cocos2d-x高级开发教程》，目前兴趣有移动安全和机器学习，Google 工程师，从事 Gmail 语义理解相关开发。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift700.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift701.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="TensorFlow-iOS-❤️-造一个颜文字输入法"><a href="#TensorFlow-iOS-❤️-造一个颜文字输入法" class="headerlink" title="TensorFlow+iOS=❤️: 造一个颜文字输入法"></a>TensorFlow+iOS=❤️: 造一个颜文字输入法</h3><pre><code>1. 机器学习，实战了一个emoji表情的输出。2. 介绍了TensorFlow，介绍了他的一些特性与简单的应用</code></pre><p>=============================================================================</p><h2 id="唐晓轩（礼物说联合创始人）"><a href="#唐晓轩（礼物说联合创始人）" class="headerlink" title="唐晓轩（礼物说联合创始人）"></a>唐晓轩（礼物说联合创始人）</h2><p>Live Coding</p><p>礼物说联合创始人，全栈打杂工程师，公众号糖炒小虾，热衷于折腾各种黑技术。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift800.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift801.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="当-Swift-遇上树莓派"><a href="#当-Swift-遇上树莓派" class="headerlink" title="当 Swift 遇上树莓派"></a>当 Swift 遇上树莓派</h3><pre><code>1. swift和树莓派之间的交互。2. Swift+ARM，展示了一个watch跑的超级玛丽。3. 展示数个小Demo，演示怎么与实际相结合，并提到为了对小米设备的实际应用</code></pre><p>=============================================================================</p><h2 id="第二天尾声…"><a href="#第二天尾声…" class="headerlink" title="第二天尾声…"></a>第二天尾声…</h2><p>到此整个会议已经全部结束，这一天在技术，底层，架构等方面收获就完全不一样了，同时后期会有文章介绍相关内容！</p><p>随后，大家都纷纷离开准备回家或者会工作的城市！</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftMain002.JPG" alt="曹理鹏(iCocos)-梦工厂"> </p>]]></content>
      
      <categories>
          
          <category> 2017@Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 大会 </tag>
            
            <tag> 2017@Swift——中国开发者大会（第二天） </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2017@Swift——中国开发者大会（第一天）</title>
      <link href="/2017/05/15/2017-Swift%E2%80%94%E2%80%94%E4%B8%AD%E5%9B%BD%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A%EF%BC%88%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%89/"/>
      <url>/2017/05/15/2017-Swift%E2%80%94%E2%80%94%E4%B8%AD%E5%9B%BD%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A%EF%BC%88%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>首先介绍一下会议信息</p><pre><code>会议时间：2017年5月13日-5月14日，地址：深圳凯宾斯基酒店，人数：400人嘉宾：18人，其中8位国外，8位国内。</code></pre><blockquote><p>第一天所有外国嘉宾的演讲时间，第二天是国内大牛的演讲时间！</p></blockquote><a id="more"></a><p>更多信息请点<a href="http://www.bagevent.com/event/378252" target="_blank" rel="noopener">2017@Swift——中国开发者大会</a>,同时后面也会抽空整理一下会议中讲到的内容，底层，细节与实现，敬请期待！</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftMain000.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftMain001.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><p>=================================================================================================================================</p><h2 id="Tuomas-Artman（Uber-移动架构和框架组负责人）"><a href="#Tuomas-Artman（Uber-移动架构和框架组负责人）" class="headerlink" title="Tuomas Artman（Uber 移动架构和框架组负责人）"></a>Tuomas Artman（Uber 移动架构和框架组负责人）</h2><p>Uber 使用 Swift 重写了 app，在这个分享中，Tuomas 会介绍如何在上百人的团队中使用 Swift 进行开发，并介绍 Uber 重写过程中遇到的各种问题和解决方法。<br>Tuomas 是 Uber 移动架构和框架组的负责人。在来湾区之前，他创立了一家芬兰知名的数字资讯公司，还在上海的一家公司工作过一年，开发游戏和多用户技术平台。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift100.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift101.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="Swift-with-hundreds-of-engineers"><a href="#Swift-with-hundreds-of-engineers" class="headerlink" title="Swift with hundreds of engineers"></a>Swift with hundreds of engineers</h3><pre><code>1. 使用swift重构Uber的过程中good，bad，ugly。 2. 对架构重新设计了，并且将他成为router-&gt;interaction-&gt;builder简称RIBs。适用于Android和iOS双平台。3. 重构后Uber的崩溃率降到了0.01%，这确实是一个非常理想的数据。4. binary size关于Uber包的大小。5. 关于如何缩短Uber的编译时间6. 最后聊了一下unit test。﻿</code></pre><p>=================================================================================================================================</p><h2 id="Sam-Davies（RayWenderlich-CTO）"><a href="#Sam-Davies（RayWenderlich-CTO）" class="headerlink" title="Sam Davies（RayWenderlich CTO）"></a>Sam Davies（RayWenderlich CTO）</h2><p>从基础的 NSOperation 一直到 Grand Central Dispatch，彻底讲明白 iOS 并发。此外还会涉及一些高级内容，比如 dispatch group 和线程安全。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift200.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift201.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="Concurrency-on-iOS"><a href="#Concurrency-on-iOS" class="headerlink" title="Concurrency on iOS"></a>Concurrency on iOS</h3><pre><code>1. 异步并发。2. 提出了开发中经常遇到的一些问题和解决方案3. 提到了反转优先级 </code></pre><p>=================================================================================================================================</p><h2 id="Igor-Jerkovic（前-Facebook-资深开发者）"><a href="#Igor-Jerkovic（前-Facebook-资深开发者）" class="headerlink" title="Igor Jerkovic（前 Facebook 资深开发者）"></a>Igor Jerkovic（前 Facebook 资深开发者）</h2><p>Igor 在 Facebook 的视频团队工作了五年，非常熟悉国外大公司的那一套理论。他会在这次分享中介绍如何提高开发效率和代码质量。</p><p>我很喜欢编程，也喜欢学习新东西，尝试不同的方法。2011-2013 年我在 Facebook 实习，负责开发 iOS 项目。2014 年我正式加入 Facebook，一直在视频团队工作到 2016年。现在我在 Bellabeat 工作，这是一家和健康相关的创业公司，在旧金山、深圳和萨格勒布都有办公室。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift300.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift301.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="iOS-development-efficiency-at-Facebook"><a href="#iOS-development-efficiency-at-Facebook" class="headerlink" title="iOS development efficiency at Facebook"></a>iOS development efficiency at Facebook</h3><pre><code>1. Facebook的开发流程，包括各种开发中的规范2. 介绍了很多实用的工具Buck...</code></pre><p>=================================================================================================================================</p><h2 id="Sommer-Panage（Chorus-Fitness-核心-iOS）"><a href="#Sommer-Panage（Chorus-Fitness-核心-iOS）" class="headerlink" title="Sommer Panage（Chorus Fitness 核心 iOS）"></a>Sommer Panage（Chorus Fitness 核心 iOS）</h2><p>在这个分享中，我会介绍无障碍和 VoiceOver。首先说明为什么无障碍支持很重要，然后通过一个权威的 iOS 应用了解你可以实现哪些无障碍功能。接着我会介绍 iOS 无障碍 API 以及如何对接 VoiceOver。最后，我会补充一些有趣的无障碍知识，除了支持 VoiceOver，我们还能做得更好。</p><p>Sommer Panage 目前是 Chorus Fitness 的核心 iOS 开发。在这之前，她做了两年 iOS freelancer，与此同时她还成为了一名马戏表演者和教练。更早的时候，她在 Twitter 和 Apple 的无障碍团队工作。Sommer 对心理学和计算机科学两个领域都有涉猎。在编写代码之余，她还会做绳索训练、高空秋千、倒立、跑步和抱石。你可以在 Twitter 上关注她，@sommer。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift400.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift401.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="From-Zero-to-Hero-Making-your-iOS-App-Accessible-to-VoiceOver-and-Beyond"><a href="#From-Zero-to-Hero-Making-your-iOS-App-Accessible-to-VoiceOver-and-Beyond" class="headerlink" title="From Zero to Hero: Making your iOS App Accessible to VoiceOver and Beyond"></a>From Zero to Hero: Making your iOS App Accessible to VoiceOver and Beyond</h3><pre><code>1. 主要是无障碍应用开发2. 讲了iOS中的accessibility programing，并演示了对失明者的交互与使用。3. 通过code演示了一些使用方式</code></pre><p>=================================================================================================================================</p><h2 id="Krunoslav-Zaher（RxSwift-框架作者）"><a href="#Krunoslav-Zaher（RxSwift-框架作者）" class="headerlink" title="Krunoslav Zaher（RxSwift 框架作者）"></a>Krunoslav Zaher（RxSwift 框架作者）</h2><p>我会介绍开发 Rx 的初衷、我对 Rx 的看法、Rx 的特点以及 Rx 和传统编程方式的区别。我还会介绍 Rx 的性能、不同设计模式的实现方式以及如何关联 Rx 和状态机。</p><p>在行业内摸爬滚打了 16 年。做过很多东西，增强现实引擎、BPM 系统、手机应用、机器人……最近在研究函数式编程和链式编程。白天我会帮准妈妈们听婴儿的心跳，晚上我会哄自己的宝贝女儿睡觉。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift500.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift501.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="Thinking-in-Rx-way"><a href="#Thinking-in-Rx-way" class="headerlink" title="Thinking in Rx way"></a>Thinking in Rx way</h3><pre><code>1. 主要是对rx的用法介绍。2. 提到了他写RX的初衷</code></pre><p>﻿</p><p>=================================================================================================================================</p><h2 id="Marius-Rackwitz（CocoaPods、Realm-核心开发者）"><a href="#Marius-Rackwitz（CocoaPods、Realm-核心开发者）" class="headerlink" title="Marius Rackwitz（CocoaPods、Realm 核心开发者）"></a>Marius Rackwitz（CocoaPods、Realm 核心开发者）</h2><p>Marius 从大学毕业开始就从事移动端和 web 应用开发。最近他开始专注移动端开发，尤其是 iOS 和 Objective-C，以及后起之秀 Swift。当然，作为 CocoaPods 核心成员，他也没有抛弃 Ruby。加入 Realm 之后，他在社区中更加活跃，参与了很多大会。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift600.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift601.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="JavaScript-for-Swift-Developer"><a href="#JavaScript-for-Swift-Developer" class="headerlink" title="JavaScript for Swift Developer"></a>JavaScript for Swift Developer</h3><pre><code>1. 这哥们整个演讲的过程中很是激情，但是却让在场大部分参会者归为叛徒的了（哈哈，开个玩笑）。2. JavaScript for Swift Developer主要是两者之间的不同。 </code></pre><p>=================================================================================================================================</p><h2 id="Kyle-Jessup（Perfect-框架作者，CTO）"><a href="#Kyle-Jessup（Perfect-框架作者，CTO）" class="headerlink" title="Kyle Jessup（Perfect 框架作者，CTO）"></a>Kyle Jessup（Perfect 框架作者，CTO）</h2><p>Perfect 作者，Lasso 编程语言（被苹果的子公司 Claris 收购）的服务端核心开发者。Kyle 自学能力很强，对 Swift、Java 和 C++ 都有深入了解。 小时候，Kyle 的父亲——一名曾在美国海军潜艇上服役的核工程师——送给他一台雅达利 800 个人电脑。从那时起，他就对技术产生兴趣，一直延续到现在。 Kyle 在德克萨斯的达拉斯出生，2015 年搬到加拿大，加入 PerfectlySoft 团队。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift700.JPG" alt="曹理鹏(iCocos)-梦工厂"> </p><h3 id="Swift作为后端开发相关"><a href="#Swift作为后端开发相关" class="headerlink" title="Swift作为后端开发相关"></a>Swift作为后端开发相关</h3><pre><code>1. 演示并分享了Swift实现后端开发的利弊2. 介绍了了Perfect ﻿</code></pre><p>=================================================================================================================================</p><h2 id="Saul-Mora（流利说-iOS-工程师，MagicalRecord-作者）"><a href="#Saul-Mora（流利说-iOS-工程师，MagicalRecord-作者）" class="headerlink" title="Saul Mora（流利说 iOS 工程师，MagicalRecord 作者）"></a>Saul Mora（流利说 iOS 工程师，MagicalRecord 作者）</h2><p>从上古时代开始接触 iOS，熟悉手动内存管理、编译器宏、pthread 和 头文件。Saul Mora 为了表达对编程前辈的尊重，在 Swift 中使用带可选变量的 Nib 编写 UI。掌握了 Objective C 之后，Saul 开始环游世界，进行历练。为了应对前方的算法挑战，Saul 积极拥抱 Swift。最近，Saul 生活在现代中国的核心城市——上海。他在流利说寺修行，开发这款优秀的 app，帮助中国用户学习英语。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift800.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift801.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="Building-Confidence-Testing-iOS-applications"><a href="#Building-Confidence-Testing-iOS-applications" class="headerlink" title="Building Confidence: Testing iOS applications"></a>Building Confidence: Testing iOS applications</h3><pre><code>1. 以一个很滑稽很有乔布斯风格的开场吸引住了在场的参会者2. 分析并深入讲解了测试的重要性和原则</code></pre><p>=============================================================================</p><h2 id="第一天尾声…"><a href="#第一天尾声…" class="headerlink" title="第一天尾声…"></a>第一天尾声…</h2><p>第一天的会议也就这样结束了，整个会议中大家谈论最多的问题就是关于英语的能力，这个后面会有相关的文章详细说明！</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftMain002.JPG" alt="曹理鹏(iCocos)-梦工厂"> </p>]]></content>
      
      <categories>
          
          <category> 2017@Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2017@Swift——中国开发者大会（第一天） </tag>
            
            <tag> Swift </tag>
            
            <tag> 大会 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于事务入门</title>
      <link href="/2017/02/19/%E5%85%B3%E4%BA%8E%E4%BA%8B%E5%8A%A1%E5%85%A5%E9%97%A8/"/>
      <url>/2017/02/19/%E5%85%B3%E4%BA%8E%E4%BA%8B%E5%8A%A1%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h3 id="一、事务的属性ACID"><a href="#一、事务的属性ACID" class="headerlink" title="一、事务的属性ACID"></a>一、事务的属性ACID</h3><ol><li>原子性(atomicity):事务是一个原子操作单元，要么全部执行，要么全部都不执行</li><li>一致性(consistent): 在事务开始和完成时，数据都必须保持一致性。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。</li><li>隔离性(lsolation): 数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的独立环境执行。这意味着事务处理过程中的中间状态对外部是不可见的。</li><li>持久性(Durable): 事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</li></ol><a id="more"></a><p>###二、并发事务带来的问题</p><h5 id="1-更新丢失"><a href="#1-更新丢失" class="headerlink" title="1.更新丢失"></a>1.更新丢失</h5><p>当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题－－最后的更新覆盖了由其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖另一个编辑人员所做的更改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题。</p><h5 id="2-脏读"><a href="#2-脏读" class="headerlink" title="2.脏读"></a>2.脏读</h5><p>一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做”脏读”。</p><h5 id="3-不可重复读"><a href="#3-不可重复读" class="headerlink" title="3.不可重复读"></a>3.不可重复读</h5><p>不可重复读（Non-Repeatable Reads）：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。</p><h5 id="4-幻读"><a href="#4-幻读" class="headerlink" title="4.幻读"></a>4.幻读</h5><p>一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。</p><p>###三、事务的隔离级别</p><h5 id="1-读取未提交的内容-Read-Uncommitted"><a href="#1-读取未提交的内容-Read-Uncommitted" class="headerlink" title="1.读取未提交的内容(Read Uncommitted)"></a>1.读取未提交的内容(Read Uncommitted)</h5><blockquote><p>(1)所有事务都可以看到其他未提交事务的执行结果</p></blockquote><blockquote><p>(2)该隔离级别引发的问题就是脏读：读取到了未提交的数据</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#首先，修改隔离级别</span><br><span class="line">set tx_isolation=&apos;READ-UNCOMMITTED&apos;;</span><br><span class="line">select @@tx_isolation;</span><br><span class="line">+------------------+</span><br><span class="line">| @@tx_isolation   |</span><br><span class="line">+------------------+</span><br><span class="line">| READ-UNCOMMITTED |</span><br><span class="line">+------------------+</span><br><span class="line">#事务A：启动一个事务</span><br><span class="line">start transaction;</span><br><span class="line">select * from tx;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | num  |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |    1 |</span><br><span class="line">|    2 |    2 |</span><br><span class="line">|    3 |    3 |</span><br><span class="line">+------+------+</span><br><span class="line">#事务B：也启动一个事务(那么两个事务交叉了)</span><br><span class="line">       在事务B中执行更新语句，且不提交</span><br><span class="line">start transaction;</span><br><span class="line">update tx set num=10 where id=1;</span><br><span class="line">select * from tx;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | num  |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |   10 |</span><br><span class="line">|    2 |    2 |</span><br><span class="line">|    3 |    3 |</span><br><span class="line">+------+------+</span><br><span class="line">#事务A：那么这时候事务A能看到这个更新了的数据吗?</span><br><span class="line">select * from tx;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | num  |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |   10 |   ---&gt;可以看到！说明我们读到了事务B还没有提交的数据</span><br><span class="line">|    2 |    2 |</span><br><span class="line">|    3 |    3 |</span><br><span class="line">+------+------+</span><br><span class="line">#事务B：事务B回滚,仍然未提交</span><br><span class="line">rollback;</span><br><span class="line">select * from tx;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | num  |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |    1 |</span><br><span class="line">|    2 |    2 |</span><br><span class="line">|    3 |    3 |</span><br><span class="line">+------+------+</span><br><span class="line">#事务A：在事务A里面看到的也是B没有提交的数据</span><br><span class="line">select * from tx;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | num  |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |    1 |      ---&gt;脏读意味着我在这个事务中(A中)，事务B虽然没有提交，但它任何一条数据变化我                             都可以看到！</span><br><span class="line">|    2 |    2 |</span><br><span class="line">|    3 |    3 |</span><br><span class="line">+------+------+</span><br></pre></td></tr></table></figure><h5 id="2-读取提交内容-Read-Committed"><a href="#2-读取提交内容-Read-Committed" class="headerlink" title="2.读取提交内容(Read Committed)"></a>2.读取提交内容(Read Committed)</h5><blockquote><p>它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。</p></blockquote><p>但是它出现的问题是：不可重复读，不可重复读意味着我们在同一个事务中执行完全相同的select语句看到的可能是完全不一样的结果。</p><p>导致这种情况的原因有：</p><ul><li>(1)有一个交叉的事务有新的commit，导致了数据的改变</li><li>（2）一个数据库被多个实例操作时，同一个事务的其他实例在该实例处理其间有可能会有新的commit</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#首先修改隔离级别</span><br><span class="line">set tx_isolation=&apos;read-committed&apos;;</span><br><span class="line">select @@tx_isolation;</span><br><span class="line">+----------------+</span><br><span class="line">| @@tx_isolation |</span><br><span class="line">+----------------+</span><br><span class="line">| READ-COMMITTED |</span><br><span class="line">+----------------+</span><br><span class="line">#事务A：启动一个事务</span><br><span class="line">start transaction;</span><br><span class="line">select * from tx;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | num  |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |    1 |</span><br><span class="line">|    2 |    2 |</span><br><span class="line">|    3 |    3 |</span><br><span class="line">+------+------+</span><br><span class="line">#事务B：也启动一个事务(那么两个事务交叉了)</span><br><span class="line">       在这事务中更新数据，且未提交</span><br><span class="line">start transaction;</span><br><span class="line">update tx set num=10 where id=1;</span><br><span class="line">select * from tx;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | num  |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |   10 |</span><br><span class="line">|    2 |    2 |</span><br><span class="line">|    3 |    3 |</span><br><span class="line">+------+------+</span><br><span class="line">#事务A：这个时候我们在事务A中能看到数据的变化吗?</span><br><span class="line">select * from tx; ---------------&gt;</span><br><span class="line">+------+------+                |</span><br><span class="line">| id   | num  |                |</span><br><span class="line">+------+------+                |</span><br><span class="line">|    1 |    1 |---&gt;并不能看到！  |</span><br><span class="line">|    2 |    2 |                |</span><br><span class="line">|    3 |    3 |                |</span><br><span class="line">+------+------+                |——&gt;相同的select语句，结果却不一样</span><br><span class="line">                               |</span><br><span class="line">#事务B：如果提交了事务B呢?        |</span><br><span class="line">commit;                        |</span><br><span class="line">                               |</span><br><span class="line">#事务A:                         |</span><br><span class="line">select * from tx; ---------------&gt;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | num  |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |   10 |---&gt;因为事务B已经提交了，所以在A中我们看到了数据变化</span><br><span class="line">|    2 |    2 |</span><br><span class="line">|    3 |    3 |</span><br><span class="line">+------+------+</span><br></pre></td></tr></table></figure><h5 id="3-可重读（Repeatable-Read）"><a href="#3-可重读（Repeatable-Read）" class="headerlink" title="3.可重读（Repeatable Read）"></a>3.可重读（Repeatable Read）</h5><ul><li>(1)这是MySQL的默认事务隔离级别</li><li>(2)它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行</li><li>(3)此级别可能出现的问题——幻读(Phantom Read)：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行</li><li>(4)InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#首先，更改隔离级别</span><br><span class="line">set tx_isolation=&apos;repeatable-read&apos;;</span><br><span class="line">select @@tx_isolation;</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br><span class="line"></span><br><span class="line">#事务A：启动一个事务</span><br><span class="line">start transaction;</span><br><span class="line">select * from tx;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | num  |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |    1 |</span><br><span class="line">|    2 |    2 |</span><br><span class="line">|    3 |    3 |</span><br><span class="line">+------+------+</span><br><span class="line"></span><br><span class="line">#事务B：开启一个新事务(那么这两个事务交叉了)</span><br><span class="line">       在事务B中更新数据，并提交</span><br><span class="line">start transaction;</span><br><span class="line">update tx set num=10 where id=1;</span><br><span class="line">select * from tx;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | num  |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |   10 |</span><br><span class="line">|    2 |    2 |</span><br><span class="line">|    3 |    3 |</span><br><span class="line">+------+------+</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line">#事务A：这时候即使事务B已经提交了,但A能不能看到数据变化？</span><br><span class="line">select * from tx;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | num  |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |    1 | ---&gt;还是看不到的！(这个级别2不一样，也说明级别3解决了不可重复读问题)</span><br><span class="line">|    2 |    2 |</span><br><span class="line">|    3 |    3 |</span><br><span class="line">+------+------+</span><br><span class="line"></span><br><span class="line">#事务A：只有当事务A也提交了，它才能够看到数据变化</span><br><span class="line">commit;</span><br><span class="line">select * from tx;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | num  |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |   10 |</span><br><span class="line">|    2 |    2 |</span><br><span class="line">|    3 |    3 |</span><br><span class="line">+------+------+</span><br></pre></td></tr></table></figure><h5 id="4-可串行化-Serializable"><a href="#4-可串行化-Serializable" class="headerlink" title="4.可串行化(Serializable)"></a>4.可串行化(Serializable)</h5><ul><li>(1)这是最高的隔离级别</li><li>(2)它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的数据行上加上共享锁。</li><li>(3)在这个级别，可能导致大量的超时现象和锁竞争</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#首先修改隔离界别</span><br><span class="line">set tx_isolation=&apos;serializable&apos;;</span><br><span class="line">select @@tx_isolation;</span><br><span class="line">+----------------+</span><br><span class="line">| @@tx_isolation |</span><br><span class="line">+----------------+</span><br><span class="line">| SERIALIZABLE   |</span><br><span class="line">+----------------+</span><br><span class="line"></span><br><span class="line">#事务A：开启一个新事务</span><br><span class="line">start transaction;</span><br><span class="line"></span><br><span class="line">#事务B：在A没有commit之前，这个交叉事务是不能更改数据的</span><br><span class="line">start transaction;</span><br><span class="line">insert tx values(&apos;4&apos;,&apos;4&apos;);</span><br><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br><span class="line">update tx set num=10 where id=1;</span><br><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL基本操作汇总</title>
      <link href="/2017/02/15/MySQL%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2017/02/15/MySQL%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>对于整型来说<code>TINYINT</code>、<code>SMALLINT</code>、<code>MEDIUMINT</code>、<code>INT</code>、<code>BIGINT</code>等<ul><li>指定长度是没有意义的，它不会限制值的范围，只会影响显示字符的个数，比如<code>int(10)</code> 如果不足十位的会补足0（通过zerofill属性来显示）。值得注意的是，如果字符少于位数则会补足0，如果超过了宽度则不受影响。</li></ul></li></ul><a id="more"></a><ul><li><p>对于实数类型来说<code>FLOAT</code>（四个字节）、<code>DOUBLE</code>（八个字节）、<code>DECIMAL</code>（可以存储比BIGINT还要大的整型，可以存储精确的小数，16字节，精度较高的运算一般用decimal）</p></li><li><p>字符串类型<code>VARCHAR</code>、<code>CHAR</code>、<code>TEXT</code>、<code>BLOB</code></p><ul><li>char的长度是固定的，最大为255个字符，而char的最大长度是255<em>每个字符占用的字节数，比如utf8编码就是255\</em>3,gbk就是255*2  </li><li>varchar代表变长，最大的长度为65535个字节，如果采用varchar的话需要用1-2个字节来存储长度信息（255个字节一下需要1个字节，超过255需要两个字节）。而varchar最大字符数也是根据编码来决定（注意：char和varchar后面跟的数字都是指字符数），如果是utf8编码，varchar最大字符数=65535/3约为21845个字符，如果是gbkvarchar最大字符数=65533/2约为32766个字符   </li><li>text和blob类型查询的时候会产生临时表，尽量不要使用</li></ul></li><li><p>日期和时间类型（尽量使用TIMESTAMP，比DATETIME空间效率高）</p></li></ul><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li>veresion();    //显示当前服务版本</li><li>now();     //显示当前时间</li><li>user();    //显示当前用户</li><li>concat(‘a’, ‘b’);     //字符链接</li><li>concat_ws(‘-‘, ‘a’, ‘b’); //使用指定分隔符连接</li><li>lower(‘MYSQL’) upper(‘mysql’) //大小写转换</li><li>left(‘mysql’, 2)  //左截取 right(‘mysql’, 2) //右截取</li><li>length(‘mysql’)   //获取字符串长度</li><li>replace(‘-my-sql’, ‘-‘, ‘+’)  //替换字符</li><li>substring(‘mysql’, 1 ,2)  //截取字符</li><li>date_format(‘2017-9-11’, ‘%Y-%m-%d’); //日期格式化</li><li>avg();    //平均值</li><li>count();  //总数</li><li>max(); min()   //最大值，最小值</li><li>sum();    //求和</li></ul><h3 id="常用数据库操作"><a href="#常用数据库操作" class="headerlink" title="常用数据库操作"></a>常用数据库操作</h3><h5 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1.创建数据库"></a>1.创建数据库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create &#123;database|schema&#125; [if not exists] db_name [default] character set [=] charset_name</span><br><span class="line">例：CREATE DATABASE test;</span><br></pre></td></tr></table></figure><h5 id="2-修改数据库"><a href="#2-修改数据库" class="headerlink" title="2.修改数据库"></a>2.修改数据库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter &#123;database|schema&#125; db_name [default] character set [=] charset_name</span><br><span class="line">例：ALTER DATABASE test CHARACTER SET utf8;</span><br></pre></td></tr></table></figure><h5 id="3-删除数据库"><a href="#3-删除数据库" class="headerlink" title="3.删除数据库"></a>3.删除数据库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drop &#123;database|schema&#125; [if exists] db_name</span><br><span class="line">例：DROP DATABASE test;</span><br></pre></td></tr></table></figure><h3 id="常用数据表操作"><a href="#常用数据表操作" class="headerlink" title="常用数据表操作"></a>常用数据表操作</h3><h5 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1.创建表"></a>1.创建表</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create table [if not exists] tbl_name(</span><br><span class="line">    age tinyint(2) unsigned not null auto_increment primary key</span><br><span class="line">);</span><br><span class="line">例：CREATE TABLE user(</span><br><span class="line">    id INT(10) UNSIGNED AUTO_INCREMENT PRIMARY KEY,//主键自增</span><br><span class="line">    name VARCHAR(20) NOT NULL UNIQUE KEY,//唯一</span><br><span class="line">    price DECIMAL(8,2) UNSIGNED DEFAULT 0.00,//默认</span><br><span class="line">    cid INT(10) UNSIGNED,</span><br><span class="line">    KEY cid(cid),</span><br><span class="line">    FOREIGN KEY (cid) REFERENCES cate (id) ON DELETE CASCADE//外键 （删除时执行CASCADE）</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><h5 id="2-查看表结构"><a href="#2-查看表结构" class="headerlink" title="2.查看表结构"></a>2.查看表结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show colums from tbl_name;</span><br><span class="line">例：SHOW COLUMUNS FROM user</span><br></pre></td></tr></table></figure><h5 id="3-修改表结构"><a href="#3-修改表结构" class="headerlink" title="3. 修改表结构"></a>3. 修改表结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alter table tbl_name op[add|drop|modify] [column] (col_name column_definition,..);</span><br><span class="line">例：</span><br><span class="line">ALTER TABLE user ADD num INT(10) UNSIGNED, time INT(10) UNSIGNED;  // 添加字段</span><br><span class="line">ALTER TABLE user DROP num,DROP time;    // 删除字段</span><br></pre></td></tr></table></figure><h5 id="4-插入"><a href="#4-插入" class="headerlink" title="4.插入"></a>4.插入</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）insert [into] tbl_name [(col_name,..)] &#123;values|value&#125; (&#123;expr|default&#125;,...),(...),...;</span><br><span class="line">例：INSERT user (id,name,price) VALUES (DEFAULT,tom&apos;,20);</span><br></pre></td></tr></table></figure><h5 id="5-更新"><a href="#5-更新" class="headerlink" title="5.更新"></a>5.更新</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update tbl_name set col_name1=&#123;expr1|default&#125; [,col_name2=&#123;expr2|default&#125;].. [where where_condition]</span><br><span class="line">例：UPDATE user SET num = num + id;</span><br></pre></td></tr></table></figure><h5 id="6-删除"><a href="#6-删除" class="headerlink" title="6.删除"></a>6.删除</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete from tbl_name [where where_condition]</span><br><span class="line">例：DELETE FROM user WHERE id=3;</span><br></pre></td></tr></table></figure><h3 id="约束性"><a href="#约束性" class="headerlink" title="约束性"></a>约束性</h3><h5 id="1-主键约束：primary-key"><a href="#1-主键约束：primary-key" class="headerlink" title="(1)主键约束：primary key"></a>(1)主键约束：primary key</h5><ol><li>每个表只存在一个</li><li>保证记录的唯一性</li><li>自动为not null</li><li>添加了主键约束</li></ol><h5 id="2-唯一约束：-unique-key"><a href="#2-唯一约束：-unique-key" class="headerlink" title="(2)唯一约束： unique key"></a>(2)唯一约束： unique key</h5><ol><li>每个表可以存在多个</li><li>保证记录的唯一性</li><li>可以存一个null</li><li>添加了唯一约束</li></ol><h5 id="3-默认约束：default"><a href="#3-默认约束：default" class="headerlink" title="(3)默认约束：default"></a>(3)默认约束：default</h5><ol><li>给列添加了默认值</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">ALTER TABLE user ALTER num SET DEFAULT 0;</span><br><span class="line">ALTER TABLE user ALTER num DROP DEFAULT;</span><br></pre></td></tr></table></figure><h5 id="4-非空约束"><a href="#4-非空约束" class="headerlink" title="(4)非空约束"></a>(4)非空约束</h5><h5 id="5-外键约束"><a href="#5-外键约束" class="headerlink" title="(5)外键约束"></a>(5)外键约束</h5><ol><li>保证了数据的一致性，实现了1对1,1对多的关系</li><li>cascade：从父表中删除或更新且自动删除或更新子表中的匹配行</li><li>set nul： 从父表删除或更新并设置子表中的外键列为null。如果使用该选项，必须保证子表没有指定not null</li><li>restrict：拒绝对父表的删除或更新操作</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">添加外键约束：</span><br><span class="line"> alter table tbl_name add [constraint [symbol]] foreign key [index_name] (index_col_name,...) reference_definition</span><br><span class="line"> 例：ALTER TABLE user ADD FOREIGN KEY (cid) REFERENCES cate (id)</span><br><span class="line"> 删除外键约束：</span><br><span class="line"> alter table tbl_name drop foreign key symbol</span><br><span class="line">  例：ALTER TABLE user DROP FOREIGN KEY cid;</span><br></pre></td></tr></table></figure><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><blockquote><p>嵌套在内部，始终出现在括号内;</p></blockquote><p>可以包含多个关键字或条件，如distinct，group by，order by，limit，函数等;<br>外层可以是：select，insert，update，set</p><h5 id="1-比较运算符-gt-lt-lt-gt-lt-gt"><a href="#1-比较运算符-gt-lt-lt-gt-lt-gt" class="headerlink" title="1.比较运算符:=,&gt;,&lt;,&lt;=,&gt;=,&lt;&gt;"></a>1.比较运算符:=,&gt;,&lt;,&lt;=,&gt;=,&lt;&gt;</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 where col_name1 &gt;= ANY (select col_name2 from t2);</span><br><span class="line">(1)any:符合任意一个</span><br><span class="line">(2)all:符合所有</span><br></pre></td></tr></table></figure><h5 id="2-（not）in-exists"><a href="#2-（not）in-exists" class="headerlink" title="2.（not）in/exists"></a>2.（not）in/exists</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 where col_name1 NOT IN ALL (select col_name2 from t2);</span><br></pre></td></tr></table></figure><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><h5 id="内连接（inner-join），左连接（left-join），-右连接（right-join）-全连接（full-join），-交叉连接（across-join）"><a href="#内连接（inner-join），左连接（left-join），-右连接（right-join）-全连接（full-join），-交叉连接（across-join）" class="headerlink" title="内连接（inner join），左连接（left join）， 右连接（right join）,全连接（full join）， 交叉连接（across join）"></a>内连接（inner join），左连接（left join）， 右连接（right join）,全连接（full join）， 交叉连接（across join）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">现有两张表A、B</span><br><span class="line">表A</span><br><span class="line">id   name  </span><br><span class="line">1    张</span><br><span class="line">2    李</span><br><span class="line">3    王</span><br><span class="line"></span><br><span class="line">表B</span><br><span class="line">id   address   A_id</span><br><span class="line">1    北京      1</span><br><span class="line">2    上海      3</span><br><span class="line">3    南京      10</span><br><span class="line"></span><br><span class="line">**************left join**********</span><br><span class="line">SELECT A.name, B.address</span><br><span class="line">FROM A</span><br><span class="line">LEFT JOIN B ON A.id = B.A_id </span><br><span class="line">结果是：</span><br><span class="line">name     address</span><br><span class="line">张     北京</span><br><span class="line">李     NULL</span><br><span class="line">王     上海</span><br><span class="line"></span><br><span class="line">可以看到A表（左边的表）的所有行都显示出来了，B表中没有匹配到的行是NULL值</span><br><span class="line"></span><br><span class="line">************right join***********</span><br><span class="line">SELECT A.name, B.address</span><br><span class="line">FROM A</span><br><span class="line">RIGHT JOIN B ON A.id = B.A_id</span><br><span class="line">结果是：</span><br><span class="line">name     address</span><br><span class="line">张     北京</span><br><span class="line">王     上海</span><br><span class="line">NULL     南京</span><br><span class="line">与left join相反，B表（右边的表）中的行全显示出来，A表中匹配不到的行显示NULL</span><br><span class="line"></span><br><span class="line">**********inner join************</span><br><span class="line">select A.name,B.address from A </span><br><span class="line">inner join B</span><br><span class="line">on A.id = B.A_id</span><br><span class="line">结果是：</span><br><span class="line">name     address</span><br><span class="line">张     北京</span><br><span class="line">王     上海</span><br><span class="line"></span><br><span class="line">内连接等价于：</span><br><span class="line">SELECT A.name, B.address</span><br><span class="line">FROM A, B</span><br><span class="line">WHERE A.id = B.A_id</span><br><span class="line"></span><br><span class="line">内连接只返回A、B两表都有的行，相当于A、B的交集</span><br><span class="line"></span><br><span class="line">*********full join**********</span><br><span class="line">全外连接返回参与连接的两个数据集合中的全部数据，无论它们是否具有与之</span><br><span class="line">相匹配的行。在功能上，它等价于对这两个数据集合分别进行左外连接和右外</span><br><span class="line">连接，然后再使用消去重复行的并操作将上述两个结果集合并为一个结果集</span><br><span class="line"></span><br><span class="line">select * from A </span><br><span class="line">full join B</span><br><span class="line">结果是：</span><br><span class="line">id     name     id     address A_id</span><br><span class="line">1     张     1     北京     1</span><br><span class="line">2     李     1     北京     1</span><br><span class="line">3     王     1     北京     1</span><br><span class="line">1     张     2     上海     3</span><br><span class="line">2     李     2     上海     3</span><br><span class="line">3     王     2     上海     3</span><br><span class="line">1     张     3     南京     10</span><br><span class="line">2     李     3     南京     10</span><br><span class="line">3     王     3     南京     10</span><br><span class="line"></span><br><span class="line">*********across join***********</span><br><span class="line">返回笛卡尔积，A*B</span><br><span class="line">SELECT * FROM A</span><br><span class="line">CROSS JOIN B</span><br><span class="line">结果是：</span><br><span class="line">id     name     id     address A_id</span><br><span class="line">1     张     1     北京     1</span><br><span class="line">2     李     1     北京     1</span><br><span class="line">3     王     1     北京     1</span><br><span class="line">1     张     2     上海     3</span><br><span class="line">2     李     2     上海     3</span><br><span class="line">3     王     2     上海     3</span><br><span class="line">1     张     3     南京     10</span><br><span class="line">2     李     3     南京     10</span><br><span class="line">3     王     3     南京     10</span><br><span class="line">等价于sql：</span><br><span class="line">select * from A,B</span><br></pre></td></tr></table></figure><h5 id="联合查询（union与union-all）"><a href="#联合查询（union与union-all）" class="headerlink" title="联合查询（union与union all）"></a>联合查询（union与union all）</h5><blockquote><p>把多个结果集集中在一起</p></blockquote>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nginx基本使用笔记</title>
      <link href="/2017/01/04/Nginx%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/01/04/Nginx%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="1-常见操作"><a href="#1-常见操作" class="headerlink" title="1.常见操作"></a>1.常见操作</h3><pre><code>`nginx -s signal`</code></pre><p>signal的值可以是：</p><ul><li>stop 快速关机</li><li>quit 正常关机</li><li>reload 重新加载配置文件</li><li>reopen 重新打开日志文件</li></ul><a id="more"></a><h3 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2.配置文件"></a>2.配置文件</h3><p>nginx是由模块组成的，这些模块在配置文件中又有指定的指令。 指令被分成简单指令和块指令。简单指令包括名称和用空格分割的参数以及用来结尾的分号(;)。 一个块指令和简单指令有相同的结构，但是它使用大括号({and})来包围一系列说明来替代使用分号作为结尾。</p><blockquote><p>放在配置文件最外面的指令的称之为主文，<code>event</code>,<code>http</code>指令在主文中；<code>server</code>在<code>http</code>中， <code>location</code>在<code>server</code>中。</p></blockquote><h3 id="3-静态服务"><a href="#3-静态服务" class="headerlink" title="3.静态服务"></a>3.静态服务</h3><p>Web服务器一个重要的任务就是提供文件（如图像或者静态html页面）。 根据需求，你将实现一个例子，文件被本地不同的目录服务着，如<code>/data/www</code> 包含html文件，<code>/data/images</code> 包含图片。这需要编辑配置文件，在<code>http</code>块中设置<code>server</code>块。</p><ul><li><p>首先，创建<code>/data/www</code> 目录并放置index.html文件（文件中可以是任意内容）。 然后创建<code>/data/images</code>目录并放置一些图片。</p></li><li><p>接下来，打开配置文件。默认的配置文件已经包含了几个server块的例子，大多数都被注释掉了。 现在注释掉所有的块，并开始一个新的server块。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，配置文件中包含多个server块，它们之间以监听的端口号和server name来区分。 一旦nginx决定了哪个server处理请求，它测试在请求的对server块内定义的位置指令的参数头中指定的URI。</p><h5 id="添加location到server中"><a href="#添加location到server中" class="headerlink" title="添加location到server中"></a>添加location到server中</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root /data/www;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与请求的URI相比，location块指定了“/”前缀。为了匹配请求，该URI会被添加到root指令指定的路径中， 即，到/data/www，在本地文件系统中组成请求文件的路径。如果有多个匹配的location块，nginx会选择前缀最长的。 上面的location块提供了最短的前缀，如果其他的location块匹配失败，这个location块就会被使用。</p><h5 id="现在来添加第二个location"><a href="#现在来添加第二个location" class="headerlink" title="现在来添加第二个location:"></a>现在来添加第二个location:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /images/ &#123;</span><br><span class="line">    root /data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它与带/images/的请求请求匹配。（location / ，当然也匹配，除非有更短的前缀。）</p><p>#####现在server中是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root /data/www;</span><br><span class="line">    &#125;</span><br><span class="line">    location /images/ &#123;</span><br><span class="line">        root /data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启配置文件，让配置生效 <code>nginx -s reload</code></p><blockquote><p>这已经是一个可以工作的服务器配置文件，它监听的是80端口，可在本地通过<code>http://localhost/</code>访问。 响应带<code>/images/</code>的URI路由请求时，服务器将会从<code>/data/images</code>目录发送文件。 例如，响应 <code>http://localhost/images/example.png</code> 路由请求，nginx将会发送<code>/data/images/example.png</code> 文件。如果这个文件不存在，nginx将会发出404错误的响应。不带<code>/images/</code>的URIs请求将会映射到<code>/data/www</code>目录。 例如，为了响应<code>http://localhost/some/example.html</code>请求，nginx将会发送<code>/data/www/some/example.html</code>文件。</p></blockquote><h3 id="3-代理服务器"><a href="#3-代理服务器" class="headerlink" title="3.代理服务器"></a>3.代理服务器</h3><p>服务器A接受到请求后，将请求转发给其他的服务器B，从服务器B处获得响应，并将取得的相应返回给客户端，服务器B则是服务器A的代理服务器</p><p>首先，我们新增一个server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    root /data/up1;</span><br><span class="line">    location / &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个简单的server块，监听8080端口（此前，listen指令没有被提起是由于已经使用了标准的80端口），并将所有的请求 映射到本地文件系统的/data/up1目录。创建这个目录，并将index.html文件放置其中。注意root指令已经被放置在server环境中。 当location块被选中服务请求时，root指令就会被使用，当然不包括自己的root指令。</p><p>修改第一个location块，放置<code>proxy_pass</code>指令与协议、名称和参数中指定的代理服务器端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:8080;</span><br><span class="line">    &#125;</span><br><span class="line">    location /images/ &#123;</span><br><span class="line">        root /data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改第二个location块，它目前映射所有带/images/前缀的请求到/data/images 目录下的文件，是为了使其符合典型的文件扩展的图像请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.(gif|jpg|png)$ &#123;</span><br><span class="line">    root /data/images;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>该参数是一个正则表达式，匹配所有.gif,.jpg,.png 结尾的路由。正则表达式应该优于～。相应的请求都会被映射到 /data/images目录。</p></blockquote><p>当nginx选择一个location块服务一个请求时，它首先检查location指令的指定前缀，记住location最长的前缀， 然后检查正则表达式。如果有一个匹配的正则表达式，nginx会挑选location块，否则它会选择之前的。<br>因此代理服务器的配置文件应该是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:8080/;</span><br><span class="line">    &#125;</span><br><span class="line">    location ~ \.(gif|jpg|png)$ &#123;</span><br><span class="line">        root /data/images;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此服务器会筛选出以.gif,.jpg,.png 结尾的请求，并将他们映射到/data/images目录下(通过添加URI到root指令的参数上)， 然后通过所有其它请求到代理服务器配置上</p><pre><code>`nginx -s reload` 重启配置使更改生效</code></pre><h3 id="4-FastCGI代理"><a href="#4-FastCGI代理" class="headerlink" title="4. FastCGI代理"></a>4. FastCGI代理</h3><p>nginx可用于路由请求FastCGI服务器，FastCGI服务器运行各种不同的框架和编程语言，如PHP，建立的应用。</p><blockquote><p>最常用与 FastCGI server工作的nginx配置，用fastcgi_pass指令替代了proxy_pass指令，并设置fastcgi_param 参数传递给FastCGI server。</p></blockquote><p>假设FastCGI server通过localhost:9000可以访问。 以上一节代理配置作为基础，用fastcgi_pass指令替换proxy_pass指令，并修改参数为localhost:9000。在PHP中， SCRIPT_FILENAME参数用来确定脚本名，QUERY_STRING参数用来传递请求参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    location / &#123;</span><br><span class="line">        fastcgi_pass  localhost:9000;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">        fastcgi_param QUERY_STRING    $query_string;</span><br><span class="line">    &#125;</span><br><span class="line">    location ~ \.(gif|jpg|png)$ &#123;</span><br><span class="line">        root /data/images;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nginx与PHP通信"><a href="#nginx与PHP通信" class="headerlink" title="nginx与PHP通信"></a>nginx与PHP通信</h2><p>首先我们先简单的看一份nginx server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80 default_server;</span><br><span class="line">    index index.php;</span><br><span class="line">    root /home/work/</span><br><span class="line">    </span><br><span class="line">    location ~[^/]\.php(/l$)</span><br><span class="line">    &#123;</span><br><span class="line">        fastcgi_pass unix:/tmp/php-cgi.sock;</span><br><span class="line">        fastcgi_index index.php;</span><br><span class="line">        include fastcgi.conf;</span><br><span class="line">    &#125;</span><br><span class="line">    access_log /home/work/logs/default.log;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CGI是通用网关协议，FastCGI则是一种常住进程的CGI模式程序。我们所熟知的PHP-FPM会通过用户配置来管理一批FastCGI进程，例如在PHP-FPM管理下的某个FastCGI进程挂了，PHP-FPM会根据用户配置来看是否要重启补全，PHP-FPM更像是管理器，而真正衔接Nginx与PHP的则是FastCGI进程。</p></blockquote><p>我们可以看到server中包含了<code>fastcgi.conf</code>，里面是一些fastcgi_param的配置项，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_param  QUERY_STRING       $query_string;</span><br><span class="line">fastcgi_param  REQUEST_METHOD     $request_method;</span><br><span class="line">fastcgi_param  CONTENT_TYPE       $content_type;</span><br><span class="line">fastcgi_param  CONTENT_LENGTH     $content_length;</span><br><span class="line"></span><br><span class="line">fastcgi_param  SCRIPT_NAME        $fastcgi_script_name;</span><br><span class="line">fastcgi_param  REQUEST_URI        $request_uri;</span><br><span class="line">fastcgi_param  DOCUMENT_URI       $document_uri;</span><br><span class="line">fastcgi_param  DOCUMENT_ROOT      $document_root;</span><br><span class="line">fastcgi_param  SERVER_PROTOCOL    $server_protocol;</span><br><span class="line">fastcgi_param  HTTPS              $https if_not_empty;</span><br><span class="line"></span><br><span class="line">fastcgi_param  GATEWAY_INTERFACE  CGI/1.1;</span><br><span class="line">fastcgi_param  SERVER_SOFTWARE    nginx/$nginx_version;</span><br><span class="line"></span><br><span class="line">fastcgi_param  REMOTE_ADDR        $remote_addr;</span><br><span class="line">fastcgi_param  REMOTE_PORT        $remote_port;</span><br><span class="line">fastcgi_param  SERVER_ADDR        $server_addr;</span><br><span class="line">fastcgi_param  SERVER_PORT        $server_port;</span><br><span class="line">fastcgi_param  SERVER_NAME        $server_name;</span><br><span class="line"></span><br><span class="line"># PHP only, required if PHP was built with --enable-force-cgi-redirect</span><br><span class="line">fastcgi_param  REDIRECT_STATUS    200;</span><br><span class="line">fastcgi_param  PHP_VALUE  &quot;open_basedir=$document_root:/usr/share/pear:/usr/share/php:/etc/phpMyAdmin:/tmp:/proc&quot;;</span><br></pre></td></tr></table></figure><p>fastcig_param中所声明的内容会传到php-fpm（或者其他fast-cgi server）所管理的fast-cgi进程。我们可以看到，fastcgi_param中都是一些服务器的信息，如remote_addr(访问用户的ip)等，他就可以把这些信息传递给后端程序，如PHP的$_SERVER</p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一步一步教你如何写开发文档</title>
      <link href="/2017/01/02/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E5%86%99%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/"/>
      <url>/2017/01/02/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E5%86%99%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/</url>
      <content type="html"><![CDATA[<p>你有没有遇到过，突然老板或者老大跟你说，你根据项目或者根据功能写一份开发文档，当时很开心的答应了，后来想想，既然懵了。</p><p>开发文档是什么鬼？写了这么多年代码都没写过什么开发文档，最多也就只是产品的需求文档，说明文档，代码的注释与规范文档，或者说过苹果的开发文档，因为之前刚好写过一次很简单的，最近公司又开始要写上面开发文档了，而且发现确实很多同学都不会，我在想，我是不是该做点什么……。</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>App开发过程中的文档分为很多种，比如最常见的就是官方的开发文档，这种比较倾向代码和接口，但是你可能还见过或者听过其他文档。</p><p>比如，这里根据个人理解整理了几个。</p><ol><li>开发文档</li><li>需求(原型)文档</li><li>需求(说明)文档</li><li>技术方案文档</li><li>Bug修复文档</li><li>注释文档</li><li>代码与UI规范文档</li><li>性能优化文档</li></ol><p>是不是有点晕了，哪有这么多鬼，其实按照之前的习惯，我都是一份开发文档就够了，基本上包含上面的东西，只是看你怎么细分。</p><h3 id="开发文档概述"><a href="#开发文档概述" class="headerlink" title="开发文档概述"></a>开发文档概述</h3><p>实际开发中如果真的遇到要写上面开发文档可以从下面几个角度写。</p><ul><li>一. 开发环境及工具</li><li>二. 项目或功能（需求）描述（最好有流程图或者UML）- 需求文档</li><li>三. 编写目的（用户特征和水平）</li><li>四. 项目或功能背景</li><li>五. 模块与关系</li><li>六. 类或术语说明</li><li>七. 参考资料（网络或公司内部资料，UI，原型，说明文档）</li><li>八. 项目进度预估</li><li>九. 难点预估（条件与限制）</li><li>十. 功能与所计划采用的技术 - 技术方案文档</li><li>十一. 用户界面与交互</li><li>十二. 软件（代码）接口 - 注释文档</li><li>十三. 通信（网络）接口 - 接口文档</li><li>十四. 问题与修复说明 - Bug修复文档</li><li>十五. 性能分析与优化</li></ul><p>当然也不是说这些全部要写，可以根据项目或者功能适当编写。</p><p>下面大概一个个的说明一些每一个步骤是什么意思，需要怎么写，这里主要以iOS开发中App开发文档为规范，并使用苹果最新的语言Swift作为唯一语言。</p><ul><li><p>一. 开发环境及工具</p><ul><li>Mac OX 10<ul><li>iPhone或者iPad 5+ 2+ 必须真机</li><li>iOS 8+</li><li>Xcode 8+</li><li>其他工具：Tower，cornerstone</li></ul></li></ul></li></ul><blockquote><p>主要指明开发在工具，开发平台，开发版本的支持。描述软件的运行环境，包括硬件平台、硬件要求、操作系统和版本，以及其他的软</p></blockquote><p>件或与其共存的应用程序等。</p><ul><li><p>二. 项目或功能（需求）描述（最好有流程图或者UML）- 需求文档</p><ul><li><p>顶层数据流图；</p></li><li><p>用例UseCase图；</p></li><li><p>系统流程图；</p></li><li><p>层次方框图。</p></li></ul></li></ul><blockquote><p>主要根据产品给出的需求结合原型进行描述，并适当给出相应的图。</p></blockquote><ul><li><p>三. 编写目的（用户特征和水平）</p><ul><li>描述最终用户应具有的受教育水平、工作经验及技术专长。</li></ul></li></ul><blockquote><p>次软件或者功能编写的目的，对项目，对用户，对公司有什么好处。</p></blockquote><ul><li><p>四. 项目或功能背景</p><ul><li><p>标识待开发软件产品的名称、代码；</p></li><li><p>列出本项目的任务提出者、项目负责人、系统分析员、系统设计员、程序设计员、程序员、资料员以及与本项目开展工作直接有关的人员和用户；</p></li><li><p>说明该软件产品与其他有关软件产品的相互关系。</p></li></ul></li></ul><blockquote><p>此项目或功能编写之前市面上的情况，公司和用户的情况</p></blockquote><ul><li>五. 模块与关系</li></ul><blockquote><p>项目或功能对应模块在位置，入口，和其他模块的关系</p></blockquote><ul><li>六. 类或术语说明</li></ul><blockquote><p>项目或功能对应类的说明，和开发中使用到的一些相关的术语的说明</p></blockquote><ul><li><p>七. 参考资料（网络或公司内部资料，UI，原型，说明文档）</p><ul><li><p>列举编写软件需求规格说明时所参考的资料，包括项目经核准的计划任务书、合同、引用的标准和规范、项目开发计划、需求规格说明、使用实例文档，以及相关产品的软件需求规格说明。</p></li><li><p>在这里应该给出详细的信息，包括标题、作者、版本号、发表日期、出版单位或资料来源。</p></li></ul></li></ul><blockquote><p>网络资料，尤其是苹果的，也可以群里或者博客，文章等。公司内部的UI，原型，说明，网络接口资料</p></blockquote><ul><li>八. 项目进度预估</li></ul><blockquote><p>预计从上面开始到指定的时间节点完成任务或者完成对应的部分</p></blockquote><ul><li>九. 难点预估（条件与限制）</li></ul><blockquote><p>其中考虑到或者可能会遇到什么技术或者实现难点</p></blockquote><ul><li><p>十. 功能与所计划采用的技术 - 技术方案文档</p><ul><li><p>将要采用的图形用户界面标准或产品系列的风格；</p></li><li><p>屏幕布局；</p></li><li><p>菜单布局；</p></li><li><p>输入输出格式；</p></li><li><p>错误信息显示格式；</p></li><li><p>建议采用RAD开发工具，    比如Visio，构造用户界面。</p></li></ul></li></ul><blockquote><p>根据项目或者功能需求，在代码层面所使用的技术或者实现方案，或者比如说ios中布局方式的使用。</p></blockquote><ul><li>十一. 用户界面与交互</li></ul><blockquote><p>根据用户界面和入口说明交互与使用步骤并</p></blockquote><ul><li>十二. 软件（代码）接口 - 注释文档</li></ul><blockquote><p>每一个方法和属性对应的注释，一般是私有的话使用private但是也要注释，公开的都会使用标准的注释说明，苹果有自带的快捷键（command+option+/），之前有个插件叫VVDocument</p></blockquote><ul><li>十三. 通信（网络）接口 - 接口文档</li></ul><blockquote><p>网络请求对应的说明包括对应的参数，字段和返回值，也可以是数据模型层对应的模型属性和方法的说明</p></blockquote><ul><li>十四. 问题与修复说明 - Bug修复文档</li></ul><blockquote><p>开发或者测试的过程中出现了什么比较重要的bug，不要什么bug都写上，然后说明解决的方案</p></blockquote><ul><li><p>十五. 性能分析与优化</p><ul><li><p>时间特性 </p><ul><li><p>响应时间；</p></li><li><p>更新处理时间；</p></li><li><p>数据转换与传输时间；</p></li><li><p>运行时间等。</p></li></ul></li><li><p>适应性</p><ul><li>在操作方式、运行环境、与其他软件的接口以及开发计划等发生变化时，软件的适应能力。</li></ul></li></ul></li></ul><blockquote><p>到此完成之后，根据实际需求和个人能力，个人理解分析项目或者功能那些地方需要进行优化一下，打算怎么去优化他。</p></blockquote><p>后期会继续完善(根据项目或功能整理一套完整的开发文档)…….</p><blockquote><p>注：这里是按照功能，并不是按照整个项目分，如果要写整个项目的开发文档也可以再根据功能细分。</p></blockquote>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 文档 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2016/09/22/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2016/09/22/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>系统安全</li><li>进程管理</li><li>用户管理</li><li>文件系统</li><li>网络测试</li><li>文件处理</li><li>压缩</li><li>定时任务（crontab）</li></ul><a id="more"></a><h3 id="系统安全"><a href="#系统安全" class="headerlink" title="系统安全"></a>系统安全</h3><ol><li>sudo</li><li>su</li><li>chmod</li><li>setfacl 对某个用户单独设置某个文件的权限</li></ol><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><ol><li>top</li><li>ps</li><li>kill -9强制杀死 -15正常杀死</li><li>pkill</li><li>killall</li></ol><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><ol><li>usermod 修改系统账户文件</li><li>useradd</li><li>groupadd</li><li>userdel</li></ol><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><ol><li>mount</li><li>umount</li><li>fsck</li><li>df</li><li>du</li></ol><h3 id="网络测试"><a href="#网络测试" class="headerlink" title="网络测试"></a>网络测试</h3><ol><li>netstat</li></ol><h3 id="文件查看"><a href="#文件查看" class="headerlink" title="文件查看"></a>文件查看</h3><ol><li>head</li><li>tail</li><li>less/more</li></ol><h3 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h3><ol><li>touch</li><li>unlink</li><li>rename</li><li>ln</li><li>cp</li></ol><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><ol><li>tar</li></ol><h3 id="定时任务（crontab）"><a href="#定时任务（crontab）" class="headerlink" title="定时任务（crontab）"></a>定时任务（crontab）</h3><ol><li>crontab的使用</li><li>at 命令  </li></ol>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux软件管理</title>
      <link href="/2016/09/07/Linux%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
      <url>/2016/09/07/Linux%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<p>包管理工具上，影响最大的两个系列，就是debian的dpkg包和Red Hat的rpm包两大系列。</p><ul><li>dpkg系的前端工具是apt，用于Debian系统及其衍生系统如Ubuntu系统，以及Ubuntu的衍生系统如LinuxMint。</li><li>rpm系的影响更广，主要有两大分支：</li><li>zypper：用于OpenSUSE系统。OpenSUSE上还有强大的yast2工具</li><li>yum：用于CentOS系统。</li><li>dnf：由于yum很久不维护，所以Fedora使用了yum的一个新的分支dnf</li></ul><a id="more"></a><h3 id="【1】软件包管理"><a href="#【1】软件包管理" class="headerlink" title="【1】软件包管理"></a>【1】软件包管理</h3><p>在系统管理中，软件包的管理是最重要的，是系统管理的基础的基础，只有我们学会软件包的管理才能谈得上其它的应用。 </p><h5 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h5><p>RPM是软件管理程序，提供软件的安装、升级、查询、反安装的功能。</p><ul><li>优点：<ul><li>a、安装方便，软件中所有数据都经过编译和打包</li><li>b、查询、升级、反安装方便</li></ul></li><li>缺点：<ul><li>a、缺乏灵活性</li><li>b、存在相依属性</li></ul></li></ul><h5 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h5><blockquote><p>rpm  参数   软件包</p></blockquote><pre><code>指令选项-i：安装。-U：升级安装，如果不存在也安装。-F：更新安装，如果不存在不安装。-v：查看信息。-h：有进度条。--replacepkgs：强制覆盖安装。 --nodeps：不考虑相依属性。 -q &lt;软件名&gt;：查询。-qa：查询所有。-ql &lt;软件名&gt;：列出软件的文件清单。-qi &lt;软件名&gt;：列出软件信息。-qf &lt;文件名&gt;：查询文件所属软件。-e &lt;软件名&gt;：删除软件。</code></pre><p>例子：</p><pre><code>rpm -ivh bind-9.3.6-4.P1.el5_4.2.i386.rpm#安装rpm -Uvh/Fvh bind-9.3.6-4.P1.el5_4.2.i386.rpm #升级安装rpm  -e  bind-9.3.6-4.P1.el5_4.2.i386 #删除软件包rpm -qpi *.rpm     #查看软件包里的内容rpm -qpl *.rpm  #查看软件包将会在系统里安装哪些部分rpm –qa   #列出所有被安装的rpm 软件包</code></pre><h3 id="【2】YUM"><a href="#【2】YUM" class="headerlink" title="【2】YUM"></a>【2】YUM</h3><p>yum = Yellow dog Updater, Modified主要功能是更方便的添加/删除/更新RPM包.它能自动解决包的倚赖性问题.</p><blockquote><p>它能便于管理大量系统的更新问题</p></blockquote><h5 id="yum特点"><a href="#yum特点" class="headerlink" title="yum特点"></a>yum特点</h5><ul><li>可以同时配置多个资源库(Repository)</li><li>简洁的配置文件(/etc/yum.conf)</li><li>自动解决增加或删除rpm包时遇到的倚赖性问题</li><li>使用方便</li><li>保持与RPM数据库的一致性</li></ul><h5 id="yum配置"><a href="#yum配置" class="headerlink" title="yum配置"></a>yum配置</h5><p>挂载光盘文件到硬盘</p><pre><code>mkdir –p /mnt/cdromchmod 777 /mntmount -t iso9660 /dev/cdrom /mnt/cdrom</code></pre><p>配置/etc/yum.repos.d/server.repo</p><pre><code>[cdrom]name=cdrombaseurl=file:///mnt/cdromenabled=1</code></pre><p>清除原有的yum信息</p><pre><code>[root@localhost ~]# yum clean all</code></pre><p>查看yum 信息</p><pre><code>[root@localhost ~]# yum list</code></pre><h5 id="创建本地YUM仓库"><a href="#创建本地YUM仓库" class="headerlink" title="创建本地YUM仓库"></a>创建本地YUM仓库</h5><ul><li>① 新建一个目录——该目录作为软件仓库，将光盘中的rpm包（位于Packages文件夹）保存到该目录下。</li><li>② 对该目录内的rpm软件包建立索引：createrepo -v /rpm-directory，创建该目录下的rpm包索引，索引创建完成后，会在该文件夹下出现一个repodata目录，里面保存了仓库索引信息。</li></ul><blockquote><p>注：第②步中的createrepo工具在默认情况下是没有安装的，需要自己手动安装（Packages中已包含createrepo安装包），安装方法如下：rpm -ivh createrepo-…….rpm。安装createrepo需要手动解决依赖关系。（createrepo工具主要用于收集目录中RPM包文件的头信息，以创建repodata软件仓库数据（经gzip压缩的xml文件））</p></blockquote><ul><li>③在/etc/yum.repos.d目录下 新建一个.repo文件，其中baseurl = file:///rpm-directory 绝对路径</li><li>④清理一下yum缓存yum clean all，列出所有的软件包yum list all，查看是否成功。</li></ul><h5 id="yum管理软件"><a href="#yum管理软件" class="headerlink" title="yum管理软件"></a>yum管理软件</h5><pre><code>yum  install –y   software   #安装软件yum  update  -y software    #更新软件yum  remove  -y  software   #删除软件yum  list     #列出资源库中特定的可以安装或更新以及已经安装的rpm包yum grouplist # 累出所有软件包群组yum groupinstall   ‘包群组名’ # 安装软件包群组yum groupremove  ‘包群组名yum  info    包名    #查看软件包信息yum search  包名 # 搜索yum clean all  #清除缓存</code></pre><h5 id="yum添加163源"><a href="#yum添加163源" class="headerlink" title="yum添加163源"></a>yum添加163源</h5><p>地址：</p><ul><li><a href="http://mirrors.163.com/.help/centos.html" target="_blank" rel="noopener">http://mirrors.163.com/.help/centos.html</a></li></ul><p>下载方式：</p><ul><li><a href="wget http://mirrors.163.com/.help/CentOS6-Base-163.repo">wget http://mirrors.163.com/.help/CentOS6-Base-163.repo</a></li></ul><h3 id="【3】apt-get"><a href="#【3】apt-get" class="headerlink" title="【3】apt-get"></a>【3】apt-get</h3><p>用Linux apt-get命令的第一步就是引入必需的软件库，Debian的软件库也就是所有Debian软件包的集合，它们存在互联网上的一些公共站点上。把它们的地址加入，apt-get就能搜索到我们想要的软件。/etc/apt/sources.list是存放这些地址列表的配置文件，其格式如下：</p><pre><code>deb [web或ftp地址] [发行版名字][main/contrib/non-free]</code></pre><p>我们常用的Ubuntu就是一个基于Debian的发行</p><pre><code>命令：apt-get update：在修改/etc/apt/sources.list或者/etc/apt/preferences之后运行该命令。此外您需要定期运行这一命令以确保您的软件包列表是最新的。apt-get install packagename：安装一个新软件包apt-get remove packagename：卸载一个已安装的软件包（保留配置文件）apt-get –purge remove packagename：卸载一个已安装的软件包（删除配置文件）apt-get autoclean apt：会把已装或已卸的软件都备份在硬盘上，所以如果需要空间的话，可以让这个命令来删除你已经删掉的软件apt-get clean：这个命令会把安装的软件的备份也删除，不过这样不会影响软件的使用的。apt-get upgrade：更新所有已安装的软件包apt-get dist-upgrade：将系统升级到新版本apt-get autoclean：定期运行这个命令来清除那些已经卸载的软件包的.deb文件。</code></pre>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS——Objective-C与Swift优缺点对比</title>
      <link href="/2016/05/19/iOS%E2%80%94%E2%80%94Objective-C%E4%B8%8ESwift%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94/"/>
      <url>/2016/05/19/iOS%E2%80%94%E2%80%94Objective-C%E4%B8%8ESwift%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94/</url>
      <content type="html"><![CDATA[<p>最近有个朋友（同事）在找工作，一起讨论关于面试过程中的面试题，有不少关于Objective-C的技术问题，尤其是关于一些技术的底层实现，当然这个在之前的文章中有整理.</p><p>其中有一个问题就是关于Objective-C和Swift区别，与优缺点的对比，由于我刚使用Swift实战开发并不久，过去三年多都都是搞Objective-C，所以对Swift和Objective-C优缺点还真没有多少简介，虽然网上也有不少相关的资料和回答，但是想想这个问题以后再很多打算或者还没有开始使用Swift的公司会被经常问到，所以就花了点时间整理一下……….</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Swift，苹果于2014年WWDC（苹果开发者大会）发布的新开发语言（已开源），可与Objective-C*共同运行于Mac OS和iOS平台，用于搭建基于苹果平台的应用程序。</p><h2 id="动态性"><a href="#动态性" class="headerlink" title="动态性"></a>动态性</h2><p>Swift 是一种强类型语言。类型静态，也就是说 Swift 的默认类型是非常安全的。</p><blockquote><ol><li>Swift 当中存在有这两个修饰符<code>@objc</code>和<code>@dynamic</code>，此外我们同样还可以访问NSObject。</li><li><code>@objc</code>将您的 Swift API 暴露给 Objective-C 运行时，但是它仍然不能保证编译器会尝试对其进行优化。</li><li>如果您真的想使用动态功能的话，就需要使用@dynamic。一旦您使用了@dynamic修饰符之后，就不需要添加<code>@objc</code>了，因为它已经隐含在其中。</li></ol></blockquote><h2 id="Swift比Objective-C有什么优势？"><a href="#Swift比Objective-C有什么优势？" class="headerlink" title="Swift比Objective-C有什么优势？"></a>Swift比Objective-C有什么优势？</h2><ol><li>Swift容易阅读，语法和文件结构简易化。</li><li>Swift更易于维护，文件分离后结构更清晰。</li><li>Swift更加安全，它是类型安全的语言。</li><li>Swift代码更少，简洁的语法，可以省去大量冗余代码</li><li>Swift速度更快，运算性能更高。</li></ol><h2 id="Swift目前存在的缺点"><a href="#Swift目前存在的缺点" class="headerlink" title="Swift目前存在的缺点"></a>Swift目前存在的缺点</h2><ol><li>版本不稳定，之前升级Swift3大动刀，苦了好多人，swift4目前还未知</li><li>使用人数比例偏低，目前还是OC的天下</li><li>社区的开源项目偏少，毕竟OC独大好多年，很多优秀的类库都不支持Swift，不过这种状况正在改变，现在有好多优秀的Swift的开源类库了</li><li>公司使用的比例不高，很多公司以稳为主，还是在使用OC开发，很少一些在进行混合开发，更少一些是纯Swift开发。</li><li>偶尔开发中遇到的一些问题，很难查找到相关资料，这是一个弊端。</li><li>纯Swift的运行时和OC有本质区别，一些OC中运行时的强大功能，在纯Swift中变无效了。</li><li>对于不支持Swift的一些第三方类库，如果非得使用，只能混合编程，利用桥接文件实现。</li></ol><h2 id="整体总结"><a href="#整体总结" class="headerlink" title="整体总结"></a>整体总结</h2><ul><li>String：<ul><li>Swift中String操作已经甩OC三百万条街</li></ul></li><li>泛型：<ul><li>Swift泛用性还是不够强，如果项目不止涉及常用的http啊xmpp啊之类的协议，而是要做一些SIP啊FFMPEG啊之类的干活，那明显是OC成熟得多</li></ul></li><li>Discriminated Union<ul><li>swift里的enum. 是静态语言独有的特性.</li></ul></li><li>安全：<ul><li>由于swift的strong static type system，编译器可帮你检查出更多问题，而不是在运行时突然boom，还有一个很牛逼的安全特性就是OptionalType。</li></ul></li><li>快速：    <ul><li>静态相对来说语言本身速度更快，swift编译期就能生成vtable，确定具体要调用的方法，比起oc的动态派发自然是更快，当然处理到与oc之间桥接部分，可能不一定比oc快</li></ul></li></ul><h2 id="细节使用区别"><a href="#细节使用区别" class="headerlink" title="细节使用区别"></a>细节使用区别</h2><ul><li>在 Swift 中没有了 main.m，@UIApplicationMain 是程序入口</li><li>swift不分.h和.m文件 ，一个类只有.swift一个文件，所以整体的文件数量比起OC有一定减少。</li><li>swift句尾不需要分号 ，除非你想在一行中写三行代码就加分号隔开。</li><li>在 Swift 中，一个类就是用一对 <code>{ }</code> 括起的，没有 @implementation 和 @end</li><li>swift数据类型都会自动判断 ， 只区分变量var 和常量let</li><li>强制类型转换格式不同   OC强转：<code>(int)a</code>      Swift强转：<code>Int(a)</code></li><li>关于BOOL类型更加严格 ，Swift不再是OC的非0就是真，而是true才是真false才是假</li><li>swift的 循环语句中必须加<code>{}</code>就算只有一行代码也必须要加</li><li>swift的switch语句后面可以跟各种数据类型了 ，如Int、字符串都行，并且里面不用写break（OC好像不能字符串）</li><li>swift  if后的括号可以省略: <code>if a&gt;b {}</code>，而OC里 if后面必须写括号。</li><li>swift打印  用<code>print(&quot;&quot;)</code>    打印变量时可以 <code>print(&quot;\(value)&quot;)</code>，不用像OC那样记很多<code>%@，d%</code>等。</li><li>Swift3的【Any】可以代表任何类型的值，无论是类、枚举、结构体还是任何其他Swift类型，这个对应OC中的【id】类型。</li><li>在 OC 中 <code>alloc / init</code>  对应<code>( )</code> </li><li>在 OC 中 alloc / initWithXXX 对应 (XXX: )</li><li>在 OC 中的类函数调用，在 Swift 中，直接使用 .</li><li>在 Swift 中，绝大多数可以省略 self.，建议一般不写，可以提高对语境的理解（闭包时会体会到）</li><li>在 OC 中的 枚举类型使用 UIButtonTypeContactAdd，而 Swift 中分开了，操作热键：回车<code>-&gt;</code> 向右 <code>-&gt;</code>.</li><li>Swift 中，枚举类型的前缀可以省略，如：<code>.ContactAdd</code>，但是：很多时候没有智能提示</li><li>监听方法，直接使用字符串引起</li></ul><h2 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h2><p>Objective-C中循环引用也是遇到比较多的，一不小心就会导致循环引用，甚至导致内存问题</p><h4 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h4><ul><li>[weak self]</li><li><p>self是可选项，如果self已经被释放，则为nil</p></li><li><p>[unowned self]</p></li><li>self不是可选项，如果self已经被释放，则出现野指针访问</li></ul><h4 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective-C"></a>Objective-C</h4><ul><li>__weak typeof(self) weakSelf;</li><li><p>如果self已经被释放，则为nil</p></li><li><p>__unsafe_unretained typeof(self) weakSelf;</p></li><li>如果self已经被释放，则出现野指针访问</li></ul><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>推荐几个Objective-C的框架</p><p><a href="http://www.jianshu.com/p/79d6a3a6a479" target="_blank" rel="noopener">FBRetainCycleDetector</a></p><p><a href="http://ios.jobbole.com/86719/" target="_blank" rel="noopener">PLeakSniffer</a></p><p><a href="http://www.jianshu.com/p/eb638ef69343" target="_blank" rel="noopener">MLeaksFinder</a></p>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> iOS——Objective-C与Swift优缺点对比 </tag>
            
            <tag> Objective-C与Swift优缺点对比 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS——App启动优化分析与总结</title>
      <link href="/2016/05/03/iOS%E2%80%94%E2%80%94App%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
      <url>/2016/05/03/iOS%E2%80%94%E2%80%94App%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>随着人们对App性能与实用要求越来越高，也随着大量iOS开发中的涌入，现如今已经不再是几年前会做简单App，然后开始开发，能写出一个可用功能的产品就可以了，于是，很多公司和开发者也开始关注和实战启动优化，因为App除了桌面Log，启动是也是夺得用户喜好最首要的条件，如果一个App每次启动都要几十秒甚至几分钟，你觉得你还会继续使用吗……</p><a id="more"></a><p>如果你对iOS开发中App的整个启动过程干兴趣，那么可以先看我之前分享的一个主题<br><a href="https://icocos.github.io/2017/06/28/iOS%E2%80%94%E2%80%94App%E6%95%B4%E4%B8%AA%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/">iOS——App整个启动过程分析 </a></p><p>当然关于启动优化，上面只是简单的提了一下，本文结合那篇文章进行详细分析</p><h2 id="启动优化准备"><a href="#启动优化准备" class="headerlink" title="启动优化准备"></a>启动优化准备</h2><h4 id="APP启动时间："><a href="#APP启动时间：" class="headerlink" title="APP启动时间："></a>APP启动时间：</h4><ul><li>t(App总启动时间) = t1(main()之前的加载时间) + t2(main()之后的加载时间)。</li></ul><blockquote><p>t1 = 系统dylib(动态链接库)和自身App可执行文件的加载；</p></blockquote><blockquote><p>t2 = main方法执行之后到AppDelegate类中的didFinishLaunchingWithOptions方法执行结束前这段时间，主要是构建第一个界面，并完成渲染展示。</p></blockquote><h3 id="前面我们分析了，Main之前和之后的加载过程"><a href="#前面我们分析了，Main之前和之后的加载过程" class="headerlink" title="前面我们分析了，Main之前和之后的加载过程"></a>前面我们分析了，Main之前和之后的加载过程</h3><h5 id="这里我们先简单介绍一下，之前没有详细说明的一些其中关联的技术："><a href="#这里我们先简单介绍一下，之前没有详细说明的一些其中关联的技术：" class="headerlink" title="这里我们先简单介绍一下，之前没有详细说明的一些其中关联的技术："></a>这里我们先简单介绍一下，之前没有详细说明的一些其中关联的技术：</h5><ul><li>App开始启动后，系统首先加载可执行文件（自身App的所有.o文件的集合），然后加载动态链接库dyld，dyld是一个专门用来加载动态链接库的库。<br>执行从dyld开始，dyld从可执行文件的依赖开始, 递归加载所有的依赖动态链接库。</li></ul><p>其实无论对于系统的动态链接库还是对于App本身的可执行文件而言，他们都算是image（镜像），而每个App都是以image(镜像)为单位进行加载的</p><blockquote><p>什么是image</p></blockquote><blockquote><p>1.executable可执行文件 比如.o文件。</p></blockquote><blockquote><p>2.dylib 动态链接库 framework就是动态链接库和相应资源包含在一起的一个文件夹结构。</p></blockquote><blockquote><p>3.bundle 资源文件 只能用dlopen加载，不推荐使用这种方式加载。</p></blockquote><p>注意：除了我们App本身的可行性文件，系统中所有的framework比如UIKit、Foundation等都是以动态链接库的方式集成进App中的。</p><blockquote><p>不同进程之间共用系统dylib的_TEXT区，但是各自维护对应的_DATA区。</p></blockquote><p>所有动态链接库和我们App中的静态库.a和所有类文件编译后的.o文件最终都是由dyld(the dynamic link editor)，Apple的动态链接器来加载到内存中。<br>每个image都是由一个叫做ImageLoader的类来负责加载（一一对应）</p><blockquote><p>是ImageLoader</p></blockquote><blockquote><p>image 表示一个二进制文件(可执行文件或 so 文件)，里面是被编译过的符号、代码等，</p></blockquote><blockquote><p>ImageLoader 作用是将这些文件加载进内存，且每一个文件对应一个ImageLoader实例来负责加载。</p></blockquote><h5 id="ImageLoader加载步骤分两步走："><a href="#ImageLoader加载步骤分两步走：" class="headerlink" title="ImageLoader加载步骤分两步走："></a>ImageLoader加载步骤分两步走：</h5><ul><li>在程序运行时它先将动态链接的 image 递归加载 (也就是上面测试栈中一串的递归调用的时刻)。</li><li>再从可执行文件 image 递归加载所有符号。</li></ul><h2 id="真正的启动优化："><a href="#真正的启动优化：" class="headerlink" title="真正的启动优化："></a>真正的启动优化：</h2><h3 id="Main之前："><a href="#Main之前：" class="headerlink" title="Main之前："></a>Main之前：</h3><p>检测方式：Apple提供了一种测量方法，在 Xcode 中 Edit scheme -&gt; Run -&gt; Auguments 将环境变量DYLD_PRINT_STATISTICS 设为1</p><blockquote><p>pre-main阶段</p><blockquote><p>1.1. 加载应用的可执行文件</p></blockquote></blockquote><blockquote><blockquote><p>1.2. 加载动态链接库加载器dyld（dynamic loader）</p></blockquote></blockquote><blockquote><blockquote><p>1.3. dyld递归加载应用所有依赖的dylib（dynamic library 动态链接库）</p></blockquote></blockquote><p>动态链接库的加载步骤具体分为5步：</p><ul><li>load dylibs image 读取库镜像文件</li><li>Rebase image</li><li>Bind image</li><li>Objc setup</li><li>initializers</li></ul><h4 id="load-dylibs-image"><a href="#load-dylibs-image" class="headerlink" title="load dylibs image"></a>load dylibs image</h4><p>在每个动态库的加载过程中， dyld需要：</p><ul><li>分析所依赖的动态库</li><li>找到动态库的mach-o文件</li><li>打开文件</li><li>验证文件</li><li>在系统核心注册文件签名</li><li>对动态库的每一个segment调用mmap()</li><li>通常的，一个App需要加载100到400个dylibs， 但是其中的系统库被优化，可以很快的加载。</li></ul><p>######&gt; 针对这一步骤的优化有：</p><ul><li>减少非系统库的依赖</li><li>尽量不使用内嵌（embedded）的dylib，加载内嵌dylib性能开销较大</li><li>合并已有的dylib和使用静态库（static archives），减少dylib的使用个数</li><li>使用静态资源，比如把代码加入主程序</li><li>懒加载dylib，但是要注意dlopen()可能造成一些问题，且实际上懒加载做的工作会更多</li></ul><h4 id="rebase-bind"><a href="#rebase-bind" class="headerlink" title="rebase/bind"></a>rebase/bind</h4><p>由于ASLR(address space layout randomization)的存在，可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不固定，所以需要这2步来修复镜像中的资源指针，来指向正确的地址。 rebase修复的是指向当前镜像内部的资源指针； 而bind指向的是镜像外部的资源指针。<br>rebase步骤先进行，需要把镜像读入内存，并以page为单位进行加密验证，保证不会被篡改，所以这一步的瓶颈在IO。bind在其后进行，由于要查询符号表，来指向跨镜像的资源，加上在rebase阶段，镜像已被读入和加密验证，所以这一步的瓶颈在于CPU计算。</p><p>通过命令行可以查看相关的资源指针:</p><p>xcrun dyldinfo -rebase -bind -lazy_bind myApp.App/myApp</p><p>优化该阶段的关键在于减少__DATA segment中的指针数量。</p><p>######&gt; 我们可以优化的点有：</p><ul><li>减少ObjC类（class）、方法（selector）、分类（category）的数量</li><li>减少C++虚函数数量（创建虚函数表有开销）</li><li>转而使用swift stuct（其实本质上就是为了减少符号的数量）</li></ul><h5 id="Objc-setup"><a href="#Objc-setup" class="headerlink" title="Objc setup"></a>Objc setup</h5><p>这一步主要工作是:</p><ul><li>注册Objc类 (class registration)</li><li>把category的定义插入方法列表 (category registration)</li><li>保证每一个selector唯一 (selctor uniquing)</li></ul><p>由于之前2步骤的优化，这一步实际上没有什么可做的。</p><h5 id="initializers"><a href="#initializers" class="headerlink" title="initializers"></a>initializers</h5><p>以上三步属于静态调整(fix-up)，都是在修改__DATA segment中的内容，而这里则开始动态调整，开始在堆和堆栈中写入内容。</p><p>在这里的工作有：</p><ul><li>Objc的+load()函数</li><li>C++的构造函数属性函数 形如attribute((constructor)) void DoSomeInitializationWork()</li><li>非基本类型的C++静态全局变量的创建(通常是类或结构体)(non-trivial initializer) 比如一个全局静态结构体的构建，如果在构造函数中有繁重的工作，那么会拖慢启动速度</li></ul><p>Objc的load函数和C++的静态构造函数采用由底向上的方式执行，来保证每个执行的方法，都可以找到所依赖的动态库。</p><p>+load方法断点的调用堆栈和顺序：</p><ul><li>dyld 开始将程序二进制文件初始化</li><li>交由 ImageLoader 读取 image，其中包含了我们的类、方法等各种符号</li><li>由于 runtime 向 dyld 绑定了回调，当 image 加载到内存后，dyld 会通知 runtime 进行处理</li><li>runtime 接手后调用 mapimages 做解析和处理，接下来 loadimages 中调用 callloadmethods 方法，遍历所有加载进来的 Class，按继承层级依次调用 Class 的 +load 方法和其 Category 的 +load 方法</li></ul><p>######&gt; 我们可以做的优化有：</p><ul><li>少在类的+load方法里做事情，尽量把这些事情推迟到+initiailize</li><li>减少构造器函数个数，在构造器函数里少做些事情</li><li>减少C++静态全局变量的个数</li></ul><p>至此，可执行文件中和动态库所有的符号(Class，Protocol，Selector，IMP，…)都已经按格式成功加载到内存中，被 runtime 所管理，再这之后，runtime 的那些方法(动态添加 Class、swizzle 等等才能生效)。</p><h4 id="到这里整个过程："><a href="#到这里整个过程：" class="headerlink" title="到这里整个过程："></a>到这里整个过程：</h4><blockquote><p>整个事件由 dyld 主导，完成运行环境的初始化后，配合 ImageLoader 将二进制文件按格式加载到内存， 动态链接依赖库，并由 runtime 负责加载成 objc 定义的结构，所有初始化工作结束后，dyld 调用真正的 main 函数。</p></blockquote><h3 id="总结优化点："><a href="#总结优化点：" class="headerlink" title="总结优化点："></a>总结优化点：</h3><ul><li>减少不必要的framework，因为动态链接比较耗时</li><li>check framework应当设为optional和required，如果该framework在当前App支持的所有iOS系统版本都存在，那么就设为required，否则就设为optional，因为optional会有些额外的检查</li><li>合并或者删减一些OC类，关于清理项目中没用到的类，使用工具AppCode代码检查功能，查到当前项目中没有用到的类如下：</li><li>删减一些无用的静态变量</li><li>删减没有被调用到或者已经废弃的方法</li><li>将不必须在+load方法中做的事情延迟到+initialize中</li><li>尽量不要用C++虚函数(创建虚函数表有开销)</li></ul><h3 id="Main之后："><a href="#Main之后：" class="headerlink" title="Main之后："></a>Main之后：</h3><p>检测方式：测量main()函数开始执行到didFinishLaunchingWithOptions执行结束的耗时，自己插入代码到工程。</p><blockquote><p>main()阶段</p><blockquote><p>2.1. dyld调用main()</p></blockquote></blockquote><blockquote><blockquote><p>2.2. 调用UIApplicationMain()</p></blockquote></blockquote><blockquote><blockquote><p>2.3. 调用applicationWillFinishLaunching</p></blockquote></blockquote><blockquote><blockquote><p>2.4. 调用didFinishLaunchingWithOptions</p></blockquote></blockquote><p>在main()被调用之后，App的主要工作就是初始化必要的服务，显示首页内容等。<br>而我们的优化也是围绕如何能够快速展现首页来开展。<br>App通常在AppDelegate类中的didFinishLaunchingWithOptions方法中创建首页需要展示的view，<br>然后在当前runloop的末尾，主动调用CA::Transaction::commit完成视图的渲染。</p><p>而视图的渲染主要涉及三个阶段：</p><ul><li>准备阶段 这里主要是图片的解码</li><li>布局阶段 首页所有UIView的- (void)layoutSubViews()运行</li><li>绘制阶段 首页所有UIView的- (void)drawRect:(CGRect)rect运行</li><li>再加上启动之后必要服务的启动、必要数据的创建和读取，这些就是我们可以尝试优化的地方</li></ul><h4 id="因此，对于main-函数调用之前我们可以优化的点有："><a href="#因此，对于main-函数调用之前我们可以优化的点有：" class="headerlink" title="因此，对于main()函数调用之前我们可以优化的点有："></a>因此，对于main()函数调用之前我们可以优化的点有：</h4><ul><li>不使用xib，直接视用代码加载首页视图</li><li>NSUserDefaults实际上是在Library文件夹下会生产一个plist文件，如果文件太大的话一次能读取到内存中可能很耗时，这个影响需要评估，如果耗时很大的话需要拆分(需考虑老版本覆盖安装兼容问题)</li><li>每次用NSLog方式打印会隐式的创建一个Calendar，因此需要删减启动时各业务方打的log，或者仅仅针对内测版输出log</li><li>梳理应用启动时发送的所有网络请求，是否可以统一在异步线程请求</li><li>梳理各个二方/三方库，找到可以延迟加载的库，做延迟加载处理，比如放到首页控制器的viewDidAppear方法里。</li><li>梳理业务逻辑，把可以延迟执行的逻辑，做延迟执行处理。比如检查新版本、注册推送通知等逻辑。</li><li>避免复杂/多余的计算。</li><li>避免在首页控制器的viewDidLoad和viewWillAppear做太多事情，这2个方法执行完，首页控制器才能显示，部分可以延迟创建的视图应做延迟创建/懒加载处理。</li><li>采用性能更好的API。</li><li>首页控制器用纯代码方式来构建。</li></ul><h3 id="总结：具体优化点"><a href="#总结：具体优化点" class="headerlink" title="总结：具体优化点"></a>总结：具体优化点</h3><ul><li>纯代码方式而不是storyboard加载首页UI。</li><li>对didFinishLaunching里的函数考虑能否挖掘可以延迟加载或者懒加载，需要与各个业务方pm和rd共同check 对于一些已经下线的业务，删减冗余代码。</li><li>对于一些与UI展示无关的业务，如微博认证过期检查、图片最大缓存空间设置等做延迟加载</li><li>对实现了+load()方法的类进行分析，尽量将load里的代码延后调用。</li><li>上面统计数据显示展示feed的导航控制器页面(NewsListViewController)比较耗时，对于viewDidLoad以及viewWillAppear方法中尽量去尝试少做，晚做，不做</li></ul><p>到这里之后其实已经差不多了，相信你应该有哪么写成就与收获。</p><h5 id="除了这些，我们还可以喂项目做一些缓存优化"><a href="#除了这些，我们还可以喂项目做一些缓存优化" class="headerlink" title="除了这些，我们还可以喂项目做一些缓存优化"></a>除了这些，我们还可以喂项目做一些缓存优化</h5><ul><li>ccache 等缓存方案</li><li>优化 Xcode 配置</li><li>加钱堆硬件</li></ul><p>以上优化方案出发点都是基础优化编译耗时来解决的。</p><p>哪有没有一个办法可以做到不编译就执行修改后的代码呢？</p><p>答案肯定是：有的</p><p>基于 Objective-C 的动态特性，是完全可以做到这一点的，这也是各种热修复框架的支撑原理之一。那么如果需要做到不编译就执行修改后的代码，我们可以这样做：</p><h5 id="获取本地修改后代码-gt-转-JavaScript-或-Lua-gt-模拟器执行修改后的脚本。"><a href="#获取本地修改后代码-gt-转-JavaScript-或-Lua-gt-模拟器执行修改后的脚本。" class="headerlink" title="获取本地修改后代码 -&gt; 转 JavaScript 或 Lua -&gt; 模拟器执行修改后的脚本。"></a>获取本地修改后代码 -&gt; 转 JavaScript 或 Lua -&gt; 模拟器执行修改后的脚本。</h5><ul><li>获取本地修改代码<ul><li>这里也有许多方法，可以手动复制，也可以自动获取。这里我是选择利用 Xcode Editor Extension 来获取到你选中的修改代码的。</li></ul></li><li>Objective-C 转 JavaScript<ul><li>由于整个流程我是基于 JSPatch 来开发的，所以是需要转为 JS 的脚本。这里我是写了个 node.js 的脚本来实现，转换算法是利用 <a href="https://github.com/bang590/JSPatchConvertor" target="_blank" rel="noopener">https://github.com/bang590/JSPatchConvertor</a> 中的开源代码。</li></ul></li><li>模拟器执行修改后的脚本<ul><li>由于已经有 JSPatch 完整的框架做支撑，这里只需要利用其中的方法 -[JPEngine evaluateScriptWithPath:] 去执行修改后的脚本即可。</li></ul></li></ul><blockquote><p>当然这种有一定的缺陷，不管是针对苹果审核，还是学习成本，或者是其他意向不到的问题</p></blockquote><blockquote><p>使用之前还是慎重考虑，可以适当的使用作为部分模块的优化，或者作为学习。</p></blockquote><p>至于后续的步骤就是，写好代码，逻辑，界面，优化……</p><h6 id="性能优化推荐：iOS应用性能调优的25个建议和技巧"><a href="#性能优化推荐：iOS应用性能调优的25个建议和技巧" class="headerlink" title="性能优化推荐：iOS应用性能调优的25个建议和技巧"></a>性能优化推荐：<a href="http://www.cocoachina.com/ios/20150408/11501.html" target="_blank" rel="noopener">iOS应用性能调优的25个建议和技巧</a></h6>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> iOS——App启动优化分析与总结 </tag>
            
            <tag> App启动优化分析与总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS——App整个启动过程分析</title>
      <link href="/2016/04/28/iOS%E2%80%94%E2%80%94App%E6%95%B4%E4%B8%AA%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
      <url>/2016/04/28/iOS%E2%80%94%E2%80%94App%E6%95%B4%E4%B8%AA%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>你想知道App是怎么显示到我们眼前的吗？你想知道点击Run之后发生了什么吗？你想知道在Main函数之前都还有那些你不知道操作吗？你想知道在Objective-C和Swift混编的时候这么处理AppDelegate吗？你想知道UIApplication都干了撒吗？你想知道怎么优化App启动过程吗？你想知道…..你撒都想知道，那还等什么？</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>本文的起因：</p></blockquote><blockquote><ol><li>前段时间在研究App启动相关内容，还有启动优化相关的东西，网上寻找了一下相关的资料并试着在整理，也自己试着去验证了其中的一些步骤。</li></ol></blockquote><blockquote><ol start="2"><li>公司项目是Objective-C版本的，大部分相关类都已经使用Swift重写了，后期新增的功能都使用的Swift混合开发。但是由于项目庞大又复杂，没有时间也没有精力去完全使用Swift重写。</li></ol></blockquote><blockquote><ol start="3"><li>因为从Swift一出来我就在学习，但是并没有在实际项目中应用到Swift，从1.0到2.0，再到3.0都有了解和学习相关的语法。但是近四年来一直都在使用OC和学习各种技术，以致于Swift其实该忘的也忘得差不多了。网上有句话：Swift从入门到入门。相信你既然都能看到这里，肯定明白其中的原因。所以我又开始重写学了一遍Swift，这一次是Swift3.1开始学，其实Swift4已经出来了，但是和3.1并没有太大的变化。</li></ol></blockquote><blockquote><ol start="4"><li>因为公司每个星期都有一个技术分享，所以我觉得去试一次，希望能把我知道的东西通过口述的方式分享出来。（不过分享的结果很差，毕竟是第一次，所以导致最后连我自己都不知道自己在说什么），同时这也是我在公司内部做的第一次技术分享的主题。</li></ol></blockquote><blockquote><ol start="5"><li>这一次，我希望能彻底从OC转到Swift进行实际开发。</li></ol></blockquote><h3 id="资料地址：-iOS——App整个启动过程分析。如果你觉得有用希望能给个star，或者有什么疑问欢迎issuse也欢迎联系我，谢谢！"><a href="#资料地址：-iOS——App整个启动过程分析。如果你觉得有用希望能给个star，或者有什么疑问欢迎issuse也欢迎联系我，谢谢！" class="headerlink" title="资料地址： iOS——App整个启动过程分析。如果你觉得有用希望能给个star，或者有什么疑问欢迎issuse也欢迎联系我，谢谢！"></a>资料地址：<a href="https://github.com/al1020119/iOS-App-Start-Up-Process" target="_blank" rel="noopener"> iOS——App整个启动过程分析</a>。如果你觉得有用希望能给个star，或者有什么疑问欢迎issuse也欢迎联系我，谢谢！</h3><p>首先申明，本文大部分会以理论和实际分析，不会涉及的太多的代码实战，也不会涉及到太多相关术语的解释，当然部分会给出链接地址，但是力求从下面几个问题并结合实际App的启动过程，让你了解代码之前所干的事情和处理实际开发中遇到的相关问题….</p><ul><li>点击Run之后发生了什么,以致App能够显示在我们的眼前？</li><li>Main函数之前苹果还为我们的App做了哪些操作？</li><li>OC项目中怎么使用Swift重写AppDelagate？</li><li>UIApplication&amp;UIApplicationMain背后做了什么？</li><li>如何优化App启动过程？<br>……</li></ul><p>本文篇幅会比较长，但是如果你能完全掌握里面的内容和应用，足以让你有一个质的提升，当然这是在你不了解上面我提到的情况下。</p><p>好了，废话说太多没有什么意思……开干！</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.001.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.002.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.003.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.004.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.005.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.006.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.007.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.008.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.009.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.010.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.011.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.012.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.013.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.014.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.015.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.016.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.017.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.018.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.019.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.020.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.021.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.022.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.023.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.024.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.025.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.026.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.027.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.028.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.029.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.030.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.031.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.032.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.033.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.034.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.035.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.036.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.037.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.038.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.039.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.040.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.041.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.042.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.043.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.044.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.045.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.046.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.047.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.048.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.049.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.050.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.051.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>2016 WWDC（苹果提供的启动优化方案）</p><p><a href="https://developer.apple.com/videos/play/wwdc2016/406/" target="_blank" rel="noopener">https://developer.apple.com/videos/play/wwdc2016/406/</a>                                    </p><p>优化 App 的启动时间（各个阶段优化与处理）</p><p><a href="http://ios.jobbole.com/90331/" target="_blank" rel="noopener">http://ios.jobbole.com/90331/</a></p><p>iOS 程序 main 函数之前发生了什么</p><p><a href="http://blog.sunnyxx.com/2014/08/30/objc-pre-main/" target="_blank" rel="noopener">http://blog.sunnyxx.com/2014/08/30/objc-pre-main/</a></p><p>点击 Run 之后发生了什么？（Build类似）</p><p><a href="http://www.jianshu.com/p/d5cf01424e92" target="_blank" rel="noopener">http://www.jianshu.com/p/d5cf01424e92</a></p><p>Xcode编译性能优化（各个阶段优化实战与对比）</p><p><a href="http://blog.csdn.net/qq_25131687/article/details/52194034" target="_blank" rel="noopener">http://blog.csdn.net/qq_25131687/article/details/52194034</a></p>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> iOS——App整个启动过程分析 </tag>
            
            <tag> App整个启动过程分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS——CocoaPods私有化组件</title>
      <link href="/2016/04/25/iOS%E2%80%94%E2%80%94CocoaPods%E7%A7%81%E6%9C%89%E5%8C%96%E7%BB%84%E4%BB%B6/"/>
      <url>/2016/04/25/iOS%E2%80%94%E2%80%94CocoaPods%E7%A7%81%E6%9C%89%E5%8C%96%E7%BB%84%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>相信你能看到这里，就一定用过cocoapods，cocoapods是什么呢？怎么用？算了吧，都是本文的范围，这里只介绍怎么将自己的项目组件进行私有化，其实严格来说不算什么私有化，只是，想自己写好的框架放到github或者其他平台上让他支持cocoapods管理。这类文章网上已经随处可见，但是由于打算开始写自己的框架，就记录了一下…..</p><a id="more"></a><p>首推荐</p><p><a href="http://blog.devtang.com/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/" target="_blank" rel="noopener">用CocoaPods做iOS程序的依赖管理</a></p><p><a href="https://objccn.io/issue-6-4/" target="_blank" rel="noopener">深入理解 CocoaPods</a></p><p><a href="https://github.com/Draveness/analyze/blob/master/contents/CocoaPods/CocoaPods%20都做了什么？.md" target="_blank" rel="noopener">CocoaPods 都做了什么?</a></p><p>如果你还不知道sm是CocoaPods，或者想对CocoaPods了解更深入一点的，可以先看看上面的推荐</p><h2 id="1-在github创建仓库完成，然后将仓库检出到本地"><a href="#1-在github创建仓库完成，然后将仓库检出到本地" class="headerlink" title="1. 在github创建仓库完成，然后将仓库检出到本地"></a>1. 在github创建仓库完成，然后将仓库检出到本地</h2><p>注意创建事项：</p><ol><li>LICENSE(许可证)文件不可缺少，否则检测spec文件时，会有警告（选择MIT就OK）</li><li>不要使用中文，最好和库名字直接对应</li><li>其实也可以在其他平台，不一定是github</li></ol><h2 id="2-将写好开源框架-库的Demo或者Example放到Git仓库下，"><a href="#2-将写好开源框架-库的Demo或者Example放到Git仓库下，" class="headerlink" title="2. 将写好开源框架/库的Demo或者Example放到Git仓库下，"></a>2. 将写好开源框架/库的Demo或者Example放到Git仓库下，</h2><p>还要将要开源的文件夹也放入到git仓库中（该文件夹在后面会被用到）</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/cocoapods/cocoapods001.png"></p><h2 id="3-项目发布到github后，我们在工程根目录中初始化一个Podspec文件："><a href="#3-项目发布到github后，我们在工程根目录中初始化一个Podspec文件：" class="headerlink" title="3. 项目发布到github后，我们在工程根目录中初始化一个Podspec文件："></a>3. 项目发布到github后，我们在工程根目录中初始化一个Podspec文件：</h2><p>创建自己项目的Podspec描述文件:</p><blockquote><p>pod spec create iCocos</p></blockquote><h2 id="4-编辑修改iCocos-podspec对应信息"><a href="#4-编辑修改iCocos-podspec对应信息" class="headerlink" title="4. 编辑修改iCocos.podspec对应信息"></a>4. 编辑修改iCocos.podspec对应信息</h2><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/cocoapods/cocoapods002.png"></p><p>可以直接参照我的内容进行修改</p><p>具体内容不介绍</p><ul><li>s.name：名称，pod search 搜索的关键词,注意这里一定要和.podspec的名称一样,否则报错</li><li>s.version：版本号</li><li>s.ios.deployment_target:支持的pod最低版本</li><li>s.summary: 简介</li><li>s.homepage:项目主页地址</li><li>s.license:许可证</li><li>s.author:作者</li><li>s.social_media_url:社交网址,这里我写的微博默认是Twitter,如果你写Twitter的话,你的podspec发布成功后会@你</li><li>s.source:项目的地址<ul><li>s.source = { :git =&gt; “<a href="https://github.com/al1020119/iCocos.git&quot;" target="_blank" rel="noopener">https://github.com/al1020119/iCocos.git&quot;</a>, :commit =&gt; “68defea” }</li><li>s.source = { :git =&gt; “<a href="https://github.com/al1020119/iCocos.git&quot;" target="_blank" rel="noopener">https://github.com/al1020119/iCocos.git&quot;</a>, :tag =&gt; 1.0.0 }</li><li>s.source = { :git =&gt; “<a href="https://github.com/al1020119/iCocos.git&quot;" target="_blank" rel="noopener">https://github.com/al1020119/iCocos.git&quot;</a>, :tag =&gt; s.version }</li></ul></li></ul><blockquote><p>commit =&gt; “68defea” 表示将这个Pod版本与Git仓库中某个commit绑定</p></blockquote><blockquote><p>tag =&gt; 1.0.0 表示将这个Pod版本与Git仓库中某个版本的comit绑定</p></blockquote><blockquote><p>tag =&gt; s.version 表示将这个Pod版本与Git仓库中相同版本的comit绑定</p></blockquote><ul><li>s.source_files:需要包含的源文件</li><li>s.resources: 资源文件</li><li>s.requires_arc: 是否支持ARC</li><li>s.dependency：依赖库，不能依赖未发布的库，如 s.dependency = ‘AFNetworking’</li><li>s.dependency：依赖库，如有多个可以这样写。我这里是托管在github上,所以这里将地址copy过来就行了。</li><li>source_files: 核心代码的文件地址。<ul><li>这里是经常出错的地方！—如果使用的是这种方式来显示核心代码地址而不是下面的模块化的话，</li><li>需要将代码文件必须以仓库名命名（也就意味着最多只有两个文件.h和.m文件了，可以有一个.h文件，把它作为头文件就行），这种方式检验podspec文件有点严格，否则就会报错。</li></ul></li><li>source_files:写法及含义建议大家写第一种或者第二种<ul><li><code>&quot;YJSettingTableView/*</code></li><li><code>&quot;&quot;YJSettingTableView/YJSettingTableView/*.{h,m}&quot;</code></li><li><code>&quot;YJSettingTableView/**/*.h&quot;</code></li></ul></li></ul><blockquote><p><code>“*”</code> 表示匹配所有文件</p></blockquote><blockquote><p><code>“*.{h,m}”</code> 表示匹配所有以<code>.h</code>和<code>.m</code>结尾的文件</p></blockquote><blockquote><p><code>“**”</code> 表示匹配所有子目录</p></blockquote><h2 id="5-设置tag号，提交修改（注：只要spec文件被修改，就必须重新执行如下命令）"><a href="#5-设置tag号，提交修改（注：只要spec文件被修改，就必须重新执行如下命令）" class="headerlink" title="5. 设置tag号，提交修改（注：只要spec文件被修改，就必须重新执行如下命令）"></a>5. 设置tag号，提交修改（注：只要spec文件被修改，就必须重新执行如下命令）</h2><p>因为cocoapods是依赖tag版本的,所以必须打tag,<br>以后再次更新只需要把你的项目打一个tag<br>然后修改.podspec文件中的版本接着提交到cocoapods官方就可以了,提交命令请看下面</p><ul><li>git commit -m “Release 1.0.0”  (先提交当前修改)</li><li>git tag “v1.0.0”            (添加tag) //为git打tag, 第一次需要在前面加一个v</li><li>git push –tags         (推送tag到远程)</li><li>git push origin master  (推送到远程到代码仓库)</li></ul><p>或许可能有些没有加入的（执行 git add . 就可以）</p><h2 id="6-提交之前先验证-podspec文件是否合法"><a href="#6-提交之前先验证-podspec文件是否合法" class="headerlink" title="6. 提交之前先验证.podspec文件是否合法"></a>6. 提交之前先验证.podspec文件是否合法</h2><ul><li>pod spec lint iCocos.podspec –verbose</li><li>pod spec lint iCocos.podspec –allow-warnings     (忽略警告)</li></ul><p>我这边在验证的时候出现了下面错误</p><blockquote><p>LiudeMacBook:iCocos a115$ pod spec lint iCocos.podspec –verbose</p></blockquote><pre><code>-&gt; iCocos (1.0.0)- ERROR | license: Sample license type.- ERROR | description: The description is empty.- ERROR | [iOS] unknown: Encountered an unknown error (The `iCocos` pod failed to validate due to 2 errors.[!] The validator for Swift projects uses Swift 3.0 by default, if you are using a different version of swift you can use a `.swift-version` file to set the version for your Pod. For example to use Swift 2.3, run:`echo &quot;2.3&quot; &gt; .swift-version`:- ERROR | license: Sample license type.- ERROR | description: The description is empty.) during validation.Analyzed 1 podspec.[!] The spec did not pass validation, due to 3 errors.[!] The validator for Swift projects uses Swift 3.0 by default, if you are using a different version of swift you can use a `.swift-version` file to set the version for your Pod. For example to use Swift 2.3, run:`echo &quot;2.3&quot; &gt; .swift-version`.</code></pre><p>根据上面提示了三个错误（due to 3 errors），其实是两个，1，3是一个</p><h3 id="1-description-is-empty"><a href="#1-description-is-empty" class="headerlink" title="1. description is empty"></a>1. description is empty</h3><p>这里原始description是这样的</p><pre><code>`s.description  = &lt;&lt;-DESC``DESC`</code></pre><p>需要改成一段属于自己的描述，其他信息类型修改</p><ol start="2"><li>关于swift-version</li></ol><p>这里直接执行<code>echo &quot;2.3&quot; &gt; .swift-version</code>就正常的</p><p>但是据需验证又出现如下错误：</p><blockquote><p>LiudeMacBook:iCocos a115$ pod spec lint iCocos.podspec</p></blockquote><pre><code>-&gt; iCocos (1.0.0)- ERROR | [iOS] unknown: Encountered an unknown error ([!] /usr/bin/git clone https://github.com/al1020119/iCocos.git /var/folders/4z/d12mnyfx7c37vg91t8h0941h0000gp/T/d20171025-8857-1oau87 --template= --single-branch --depth 1 --branch 1.0.0Cloning into &apos;/var/folders/4z/d12mnyfx7c37vg91t8h0941h0000gp/T/d20171025-8857-1oau87&apos;...warning: Could not find remote branch 1.0.0 to clone.fatal: Remote branch 1.0.0 not found in upstream origin) during validation.Analyzed 1 podspec.[!] The spec did not pass validation, due to 1 error.</code></pre><p>这里其实不是错误，是没有更新处理，前面说了：</p><blockquote><p>（注：只要spec文件被修改，就必须重新执行如下命令）</p></blockquote><pre><code>git commit -m &quot;Release 1.0.0&quot;  (先提交当前修改)git tag 1.0.0            (添加tag)git push --tags         (推送tag到远程)git push origin master  (推送到远程到代码仓库)</code></pre><p>或许可能有些没有加入的（执行 git add . 就可以）</p><h2 id="7-然后再次验证就会成功"><a href="#7-然后再次验证就会成功" class="headerlink" title="7. 然后再次验证就会成功"></a>7. 然后再次验证就会成功</h2><blockquote><p>LiudeMacBook:iCocos a115$ pod spec lint iCocos.podspec  –verbose</p></blockquote><pre><code>-&gt; iCocos (1.0.0)Analyzed 1 podspec.iCocos.podspec passed validation.</code></pre><p>或许你还可能遇到下面的错误，不过不要慌，直接按照下面操作就可以</p><pre><code>先删除tag// 删除本地taggit tag -d 1.0.0// 删除远程taggit push origin -d tag 1.0.0</code></pre><p>修改spec文件（必须修改相应的version和source）<br>重新执行–&gt;设置tag号，提交修改的步骤</p><h2 id="8-trunk推送podspec文件"><a href="#8-trunk推送podspec文件" class="headerlink" title="8. trunk推送podspec文件"></a>8. trunk推送podspec文件</h2><p>podspec文件验证成功，通过trunk推送podspec文件</p><pre><code>pod trunk push iCocos.podspec</code></pre><p>如果你是第一次，并且没有帐号你会看到下面一段</p><blockquote><p>LiudeMacBook:iCocos a115$ pod trunk push iCocos.podspec</p></blockquote><pre><code>[!] You need to register a session first.Usage:$ pod trunk push [PATH]Publish the podspec at `PATH` to make it available to all users of the ‘master’spec-repo. If `PATH` is not provided, defaults to the current directory.Before pushing the podspec to cocoapods.org, this will perform a local lint ofthe podspec, including a build of the library. However, it remains *your*responsibility to ensure that the published podspec will actually work for yourusers. Thus it is recommended that you *first* try to use the podspec tointegrate the library into your demo and/or real application.If this is the first time you publish a spec for this pod, you willautomatically be registered as the ‘owner’ of this pod. (Note that ‘owner’ inthis case implies a person that is allowed to publish new versions and add other‘owners’, not necessarily the library author.)Options:--allow-warnings           Allows push even if there are lint warnings--use-libraries            Linter uses static libraries to install the spec--swift-version=VERSION    The SWIFT_VERSION that should be used to lint the spec.This takes precedence over a .swift-version file.--skip-import-validation   Lint skips validating that the pod can be imported--skip-tests               Lint skips building and running tests during validation--silent                   Show nothing--verbose                  Show more debugging information--no-ansi                  Show output without ANSI codes--help                     Show help banner of specified command</code></pre><p>根据上面的提示是告诉你：需要你用邮箱注册一个trunk</p><h2 id="9-我们直接使用终端注册"><a href="#9-我们直接使用终端注册" class="headerlink" title="9. 我们直接使用终端注册"></a>9. 我们直接使用终端注册</h2><pre><code>pod trunk register al10201119@163.com &quot;iCocos&quot; --description=&quot;iCocos&quot;</code></pre><p>之后会有一封带有验证链接的邮件发送到你输入的邮箱，点击验证后就可以回来终端继续提交操作了。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/cocoapods/cocoapods003.png"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/cocoapods/cocoapods004.png"></p><p>已经注册过的不需要注册,怎么看自己有没有注册</p><pre><code>pod trunk me</code></pre><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/cocoapods/cocoapods005.png"></p><h2 id="10-发布代码到cocoapods"><a href="#10-发布代码到cocoapods" class="headerlink" title="10. 发布代码到cocoapods"></a>10. 发布代码到cocoapods</h2><pre><code>pod trunk push iCocos.podspec --verbosepod trunk push iCocos.podspec --allow-warnings</code></pre><p>发布时会验证 Pod 的有效性，如果你在手动验证 Pod 时使用了 –use-libraries 或 –allow-warnings 等修饰符，那么发布的时候也应该使用相同的字段修饰，否则出现相同的报错。</p><p>pod trunk push iCocos.podspec –verbose</p><p>一段很长的描述，然后你会看到下面的成功提示</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/cocoapods/cocoapods006.png"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/cocoapods/cocoapods007.png"></p><h2 id="11-如果提交到cocoapods还有可能遇到下面错误："><a href="#11-如果提交到cocoapods还有可能遇到下面错误：" class="headerlink" title="11. 如果提交到cocoapods还有可能遇到下面错误："></a>11. 如果提交到cocoapods还有可能遇到下面错误：</h2><pre><code>Updating spec repo &apos;master&apos;warning: inexact rename detection was skipped due to too many files.warning: you may want yo set your diff.renameLimit variable to at least 3080 an retry the command...[!] There was an error pushing a new version to trunk: execution expired</code></pre><p>这里有解决方案：<a href="http://www.sw33tcode.com/?p=31" target="_blank" rel="noopener">http://www.sw33tcode.com/?p=31</a></p><pre><code>git config merge.renameLimit 999999git config --unset merge.renameLimit</code></pre><h2 id="12-然后开始去搜索我的库了"><a href="#12-然后开始去搜索我的库了" class="headerlink" title="12. 然后开始去搜索我的库了"></a>12. 然后开始去搜索我的库了</h2><p>但是发现既然没有，各种排查，最后发现由于延时的问题，不过如果还是不出现的，网上找到了相应的方案：</p><blockquote><p>删除<code>~/Library/Caches/CocoaPods</code>目录下的<code>search_index.json</code>文件</p></blockquote><blockquote><p><code>pod setup</code>成功后会生成<code>~/Library/Caches/CocoaPods/search_index.json</code>文件。</p></blockquote><blockquote><p>终端输入<code>rm ~/Library/Caches/CocoaPods/search_index.json</code></p></blockquote><blockquote><p>删除成功后再执行pod search</p></blockquote><p>稍等片刻，然后<code>pod search</code>就会出现你所要搜的类库了。</p>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> iOS——CocoaPods私有化组件 </tag>
            
            <tag> CocoaPods私有化组件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Xcode Server完整教程</title>
      <link href="/2016/04/11/Xcode-Server%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/"/>
      <url>/2016/04/11/Xcode-Server%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>由于公司项目的需要，以及同事和测试人员的反馈，我们的打包服务器挂了，貌似之前经常挂（因为我桌旁的就是装有打包服务器的垃圾桶，在领用Mac之前，我都是用那个开发的）。其实之前我也一直想找个机会搞一下Xcode Server，记得还专门写过一篇总结，但是由于工作的原因，也由于帐号的原因就没去搞了，这一次刚好有这个机会，于是我专门放下手上所有的活，打算把这个东西弄好来………</p><a id="more"></a><blockquote><p>如果你对CI和CD已经足够了解，仅仅想知道怎么搞好Xcode Server，那么你可以直接从<code>准备</code>开始…</p></blockquote><h3 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h3><p>之前项目使用的是Jenkins，但是由于Jenkins的各种问题，配置，后面被换到了Xcode Server（当然除了他们我还可以选择Fantlane）。自从老大走了以后Xcode Server经常挂，导致测试人员不发打包测试，从而影响整体进度。而且这一次好像是彻底挂了，根本都进不去了…..</p><h3 id="常识："><a href="#常识：" class="headerlink" title="常识："></a>常识：</h3><h4 id="这里简单介绍一下Xcode-Server和常用的持续交付与继承工具（CI-amp-CD）。"><a href="#这里简单介绍一下Xcode-Server和常用的持续交付与继承工具（CI-amp-CD）。" class="headerlink" title="这里简单介绍一下Xcode Server和常用的持续交付与继承工具（CI&amp;CD）。"></a>这里简单介绍一下Xcode Server和常用的持续交付与继承工具（CI&amp;CD）。</h4><ul><li>xcodebuild - 由Apple开发，主要用于Xcode的构建和测试，有时可能难以想起，但可配置程度很高。</li><li>fastlane - 实际上并不是一个工具，而是一组可用于构建、测试、上传至iTunes Connect、供应配置文件管理、屏幕截图创建、dsym上传/下载至主要崩溃报告平台的一系列工具。</li><li>xctool和其他 - “其他”是指诸如nomad tools等工具，这些工具或者被弃用，或者逐渐缺少支持，或者即将被废弃。尽管Facebook在使用某种工具，但并不意味着这个工具依然可以得到妥善的维护。</li></ul><h4 id="服务器方面主要的选择包括："><a href="#服务器方面主要的选择包括：" class="headerlink" title="服务器方面主要的选择包括："></a>服务器方面主要的选择包括：</h4><ul><li>TravisCI/CircleCI - 托管式服务器，可免费用于开源项目，可随处访问，极为强大。相比Jenkins可配置的选项较少，仅支持与Github集成。用于私有代码库的价格高昂。</li><li>Xcode Server - 能与Xcode高度集成，实际上也是唯一可用于Xcode的服务器，由Apple开发，最有可能只需要少量配置即可投入使用。</li><li>Jenkins - CI服务器领域曾经的王者，有大量插件可用，可与各种其他产品集成，需要一定的配置和维护，但是非常强大。</li></ul><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>一般项目到了一定程度，或者公司和成员到了一定规模都会考虑自动化，当然也包括那些喜欢导致或者懒惰想一键打包发布的程序员。因此结合公司，项目或者个人的情况我们可以将整个过程进行拆分。</p><ul><li>构建并签署我们的所有不同特性的应用；</li><li>将我们的应用商店首选项上传至iTunes Connect；</li><li>将IPA、dSYM，以及变更日志上传至HockeyApp；</li><li>针对发布和开发分支持续不断地运行单元测试和UI测试；</li><li>构建每次合并请求（MR）并汇报测试结果；</li><li>进行持续不断地构建和签署，以确保没有引入新的问题。</li></ul><blockquote><p>由于时间的原因，也由于目前需求的原因，我们目前只需要进行打包发布相关操作，至于，分析，测试…</p></blockquote><p>看完上面之后，相信你知道我接下来要说的是什么，</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="OS-X工具下载"><a href="#OS-X工具下载" class="headerlink" title="OS X工具下载"></a>OS X工具下载</h3><ul><li>下载 OS X Server（付费开发者免费使用）</li><li>下载 Xcode</li></ul><p>这里就不多废话了，直接到苹果商店搜索就可以</p><h3 id="帐号与代码仓库地址"><a href="#帐号与代码仓库地址" class="headerlink" title="帐号与代码仓库地址"></a>帐号与代码仓库地址</h3><ul><li>开发者帐号（相关证书与描述文件）</li><li>git源代码仓库地址</li></ul><p>装备完了上面所需要的东西之后我们就可以开始配置和使用OS X Server了</p><h2 id="配置Xcode"><a href="#配置Xcode" class="headerlink" title="配置Xcode"></a>配置Xcode</h2><p>打开OS X Server，根据提示点击一步一步操作即可</p><ul><li>1 选择服务器主机：一般选自身，也可以指定IP</li><li>2 选择Xcode服务，开启服务（右上角）</li></ul><h4 id="老版配置页面"><a href="#老版配置页面" class="headerlink" title="老版配置页面"></a>老版配置页面</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/000.png"></p><p>这里需要注意，之前的配置方案是直接有</p><ul><li>权限和版本号：自己考虑，我这里默认设置不改了；</li><li>开发团队：使用自己的apple ID添加；</li><li>开发设备：需要用设备连接服务器后才能搜索到，初次连接，可能还需要在Status选项里面点击【Add to Teams】（比如设备不是你上面apple ID 的就需要）</li><li>查看Bot：会打开网页（Bot管理页面，默认127.0.01）,可以直接静态分析测试打包等，当然需要后面配置成功才能使用。</li></ul><h4 id="新版配置页面"><a href="#新版配置页面" class="headerlink" title="新版配置页面"></a>新版配置页面</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/001.png"></p><p>最新版本不知道为什么没有了对应的信息，根据提示信息应该的Xcode兼容性问题（因为：点击选择Xcode，选择指定Xcode之后提示是说版本不兼容）</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/002.png"></p><p>此时界面只有一个选择Xcode的按钮，点击进去就会直接进入到Server &amp; Bots</p><p>你会看到下面的界面</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/003.png"></p><blockquote><p>这里也可以直接在Xcode Preferences中打开，</p></blockquote><p>解锁后点击OFF&amp;ON进行开启服务，然后会提示Select Integration User（选择集成用户）</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/004.png"></p><p>这里我们一般都会新建一个用户，而不是直接使用服务器账户，然后填写对应的信息（帐号密码），这里要记住后面会有用</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/005.png"></p><p>点击创建之后就会执行一系列操作，对Xcode进行配置</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/006.png"></p><h5 id="具体执行操作有"><a href="#具体执行操作有" class="headerlink" title="具体执行操作有"></a>具体执行操作有</h5><ul><li>Saveing version information</li><li>Enableing developer model</li><li>Configuring SSL certificates</li><li>Starting Redis</li><li>initializing database</li><li>Starting API Server</li><li>Starting Apache</li><li>Starting control daemon</li><li>Starting Builder</li><li>Upgrading Xcode Server Data</li><li>Saveing version information</li></ul><p>完成后你会看到，一个提示新用户登录的提示，为了更好的进行测试和验证，我们都会先登录用户</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/007.png"></p><p>直接登录就可以，并且一步一步确认进入到子账户，子账户会提示：</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/008.png"></p><p>这里先不用管，切回到服务器账户就可以，这个时候，你就可以看到刚刚创建的账户已经出现了，并且处于登录状态，我们可以点击直接切换到对应账户，或者选择和重新创建多个账户，控制超时时间。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/009.png"></p><h2 id="登录账户"><a href="#登录账户" class="headerlink" title="登录账户"></a>登录账户</h2><p>在Xcode Preferences中选择Account，点击右下角添加账户，分别登录Apple ID，GitHub，Xcode Server</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/10.png"></p><h4 id="Apple-ID：对应开发者帐号，要和本地证书与描述文件对应"><a href="#Apple-ID：对应开发者帐号，要和本地证书与描述文件对应" class="headerlink" title="Apple ID：对应开发者帐号，要和本地证书与描述文件对应"></a>Apple ID：对应开发者帐号，要和本地证书与描述文件对应</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/11.png"></p><h4 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/12.png"></p><blockquote><p>注意:Source Control 需要打开才能使用！具体下面的各种自动自己考虑勾选；</p></blockquote><h4 id="Xcode-Server（如果使用Xcode-9-1最新版本，这一步已经不需要了，也就是说Xcode-9-1已经自带了Bots功能）"><a href="#Xcode-Server（如果使用Xcode-9-1最新版本，这一步已经不需要了，也就是说Xcode-9-1已经自带了Bots功能）" class="headerlink" title="Xcode Server（如果使用Xcode 9.1最新版本，这一步已经不需要了，也就是说Xcode 9.1已经自带了Bots功能）"></a>Xcode Server（如果使用Xcode 9.1最新版本，这一步已经不需要了，也就是说Xcode 9.1已经自带了Bots功能）</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/13.png"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/14.png"></p><blockquote><p>注意：Accounts 添加 Servers，一般默认自己主机，也可以选择指定IP地址，按服务器配置时对应选择；需要填写用户名，密码，自己搞定；</p></blockquote><p>完成帐号登录以后，可以适当下载更新一下证书文件</p><h2 id="配置Xcode-Server（如果使用Xcode-9-1最新版本，这一步已经不需要了，也就是说Xcode-9-1已经自带了Bots功能）"><a href="#配置Xcode-Server（如果使用Xcode-9-1最新版本，这一步已经不需要了，也就是说Xcode-9-1已经自带了Bots功能）" class="headerlink" title="配置Xcode Server（如果使用Xcode 9.1最新版本，这一步已经不需要了，也就是说Xcode 9.1已经自带了Bots功能）"></a>配置Xcode Server（如果使用Xcode 9.1最新版本，这一步已经不需要了，也就是说Xcode 9.1已经自带了Bots功能）</h2><p>再次打开Xcode Server，进入Xcode服务页面，点击打开Xcode，会直接打开Xcode Preferences中的Server &amp; Bots并开启对应账户，这里和前面操作一样，如果没有就根据提示直接确定或者输入对应的账号信息就可以（如果没有登录帐号的话）</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/16.png"></p><h2 id="创建Bots"><a href="#创建Bots" class="headerlink" title="创建Bots"></a>创建Bots</h2><blockquote><p>注意：自己的项目必须是个git文件夹，比如github上clone下来的项目，或者是本地服务器git来的，总之需要git文件夹；（官方文档使用Xcode的Source Control 方式搞定，具体可以看官方指南。我直接用了第三方软件SourceTree管理的）</p></blockquote><blockquote><p>这里由于我们是直接使用GitLab的，所以我直接从GitLab克隆了一分项目源码到本地文件夹。</p></blockquote><p>打开Xcode，保证项目编译正常的情况下创建Bots（这里可以直接点击Products-&gt;Create Bots）</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/61.png"></p><p>1 Bot命名与服务器选择，基本默认不改；<br>2 选择项目内容，后面的master，可选其他分支，比如develop；<br>3 Bot 操作配置<br>Scheme：默认项目本身<br>Actions：1分析；2单元测试（测试项目没开单元测试所有没的选）；3打包；<br>Cleaning：可以选择，因为是自己的电脑做服务器的，所以选择了一周清理一次；<br>Configuation：项目配置；<br>4 环境变量？没用过，sorry；<br>5 添加脚本，比如完成后发送个邮件通知；<br>6 create！注意 需要一次验证 git 的用户名和密码！不是之前设置的用户名与密码。<br>7 成功；各种信息以及完成的打包等；通过IP地址也可以实时整合并下载；</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/62.png"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/63.png"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/64.png"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/65.png"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/67.png"></p><p>当你看到一个类型这样的界面，说明已经配置并且创建Bots完成，具体是否正确，需要进行打包验证或者根据日志进行查找具体问题</p><blockquote><p>注意：</p></blockquote><blockquote><blockquote><p>如果在使用Xcode Server对应的分析，测试功能，还需要额外进行一些配置，由于时间的问题，这里我们暂时只使用打包功能。</p></blockquote></blockquote><blockquote><blockquote><p>打包配置需要选择InHouse</p></blockquote></blockquote><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/30.png"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/31.png"></p><h2 id="打包验证"><a href="#打包验证" class="headerlink" title="打包验证"></a>打包验证</h2><p>输入网址或者点击Xcode Perferences中的Account，点击Xcode Server对应的地址链接，进入网址（这里是icocos.local对应ip是10.0.6.7），这里可以在当前服务器进行操作，也可以在配置Xcode的时候创建的那个帐号进行操作，同意可以在内网的其他端系统或者浏览器进行操作</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/32.png"></p><p>然后就会有一打包的进度……</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/33.png"></p><h2 id="错误总结"><a href="#错误总结" class="headerlink" title="错误总结"></a>错误总结</h2><h4 id="错误问题一："><a href="#错误问题一：" class="headerlink" title="错误问题一："></a>错误问题一：</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/40.png"></p><ul><li>问题原因：</li><li>因为没有登录对应的Git帐号或者没有打包对应项目的workspace</li></ul><h4 id="错误问题二："><a href="#错误问题二：" class="headerlink" title="错误问题二："></a>错误问题二：</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/41.png"></p><ul><li>问题原因：</li><li>同样是因为没有登录对应的Git帐号</li></ul><h4 id="错误问题三："><a href="#错误问题三：" class="headerlink" title="错误问题三："></a>错误问题三：</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/43.png"></p><ul><li>问题原因：</li><li>同样是因为没有登录对应的Git帐号</li></ul><h4 id="错误问题四："><a href="#错误问题四：" class="headerlink" title="错误问题四："></a>错误问题四：</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/42.png"></p><ul><li>问题原因：</li><li>这里是由于创建Bots进行配置的时候，只需要打包功能就行了，那些什么分析,测试不需要,还有打包配置要选InHouse，不然打不了的</li></ul><h4 id="错误问题五："><a href="#错误问题五：" class="headerlink" title="错误问题五："></a>错误问题五：</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/45.png"></p><ul><li>问题原因：</li><li>由于升级了Xcode 9.1，和对应的Xcode Server不兼容，这里需要输入xcsd密码（也不知道是sm鬼），根据2017@swift大会的朋友经验：</li><li><code>备份/Library/Developer/XcodeServer，然后删除XcodeServer文件夹内容，重新前面的步骤就正常了。</code></li></ul><h4 id="错误问题六："><a href="#错误问题六：" class="headerlink" title="错误问题六："></a>错误问题六：</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/46.png"></p><ul><li>问题原因：</li><li>这其实不是sm错误 ，只是一个安全警告，解决方案：点击显示详细信息-&gt;继续访问网址，就可以了</li></ul><h4 id="错误问题七："><a href="#错误问题七：" class="headerlink" title="错误问题七："></a>错误问题七：</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/47.png"></p><ul><li>问题原因：</li><li>此问题困扰了很久，由于加入了GZIP库，但是….</li></ul><h4 id="错误问题八："><a href="#错误问题八：" class="headerlink" title="错误问题八："></a>错误问题八：</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/48.png"></p><ul><li>问题原因：</li><li>此问题困扰了很久，由于加入了GZIP库，但是….</li></ul><h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/91.png"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/92.png"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/93.png"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/94.png"></p><p>这些问题目前没有找到好的解决方案，根据提示查找发现，证书，前面都没有问题……</p><h2 id="总结一"><a href="#总结一" class="headerlink" title="总结一"></a>总结一</h2><p>最后根据最新经验总结，最新版本Xcode 9.1配置其实非常简单了</p><ol><li>配置Xcode Perferences中Server &amp; Bots</li><li>创建并登录帐号</li><li>Xcode Perferences登录git，app，server帐号</li><li>Clone远程Git源代码，并打开保证正常编译</li><li>Create Bots并配置</li><li>重启相关服务，Server，Bots，Xcode，开始打包</li></ol><blockquote><p>注意：</p></blockquote><blockquote><blockquote><p>关于代码提交，不管使用Xcode还是其他方式，是没有关系的，Xcode服务指向的是master或者其他分支的服务器资源；<br>关于打包，项目配置里就做好证书等配置文件的选择；<br>内测的ipa包，可以结合蒲公英等平台作分发也是很方便的；<br>考虑是不是可以搞个脚本上传。</p></blockquote></blockquote><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/87.png"></p><p>打包过程中</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/88.png"></p><blockquote><p>通过 Xcode 中的 Integrate 查看进度我们不难发现，其实整个过程和我们手动打包的过程是一样的</p></blockquote><p>打包完成</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/89.png"></p><p>但是这样可能享受不到OS X Server那样多而且好用的服务，不过如果只是需要简单的进行打包，配合测试进行验证，简单的发布引用还是可以满足的……..</p><h3 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h3><p>想了解更过关于Xcode Server配置与使用的，可以参考与学习下面的文章，笔者也是从下面的文章中一点一点学习的，并结合了朋友指点进行实战。</p><h5 id="3个官方文档："><a href="#3个官方文档：" class="headerlink" title="3个官方文档："></a>3个官方文档：</h5><ul><li><p><a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/PublishYourCodetoaSourceRepository.html#//apple_ref/doc/uid/TP40013292-CH8-SW1" target="_blank" rel="noopener">官方配置教程</a></p></li><li><p><a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/index.html#//apple_ref/doc/uid/TP40013292-CH1-SW1" target="_blank" rel="noopener">苹果开发指南</a></p></li><li><p><a href="https://help.apple.com/serverapp/mac/4.0/#/apd9148CA5C-96E5-43AC-97CE-CB1B1002F4DE" target="_blank" rel="noopener">OS X Server 帮助</a></p></li></ul><h5 id="简书教程："><a href="#简书教程：" class="headerlink" title="简书教程："></a>简书教程：</h5><ul><li><a href="http://www.jianshu.com/p/80cf70edfe27" target="_blank" rel="noopener">OS X Server 之 Xcode服务</a></li></ul><h5 id="手动打包流程"><a href="#手动打包流程" class="headerlink" title="手动打包流程"></a>手动打包流程</h5><ul><li><a href="http://www.jianshu.com/p/817686897ec1?open_source=weibo_search" target="_blank" rel="noopener">iOS App打包上架超详细流程</a></li></ul>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Xcode Server </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS——重整iOS技术（Fastlane完整打包流程）</title>
      <link href="/2016/04/09/iOS%E2%80%94%E2%80%94%E9%87%8D%E6%95%B4iOS%E6%8A%80%E6%9C%AF%EF%BC%88Fastlane%E5%AE%8C%E6%95%B4%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B%EF%BC%89/"/>
      <url>/2016/04/09/iOS%E2%80%94%E2%80%94%E9%87%8D%E6%95%B4iOS%E6%8A%80%E6%9C%AF%EF%BC%88Fastlane%E5%AE%8C%E6%95%B4%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>自从去年中旬电脑被我整挂了之后，大部分插件和脚本配置都失效了，重新安装也试了好几次，最近上班要上线了，不得不重新整理和配置一下，还好没有遇到什么坑……</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>项目即将进入阶段，每次都要点击那么多，频繁的打包脑子都要晕了，习惯了之前一行命令就搞定的我，只能花一个晚上加班整回之前的Fastlane。</p></blockquote><blockquote><p> 本文采用的方案是：Fastlane + 蒲公英 + ……。</p><blockquote><p>关于具体发布状态可以在这里（app-store, package, ad-hoc, enterprise, development）改，<br>当然后面会结合App store发布最近本文内容，同时支持jenkins或者其他持续集成系统.</p></blockquote></blockquote><h3 id="Fastlane安装"><a href="#Fastlane安装" class="headerlink" title="Fastlane安装"></a>Fastlane安装</h3><p>Fastlane是一套使用Ruby写的自动化工具集，用于iOS和Android的自动化打包、发布等工作，可以节省大量的时间。</p><p>安装过程如下：</p><h4 id="1-检查Ruby版本，需要2-0及以上版本。在终端输入以下命令确认："><a href="#1-检查Ruby版本，需要2-0及以上版本。在终端输入以下命令确认：" class="headerlink" title="1.检查Ruby版本，需要2.0及以上版本。在终端输入以下命令确认："></a>1.检查Ruby版本，需要2.0及以上版本。在终端输入以下命令确认：</h4><pre><code>ruby -v</code></pre><p>需要注意的是需要将gem的source改为<a href="https://gems.ruby-china.org/。" target="_blank" rel="noopener">https://gems.ruby-china.org/。</a><br>如何检查?在终端输入以下命令:</p><pre><code>gem sources</code></pre><p>结果应为：</p><pre><code>*** CURRENT SOURCES ***https://gems.ruby-china.org/</code></pre><h4 id="2-检查Xcode命令行工具是否安装。在终端输入以下命令："><a href="#2-检查Xcode命令行工具是否安装。在终端输入以下命令：" class="headerlink" title="2.检查Xcode命令行工具是否安装。在终端输入以下命令："></a>2.检查Xcode命令行工具是否安装。在终端输入以下命令：</h4><pre><code>xcode-select --install</code></pre><p>如果没有安装会进行安装。如果已经安装了则会提示：</p><pre><code>xcode-select: error: command line tools are already installed, use &quot;Software Update&quot; to install updates</code></pre><p> <img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0001.png" alt="曹理鹏(iCocos)-梦工厂"></p><h4 id="3-安装Fastlane"><a href="#3-安装Fastlane" class="headerlink" title="3.安装Fastlane"></a>3.安装Fastlane</h4><pre><code>sudo gem install fastlane --verbose</code></pre><p>如果出现以下错误：</p><pre><code>ERROR:  While executing gem ... (Errno::EPERM)    Operation not permitted - /usr/bin/rougify</code></pre><p>则输入以下命令：</p><pre><code>sudo gem install -n /usr/local/bin fastlane</code></pre><p> <img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0002.png" alt="曹理鹏(iCocos)-梦工厂"></p><h4 id="4-检查Fastlane是否正确安装。输入以下命令："><a href="#4-检查Fastlane是否正确安装。输入以下命令：" class="headerlink" title="4.检查Fastlane是否正确安装。输入以下命令："></a>4.检查Fastlane是否正确安装。输入以下命令：</h4><pre><code>fastlane --version</code></pre><p> <img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0003.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>可以看到Fastlane版本信息，我的是2.85.0。</p><h3 id="蒲公英的Fastlane插件安装"><a href="#蒲公英的Fastlane插件安装" class="headerlink" title="蒲公英的Fastlane插件安装"></a>蒲公英的Fastlane插件安装</h3><p>打开终端，进入你的项目工程的根目录，输入以下命令：</p><pre><code>fastlane add_plugin pgyer</code></pre><p>出现</p><pre><code>Plugin &apos;fastlane-plugin-pgyer&apos; was added to &apos;./fastlane/Pluginfile&apos;It looks like fastlane plugins are not yet set up for this project.fastlane will create a new Gemfile at path &apos;Gemfile&apos;This change is necessary for fastlane plugins to workShould fastlane modify the Gemfile at path &apos;Gemfile&apos; for you?(y/n)</code></pre><p>输入y按回车，出现</p><pre><code>Installing plugin dependencies...Successfully installed plugins</code></pre><p>便是安装成功了。</p><p> <img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0004.png" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="Fastlane配置"><a href="#Fastlane配置" class="headerlink" title="Fastlane配置"></a>Fastlane配置</h3><h4 id="1-打开终端，进入你的项目工程的根目录，输入以下命令："><a href="#1-打开终端，进入你的项目工程的根目录，输入以下命令：" class="headerlink" title="1.打开终端，进入你的项目工程的根目录，输入以下命令："></a>1.打开终端，进入你的项目工程的根目录，输入以下命令：</h4><pre><code>fastlane init</code></pre><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0005.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>中间会让你输入苹果开发者账号的账号和密码，之后会在你项目工程的目录下生成一个fastlane文件夹，里面有Fastlane的配置文件，一个是Appfile文件，一个是Fastfile文件(如果要上传AppStore的话还有Deliverfile文件)。Appfile保存苹果开发者的相关信息、项目的相关信息等。Fastfile是运行脚本。</p><p> <img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0006.png" alt="曹理鹏(iCocos)-梦工厂"></p><h4 id="2-编辑Fastfile文件"><a href="#2-编辑Fastfile文件" class="headerlink" title="2.编辑Fastfile文件"></a>2.编辑Fastfile文件</h4><p>有时候一天需要打好几个包，为了区分，我们这里实现一个递增build号的功能。</p><h5 id="1-修改项目工程配置"><a href="#1-修改项目工程配置" class="headerlink" title="(1)修改项目工程配置"></a>(1)修改项目工程配置</h5><ul><li>修改Build Settings中的Versioning配置，Current Project Version随便填一个，Versioning System选择Apple Generic。</li></ul><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0007.png" alt="曹理鹏(iCocos)-梦工厂"></p><ul><li><p>修改Info.plist File路径</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0008.png" alt="曹理鹏(iCocos)-梦工厂"></p></li></ul><h5 id="2-定义一个递增build号的函数，添加到Fastfile中"><a href="#2-定义一个递增build号的函数，添加到Fastfile中" class="headerlink" title="(2)定义一个递增build号的函数，添加到Fastfile中"></a>(2)定义一个递增build号的函数，添加到Fastfile中</h5><pre><code>def updateProjectBuildNumbercurrentTime = Time.new.strftime(&quot;%Y%m%d&quot;)build = get_build_number()if build.include?&quot;#{currentTime}.&quot;# =&gt; 为当天版本 计算迭代版本号lastStr = build[build.length-2..build.length-1]lastNum = lastStr.to_ilastNum = lastNum + 1lastStr = lastNum.to_sif lastNum &lt; 10lastStr = lastStr.insert(0,&quot;0&quot;)endbuild = &quot;#{currentTime}.#{lastStr}&quot;else# =&gt; 非当天版本 build 号重置build = &quot;#{currentTime}.01&quot;endputs(&quot;*************| 更新build #{build} |*************&quot;)# =&gt; 更改项目 build 号increment_build_number(build_number: &quot;#{build}&quot;)end</code></pre><h6 id="实现自动打包的完整Fastfile如下：可以直接拷贝修改"><a href="#实现自动打包的完整Fastfile如下：可以直接拷贝修改" class="headerlink" title="实现自动打包的完整Fastfile如下：可以直接拷贝修改"></a>实现自动打包的完整Fastfile如下：可以直接拷贝修改</h6><pre><code># 定义fastlane版本号 ---- 修改fastlane_version &quot;2.85.0&quot;# 定义打包平台default_platform :iosdef updateProjectBuildNumbercurrentTime = Time.new.strftime(&quot;%Y%m%d&quot;)build = get_build_number()if build.include?&quot;#{currentTime}.&quot;# =&gt; 为当天版本 计算迭代版本号lastStr = build[build.length-2..build.length-1]lastNum = lastStr.to_ilastNum = lastNum + 1lastStr = lastNum.to_sif lastNum &lt; 10lastStr = lastStr.insert(0,&quot;0&quot;)endbuild = &quot;#{currentTime}.#{lastStr}&quot;else# =&gt; 非当天版本 build 号重置build = &quot;#{currentTime}.01&quot;endputs(&quot;*************| 更新build #{build} |*************&quot;)# =&gt; 更改项目 build 号increment_build_number(build_number: &quot;#{build}&quot;)end#指定项目的scheme名称 ---- 修改scheme=&quot;Fiction_iOS&quot;#蒲公英api_key和user_key ---- 修改api_key=&quot;264c007c340157969a5e4da77637e60f&quot;user_key=&quot;3fdffa475f545097333473b980765ce1&quot;# 任务脚本platform :ios dolane :development_build do|options|branch = options[:branch]puts &quot;开始打development ipa&quot;updateProjectBuildNumber #更改项目build号# 开始打包gym(#输出的ipa名称output_name:&quot;#{scheme}_#{get_build_number()}&quot;,# 是否清空以前的编译信息 true：是clean:true,# 指定打包方式，Release 或者 Debugconfiguration:&quot;Release&quot;,# 指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, developmentexport_method:&quot;development&quot;,# 指定输出文件夹output_directory:&quot;./fastlane/build&quot;,)puts &quot;开始上传蒲公英&quot;# 开始上传蒲公英pgyer(api_key: &quot;#{api_key}&quot;, user_key: &quot;#{user_key}&quot;)endend</code></pre><blockquote><p>注意：<br>蒲公英的 api_key 和 user_key，开发者在自己账号下的 账号设置-API信息 中可以找到。打其它类型的包的方法与development类似，可自定义一个新的lane实现。</p></blockquote><h4 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h4><ul><li><p>在终端输入</p><ul><li>fastlane development_build</li></ul></li></ul><p>便会进行自动打包并上传蒲公英了。</p><h4 id="下面以执行流程"><a href="#下面以执行流程" class="headerlink" title="下面以执行流程"></a>下面以执行流程</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0009.png" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0010.png" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0011.png" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0012.png" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0013.png" alt="曹理鹏(iCocos)-梦工厂"></p><h4 id="下面以执行结果"><a href="#下面以执行结果" class="headerlink" title="下面以执行结果"></a>下面以执行结果</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0015.png" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0014.png" alt="曹理鹏(iCocos)-梦工厂"></p><h4 id="再来三张：入口，选项与结果"><a href="#再来三张：入口，选项与结果" class="headerlink" title="再来三张：入口，选项与结果"></a>再来三张：入口，选项与结果</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/000.png" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/111.png" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/222.png" alt="曹理鹏(iCocos)-梦工厂"></p>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> iOS——重整iOS技术（Fastlane完整打包流程） </tag>
            
            <tag> 重整iOS技术（Fastlane完整打包流程） </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS——自动打包上传</title>
      <link href="/2016/04/04/iOS%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0/"/>
      <url>/2016/04/04/iOS%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0/</url>
      <content type="html"><![CDATA[<p>为了不去每次都做这些繁琐的操作，我们只能做一个懒得程序狗，也就是将整个过程进行脚本化……</p><a id="more"></a><p>之前写过一篇关于自动打包上传代码的教程，最近又开始需要上线APP，发现新版的Mac对之前的教程不支持了，就换了一种方式，这次试用fir.</p><p><a href="http://al1020119.github.io/blog/2016/12/26/ios-daobao/" target="_blank" rel="noopener">http://al1020119.github.io/blog/2016/12/26/ios-daobao/</a></p><h2 id="工作中一般两种情况，"><a href="#工作中一般两种情况，" class="headerlink" title="工作中一般两种情况，"></a>工作中一般两种情况，</h2><pre><code>1.打包Ad-Hoc给测试人员，或者内部人员测试2.打包product发布到App Store</code></pre><p>所以，为了不去每次都做这些繁琐的操作，我们只能做一个懒得程序狗，也就是将整个过程进行脚本化</p><h3 id="大概的步骤是"><a href="#大概的步骤是" class="headerlink" title="大概的步骤是"></a>大概的步骤是</h3><pre><code>写个bash脚本，执行自动打包iOS版本，到指定的目录 （有条件的公司，可以自己搭个小服务器，这样谁都可以随时随地的打包）将打包好的文件上传到fir.im (当然上传到自己公司的服务器或者任何地方都行，只是fir.im我一直用，觉得比较方便)开发一个内部使用的类似APPStore，上面放着自己公司的所有APP,每次有更新的时候，测试童鞋直接通过这个自己下载新APP就可以了</code></pre><h2 id="主要命令"><a href="#主要命令" class="headerlink" title="主要命令"></a>主要命令</h2><h3 id="编译workspace"><a href="#编译workspace" class="headerlink" title="编译workspace"></a>编译workspace</h3><pre><code>xcodebuild -workspace workspacename -scheme schemename -configuration [-configuration configurationname] clean build SYMROOT=(SYMROOT)</code></pre><h3 id="编译project"><a href="#编译project" class="headerlink" title="编译project"></a>编译project</h3><pre><code>xcodebuild -target targetname -configuration [-configuration configurationname] clean build SYMROOT=(SYMROOT)</code></pre><h3 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h3><pre><code>xcodebuild -list</code></pre><h3 id="xcrun打包ipa"><a href="#xcrun打包ipa" class="headerlink" title="xcrun打包ipa"></a>xcrun打包ipa</h3><pre><code>xcrun -sdk iphoneos PackageApplication -v projectName.app -o ipaName.ipa</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><pre><code>在终端输入：xcodebuild –help 或 –h查看具体的选项显示xcodebuildversion：xcodebuild –version显示当前系统安装的sdk：xcodebuild –showsdks显示当前目录下project Information：xcodebuild –list</code></pre><h3 id="xcodebuild-amp-xcrun"><a href="#xcodebuild-amp-xcrun" class="headerlink" title="xcodebuild&amp;xcrun"></a>xcodebuild&amp;xcrun</h3><pre><code>xcodebuild-&gt;Buildxcrun-&gt;Api</code></pre><h3 id="终端查看对应版本"><a href="#终端查看对应版本" class="headerlink" title="终端查看对应版本"></a>终端查看对应版本</h3><pre><code>iCocosdeiMac:115科技 iCocos$ xcrun --versionxcrun version 31.iCocosdeiMac:115科技 iCocos$ xcodebuild -versionXcode 8.2.1Build version 8C1002</code></pre><h3 id="xcodebuild-是苹果提供的打包项目或者工程的命令"><a href="#xcodebuild-是苹果提供的打包项目或者工程的命令" class="headerlink" title="xcodebuild 是苹果提供的打包项目或者工程的命令"></a>xcodebuild 是苹果提供的打包项目或者工程的命令</h3><pre><code>需要在包含 name.xcodeproj 的目录下执行 xcodebuild 命令，且如果该目录下有多个 projects，那么需要使用 -project 指定需要 build 的项目。在不指定 build 的 target 的时候，默认情况下会 build project 下的第一个 target当 build workspace 时，需要同时指定 -workspace 和 -scheme 参数，scheme 参数控制了哪些 targets 会被 build 以及以怎样的方式 build。有一些诸如 -list, -showBuildSettings, -showsdks 的参数可以查看项目或者工程的信息，不会对 build action 造成任何影响，放心使用。</code></pre><h3 id="使用xcodebuild和xcrun打包签名"><a href="#使用xcodebuild和xcrun打包签名" class="headerlink" title="使用xcodebuild和xcrun打包签名"></a>使用xcodebuild和xcrun打包签名</h3><p>我这里就使用公司项目作为测试，方便查找问题和后续打包上传</p><h3 id="1-终端输入"><a href="#1-终端输入" class="headerlink" title="1. 终端输入"></a>1. 终端输入</h3><pre><code>xcodebuild -project T 115科技.xcodeproj -target 115科技 -configuration Release xcodebuild -project T 曹理鹏(iCocos)-梦工厂.xcodeproj -target 曹理鹏(iCocos)-梦工厂 -configuration Debug </code></pre><h3 id="这是骚等所有走完之后就能看到对应的信息，表示build成功"><a href="#这是骚等所有走完之后就能看到对应的信息，表示build成功" class="headerlink" title="这是骚等所有走完之后就能看到对应的信息，表示build成功"></a>这是骚等所有走完之后就能看到对应的信息，表示build成功</h3><pre><code>Signing Identity: &quot;iPhone Developer: xxx(59xxxxxx)&quot;Provisioning Profile: &quot;iOS Team Provisioning Profile: *&quot;</code></pre><h3 id="且在该目录下会多出一个-build-目录，该目录下有-Release-iphoneos-和-曹理鹏-iCocos-梦工厂-build-文件，根据我们-build-configuration-配置的参数不同，Release-iphoneos-的文件名会不同。"><a href="#且在该目录下会多出一个-build-目录，该目录下有-Release-iphoneos-和-曹理鹏-iCocos-梦工厂-build-文件，根据我们-build-configuration-配置的参数不同，Release-iphoneos-的文件名会不同。" class="headerlink" title="且在该目录下会多出一个 build 目录，该目录下有 Release-iphoneos 和 曹理鹏(iCocos)-梦工厂.build 文件，根据我们 build -configuration 配置的参数不同，Release-iphoneos 的文件名会不同。"></a>且在该目录下会多出一个 build 目录，该目录下有 Release-iphoneos 和 曹理鹏(iCocos)-梦工厂.build 文件，根据我们 build -configuration 配置的参数不同，Release-iphoneos 的文件名会不同。</h3><p>在 Release-iphoneos 文件夹下，有我们需要的曹理鹏(iCocos)-梦工厂.app文件，但是要安装到真机上，我们需要将该文件导出为ipa文件，这里使用 xcrun 命令。</p><pre><code>xcrun -sdk iphoneos -v PackageApplication ./build/Release-iphoneos/曹理鹏(iCocos)-梦工厂.app -o ~/Desktop/曹理鹏(iCocos)-梦工厂.ipa</code></pre><p>这个时候桌面上就会出现一个曹理鹏(iCocos)-梦工厂.ipa文件，这就是我们平时Archive之后的问题，也正是我们所需要的ipa包</p><h3 id="但是xcodebuild期间我出现了一个这样的错误"><a href="#但是xcodebuild期间我出现了一个这样的错误" class="headerlink" title="但是xcodebuild期间我出现了一个这样的错误"></a>但是xcodebuild期间我出现了一个这样的错误</h3><pre><code>ld: library not found for -lAFNetworkingclang: error: linker command failed with exit code 1 (use -v to see invocation)** BUILD FAILED **The following build commands failed:Ld build/曹理鹏(iCocos)-梦工厂.build/Release-iphoneos/曹理鹏(iCocos)-梦工厂.build/Objects-normal/armv7/曹理鹏(iCocos)-梦工厂 normal armv7Ld build/曹理鹏(iCocos)-梦工厂.build/Release-iphoneos/曹理鹏(iCocos)-梦工厂.build/Objects-normal/arm64/曹理鹏(iCocos)-梦工厂 normal arm64(2 failures)</code></pre><h3 id="貌似是linker-command-failed-with-exit-code-1经典错误，但是然并卵，于是看了一下pingpong从零开始写个自动打包IPA脚本中的build方式，也有类似的问题。多谢pingpong帮我解决了这个问题。"><a href="#貌似是linker-command-failed-with-exit-code-1经典错误，但是然并卵，于是看了一下pingpong从零开始写个自动打包IPA脚本中的build方式，也有类似的问题。多谢pingpong帮我解决了这个问题。" class="headerlink" title="貌似是linker command failed with exit code 1经典错误，但是然并卵，于是看了一下pingpong从零开始写个自动打包IPA脚本中的build方式，也有类似的问题。多谢pingpong帮我解决了这个问题。"></a>貌似是linker command failed with exit code 1经典错误，但是然并卵，于是看了一下pingpong<a href="http://www.jianshu.com/p/97c97c2ec1ca" target="_blank" rel="noopener">从零开始写个自动打包IPA脚本</a>中的build方式，也有类似的问题。多谢pingpong帮我解决了这个问题。</h3><pre><code>iCocosdeiMac ios (develop) $ xcodebuild2016-05-02 13:05:04.623 xcodebuild[1015:16272] [MT] PluginLoading: Required plug-in compatibility UUID ACA8656B-FEA8-4B6D-8E4A-93F4C95C362C for plug-in at path &apos;~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/XcodeColors.xcplugin&apos; not present in DVTPlugInCompatibilityUUIDs2016-05-02 13:05:04.625 xcodebuild[1015:16272] [MT] PluginLoading: Required plug-in compatibility UUID ACA8656B-FEA8-4B6D-8E4A-93F4C95C362C for plug-in at path &apos;~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/OMColorSense.xcplugin&apos; not present in DVTPlugInCompatibilityUUIDs=== BUILD TARGET xxx OF PROJECT xxx WITH THE DEFAULT CONFIGURATION (Release) ===Check dependenciesWrite auxiliary fileswrite-file /Users/iCocos/Documents/code/xxx/ios/build/xxx.build/Release-iphoneos/xxx.build/xxx.hmapwrite-file /Users/iCocos/Documents/code/xxx/ios/build/xxx.build/Release-iphoneos/xxx.build/xxx-own-target-headers.hmapwrite-file /Users/iCocos/Documents/code/xxx/ios/build/xxx.build/Release-iphoneos/xxx.build/Script-492B764475E022A63FB67F55.sh</code></pre><h3 id="解决方案是：执行xcodebuild需要指定你所需要对应的workspace和scheme"><a href="#解决方案是：执行xcodebuild需要指定你所需要对应的workspace和scheme" class="headerlink" title="解决方案是：执行xcodebuild需要指定你所需要对应的workspace和scheme"></a>解决方案是：执行xcodebuild需要指定你所需要对应的workspace和scheme</h3><pre><code>xcodebuild -workspace /Users/iCocos/Desktop/MBA/最新Git源代码/曹理鹏(iCocos)-梦工厂/曹理鹏(iCocos)-梦工厂.xcworkspace -scheme 曹理鹏(iCocos)-梦工厂</code></pre><h3 id="执行前，先查看下-list-这个可以知道xcodebuild命令下对应的参数需要填写的内容"><a href="#执行前，先查看下-list-这个可以知道xcodebuild命令下对应的参数需要填写的内容" class="headerlink" title="执行前，先查看下-list,这个可以知道xcodebuild命令下对应的参数需要填写的内容"></a>执行前，先查看下-list,这个可以知道xcodebuild命令下对应的参数需要填写的内容</h3><pre><code>iCocosdeiMac ios (develop) $ xcodebuild -list2016-05-02 15:24:26.656 xcodebuild[16535:154176] [MT] PluginLoading: Required plug-in compatibility UUID ACA8656B-FEA8-4B6D-8E4A-93F4C95C362C for plug-in at path &apos;~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/XcodeColors.xcplugin&apos; not present in DVTPlugInCompatibilityUUIDs2016-05-02 15:24:26.661 xcodebuild[16535:154176] [MT] PluginLoading: Required plug-in compatibility UUID ACA8656B-FEA8-4B6D-8E4A-93F4C95C362C for plug-in at path &apos;~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/OMColorSense.xcplugin&apos; not present in DVTPlugInCompatibilityUUIDsInformation about project &quot;xxx&quot;:Targets:xxxxxxTestsBuild Configurations:DebugReleaseIf no build configuration is specified and -scheme is not passed then &quot;Release&quot; is used.Schemes:xxx</code></pre><h3 id="然后，成功了-如下："><a href="#然后，成功了-如下：" class="headerlink" title="然后，成功了,如下："></a>然后，成功了,如下：</h3><pre><code>Entitlements:{&quot;application-identifier&quot; = &quot;L64TE3S9T9.com.曹理鹏(iCocos)-梦工厂.shaoshang&quot;;&quot;aps-environment&quot; = development;&quot;com.apple.developer.pass-type-identifiers&quot; =     (&quot;L64TE3S9T9.*&quot;);&quot;com.apple.developer.team-identifier&quot; = L64TE3S9T9;&quot;get-task-allow&quot; = 1;}builtin-productPackagingUtility -entitlements -format xml -o /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Intermediates/曹理鹏(iCocos)-梦工厂.build/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.build/曹理鹏(iCocos)-梦工厂.app.xcentCodeSign /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Products/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.appcd /Users/iCocos/Desktop/MBA/最新Git源代码/曹理鹏(iCocos)-梦工厂export CODESIGN_ALLOCATE=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/codesign_allocateexport PATH=&quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/Users/iCocos/.rvm/gems/ruby-2.3.0/bin:/Users/iCocos/.rvm/gems/ruby-2.3.0@global/bin:/Users/iCocos/.rvm/rubies/ruby-2.3.0/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/iCocos/.rvm/bin:/usr/local/mysql/bin/mysql&quot;Signing Identity:     &quot;iPhone Developer: Songbai He (73N6HPPJDP)&quot;Provisioning Profile: &quot;iOS Team Provisioning Profile: com.曹理鹏(iCocos)-梦工厂.shaoshang&quot;(34c1d23b-ade5-4d0f-9329-7b16009b30c2)/usr/bin/codesign --force --sign F8BAED0C84DB84AAA84769FED9FEAA9E80825C29 --entitlements /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Intermediates/曹理鹏(iCocos)-梦工厂.build/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.build/曹理鹏(iCocos)-梦工厂.app.xcent --timestamp=none /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Products/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.appValidate /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Products/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.appcd /Users/iCocos/Desktop/MBA/最新Git源代码/曹理鹏(iCocos)-梦工厂export PATH=&quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/Users/iCocos/.rvm/gems/ruby-2.3.0/bin:/Users/iCocos/.rvm/gems/ruby-2.3.0@global/bin:/Users/iCocos/.rvm/rubies/ruby-2.3.0/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/iCocos/.rvm/bin:/usr/local/mysql/bin/mysql&quot;export PRODUCT_TYPE=com.apple.product-type.applicationbuiltin-validationUtility /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Products/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.app** BUILD SUCCEEDED **</code></pre><h2 id="下面就是验证你全栈的时候到了，其实也没有那么难，就是一点脚本而已"><a href="#下面就是验证你全栈的时候到了，其实也没有那么难，就是一点脚本而已" class="headerlink" title="下面就是验证你全栈的时候到了，其实也没有那么难，就是一点脚本而已"></a>下面就是验证你全栈的时候到了，其实也没有那么难，就是一点脚本而已</h2><h3 id="先git-指令，pull到最新的分支"><a href="#先git-指令，pull到最新的分支" class="headerlink" title="先git 指令，pull到最新的分支"></a>先git 指令，pull到最新的分支</h3><pre><code># git updategit checkout $BRANCHNAMEif [ $? -ne 0 ]; thenexit 1figit pull #pod update --verbose --no-repo-updateif [ $? -ne 0 ]; thenexit 1fi</code></pre><h3 id="成功之后你同意会看到提示信息"><a href="#成功之后你同意会看到提示信息" class="headerlink" title="成功之后你同意会看到提示信息"></a>成功之后你同意会看到提示信息</h3><pre><code>logoutSaving session......copying shared history......saving history...truncating history files......completed.Deleting expired sessions...118 completed.</code></pre><h3 id="xcodebuild进行编译"><a href="#xcodebuild进行编译" class="headerlink" title="xcodebuild进行编译"></a>xcodebuild进行编译</h3><pre><code>xcodebuild \-workspace $SORCEPATH/曹理鹏(iCocos)-梦工厂.xcworkspace \-scheme $SCHEMENAMEPLQ \-configuration Debug \CODE_SIGN_IDENTITY=&quot;iPhone Developer: Songbai He(73N6HPPJDP)”  \PROVISIONING_PROFILE=&quot;com.曹理鹏(iCocos)-梦工厂.shaoshang&quot; \clean \build \-derivedDataPath $IPAPATH/$BRANCHNAME/$DATE</code></pre><h3 id="测试与发布只需要更改对应的参数即可"><a href="#测试与发布只需要更改对应的参数即可" class="headerlink" title="测试与发布只需要更改对应的参数即可"></a>测试与发布只需要更改对应的参数即可</h3><pre><code>-configuration Debug-configuration Release</code></pre><h2 id="用xcrun打包成ipa包"><a href="#用xcrun打包成ipa包" class="headerlink" title="用xcrun打包成ipa包"></a>用xcrun打包成ipa包</h2><pre><code>xcrun -sdk iphoneos PackageApplication \-v $IPAPATH/Build/Products/Debug-iphoneos/$SCHEMENAME.app \-o $IPAPATH/$IPANAME</code></pre><h2 id="生成ipa包，上传到fir-im"><a href="#生成ipa包，上传到fir-im" class="headerlink" title="生成ipa包，上传到fir.im"></a>生成ipa包，上传到fir.im</h2><h3 id="一：1-注册fir-拿到token"><a href="#一：1-注册fir-拿到token" class="headerlink" title="一：1.注册fir.拿到token"></a>一：1.注册fir.拿到token</h3><pre><code>fir.im官网：https://fir.im</code></pre><p>注册号账号，点击右上角个人信息，进入API token 拿到token，并保存</p><h3 id="二：安装fir-cli"><a href="#二：安装fir-cli" class="headerlink" title="二：安装fir-cli"></a>二：安装fir-cli</h3><pre><code>fir-cli 使用 Ruby 构建, 无需编译, 只要安装相应 gem 即可.$ ruby -v # &gt; 1.9.3$ gem install fir-cli</code></pre><h3 id="三：Mac新版之后可能由于源的问题导致无法安装（由于10-11引入了-rootless-无法直接安装-fir-cli）"><a href="#三：Mac新版之后可能由于源的问题导致无法安装（由于10-11引入了-rootless-无法直接安装-fir-cli）" class="headerlink" title="三：Mac新版之后可能由于源的问题导致无法安装（由于10.11引入了 rootless, 无法直接安装 fir-cli）"></a>三：Mac新版之后可能由于源的问题导致无法安装（由于10.11引入了 rootless, 无法直接安装 fir-cli）</h3><p>一般都是这么安装的：使用 Homebrew 及 RVM 安装 Ruby, 再安装 fir-cli</p><pre><code>Install Homebrew:$ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;Install RVM:$ \curl -sSL https://get.rvm.io | bash -s stable --rubyInstall fir-cli:$ gem install fir-cli</code></pre><h3 id="四：在终端登录并查看信息"><a href="#四：在终端登录并查看信息" class="headerlink" title="四：在终端登录并查看信息"></a>四：在终端登录并查看信息</h3><ol><li>$ fir login  </li></ol><p>按照提示输入token,然后</p><pre><code>iCocosdeiMac:曹理鹏(iCocos)-梦工厂 iCocos$ fir login  Please enter your fir.im API Token: 849ad212b94683b4c3087248d422d124I, [2017-04-18T13:58:01.184043 #14531]  INFO -- : Login succeed, previous user&apos;s email: al10201119@163.comI, [2017-04-18T13:58:01.185131 #14531]  INFO -- : Login succeed, current  user&apos;s email: al10201119@163.comI, [2017-04-18T13:58:01.185223 #14531]  INFO -- : </code></pre><ol start="2"><li><p>$fir me</p><p>登录成功,就会显示用户信息</p><p> I, [2017-04-18T13:58:21.876164 #14545]  INFO – : Login succeed, current user’s email: <a href="mailto:al10201119@163.com" target="_blank" rel="noopener">al10201119@163.com</a><br> I, [2017-04-18T13:58:21.876246 #14545]  INFO – : Login succeed, current user’s name:  al10201119<br> I, [2017-04-18T13:58:21.876261 #14545]  INFO – : </p></li></ol><ol start="3"><li>使用fir指令，上传我们的ipa包</li></ol><pre><code>fir login -T c525718a775b954882xxxxxxxx       # fir.im tokenfir publish $IPAPATH/Develop/xxx.ipa</code></pre><ol start="4"><li><p>最后你会看到</p><p> 恭喜！！！上传fir.im成功！</p></li></ol><h2 id="也可以直接使用执行脚本"><a href="#也可以直接使用执行脚本" class="headerlink" title="也可以直接使用执行脚本"></a>也可以直接使用执行脚本</h2><pre><code>#author iCocos#注意：脚本目录和xxxx.xcodeproj要在同一个目录，如果放到其他目录，请自行修改脚本。#工程名字(Target名字)Project_Name=&quot;Target名字，系统默认和工程名字一样&quot;#配置环境，Release或者DebugConfiguration=&quot;Release&quot;#AdHoc版本的Bundle IDAdHocBundleID=&quot;com.xxx&quot;#AppStore版本的Bundle IDAppStoreBundleID=&quot;com.xxx&quot;#enterprise的Bundle IDEnterpriseBundleID=&quot;com.xxx&quot;# ADHOC#证书名#描述文件ADHOCCODE_SIGN_IDENTITY=&quot;iPhone Distribution: xxxx&quot;ADHOCPROVISIONING_PROFILE_NAME=&quot;xxxx-xxxx-xxxx-xxxx&quot;#AppStore证书名#描述文件APPSTORECODE_SIGN_IDENTITY=&quot;iPhone Distribution: xxxx&quot;APPSTOREROVISIONING_PROFILE_NAME=&quot;xxxx-xxxx-xxxx-xxxx&quot;#企业(enterprise)证书名#描述文件ENTERPRISECODE_SIGN_IDENTITY=&quot;iPhone Distribution: xxxxx&quot;ENTERPRISEROVISIONING_PROFILE_NAME=&quot;xxxx-xxxx-xxxx-xxxx&quot;#加载各个版本的plist文件ADHOCExportOptionsPlist=./ADHOCExportOptionsPlist.plistAppStoreExportOptionsPlist=./AppStoreExportOptionsPlist.plistEnterpriseExportOptionsPlist=./EnterpriseExportOptionsPlist.plistADHOCExportOptionsPlist=${ADHOCExportOptionsPlist}AppStoreExportOptionsPlist=${AppStoreExportOptionsPlist}EnterpriseExportOptionsPlist=${EnterpriseExportOptionsPlist}echo &quot;~~~~~~~~~~~~选择打包方式(输入序号)~~~~~~~~~~~~~~~&quot;echo &quot;  1 appstore&quot;echo &quot;  2 adhoc&quot;echo &quot;  3 enterprise&quot;# 读取用户输入并存到变量里read parametersleep 0.5method=&quot;$parameter&quot;# 判读用户是否有输入if [ -n &quot;$method&quot; ]then#clean下xcodebuild clean -xcodeproj ./$Project_Name/$Project_Name.xcodeproj -configuration $Configuration -alltargetsif [ &quot;$method&quot; = &quot;1&quot; ]then#appstore脚本xcodebuild -project $Project_Name.xcodeproj -scheme $Project_Name -configuration $Configuration -archivePath build/$Project_Name-appstore.xcarchive clean archive build  CODE_SIGN_IDENTITY=&quot;${APPSTORECODE_SIGN_IDENTITY}&quot; PROVISIONING_PROFILE=&quot;${APPSTOREROVISIONING_PROFILE_NAME}&quot; PRODUCT_BUNDLE_IDENTIFIER=&quot;${AppStoreBundleID}&quot;xcodebuild -exportArchive -archivePath build/$Project_Name-appstore.xcarchive -exportOptionsPlist $AppStoreExportOptionsPlist -exportPath ~/Desktop/$Project_Name-appstore.ipaelif [ &quot;$method&quot; = &quot;2&quot; ]then#adhoc脚本xcodebuild -project $Project_Name.xcodeproj -scheme $Project_Name -configuration $Configuration -archivePath build/$Project_Name-adhoc.xcarchive clean archive build CODE_SIGN_IDENTITY=&quot;${ADHOCCODE_SIGN_IDENTITY}&quot; PROVISIONING_PROFILE=&quot;${ADHOCPROVISIONING_PROFILE_NAME}&quot; PRODUCT_BUNDLE_IDENTIFIER=&quot;${AdHocBundleID}&quot;xcodebuild -exportArchive -archivePath build/$Project_Name-adhoc.xcarchive -exportOptionsPlist $ADHOCExportOptionsPlist -exportPath ~/Desktop/$Project_Name-adhoc.ipaelif [ &quot;$method&quot; = &quot;3&quot; ]then#企业打包脚本xcodebuild -project $Project_Name.xcodeproj -scheme $Project_Name -configuration $Configuration -archivePath build/$Project_Name-enterprise.xcarchive clean archive build CODE_SIGN_IDENTITY=&quot;${ENTERPRISECODE_SIGN_IDENTITY}&quot; PROVISIONING_PROFILE=&quot;${ENTERPRISEROVISIONING_PROFILE_NAME}&quot; PRODUCT_BUNDLE_IDENTIFIER=&quot;${EnterpriseBundleID}&quot;xcodebuild -exportArchive -archivePath build/$Project_Name-enterprise.xcarchive -exportOptionsPlist $EnterpriseExportOptionsPlist -exportPath ~/Desktop/$Project_Name-enterprise.ipaelseecho &quot;参数无效....&quot;exit 1fifi</code></pre><p>这里还有一个大神使用PHP干了一票，虽然还在学习PHP中，但是有机会也要试一下</p><blockquote><p>这里目前只是实现了Ad-Hoc打包上传，关于App Store其实也就是更改参数，和对应的地址，后续会退出相应的文章界面具体实战……</p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> iOS——自动打包上传 </tag>
            
            <tag> 自动打包上传 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>带你简单理解block和__block的实现？</title>
      <link href="/2016/03/25/%E5%B8%A6%E4%BD%A0%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3block%E5%92%8C-block%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F/"/>
      <url>/2016/03/25/%E5%B8%A6%E4%BD%A0%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3block%E5%92%8C-block%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>其实类似block和__block的实现网上随便一搜就能找到无数篇，有些分析的确实非常不错，但是或许有些人刚好就没有那个耐心去看完，有些人就算最后看完也没有理解，甚至还是没能理解其中的核心,所以这里我就根据个人的理解和网上资料的整理，简单的总结一下……</p><a id="more"></a><h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><pre><code>1.Block其实是闭包2.Block是基于C语言的拓展3.Block是基于指针和函数指针实现的，4.同时他也是一种匿名函数，而且你会发现他和函数其实有很多相似的地方5.通过打印我们可以知道他其实是一种的结构体</code></pre><h3 id="block的实现"><a href="#block的实现" class="headerlink" title="block的实现"></a>block的实现</h3><pre><code>Block是被设为_NSConcreteStackBlock，在栈上生成。当我们把Block作为全局变量使用时，对应生成的Block将被设为_NSConcreteGlobalBlock</code></pre><h3 id="Block属性"><a href="#Block属性" class="headerlink" title="Block属性"></a>Block属性</h3><p>这里还有一点关于block类型的ARC属性。上文也说明了，ARC会自动帮strong类型且捕获外部变量的block进行copy，所以在定义block类型的属性时也可以使用strong，不一定使用copy。也就是以下代码：</p><pre><code>/** 假如有栈block赋给以下两个属性 **/// 这里因为ARC，当栈block中会捕获外部变量时，这个block会被copy进堆中// 如果没有捕获外部变量，这个block会变为全局类型// 不管怎么样，它都脱离了栈生命周期的约束@property (strong, nonatomic) Block *strongBlock;// 这里都会被copy进堆中@property (copy, nonatomic) Block *copyBlock;</code></pre><h3 id="block-1"><a href="#block-1" class="headerlink" title="__block"></a>__block</h3><pre><code>Block不允许修改外部变量的值，这里所说的外部变量的值，指的是栈中指针的内存地址。__block 所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。</code></pre><blockquote><p>总结就是：__block对象在block中是可以被修改、重新赋值的。</p></blockquote><h3 id="block的实现-1"><a href="#block的实现-1" class="headerlink" title="__block的实现"></a>__block的实现</h3><pre><code>__block其实是堆栈的拷贝，</code></pre><p>首先<strong>block修饰的变量会变成</strong>block_bref_val_0的结构体，它包含实例变量本身__forwarding(用于访问局部变量val)。</p><p>block拷贝到堆上的时候：</p><pre><code>_val_0也会拷贝到堆上，局部变量销毁，block任然能对堆上的局部变量操作__forwarding替换为堆上的__block变量的地址栈上的_val_0结构体中的__forwarding指针也会指向堆上的结构体main函数或者blcok释放的时候，只是释放了栈上的东西，所有对局部变量的操作都已经移到了对上。</code></pre>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>带你简单理解weak和__weak的实现？</title>
      <link href="/2016/03/21/%E5%B8%A6%E4%BD%A0%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3weak%E5%92%8C-weak%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F/"/>
      <url>/2016/03/21/%E5%B8%A6%E4%BD%A0%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3weak%E5%92%8C-weak%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>其实类似weak和__weak的实现网上随便一搜就能找到无数篇，有些分析的确实非常不错，但是或许有些人刚好就没有那个耐心去看完，有些人就算最后看完也没有理解，甚至还是没能理解其中的核心,所以这里我就根据个人的理解和网上资料的整理，简单的总结一下……</p><a id="more"></a><h3 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h3><pre><code>字面含义就是弱引用,Objective-C中默认都是强引用的（strong）</code></pre><h3 id="weak的实现"><a href="#weak的实现" class="headerlink" title="weak的实现"></a>weak的实现</h3><p>Runtime维护了一个weak表，用于存储指向某个对象的所有weak指针。weak表其实是一个hash（哈希）表，Key是所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象的地址）数组。</p><h4 id="weak-的实现原理可以概括一下三步："><a href="#weak-的实现原理可以概括一下三步：" class="headerlink" title="weak 的实现原理可以概括一下三步："></a>weak 的实现原理可以概括一下三步：</h4><pre><code>1、初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。2、添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。3、释放时，调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。</code></pre><h3 id="weak-1"><a href="#weak-1" class="headerlink" title="__weak"></a>__weak</h3><pre><code>__weak修饰符的对象，作用等同于定义为weak的property。他并不会导致循环引用问题（通过苹果文档我们可以得出这样的结论），当原对象没有任何强引用的时候，弱引用指针也会被设置为nil。</code></pre><h3 id="weak的实现-1"><a href="#weak的实现-1" class="headerlink" title="__weak的实现"></a>__weak的实现</h3><pre><code>简单来说，系统有一个全局的 CFMutableDictionary 实例，来保存每个对象的 weak 指针列表，因为每个对象可能有多个 weak 指针，所以这个实例的值是 CFMutableSet（Array） 类型。</code></pre><p>剩下我们要做的，就是在引用计数变成 0 的时候，去这个全局的字典里面，找到所有的 weak 指针，将其值设置成 nil。如何做到这一点呢？Friday QA 上介绍了一种类似 KVO 实现的方式。当对象存在 weak 指针时，我们可以将这个实例指向一个新创建的子类，然后修改这个子类的 release 方法，在 release 方法中，去从全局的</p><p>CFMutableDictionary 字典中找到所有的 weak 对象，并且设置成 nil。我摘抄了 Friday QA 上的实现的核心代码，如下：</p><pre><code>Class subclass = objc_allocateClassPair(class, newNameC, 0);Method release = class_getInstanceMethod(class, @selector(release));Method dealloc = class_getInstanceMethod(class, @selector(dealloc));class_addMethod(subclass, @selector(release), (IMP)CustomSubclassRelease, method_getTypeEncoding(release));class_addMethod(subclass, @selector(dealloc), (IMP)CustomSubclassDealloc, method_getTypeEncoding(dealloc));objc_registerClassPair(subclass);</code></pre><blockquote><p>总结一句就是：一个通俗的解释就是，在Objective-C的运行时环境中，维护了一种weak表，这张哈希表用对象的首地址作为键，将由若干个<strong>weak修饰的指针自身的地址组成的数组作为值。当一个Objective-C对象被释放后，通过这个对象的起始地址来找到所有指向它的</strong>weak指针，并将它们指向nil。</p></blockquote><h4 id="weak的作用"><a href="#weak的作用" class="headerlink" title="__weak的作用"></a>__weak的作用</h4><pre><code>在Objective-C中，用__weak修饰的指针，会在所指向的那个Objective-C对象被释放后，自动指向nil。使用__weak来修饰指针，相比于__unsafe_unretained，可以帮助程序员减小访问野指针的风险，方便了程序员对内存的管理。</code></pre><h3 id="block和weak的区别"><a href="#block和weak的区别" class="headerlink" title="block和weak的区别"></a><strong>block和</strong>weak的区别</h3><p>前面提到了<strong>block，也大概说了一下其简单实现，所以这里总结一下</strong>block和__weak修饰符的区别：</p><pre><code>1.__block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型。2.__weak只能在ARC模式下使用，也只能修饰对象（NSString），不能修饰基本数据类型（int）。3.__block对象可以在block中被重新赋值，__weak不可以。4.__block对象在ARC下可能会导致循环引用，非ARC下会避免循环引用，__weak只在ARC下使用，可以避免循环引用。</code></pre>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 带你简单理解weak和__weak的实现？ </tag>
            
            <tag> 底层分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分类能添加属性吗？成员变量呢？为什么？</title>
      <link href="/2016/03/18/%E5%88%86%E7%B1%BB%E8%83%BD%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E5%90%97%EF%BC%9F%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%91%A2%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2016/03/18/%E5%88%86%E7%B1%BB%E8%83%BD%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E5%90%97%EF%BC%9F%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%91%A2%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>在iOS开发中，如果你要在不改变原来的类内容的基础上，为类增加一些方法，那么苹果提供了一个很好机制，那就是分类，当然我们平时可能比较多的是直接给他添加方法，并且我们清楚一点的是，我们还能给一个分类添加属性（使用关联对象），但是并不能添加成员变量，可是为什么刚好成员变量就不能连接呢……</p><a id="more"></a><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>概念：</p><pre><code>Category  分类是OC特有的语言，依赖于类。</code></pre><p>分类的作用：</p><pre><code>在不改变原来的类内容的基础上，为类增加一些方法。</code></pre><h3 id="分类增加属性和方法"><a href="#分类增加属性和方法" class="headerlink" title="分类增加属性和方法"></a>分类增加属性和方法</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>方法</p><pre><code>这里其实就不用做过多介绍了，只需要知道分类增加方法其实就和一个类增加一个方法一样。</code></pre><p>属性</p><pre><code>至于分类增加属性，只要使用到的就是Objective-C里面比较底层的一个技术Runtime，Runtime里面有个里面有个关联对象的概念，具体请查看官方或者相关资料，很简单。</code></pre><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>NO，NO，NO，分类是不能增加属性的，一定没办法，如果你有可以来找我，哈哈….</p><h4 id="为什么不能增加成员变量呢？"><a href="#为什么不能增加成员变量呢？" class="headerlink" title="为什么不能增加成员变量呢？"></a>为什么不能增加成员变量呢？</h4><pre><code>首先我们不能混淆了成员变量和属性的概念.Property是Property，Ivar是Ivar。分类里面不能添加Ivar是因为分类本身并不是一个真正的类（Objective-C中真正的类是有一个isa存在的），但是分类并没有自己的ISA .类最开始生成了很多基本属性，比如IvarList，MethodList，分类只会将自己的method attach到主类，并不会影响到主类的IvarList。</code></pre><p>这就是为什么分类里面不能增加成员变量的原因”</p><h3 id="类和分类的初始化"><a href="#类和分类的初始化" class="headerlink" title="类和分类的初始化"></a>类和分类的初始化</h3><pre><code>1.当程序启动时，就会加载项目中所有的类和分类，而且加载后会调用每个类和分类的+load方法，只会调用一次；2.当第一次使用某个类时，就会调用当前类的+initialize方法；3.先加载父类，再加载子类（先调用父类的+load方法，再调用子类的+load方法，最后调用分类的+load方法），先初始化父类，再初始化子类（先调用父类的+initialize方法，再调用子类的+initialize方法）。4.注意：在初始化的时候，如果在分类中重写了+initialize方法，则会覆盖掉父类的。5.重写+initialize方法可以监听类的使用情况。</code></pre>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>为什么调用nil的任何方法都不会崩溃？</title>
      <link href="/2016/03/15/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B0%83%E7%94%A8nil%E7%9A%84%E4%BB%BB%E4%BD%95%E6%96%B9%E6%B3%95%E9%83%BD%E4%B8%8D%E4%BC%9A%E5%B4%A9%E6%BA%83%EF%BC%9F/"/>
      <url>/2016/03/15/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B0%83%E7%94%A8nil%E7%9A%84%E4%BB%BB%E4%BD%95%E6%96%B9%E6%B3%95%E9%83%BD%E4%B8%8D%E4%BC%9A%E5%B4%A9%E6%BA%83%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>我们知道，在Objective-C消息和转发机制的背后有这样一个说法：调用没有实现或者不存在的方法，会导致App崩溃，但是如果你比较细心或者专门研究过消息和转发机制那么你应该听过这样的结论：</p><blockquote><p>Objective-C中调用nil的任何方法都不会崩溃，但是，为什么就不会崩溃呢？这里就简单分析一下具体的原因和底层的实现方式……</p></blockquote><a id="more"></a><h3 id="访问了一个已经被释放的对象"><a href="#访问了一个已经被释放的对象" class="headerlink" title="访问了一个已经被释放的对象"></a>访问了一个已经被释放的对象</h3><p>我们知道在不使用 ARC 的时候，内存要自己管理，这时重复或过早释放都有可能导致 Crash。</p><pre><code>NSObject * aObj = [[NSObject alloc] init];[aObj release];NSLog(@&quot;%@&quot;, aObj);</code></pre><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><pre><code>aObj 这个对象已经被释放，但是指针没有置空，这时访问这个指针指向的内存就会 Crash。</code></pre><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>使用前要判断非空，释放后要置空。正确的释放应该是:</p><pre><code>[aObj release];aObj = nil;</code></pre><p>由于ObjC的特性，调用 nil 指针的任何方法相当于无作用，所以即使有人在使用这个指针时没有判断至少还不会挂掉。</p><h2 id="那么这里就有一个问题？"><a href="#那么这里就有一个问题？" class="headerlink" title="那么这里就有一个问题？"></a>那么这里就有一个问题？</h2><pre><code>为什么调用nil的任何方法都不会崩溃呢？</code></pre><p>首先在Objective-C里，nil对象被设计来跟NULL空指针关联的。他们的区别就是nil是一个对象，而NULL只是一个值。而且我们对于nil调用方法，不会产生crash或者抛出异常。这个技术被framework通过多种不同的方式使用。</p><pre><code>最主要的就是我们现在在调用方法之前根本无须去检查这个对象是否是nil。假如我们调了nil对象的一个有返回值的方法，那么我们会得到一个nil返回值。</code></pre><p>我们先来看看这断代码：</p><pre><code>- (void) dealloc{    self.caption = nil;    self.photographer = nil;    [super dealloc];}</code></pre><h2 id="具体原因"><a href="#具体原因" class="headerlink" title="具体原因"></a>具体原因</h2><p>　　之所以可以这么做是因为我们给把nil对象设给了一个成员变量，setter就会retain nil对象(当然了这个时候nil对象啥事情也不会做)然后release旧的对象。这个方式来释放对象其实更好，因为这样做的话，成员变量连指向随机数据的机会都没有，而通过别的方式，出现指向随机数据的情形机会不可避免。</p><p>注意到我们调用的self.VAR这样的语法，这表示我们正在用setter，而且不会引起任何内存问题。假如我们直接去设值的话，就会有内存溢出：</p><pre><code>// incorrect. causes a memory leak.// use self.caption to Go through settercaption = nil;</code></pre><h3 id="这里进入提到了崩溃，那么就大概整理一下开发中常见的崩溃问题和类型，方便提前预防和部分相关处理"><a href="#这里进入提到了崩溃，那么就大概整理一下开发中常见的崩溃问题和类型，方便提前预防和部分相关处理" class="headerlink" title="这里进入提到了崩溃，那么就大概整理一下开发中常见的崩溃问题和类型，方便提前预防和部分相关处理"></a>这里进入提到了崩溃，那么就大概整理一下开发中常见的崩溃问题和类型，方便提前预防和部分相关处理</h3><pre><code>一、访问了一个已经被释放的对象：nil，autorelease二、访问数组类对象越界或插入了空对象：分类或者runtime替换三、访问了不存在的方法：判断是否有，runtime修改四、字节对齐：使用 memcpy 来作内存拷贝，而不是直接对指针赋值五、堆栈溢出（过多的递归会导致栈溢出，过多的 alloc 变量会导致堆溢出。）六、多线程并发操作：加锁 ，原子，Operation Objects, GCD, Idle-time notifications, Asynchronous functions, Timers, Separate processes。七、Repeating NSTimer：写了个宏用来释放Timer</code></pre>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>生命之源-RunLoop</title>
      <link href="/2016/03/09/%E7%94%9F%E5%91%BD%E4%B9%8B%E6%BA%90-RunLoop/"/>
      <url>/2016/03/09/%E7%94%9F%E5%91%BD%E4%B9%8B%E6%BA%90-RunLoop/</url>
      <content type="html"><![CDATA[<p>iOS一切的生命之源都需要RunLoop的支持，关于RunLoop的界面和相关知识，网上想你一一搜一天也看不完，所以这里只为总结Runloop相关技术，适用于底层，面试，简单实战了解！</p><a id="more"></a><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ 一个线程只能执行一个任务，任务执行完之后，线程就会退出，但是主线程不会退出，因为我们需要让主线程等待接收事件</span><br></pre></td></tr></table></figure><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ 运行循环（<span class="keyword">do</span>-while）：不断处理各种事件</span><br><span class="line">+ 一个线程（唯一）对应一个RunLoop（可以嵌套子runloops），主线程默认启动，子线程手动启动（run）：获取RunLoop对象的时候，就会创建RunLoop</span><br><span class="line">+ RunLoop有多个Model，Model有多个timer（array）/<span class="built_in">source</span>（<span class="built_in">set</span>）/observer（array）。</span><br><span class="line">+ 每次启动只能启动一个，切换需要先推出在指定（分隔不同time/<span class="built_in">source</span>/observer）</span><br><span class="line">+ 当前Model没有任何timer/<span class="built_in">source</span>/observer就会推出（mode只能添加不能删除）</span><br><span class="line">+ 第一次获取创建，线程结束销毁</span><br></pre></td></tr></table></figure><h3 id="runloop退出的条件："><a href="#runloop退出的条件：" class="headerlink" title="runloop退出的条件："></a>runloop退出的条件：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app退出；线程关闭；设置最大时间到期；modeItem为空；</span><br></pre></td></tr></table></figure><h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ CFRunLoopTimerRef，基于时间触发（NSTimer），受Model影响，GCD不受Model影响</span><br><span class="line">+ CFRunLoopSourceRef，事件源，source0（非Port），source1（Port），跟Port密切联系</span><br><span class="line"></span><br><span class="line">source0：event事件，只含有回调，需要标记待处理（signal），然后手动将runloop唤醒（wakeup）；</span><br><span class="line">source1 ：包含一个 mach_port 和一个回调，被用于通过内核和其他线程发送的消息，能主动唤醒runloop。</span><br></pre></td></tr></table></figure><h3 id="Runloop本质：mach-port和mach-msg-。"><a href="#Runloop本质：mach-port和mach-msg-。" class="headerlink" title="Runloop本质：mach port和mach_msg()。"></a>Runloop本质：mach port和mach_msg()。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mach是XNU的内核，进程、线程和虚拟内存等对象通过端口发消息进行通信，Runloop通过mach_msg()函数发送消息，如果没有port 消息，内核会将线程置于等待状态 mach_msg_trap() 。如果有消息，判断消息类型处理事件，并通过modeItem的callback回调(处理事件的具体执行是在DoBlock里还是在回调里目前我还不太明白？？？)。</span><br><span class="line"></span><br><span class="line">Runloop有两个关键判断点，一个是通过msg决定Runloop是否等待，一个是通过判断退出条件来决定Runloop是否循环</span><br></pre></td></tr></table></figure><h3 id="定时源，输入源"><a href="#定时源，输入源" class="headerlink" title="定时源，输入源"></a>定时源，输入源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ 定时源，同步消息，特定或者一定时间间隔发生</span><br><span class="line">+ 输入源，来自起来线程或者程序</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ NSTimer，ImageView显示，PerformSelector，常驻线程，自动释放池，界面刷新，手势识别，GCD任务，timer：（与CADisplayLink），网络请求：</span><br></pre></td></tr></table></figure><h3 id="autorrelease释放时机："><a href="#autorrelease释放时机：" class="headerlink" title="autorrelease释放时机："></a>autorrelease释放时机：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ 手动干预释放：指定autorreleasepool,当前作用域大括号结束立即释放</span><br><span class="line">+ 系统自动释放：不指定，aut对象在当前RunLoop迭代结束释放</span><br></pre></td></tr></table></figure><h3 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">自动释放池寄生于Runloop：程序启动后，主线程注册了两个Observer监听runloop的进出与睡觉。一个最高优先级OB监测Entry状态；一个最低优先级OB监听BeforeWaiting状态和Exit状态。</span><br><span class="line">线程(创建)--&gt;runloop将进入--&gt;最高优先级OB创建释放池--&gt;runloop将睡--&gt;最低优先级OB销毁旧池创建新池--&gt;runloop将退出--&gt;最低优先级OB销毁新池--&gt;线程(销毁)</span><br></pre></td></tr></table></figure><h3 id="Timer注意"><a href="#Timer注意" class="headerlink" title="Timer注意"></a>Timer注意</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、如果是在主线程中运行timer，想要timer在某界面有视图滚动时，依然能正常运转，那么将timer添加到RunLoop中时，就需要设置mode 为NSRunLoopCommonModes。</span><br><span class="line">2、如果是在子线程中运行timer,那么将timer添加到RunLoop中后，Mode设置为NSDefaultRunLoopMode或NSRunLoopCommonModes均可，但是需要保证RunLoop在运行，且其中有任务。</span><br></pre></td></tr></table></figure><h3 id="runloop"><a href="#runloop" class="headerlink" title="runloop:"></a>runloop:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、（要让马儿跑）通过<span class="keyword">do</span>-while死循环让程序持续运行：接收用户输入，调度处理事件时间。</span><br><span class="line">2、（要让马儿少吃草）通过mach_msg()让runloop没事时进入<span class="built_in">trap</span>状态，节省CPU资源。</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 生命之源-RunLoop </tag>
            
            <tag> RunLoop </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前世-内存管理</title>
      <link href="/2016/03/03/%E5%89%8D%E4%B8%96-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2016/03/03/%E5%89%8D%E4%B8%96-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<p>最近越来越发觉，自己做了这么久iOS开发，似乎都是在瞎玩，回望这一路写的App，写的代码，以及上线的App，又有几个自己真的非常满意的？</p><blockquote><p>说道这里，不得不提的是：我相信不止我一个人有这种感触，代码写久了，自己都不知道自己在写撒，就连上线都是个意外。</p></blockquote><p>这一路走来我一直在总结，也在回望，到底自己哪里出了问题，终于发现：终究是自己不敢面对而已，底层不了解，只知道敲。</p><a id="more"></a><blockquote><p>因为换了电脑，换了工作，换了新的环境，也换了一个不一样的心情重新开始探索之路，所以之前的博客地址也停止更新了，如果你对iOS相关知识感兴趣或者有什么疑问和建议可以联系我，或者直接在下面评论，</p></blockquote><p>本来打算这个博客中不会再写iOS的东西，但是最近一直上班，也找了一段时间公司，总之感触不少，现在这个行情，大家都懂的。</p><p>前段时间也整理了一些东西，我相信值得一看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原则：没有强指针指向对象，对象就会被释放。</span><br></pre></td></tr></table></figure><h3 id="MRC-ARC"><a href="#MRC-ARC" class="headerlink" title="MRC-ARC"></a>MRC-ARC</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ARC：LLVM3.0（iOS5，Xcode4）</span><br><span class="line">前段编译器：方法内创建对象，末尾自动插入release销毁。类拥有对象，在dealloc内释放。更底层的C语言实现。objc_release,objc_retain优化调用过程</span><br><span class="line">ARC优化器：负责移除多余的插入，和一些引用的优化。包括运行期组件。</span><br></pre></td></tr></table></figure><h3 id="关于循环"><a href="#关于循环" class="headerlink" title="关于循环"></a>关于循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">weak：循环引用，自身强引用，IBOutlet。非拥有，不保留也不释放，置nil，weak必须用于OC对象，assign非OC对象</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>循环：只有当自动释放器被release，池中的表示autorrelease对象才会被释放===内存耗尽，没有释放-&gt;内存泄露</span><br><span class="line">1.i比较大：使用@autorreleasepool&#123;&#125;，在<span class="keyword">for</span>外面，循环结束，销毁创建对象，解决占据栈内存问题。</span><br><span class="line">2.i玩命大：一次循环都会自动释放池满，@autorreleasepool&#123;&#125;放在<span class="keyword">for</span>里面，每次循环前将上一次对象release。</span><br></pre></td></tr></table></figure><h3 id="关于内存"><a href="#关于内存" class="headerlink" title="关于内存"></a>关于内存</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">内存布局：没有多继承，所以布局简单</span><br><span class="line">最前面isa，指向类。父类实例变量在子类实例变量之前。</span><br></pre></td></tr></table></figure><h3 id="关于线程"><a href="#关于线程" class="headerlink" title="关于线程"></a>关于线程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">界面线程维护自己的线程池。自己创建的线程数据，需要创建线程的内存池。</span><br><span class="line"></span><br><span class="line">autorreleasepool实现：objc_autorreleasepool=Push,Pop,objc_autorrelease</span><br><span class="line"></span><br><span class="line">每次RunLoop完成一个循环的时候，都会检测对象的retainCount，为0则没有使用，释放。</span><br><span class="line"></span><br><span class="line">内存管理的范围：集成自NSObject对象，基本数据类型无效。因为存储空间不同，基本数据存在栈区。对象在堆中，代码块结束，涉及局部变量弹栈清空，指向对象指针回收，对象没有指针指向，但是还在堆中，所以内存泄露了。</span><br><span class="line"></span><br><span class="line">unowned（unsafe_unretained）：对象销毁不会为空，但是更快，因为weak需要unwrap。</span><br></pre></td></tr></table></figure><h3 id="常见状态管理"><a href="#常见状态管理" class="headerlink" title="常见状态管理"></a>常见状态管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">野指针:指针变量没有初始化，指向的空间被释放。调用方法报异常，崩溃。release后，地址nil，OC中没有空指针异常</span><br><span class="line">内存泄露：对象提前赋值nil，导致release不起作用。没有配对释放或者清空。栈区释放了，堆区没有释放。最终导致内存溢出</span><br><span class="line">内存溢出：容量超出使用限制</span><br><span class="line">僵尸对象：堆中已经被释放的对象count=0</span><br><span class="line">空指针：指针赋值为nil</span><br><span class="line"></span><br><span class="line">判断对象销毁：dealloc（需要super一下），已经释放的对象无法复活</span><br></pre></td></tr></table></figure><h3 id="对象关系"><a href="#对象关系" class="headerlink" title="对象关系"></a>对象关系</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">集成：</span><br><span class="line">组合：（包含关系），确保成员连边不被提前释放，重写<span class="built_in">set</span>方法，retain一下。成员变量在dealloc中配对释放。内存泄露：1.set没有retain对象，2.没有release旧对象，3.没有判断<span class="built_in">set</span>方法传入是否是同一对象</span><br><span class="line">依赖：（对象作为方法参数传递）</span><br></pre></td></tr></table></figure><h3 id="autorrelease（pool）-垃圾回收机制"><a href="#autorrelease（pool）-垃圾回收机制" class="headerlink" title="autorrelease（pool）/垃圾回收机制"></a>autorrelease（pool）/垃圾回收机制</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">autorrelease：把该对象放入自动释放池，自动释放池释放时，内部对象引用计数-1。</span><br><span class="line">NSAutorreleasePool：通过接受对象向他发送的release消息，记录该对象的release消息，自动释放池销毁时，向池中记录release的对象发送release消息。</span><br><span class="line"> </span><br><span class="line">垃圾回收机制：autorrelease只是延迟释放，GC是每隔一段时间询问程序，是否有无指针指向的对象，没有就释放</span><br></pre></td></tr></table></figure><h3 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">自动释放池：</span><br><span class="line">    1.存储多想对象类型的指针变量（可以嵌套）</span><br><span class="line">    2.作用：将对象与自动释放池建议关系，池子内调用autorrelease，在自动释放池销毁时销毁对象，延迟release销毁时间</span><br><span class="line">    3.对池内对象作用：存入池中的对象，池销毁，全部对象release一次</span><br><span class="line">    4.调用autorrelease将对象加入自动释放池，多次调用导致野指针异常</span><br><span class="line">    5.释放时机：简单：autorrelease的&#125;执行完后。实际：Autorrelease对象是在当前RunLoop迭代结束时释放，原因是：系统在每个RunLoop迭代中加入了自动释放池Push，Pop</span><br></pre></td></tr></table></figure><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">block中多次使用weakSelf（延迟操作，导致取不到弱指针），可以block种先使用strongSelf，防止执行是weakSelf意外释放，对于非ARCweak改为block就可以</span><br><span class="line"></span><br><span class="line">release和drain：ARC中一样，GC中release无效操作，所以无论是否为GC使用drain没有问题。</span><br><span class="line"></span><br><span class="line">copy：OC对象类型如果有mutable，深拷贝，新对象为count=1，没有为浅拷贝，count+1.</span><br></pre></td></tr></table></figure><h3 id="其他总结"><a href="#其他总结" class="headerlink" title="其他总结"></a>其他总结</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">通过Observer监听RunLoop状态，一旦监听到RunLoop即将进入休眠等状态，就释放自动释放池。</span><br><span class="line"></span><br><span class="line">FIFO：新访问的数据插入队列尾部，数据在队列中移动，淘汰头部数据。LRU（FIFO相反），LFU</span><br><span class="line"></span><br><span class="line">循环引用：定时器（timer作为类的成员变量，self-target,不使用记得invalidate），Blcok（block在copy时对内部对象强引用（ARC）或者引用计数+1（MRC）），代理：（assign（MRC），weak（ARC））</span><br><span class="line"></span><br><span class="line">通知：多对多，主要跨层传值。对象加入到通知中心后，对象被销毁前没有将对象从通知中心移除，当再次发送通知的时候，会崩溃。</span><br><span class="line"></span><br><span class="line">默认关键字：基本数据类型（atomic，readwrite，assign），OC对象类型（atomic，readwrite，strong）</span><br><span class="line"></span><br><span class="line">TableView代理用assign：控制器对内部的View进行了一次retain，TableView对代理控制器也retain一次就会循环引用。</span><br></pre></td></tr></table></figure><h3 id="其实知道了这个并不证明就能写出好的代码，还需要时间的沉淀，不断的尝试，不断的思考与总结。感谢你能看到最后，希望对你有用，我们下次再见！"><a href="#其实知道了这个并不证明就能写出好的代码，还需要时间的沉淀，不断的尝试，不断的思考与总结。感谢你能看到最后，希望对你有用，我们下次再见！" class="headerlink" title="其实知道了这个并不证明就能写出好的代码，还需要时间的沉淀，不断的尝试，不断的思考与总结。感谢你能看到最后，希望对你有用，我们下次再见！"></a>其实知道了这个并不证明就能写出好的代码，还需要时间的沉淀，不断的尝试，不断的思考与总结。感谢你能看到最后，希望对你有用，我们下次再见！</h3>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>温馨提示</title>
      <link href="/2016/03/01/%E6%B8%A9%E9%A6%A8%E6%8F%90%E7%A4%BA/"/>
      <url>/2016/03/01/%E6%B8%A9%E9%A6%A8%E6%8F%90%E7%A4%BA/</url>
      <content type="html"><![CDATA[<p>嗨，欢迎来到梦工厂，我是曹理鹏 (@iCocos)，一名 PHP开发工程师，前iOS(+游戏)/ 前端 开发者，希望做点有意义的事情。现居广州，正在修行，探求创意之源。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">微信：clpaial10201119 / QQ：2211523682</span><br><span class="line">博客(前后端)：https://icocos.github.io/</span><br><span class="line">github：https://github.com/al1020119</span><br><span class="line">个人网站：http://www.icocos.cn/</span><br></pre></td></tr></table></figure><a id="more"></a><p>由于学习，技术方向的原因，本人之前<a href="http://al1020119.github.io/" target="_blank" rel="noopener">github博客</a>将会停止更新，之前所有文章偏向技术，并且主要针对iOS基础，底层，面试与实战，此后将会停止更新此博客，并将所有新发布文章，更新至当前<a href="https://icocos.github.io/">博客</a>地址，届时会不定时在公众号，和微博发布相关动态。</p><ul><li>此博客将会保函以下内容：<ul><li>iOS实战经验(+游戏)</li><li>前端开发相关技术</li><li>后端开发实战/架构/优化</li><li>读书笔记与后感</li><li>个人业余爱好</li><li>其他原创杂文</li></ul></li></ul><p>如果你想了解更多关于作者，或者关于PHP后端开发，iOS/前后端，和个人关注内容，请关注我的个人公众号，也可以通过微信，QQ，Github联系我，也可以直接在这里评论留言。</p><p>同时，如果对我的文章有一些意见或者建议，也欢迎联系我，我们一起共进退！</p>]]></content>
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 温馨提示 </tag>
            
            <tag> iCocos </tag>
            
            <tag> 提示 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
