<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>大数据面试之Zookeeper</title>
      <link href="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E4%B9%8BZookeeper/"/>
      <url>/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E4%B9%8BZookeeper/</url>
      <content type="html"><![CDATA[<h2 id="zookeeper是什么-有什么功能"><a href="#zookeeper是什么-有什么功能" class="headerlink" title="zookeeper是什么,有什么功能"></a>zookeeper是什么,有什么功能</h2><p>Zookeeper 是 一个典型的分布式数据一致性的解决方案.</p><p><strong>Zookeeper的典型应用场景</strong>:</p><ul><li>数据发布/订阅</li><li>负载均衡</li><li>命名服务</li><li>分布式协调/通知</li><li>集群管理</li><li>Master</li><li>分布式锁</li><li>分布式队列</li></ul><a id="more"></a><h2 id="zk-有几种部署模式"><a href="#zk-有几种部署模式" class="headerlink" title="zk 有几种部署模式"></a>zk 有几种部署模式</h2><p>zookeeper有两种运行模式: 集群模式和单机模式,还有一种伪集群模式,在单机模式下模拟集群的zookeeper服务</p><h2 id="zk是怎样保证主从节点的状态同步"><a href="#zk是怎样保证主从节点的状态同步" class="headerlink" title="zk是怎样保证主从节点的状态同步"></a>zk是怎样保证主从节点的状态同步</h2><p>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p><h2 id="说一下zk的通知机制"><a href="#说一下zk的通知机制" class="headerlink" title="说一下zk的通知机制"></a>说一下zk的通知机制</h2><p>客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变</p><h2 id="zk的分布式锁实现方式"><a href="#zk的分布式锁实现方式" class="headerlink" title="zk的分布式锁实现方式"></a>zk的分布式锁实现方式</h2><p>使用zookeeper实现分布式锁的算法流程，假设锁空间的根节点为/lock：</p><ol><li>客户端连接zookeeper，并在/lock下创建<strong>临时的</strong>且<strong>有序的</strong>子节点，第一个客户端对应的子节点为/lock/lock-0000000000，第二个为/lock/lock-0000000001，以此类推。</li><li>客户端获取/lock下的子节点列表，判断自己创建的子节点是否为当前子节点列表中<strong>序号最小</strong>的子节点，如果是则认为获得锁，否则<strong>监听刚好在自己之前一位的子节点删除消息</strong>，获得子节点变更通知后重复此步骤直至获得锁；</li><li>执行业务代码；</li><li>完成业务流程后，删除对应的子节点释放锁。</li></ol><p><a href="http://www.dengshenyu.com/java/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2017/10/23/zookeeper-distributed-lock.html" target="_blank" rel="noopener">参考文章</a></p><h2 id="zk-采用的哪种分布式一致性协议-还有哪些分布式一致性协议"><a href="#zk-采用的哪种分布式一致性协议-还有哪些分布式一致性协议" class="headerlink" title="zk 采用的哪种分布式一致性协议? 还有哪些分布式一致性协议"></a>zk 采用的哪种分布式一致性协议? 还有哪些分布式一致性协议</h2><p>常见的分布式一致性协议有: 两阶段提交协议，三阶段提交协议，向量时钟，RWN协议，paxos协议，Raft协议. zk采用的是paxos协议.</p><ul><li><h4 id="两阶段提交协议-2PC"><a href="#两阶段提交协议-2PC" class="headerlink" title="两阶段提交协议(2PC)"></a>两阶段提交协议(2PC)</h4><p>两阶段提交协议，简称2PC，是比较常用的解决分布式事务问题的方式，要么所有参与进程都提交事务，要么都取消事务，即实现ACID中的原子性(A)的常用手段。</p></li><li><h4 id="三阶段提交协议-3PC"><a href="#三阶段提交协议-3PC" class="headerlink" title="三阶段提交协议(3PC)"></a>三阶段提交协议(3PC)</h4><p>3PC就是在2PC基础上将2PC的提交阶段细分位两个阶段：预提交阶段和提交阶段</p></li><li><h4 id="向量时钟"><a href="#向量时钟" class="headerlink" title="向量时钟"></a>向量时钟</h4><p>通过向量空间祖先继承的关系比较, 使数据保持最终一致性,这就是向量时钟的基本定义。</p></li><li><h4 id="NWR协议"><a href="#NWR协议" class="headerlink" title="NWR协议"></a>NWR协议</h4><p>NWR是一种在分布式存储系统中用于控制一致性级别的一种策略。在Amazon的Dynamo云存储系统中，就应用NWR来控制一致性。<br>让我们先来看看这三个字母的含义：<br>N：在分布式存储系统中，有多少份备份数据<br>W：代表一次成功的更新操作要求至少有w份数据写入成功<br>R： 代表一次成功的读数据操作要求至少有R份数据成功读取<br>NWR值的不同组合会产生不同的一致性效果，当W+R&gt;N的时候，整个系统对于客户端来讲能保证强一致性。当W+R 以常见的N=3、W=2、R=2为例：<br>N=3，表示，任何一个对象都必须有三个副本（Replica），W=2表示，对数据的修改操作（Write）只需要在3个Replica中的2个上面完成就返回，R=2表示，从三个对象中要读取到2个数据对象，才能返回。<br>在分布式系统中，数据的单点是不允许存在的。即线上正常存在的Replica数量是1的情况是非常危险的，因为一旦这个Replica再次错误，就 可能发生数据的永久性错误。假如我们把N设置成为2，那么，只要有一个存储节点发生损坏，就会有单点的存在。所以N必须大于2。N约高，系统的维护和整体 成本就越高。工业界通常把N设置为3。<br>当W是2、R是2的时候，W+R&gt;N，这种情况对于客户端就是强一致性的。</p></li><li><h4 id="paxos协议"><a href="#paxos协议" class="headerlink" title="paxos协议"></a>paxos协议</h4><p><a href="http://chuansong.me/n/2189245" target="_blank" rel="noopener">架构师需要了解的Paxos原理，历程及实践</a></p></li><li><h4 id="Raft协议"><a href="#Raft协议" class="headerlink" title="Raft协议"></a>Raft协议</h4><p><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">Raft协议的动画</a></p></li></ul><p><a href="https://blog.csdn.net/chdhust/article/details/52651741" target="_blank" rel="noopener">参考文章</a></p><h2 id="讲一下leader-选举过程"><a href="#讲一下leader-选举过程" class="headerlink" title="讲一下leader 选举过程"></a>讲一下leader 选举过程</h2><p>　　这里选取3台机器组成的服务器集群为例。在集群初始化阶段，当有一台服务器Server1启动时，其单独无法进行和完成Leader选举，当第二台服务器Server2启动时，此时两台机器可以相互通信，每台机器都试图找到Leader，于是进入Leader选举过程。选举过程如下</p><p>　　<strong>(1) 每个Server发出一个投票</strong>。由于是初始情况，Server1和Server2都会将自己作为Leader服务器来进行投票，每次投票会包含所推举的服务器的myid和ZXID，使用(myid, ZXID)来表示，此时Server1的投票为(1, 0)，Server2的投票为(2, 0)，然后各自将这个投票发给集群中其他机器。</p><p>　　<strong>(2) 接受来自各个服务器的投票</strong>。集群的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票、是否来自LOOKING状态的服务器。</p><p>　　<strong>(3) 处理投票</strong>。针对每一个投票，服务器都需要将别人的投票和自己的投票进行PK，PK规则如下</p><p>　　　　<strong>· 优先检查ZXID</strong>。ZXID比较大的服务器优先作为Leader。</p><p>　　　　<strong>· 如果ZXID相同，那么就比较myid</strong>。myid较大的服务器作为Leader服务器。</p><p>　　对于Server1而言，它的投票是(1, 0)，接收Server2的投票为(2, 0)，首先会比较两者的ZXID，均为0，再比较myid，此时Server2的myid最大，于是更新自己的投票为(2, 0)，然后重新投票，对于Server2而言，其无须更新自己的投票，只是再次向集群中所有机器发出上一次投票信息即可。</p><p>　　<strong>(4) 统计投票</strong>。每次投票后，服务器都会统计投票信息，判断是否已经有过半机器接受到相同的投票信息，对于Server1、Server2而言，都统计出集群中已经有两台机器接受了(2, 0)的投票信息，此时便认为已经选出了Leader。</p><p>　　<strong>(5) 改变服务器状态</strong>。一旦确定了Leader，每个服务器就会更新自己的状态，如果是Follower，那么就变更为FOLLOWING，如果是Leader，就变更为LEADING。</p><h3 id="Leader选举算法分析"><a href="#Leader选举算法分析" class="headerlink" title="Leader选举算法分析"></a>Leader选举算法分析</h3><p>在3.4.0后的Zookeeper的版本只保留了TCP版本的FastLeaderElection选举算法。当一台机器进入Leader选举时，当前集群可能会处于以下两种状态</p><p>　　　　· 集群中已经存在Leader。</p><p>　　　　· 集群中不存在Leader。</p><p>　　对于集群中已经存在Leader而言，此种情况一般都是某台机器启动得较晚，在其启动之前，集群已经在正常工作，对这种情况，该机器试图去选举Leader时，会被告知当前服务器的Leader信息，对于该机器而言，仅仅需要和Leader机器建立起连接，并进行状态同步即可。而在集群中不存在Leader情况下则会相对复杂，其步骤如下</p><p>　　(1) <strong>第一次投票</strong>。无论哪种导致进行Leader选举，集群的所有机器都处于试图选举出一个Leader的状态，即LOOKING状态，LOOKING机器会向所有其他机器发送消息，该消息称为投票。投票中包含了SID（服务器的唯一标识）和ZXID（事务ID），(SID, ZXID)形式来标识一次投票信息。假定Zookeeper由5台机器组成，SID分别为1、2、3、4、5，ZXID分别为9、9、9、8、8，并且此时SID为2的机器是Leader机器，某一时刻，1、2所在机器出现故障，因此集群开始进行Leader选举。在第一次投票时，每台机器都会将自己作为投票对象，于是SID为3、4、5的机器投票情况分别为(3, 9)，(4, 8)， (5, 8)。</p><p>　　(2) <strong>变更投票</strong>。每台机器发出投票后，也会收到其他机器的投票，每台机器会根据一定规则来处理收到的其他机器的投票，并以此来决定是否需要变更自己的投票，这个规则也是整个Leader选举算法的核心所在，其中术语描述如下</p><p>　　　　<strong>· vote_sid</strong>：接收到的投票中所推举Leader服务器的SID。</p><p>　　　　<strong>· vote_zxid</strong>：接收到的投票中所推举Leader服务器的ZXID。</p><p>　　　　<strong>· self_sid</strong>：当前服务器自己的SID。</p><p>　　　　<strong>· self_zxid</strong>：当前服务器自己的ZXID。</p><p>　　每次对收到的投票的处理，都是对(vote_sid, vote_zxid)和(self_sid, self_zxid)对比的过程。</p><p>　　　　规则一：如果vote_zxid大于self_zxid，就认可当前收到的投票，并再次将该投票发送出去。</p><p>　　　　规则二：如果vote_zxid小于self_zxid，那么坚持自己的投票，不做任何变更。</p><p>　　　　规则三：如果vote_zxid等于self_zxid，那么就对比两者的SID，如果vote_sid大于self_sid，那么就认可当前收到的投票，并再次将该投票发送出去。</p><p>　　　　规则四：如果vote_zxid等于self_zxid，并且vote_sid小于self_sid，那么坚持自己的投票，不做任何变更。</p><p>　　结合上面规则，给出下面的集群变更过程。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/pictures/leader选举算法.png" alt=""></p><p>​    (3) <strong>确定Leader</strong>。经过第二轮投票后，集群中的每台机器都会再次接收到其他机器的投票，然后开始统计投票，如果一台机器收到了超过半数的相同投票，那么这个投票对应的SID机器即为Leader。此时Server3将成为Leader。</p><p>　　由上面规则可知，通常那台服务器上的数据越新（ZXID会越大），其成为Leader的可能性越大，也就越能够保证数据的恢复。如果ZXID相同，则SID越大机会越大。</p><p><a href="https://www.cnblogs.com/leesf456/p/6107600.html" target="_blank" rel="noopener">参考文章</a></p>]]></content>
      
      <categories>
          
          <category> Zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 面试 </tag>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>大数据面试之Kafka</title>
      <link href="/2020/03/10/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E4%B9%8Bkafka/"/>
      <url>/2020/03/10/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E4%B9%8Bkafka/</url>
      <content type="html"><![CDATA[<h2 id="讲一下kafka-的架构"><a href="#讲一下kafka-的架构" class="headerlink" title="讲一下kafka 的架构"></a>讲一下kafka 的架构</h2><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/pictures/kafka架构图.png" alt=""></p><ul><li><p><strong>Producer</strong>：消息生产者</p><ul><li><p>Producer可以发送消息到Topic</p></li><li><ul><li>Topic的消息存放在不同Partition中，不同Partition存放在不同Broker中</li><li>Producer只需要指定Topic的名字、要连接到的Broker，这样Kafka就可以自动地把消息数据路由到合适的Broker（不一定是指定连接的Broker）</li></ul></li></ul></li></ul><a id="more"></a><ul><li><p>Producer发送消息后，可以选择是否要确认消息写入成功（ACK，Acknowledgment）</p></li><li><ul><li>ACK=0：Producer不会等待ACK（消息可能丢失）</li><li>ACK=1：Producer会等待Leader Partition的ACK（Follower Partition消息可能丢失）</li><li>ACK=all：Producer会等待Leader Partition和Follower Partition的ACK（消息不会丢失）</li></ul></li><li><p>消息key：Producer可以给消息加上key，带相同key的消息会被分发到同一个Partition，这样就可以保证带相同key的消息的消费是有序的</p></li></ul><ul><li><p><strong>Broker</strong>：每个Broker里包含了不同Topic的不同Partition，Partition中包含了有序的消息</p><ul><li>一个Kafka集群由多个Broker（server）组成</li><li>每个Broker都有ID标识</li><li>每个Broker里保存一定数量的Partition</li><li>客户端只要连接上任意一个Broker，就可以连接上整个Kafka集群</li><li>大多数Kafka集群刚开始的时候建议使用至少3个Broker，集群大了可以有上百个Broker</li></ul></li><li><p><strong>Consumer</strong>：消息消费者</p><ul><li><p>Consumer可以从Topic读取消息进行消费</p></li><li><ul><li>Topic的消息存放在不同Partition中，不同Partition存放在不同Broker中</li><li>Consumer只需要指定Topic的名字、要连接到的Broker，这样Kafka就可以自动地把Consumer路由到合适的Broker拉取消息进行消费（不一定是指定连接的Broker）</li><li>每一个Partition中的消息都会被有序消费</li></ul></li><li><p>Consumer Group：</p></li><li><ul><li>Consumer Group由多个Consumer组成</li><li>Consumer Group里的每个Consumer都会从不同的Partition中读取消息</li><li>如果Consumer的数量大于Partition的数量，那么多出来的Consumer就会空闲下来（浪费资源）</li></ul></li><li><p>Consumer offset：</p></li><li><ul><li>Kafka会为Consumer Group要消费的每个Partion保存一个offset，这个offset标记了该Consumer Group最后消费消息的位置</li><li>这个offset保存在Kafka里一个名为“__consumer_offsets”的Topic中；当Consumer从Kafka拉取消息消费时，同时也要对这个offset提交修改更新操作。这样若一个Consumer消费消息时挂了，其他Consumer可以通过这个offset值重新找到上一个消息再进行处理</li></ul></li></ul></li></ul><p><a href="https://zhuanlan.zhihu.com/p/48896367" target="_blank" rel="noopener">参考文章</a></p><h2 id="kafka-与其他消息组件对比"><a href="#kafka-与其他消息组件对比" class="headerlink" title="kafka 与其他消息组件对比"></a>kafka 与其他消息组件对比</h2><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/why-mq.md" target="_blank" rel="noopener">推荐阅读文章</a></p><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级，比 RocketMQ、Kafka 低一个数量级</td><td>同 ActiveMQ</td><td>10 万级，支撑高吞吐</td><td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td>topic 数量对吞吐量的影响</td><td></td><td></td><td>topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td></tr><tr><td>时效性</td><td>ms 级</td><td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td><td>ms 级</td><td>延迟在 ms 级以内</td></tr><tr><td>可用性</td><td>高，基于主从架构实现高可用</td><td>同 ActiveMQ</td><td>非常高，分布式架构</td><td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢失数据</td><td>基本不丢</td><td>经过参数优化配置，可以做到 0 丢失</td><td>同 RocketMQ</td></tr><tr><td>功能支持</td><td>MQ 领域的功能极其完备</td><td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td><td>MQ 功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table><h2 id="kafka-实现高吞吐的原理"><a href="#kafka-实现高吞吐的原理" class="headerlink" title="kafka 实现高吞吐的原理"></a>kafka 实现高吞吐的原理</h2><ul><li>读写文件依赖OS文件系统的页缓存，而不是在JVM内部缓存数据，利用OS来缓存，内存利用率高</li><li>sendfile技术（零拷贝），避免了传统网络IO四步流程</li><li>支持End-to-End的压缩</li><li>顺序IO以及常量时间get、put消息</li><li>Partition 可以很好的横向扩展和提供高并发处理</li></ul><p><a href="https://www.jianshu.com/p/d6a73be9d803" target="_blank" rel="noopener">参考文章1</a></p><p><a href="https://blog.csdn.net/stark_summer/article/details/50144591" target="_blank" rel="noopener">参考文章2</a></p><h2 id="kafka怎样保证不重复消费"><a href="#kafka怎样保证不重复消费" class="headerlink" title="kafka怎样保证不重复消费"></a>kafka怎样保证不重复消费</h2><p>此问题其实等价于保证消息队列消费的幂等性</p><p>主要需要结合实际业务来操作:</p><ul><li>比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。</li><li>比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。</li><li>比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。</li><li>比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。</li></ul><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-that-messages-are-not-repeatedly-consumed.md" target="_blank" rel="noopener">参考文章</a></p><h2 id="kafka怎样保证不丢失消息"><a href="#kafka怎样保证不丢失消息" class="headerlink" title="kafka怎样保证不丢失消息"></a>kafka怎样保证不丢失消息</h2><h4 id="消费端弄丢了数据"><a href="#消费端弄丢了数据" class="headerlink" title="消费端弄丢了数据"></a>消费端弄丢了数据</h4><p>唯一可能导致消费者弄丢数据的情况，就是说，你消费到了这个消息，然后消费者那边<strong>自动提交了 offset</strong>，让 Kafka 以为你已经消费好了这个消息，但其实你才刚准备处理这个消息，你还没处理，你自己就挂了，此时这条消息就丢咯。</p><p>这不是跟 RabbitMQ 差不多吗，大家都知道 Kafka 会自动提交 offset，那么只要<strong>关闭自动提交</strong> offset，在处理完之后自己手动提交 offset，就可以保证数据不会丢。但是此时确实还是<strong>可能会有重复消费</strong>，比如你刚处理完，还没提交 offset，结果自己挂了，此时肯定会重复消费一次，自己保证幂等性就好了。</p><p>生产环境碰到的一个问题，就是说我们的 Kafka 消费者消费到了数据之后是写到一个内存的 queue 里先缓冲一下，结果有的时候，你刚把消息写入内存 queue，然后消费者会自动提交 offset。然后此时我们重启了系统，就会导致内存 queue 里还没来得及处理的数据就丢失了。</p><h4 id="Kafka-弄丢了数据"><a href="#Kafka-弄丢了数据" class="headerlink" title="Kafka 弄丢了数据"></a>Kafka 弄丢了数据</h4><p>这块比较常见的一个场景，就是 Kafka 某个 broker 宕机，然后重新选举 partition 的 leader。大家想想，要是此时其他的 follower 刚好还有些数据没有同步，结果此时 leader 挂了，然后选举某个 follower 成 leader 之后，不就少了一些数据？这就丢了一些数据啊。</p><p>生产环境也遇到过，我们也是，之前 Kafka 的 leader 机器宕机了，将 follower 切换为 leader 之后，就会发现说这个数据就丢了。</p><p>所以此时一般是要求起码设置如下 4 个参数：</p><ul><li>给 topic 设置 <code>replication.factor</code> 参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本。</li><li>在 Kafka 服务端设置 <code>min.insync.replicas</code> 参数：这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower 吧。</li><li>在 producer 端设置 <code>acks=all</code>：这个是要求每条数据，必须是<strong>写入所有 replica 之后，才能认为是写成功了</strong>。</li><li>在 producer 端设置 <code>retries=MAX</code>（很大很大很大的一个值，无限次重试的意思）：这个是<strong>要求一旦写入失败，就无限重试</strong>，卡在这里了。</li></ul><p>我们生产环境就是按照上述要求配置的，这样配置之后，至少在 Kafka broker 端就可以保证在 leader 所在 broker 发生故障，进行 leader 切换时，数据不会丢失。</p><h4 id="生产者会不会弄丢数据？"><a href="#生产者会不会弄丢数据？" class="headerlink" title="生产者会不会弄丢数据？"></a>生产者会不会弄丢数据？</h4><p>如果按照上述的思路设置了 <code>acks=all</code>，一定不会丢，要求是，你的 leader 接收到消息，所有的 follower 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次。</p><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-the-reliable-transmission-of-messages.md" target="_blank" rel="noopener">参考文章</a></p><h2 id="kafka-与-spark-streaming-集成-如何保证-exactly-once-语义"><a href="#kafka-与-spark-streaming-集成-如何保证-exactly-once-语义" class="headerlink" title="kafka 与 spark streaming 集成,如何保证 exactly once 语义"></a>kafka 与 spark streaming 集成,如何保证 exactly once 语义</h2><ul><li><h3 id="Spark-Streaming上游对接kafka时保证Exactly-Once"><a href="#Spark-Streaming上游对接kafka时保证Exactly-Once" class="headerlink" title="Spark Streaming上游对接kafka时保证Exactly Once"></a>Spark Streaming上游对接kafka时保证Exactly Once</h3><p>Spark Streaming使用Direct模式对接上游kafka。无论kafka有多少个partition， 使用Direct模式总能保证SS中有相同数量的partition与之相对， 也就是说SS中的KafkaRDD的并发数量在Direct模式下是由上游kafka决定的。 在这个模式下，kafka的offset是作为KafkaRDD的一部分存在，会存储在checkpoints中， 由于checkpoints只存储offset内容，而不存储数据，这就使得checkpoints是相对轻的操作。 这就使得SS在遇到故障时，可以从checkpoint中恢复上游kafka的offset，从而保证exactly once</p></li><li><h3 id="Spark-Streaming输出下游保证Exactly-once"><a href="#Spark-Streaming输出下游保证Exactly-once" class="headerlink" title="Spark Streaming输出下游保证Exactly once"></a>Spark Streaming输出下游保证Exactly once</h3><ul><li><p>第一种“鸵鸟做法”，就是期望下游（数据）具有幂等特性。</p><p>多次尝试总是写入相同的数据，例如，saveAs***Files 总是将相同的数据写入生成的文件</p></li></ul></li><li><ul><li><p>使用事务更新</p><p>所有更新都是事务性的，以便更新完全按原子进行。这样做的一个方法如下： 使用批处理时间(在foreachRDD中可用)和RDD的partitionIndex（分区索引）来创建identifier（标识符)。 该标识符唯一地标识streaming application 中的blob数据。 使用该identifier，blob 事务地更新到外部系统中。也就是说，如果identifier尚未提交，则以 (atomicall)原子方式提交分区数据和identifier。否则，如果已经提交，请跳过更新。</p></li></ul></li></ul><p><a href="http://www.aihacks.life/post/spark-streaming%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81exactly-once%E8%AF%AD%E4%B9%89/" target="_blank" rel="noopener">参考文章1</a></p><p><a href="https://www.jianshu.com/p/10de8f3b1be8" target="_blank" rel="noopener">参考文章2</a></p><p><a href="https://blog.csdn.net/cymvp/article/details/52605987" target="_blank" rel="noopener">参考文章3</a></p><h2 id="Ack-有哪几种-生产中怎样选择"><a href="#Ack-有哪几种-生产中怎样选择" class="headerlink" title="Ack 有哪几种, 生产中怎样选择?"></a>Ack 有哪几种, 生产中怎样选择?</h2><p>ack=0/1/-1的不同情况：</p><ul><li><p>Ack = 0</p><p>producer不等待broker的ack，broker一接收到还没有写入磁盘就已经返回，当broker故障时有可能丢失数据；</p></li><li><p>Ack = 1</p><p>producer等待broker的ack，partition的leader落盘成功后返回ack，如果在follower同步成功之前leader故障，那么将会丢失数据；</p></li><li><p>Ack = -1</p><p>producer等待broker的ack，partition的leader和follower全部落盘成功后才返回ack，数据一般不会丢失，延迟时间长但是可靠性高。</p></li></ul><p><strong>生产中主要以 Ack=-1为主,如果压力过大,可切换为Ack=1. Ack=0的情况只能在测试中使用.</strong></p><h2 id="如何通过offset寻找数据"><a href="#如何通过offset寻找数据" class="headerlink" title="如何通过offset寻找数据"></a>如何通过offset寻找数据</h2><p>如果consumer要找offset是1008的消息，那么，</p><p>1，按照二分法找到小于1008的segment，也就是00000000000000001000.log和00000000000000001000.index</p><p>2，用目标offset减去文件名中的offset得到消息在这个segment中的偏移量。也就是1008-1000=8，偏移量是8。</p><p>3，再次用二分法在index文件中找到对应的索引，也就是第三行6,45。</p><p>4，到log文件中，从偏移量45的位置开始（实际上这里的消息offset是1006），顺序查找，直到找到offset为1008的消息。查找期间kafka是按照log的存储格式来判断一条消息是否结束的。</p><p><a href="https://blog.csdn.net/lkforce/article/details/77854813" target="_blank" rel="noopener">参考文章</a></p><h2 id="如何清理过期数据"><a href="#如何清理过期数据" class="headerlink" title="如何清理过期数据"></a>如何清理过期数据</h2><ul><li><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>log.cleanup.policy=delete启用删除策略</p><ul><li>直接删除，删除后的消息不可恢复。可配置以下两个策略：<br>清理超过指定时间清理：<br>log.retention.hours=16</li><li>超过指定大小后，删除旧的消息：<br>log.retention.bytes=1073741824<br>为了避免在删除时阻塞读操作，采用了copy-on-write形式的实现，删除操作进行时，读取操作的二分查找功能实际是在一个静态的快照副本上进行的，这类似于Java的CopyOnWriteArrayList。</li></ul></li><li><h4 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h4><p>将数据压缩，只保留每个key最后一个版本的数据。<br>首先在broker的配置中设置log.cleaner.enable=true启用cleaner，这个默认是关闭的。<br>在topic的配置中设置log.cleanup.policy=compact启用压缩策略。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/pictures/kafka压缩.png" alt=""></p><p>如上图，在整个数据流中，每个Key都有可能出现多次，压缩时将根据Key将消息聚合，只保留最后一次出现时的数据。这样，无论什么时候消费消息，都能拿到每个Key的最新版本的数据。<br>压缩后的offset可能是不连续的，比如上图中没有5和7，因为这些offset的消息被merge了，当从这些offset消费消息时，将会拿到比这个offset大的offset对应的消息，比如，当试图获取offset为5的消息时，实际上会拿到offset为6的消息，并从这个位置开始消费。<br>这种策略只适合特俗场景，比如消息的key是用户ID，消息体是用户的资料，通过这种压缩策略，整个消息集里就保存了所有用户最新的资料。<br>压缩策略支持删除，当某个Key的最新版本的消息没有内容时，这个Key将被删除，这也符合以上逻辑。</p></li></ul><p><a href="https://blog.csdn.net/honglei915/article/details/49683065" target="_blank" rel="noopener">参考文章</a></p><h2 id="1条message中包含哪些信息"><a href="#1条message中包含哪些信息" class="headerlink" title="1条message中包含哪些信息"></a>1条message中包含哪些信息</h2><table><thead><tr><th><strong>Field</strong></th><th>Description</th></tr></thead><tbody><tr><td>Attributes</td><td>该字节包含有关消息的元数据属性。 最低的2位包含用于消息的压缩编解码器。 其他位应设置为0。</td></tr><tr><td>Crc</td><td>CRC是消息字节的其余部分的CRC32。 这用于检查代理和使用者上的消息的完整性。</td></tr><tr><td></td><td>key是用于分区分配的可选参数。 key可以为null。</td></tr><tr><td>MagicByte</td><td>这是用于允许向后兼容的消息二进制格式演变的版本ID。 当前值为0。</td></tr><tr><td>Offset</td><td>这是kafka中用作日志序列号的偏移量。 当producer发送消息时，它实际上并不知道偏移量，并且可以填写它喜欢的任何值。</td></tr><tr><td>Value</td><td>该值是实际的消息内容，作为不透明的字节数组。 Kafka支持递归消息，在这种情况下，它本身可能包含消息集。 消息可以为null。</td></tr></tbody></table><h2 id="讲一下zookeeper在kafka中的作用"><a href="#讲一下zookeeper在kafka中的作用" class="headerlink" title="讲一下zookeeper在kafka中的作用"></a>讲一下zookeeper在kafka中的作用</h2><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/pictures/kafka在zk中的存储结构.png" alt=""></p><h4 id="zk的作用主要有如下几点"><a href="#zk的作用主要有如下几点" class="headerlink" title="zk的作用主要有如下几点:"></a>zk的作用主要有如下几点:</h4><ol><li>kafka的元数据都存放在zk上面,由zk来管理</li><li>0.8之前版本的kafka, consumer的消费状态，group的管理以及 offset的值都是由zk管理的,现在offset会保存在本地topic文件里</li><li>负责borker的lead选举和管理</li></ol><h2 id="kafka-可以脱离-zookeeper-单独使用吗"><a href="#kafka-可以脱离-zookeeper-单独使用吗" class="headerlink" title="kafka 可以脱离 zookeeper 单独使用吗"></a>kafka 可以脱离 zookeeper 单独使用吗</h2><p>kafka 不能脱离 zookeeper 单独使用，因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。</p><h2 id="kafka-有几种数据保留策略"><a href="#kafka-有几种数据保留策略" class="headerlink" title="kafka 有几种数据保留策略"></a>kafka 有几种数据保留策略</h2><p>kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。</p><h2 id="kafka同时设置了7天和10G清除数据-到第5天的时候消息到达了10G-这个时候kafka如何处理"><a href="#kafka同时设置了7天和10G清除数据-到第5天的时候消息到达了10G-这个时候kafka如何处理" class="headerlink" title="kafka同时设置了7天和10G清除数据,到第5天的时候消息到达了10G,这个时候kafka如何处理?"></a>kafka同时设置了7天和10G清除数据,到第5天的时候消息到达了10G,这个时候kafka如何处理?</h2><p>这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。</p>]]></content>
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 面试 </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>大数据面试之HBase</title>
      <link href="/2020/03/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E4%B9%8BHBase/"/>
      <url>/2020/03/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E4%B9%8BHBase/</url>
      <content type="html"><![CDATA[<h2 id="讲一下-Hbase-架构"><a href="#讲一下-Hbase-架构" class="headerlink" title="讲一下 Hbase 架构"></a>讲一下 Hbase 架构</h2><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/pictures/hbase架构图.png" alt=""></p><p><strong>Hbase主要包含HMaster/HRegionServer/Zookeeper</strong></p><a id="more"></a><ul><li><p><strong>HRegionServer 负责实际数据的读写. 当访问数据时, 客户端直接与RegionServer通信.</strong></p><p>HBase的表根据Row Key的区域分成多个Region, 一个Region包含这这个区域内所有数据. 而Region server负责管理多个Region, 负责在这个Region server上的所有region的读写操作. </p></li><li><p><strong>HMaster 负责管理Region的位置, DDL(新增和删除表结构)</strong></p><ul><li>协调RegionServer</li><li>在集群处于数据恢复或者动态调整负载时,分配Region到某一个RegionServer中</li><li>管控集群,监控所有Region Server的状态</li><li>提供DDL相关的API, 新建(create),删除(delete)和更新(update)表结构.</li></ul></li><li><p><strong>Zookeeper 负责维护和记录整个Hbase集群的状态</strong></p><p>zookeeper探测和记录Hbase集群中服务器的状态信息.如果zookeeper发现服务器宕机,它会通知Hbase的master节点.</p></li></ul><h2 id="hbase-如何设计rowkey"><a href="#hbase-如何设计rowkey" class="headerlink" title="hbase 如何设计rowkey"></a>hbase 如何设计rowkey</h2><ul><li><p><strong>RowKey长度原则</strong></p><p>Rowkey是一个二进制码流，Rowkey的长度被很多开发者建议说设计在10~100个字节，不过建议是越短越好，不要超过16个字节。</p><p>原因如下：</p><ul><li><p>数据的持久化文件HFile中是按照KeyValue存储的，如果Rowkey过长比如100个字节，1000万列数据光Rowkey就要占用100*1000万=10亿个字节，将近1G数据，这会极大影响HFile的存储效率；</p></li><li><p>MemStore将缓存部分数据到内存，如果Rowkey字段过长内存的有效利用率会降低，系统将无法缓存更多的数据，这会降低检索效率。因此Rowkey的字节长度越短越好。</p></li><li><p>目前操作系统是都是64位系统，内存8字节对齐。控制在16个字节，8字节的整数倍利用操作系统的最佳特性。</p></li></ul></li><li><p><strong>RowKey散列原则</strong></p><p>如果Rowkey是按时间戳的方式递增，不要将时间放在二进制码的前面，建议将Rowkey的高位作为散列字段，由程序循环生成，低位放时间字段，这样将提高数据均衡分布在每个Regionserver实现负载均衡的几率。如果没有散列字段，首字段直接是时间信息将产生所有新数据都在一个RegionServer上堆积的热点现象，这样在做数据检索的时候负载将会集中在个别RegionServer，降低查询效率。</p></li><li><p><strong>RowKey唯一原则</strong></p><p>必须在设计上保证其唯一性。</p></li></ul><p><a href="https://zhuanlan.zhihu.com/p/30074408" target="_blank" rel="noopener">参考文章1</a></p><p><a href="http://www.nosqlnotes.com/technotes/hbase/hbase-rowkey-design/" target="_blank" rel="noopener">参考文章2</a></p><h2 id="讲一下hbase的存储结构-这样的存储结构有什么优缺点"><a href="#讲一下hbase的存储结构-这样的存储结构有什么优缺点" class="headerlink" title="讲一下hbase的存储结构,这样的存储结构有什么优缺点"></a>讲一下hbase的存储结构,这样的存储结构有什么优缺点</h2><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/pictures\hbase逻辑结构.png" alt=""></p><p><strong>Hbase的优点及应用场景</strong>:</p><ol><li>半结构化或非结构化数据:<br>对于数据结构字段不够确定或杂乱无章非常难按一个概念去进行抽取的数据适合用HBase，因为HBase支持动态添加列。</li><li>记录很稀疏：<br>RDBMS的行有多少列是固定的。为null的列浪费了存储空间。HBase为null的Column不会被存储，这样既节省了空间又提高了读性能。</li><li>多版本号数据：<br>依据Row key和Column key定位到的Value能够有随意数量的版本号值，因此对于须要存储变动历史记录的数据，用HBase是很方便的。比方某个用户的Address变更，用户的Address变更记录也许也是具有研究意义的。</li><li>仅要求最终一致性：<br>对于数据存储事务的要求不像金融行业和财务系统这么高，只要保证最终一致性就行。（比如HBase+elasticsearch时，可能出现数据不一致）</li><li>高可用和海量数据以及很大的瞬间写入量：<br>WAL解决高可用，支持PB级数据，put性能高<br>适用于插入比查询操作更频繁的情况。比如，对于历史记录表和日志文件。（HBase的写操作更加高效）</li><li>业务场景简单：<br>不需要太多的关系型数据库特性，列入交叉列，交叉表，事务，连接等。</li></ol><p><strong>Hbase的缺点：</strong></p><ol><li>单一RowKey固有的局限性决定了它不可能有效地支持多条件查询</li><li>不适合于大范围扫描查询</li><li>不直接支持 SQL 的语句查询</li></ol><p><a href="https://www.iteye.com/blog/forlan-2364661" target="_blank" rel="noopener">参考文章1</a></p><p><a href="https://blog.csdn.net/liaynling/article/details/81199238" target="_blank" rel="noopener">参考文章2</a></p><p><a href="https://juejin.im/post/5c31cf486fb9a04a102f6f89#heading-2" target="_blank" rel="noopener">参考文章3</a></p><h2 id="hbase的HA实现-zookeeper在其中的作用"><a href="#hbase的HA实现-zookeeper在其中的作用" class="headerlink" title="hbase的HA实现,zookeeper在其中的作用"></a>hbase的HA实现,zookeeper在其中的作用</h2><p> HBase中可以启动多个HMaster，通过Zookeeper的Master Election机制保证总有一个Master运行。<br>配置HBase高可用，只需要启动两个HMaster，让Zookeeper自己去选择一个Master Acitve即可</p><p>zk的在这里起到的作用就是用来管理master节点,以及帮助hbase做master选举</p><h2 id="HMaster宕机的时候-哪些操作还能正常工作"><a href="#HMaster宕机的时候-哪些操作还能正常工作" class="headerlink" title="HMaster宕机的时候,哪些操作还能正常工作"></a>HMaster宕机的时候,哪些操作还能正常工作</h2><p>对表内数据的增删查改是可以正常进行的,因为hbase client 访问数据只需要通过 zookeeper 来找到 rowkey 的具体 region 位置即可. 但是对于创建表/删除表等的操作就无法进行了,因为这时候是需要HMaster介入, 并且region的拆分,合并,迁移等操作也都无法进行了</p><h2 id="讲一下hbase的写数据的流程"><a href="#讲一下hbase的写数据的流程" class="headerlink" title="讲一下hbase的写数据的流程"></a>讲一下hbase的写数据的流程</h2><ol><li>Client先访问zookeeper，从.META.表获取相应region信息，然后从meta表获取相应region信息 </li><li>根据namespace、表名和rowkey根据meta表的数据找到写入数据对应的region信息 </li><li>找到对应的regionserver 把数据先写到WAL中，即HLog，然后写到MemStore上 </li><li>MemStore达到设置的阈值后则把数据刷成一个磁盘上的StoreFile文件。 </li><li>当多个StoreFile文件达到一定的大小后(这个可以称之为小合并，合并数据可以进行设置，必须大于等于2，小于10——hbase.hstore.compaction.max和hbase.hstore.compactionThreshold，默认为10和3)，会触发Compact合并操作，合并为一个StoreFile，（这里同时进行版本的合并和数据删除。） </li><li>当Storefile大小超过一定阈值后，会把当前的Region分割为两个（Split）【可称之为大合并，该阈值通过hbase.hregion.max.filesize设置，默认为10G】，并由Hmaster分配到相应的HRegionServer，实现负载均衡</li></ol><h2 id="讲一下hbase读数据的流程"><a href="#讲一下hbase读数据的流程" class="headerlink" title="讲一下hbase读数据的流程"></a>讲一下hbase读数据的流程</h2><ol><li><p>首先，客户端需要获知其想要读取的信息的Region的位置，这个时候，Client访问hbase上数据时并不需要Hmaster参与（HMaster仅仅维护着table和Region的元数据信息，负载很低），只需要访问zookeeper，从meta表获取相应region信息(地址和端口等)。【Client请求ZK获取.META.所在的RegionServer的地址。】</p></li><li><p>客户端会将该保存着RegionServer的位置信息的元数据表.META.进行缓存。然后在表中确定待检索rowkey所在的RegionServer信息（得到持有对应行键的.META表的服务器名）。【获取访问数据所在的RegionServer地址】</p></li><li><p>根据数据所在RegionServer的访问信息，客户端会向该RegionServer发送真正的数据读取请求。服务器端接收到该请求之后需要进行复杂的处理。</p></li><li><p>先从MemStore找数据，如果没有，再到StoreFile上读(为了读取的效率)。</p></li></ol><p><a href="https://blog.csdn.net/HaixWang/article/details/79520141#%E8%AF%BB%E6%B5%81%E7%A8%8B%E6%A6%82%E8%A7%88" target="_blank" rel="noopener">参考文章1</a></p><p><a href="http://hbasefly.com/2016/12/21/hbase-getorscan/?rkfcfo=fy6gy1" target="_blank" rel="noopener">参考文章2</a></p>]]></content>
      
      <categories>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 面试 </tag>
            
            <tag> HBase </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>大数据面试之Flink</title>
      <link href="/2020/03/05/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E4%B9%8BFlink/"/>
      <url>/2020/03/05/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E4%B9%8BFlink/</url>
      <content type="html"><![CDATA[<h2 id="讲一下flink的运行架构"><a href="#讲一下flink的运行架构" class="headerlink" title="讲一下flink的运行架构"></a>讲一下flink的运行架构</h2><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/pictures/flink架构图.png" alt=""></p><p>当 Flink 集群启动后，首先会启动一个 JobManger 和一个或多个的 TaskManager。由 Client 提交任务给 JobManager，JobManager 再调度任务到各个 TaskManager 去执行，然后 TaskManager 将心跳和统计信息汇报给 JobManager。TaskManager 之间以流的形式进行数据的传输。上述三者均为独立的 JVM 进程。</p><a id="more"></a><ul><li><strong>Client</strong> 为提交 Job 的客户端，可以是运行在任何机器上（与 JobManager 环境连通即可）。提交 Job 后，Client 可以结束进程（Streaming的任务），也可以不结束并等待结果返回。</li><li><strong>JobManager</strong> 主要负责调度 Job 并协调 Task 做 checkpoint，职责上很像 Storm 的 Nimbus。从 Client 处接收到 Job 和 JAR 包等资源后，会生成优化后的执行计划，并以 Task 的单元调度到各个 TaskManager 去执行。</li><li><strong>TaskManager</strong> 在启动的时候就设置好了槽位数（Slot），每个 slot 能启动一个 Task，Task 为线程。从 JobManager 处接收需要部署的 Task，部署启动后，与自己的上游建立 Netty 连接，接收数据并处理。</li></ul><p><a href="http://wuchong.me/blog/2016/05/03/flink-internals-overview/" target="_blank" rel="noopener">参考文章1</a></p><p><a href="http://shiyanjun.cn/archives/1508.html" target="_blank" rel="noopener">参考文章2</a></p><h2 id="讲一下flink的作业执行流程"><a href="#讲一下flink的作业执行流程" class="headerlink" title="讲一下flink的作业执行流程"></a>讲一下flink的作业执行流程</h2><p> <img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/pictures/flinkRuntime.png" alt=""></p><p><strong>以yarn模式Per-job方式为例概述作业提交执行流程</strong></p><ol><li><p>当执行executor() 之后,会首先在本地client 中将代码转化为可以提交的 JobGraph</p><p>如果提交为Per-Job模式,则首先需要启动AM, client会首先向资源系统申请资源, 在yarn下即为申请container开启AM, 如果是Session模式的话则不需要这个步骤</p></li><li><p>Yarn分配资源, 开启AM</p></li><li>Client将Job提交给Dispatcher</li><li>Dispatcher 会开启一个新的 JobManager线程</li><li>JM 向Flink 自己的 Resourcemanager申请slot资源来执行任务</li><li>RM 向 Yarn申请资源来启动 TaskManger (Session模式跳过此步)</li><li>Yarn 分配 Container 来启动 taskManger (Session模式跳过此步)</li><li>Flink 的 RM 向 TM 申请 slot资源来启动 task</li><li>TM 将待分配的 slot 提供给 JM</li><li>JM 提交 task, TM 会启动新的线程来执行任务,开始启动后就可以通过 shuffle模块进行 task之间的数据交换</li></ol><p><a href="https://www.bilibili.com/video/av52394455?t=343" target="_blank" rel="noopener">参考视频</a></p><h2 id="flink具体是如何实现exactly-once-语义"><a href="#flink具体是如何实现exactly-once-语义" class="headerlink" title="flink具体是如何实现exactly once 语义"></a>flink具体是如何实现exactly once 语义</h2><p>在谈到 flink 所实现的 exactly-once语义时,主要是2个层面上的,首先 flink在0.9版本以后已经实现了基于state的内部一致性语义, 在1.4版本以后也可以实现端到端 Exactly-Once语义</p><ul><li><h4 id="状态-Exactly-Once"><a href="#状态-Exactly-Once" class="headerlink" title="状态 Exactly-Once"></a>状态 Exactly-Once</h4><p>Flink 提供 exactly-once 的状态（state）投递语义，这为有状态的（stateful）计算提供了准确性保证。也就是状态是不会重复使用的,有且仅有一次消费</p></li></ul><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/pictures/flink故障恢复.png" alt=""></p><p>​    这里需要注意的一点是如何理解state语义的exactly-once,并不是说在flink中的所有事件均只会处理一次,而是所有的事件所影响生成的state只有作用一次.</p><p>​    在上图中, 假设每两条消息后出发一次checkPoint操作,持久化一次state. TaskManager 在 处理完 event c 之后被shutdown, 这时候当 JobManager重启task之后, TaskManager  会从 checkpoint 1 处恢复状态,重新执行流处理,也就是说 此时 event c 事件 的的确确是会被再一次处理的. 那么 这里所说的一致性语义是何意思呢? 本身,flink每处理完一条数据都会记录当前进度到 state中, 也就是说在 故障前, 处理完 event c 这件事情已经记录到了state中,但是,由于在checkPoint 2 之前, 就已经发生了宕机,那么 event c 对于state的影响并没有被记录下来,对于整个flink内部系统来说就好像没有发生过一样, 在 故障恢复后, 当触发 checkpoint 2 时, event c 的 state才最终被保存下来. <strong>所以说,可以这样理解, 进入flink 系统中的 事件 永远只会被 一次state记录并checkpoint下来,而state是永远不会发生重复被消费的, 这也就是 flink内部的一致性语义,就叫做 状态 Exactly once.</strong></p><ul><li><h4 id="端到端（end-to-end）Exactly-Once"><a href="#端到端（end-to-end）Exactly-Once" class="headerlink" title="端到端（end-to-end）Exactly-Once"></a>端到端（end-to-end）Exactly-Once</h4></li></ul><p>2017年12月份发布的Apache Flink 1.4版本，引进了一个重要的特性：TwoPhaseCommitSinkFunction.，它抽取了两阶段提交协议的公共部分，使得构建端到端Excatly-Once的Flink程序变为了可能。这些外部系统包括Kafka0.11及以上的版本，以及一些其他的数据输入（data sources）和数据接收(data sink)。它提供了一个抽象层，需要用户自己手动去实现Exactly-Once语义.</p><p>为了提供端到端Exactly-Once语义，除了Flink应用程序本身的状态，Flink写入的外部存储也需要满足这个语义。也就是说，这些外部系统必须提供提交或者回滚的方法，然后通过Flink的checkpoint来协调</p><p><a href="https://www.whitewood.me/2018/10/16/Flink-Exactly-Once-%E6%8A%95%E9%80%92%E5%AE%9E%E7%8E%B0%E6%B5%85%E6%9E%90/" target="_blank" rel="noopener">参考文章1</a></p><p><a href="https://my.oschina.net/u/992559/blog/1819948" target="_blank" rel="noopener">参考文章2</a></p><h2 id="flink-的-window-实现机制"><a href="#flink-的-window-实现机制" class="headerlink" title="flink 的 window 实现机制"></a>flink 的 window 实现机制</h2><p>Flink 中定义一个窗口主要需要以下三个组件。</p><ul><li><p><strong>Window Assigner：</strong>用来决定某个元素被分配到哪个/哪些窗口中去。</p></li><li><p><strong>Trigger：</strong>触发器。决定了一个窗口何时能够被计算或清除，每个窗口都会拥有一个自己的Trigger。</p></li><li><p><strong>Evictor：</strong>可以译为“驱逐者”。在Trigger触发之后，在窗口被处理之前，Evictor（如果有Evictor的话）会用来剔除窗口中不需要的元素，相当于一个filter。</p></li></ul><h4 id="Window-的实现"><a href="#Window-的实现" class="headerlink" title="Window 的实现"></a>Window 的实现</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/pictures/flink中window的实现.png" alt=""></p><p>首先上图中的组件都位于一个算子（window operator）中，数据流源源不断地进入算子，每一个到达的元素都会被交给 WindowAssigner。WindowAssigner 会决定元素被放到哪个或哪些窗口（window），可能会创建新窗口。因为一个元素可以被放入多个窗口中，所以同时存在多个窗口是可能的。注意，<code>Window</code>本身只是一个ID标识符，其内部可能存储了一些元数据，如<code>TimeWindow</code>中有开始和结束时间，但是并不会存储窗口中的元素。窗口中的元素实际存储在 Key/Value State 中，key为<code>Window</code>，value为元素集合（或聚合值）。为了保证窗口的容错性，该实现依赖了 Flink 的 State 机制（参见 <a href="https://ci.apache.org/projects/flink/flink-docs-master/apis/streaming/state.html" target="_blank" rel="noopener">state 文档</a>）。</p><p>每一个窗口都拥有一个属于自己的 Trigger，Trigger上会有定时器，用来决定一个窗口何时能够被计算或清除。每当有元素加入到该窗口，或者之前注册的定时器超时了，那么Trigger都会被调用。Trigger的返回结果可以是 continue（不做任何操作），fire（处理窗口数据），purge（移除窗口和窗口中的数据），或者 fire + purge。一个Trigger的调用结果只是fire的话，那么会计算窗口并保留窗口原样，也就是说窗口中的数据仍然保留不变，等待下次Trigger fire的时候再次执行计算。一个窗口可以被重复计算多次知道它被 purge 了。在purge之前，窗口会一直占用着内存。</p><p>当Trigger fire了，窗口中的元素集合就会交给<code>Evictor</code>（如果指定了的话）。Evictor 主要用来遍历窗口中的元素列表，并决定最先进入窗口的多少个元素需要被移除。剩余的元素会交给用户指定的函数进行窗口的计算。如果没有 Evictor 的话，窗口中的所有元素会一起交给函数进行计算。</p><p>计算函数收到了窗口的元素（可能经过了 Evictor 的过滤），并计算出窗口的结果值，并发送给下游。窗口的结果值可以是一个也可以是多个。DataStream API 上可以接收不同类型的计算函数，包括预定义的<code>sum()</code>,<code>min()</code>,<code>max()</code>，还有 <code>ReduceFunction</code>，<code>FoldFunction</code>，还有<code>WindowFunction</code>。WindowFunction 是最通用的计算函数，其他的预定义的函数基本都是基于该函数实现的。</p><p>Flink 对于一些聚合类的窗口计算（如sum,min）做了优化，因为聚合类的计算不需要将窗口中的所有数据都保存下来，只需要保存一个result值就可以了。每个进入窗口的元素都会执行一次聚合函数并修改result值。这样可以大大降低内存的消耗并提升性能。但是如果用户定义了 Evictor，则不会启用对聚合窗口的优化，因为 Evictor 需要遍历窗口中的所有元素，必须要将窗口中所有元素都存下来。</p><p><a href="http://wuchong.me/blog/2016/05/25/flink-internals-window-mechanism/" target="_blank" rel="noopener">参考文章</a></p><h2 id="flink-的-window-分类"><a href="#flink-的-window-分类" class="headerlink" title="flink 的 window 分类"></a>flink 的 window 分类</h2><p><strong>flink中的窗口主要分为3大类共5种窗口</strong>:</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/pictures/flink中window分类.png" alt=""></p><ul><li><p><strong>Time Window 时间窗口</strong></p><ul><li><p><strong>Tumbing Time Window 滚动时间窗口</strong></p><p>实现统计每一分钟(或其他长度)窗口内 计算的效果</p></li><li><p><strong>Sliding Time Window 滑动时间窗口</strong></p><p>实现每过xxx时间 统计 xxx时间窗口的效果. 比如，我们可以每30秒计算一次最近一分钟用户购买的商品总数。</p></li></ul></li><li><p><strong>Count Window 计数窗口</strong></p><ul><li><p><strong>Tumbing Count Window  滚动计数窗口</strong></p><p>当我们想要每100个用户购买行为事件统计购买总数，那么每当窗口中填满100个元素了，就会对窗口进行计算，这种窗口我们称之为翻滚计数窗口（Tumbling Count Window）</p></li><li><p><strong>Sliding Count Window   滑动计数窗口</strong></p><p>和Sliding Time Window含义是类似的，例如计算每10个元素计算一次最近100个元素的总和</p></li></ul></li><li><p><strong>Session Window  会话窗口</strong></p><p>在这种用户交互事件流中，我们首先想到的是将事件聚合到会话窗口中（一段用户持续活跃的周期），由非活跃的间隙分隔开。如上图所示，就是需要计算每个用户在活跃期间总共购买的商品数量，如果用户30秒没有活动则视为会话断开（假设raw data stream是单个用户的购买行为流）</p></li></ul><h2 id="flink-的-state-是存储在哪里的"><a href="#flink-的-state-是存储在哪里的" class="headerlink" title="flink 的 state 是存储在哪里的"></a>flink 的 state 是存储在哪里的</h2><p>Apache Flink内部有四种state的存储实现，具体如下：</p><ul><li><strong>基于内存的HeapStateBackend</strong> - 在debug模式使用，不 建议在生产模式下应用；</li><li><strong>基于HDFS的FsStateBackend</strong> - 分布式文件持久化，每次读写都产生网络IO，整体性能不佳；</li><li><strong>基于RocksDB的RocksDBStateBackend</strong> - 本地文件+异步HDFS持久化；</li><li><strong>基于Niagara(Alibaba内部实现)NiagaraStateBackend</strong> - 分布式持久化- 在Alibaba生产环境应用；</li></ul><p><a href="https://juejin.im/post/5c87dbdbe51d45494c77d607" target="_blank" rel="noopener">参考文章</a></p><h2 id="flink是如何实现反压的"><a href="#flink是如何实现反压的" class="headerlink" title="flink是如何实现反压的"></a>flink是如何实现反压的</h2><p>flink的反压经历了两个发展阶段,分别是基于TCP的反压(&lt;1.5)和基于credit的反压(&gt;1.5)</p><ul><li><h4 id="基于-TCP-的反压"><a href="#基于-TCP-的反压" class="headerlink" title="基于 TCP 的反压"></a>基于 TCP 的反压</h4><p>flink中的消息发送通过RS(ResultPartition),消息接收通过IC(InputGate),两者的数据都是以 LocalBufferPool的形式来存储和提取,进一步的依托于Netty的NetworkBufferPool,之后更底层的便是依托于TCP的滑动窗口机制,当IC端的buffer池满了之后,两个task之间的滑动窗口大小便为0,此时RS端便无法再发送数据</p><p>基于TCP的反压最大的问题是会造成整个TaskManager端的反压,所有的task都会受到影响</p></li><li><h4 id="基于-Credit-的反压"><a href="#基于-Credit-的反压" class="headerlink" title="基于 Credit 的反压"></a>基于 Credit 的反压</h4><p>RS与IC之间通过backlog和credit来确定双方可以发送和接受的数据量的大小以提前感知,而不是通过TCP滑动窗口的形式来确定buffer的大小之后再进行反压</p><p><img src="D:\Note\big-data-interview\BigData-Interview\pictures\flink基于credit的反压.png" alt=""></p></li></ul><p><a href="https://www.bilibili.com/video/av55487329" target="_blank" rel="noopener">参考视频</a></p><p><a href="https://blog.csdn.net/u010376788/article/details/92086752" target="_blank" rel="noopener">参考文章1</a></p><p><a href="https://blog.csdn.net/u010376788/article/details/95047250" target="_blank" rel="noopener">参考文章2</a></p><h2 id="flink的部署模式都有哪些"><a href="#flink的部署模式都有哪些" class="headerlink" title="flink的部署模式都有哪些"></a>flink的部署模式都有哪些</h2><p><strong>flink可以以多种方式部署,包括standlone模式/yarn/Mesos/Kubernetes/Docker/AWS/Google Compute Engine/MAPR等</strong></p><p>一般公司中主要采用 on yarn模式</p><h2 id="讲一下flink-on-yarn的部署"><a href="#讲一下flink-on-yarn的部署" class="headerlink" title="讲一下flink on yarn的部署"></a>讲一下flink on yarn的部署</h2><p>Flink作业提交有两种类型:</p><ul><li><h4 id="yarn-session"><a href="#yarn-session" class="headerlink" title="yarn session"></a>yarn session</h4><p>需要先启动集群，然后在提交作业，接着会向yarn申请一块空间后，资源永远保持不变。如果资源满了，下一个作业就无法提交，只能等到yarn中的其中一个作业执行完成后，释放了资源，那下一个作业才会正常提交.</p><ul><li><p>客户端模式</p><p>对于客户端模式而言，你可以启动多个yarn session，一个yarn session模式对应一个JobManager,并按照需求提交作业，同一个Session中可以提交多个Flink作业。如果想要停止Flink Yarn Application，需要通过yarn application -kill命令来停止.</p></li><li><p>分离式模式</p><p>对于分离式模式，并不像客户端那样可以启动多个yarn session，如果启动多个，会出现下面的session一直处在等待状态。JobManager的个数只能是一个，同一个Session中可以提交多个Flink作业。如果想要停止Flink Yarn Application，需要通过yarn application -kill命令来停止</p></li></ul></li><li><h4 id="Flink-run-Per-Job"><a href="#Flink-run-Per-Job" class="headerlink" title="Flink run(Per-Job)"></a>Flink run(Per-Job)</h4><p>直接在YARN上提交运行Flink作业(Run a Flink job on YARN)，这种方式的好处是一个任务会对应一个job,即没提交一个作业会根据自身的情况，向yarn申请资源，直到作业执行完成，并不会影响下一个作业的正常运行，除非是yarn上面没有任何资源的情况下</p></li></ul><table><thead><tr><th>Session</th><th></th></tr></thead><tbody><tr><td>共享Dispatcher和Resource Manager</td><td>Dispatcher和Resource Manager</td></tr><tr><td>共享资源(即 TaskExecutor)</td><td>按需要申请资源 (即 TaskExecutor)</td></tr><tr><td>适合规模小,执行时间短的作业</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/pictures/flinkOnYarn.png" alt=""></p><h2 id="flink中的时间概念-eventTime-和-processTime的区别"><a href="#flink中的时间概念-eventTime-和-processTime的区别" class="headerlink" title="flink中的时间概念 , eventTime 和 processTime的区别"></a>flink中的时间概念 , eventTime 和 processTime的区别</h2><p>Flink中有三种时间概念,分别是 Processing Time、Event Time 和 Ingestion Time</p><ul><li><h4 id="Processing-Time"><a href="#Processing-Time" class="headerlink" title="Processing Time"></a>Processing Time</h4><p>Processing Time 是指事件被处理时机器的系统时间。</p><p>当流程序在 Processing Time 上运行时，所有基于时间的操作(如时间窗口)将使用当时机器的系统时间。每小时 Processing Time 窗口将包括在系统时钟指示整个小时之间到达特定操作的所有事件</p></li><li><h4 id="Event-Time"><a href="#Event-Time" class="headerlink" title="Event Time"></a>Event Time</h4><p>Event Time 是事件发生的时间，一般就是数据本身携带的时间。这个时间通常是在事件到达 Flink 之前就确定的，并且可以从每个事件中获取到事件时间戳。在 Event Time 中，时间取决于数据，而跟其他没什么关系。Event Time 程序必须指定如何生成 Event Time 水印，这是表示 Event Time 进度的机制</p></li><li><h4 id="Ingestion-Time"><a href="#Ingestion-Time" class="headerlink" title="Ingestion Time"></a>Ingestion Time</h4><p>Ingestion Time 是事件进入 Flink 的时间。 在源操作处，每个事件将源的当前时间作为时间戳，并且基于时间的操作（如时间窗口）会利用这个时间戳</p><p>Ingestion Time 在概念上位于 Event Time 和 Processing Time 之间。 与 Processing Time 相比，它稍微贵一些，但结果更可预测。因为 Ingestion Time 使用稳定的时间戳（在源处分配一次），所以对事件的不同窗口操作将引用相同的时间戳，而在 Processing Time 中，每个窗口操作符可以将事件分配给不同的窗口（基于机器系统时间和到达延迟）</p><p>与 Event Time 相比，Ingestion Time 程序无法处理任何无序事件或延迟数据，但程序不必指定如何生成水印</p></li></ul><p><a href="https://zhuanlan.zhihu.com/p/55322400" target="_blank" rel="noopener">参考文章</a></p><h2 id="flink中的session-Window怎样使用"><a href="#flink中的session-Window怎样使用" class="headerlink" title="flink中的session Window怎样使用"></a>flink中的session Window怎样使用</h2><p>会话窗口主要是将某段时间内活跃度较高的数据聚合成一个窗口进行计算,窗口的触发条件是 Session Gap, 是指在规定的时间内如果没有数据活跃接入,则认为窗口结束,然后触发窗口结果</p><p>Session Windows窗口类型比较适合非连续性数据处理或周期性产生数据的场景,根据用户在线上某段时间内的活跃度对用户行为进行数据统计</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val sessionWindowStream = inputStream</span><br><span class="line">.keyBy(_.id)</span><br><span class="line">//使用EventTimeSessionWindow 定义 Event Time 滚动窗口</span><br><span class="line">.window(EventTimeSessionWindow.withGap(Time.milliseconds(10)))</span><br><span class="line">.process(......)</span><br></pre></td></tr></table></figure><p>Session Window 本质上没有固定的起止时间点,因此底层计算逻辑和Tumbling窗口及Sliding 窗口有一定的区别,</p><p>Session Window 为每个进入的数据都创建了一个窗口,最后再将距离窗口Session Gap 最近的窗口进行合并,然后计算窗口结果</p>]]></content>
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Flink </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>大数据面试之Spark</title>
      <link href="/2020/03/04/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E4%B9%8BSpark/"/>
      <url>/2020/03/04/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E4%B9%8BSpark/</url>
      <content type="html"><![CDATA[<h2 id="讲一下spark-的运行架构"><a href="#讲一下spark-的运行架构" class="headerlink" title="讲一下spark 的运行架构"></a>讲一下spark 的运行架构</h2><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/pictures/spark架构图.jpg" alt=""></p><ul><li><p><strong>Cluster Manager(Master)</strong>：在standalone模式中即为Master主节点，控制整个集群，监控worker。在YARN模式中为资源管理器</p></li><li><p><strong>Worker节点</strong>：从节点，负责控制计算节点，启动Executor或者Driver。</p></li><li><p><strong>Driver</strong>： 运行Application 的main()函数</p></li><li><p><strong>Executor</strong>：执行器，是为某个Application运行在worker node上的一个进程</p></li></ul><a id="more"></a><p><a href="https://juejin.im/post/5a73c8386fb9a0635e3cafaa" target="_blank" rel="noopener">参考文章</a></p><h2 id="一个spark程序的执行流程"><a href="#一个spark程序的执行流程" class="headerlink" title="一个spark程序的执行流程"></a>一个spark程序的执行流程</h2><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/pictures/spark程序执行流程.jpg" alt=""></p><ul><li><strong>A -&gt;</strong> 当 Driver 进程被启动之后,首先它将发送请求到Master节点上,进行Spark应用程序的注册</li><li><strong>B -&gt;</strong> Master在接受到Spark应用程序的注册申请之后,会发送给Worker,让其进行资源的调度和分配.</li><li><strong>C -&gt;</strong> Worker 在接受Master的请求之后,会为Spark应用程序启动Executor, 来分配资源</li><li><strong>D -&gt;</strong> Executor启动分配资源好后,就会想Driver进行反注册,这是Driver已经知道哪些Executor为他服务了</li><li><strong>E -&gt;</strong> 当Driver得到注册了Executor之后,就可以开始正式执行spark应用程序了. 首先第一步,就是创建初始RDD,读取数据源,再执行之后的一系列算子. HDFS文件内容被读取到多个worker节点上,形成内存中的分布式数据集,也就是初始RDD</li><li><strong>F -&gt;</strong> Driver就会根据 Job 任务任务中的算子形成对应的task,最后提交给 Executor, 来分配给task进行计算的线程</li><li><strong>G -&gt;</strong> task就会去调用对应的任务数据来计算,并task会对调用过来的RDD的partition数据执行指定的算子操作,形成新的RDD的partition,这时一个大的循环就结束了</li><li>后续的RDD的partition数据又通过Driver形成新的一批task提交给Executor执行,循环这个操作,直到所有的算子结束</li></ul><p><a href="https://zhuanlan.zhihu.com/p/35713084" target="_blank" rel="noopener">参考文章</a></p><h2 id="spark的shuffle介绍"><a href="#spark的shuffle介绍" class="headerlink" title="spark的shuffle介绍"></a>spark的shuffle介绍</h2><p><strong>spark中的shuffle主要有3种:</strong></p><ul><li><p><strong>Hash Shuffle</strong> 2.0以后移除</p><p><img src="D:\Note\big-data-interview\BigData-Interview\pictures\spark-shuffle-v1.png" alt=""></p><p>在map阶段(shuffle write)，每个map都会为下游stage的每个partition写一个临时文件，假如下游stage有1000个partition，那么每个map都会生成1000个临时文件，一般来说一个executor上会运行多个map task，这样下来，一个executor上会有非常多的临时文件，假如一个executor上运行M个map task，下游stage有N个partition，那么一个executor上会生成M<em>N个文件。另一方面，如果一个executor上有K个core，那么executor同时可运行K个task，这样一来，就会同时申请K</em>N个文件描述符，一旦partition数较多，势必会耗尽executor上的文件描述符，同时生成K*N个write handler也会带来大量内存的消耗。</p><p>在reduce阶段(shuffle read)，每个reduce task都会拉取所有map对应的那部分partition数据，那么executor会打开所有临时文件准备网络传输，这里又涉及到大量文件描述符，另外，如果reduce阶段有combiner操作，那么它会把网络中拉到的数据保存在一个<code>HashMap</code>中进行合并操作，如果数据量较大，很容易引发OOM操作。</p></li><li><p><strong>Sort Shuffle</strong> 1.1开始(sort shuffle也经历过优化升级,详细见参考文章1)</p><p><img src="D:\Note\big-data-interview\BigData-Interview\pictures\spark-shuffle-v3.png" alt=""></p><p>在map阶段(shuffle write)，会按照partition id以及key对记录进行排序，将所有partition的数据写在同一个文件中，该文件中的记录首先是按照partition id排序一个一个分区的顺序排列，每个partition内部是按照key进行排序存放，map task运行期间会顺序写每个partition的数据，并通过一个索引文件记录每个partition的大小和偏移量。这样一来，每个map task一次只开两个文件描述符，一个写数据，一个写索引，大大减轻了Hash Shuffle大量文件描述符的问题，即使一个executor有K个core，那么最多一次性开K*2个文件描述符。</p><p>在reduce阶段(shuffle read)，reduce task拉取数据做combine时不再是采用<code>HashMap</code>，而是采用<code>ExternalAppendOnlyMap</code>，该数据结构在做combine时，如果内存不足，会刷写磁盘，很大程度的保证了鲁棒性，避免大数据情况下的OOM。</p></li><li><p><strong>Unsafe Shuffle</strong> 1.5开始, 1.6与Sort shuffle合并</p><p>从spark 1.5.0开始，spark开始了钨丝计划(Tungsten)，目的是优化内存和CPU的使用，进一步提升spark的性能。为此，引入Unsafe Shuffle，它的做法是将数据记录用二进制的方式存储，直接在序列化的二进制数据上sort而不是在java 对象上，这样一方面可以减少memory的使用和GC的开销，另一方面避免shuffle过程中频繁的序列化以及反序列化。在排序过程中，它提供cache-efficient sorter，使用一个8 bytes的指针，把排序转化成了一个指针数组的排序，极大的优化了排序性能.</p></li></ul><hr><p><strong>现在2.1 分为三种writer， 分为 BypassMergeSortShuffleWriter， SortShuffleWriter 和 UnsafeShuffleWriter</strong></p><h4 id="三种Writer的分类"><a href="#三种Writer的分类" class="headerlink" title="三种Writer的分类"></a>三种Writer的分类</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/pictures/sparkShuffleWriter.jpg" alt=""></p><p>上面是使用哪种 writer 的判断依据， 是否开启 mapSideCombine 这个判断，是因为有些算子会在 map 端先进行一次 combine， 减少传输数据。 因为 BypassMergeSortShuffleWriter 会临时输出Reducer个（分区数目）小文件，所以分区数必须要小于一个阀值，默认是小于200</p><p>UnsafeShuffleWriter需要Serializer支持relocation，Serializer支持relocation：原始数据首先被序列化处理，并且再也不需要反序列，在其对应的元数据被排序后，需要Serializer支持relocation，在指定位置读取对应数据</p><p><a href="http://sharkdtu.com/posts/spark-shuffle.html" target="_blank" rel="noopener">参考文章1</a></p><p><a href="http://spark.coolplayer.net/?p=576" target="_blank" rel="noopener">参考文章2</a></p><h2 id="Spark的-partitioner-都有哪些"><a href="#Spark的-partitioner-都有哪些" class="headerlink" title="Spark的 partitioner 都有哪些?"></a>Spark的 partitioner 都有哪些?</h2><p><strong>Partitioner主要有两个实现类：HashPartitioner和RangePartitioner,HashPartitioner是大部分transformation的默认实现，sortBy、sortByKey使用RangePartitioner实现，也可以自定义Partitioner.</strong></p><ul><li><p><strong>HashPartitioner</strong></p><p>numPartitions方法返回传入的分区数，getPartition方法使用key的hashCode值对分区数取模得到PartitionId，写入到对应的bucket中。</p></li><li><p><strong>RangePartitioner</strong></p><p>RangePartitioner是先根据所有partition中数据的分布情况，尽可能均匀地构造出重分区的分隔符，再将数据的key值根据分隔符进行重新分区</p><ul><li>使用reservoir Sample方法对每个Partition进行分别抽样</li><li>对数据量大(大于sampleSizePerPartition)的分区进行重新抽样</li><li>由权重信息计算出分区分隔符rangeBounds</li><li>由rangeBounds计算分区数和key的所属分区</li></ul></li></ul><p><a href="https://blog.csdn.net/qq_34842671/article/details/83685179" target="_blank" rel="noopener">参考文章</a></p><h2 id="spark有哪几种join"><a href="#spark有哪几种join" class="headerlink" title="spark有哪几种join"></a>spark有哪几种join</h2><p><strong>Spark 中和 join 相关的算子有这几个</strong>：<code>join</code>、<code>fullOuterJoin</code>、<code>leftOuterJoin</code>、<code>rightOuterJoin</code></p><ul><li><p><strong>join</strong></p><p>join函数会输出两个RDD中key相同的所有项，并将它们的value联结起来，它联结的key要求在两个表中都存在，类似于SQL中的INNER JOIN。但它不满足交换律，a.join(b)与b.join(a)的结果不完全相同，值插入的顺序与调用关系有关。</p></li><li><p><strong>leftOuterJoin</strong></p><p>leftOuterJoin会保留对象的所有key，而用None填充在参数RDD other中缺失的值，因此调用顺序会使结果完全不同。如下面展示的结果，</p></li><li><p><strong>rightOuterJoin</strong></p><p>rightOuterJoin与leftOuterJoin基本一致，区别在于它的结果保留的是参数other这个RDD中所有的key。</p></li><li><p><strong>fullOuterJoin</strong></p><p>fullOuterJoin会保留两个RDD中所有的key，因此所有的值列都有可能出现缺失的情况，所有的值列都会转为Some对象。</p></li></ul><p><a href="http://www.neilron.xyz/join-in-spark/" target="_blank" rel="noopener">参考文章</a></p><h2 id="RDD有哪些特点"><a href="#RDD有哪些特点" class="headerlink" title="RDD有哪些特点"></a>RDD有哪些特点</h2><ol><li><p><strong>A list of partitions</strong><br>RDD是一个由多个partition（某个节点里的某一片连续的数据）组成的的list；将数据加载为RDD时，一般会遵循数据的本地性（一般一个hdfs里的block会加载为一个partition）。</p></li><li><p><strong>A function for computing each split</strong><br>RDD的每个partition上面都会有function，也就是函数应用，其作用是实现RDD之间partition的转换。</p></li><li><p><strong>A list of dependencies on other RDDs</strong><br>RDD会记录它的依赖 ，为了容错（重算，cache，checkpoint），也就是说在内存中的RDD操作时出错或丢失会进行重算。</p></li><li><p><strong>Optionally,a Partitioner for Key-value RDDs</strong><br>  可选项，如果RDD里面存的数据是key-value形式，则可以传递一个自定义的Partitioner进行重新分区，例如这里自定义的Partitioner是基于key进行分区，那则会将不同RDD里面的相同key的数据放到同一个partition里面</p></li><li><p><strong>Optionally, a list of preferred locations to compute each split on</strong></p><p>最优的位置去计算，也就是数据的本地性。</p></li></ol><h2 id="讲一下宽依赖和窄依赖"><a href="#讲一下宽依赖和窄依赖" class="headerlink" title="讲一下宽依赖和窄依赖"></a>讲一下宽依赖和窄依赖</h2><p>区别宽窄依赖的核心点是 <strong>子RDD的partition与父RDD的partition是否是1对多的关系</strong>,如果是这样的关系的话,</p><p>说明多个父rdd的partition需要经过shuffle过程汇总到一个子rdd的partition,这样就是一次宽依赖,在DAGScheduler中会产生stage的切分.</p><h2 id="Spark中的算子都有哪些"><a href="#Spark中的算子都有哪些" class="headerlink" title="Spark中的算子都有哪些"></a>Spark中的算子都有哪些</h2><p>总的来说,spark分为两大类算子:</p><ul><li><p><strong>Transformation 变换/转换算子：这种变换并不触发提交作业，完成作业中间过程处理</strong></p><p>Transformation 操作是延迟计算的，也就是说从一个RDD 转换生成另一个 RDD 的转换操作不是马上执行，需要等到有 Action 操作的时候才会真正触发运算</p></li><li><p><strong>Action 行动算子：这类算子会触发 SparkContext 提交 Job 作业</strong></p><p>Action 算子会触发 Spark 提交作业（Job），并将数据输出 Spark系统</p><hr></li></ul><h4 id="1-Value数据类型的Transformation算子"><a href="#1-Value数据类型的Transformation算子" class="headerlink" title="1. Value数据类型的Transformation算子"></a>1. Value数据类型的Transformation算子</h4><ul><li><p>输入分区与输出分区一对一型</p><ul><li>map算子</li><li>flatMap算子</li><li>mapPartitions算子</li><li>glom算子</li></ul></li><li><p>输入分区与输出分区多对一型</p><ul><li>union算子</li><li>cartesian算子</li></ul></li><li><p>输入分区与输出分区多对多型</p><ul><li>grouBy算子</li></ul></li><li><p>输出分区为输入分区子集型</p><ul><li>filter算子</li><li>distinct算子</li><li>subtract算子</li><li>sample算子</li><li>takeSample算子</li></ul></li><li><p>Cache型</p><ul><li>cache算子</li><li>persist算子</li></ul></li></ul><h4 id="2-Key-Value数据类型的Transfromation算子"><a href="#2-Key-Value数据类型的Transfromation算子" class="headerlink" title="2. Key-Value数据类型的Transfromation算子"></a>2. Key-Value数据类型的Transfromation算子</h4><ul><li><p>输入分区与输出分区一对一</p><ul><li>mapValues算子</li></ul></li><li><p>对单个RDD或两个RDD聚集</p><ul><li>combineByKey算子</li><li>reduceByKey算子</li><li>partitionBy算子</li><li>Cogroup算子</li></ul></li><li><p>连接</p><ul><li>join算子</li><li>leftOutJoin 和 rightOutJoin算子</li></ul></li></ul><h4 id="3-Action算子"><a href="#3-Action算子" class="headerlink" title="3. Action算子"></a>3. Action算子</h4><ul><li><p>无输出</p><ul><li>foreach算子</li></ul></li><li><p>HDFS算子</p><ul><li>saveAsTextFile算子</li><li>saveAsObjectFile算子</li></ul></li><li><p>Scala集合和数据类型</p><ul><li>collect算子</li><li>collectAsMap算子</li><li>reduceByKeyLocally算子</li><li>lookup算子</li><li>count算子</li><li>top算子</li><li>reduce算子</li><li>fold算子</li><li>aggregate算子</li><li>countByValue</li><li>countByKey</li></ul></li></ul><p><a href="https://www.cnblogs.com/kpsmile/p/10434390.html" target="_blank" rel="noopener">参考文章</a></p><h2 id="RDD的缓存级别都有哪些"><a href="#RDD的缓存级别都有哪些" class="headerlink" title="RDD的缓存级别都有哪些"></a>RDD的缓存级别都有哪些</h2><p>NONE :什么类型都不是<br>DISK_ONLY：磁盘<br>DISK_ONLY_2：磁盘；双副本<br>MEMORY_ONLY： 内存；反序列化；把RDD作为反序列化的方式存储，假如RDD的内容存不下，剩余的分区在以后需要时会重新计算，不会刷到磁盘上。<br>MEMORY_ONLY_2：内存；反序列化；双副本<br>MEMORY_ONLY_SER：内存；序列化；这种序列化方式，每一个partition以字节数据存储，好处是能带来更好的空间存储，但CPU耗费高<br>MEMORY_ONLY_SER_2 : 内存；序列化；双副本<br>MEMORY_AND_DISK：内存 + 磁盘；反序列化；双副本；RDD以反序列化的方式存内存，假如RDD的内容存不下，剩余的会存到磁盘<br>MEMORY_AND_DISK_2 : 内存 + 磁盘；反序列化；双副本<br>MEMORY_AND_DISK_SER：内存 + 磁盘；序列化<br>MEMORY_AND_DISK_SER_2：内存 + 磁盘；序列化；双副本</p><h2 id="RDD懒加载是什么意思"><a href="#RDD懒加载是什么意思" class="headerlink" title="RDD懒加载是什么意思"></a>RDD懒加载是什么意思</h2><p>Transformation 操作是延迟计算的，也就是说从一个RDD 转换生成另一个 RDD 的转换操作不是马上执行，需要等到有 Acion 操作的时候才会真正触发运算,这也就是懒加载.</p><h2 id="讲一下spark的几种部署方式"><a href="#讲一下spark的几种部署方式" class="headerlink" title="讲一下spark的几种部署方式"></a>讲一下spark的几种部署方式</h2><p><strong>目前,除了local模式为本地调试模式以为, Spark支持三种分布式部署方式，分别是standalone、spark on mesos和 spark on YARN</strong></p><ul><li><p><strong>Standalone模式</strong></p><p>即独立模式，自带完整的服务，可单独部署到一个集群中，无需依赖任何其他资源管理系统。从一定程度上说，该模式是其他两种的基础。目前Spark在standalone模式下是没有任何单点故障问题的，这是借助zookeeper实现的，思想类似于Hbase master单点故障解决方案。将Spark standalone与MapReduce比较，会发现它们两个在架构上是完全一致的： </p><ul><li>都是由master/slaves服务组成的，且起初master均存在单点故障，后来均通过zookeeper解决（Apache MRv1的JobTracker仍存在单点问题，但CDH版本得到了解决）； </li><li>各个节点上的资源被抽象成粗粒度的slot，有多少slot就能同时运行多少task。不同的是，MapReduce将slot分为map slot和reduce slot，它们分别只能供Map Task和Reduce Task使用，而不能共享，这是MapReduce资源利率低效的原因之一，而Spark则更优化一些，它不区分slot类型，只有一种slot，可以供各种类型的Task使用，这种方式可以提高资源利用率，但是不够灵活，不能为不同类型的Task定制slot资源。总之，这两种方式各有优缺点。 </li></ul></li><li><p><strong>Spark On YARN模式</strong></p><p><strong>spark on yarn 的支持两种模式：</strong> </p><ul><li>yarn-cluster：适用于生产环境； </li><li>yarn-client：适用于交互、调试，希望立即看到app的输出 </li></ul><p>yarn-cluster和yarn-client的区别在于yarn appMaster，每个yarn app实例有一个appMaster进程，是为app启动的第一个container；负责从ResourceManager请求资源，获取到资源后，告诉NodeManager为其启动container。yarn-cluster和yarn-client模式内部实现还是有很大的区别。如果你需要用于生产环境，那么请选择yarn-cluster；而如果你仅仅是Debug程序，可以选择yarn-client。</p></li><li><p><strong>Spark On Mesos模式</strong></p><p>Spark运行在Mesos上会比运行在YARN上更加灵活，更加自然。目前在Spark On Mesos环境中，用户可选择两种调度模式之一运行自己的应用程序</p><ul><li><p>粗粒度模式（Coarse-grained Mode）：每个应用程序的运行环境由一个Dirver和若干个Executor组成，其中，每个Executor占用若干资源，内部可运行多个Task（对应多少个“slot”）。应用程序的各个任务正式运行之前，需要将运行环境中的资源全部申请好，且运行过程中要一直占用这些资源，即使不用，最后程序运行结束后，回收这些资源。</p></li><li><p>细粒度模式（Fine-grained Mode）：鉴于粗粒度模式会造成大量资源浪费，Spark On Mesos还提供了另外一种调度模式：细粒度模式，这种模式类似于现在的云计算，思想是按需分配。与粗粒度模式一样，应用程序启动时，先会启动executor，但每个executor占用资源仅仅是自己运行所需的资源，不需要考虑将来要运行的任务，之后，mesos会为每个executor动态分配资源，每分配一些，便可以运行一个新任务，单个Task运行完之后可以马上释放对应的资源。</p></li></ul><h2 id="spark-on-yarn-模式下的-cluster模式和-client模式有什么区别"><a href="#spark-on-yarn-模式下的-cluster模式和-client模式有什么区别" class="headerlink" title="spark on yarn 模式下的 cluster模式和 client模式有什么区别"></a>spark on yarn 模式下的 cluster模式和 client模式有什么区别</h2></li></ul><ol><li>yarn-cluster 适用于生产环境。而 yarn-client 适用于交互和调试，也就是希望快速地看到 application 的输出.</li><li>yarn-cluster 和 yarn-client 模式的区别其实就是 <strong>Application Master 进程</strong>的区别，yarn-cluster 模式下，driver 运行在 AM(Application Master)中，它负责向 YARN 申请资源，并监督作业的运行状况。当用户提交了作业之后，就可以关掉 Client，作业会继续在 YARN 上运行。然而 yarn-cluster 模式不适合运行交互类型的作业。而 yarn-client 模式下，Application Master 仅仅向 YARN 请求 executor，Client 会和请求的container 通信来调度他们工作，也就是说 Client 不能离开。</li></ol><h2 id="spark运行原理-从提交一个jar到最后返回结果-整个过程"><a href="#spark运行原理-从提交一个jar到最后返回结果-整个过程" class="headerlink" title="spark运行原理,从提交一个jar到最后返回结果,整个过程"></a>spark运行原理,从提交一个jar到最后返回结果,整个过程</h2><ol><li><code>spark-submit</code> 提交代码，执行 <code>new SparkContext()</code>，在 SparkContext 里构造 <code>DAGScheduler</code> 和 <code>TaskScheduler</code>。</li><li>TaskScheduler 会通过后台的一个进程，连接 Master，向 Master 注册 Application。</li><li>Master 接收到 Application 请求后，会使用相应的资源调度算法，在 Worker 上为这个 Application 启动多个 Executer。</li><li>Executor 启动后，会自己反向注册到 TaskScheduler 中。 所有 Executor 都注册到 Driver 上之后，SparkContext 结束初始化，接下来往下执行我们自己的代码。</li><li>每执行到一个 Action，就会创建一个 Job。Job 会提交给 DAGScheduler。</li><li>DAGScheduler 会将 Job划分为多个 stage，然后每个 stage 创建一个 TaskSet。</li><li>TaskScheduler 会把每一个 TaskSet 里的 Task，提交到 Executor 上执行。</li><li>Executor 上有线程池，每接收到一个 Task，就用 TaskRunner 封装，然后从线程池里取出一个线程执行这个 task。(TaskRunner 将我们编写的代码，拷贝，反序列化，执行 Task，每个 Task 执行 RDD 里的一个 partition)</li></ol><h2 id="spark的stage是如何划分的"><a href="#spark的stage是如何划分的" class="headerlink" title="spark的stage是如何划分的"></a>spark的stage是如何划分的</h2><p><strong>stage的划分依据就是看是否产生了shuflle(即宽依赖),遇到一个shuffle操作就划分为前后两个stage.</strong></p><p><img src="D:\Note\big-data-interview\BigData-Interview\pictures\stageDivide.jpg" alt=""></p><h2 id="spark2-0为什么放弃了akka-而用netty"><a href="#spark2-0为什么放弃了akka-而用netty" class="headerlink" title="spark2.0为什么放弃了akka 而用netty"></a>spark2.0为什么放弃了akka 而用netty</h2><ol><li>很多Spark用户也使用Akka，但是由于Akka不同版本之间无法互相通信，这就要求用户必须使用跟Spark完全一样的Akka版本，导致用户无法升级Akka。</li><li>Spark的Akka配置是针对Spark自身来调优的，可能跟用户自己代码中的Akka配置冲突。</li><li>Spark用的Akka特性很少，这部分特性很容易自己实现。同时，这部分代码量相比Akka来说少很多，debug比较容易。如果遇到什么bug，也可以自己马上fix，不需要等Akka上游发布新版本。而且，Spark升级Akka本身又因为第一点会强制要求用户升级他们使用的Akka，对于某些用户来说是不现实的。</li></ol><p><a href="https://www.zhihu.com/question/61638635" target="_blank" rel="noopener">参考文章</a></p><h2 id="spark的各种HA-master-worker-executor的ha"><a href="#spark的各种HA-master-worker-executor的ha" class="headerlink" title="spark的各种HA,  master/worker/executor的ha"></a>spark的各种HA,  master/worker/executor的ha</h2><ul><li><h4 id="Master异常"><a href="#Master异常" class="headerlink" title="Master异常"></a>Master异常</h4><p>spark可以在集群运行时启动一个或多个standby Master,当 Master 出现异常时,会根据规则启动某个standby master接管,在standlone模式下有如下几种配置</p><ul><li><p>ZOOKEEPER</p><p>集群数据持久化到zk中,当master出现异常时,zk通过选举机制选出新的master,新的master接管是需要从zk获取持久化信息</p></li><li><p>FILESYSTEM</p><p>集群元数据信息持久化到本地文件系统, 当master出现异常时,只需要在该机器上重新启动master,启动后新的master获取持久化信息并根据这些信息恢复集群状态</p></li><li><p>CUSTOM</p><p>自定义恢复方式,对 standloneRecoveryModeFactory 抽象类 进行实现并把该类配置到系统中,当master出现异常时,会根据用户自定义行为恢复集群</p></li><li><p>None</p><p>不持久化集群的元数据, 当 master出现异常时, 新启动的Master 不进行恢复集群状态,而是直接接管集群</p></li></ul></li><li><h4 id="Worker异常"><a href="#Worker异常" class="headerlink" title="Worker异常"></a>Worker异常</h4><p>Worker 以定时发送心跳给 Master, 让 Master 知道 Worker 的实时状态,当worker出现超时时,Master 调用 timeOutDeadWorker 方法进行处理,在处理时根据 Worker 运行的是 Executor 和 Driver 分别进行处理</p><ul><li>如果是Executor, Master先把该 Worker 上运行的Executor 发送信息ExecutorUpdate给对应的Driver,告知Executor已经丢失,同时把这些Executor从其应用程序列表删除, 另外, 相关Executor的异常也需要处理</li><li>如果是Driver, 则判断是否设置重新启动,如果需要,则调用Master.shedule方法进行调度,分配合适节点重启Driver, 如果不需要重启, 则删除该应用程序</li></ul></li><li><h4 id="Executor异常"><a href="#Executor异常" class="headerlink" title="Executor异常"></a>Executor异常</h4><ol><li>Executor发生异常时由ExecutorRunner捕获该异常并发送ExecutorStateChanged信息给Worker</li><li>Worker接收到消息时, 在Worker的 handleExecutorStateChanged 方法中, 根据Executor状态进行信息更新,同时把Executor状态发送给Master</li><li>Master在接受Executor状态变化消息之后,如果发现其是异常退出,会尝试可用的Worker节点去启动Executor</li></ol></li></ul><h2 id="spark的内存管理机制"><a href="#spark的内存管理机制" class="headerlink" title="spark的内存管理机制"></a>spark的内存管理机制</h2><p><strong>spark的内存结构分为3大块:storage/execution/系统自留</strong></p><ul><li><p><strong>storage 内存</strong>：用于缓存 RDD、展开 partition、存放 Direct Task Result、存放广播变量。在 Spark Streaming receiver 模式中，也用来存放每个 batch 的 blocks</p></li><li><p><strong>execution 内存</strong>：用于 shuffle、join、sort、aggregation 中的缓存、buffer</p></li><li><p><strong>系统自留</strong>:</p><ul><li><p>在 spark 运行过程中使用：比如序列化及反序列化使用的内存，各个对象、元数据、临时变量使用的内存，函数调用使用的堆栈等</p></li><li><p>作为误差缓冲：由于 storage 和 execution 中有很多内存的使用是估算的，存在误差。当 storage 或 execution 内存使用超出其最大限制时，有这样一个安全的误差缓冲在可以大大减小 OOM 的概率</p></li></ul></li></ul><hr><h4 id="1-6版本以前的问题"><a href="#1-6版本以前的问题" class="headerlink" title="1.6版本以前的问题"></a>1.6版本以前的问题</h4><ul><li>旧方案最大的问题是 storage 和 execution 的内存大小都是固定的，不可改变，即使 execution 有大量的空闲内存且 storage 内存不足，storage 也无法使用 execution 的内存，只能进行 spill，反之亦然。所以，在很多情况下存在资源浪费</li><li>旧方案中，只有 execution 内存支持 off heap，storage 内存不支持 off heap</li></ul><h4 id="新方案的改进"><a href="#新方案的改进" class="headerlink" title="新方案的改进"></a>新方案的改进</h4><ul><li>新方案 storage 和 execution 内存可以互相借用，当一方内存不足可以向另一方借用内存，提高了整体的资源利用率</li><li>新方案中 execution 内存和 storage 内存均支持 off heap</li></ul><h2 id="spark中的广播变量"><a href="#spark中的广播变量" class="headerlink" title="spark中的广播变量"></a>spark中的广播变量</h2><p><a href="https://www.jianshu.com/p/6ef7f0a44fbf" target="_blank" rel="noopener">图片来源</a> /<a href="https://github.com/JerryLead/SparkInternals/blob/master/markdown/7-Broadcast.md" target="_blank" rel="noopener">文字来源</a></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/pictures/spark中的广播变量.png" alt=""></p><p><strong>顾名思义，broadcast 就是将数据从一个节点发送到其他各个节点上去。这样的场景很多，比如 driver 上有一张表，其他节点上运行的 task 需要 lookup 这张表，那么 driver 可以先把这张表 copy 到这些节点，这样 task 就可以在本地查表了。如何实现一个可靠高效的 broadcast 机制是一个有挑战性的问题。先看看 Spark 官网上的一段话：</strong></p><p>Broadcast variables allow the programmer to keep a <strong>read-only</strong> variable cached on each <strong>machine</strong> rather than shipping a copy of it with <strong>tasks</strong>. They can be used, for example, to give every node a copy of a <strong>large input dataset</strong> in an efficient manner. Spark also attempts to distribute broadcast variables using <strong>efficient</strong> broadcast algorithms to reduce communication cost.</p><h3 id="问题：为什么只能-broadcast-只读的变量？"><a href="#问题：为什么只能-broadcast-只读的变量？" class="headerlink" title="问题：为什么只能 broadcast 只读的变量？"></a>问题：为什么只能 broadcast 只读的变量？</h3><p>这就涉及一致性的问题，如果变量可以被更新，那么一旦变量被某个节点更新，其他节点要不要一块更新？如果多个节点同时在更新，更新顺序是什么？怎么做同步？还会涉及 fault-tolerance 的问题。为了避免维护数据一致性问题，Spark 目前只支持 broadcast 只读变量。</p><h3 id="问题：broadcast-到节点而不是-broadcast-到每个-task？"><a href="#问题：broadcast-到节点而不是-broadcast-到每个-task？" class="headerlink" title="问题：broadcast 到节点而不是 broadcast 到每个 task？"></a>问题：broadcast 到节点而不是 broadcast 到每个 task？</h3><p>因为每个 task 是一个线程，而且同在一个进程运行 tasks 都属于同一个 application。因此每个节点（executor）上放一份就可以被所有 task 共享。</p><h3 id="问题：-具体怎么用-broadcast？"><a href="#问题：-具体怎么用-broadcast？" class="headerlink" title="问题： 具体怎么用 broadcast？"></a>问题： 具体怎么用 broadcast？</h3><p>driver program 例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val data = List(1, 2, 3, 4, 5, 6)</span><br><span class="line">val bdata = sc.broadcast(data)</span><br><span class="line"></span><br><span class="line">val rdd = sc.parallelize(1 to 6, 2)</span><br><span class="line">val observedSizes = rdd.map(_ =&gt; bdata.value.size)</span><br></pre></td></tr></table></figure><p>driver 使用 <code>sc.broadcast()</code> 声明要 broadcast 的 data，bdata 的类型是 Broadcast。</p><p>当 <code>rdd.transformation(func)</code> 需要用 bdata 时，直接在 func 中调用，比如上面的例子中的 map() 就使用了 bdata.value.size。</p><h3 id="问题：怎么实现-broadcast？"><a href="#问题：怎么实现-broadcast？" class="headerlink" title="问题：怎么实现 broadcast？"></a>问题：怎么实现 broadcast？</h3><p>broadcast 的实现机制很有意思：</p><h4 id="1-分发-task-的时候先分发-bdata-的元信息"><a href="#1-分发-task-的时候先分发-bdata-的元信息" class="headerlink" title="1. 分发 task 的时候先分发 bdata 的元信息"></a>1. 分发 task 的时候先分发 bdata 的元信息</h4><p>Driver 先建一个本地文件夹用以存放需要 broadcast 的 data，并启动一个可以访问该文件夹的 HttpServer。当调用<code>val bdata = sc.broadcast(data)</code>时就把 data 写入文件夹，同时写入 driver 自己的 blockManger 中（StorageLevel 为内存＋磁盘），获得一个 blockId，类型为 BroadcastBlockId。当调用<code>rdd.transformation(func)</code>时，如果 func 用到了 bdata，那么 driver submitTask() 的时候会将 bdata 一同 func 进行序列化得到 serialized task，<strong>注意序列化的时候不会序列化 bdata 中包含的 data。</strong>上一章讲到 serialized task 从 driverActor 传递到 executor 时使用 Akka 的传消息机制，消息不能太大，而实际的 data 可能很大，所以这时候还不能 broadcast data。</p><blockquote><p>driver 为什么会同时将 data 放到磁盘和 blockManager 里面？放到磁盘是为了让 HttpServer 访问到，放到 blockManager 是为了让 driver program 自身使用 bdata 时方便（其实我觉得不放到 blockManger 里面也行）。</p></blockquote><p><strong>那么什么时候传送真正的 data？</strong>在 executor 反序列化 task 的时候，会同时反序列化 task 中的 bdata 对象，这时候会调用 bdata 的 readObject() 方法。该方法先去本地 blockManager 那里询问 bdata 的 data 在不在 blockManager 里面，如果不在就使用下面的两种 fetch 方式之一去将 data fetch 过来。得到 data 后，将其存放到 blockManager 里面，这样后面运行的 task 如果需要 bdata 就不需要再去 fetch data 了。如果在，就直接拿来用了。</p><p>下面探讨 broadcast data 时候的两种实现方式：</p><h4 id="2-HttpBroadcast"><a href="#2-HttpBroadcast" class="headerlink" title="2. HttpBroadcast"></a>2. HttpBroadcast</h4><p>顾名思义，HttpBroadcast 就是每个 executor 通过的 http 协议连接 driver 并从 driver 那里 fetch data。</p><p>Driver 先准备好要 broadcast 的 data，调用<code>sc.broadcast(data)</code>后会调用工厂方法建立一个 HttpBroadcast 对象。该对象做的第一件事就是将 data 存到 driver 的 blockManager 里面，StorageLevel 为内存＋磁盘，blockId 类型为 BroadcastBlockId。</p><p>同时 driver 也会将 broadcast 的 data 写到本地磁盘，例如写入后得到 <code>/var/folders/87/grpn1_fn4xq5wdqmxk31v0l00000gp/T/spark-6233b09c-3c72-4a4d-832b-6c0791d0eb9c/broadcast_0</code>， 这个文件夹作为 HttpServer 的文件目录。</p><blockquote><p>Driver 和 executor 启动的时候，都会生成 broadcastManager 对象，调用 HttpBroadcast.initialize()，driver 会在本地建立一个临时目录用来存放 broadcast 的 data，并启动可以访问该目录的 httpServer。</p></blockquote><p><strong>Fetch data：</strong>在 executor 反序列化 task 的时候，会同时反序列化 task 中的 bdata 对象，这时候会调用 bdata 的 readObject() 方法。该方法先去本地 blockManager 那里询问 bdata 的 data 在不在 blockManager 里面，<strong>如果不在就使用 http 协议连接 driver 上的 httpServer，将 data fetch 过来。</strong>得到 data 后，将其存放到 blockManager 里面，这样后面运行的 task 如果需要 bdata 就不需要再去 fetch data 了。如果在，就直接拿来用了。</p><p>HttpBroadcast 最大的问题就是 <strong>driver 所在的节点可能会出现网络拥堵</strong>，因为 worker 上的 executor 都会去 driver 那里 fetch 数据。</p><h4 id="3-TorrentBroadcast"><a href="#3-TorrentBroadcast" class="headerlink" title="3. TorrentBroadcast"></a>3. TorrentBroadcast</h4><p>为了解决 HttpBroadast 中 driver 单点网络瓶颈的问题，Spark 又设计了一种 broadcast 的方法称为 TorrentBroadcast，<strong>这个类似于大家常用的 BitTorrent 技术。</strong>基本思想就是将 data 分块成 data blocks，然后假设有 executor fetch 到了一些 data blocks，那么这个 executor 就可以被当作 data server 了，随着 fetch 的 executor 越来越多，有更多的 data server 加入，data 就很快能传播到全部的 executor 那里去了。</p><p>HttpBroadcast 是通过传统的 http 协议和 httpServer 去传 data，在 TorrentBroadcast 里面使用在上一章介绍的 blockManager.getRemote() =&gt; NIO ConnectionManager 传数据的方法来传递，读取数据的过程与读取 cached rdd 的方式类似，可以参阅 <a href="https://github.com/JerryLead/SparkInternals/blob/master/markdown/6-CacheAndCheckpoint.md" target="_blank" rel="noopener">CacheAndCheckpoint</a> 中的最后一张图。</p><p>下面讨论 TorrentBroadcast 的一些细节：</p><p><a href="https://github.com/JerryLead/SparkInternals/blob/master/markdown/PNGfigures/TorrentBroadcast.png" target="_blank" rel="noopener"><img src="https://github.com/JerryLead/SparkInternals/raw/master/markdown/PNGfigures/TorrentBroadcast.png" alt="TorrentBroadcast"></a></p><h4 id="driver-端："><a href="#driver-端：" class="headerlink" title="driver 端："></a>driver 端：</h4><p>Driver 先把 data 序列化到 byteArray，然后切割成 BLOCK_SIZE（由 <code>spark.broadcast.blockSize = 4MB</code> 设置）大小的 data block，每个 data block 被 TorrentBlock 对象持有。切割完 byteArray 后，会将其回收，因此内存消耗虽然可以达到 2 * Size(data)，但这是暂时的。</p><p>完成分块切割后，就将分块信息（称为 meta 信息）存放到 driver 自己的 blockManager 里面，StorageLevel 为内存＋磁盘，同时会通知 driver 自己的 blockManagerMaster 说 meta 信息已经存放好。<strong>通知 blockManagerMaster 这一步很重要，因为 blockManagerMaster 可以被 driver 和所有 executor 访问到，信息被存放到 blockManagerMaster 就变成了全局信息。</strong></p><p>之后将每个分块 data block 存放到 driver 的 blockManager 里面，StorageLevel 为内存＋磁盘。存放后仍然通知 blockManagerMaster 说 blocks 已经存放好。到这一步，driver 的任务已经完成。</p><h4 id="Executor-端："><a href="#Executor-端：" class="headerlink" title="Executor 端："></a>Executor 端：</h4><p>executor 收到 serialized task 后，先反序列化 task，这时候会反序列化 serialized task 中包含的 bdata 类型是 TorrentBroadcast，也就是去调用 TorrentBroadcast.readObject()。这个方法首先得到 bdata 对象，<strong>然后发现 bdata 里面没有包含实际的 data。怎么办？</strong>先询问所在的 executor 里的 blockManager 是会否包含 data（通过查询 data 的 broadcastId），包含就直接从本地 blockManager 读取 data。否则，就通过本地 blockManager 去连接 driver 的 blockManagerMaster 获取 data 分块的 meta 信息，获取信息后，就开始了 BT 过程。</p><p><strong>BT 过程：</strong>task 先在本地开一个数组用于存放将要 fetch 过来的 data blocks <code>arrayOfBlocks = new Array[TorrentBlock](totalBlocks)</code>，TorrentBlock 是对 data block 的包装。然后打乱要 fetch 的 data blocks 的顺序，比如如果 data block 共有 5 个，那么打乱后的 fetch 顺序可能是 3-1-2-4-5。然后按照打乱后的顺序去 fetch 一个个 data block。fetch 的过程就是通过 “本地 blockManager －本地 connectionManager－driver/executor 的 connectionManager－driver/executor 的 blockManager－data” 得到 data，这个过程与 fetch cached rdd 类似。<strong>每 fetch 到一个 block 就将其存放到 executor 的 blockManager 里面，同时通知 driver 上的 blockManagerMaster 说该 data block 多了一个存储地址。</strong>这一步通知非常重要，意味着 blockManagerMaster 知道 data block 现在在 cluster 中有多份，下一个不同节点上的 task 再去 fetch 这个 data block 的时候，可以有两个选择了，而且会随机选择一个去 fetch。这个过程持续下去就是 BT 协议，随着下载的客户端越来越多，data block 服务器也越来越多，就变成 p2p下载了。关于 BT 协议，Wikipedia 上有一个<a href="http://zh.wikipedia.org/wiki/BitTorrent_(%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">动画</a>)。</p><p>整个 fetch 过程结束后，task 会开一个大 Array[Byte]，大小为 data 的总大小，然后将 data block 都 copy 到这个 Array，然后对 Array 中 bytes 进行反序列化得到原始的 data，这个过程就是 driver 序列化 data 的反过程。</p><p>最后将 data 存放到 task 所在 executor 的 blockManager 里面，StorageLevel 为内存＋磁盘。显然，这时候 data 在 blockManager 里存了两份，不过等全部 executor 都 fetch 结束，存储 data blocks 那份可以删掉了。</p><h3 id="问题：broadcast-RDD-会怎样"><a href="#问题：broadcast-RDD-会怎样" class="headerlink" title="问题：broadcast RDD 会怎样?"></a>问题：broadcast RDD 会怎样?</h3><p><a href="http://weibo.com/u/1410938285" target="_blank" rel="noopener">@Andrew-Xia</a> 回答道：不会怎样，就是这个rdd在每个executor中实例化一份。</p><h2 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h2><p>公共数据的 broadcast 是很实用的功能，在 Hadoop 中使用 DistributedCache，比如常用的<code>-libjars</code>就是使用 DistributedCache 来将 task 依赖的 jars 分发到每个 task 的工作目录。不过分发前 DistributedCache 要先将文件上传到 HDFS。这种方式的主要问题是<strong>资源浪费</strong>，如果某个节点上要运行来自同一 job 的 4 个 mapper，那么公共数据会在该节点上存在 4 份（每个 task 的工作目录会有一份）。但是通过 HDFS 进行 broadcast 的好处在于<strong>单点瓶颈不明显</strong>，因为公共 data 首先被分成多个 block，然后不同的 block 存放在不同的节点。这样，只要所有的 task 不是同时去同一个节点 fetch 同一个 block，网络拥塞不会很严重。</p><p>对于 Spark 来讲，broadcast 时考虑的不仅是如何将公共 data 分发下去的问题，还要考虑如何让同一节点上的 task 共享 data。</p><p>对于第一个问题，Spark 设计了两种 broadcast 的方式，传统存在单点瓶颈问题的 HttpBroadcast，和类似 BT 方式的 TorrentBroadcast。HttpBroadcast 使用传统的 client-server 形式的 HttpServer 来传递真正的 data，而 TorrentBroadcast 使用 blockManager 自带的 NIO 通信方式来传递 data。TorrentBroadcast 存在的问题是<strong>慢启动</strong>和<strong>占内存</strong>，慢启动指的是刚开始 data 只在 driver 上有，要等 executors fetch 很多轮 data block 后，data server 才会变得可观，后面的 fetch 速度才会变快。executor 所占内存的在 fetch 完 data blocks 后进行反序列化时需要将近两倍 data size 的内存消耗。不管哪一种方式，driver 在分块时会有两倍 data size 的内存消耗。</p><p>对于第二个问题，每个 executor 都包含一个 blockManager 用来管理存放在 executor 里的数据，将公共数据存放在 blockManager 中（StorageLevel 为内存＋磁盘），可以保证在 executor 执行的 tasks 能够共享 data。</p><p>其实 Spark 之前还尝试了一种称为 TreeBroadcast 的机制，详情可以见技术报告 <a href="http://www.cs.berkeley.edu/~agearh/cs267.sp10/files/mosharaf-spark-bc-report-spring10.pdf" target="_blank" rel="noopener">Performance and Scalability of Broadcast in Spark</a>。</p><p>更深入点，broadcast 可以用多播协议来做，不过多播使用 UDP，不是可靠的，仍然需要应用层的设计一些可靠性保障机制。</p><h2 id="什么是数据倾斜-怎样去处理数据倾斜"><a href="#什么是数据倾斜-怎样去处理数据倾斜" class="headerlink" title="什么是数据倾斜,怎样去处理数据倾斜"></a>什么是数据倾斜,怎样去处理数据倾斜</h2><p>数据倾斜是一种很常见的问题（依据二八定律），简单来说，比方WordCount中某个Key对应的数据量非常大的话，就会产生数据倾斜，导致两个后果：</p><ul><li>OOM（单或少数的节点）；</li><li>拖慢整个Job执行时间（其他已经完成的节点都在等这个还在做的节点）</li></ul><h4 id="数据倾斜主要分为两类-聚合倾斜-和-join倾斜"><a href="#数据倾斜主要分为两类-聚合倾斜-和-join倾斜" class="headerlink" title="数据倾斜主要分为两类: 聚合倾斜 和 join倾斜"></a>数据倾斜主要分为两类: 聚合倾斜 和 join倾斜</h4><ul><li><p><strong>聚合倾斜</strong></p><ul><li><p><strong>双重聚合（局部聚合+全局聚合）</strong></p><p><strong>场景</strong>: 对RDD进行reduceByKey等聚合类shuffle算子，SparkSQL的groupBy做分组聚合这两种情况<br> 思路：首先通过map给每个key打上n以内的随机数的前缀并进行局部聚合，即(hello, 1) (hello, 1) (hello, 1) (hello, 1)变为(1_hello, 1) (1_hello, 1) (2_hello, 1)，并进行reduceByKey的局部聚合，然后再次map将key的前缀随机数去掉再次进行全局聚合；<br> <strong>原理</strong>: 对原本相同的key进行随机数附加，变成不同key，让原本一个task处理的数据分摊到多个task做局部聚合，规避单task数据过量。之后再去随机前缀进行全局聚合；<br> 优点：效果非常好（对聚合类Shuffle操作的倾斜问题）；<br> 缺点：范围窄（仅适用于聚合类的Shuffle操作，join类的Shuffle还需其它方案）</p></li></ul></li><li><p><strong>join倾斜</strong></p><ul><li><p><strong>将reduce join转为map join</strong></p><p><strong>场景</strong>: 对RDD或Spark SQL使用join类操作或语句，且join操作的RDD或表比较小（百兆或1,2G）； 思路：使用broadcast和map类算子实现join的功能替代原本的join，彻底规避shuffle。对较小RDD直接collect到内存，并创建broadcast变量；并对另外一个RDD执行map类算子，在该算子的函数中，从broadcast变量（collect出的较小RDD）与当前RDD中的每条数据依次比对key，相同的key执行你需要方式的join；</p><p><strong>原理</strong>: 若RDD较小，可采用广播小的RDD，并对大的RDD进行map，来实现与join同样的效果。简而言之，用broadcast-map代替join，规避join带来的shuffle（无Shuffle无倾斜）； 优点：效果很好（对join操作导致的倾斜），根治； </p><p><strong>缺点</strong>：适用场景小（大表+小表），广播（driver和executor节点都会驻留小表数据）小表也耗内存</p></li><li><p><strong>采样倾斜key并分拆join操作</strong></p><p><strong>场景</strong>: 两个较大的（无法采用方案五）RDD/Hive表进行join时，且一个RDD/Hive表中少数key数据量过大，另一个RDD/Hive表的key分布较均匀（RDD中两者之一有一个更倾斜）；<br><strong>思路</strong>:</p><ol><li>对更倾斜rdd1进行采样（RDD.sample）并统计出数据量最大的几个key；</li><li>对这几个倾斜的key从原本rdd1中拆出形成一个单独的rdd1_1，并打上0~n的随机数前缀，被拆分的原rdd1的另一部分（不包含倾斜key）又形成一个新rdd1_2；</li><li>对rdd2过滤出rdd1倾斜的key，得到rdd2_1，并将其中每条数据扩n倍，对每条数据按顺序附加0~n的前缀，被拆分出key的rdd2也独立形成另一个rdd2_2； 【个人认为，这里扩了n倍，最后union完还需要将每个倾斜key对应的value减去(n-1)】</li><li>将加了随机前缀的rdd1_1和rdd2_1进行join（此时原本倾斜的key被打散n份并被分散到更多的task中进行join）； 【个人认为，这里应该做两次join，两次join中间有一个map去前缀】</li><li>另外两个普通的RDD（rdd1_2、rdd2_2）照常join；</li><li>最后将两次join的结果用union结合得到最终的join结果。 原理：对join导致的倾斜是因为某几个key，可将原本RDD中的倾斜key拆分出原RDD得到新RDD，并以加随机前缀的方式打散n份做join，将倾斜key对应的大量数据分摊到更多task上来规避倾斜；</li></ol><p><strong>优点</strong>: 前提是join导致的倾斜（某几个key倾斜），避免占用过多内存（只需对少数倾斜key扩容n倍）；<br><strong>缺点</strong>: 对过多倾斜key不适用。</p></li><li><p><strong>用随机前缀和扩容RDD进行join</strong></p><p><strong>场景</strong>: RDD中有大量key导致倾斜； 思路：与方案六类似。</p><ol><li>查看RDD/Hive表中数据分布并找到造成倾斜的RDD/表；</li><li>对倾斜RDD中的每条数据打上n以内的随机数前缀；</li><li>对另外一个正常RDD的每条数据扩容n倍，扩容出的每条数据依次打上0到n的前缀；</li><li>对处理后的两个RDD进行join。</li></ol><p><strong>原理</strong>: 与方案六只有唯一不同在于这里对不倾斜RDD中所有数据进行扩大n倍，而不是找出倾斜key进行扩容；<br><strong>优点</strong>: 对join类的数据倾斜都可处理，效果非常显著；<br><strong>缺点</strong>: 缓解，扩容需要大内存</p></li></ul></li></ul><p><a href="https://juejin.im/post/5ccd5cc7f265da03474e1249#heading-9" target="_blank" rel="noopener">参考文章1</a></p><p><a href="https://blog.csdn.net/qq_35394891/article/details/82260907" target="_blank" rel="noopener">参考文章2</a></p><h2 id="分析一下一段spark代码中哪些部分在Driver端执行-哪些部分在Worker端执行"><a href="#分析一下一段spark代码中哪些部分在Driver端执行-哪些部分在Worker端执行" class="headerlink" title="分析一下一段spark代码中哪些部分在Driver端执行,哪些部分在Worker端执行"></a>分析一下一段spark代码中哪些部分在Driver端执行,哪些部分在Worker端执行</h2><p>Driver Program是用户编写的提交给Spark集群执行的application，它包含两部分</p><ul><li><strong>作为驱动</strong>： Driver与Master、Worker协作完成application进程的启动、DAG划分、计算任务封装、计算任务分发到各个计算节点(Worker)、计算资源的分配等。</li><li><strong>计算逻辑本身</strong>，当计算任务在Worker执行时，执行计算逻辑完成application的计算任务</li></ul><p>一般来说transformation算子均是在worker上执行的,其他类型的代码在driver端执行</p>]]></content>
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 面试 </tag>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>大数据面试之Hive</title>
      <link href="/2020/03/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E4%B9%8BHive/"/>
      <url>/2020/03/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E4%B9%8BHive/</url>
      <content type="html"><![CDATA[<h2 id="hive-内部表和外部表的区别"><a href="#hive-内部表和外部表的区别" class="headerlink" title="hive 内部表和外部表的区别"></a>hive 内部表和外部表的区别</h2><ul><li>建表时带有external关键字为外部表，否则为内部表</li><li>内部表和外部表建表时都可以自己指定location</li><li>删除表时，外部表不会删除对应的数据，只会删除元数据信息，内部表则会删除</li><li>其他用法是一样的</li></ul><a id="more"></a><h2 id="hive四种排序方式的区别"><a href="#hive四种排序方式的区别" class="headerlink" title="hive四种排序方式的区别"></a>hive四种排序方式的区别</h2><ul><li><p><strong>order by</strong> </p><pre><code>order by 是要对输出的结果进行全局排序，这就意味着**只有一个reducer**才能实现（多个reducer无法保证全局有序）但是当数据量过大的时候，效率就很低。如果在严格模式下（hive.mapred.mode=strict）,则必须配合limit使用</code></pre></li><li><p><strong>sort by</strong></p><pre><code>sort by 不是全局排序，只是在进入到reducer之前完成排序，只保证了每个reducer中数据按照指定字段的有序性，是局部排序。配置mapred.reduce.tasks=[nums]可以对输出的数据执行归并排序。可以配合limit使用，提高性能</code></pre></li><li><p><strong>distribute by</strong> </p><pre><code>distribute by 指的是按照指定的字段划分到不同的输出reduce文件中，和sort by一起使用时需要注意，</code></pre><p>distribute by必须放在前面</p></li><li><p><strong>cluster by</strong></p><p>cluster by 可以看做是一个特殊的distribute by+sort by，它具备二者的功能，但是只能实现倒序排序的方式,不能指定排序规则为asc 或者desc</p></li></ul><p><a href="https://blog.csdn.net/high2011/article/details/78012317" target="_blank" rel="noopener">参考文章</a></p><h2 id="hive的metastore的三种模式"><a href="#hive的metastore的三种模式" class="headerlink" title="hive的metastore的三种模式"></a>hive的metastore的三种模式</h2><ul><li><p><strong>内嵌Derby方式</strong></p><p>这个是Hive默认的启动模式，一般用于单元测试，这种存储方式有一个缺点：在同一时间只能有一个进程连接使用数据库。</p></li><li><p><strong>Local方式</strong></p><p>本地MySQL</p></li><li><p><strong>Remote方式</strong></p><p>远程MySQL,一般常用此种方式</p></li></ul><p><a href="https://blog.csdn.net/baolibin528/article/details/46710025" target="_blank" rel="noopener">参考文章</a></p><h2 id="hive中join都有哪些"><a href="#hive中join都有哪些" class="headerlink" title="hive中join都有哪些"></a>hive中join都有哪些</h2><p>Hive中除了支持和传统数据库中一样的内关联（JOIN）、左关联（LEFT JOIN）、右关联（RIGHT JOIN）、全关联（FULL JOIN），还支持左半关联（LEFT SEMI JOIN）</p><ul><li><p><strong>内关联（JOIN）</strong></p><p>只返回能关联上的结果。</p></li><li><p><strong>左外关联（LEFT [OUTER] JOIN）</strong></p><p>以LEFT [OUTER] JOIN关键字前面的表作为主表，和其他表进行关联，返回记录和主表的记录数一致，关联不上的字段置为NULL。</p></li><li><p><strong>右外关联（RIGHT [OUTER] JOIN）</strong></p><p>和左外关联相反，以RIGTH [OUTER] JOIN关键词后面的表作为主表，和前面的表做关联，返回记录数和主表一致，关联不上的字段为NULL。</p></li><li><p><strong>全外关联（FULL [OUTER] JOIN）</strong></p><p>以两个表的记录为基准，返回两个表的记录去重之和，关联不上的字段为NULL。</p></li><li><p><strong>LEFT SEMI JOIN</strong></p><p>以LEFT SEMI JOIN关键字前面的表为主表，返回主表的KEY也在副表中的记录</p></li><li><p><strong>笛卡尔积关联（CROSS JOIN）</strong></p><p>返回两个表的笛卡尔积结果，不需要指定关联键。</p></li></ul><p><a href="http://lxw1234.com/archives/2015/06/315.htm" target="_blank" rel="noopener">参考文章</a></p><h2 id="Impala-和-hive-的查询有哪些区别"><a href="#Impala-和-hive-的查询有哪些区别" class="headerlink" title="Impala 和 hive 的查询有哪些区别"></a>Impala 和 hive 的查询有哪些区别</h2><p><strong>Impala是基于Hive的大数据实时分析查询引擎</strong>，直接使用Hive的元数据库Metadata,意味着impala元数据都存储在Hive的metastore中。并且impala兼容Hive的sql解析，实现了Hive的SQL语义的子集，功能还在不断的完善中。</p><h4 id="Impala相对于Hive所使用的优化技术"><a href="#Impala相对于Hive所使用的优化技术" class="headerlink" title="Impala相对于Hive所使用的优化技术"></a>Impala相对于Hive所使用的优化技术</h4><ul><li>1、没有使用 MapReduce进行并行计算，虽然MapReduce是非常好的并行计算框架，但它更多的面向批处理模式，而不是面向交互式的SQL执行。与 MapReduce相比：Impala把整个查询分成一执行计划树，而不是一连串的MapReduce任务，在分发执行计划后，Impala使用拉式获取 数据的方式获取结果，把结果数据组成按执行树流式传递汇集，减少的了把中间结果写入磁盘的步骤，再从磁盘读取数据的开销。Impala使用服务的方式避免 每次执行查询都需要启动的开销，即相比Hive没了MapReduce启动时间。</li><li>2、使用LLVM产生运行代码，针对特定查询生成特定代码，同时使用Inline的方式减少函数调用的开销，加快执行效率。</li><li>3、充分利用可用的硬件指令（SSE4.2）。</li><li>4、更好的IO调度，Impala知道数据块所在的磁盘位置能够更好的利用多磁盘的优势，同时Impala支持直接数据块读取和本地代码计算checksum。</li><li>5、通过选择合适的数据存储格式可以得到最好的性能（Impala支持多种存储格式）。</li><li>6、最大使用内存，中间结果不写磁盘，及时通过网络以stream的方式传递。</li></ul><p><a href="https://cloud.tencent.com/developer/article/1175527" target="_blank" rel="noopener">参考文章</a></p><h2 id="Hive中大表join小表的优化方法"><a href="#Hive中大表join小表的优化方法" class="headerlink" title="Hive中大表join小表的优化方法"></a>Hive中大表join小表的优化方法</h2><p>在小表和大表进行join时，将<strong>小表放在前边</strong>，效率会高，hive会将小表进行缓存</p><h2 id="Hive-Sql-是怎样解析成MR-job的"><a href="#Hive-Sql-是怎样解析成MR-job的" class="headerlink" title="Hive Sql 是怎样解析成MR job的?"></a>Hive Sql 是怎样解析成MR job的?</h2><p><strong>主要分为6个阶段:</strong></p><ol><li><p><strong>Hive使用Antlr实现语法解析</strong>.根据Antlr制定的SQL语法解析规则,完成SQL语句的词法/语法解析,将SQL转为抽象语法树AST.</p></li><li><p><strong>遍历AST,生成基本查询单元QueryBlock</strong>.QueryBlock是一条SQL最基本的组成单元，包括三个部分：输入源，计算过程，输出.</p></li><li><strong>遍历QueryBlock,生成OperatorTree</strong>.Hive最终生成的MapReduce任务，Map阶段和Reduce阶段均由OperatorTree组成。Operator就是在Map阶段或者Reduce阶段完成单一特定的操作。QueryBlock生成Operator Tree就是遍历上一个过程中生成的QB和QBParseInfo对象的保存语法的属性.</li><li><strong>优化OperatorTree.</strong>大部分逻辑层优化器通过变换OperatorTree，合并操作符，达到减少MapReduce Job，减少shuffle数据量的目的</li><li><p><strong>OperatorTree生成MapReduce Job</strong>.遍历OperatorTree,翻译成MR任务.</p><ul><li>对输出表生成MoveTask</li><li>从OperatorTree的其中一个根节点向下深度优先遍历</li><li>ReduceSinkOperator标示Map/Reduce的界限，多个Job间的界限</li><li>遍历其他根节点，遇过碰到JoinOperator合并MapReduceTask</li><li>生成StatTask更新元数据</li><li>剪断Map与Reduce间的Operator的关系</li></ul></li><li><p><strong>优化任务.</strong> 使用物理优化器对MR任务进行优化,生成最终执行任务</p></li></ol><p><a href="https://www.cnblogs.com/Dhouse/p/7132476.html" target="_blank" rel="noopener">参考文章</a></p><h2 id="Hive-UDF简单介绍"><a href="#Hive-UDF简单介绍" class="headerlink" title="Hive UDF简单介绍"></a>Hive UDF简单介绍</h2><p>在Hive中，用户可以自定义一些函数，用于扩展HiveQL的功能，而这类函数叫做UDF（用户自定义函数）。UDF分为两大类：UDAF（用户自定义聚合函数）和UDTF（用户自定义表生成函数）。</p><p><strong>Hive有两个不同的接口编写UDF程序。一个是基础的UDF接口，一个是复杂的GenericUDF接口。</strong></p><ol><li>org.apache.hadoop.hive.ql. exec.UDF 基础UDF的函数读取和返回基本类型，即Hadoop和Hive的基本类型。如，Text、IntWritable、LongWritable、DoubleWritable等。</li><li>org.apache.hadoop.hive.ql.udf.generic.GenericUDF 复杂的GenericUDF可以处理Map、List、Set类型。</li></ol><p><a href="http://www.voidcn.com/article/p-suceexsl-vb.html" target="_blank" rel="noopener">参考文章</a></p><h2 id="Hive-SQL-按照学生科目取每个科目的TopN"><a href="#Hive-SQL-按照学生科目取每个科目的TopN" class="headerlink" title="Hive SQL : 按照学生科目取每个科目的TopN"></a>Hive SQL : 按照学生科目取每个科目的TopN</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">id,name,subject,score</span><br><span class="line">1,小明,语文,87</span><br><span class="line">2,张三,语文,27</span><br><span class="line">3,王五,语文,69</span><br><span class="line">4,李四,语文,99</span><br><span class="line">5,小明,数学,86</span><br><span class="line">6,马六,数学,33</span><br><span class="line">7,李四,数学,44</span><br><span class="line">8,小红,数学,50</span><br></pre></td></tr></table></figure><p><strong>按照各个科目的成绩排名 取 Top3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select a.* from</span><br><span class="line">(select id,name,subject,score,row_number() over(partition by subject order by score desc) rank from student) a</span><br><span class="line">where a.rank &lt;= 3</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/WYpersist/article/details/80318305" target="_blank" rel="noopener">参考文章</a></p><h2 id="Hive-SQL-获取每个用户的前1-4次的数据"><a href="#Hive-SQL-获取每个用户的前1-4次的数据" class="headerlink" title="Hive SQL: 获取每个用户的前1/4次的数据"></a>Hive SQL: 获取每个用户的前1/4次的数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cookieId  createTime    pv</span><br><span class="line">--------------------------</span><br><span class="line">cookie1 2015-04-10      1</span><br><span class="line">cookie1 2015-04-11      5</span><br><span class="line">cookie1 2015-04-12      7</span><br><span class="line">cookie1 2015-04-13      3</span><br><span class="line">cookie1 2015-04-14      2</span><br><span class="line">cookie1 2015-04-15      4</span><br><span class="line">cookie1 2015-04-16      4</span><br><span class="line">cookie2 2015-04-10      2</span><br><span class="line">cookie2 2015-04-11      3</span><br><span class="line">cookie2 2015-04-12      5</span><br><span class="line">cookie2 2015-04-13      6</span><br><span class="line">cookie2 2015-04-14      3</span><br><span class="line">cookie2 2015-04-15      9</span><br><span class="line">cookie2 2015-04-16      7</span><br></pre></td></tr></table></figure><p>获取每个用户前1/4次的访问记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.* from </span><br><span class="line">(SELECT cookieid,createtime,pv,NTILE(4)</span><br><span class="line">OVER(PARTITION BY cookieId ORDER BY createtime) AS rn</span><br><span class="line">from table ) a</span><br><span class="line">WHERE a.rn = 1</span><br></pre></td></tr></table></figure><p>NTILE(n)，用于将分组数据按照顺序切分成n片，返回当前切片值</p><p><a href="http://lxw1234.com/archives/2015/04/181.htm" target="_blank" rel="noopener">参考文章</a></p>]]></content>
      
      <categories>
          
          <category> Hive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 面试 </tag>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>大数据面试之Hadoop</title>
      <link href="/2020/03/01/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E4%B9%8BHadoop/"/>
      <url>/2020/03/01/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E4%B9%8BHadoop/</url>
      <content type="html"><![CDATA[<h2 id="HDFS架构"><a href="#HDFS架构" class="headerlink" title="HDFS架构"></a>HDFS架构</h2><h3 id="1-HDFS-1-0-架构"><a href="#1-HDFS-1-0-架构" class="headerlink" title="1. HDFS 1.0 架构"></a>1. HDFS 1.0 架构</h3><p>HDFS 采用的是 Master/Slave 架构，一个 HDFS 集群包含一个单独的 NameNode 和多个 DataNode 节点</p><a id="more"></a><h4 id="NameNode"><a href="#NameNode" class="headerlink" title="NameNode"></a>NameNode</h4><p>NameNode 负责管理整个分布式系统的元数据，主要包括：</p><ul><li>目录树结构；</li><li>文件到数据库 Block 的映射关系；</li></ul><ul><li>Block 副本及其存储位置等管理数据；</li><li>DataNode 的状态监控，两者通过段时间间隔的心跳来传递管理信息和数据信息，通过这种方式的信息传递，NameNode 可以获知每个 DataNode 保存的 Block 信息、DataNode 的健康状况、命令 DataNode 启动停止等（如果发现某个 DataNode 节点故障，NameNode 会将其负责的 block 在其他 DataNode 上进行备份）。</li></ul><p>这些数据保存在内存中，同时在磁盘保存两个元数据管理文件：fsimage 和 editlog。</p><ul><li>fsimage：是内存命名空间元数据在外存的镜像文件；</li><li>editlog：则是各种元数据操作的 write-ahead-log 文件，在体现到内存数据变化前首先会将操作记入 editlog 中，以防止数据丢失。</li></ul><p>这两个文件相结合可以构造完整的内存数据。</p><h4 id="Secondary-NameNode"><a href="#Secondary-NameNode" class="headerlink" title="Secondary NameNode"></a>Secondary NameNode</h4><p>Secondary NameNode 并不是 NameNode 的热备机，而是定期从 NameNode 拉取 fsimage 和 editlog 文件，并对两个文件进行合并，形成新的 fsimage 文件并传回 NameNode，这样做的目的是减轻 NameNod 的工作压力，本质上 SNN 是一个提供检查点功能服务的服务点。</p><h4 id="DataNode"><a href="#DataNode" class="headerlink" title="DataNode"></a>DataNode</h4><p>负责数据块的实际存储和读写工作，Block 默认是64MB（HDFS2.0改成了128MB），当客户端上传一个大文件时，HDFS 会自动将其切割成固定大小的 Block，为了保证数据可用性，每个 Block 会以多备份的形式存储，默认是3份。</p><hr><h3 id="2-HDFS-2-0-的-HA-实现"><a href="#2-HDFS-2-0-的-HA-实现" class="headerlink" title="2. HDFS 2.0 的 HA 实现"></a>2. HDFS 2.0 的 HA 实现</h3><p><img src="D:\Note\big-data-interview\BigData-Interview\pictures\hdfs-ha.png" alt="2.0架构图"></p><ul><li><p><strong>Active NameNode 和 Standby NameNode</strong>：两台 NameNode 形成互备，一台处于 Active 状态，为主 NameNode，另外一台处于 Standby 状态，为备 NameNode，只有主 NameNode 才能对外提供读写服务；</p></li><li><p><strong>ZKFailoverController</strong>（主备切换控制器，FC）：ZKFailoverController 作为独立的进程运行，对 NameNode 的主备切换进行总体控制。ZKFailoverController 能及时检测到 NameNode 的健康状况，在主 NameNode 故障时借助 Zookeeper 实现自动的主备选举和切换（当然 NameNode 目前也支持不依赖于 Zookeeper 的手动主备切换）；</p></li><li><p><strong>Zookeeper 集群</strong>：为主备切换控制器提供主备选举支持；</p></li><li><p><strong>共享存储系统</strong>：共享存储系统是实现 NameNode 的高可用最为关键的部分，共享存储系统保存了 NameNode 在运行过程中所产生的 HDFS 的元数据。主 NameNode 和备 NameNode 通过共享存储系统实现元数据同步。在进行主备切换的时候，新的主 NameNode 在<strong>确认元数据完全同步之后才能继续对外提供服务</strong>。</p></li><li><p><strong>DataNode 节点</strong>：因为主 NameNode 和备 NameNode 需要共享 HDFS 的数据块和 DataNode 之间的映射关系，为了使故障切换能够快速进行，DataNode 会同时向主 NameNode 和备 NameNode 上报数据块的位置信息。</p></li></ul><p><a href="http://matt33.com/2018/07/15/hdfs-architecture-learn/#HDFS-2-0-%E7%9A%84-HA-%E5%AE%9E%E7%8E%B0" target="_blank" rel="noopener">-&gt;参考文章链接</a></p><h2 id="Yarn架构"><a href="#Yarn架构" class="headerlink" title="Yarn架构"></a>Yarn架构</h2><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/pictures/yarn.gif" alt=""></p><h3 id="1-ResourceManager（RM）"><a href="#1-ResourceManager（RM）" class="headerlink" title="1. ResourceManager（RM）"></a>1. ResourceManager（RM）</h3><p>RM 是一个全局的资源管理器，负责整个系统的资源管理和分配，它主要有两个组件构成：</p><ol><li>调度器：Scheduler；</li><li>应用程序管理器：Applications Manager，ASM。</li></ol><h4 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h4><p>调度器根据容量、队列等限制条件（如某个队列分配一定的资源，最多执行一定数量的作业等），将系统中的资源分配给各个正在运行的应用程序。要注意的是，该调度器是一个纯调度器，它不再从事任何与应用程序有关的工作，比如不负责重新启动（因应用程序失败或者硬件故障导致的失败），这些均交由应用程序相关的 ApplicationMaster 完成。调度器仅根据各个应用程序的资源需求进行资源分配，而资源分配单位用一个抽象概念 <strong>资源容器(Resource Container，也即 Container)</strong>，Container 是一个动态资源分配单位，它将内存、CPU、磁盘、网络等资源封装在一起，从而限定每个任务使用的资源量。此外，该调度器是一个可插拔的组件，用户可根据自己的需求设计新的调度器，YARN 提供了多种直接可用的调度器，比如 Fair Scheduler 和 Capacity Schedule 等。</p><h4 id="应用程序管理器"><a href="#应用程序管理器" class="headerlink" title="应用程序管理器"></a>应用程序管理器</h4><p>应用程序管理器负责管理整个系统中所有应用程序，包括应用程序提交、与调度器协商资源以 AM、监控 AM 运行状态并在失败时重新启动它等。</p><h3 id="2-NodeManager（NM）"><a href="#2-NodeManager（NM）" class="headerlink" title="2. NodeManager（NM）"></a>2. NodeManager（NM）</h3><p>NM 是每个节点上运行的资源和任务管理器，一方面，它会定时向 RM 汇报本节点上的资源使用情况和各个 Container 的运行状态；另一方面，它接收并处理来自 AM 的 Container 启动/停止等各种请求。</p><h3 id="3-ApplicationMaster（AM）"><a href="#3-ApplicationMaster（AM）" class="headerlink" title="3. ApplicationMaster（AM）"></a>3. ApplicationMaster（AM）</h3><p>提交的每个作业都会包含一个 AM，主要功能包括：</p><ol><li>与 RM 协商以获取资源（用 container 表示）；</li><li>将得到的任务进一步分配给内部的任务；</li><li>与 NM 通信以启动/停止任务；</li><li>监控所有任务的运行状态，当任务有失败时，重新为任务申请资源并重启任务。</li></ol><p>MapReduce 就是原生支持 ON YARN 的一种框架，可以在 YARN 上运行 MapReduce 作业。有很多分布式应用都开发了对应的应用程序框架，用于在 YARN 上运行任务，例如 Spark，Storm、Flink 等。</p><h3 id="4-Container"><a href="#4-Container" class="headerlink" title="4. Container"></a>4. Container</h3><p>Container 是 YARN 中的资源抽象，它封装了某个节点上的多维度资源，如内存、CPU、磁盘、网络等，当 AM 向 RM 申请资源时，RM 为 AM 返回的资源便是用 Container 表示的。 YARN 会为每个任务分配一个 Container 且该任务只能使用该 Container 中描述的资源。</p><h2 id="MapReduce过程"><a href="#MapReduce过程" class="headerlink" title="MapReduce过程"></a>MapReduce过程</h2><p>MapReduce分为两个阶段: <strong>Map</strong> 和  <strong>Ruduce</strong>.</p><p><strong>Map阶段:</strong></p><ol><li><strong>input</strong>. 在进行map计算之前，mapreduce会根据输入文件计算输入分片（input split），每个输入分片（input split）针对一个map任务</li><li><strong>map</strong>. 就是程序员编写好的map函数了，因此map函数效率相对好控制，而且一般map操作都是本地化操作也就是在数据存储节点上进行</li><li><strong>Partition</strong>. 需要计算每一个map的结果需要发到哪个reduce端,partition数等于reducer数.默认采用HashPartition.</li><li><p><strong>spill</strong>.此阶段分为sort和combine.首先分区过得数据会经过排序之后写入环形内存缓冲区.在达到阈值之后守护线程将数据溢出分区文件.</p><ul><li><strong>sort</strong>. 在写入环形缓冲区前,对数据排序.&lt;key,value,partition&gt;格式排序</li><li><strong>combine</strong>(可选). 在溢出文件之前,提前开始combine,相当于本地化的reduce操作</li></ul></li><li><p><strong>merge.</strong> spill结果会有很多个文件,但最终输出只有一个,故有一个merge操作会合并所有的本地文件,并且该文件会有一个对应的索引文件.</p></li></ol><p><strong>Reduce阶段:</strong></p><ol><li><strong>copy</strong>. 拉取数据,reduce启动数据copy线程(默认5个),通过Http请求对应节点的map task输出文件,copy的数据也会先放到内部缓冲区.之后再溢写,类似map端操作.</li><li><strong>merge</strong>. 合并多个copy的多个map端的数据.在一个reduce端先将多个map端的数据溢写到本地磁盘,之后再将多个文件合并成一个文件.  数据经过 <strong>内存-&gt;磁盘 , 磁盘-&gt;磁盘</strong>的过程.</li><li><strong>output</strong>.merge阶段最后会生成一个文件,将此文件转移到内存中,shuffle阶段结束</li><li><strong>reduce</strong>. 开始执行reduce任务,最后结果保留在hdfs上.</li></ol><h2 id="Yarn-调度MapReduce过程"><a href="#Yarn-调度MapReduce过程" class="headerlink" title="Yarn 调度MapReduce过程"></a>Yarn 调度MapReduce过程</h2><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/picturees/yarn调度mr过程.jpg" alt=""></p><ol><li>Mr程序提交到客户端所在的节点（MapReduce）</li><li>yarnrunner向Resourcemanager申请一个application。</li><li>rm将该应用程序的资源路径返回给yarnrunner</li><li>该程序将运行所需资源提交到HDFS上</li><li>程序资源提交完毕后，申请运行mrAppMaster</li><li>RM将用户的请求初始化成一个task</li><li>其中一个NodeManager领取到task任务。</li><li>该NodeManager创建容器Container，并产生MRAppmaster</li><li>Container从HDFS上拷贝资源到本地</li><li>MRAppmaster向RM申请运行maptask容器</li><li>RM将运行maptask任务分配给另外两个NodeManager，另两个NodeManager分别领取任务并创建容器.</li><li>MR向两个接收到任务的NodeManager发送程序启动脚本，这两个NodeManager分别启动maptask，maptask对数据分区排序。</li><li>MRAppmaster向RM申请2个容器，运行reduce task。</li><li>reduce task向maptask获取相应分区的数据。</li><li>程序运行完毕后，MR会向RM注销自己。</li></ol><p><a href="https://blog.csdn.net/qq_26442553/article/details/78699759" target="_blank" rel="noopener">参考文章</a></p><h2 id="hdfs写流程"><a href="#hdfs写流程" class="headerlink" title="hdfs写流程"></a>hdfs写流程</h2><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/pictures/hdfs写流程.png" alt=""></p><ol><li>Client 调用 DistributedFileSystem 对象的 <code>create</code> 方法，创建一个文件输出流（FSDataOutputStream）对象；</li><li>通过 DistributedFileSystem 对象与集群的 NameNode 进行一次 RPC 远程调用，在 HDFS 的 Namespace 中创建一个文件条目（Entry），此时该条目没有任何的 Block，NameNode 会返回该数据每个块需要拷贝的 DataNode 地址信息；</li><li>通过 FSDataOutputStream 对象，开始向 DataNode 写入数据，数据首先被写入 FSDataOutputStream 对象内部的数据队列中，数据队列由 DataStreamer 使用，它通过选择合适的 DataNode 列表来存储副本，从而要求 NameNode 分配新的 block；</li><li>DataStreamer 将数据包以流式传输的方式传输到分配的第一个 DataNode 中，该数据流将数据包存储到第一个 DataNode 中并将其转发到第二个 DataNode 中，接着第二个 DataNode 节点会将数据包转发到第三个 DataNode 节点；</li><li>DataNode 确认数据传输完成，最后由第一个 DataNode 通知 client 数据写入成功；</li><li>完成向文件写入数据，Client 在文件输出流（FSDataOutputStream）对象上调用 <code>close</code> 方法，完成文件写入；</li><li>调用 DistributedFileSystem 对象的 complete 方法，通知 NameNode 文件写入成功，NameNode 会将相关结果记录到 editlog 中。</li></ol><h2 id="hdfs读流程"><a href="#hdfs读流程" class="headerlink" title="hdfs读流程"></a>hdfs读流程</h2><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/pictures/hdfs读流程.png" alt=""></p><ol><li>Client 通过 DistributedFileSystem 对象与集群的 NameNode 进行一次 RPC 远程调用，获取文件 block 位置信息；</li><li>NameNode 返回存储的每个块的 DataNode 列表；</li><li>Client 将连接到列表中最近的 DataNode；</li><li>Client 开始从 DataNode 并行读取数据；</li><li>一旦 Client 获得了所有必须的 block，它就会将这些 block 组合起来形成一个文件。</li></ol><h2 id="hdfs创建一个文件的流程"><a href="#hdfs创建一个文件的流程" class="headerlink" title="hdfs创建一个文件的流程"></a>hdfs创建一个文件的流程</h2><ol><li>客户端通过ClientProtocol协议向RpcServer发起创建文件的RPC请求。</li><li>FSNamesystem封装了各种HDFS操作的实现细节，RpcServer调用FSNamesystem中的相关方法以创建目录。</li><li>进一步的，FSDirectory封装了各种目录树操作的实现细节，FSNamesystem调用FSDirectory中的相关方法在目录树中创建目标文件，并通过日志系统备份文件系统的修改。</li><li>最后，RpcServer将RPC响应返回给客户端。</li></ol><p><a href="https://monkeysayhi.github.io/2018/02/07/%E6%BA%90%E7%A0%81%7CHDFS%E4%B9%8BNameNode%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%EF%BC%881%EF%BC%89/" target="_blank" rel="noopener">参考文章</a></p><h2 id="hadoop1-x-和hadoop-2-x-的区别"><a href="#hadoop1-x-和hadoop-2-x-的区别" class="headerlink" title="hadoop1.x 和hadoop 2.x 的区别"></a>hadoop1.x 和hadoop 2.x 的区别</h2><ol><li><p><strong>资源调度方式的改变</strong></p><p>在1.x, 使用Jobtracker负责任务调度和资源管理,单点负担过重,在2.x中,新增了yarn作为集群的调度工具.在yarn中,使用ResourceManager进行 资源管理, 单独开启一个Container作为ApplicationMaster来进行任务管理.</p></li><li><p><strong>HA模式</strong></p><p>在1.x中没有HA模式,集群中只有一个NameNode,而在2.x中可以启用HA模式,存在一个Active NameNode 和Standby NameNode.</p></li><li><p><strong>HDFS Federation</strong></p><p>Hadoop 2.0中对HDFS进行了改进，使NameNode可以横向扩展成多个，每个NameNode分管一部分目录，进而产生了HDFS Federation，该机制的引入不仅增强了HDFS的扩展性，也使HDFS具备了隔离性</p></li></ol><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/pictures/hadoop1.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/pictures/hadoop2.jpg" alt=""></p><h2 id="hadoop1-x的缺点"><a href="#hadoop1-x的缺点" class="headerlink" title="hadoop1.x的缺点"></a>hadoop1.x的缺点</h2><ol><li>JobTracker存在单点故障的隐患</li><li>任务调度和资源管理全部是JobTracker来完成,单点负担过重</li><li>TaskTracker以Map/Reduce数量表示资源太过简单</li><li>TaskTracker 分Map Slot 和 Reduce Slot, 如果任务只需要map任务可能会造成资源浪费</li></ol><h2 id="hadoop-HA介绍"><a href="#hadoop-HA介绍" class="headerlink" title="hadoop HA介绍"></a>hadoop HA介绍</h2><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/pictures/hdfs-ha.png" alt=""></p><ol><li><strong>Active NameNode 和 Standby NameNode</strong>：两台 NameNode 形成互备，一台处于 Active 状态，为主 NameNode，另外一台处于 Standby 状态，为备 NameNode，只有主 NameNode 才能对外提供读写服务；</li><li><strong>ZKFailoverController（主备切换控制器，FC）</strong>：ZKFailoverController 作为独立的进程运行，对 NameNode 的主备切换进行总体控制。ZKFailoverController 能及时检测到 NameNode 的健康状况，在主 NameNode 故障时借助 Zookeeper 实现自动的主备选举和切换（当然 NameNode 目前也支持不依赖于 Zookeeper 的手动主备切换）；</li><li><strong>Zookeeper 集群</strong>：为主备切换控制器提供主备选举支持；</li><li><strong>共享存储系统</strong>：共享存储系统是实现 NameNode 的高可用最为关键的部分，共享存储系统保存了 NameNode 在运行过程中所产生的 HDFS 的元数据。主 NameNode 和备 NameNode 通过共享存储系统实现元数据同步。在进行主备切换的时候，新的主 NameNode 在<strong>确认元数据完全同步之后才能继续对外提供服务</strong>。</li><li><strong>DataNode 节点</strong>：因为主 NameNode 和备 NameNode 需要共享 HDFS 的数据块和 DataNode 之间的映射关系，为了使故障切换能够快速进行，DataNode 会同时向主 NameNode 和备 NameNode 上报数据块的位置信息。</li></ol><h2 id="hadoop的常用配置文件有哪些"><a href="#hadoop的常用配置文件有哪些" class="headerlink" title="hadoop的常用配置文件有哪些"></a>hadoop的常用配置文件有哪些</h2><ul><li><p><strong>hadoop-env.sh</strong>: 用于定义hadoop运行环境相关的配置信息，比如配置JAVA_HOME环境变量、为hadoop的JVM指定特定的选项、指定日志文件所在的目录路径以及master和slave文件的位置等；</p></li><li><p><strong>core-site.xml</strong>: 用于定义系统级别的参数，如HDFS URL、Hadoop的临时目录以及用于rack-aware集群中的配置文件的配置等，此中的参数定义会覆盖core-default.xml文件中的默认配置；</p></li><li><p><strong>hdfs-site.xml</strong>: HDFS的相关设定，如文件副本的个数、块大小及是否使用强制权限等，此中的参数定义会覆盖hdfs-default.xml文件中的默认配置；</p></li><li><p><strong>mapred-site.xml</strong>：HDFS的相关设定，如reduce任务的默认个数、任务所能够使用内存的默认上下限等，此中的参数定义会覆盖mapred-default.xml文件中的默认配置；</p></li></ul><h2 id="小文件过多会有什么危害-如何避免"><a href="#小文件过多会有什么危害-如何避免" class="headerlink" title="小文件过多会有什么危害,如何避免?"></a>小文件过多会有什么危害,如何避免?</h2><p>Hadoop上大量HDFS元数据信息存储在NameNode内存中,因此过多的小文件必定会压垮NameNode的内存.</p><p>每个元数据对象约占150byte，所以如果有1千万个小文件，每个文件占用一个block，则NameNode大约需要2G空间。如果存储1亿个文件，则NameNode需要20G空间.</p><p>显而易见的解决这个问题的方法就是合并小文件,可以选择在客户端上传时执行一定的策略先合并,或者是使用Hadoop的CombineFileInputFormat&lt;K,V&gt;实现小文件的合并</p><p><a href="https://blog.csdn.net/luofazha2012/article/details/80904791" target="_blank" rel="noopener">参考文章</a></p><h2 id="启动hadoop集群会分别启动哪些进程-各自的作用"><a href="#启动hadoop集群会分别启动哪些进程-各自的作用" class="headerlink" title="启动hadoop集群会分别启动哪些进程,各自的作用"></a>启动hadoop集群会分别启动哪些进程,各自的作用</h2><ul><li><p><strong>NameNode：</strong></p><ul><li>维护文件系统树及整棵树内所有的文件和目录。这些信息永久保存在本地磁盘的两个文件中：命名空间镜像文件、编辑日志文件</li><li>记录每个文件中各个块所在的数据节点信息，这些信息在内存中保存，每次启动系统时重建这些信息</li><li>负责响应客户端的   数据块位置请求  。也就是客户端想存数据，应该往哪些节点的哪些块存；客户端想取数据，应该到哪些节点取</li><li>接受记录在数据存取过程中，datanode节点报告过来的故障、损坏信息</li></ul></li><li><p><strong>SecondaryNameNode(非HA模式)：</strong></p><ul><li>实现namenode容错的一种机制。定期合并编辑日志与命名空间镜像，当namenode挂掉时，可通过一定步骤进行上顶。(<strong>注意 并不是NameNode的备用节点</strong>)</li></ul></li><li><strong>DataNode：</strong><ul><li>根据需要存取并检索数据块</li><li>定期向namenode发送其存储的数据块列表</li></ul></li><li><strong>ResourceManager：</strong><ul><li>负责Job的调度,将一个任务与一个NodeManager相匹配。也就是将一个MapReduce之类的任务分配给一个从节点的NodeManager来执行。</li></ul></li><li><p><strong>NodeManager：</strong></p><ul><li>运行ResourceManager分配的任务，同时将任务进度向application master报告</li></ul></li><li><p><strong>JournalNode(HA下启用):</strong></p><ul><li>高可用情况下存放namenode的editlog文件</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 面试 </tag>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>大数据面试题全套汇总+答案</title>
      <link href="/2020/02/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E9%A2%98%E5%85%A8%E5%A5%97%E6%B1%87%E6%80%BB+%E7%AD%94%E6%A1%88/"/>
      <url>/2020/02/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E9%A2%98%E5%85%A8%E5%A5%97%E6%B1%87%E6%80%BB+%E7%AD%94%E6%A1%88/</url>
      <content type="html"><![CDATA[<h4 id="大数据面试题全套汇总-答案"><a href="#大数据面试题全套汇总-答案" class="headerlink" title="大数据面试题全套汇总+答案"></a>大数据面试题全套汇总+答案</h4><hr><table><br>    <tr><br>     <th><img width="50px" src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/pictures/hadoop.jpg"></th><br>     <th><img width="50px" src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/pictures/hive.jpg"></th><br>     <th><img width="50px" src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/pictures/spark.jpg"></th><br>     <th><img width="50px" src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/pictures/flink.png"></th><br>     <th><img width="50px" src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/pictures/hbase.png"></th><br>     <th><img width="50px" src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/pictures/kafka.png"></th><br>     <th><img width="50px" src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2020/bd_Interview/pictures/zookeeper.jpg"></th><br>    </tr><br><tr><br>  <td align="center"><a href="#一hadoop">Hadoop</a></td><br>  <td align="center"><a href="#二hive">Hive</a></td><br>  <td align="center"><a href="#三spark">Spark</a></td><br>  <td align="center"><a href="#四flink">Flink</a></td><br>  <td align="center"><a href="#五hbase">HBase</a></td><br>  <td align="center"><a href="#六kafka">Kafka</a></td><br>  <td align="center"><a href="#七zookeeper">Zookeeper</a></td><br></tr><br>    </table><a id="more"></a><h2 id="一、Hadoop"><a href="#一、Hadoop" class="headerlink" title="一、Hadoop"></a>一、Hadoop</h2><ol><li>HDFS架构 </li><li>Yarn架构 </li><li>MapReduce过程 </li><li>Yarn 调度MapReduce </li><li>hdfs写流程 </li><li>hdfs读流程</li><li>hdfs创建一个文件的流程 </li><li>hadoop1.x 和hadoop 2.x 的区别 </li><li>hadoop1.x的缺点 </li><li>hadoop HA介绍 </li><li>hadoop的常用配置文件有哪些,自己实际改过哪些? </li><li>小文件过多会有什么危害,如何避免? </li><li>启动hadoop集群会分别启动哪些进程,各自的作用 </li></ol><h2 id="二、Hive"><a href="#二、Hive" class="headerlink" title="二、Hive"></a>二、Hive</h2><ol><li>hive 内部表和外部表的区别</li><li>hive中 sort by / order by / cluster by / distribute by 的区别</li><li>hive的metastore的三种模式</li><li>hive 中 join都有哪些</li><li>Impala 和 hive 的查询有哪些区别 </li><li>Hive中大表join小表的优化方法 </li><li>Hive Sql 是怎样解析成MR job的? </li><li>Hive UDF简单介绍 </li><li>SQL题: 按照学生科目分组, 取每个科目的TopN </li><li>SQL题: 获取每个用户的前1/4次的数据 </li></ol><h2 id="三、Spark"><a href="#三、Spark" class="headerlink" title="三、Spark"></a>三、Spark</h2><ol><li>讲一下spark 的运行架构 </li><li>一个spark程序的执行流程 </li><li>spark的shuffle介绍 </li><li>Spark的 partitioner 都有哪些? </li><li>spark 有哪几种join </li><li>RDD有哪些特点 </li><li>讲一下宽依赖和窄依赖 </li><li>Spark中的算子都有哪些 </li><li>RDD的缓存级别都有哪些 </li><li>RDD 懒加载是什么意思 </li><li>讲一下spark的几种部署方式 </li><li>spark on yarn 模式下的 cluster模式和 client模式有什么区别 </li><li>spark运行原理,从提交一个jar到最后返回结果,整个过程 </li><li>spark的stage是如何划分的 </li><li>spark的rpc: spark2.0为什么放弃了akka 而用netty? </li><li>spark的各种HA,  master/worker/executor/driver/task的ha </li><li>spark的内存管理机制,spark 1.6前后分析对比, spark2.0 做出来哪些优化 </li><li>讲一下spark 中的广播变量 </li><li>什么是数据倾斜,怎样去处理数据倾斜 </li><li>分析一下一段spark代码中哪些部分在Driver端执行,哪些部分在Worker端执行 </li></ol><h2 id="四、Flink"><a href="#四、Flink" class="headerlink" title="四、Flink"></a>四、Flink</h2><ol><li>讲一下flink的运行架构 </li><li>讲一下flink的作业执行流程 </li><li>flink具体是如何实现exactly once 语义 </li><li>flink 的 window 实现机制 </li><li>flink的window分类 </li><li>flink 的 state 是存储在哪里的 </li><li>flink是如何实现反压的 </li><li>flink的部署模式都有哪些 </li><li>讲一下flink on yarn的部署 </li><li>flink中的时间概念 , eventTime 和 processTime的区别 </li><li>flink中的session Window怎样使用 </li></ol><h2 id="五、HBase"><a href="#五、HBase" class="headerlink" title="五、HBase"></a>五、HBase</h2><ol><li>讲一下 Hbase 架构 </li><li>hbase 如何设计 rowkey </li><li>讲一下hbase的存储结构,这样的存储结构有什么优缺点 </li><li>hbase的HA实现,zookeeper在其中的作用 </li><li>HMaster宕机的时候,哪些操作还能正常工作 </li><li>讲一下hbase的写数据的流程 </li><li>讲一下hbase读数据的流程 </li></ol><h2 id="六、Kafka"><a href="#六、Kafka" class="headerlink" title="六、Kafka"></a>六、Kafka</h2><ol><li>讲一下 kafka 的架构 </li><li>kafka 与其他消息组件对比? </li><li>kafka 实现高吞吐的原理 </li><li>kafka怎样保证不重复消费 </li><li>kafka怎样保证不丢失消息 </li><li>kafka 与 spark streaming 集成,如何保证 exactly once 语义 </li><li>ack 有哪几种, 生产中怎样选择? </li><li>如何通过 offset 寻找数据 </li><li>如何清理过期数据 </li><li>1条message中包含哪些信息 </li><li>讲一下zookeeper在kafka中的作用 </li><li>kafka 可以脱离 zookeeper 单独使用吗 </li><li>kafka有几种数据保留策略 </li><li>kafka同时设置了7天和10G清除数据,到第5天的时候消息到达了10G,这个时候kafka如何处理? </li></ol><h2 id="七、Zookeeper"><a href="#七、Zookeeper" class="headerlink" title="七、Zookeeper"></a>七、Zookeeper</h2><ol><li>zookeeper是什么,都有哪些功能 </li><li>zk 有几种部署模式 </li><li>zk 是怎样保证主从节点的状态同步</li><li>说一下 zk 的通知机制</li><li>zk 的分布式锁实现方式</li><li>zk 采用的哪种分布式一致性协议? 还有哪些分布式一致性协议</li><li>讲一下leader 选举过程</li></ol>]]></content>
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>架构篇——MySQL高可用集群(PXC)详解</title>
      <link href="/2019/06/11/%E6%9E%B6%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4-PXC-%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/06/11/%E6%9E%B6%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4-PXC-%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h5 id="在介绍PXC之前，先来看一个相关的技术：MyCat"><a href="#在介绍PXC之前，先来看一个相关的技术：MyCat" class="headerlink" title="在介绍PXC之前，先来看一个相关的技术：MyCat"></a>在介绍PXC之前，先来看一个相关的技术：MyCat</h5><h3 id="MyCat简介"><a href="#MyCat简介" class="headerlink" title="MyCat简介"></a>MyCat简介</h3><p>MyCat是阿里开源的分布式数据库分库分表中间件</p><blockquote><p>MyCat是一个开源的分布式数据库系统，是一个实现了MySQL协议的服务器，前端用户可以把它看作是一个数据库代理，用MySQL客户端工具和命令行访问，而其后端可以用MySQL原生协议与多个MySQL服务器通信，也可以用JDBC协议与大多数主流数据库服务器通信</p></blockquote><h4 id="MyCat功能"><a href="#MyCat功能" class="headerlink" title="MyCat功能:"></a>MyCat功能:</h4><ul><li>数据库读写分离(写操作在主,读操作在从数据库)</li><li>读的负载均衡(一主多从)</li><li>垂直拆分(将表分开为多个数据库)</li><li>水平拆分(对表取模拆分)</li></ul><a id="more"></a><blockquote><p>MyCAT是mysql中间件，前身是阿里大名鼎鼎的Cobar，Cobar在开源了一段时间后，不了了之。于是MyCAT扛起了这面大旗，在大数据时代，其重要性愈发彰显。这篇文章主要是MyCAT的入门部署。</p></blockquote><ul><li>更多相关可以参考这里：<a href="https://www.jianshu.com/p/c6e29d724fca" target="_blank" rel="noopener">https://www.jianshu.com/p/c6e29d724fca</a></li></ul><p>下面是MyCat结合PXC的架构图</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2019/phps/pxc.png"></p><h3 id="PXC简介"><a href="#PXC简介" class="headerlink" title="PXC简介"></a>PXC简介</h3><p>PXC是percona公司的percona  xtraDB  cluster，简称PXC。它是基于Galera协议的高可用集群方案。可以实现多个节点间的数据同步复制以及读写，并且可保障数据库的服务高可用及数据强一致性。</p><blockquote><p>PXC就属于一套近乎完美的MySQL高可用集群架构方案；</p></blockquote><h5 id="主要特点是：-读写强一致性-牺牲性能"><a href="#主要特点是：-读写强一致性-牺牲性能" class="headerlink" title="主要特点是： 读写强一致性(牺牲性能)"></a>主要特点是： 读写强一致性(牺牲性能)</h5><h5 id="PXC特性"><a href="#PXC特性" class="headerlink" title="PXC特性"></a>PXC特性</h5><ul><li>1）同步复制，事务要么在所有节点提交或不提交。</li><li>2）多主复制，可以在任意节点进行写操作。</li><li>3）在从服务器上并行应用事件，真正意义上的并行复制。</li><li>4）节点自动配置，数据一致性，不再是异步复制。</li></ul><p>PXC最大的优势：强一致性、无同步延迟</p><ul><li><p>优点总结：</p><ul><li>服务高可用</li><li>可以达到时时同步(并发复制)，无延迟现象发生</li><li>完全兼容MySQL</li><li>对于集群中新节点的加入(自动部署)，维护起来很简单</li><li>数据的强一致性</li><li>多个可同时读写节点，可实现写扩展，不过最好事先进行分库分表，让各个节点分别写不同的表或者库，避免让galera解决数据冲突；</li></ul></li><li><p>不足之处总结：</p><ul><li>只支持Innodb存储引擎</li><li>存在多节点update更新问题，也就是写放大问题</li><li>在线DDL语句，锁表问题</li><li>sst针对新节点加入的传输代价过高的问题</li><li>所有表都要有主键；</li><li>不支持LOCK TABLE等显式锁操作；</li><li>锁冲突、死锁问题相对更多；</li><li>不支持XA；</li></ul></li></ul><p>事实上，采用PXC的主要目的是解决数据的一致性问题，高可用是顺带实现的。因为PXC存在写扩大以及短板效应，并发效率会有较大损失，类似semi sync replication机制。</p><pre><code>网络说明基于Galere协议的高可用方案：pxc+ Galera是Codership提供的多主数据同步复制机制，可以实现多个节点间的数据同步复制以及读写，并且+ 可保障数据库的服务高可用及数据一致性。+ 基于Galera的高可用方案主要有MariaDB Galera Cluster和Percona XtraDB Cluster（简称PXC），目前PXC用的会比较多一些。+ mariadb的集群原理跟PXC一样,maridb-cluster其实就是PXC，两者原理是一样的。</code></pre><h3 id="PXC原理"><a href="#PXC原理" class="headerlink" title="PXC原理"></a>PXC原理</h3><p>Percona XtraDB Cluster（简称PXC集群）提供了MySQL高可用的一种实现方法。</p><ul><li>1）集群是有节点组成的，推荐配置至少3个节点，但是也可以运行在2个节点上。</li><li>2）每个节点都是普通的mysql/percona服务器，可以将现有的数据库服务器组成集群，反之，也可以将集群拆分成单独的服务器。</li><li>3）每个节点都包含完整的数据副本。</li></ul><p>PXC集群主要由两部分组成：Percona Server with XtraDB和Write Set Replication patches（使用了Galera library，一个通用的用于事务型应用的同步、多主复制插件）。</p><p>PXC会使用大概是4个端口号</p><ul><li>3306 数据库对外服务的端口号</li><li>4444 请求SST SST: 指数据一个镜象传输 xtrabackup , rsync ,mysqldump </li><li>4567 : 组成员之间进行沟通的一个端口号</li><li>4568 : 传输IST用的。相对于SST来说的一个增量。</li></ul><blockquote><p>注：安装PXC过程中， iptables 禁掉 ，selinux 也禁掉</p></blockquote><h3 id="PXC的操作流程："><a href="#PXC的操作流程：" class="headerlink" title="PXC的操作流程："></a>PXC的操作流程：</h3><ul><li>首先客户端先发起一个事务，该事务先在本地执行，执行完成之后就要发起对事务的提交操作了。</li><li>在提交之前需要将产生的复制写集广播出去，然后获取到一个全局的事务ID号，一并传送到另一个节点上面。</li><li>通过合并数据之后，发现没有冲突数据，执行apply_cd和commit_cb动作，否则就需要取消此次事务的操作。</li><li>当前server节点通过验证之后，执行提交操作，并返回OK，如果验证没通过，则执行回滚。</li><li>在生产中至少要有3个节点的集群环境，如果其中一个节点没有验证通过，出现了数据冲突，那么此时采取的方式就是讲出现不一致的节点踢出集群环境，而且它自己会执行shutdown命令，自动关机。</li></ul><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>部署环境： CentOS7.X</p><h5 id="1、执行-命令-vi-etc-selinux-config"><a href="#1、执行-命令-vi-etc-selinux-config" class="headerlink" title="1、执行 命令   vi /etc/selinux/config"></a>1、执行 命令   vi /etc/selinux/config</h5><pre><code>SELINUX=disabled   #修改该项为disabled</code></pre><h5 id="2、执行命令-setenforce-0"><a href="#2、执行命令-setenforce-0" class="headerlink" title="2、执行命令   setenforce 0"></a>2、执行命令   setenforce 0</h5><h5 id="3、查看防火墙是否开启-systemctl-status-firewalld"><a href="#3、查看防火墙是否开启-systemctl-status-firewalld" class="headerlink" title="3、查看防火墙是否开启     systemctl status firewalld"></a>3、查看防火墙是否开启     systemctl status firewalld</h5><p>如果防火墙是开启状态，则开放端口 3306 、4444、4567、4568</p><pre><code>firewall-cmd --add-port=3306/tcp --permanent     #开放了3306端口</code></pre><p>开放完4个端口后，重新加载防火墙规则</p><pre><code>firewall-cmd --reload</code></pre><h5 id="4、安装Persona仓库"><a href="#4、安装Persona仓库" class="headerlink" title="4、安装Persona仓库"></a>4、安装Persona仓库</h5><pre><code>yum install http://www.percona.com/downloads/percona-release/redhat/0.1-4/percona-release-0.1-4.noarch.rpm</code></pre><h5 id="5、安装PXC（保证服务器没有装MySQL）卸载MySQL-参考链接：https-blog-csdn-net-tjcyjd-article-details-52189182"><a href="#5、安装PXC（保证服务器没有装MySQL）卸载MySQL-参考链接：https-blog-csdn-net-tjcyjd-article-details-52189182" class="headerlink" title="5、安装PXC（保证服务器没有装MySQL）卸载MySQL 参考链接：https://blog.csdn.net/tjcyjd/article/details/52189182"></a>5、安装PXC（保证服务器没有装MySQL）卸载MySQL 参考链接：<a href="https://blog.csdn.net/tjcyjd/article/details/52189182" target="_blank" rel="noopener">https://blog.csdn.net/tjcyjd/article/details/52189182</a></h5><pre><code>yum install Percona-XtraDB-Cluster-57</code></pre><h5 id="6、开启PXC服务"><a href="#6、开启PXC服务" class="headerlink" title="6、开启PXC服务"></a>6、开启PXC服务</h5><pre><code>service mysql start</code></pre><h5 id="7、查看安装数据库的临时密码并记住"><a href="#7、查看安装数据库的临时密码并记住" class="headerlink" title="7、查看安装数据库的临时密码并记住"></a>7、查看安装数据库的临时密码并记住</h5><pre><code>grep &apos;temporary password&apos; /var/log/mysqld.log</code></pre><h5 id="8、登录MySQL数据库"><a href="#8、登录MySQL数据库" class="headerlink" title="8、登录MySQL数据库"></a>8、登录MySQL数据库</h5><pre><code>mysql -u root -p</code></pre><p>输入临时密码, 登录成功后修改密码</p><pre><code>ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;你的密码&apos;;</code></pre><h5 id="9、停止MySQL服务"><a href="#9、停止MySQL服务" class="headerlink" title="9、停止MySQL服务"></a>9、停止MySQL服务</h5><pre><code>service mysql stop   （某些版本使用mysqld）</code></pre><h5 id="10、配置节点"><a href="#10、配置节点" class="headerlink" title="10、配置节点"></a>10、配置节点</h5><pre><code>vi  /etc/percona-xtradb-cluster.conf.d/wsrep.cnf</code></pre><p>修改配置文件</p><pre><code># Cluster connection URL contains IPs of nodes#If no IP is found, this implies that a new cluster needs to be created,#in order to do that you need to bootstrap this node#集群中节点的IP地址（本机填最后）wsrep_cluster_address=gcomm://ip地址,IP地址,IP地址（用,号隔开）# In order for Galera to work correctly binlog format should be ROWbinlog_format=ROW# MyISAM storage engine has only experimental supportdefault_storage_engine=InnoDB# Slave thread to usewsrep_slave_threads= 8wsrep_log_conflicts# This changes how InnoDB autoincrement locks are managed and is a requirement for Galerainnodb_autoinc_lock_mode=2# Node IP address#当前节点IPwsrep_node_address=IP地址# Cluster name#集群名称wsrep_cluster_name=pxc-cluster#If wsrep_node_name is not specified,  then system hostname will be used#当前节点名称wsrep_node_name=pxc-cluster-node-1#pxc_strict_mode allowed values: DISABLED,PERMISSIVE,ENFORCING,MASTER#不使用实验功能pxc_strict_mode=ENFORCING# SST method#状态快照传输（sst）方法，官方建议wsrep_sst_method=xtrabackup-v2#Authentication for SST method#用户凭证（mysql的用户名和密码）wsrep_sst_auth=&quot;用户名:密码&quot;</code></pre><p>剩下的节点修改当前节点名、当前节点IP、集群中的节点IP，其他相同</p><blockquote><p>注：1—10步骤  每个节点都要配置一次</p></blockquote><h5 id="11、初始化集群节点"><a href="#11、初始化集群节点" class="headerlink" title="11、初始化集群节点"></a>11、初始化集群节点</h5><p>其中一个节点使用 systemctl start <a href="mailto:mysql@bootstrap.service" target="_blank" rel="noopener">mysql@bootstrap.service</a> 启动</p><h6 id="登录mysql"><a href="#登录mysql" class="headerlink" title="登录mysql"></a>登录mysql</h6><pre><code>mysql -u root -p</code></pre><p>开启 wsrep_causal_reads</p><pre><code>set wsrep_causal_reads =1;</code></pre><h5 id="12、创建配置文件中对应的用户"><a href="#12、创建配置文件中对应的用户" class="headerlink" title="12、创建配置文件中对应的用户"></a>12、创建配置文件中对应的用户</h5><blockquote><p>所有节点的IP都要创建</p></blockquote><p>创建用户：    </p><pre><code>CREATE USER &apos;用户名&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;密码&apos;;  </code></pre><p>刷新权限：   </p><pre><code>GRANT all privileges ON *.* TO &apos;用户名&apos;@&apos;localhost&apos; ;FLUSH PRIVILEGES;</code></pre><p>创建用户：</p><pre><code>CREATE USER &apos;用户名&apos;@&apos;当前需要访问数据库的IP地址&apos; IDENTIFIED BY &apos;密码&apos;;  </code></pre><p>刷新权限：</p><pre><code>GRANT all privileges ON *.* TO &apos;用户名&apos;@&apos;当前节点IP地址&apos; ;FLUSH PRIVILEGES;</code></pre><h5 id="13、其他节点使用-service-mysql-start-启动-，登录mysql，配置wsrep-causal-reds，set-wsrep-causal-reads-1"><a href="#13、其他节点使用-service-mysql-start-启动-，登录mysql，配置wsrep-causal-reds，set-wsrep-causal-reads-1" class="headerlink" title="13、其他节点使用   service mysql start  启动 ，登录mysql，配置wsrep_causal_reds，set wsrep_causal_reads =1;"></a>13、其他节点使用   service mysql start  启动 ，登录mysql，配置wsrep_causal_reds，set wsrep_causal_reads =1;</h5><h5 id="14、其他节点启动成功后在引导节点（使用-systemctl-start-mysql-bootstrap-service-命令启动的节点）"><a href="#14、其他节点启动成功后在引导节点（使用-systemctl-start-mysql-bootstrap-service-命令启动的节点）" class="headerlink" title="14、其他节点启动成功后在引导节点（使用 systemctl start mysql@bootstrap.service 命令启动的节点）"></a>14、其他节点启动成功后在引导节点（使用 systemctl start <a href="mailto:mysql@bootstrap.service" target="_blank" rel="noopener">mysql@bootstrap.service</a> 命令启动的节点）</h5><p>验证集群：</p><pre><code>show status like &apos;wsrep%&apos;;  </code></pre><h5 id="15、节点数据同步验证"><a href="#15、节点数据同步验证" class="headerlink" title="15、节点数据同步验证"></a>15、节点数据同步验证</h5><p>在当前节点创建一个数据库 </p><pre><code>CREATE DATABASE percona;</code></pre><p>启动其他节点的数据库服务，进去后会发现新建的数据库，同理 其他节点创建的数据  当前节点也能看到</p><p>注意：服务的启动和停止要对应</p><pre><code>service mysql stop   ------&gt;  启动时用service mysql start</code></pre><p>或者 </p><pre><code>systemctl stop mysql@bootstrap.service   -----&gt;  启用是用 systemctl start mysql@bootstrap.service </code></pre><ul><li>更多相关实战配置可以参考这里：<a href="https://www.jianshu.com/p/0b7c050dfab6" target="_blank" rel="noopener">https://www.jianshu.com/p/0b7c050dfab6</a></li></ul><h5 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h5><ul><li>带你玩转Mysql高可用方案–PXC<ul><li><a href="https://blog.csdn.net/zisefeizhu/article/details/81873466" target="_blank" rel="noopener">https://blog.csdn.net/zisefeizhu/article/details/81873466</a></li></ul></li><li><p>Docker搭建PXC集群</p><ul><li><a href="https://blog.csdn.net/weixin_41141219/article/details/82767832" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41141219/article/details/82767832</a></li></ul></li><li><p>MySQL高可用方案－PXC环境部署记录: 详细教程</p><ul><li><a href="http://www.cnblogs.com/kevingrace/p/5685371.html" target="_blank" rel="noopener">http://www.cnblogs.com/kevingrace/p/5685371.html</a></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> MySQL </tag>
            
            <tag> PXC集群 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>架构篇——MySQL主从复制(Master-Slave)详解</title>
      <link href="/2019/06/09/%E6%9E%B6%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-Master-Slave-%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/06/09/%E6%9E%B6%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-Master-Slave-%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h3><p>Mysql主从又叫Replication、AB复制(不同于PXC)。简单讲就是A与B两台机器做主从后，在A上写数据，另外一台B也会跟着写数据，实现数据实时同步</p><blockquote><p>mysql主从是基于binlog，主上需开启binlog才能进行主从</p></blockquote><h5 id="主从过程大概有3个步骤"><a href="#主从过程大概有3个步骤" class="headerlink" title="主从过程大概有3个步骤"></a>主从过程大概有3个步骤</h5><ul><li>主将更改操作记录到binlog里</li><li>从将主的binlog事件（sql语句） 同步本机上并记录在relaylog里</li><li>从根据relaylog里面的sql语句按顺序执行</li></ul><a id="more"></a><h4 id="主从作用"><a href="#主从作用" class="headerlink" title="主从作用"></a>主从作用</h4><pre><code>实时灾备，用于故障切换读写分离，提供查询服务备份，避免影响业务</code></pre><h4 id="主从形式"><a href="#主从形式" class="headerlink" title="主从形式"></a>主从形式</h4><ul><li>一主一从</li><li>主主复制</li><li>一主多从—扩展系统读取的性能，因为读是在从库读取的</li><li>多主一从—5.7版本开始支持</li><li>联级复制</li></ul><p>MySQL数据库自身提供的主从复制功能可以方便的实现数据的多处自动备份，实现数据库的拓展。多个数据备份不仅可以加强数据的安全性，通过实现读写分离还能进一步提升数据库的负载性能。</p><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><blockquote><p>MySQL之间数据复制的基础是二进制日志文件（binary log file）。一台MySQL数据库一旦启用二进制日志后，其作为master，它的数据库中所有操作都会以“事件”的方式记录在二进制日志中，其他数据库作为slave通过一个I/O线程与主服务器保持通信，并监控master的二进制日志文件的变化，如果发现master二进制日志文件发生变化，则会把变化复制到自己的中继日志中，然后slave的一个SQL线程会把相关的“事件”执行到自己的数据库中，以此实现从数据库和主数据库的一致性，也就实现了主从复制。</p></blockquote><ul><li>主库将所有的写操作记录在binlog日志中，并生成log dump线程，将binlog日志传给从库的I/O线程</li><li>从库生成两个线程，一个是I/O线程，另一个是SQL线程</li><li>I/O线程去请求主库的binlog日志，并将binlog日志中的文件写入relay log（中继日志）中</li><li>SQL线程会读取relay loy中的内容，并解析成具体的操作，来实现主从的操作一致，达到最终数据一致的目的</li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>实现MySQL主从复制需要进行的配置：</p><ul><li><p>主服务器：</p><ul><li>开启二进制日志</li><li>配置唯一的server-id</li><li>获得master二进制日志文件名及位置</li><li>创建一个用于slave和master通信的用户账号</li></ul></li><li><p>从服务器：</p><ul><li>配置唯一的server-id</li><li>使用master分配的用户账号读取master二进制日志</li><li>启用slave服务</li></ul></li></ul><h4 id="具体实现过程如下："><a href="#具体实现过程如下：" class="headerlink" title="具体实现过程如下："></a>具体实现过程如下：</h4><p>主从复制配置步骤：</p><ul><li>确保从数据库与主数据库里的数据一致</li><li>在主数据库里创建一个同步账户授权给从数据库使用</li><li>配合主数据库（修改配置文件）</li><li>配置从数据库（修改配置文件）</li></ul><h5 id="一、准备工作："><a href="#一、准备工作：" class="headerlink" title="一、准备工作："></a>一、准备工作：</h5><ol><li>主从数据库版本最好一致</li><li>主从数据库内数据保持一致</li></ol><p>搭建两台MYSQL服务器，一台作为主服务器，一台作为从服务器，主服务器进行写操作，从服务器进行读操作</p><pre><code>+ 主数据库：192.168.0.1 /Linux-MySQL+ 从数据库：192.168.0.2 /Linux-MySQL</code></pre><h5 id="二、主数据库master修改："><a href="#二、主数据库master修改：" class="headerlink" title="二、主数据库master修改："></a>二、主数据库master修改：</h5><p>1.修改mysql配置</p><p>找到主数据库的配置文件my.cnf(或者my.ini)，我的在/etc/mysql/my.cnf,在[mysqld]部分插入如下两行：</p><pre><code>[mysqld]log-bin=mysql-bin #开启二进制日志server-id=1 #设置server-id</code></pre><p>2.重启mysql，创建用于同步的用户账号</p><p>打开mysql会话shell</p><pre><code>mysql -hlocalhost -uname -ppassword</code></pre><p>创建用户：用户：rel1密码：slavepass</p><p>3.授权</p><p>主服务器授权从服务器特定账号登录</p><pre><code>mysql&gt; CREATE USER &apos;repl&apos;@&apos;192.168.0.2&apos; IDENTIFIED BY &apos;slavepass&apos;;#创建用户mysql&gt; GRANT REPLICATION SLAVE ON *.* TO &apos;repl&apos;@&apos;192.168.0.2&apos;;#分配权限mysql&gt;flush privileges;   #刷新权限</code></pre><p>4.查看master状态，记录二进制文件名(mysql-bin.000003)和位置(73)：</p><pre><code>mysql &gt; SHOW MASTER STATUS;+------------------+----------+--------------+------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |+------------------+----------+--------------+------------------+| mysql-bin.000003 | 73       | test         | manual,mysql     |+------------------+----------+--------------+------------------+</code></pre><h5 id="三、从服务器slave修改："><a href="#三、从服务器slave修改：" class="headerlink" title="三、从服务器slave修改："></a>三、从服务器slave修改：</h5><p>1.修改mysql配置</p><p>同样找到my.cnf配置文件，添加server-id</p><pre><code>[mysqld]server-id=2 #设置server-id，必须唯一</code></pre><p>2.重启mysql，打开mysql会话，执行同步SQL语句(需要主服务器主机名，登陆凭据，二进制文件的名称和位置)：<br>复制代码</p><pre><code>mysql&gt; CHANGE MASTER TO    -&gt;     MASTER_HOST=&apos;192.168.0.1&apos;,    -&gt;     MASTER_USER=&apos;rep1&apos;,    -&gt;     MASTER_PASSWORD=&apos;slavepass&apos;,    -&gt;     MASTER_LOG_FILE=&apos;mysql-bin.000003&apos;,    -&gt;     MASTER_LOG_POS=73;</code></pre><p>3.启动slave同步进程：</p><pre><code>mysql&gt;start slave;</code></pre><p>4.查看slave状态：</p><pre><code>mysql&gt; show slave status\G;*************************** 1. row ***************************               Slave_IO_State: Waiting for master to send event                  Master_Host: 192.168.0.1                  Master_User: rep1                  Master_Port: 3306                Connect_Retry: 60              Master_Log_File: mysql-bin.000013          Read_Master_Log_Pos: 11662               Relay_Log_File: mysqld-relay-bin.000022                Relay_Log_Pos: 11765        Relay_Master_Log_File: mysql-bin.000013             Slave_IO_Running: Yes            Slave_SQL_Running: Yes              Replicate_Do_DB:           Replicate_Ignore_DB:         ...</code></pre><p>当Slave_IO_Running和Slave_SQL_Running都为YES的时候就表示主从同步设置成功了。</p><p>接下来就可以进行一些验证了，比如在主master数据库的test数据库的一张表中插入一条数据，在slave的test库的相同数据表中查看是否有新增的数据即可验证主从复制功能是否有效，还可以关闭slave（mysql&gt;stop slave;）,然后再修改master，看slave是否也相应修改（停止slave后，master的修改不会同步到slave），就可以完成主从复制功能的验证了。</p><p>还可以用到的其他相关参数：</p><blockquote><p>master开启二进制日志后默认记录所有库所有表的操作，可以通过配置来指定只记录指定的数据库甚至指定的表的操作，具体在mysql配置文件的[mysqld]可添加修改如下选项：</p></blockquote><pre><code># 不同步哪些数据库  binlog-ignore-db = mysql  binlog-ignore-db = test  binlog-ignore-db = information_schema  # 只同步哪些数据库，除此之外，其他不同步  binlog-do-db = game  </code></pre><blockquote><p>如之前查看master状态时就可以看到只记录了test库，忽略了manual和mysql库。</p></blockquote><h3 id="操作流程汇总"><a href="#操作流程汇总" class="headerlink" title="操作流程汇总"></a>操作流程汇总</h3><h5 id="关闭防火墙以SELINUX"><a href="#关闭防火墙以SELINUX" class="headerlink" title="关闭防火墙以SELINUX"></a>关闭防火墙以SELINUX</h5><pre><code>[root@icocos ~]# systemctl stop firewalld[root@icocos ~]# systemctl disable firewalld[root@icocos ~]#  sed -ri &apos;s/(SELINUX=).*/\1disabled/g&apos; /etc/selinux/config[root@icocos ~]# setenforce 0</code></pre><h5 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h5><pre><code>安装依赖包[root@icocos ~]# yum -y install ncurses-devel openssl-devel openssl cmake mariadb-devel</code></pre><h5 id="创建用户和组"><a href="#创建用户和组" class="headerlink" title="创建用户和组"></a>创建用户和组</h5><pre><code>[root@icocos ~]# groupadd -r -g 306 mysql[root@icocos ~]# useradd -M -s /sbin/nologin -g 306 -u 306 mysql</code></pre><h5 id="下载二进制格式的mysql软件包"><a href="#下载二进制格式的mysql软件包" class="headerlink" title="下载二进制格式的mysql软件包"></a>下载二进制格式的mysql软件包</h5><pre><code>[root@icocos ~]# cd /usr/src/[root@icocos src]#wget https://downloads.mysql.com/archives/get/file/mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz</code></pre><h5 id="解压软件至-usr-local"><a href="#解压软件至-usr-local" class="headerlink" title="解压软件至/usr/local/"></a>解压软件至/usr/local/</h5><pre><code>[root@icocos src]# lsdebug  kernels  mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz[root@icocos src]# tar xf mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz -C /usr/local/[root@icocos src]#  ls  /usr/local/bin  etc  games  include  lib  lib64  libexec  mysql-5.7.22-linux-glibc2.12-x86_64  sbin  share  src[root@icocos src]#  cd  /usr/local/[root@icocos local]# ln -sv mysql-5.7.22-linux-glibc2.12-x86_64/ mysql&quot;mysql&quot; -&gt; &quot;mysql-5.7.22-linux-glibc2.12-x86_64/&quot;[root@icocos local]# ll总用量 0drwxr-xr-x. 2 root root   6 11月  5 2016 bindrwxr-xr-x. 2 root root   6 11月  5 2016 etcdrwxr-xr-x. 2 root root   6 11月  5 2016 gamesdrwxr-xr-x. 2 root root   6 11月  5 2016 includedrwxr-xr-x. 2 root root   6 11月  5 2016 libdrwxr-xr-x. 2 root root   6 11月  5 2016 lib64drwxr-xr-x. 2 root root   6 11月  5 2016 libexeclrwxrwxrwx. 1 root root  36 9月   7 22:20 mysql -&gt; mysql-5.7.22-linux-glibc2.12-x86_64/drwxr-xr-x. 9 root root 129 9月   7 22:19 mysql-5.7.22-linux-glibc2.12-x86_64drwxr-xr-x. 2 root root   6 11月  5 2016 sbindrwxr-xr-x. 5 root root  49 9月   3 23:02 sharedrwxr-xr-x. 2 root root   6 11月  5 2016 src</code></pre><h5 id="修改目录-usr-locaal-mysql的属主属组"><a href="#修改目录-usr-locaal-mysql的属主属组" class="headerlink" title="修改目录/usr/locaal/mysql的属主属组"></a>修改目录/usr/locaal/mysql的属主属组</h5><pre><code>[root@icocos local]# chown -R mysql.mysql /usr/local/mysql[root@icocos local]#  ll /usr/local/mysql -dlrwxrwxrwx. 1 mysql mysql 36 9月   7 22:20 /usr/local/mysql -&gt; mysql-5.7.22-linux-glibc2.12-x86_64/</code></pre><h5 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h5><pre><code>[root@icocos local]# ls /usr/local/mysqlbin  COPYING  docs  include  lib  man  README  share  support-files[root@icocos local]# cd[root@icocos ~]# echo &apos;export PATH=/usr/local/mysql/bin:$PATH&apos; &gt; /etc/profile.d/mysql.sh[root@icocos ~]# . /etc/profile.d/mysql.sh[root@icocos ~]# echo $PATH/usr/local/mysql/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</code></pre><h5 id="建立数据存放目录"><a href="#建立数据存放目录" class="headerlink" title="建立数据存放目录"></a>建立数据存放目录</h5><pre><code>[root@icocos ~]# cd /usr/local/mysql[root@icocos mysql]# mkdir /opt/data[root@icocos mysql]#  chown -R mysql.mysql /opt/data/[root@icocos mysql]#  ll /opt/总用量 0drwxr-xr-x. 2 mysql mysql 6 9月   7 22:25 data</code></pre><h5 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h5><pre><code>[root@icocos mysql]# /usr/local/mysql/bin/mysqld --initialize --user=mysql --datadir=/opt/data///这个命令的最后会生成一个临时密码，此处密码是1EbNA-k*BtKo</code></pre><h5 id="配置mysql"><a href="#配置mysql" class="headerlink" title="配置mysql"></a>配置mysql</h5><pre><code>[root@icocos ~]# ln -sv /usr/local/mysql/include/ /usr/local/include/mysql&quot;/usr/local/include/mysql&quot; -&gt; &quot;/usr/local/mysql/include/&quot;[root@icocos ~]# echo &apos;/usr/local/mysql/lib&apos; &gt; /etc/ld.so.conf.d/mysql.conf[root@icocos ~]#  ldconfig -v</code></pre><h5 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h5><pre><code>[root@icocos ~]# cat &gt; /etc/my.cnf &lt;&lt;EOF&gt; [mysqld]&gt; basedir = /usr/local/mysql&gt; datadir = /opt/data&gt; socket = /tmp/mysql.sock&gt; port = 3306&gt; pid-file = /opt/data/mysql.pid&gt; user = mysql&gt; skip-name-resolve&gt; EOF</code></pre><h5 id="配置服务启动脚本"><a href="#配置服务启动脚本" class="headerlink" title="配置服务启动脚本"></a>配置服务启动脚本</h5><pre><code>[root@icocos ~]# cp -a /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld[root@icocos ~]#  sed -ri &apos;s#^(basedir=).*#\1/usr/local/mysql#g&apos; /etc/init.d/mysqld[root@icocos ~]# sed -ri &apos;s#^(datadir=).*#\1/opt/data#g&apos; /etc/init.d/mysqld</code></pre><h5 id="启动mysql"><a href="#启动mysql" class="headerlink" title="启动mysql"></a>启动mysql</h5><pre><code>[root@icocos ~]#  service mysqld startStarting MySQL.Logging to &apos;/opt/data/icocos.err&apos;... SUCCESS![root@icocos ~]#  ps -ef|grep mysqlroot       4897      1  0 22:38 pts/2    00:00:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/opt/data --pid-file=/opt/data/mysql.pidmysql      5075   4897  6 22:38 pts/2    00:00:01 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/opt/data --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=icocos.err --pid-file=/opt/data/mysql.pid --socket=/tmp/mysql.sock --port=3306root       5109   4668  0 22:38 pts/2    00:00:00 grep --color=auto mysql[root@icocos ~]# ss -antlState       Recv-Q Send-Q                     Local Address:Port                                    Peer Address:Port              LISTEN      0      128                                    *:22                                                 *:*                  LISTEN      0      100                            127.0.0.1:25                                                 *:*                  LISTEN      0      128                                   :::22                                                :::*                  LISTEN      0      100                                  ::1:25                                                :::*                  LISTEN      0      80                                    :::3306                                              :::*                  </code></pre><h5 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h5><p>使用临时密码修改</p><pre><code>[root@icocos ~]# mysql -uroot -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.7.22Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; set password = password(&apos;123456&apos;);Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; quitBye</code></pre><h5 id="mysql主从配置"><a href="#mysql主从配置" class="headerlink" title="mysql主从配置"></a>mysql主从配置</h5><p>确保从数据库与主数据库的数据一样先在主数据库创建所需要同步的库和表</p><pre><code>[root@icocos ~]# mysql -uroot -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 4Server version: 5.7.22 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. AlOracle is a registered trademark of Oracle Corporation andaffiliates. Other names may be trademarks of their respectowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the currmysql&gt; create database yan;Query OK, 1 row affected (0.00 sec)mysql&gt; create database lisi;Query OK, 1 row affected (0.00 sec)mysql&gt; create database wangwu;Query OK, 1 row affected (0.00 sec)mysql&gt; use yan;Database changedmysql&gt; create table tom (id int not null,name varchar(100)not null ,age tinyint);Query OK, 0 rows affected (11.83 sec)mysql&gt; insert tom (id,name,age) values(1,&apos;zhangshan&apos;,20),(2,&apos;wangwu&apos;,7),(3,&apos;lisi&apos;,23);Query OK, 3 rows affected (0.07 sec)Records: 3  Duplicates: 0  Warnings: 0mysql&gt; select * from tom;+----+-----------+------+| id | name      | age  |+----+-----------+------+|  1 | zhangshan |   20 ||  2 | wangwu    |    7 ||  3 | lisi      |   23 |+----+-----------+------+3 rows in set (0.00 sec)</code></pre><h5 id="备份主库"><a href="#备份主库" class="headerlink" title="备份主库"></a>备份主库</h5><p>备份主库时需要另开一个终端，给数据库上读锁，避免在备份期间有其他人在写入导致数据同步的不一致</p><pre><code>[root@icocos ~]# mysql -uroot -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 5Server version: 5.7.22 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; flush tables with read lock;Query OK, 0 rows affected (0.76 sec)</code></pre><p>此锁表的终端必须在备份完成以后才能退出（退出锁表失效）</p><h5 id="备份主库并将备份文件传送到从库"><a href="#备份主库并将备份文件传送到从库" class="headerlink" title="备份主库并将备份文件传送到从库"></a>备份主库并将备份文件传送到从库</h5><pre><code>[root@icocos ~]# mysqldump -uroot -p123456 --all-databases &gt; /opt/all-20180907.sqlmysqldump: [Warning] Using a password on the command line interface can be insecure.[root@icocos ~]# ls /opt/all-20180907.sql  data[root@icocos ~]# scp /opt/all-20180907.sql root@192.168.0.2:/opt/The authenticity of host &apos;192.168.0.2 (192.168.0.2)&apos; can&apos;t be established.ECDSA key fingerprint is SHA256:7mLj77SFk7sPkhjpMPfdK3nZ98hOuyP4OKzjXeijSJ0.ECDSA key fingerprint is MD5:a0:1b:eb:7f:f0:b6:7b:73:97:91:4c:f3:b1:89:d8:ea.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;192.168.0.2&apos; (ECDSA) to the list of known hosts.root@192.168.0.2&apos;s password:all-20180907.sql       100%  784KB 783.3KB/s   00:01    </code></pre><h5 id="解除主库的锁表状态，直接退出交互式界面即可"><a href="#解除主库的锁表状态，直接退出交互式界面即可" class="headerlink" title="解除主库的锁表状态，直接退出交互式界面即可"></a>解除主库的锁表状态，直接退出交互式界面即可</h5><pre><code>mysql&gt; quitBye</code></pre><h5 id="在从库上恢复主库的备份并查看是否与主库的数据保持一致"><a href="#在从库上恢复主库的备份并查看是否与主库的数据保持一致" class="headerlink" title="在从库上恢复主库的备份并查看是否与主库的数据保持一致"></a>在从库上恢复主库的备份并查看是否与主库的数据保持一致</h5><pre><code>[root@icocos ~]# mysql -uroot -p123456 &lt; /opt/all-20180907.sqlmysql: [Warning] Using a password on the command line interface can be insecure.[root@icocos ~]# mysql -uroot -p123456mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 4Server version: 5.7.22 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || lisi               || mysql              || performance_schema || sys                || wangwu             || yan                |+--------------------+7 rows in set (0.18 sec)mysql&gt; use yan;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; select * from tom;+----+-----------+------+| id | name      | age  |+----+-----------+------+|  1 | zhangshan |   20 ||  2 | wangwu    |    7 ||  3 | lisi      |   23 |+----+-----------+------+3 rows in set (0.06 sec)</code></pre><h5 id="在主数据库创建一个同步账户授权给从数据使用"><a href="#在主数据库创建一个同步账户授权给从数据使用" class="headerlink" title="在主数据库创建一个同步账户授权给从数据使用"></a>在主数据库创建一个同步账户授权给从数据使用</h5><pre><code>[root@icocos ~]# mysql -uroot -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 7Server version: 5.7.22 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; create user &apos;repl&apos;@&apos;192.168.0.2&apos; identified by &apos;123456&apos;;Query OK, 0 rows affected (5.50 sec)mysql&gt; grant replication slave on *.* to &apos;repl&apos;@&apos;192.168.0.2&apos;;Query OK, 0 rows affected (0.04 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.09 sec)</code></pre><h5 id="配置主数据库编辑配置文件"><a href="#配置主数据库编辑配置文件" class="headerlink" title="配置主数据库编辑配置文件"></a>配置主数据库编辑配置文件</h5><pre><code>[root@icocos ~]# vim /etc/my.cnf[root@icocos ~]# cat /etc/my.cnf[mysqld]basedir = /usr/local/mysqldatadir = /opt/datasocket = /tmp/mysql.sockport = 3306pid-file = /opt/data/mysql.piduser = mysqlskip-name-resolve//添加以下内容log-bin=mysql-bin //启用binlog日志server-id=1 //主数据库服务器唯一标识符 主的必须必从大log-error=/opt/data/mysql.log</code></pre><h5 id="重启mysql服务"><a href="#重启mysql服务" class="headerlink" title="重启mysql服务"></a>重启mysql服务</h5><pre><code>[root@icocos ~]# service mysqld restartShutting down MySQL..... SUCCESS!Starting MySQL.Logging to &apos;/opt/data/mysql.log&apos;................................ SUCCESS![root@icocos ~]# ss -antlState       Recv-Q Send-Q Local Address:Port               Peer Address:Port              LISTEN      0      128     *:22                  *:*                  LISTEN      0      100    127.0.0.1:25                  *:*                  LISTEN      0      128    :::22                 :::*                  LISTEN      0      100       ::1:25                 :::*                  LISTEN      0      80     :::3306               :::*</code></pre><h5 id="查看主库的状态"><a href="#查看主库的状态" class="headerlink" title="查看主库的状态"></a>查看主库的状态</h5><pre><code>mysql&gt; show master status;+------------------+----------+--------------+------------------+-------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+------------------+----------+--------------+------------------+-------------------+| mysql-bin.000001 |      154 |              |                  |                   |+------------------+----------+--------------+------------------+-------------------+1 row in set (0.00 sec)</code></pre><h5 id="配置从数据库"><a href="#配置从数据库" class="headerlink" title="配置从数据库"></a>配置从数据库</h5><p>编辑配置文件</p><pre><code>[root@icocos ~]# cat /etc/my.cnf[mysqld]basedir = /usr/local/mysqldatadir = /opt/datasocket = /tmp/mysql.sockport = 3306pid-file = /opt/data/mysql.piduser = mysqlskip-name-resolve//添加以下内容：server-id=2 //设置从库的唯一标识符 从的必须比主小relay-log=mysql-relay-bin //启用中继日志relay logerror-log=/opt/data/mysql.log</code></pre><h5 id="重启从库的mysql服务"><a href="#重启从库的mysql服务" class="headerlink" title="重启从库的mysql服务"></a>重启从库的mysql服务</h5><pre><code>[root@icocos ~]# service mysqld restartShutting down MySQL.. SUCCESS!Starting MySQL.. SUCCESS![root@icocos ~]# ss -antlState       Recv-Q Send-Q Local Address:Port               Peer Address:Port              LISTEN      0      128     *:22                  *:*                  LISTEN      0      100    127.0.0.1:25                  *:*                  LISTEN      0      128    :::22                 :::*                  LISTEN      0      100       ::1:25                 :::*                  LISTEN      0      80     :::3306               :::*                  </code></pre><h5 id="配置并启动主从复制"><a href="#配置并启动主从复制" class="headerlink" title="配置并启动主从复制"></a>配置并启动主从复制</h5><pre><code>mysql&gt; change master to    -&gt; master_host=&apos;192.168.0.1&apos;,    -&gt; master_user=&apos;repl&apos;,    -&gt; master_password=&apos;123456&apos;,    -&gt; master_log_file=&apos;mysql-bin.000001&apos;,    -&gt; master_log_pos=154;Query OK, 0 rows affected, 2 warnings (0.28 sec)</code></pre><h5 id="查看从服务器状态"><a href="#查看从服务器状态" class="headerlink" title="查看从服务器状态"></a>查看从服务器状态</h5><pre><code>mysql&gt; show slave status\G;*************************** 1. row ***************************               Slave_IO_State: Waiting for master to send event                  Master_Host: 192.168.0.1                  Master_User: repl                  Master_Port: 3306                Connect_Retry: 60              Master_Log_File: mysql-bin.000001          Read_Master_Log_Pos: 154               Relay_Log_File: mysql-relay-bin.000003                Relay_Log_Pos: 320        Relay_Master_Log_File: mysql-bin.000001             Slave_IO_Running: Yes                                     //此处必须是yes            Slave_SQL_Running: Yes                                    //此处必须是yes                     Replicate_Do_DB:          Replicate_Ignore_DB:           Replicate_Do_Table:       Replicate_Ignore_Table:      Replicate_Wild_Do_Table:  Replicate_Wild_Ignore_Table:                   Last_Errno: 0                   Last_Error:                 Skip_Counter: 0          Exec_Master_Log_Pos: 154              Relay_Log_Space: 527              Until_Condition: None               Until_Log_File:                Until_Log_Pos: 0           Master_SSL_Allowed: No           Master_SSL_CA_File:           Master_SSL_CA_Path:              Master_SSL_Cert:            Master_SSL_Cipher:               Master_SSL_Key:        Seconds_Behind_Master: 0Master_SSL_Verify_Server_Cert: No                Last_IO_Errno: 0                Last_IO_Error:               Last_SQL_Errno: 0               Last_SQL_Error:  Replicate_Ignore_Server_Ids:             Master_Server_Id: 1                  Master_UUID: 5abf1791-b2af-11e8-b6ad-000c2980fbb4             Master_Info_File: /opt/data/master.info                    SQL_Delay: 0          SQL_Remaining_Delay: NULL      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates           Master_Retry_Count: 86400                  Master_Bind:      Last_IO_Error_Timestamp:     Last_SQL_Error_Timestamp:               Master_SSL_Crl:           Master_SSL_Crlpath:           Retrieved_Gtid_Set:            Executed_Gtid_Set:                Auto_Position: 0         Replicate_Rewrite_DB:                 Channel_Name:           Master_TLS_Version:1 row in set (0.00 sec)ERROR:No query specified</code></pre><h5 id="测试验证在主服务器的yan库的tom表插入数据"><a href="#测试验证在主服务器的yan库的tom表插入数据" class="headerlink" title="测试验证在主服务器的yan库的tom表插入数据:"></a>测试验证在主服务器的yan库的tom表插入数据:</h5><pre><code>mysql&gt; use yan;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; select * from tom;+----+-----------+------+| id | name      | age  |+----+-----------+------+|  1 | zhangshan |   20 ||  2 | wangwu    |    7 ||  3 | lisi      |   23 |+----+-----------+------+3 rows in set (0.09 sec)mysql&gt; insert tom(id,name,age) value (4,&quot;yyl&quot;,18);Query OK, 1 row affected (0.14 sec)mysql&gt; select * from tom;+----+-----------+------+| id | name      | age  |+----+-----------+------+|  1 | zhangshan |   20 ||  2 | wangwu    |    7 ||  3 | lisi      |   23 ||  4 | yyl       |   18 |+----+-----------+------+4 rows in set (0.00 sec)</code></pre><h5 id="在从数据库查看是否数据同步"><a href="#在从数据库查看是否数据同步" class="headerlink" title="在从数据库查看是否数据同步"></a>在从数据库查看是否数据同步</h5><pre><code>mysql&gt; use yan;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; select * from tom;+----+-----------+------+| id | name      | age  |+----+-----------+------+|  1 | zhangshan |   20 ||  2 | wangwu    |    7 ||  3 | lisi      |   23 ||  4 | yyl       |   18 |+----+-----------+------+4 rows in set (0.00 sec)</code></pre>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> MySQL </tag>
            
            <tag> 主从复制 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL锁机制和PHP锁机制</title>
      <link href="/2019/06/06/MySQL%E9%94%81%E6%9C%BA%E5%88%B6%E5%92%8CPHP%E9%94%81%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/06/06/MySQL%E9%94%81%E6%9C%BA%E5%88%B6%E5%92%8CPHP%E9%94%81%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h3 id="PHP中的文件锁-（锁的是文件，不是表）"><a href="#PHP中的文件锁-（锁的是文件，不是表）" class="headerlink" title="PHP中的文件锁 （锁的是文件，不是表）"></a>PHP中的文件锁 （锁的是文件，不是表）</h3><p>文件锁的文件与表有什么关系？：一点关系也没有，与令牌相似，谁拿到谁操作。所以表根本没锁。<br>测试时，有个文件就行，叫什么名无所谓</p><p>bool flock ( int handle, int operation [, int &amp;wouldblock] );<br>flock() 操作的 handle 必须是一个已经打开的文件指针。operation 可以是以下值之一：</p><ul><li>要取得共享锁定（读取程序），将 operation 设为 LOCK_SH（PHP 4.0.1 以前的版本设置为 1）</li><li>要取得独占锁定（写入程序），将 operation 设为 LOCK_EX（PHP 4.0.1 以前的版本中设置为 2）</li><li>要释放锁定（无论共享或独占），将 operation 设为 LOCK_UN（PHP 4.0.1 以前的版本中设置为 3）</li><li>如果你不希望 flock() 在锁定时堵塞，则给 operation 加上 LOCK_NB（PHP 4.0.1 以前的版本中设置为4）</li></ul><a id="more"></a><h4 id="建两个文件"><a href="#建两个文件" class="headerlink" title="建两个文件"></a>建两个文件</h4><!--more--><h5 id="1-a-php"><a href="#1-a-php" class="headerlink" title="(1) a.php"></a>(1) a.php</h5><pre><code>$file = &quot;temp.txt&quot;;   $fp = fopen($file , &apos;w&apos;);   if(flock($fp , LOCK_EX)){        fwrite($fp , &quot;abc\n&quot;);        sleep(10);        fwrite($fp , &quot;123\n&quot;);       flock($fp , LOCK_UN);   }   fclose($fp);  </code></pre><h5 id="2-b-php"><a href="#2-b-php" class="headerlink" title="(2) b.php"></a>(2) b.php</h5><pre><code>$file = &quot;temp.txt&quot;;   $fp = fopen($file , &apos;r&apos;);   echo fread($fp , 100);   fclose($fp);  </code></pre><p>运行 a.php 后，马上运行 b.php ，可以看到输出：</p><pre><code>abc</code></pre><p>等 a.php 运行完后运行 b.php ，可以看到输出：</p><pre><code>abc123</code></pre><p>显然，当 a.php 写文件时数据太大，导致时间比较长时，这时 b.php 读取数据不完整</p><p>修改 b.php 为：</p><pre><code>$file = &quot;temp.txt&quot;;   $fp = fopen($file , &apos;r&apos;);   if(flock($fp , LOCK_EX)){       echo fread($fp , 100);       flock($fp , LOCK_UN);   } else{       echo &quot;Lock file failed...\n&quot;;   }   fclose($fp);  </code></pre><p>运行 a.php 后，马上运行 b.php ，可以发现 b.php 会等到 a.php 运行完成后(即 10 秒后)才显示：</p><pre><code>abc123</code></pre><p>读取数据完整，但时间过长，他要等待写锁释放。</p><p>修改 b.php 为：</p><pre><code>$file = &quot;temp.txt&quot;;   $fp = fopen($file , &apos;r&apos;);   if(flock($fp , LOCK_SH | LOCK_NB)){       echo fread($fp , 100);       flock($fp , LOCK_UN);   } else{       echo &quot;Lock file failed...\n&quot;;   }   fclose($fp);  </code></pre><p>运行 a.php 后，马上运行 b.php ，可以看到输出：<br>    Lock file failed…</p><p>证明可以返回锁文件失败状态，而不是向上面一样要等很久。</p><h5 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h5><blockquote><p>建议作文件缓存时，选好相关的锁，不然可能导致读取数据不完整，或重复写入数据。<br>file_get_contents 好像选择不了锁，不知道他默认用的什么锁，反正和不锁得到的输出一样，是不完整的数据。</p></blockquote><p>我是要做文件缓存，所以只需要知道是否有写锁存在即可，有的话就查数据库就可以了。<br>测试环境：Linux(Ubuntu 6) , PHP 5.1.2 , Apache 2</p><h5 id="再转："><a href="#再转：" class="headerlink" title="再转："></a>再转：</h5><p>文件锁有两种：共享锁和排他锁，也就是读锁(LOCK_SH)和写锁(LOCK_EX)<br>文件的锁一般这么使用：</p><pre><code>$fp = fopen(&quot;filename&quot;, &quot;a&quot;);   flock($fp, LOCK_SH) or die(&quot;lock error&quot;)   $str = fread($fp, 1024);   flock($fp, LOCK_UN);   fclose($fp);  </code></pre><blockquote><p>注意fwrite之后，文件立即就被更新了，而不是等fwrite然后fclose之后文件才会更新，这个可以通过在fwrite之后fclose之前读取这个文件进行检查 </p></blockquote><p>但是什么时候使用lock_ex什么时候使用lock_sh呢？ </p><h5 id="读的时候："><a href="#读的时候：" class="headerlink" title="读的时候："></a>读的时候：</h5><p>如果不想出现dirty数据，那么最好使用lock_sh共享锁。可以考虑以下三种情况： </p><ol><li>如果读的时候没有加共享锁，那么其他程序要写的话（不管这个写是加锁还是不加锁）都会立即写成功。如果正好读了一半，然后被其他程序给写了，那么读的后一半就有可能跟前一半对不上（前一半是修改前的，后一半是修改后的） </li><li>如果读的时候加上了共享锁（因为只是读，没有必要使用排他锁），这个时候，其他程序开始写，这个写程序没有使用锁，那么写程序会直接修改这个文件，也会导致前面一样的问题 </li><li>最理想的情况是，读的时候加锁(lock_sh),写的时候也进行加锁(lock_ex),这样写程序会等着读程序完成之后才进行操作，而不会出现贸然操作的情况 </li></ol><h5 id="写的时候："><a href="#写的时候：" class="headerlink" title="写的时候："></a>写的时候：</h5><p>如果多个写程序不加锁同时对文件进行操作，那么最后的数据有可能一部分是a程序写的，一部分是b程序写的<br>如果写的时候加锁了，这个时候有其他的程序来读，那么他会读到什么东西呢？ </p><ol><li>如果读程序没有申请共享锁，那么他会读到dirty的数据。比如写程序要写a,b,c三部分，写完a,这时候读读到的是a，继续写b，这时候读读到的是ab，然后写c，这时候读到的是abc. </li><li>如果读程序在之前申请了共享锁，那么读程序会等写程序将abc写完并释放锁之后才进行读。</li></ol><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>项目中应该只使用PHP中的文件锁，尽量避免锁表，因为如果表被锁定了，那么整个网站中所有和这个表相关的功能都被拖慢了（例如：前台很多用户一直下订单，商品表mysql锁表，其他与商品表相关的操作一直处于阻塞状态【读不出来商品表】，因为一个功能把整个网站速度拖慢）。</p><blockquote><p> 比如在一个O2O外卖项目中，中午12-2点，晚上6点都是订单高并发时，这种情况下，MySQL锁显然是不考虑的，用户体验太差。其实根据实际的需求，外卖可以不用设计库存量的，当然除了秒杀活动模块还是需要php文件锁的。</p></blockquote><p>应用场景：</p><ol><li>高并发下单时，减库存量时要加锁</li><li>高并发抢单、抢票时要使用</li></ol><p>MySQL锁示例代码：</p><pre><code>&lt;?php /**模拟秒杀活动-- 商品100件CREATE TABLE a(    id int comment &apos;模拟100件活动商品的数量&apos;);INSERT INTO a VALUES(100);模仿：以10的并发量访问这个脚本！    使用apache自带的ab.exe软件 */ error_reporting(0); mysql_connect(&apos;localhost&apos;,&apos;root&apos;,&apos;admin123&apos;); mysql_select_db(&apos;test&apos;); # mysql 锁 mysql_query(&apos;LOCK TABLE a WRITE&apos;);// 只有一个客户端可以锁定表，其他客户端阻塞在这 $rs = mysql_query(&apos;SELECT id FROM a&apos;); $id = mysql_result($rs, 0, 0); if($id &gt; 0) {     --$id;     mysql_query(&apos;UPDATE a SET id=&apos;.$id); } # mysql 解锁 mysql_query(&apos;UNLOCK TABLES&apos;);</code></pre><p>PHP文件锁示例代码：</p><pre><code>&lt;?php /**模拟秒杀活动-- 商品100件CREATE TABLE a(    id int comment &apos;模拟100件活动商品的数量&apos;);INSERT INTO a VALUES(100);模仿：以10的并发量访问这个脚本！    使用apache自带的ab.exe软件 */ error_reporting(0); mysql_connect(&apos;localhost&apos;,&apos;root&apos;,&apos;admin123&apos;); mysql_select_db(&apos;test&apos;); # php中的文件锁 $fp = fopen(&apos;./a.lock&apos;, &apos;r&apos;); // php的文件锁和表没关系，随便一个文件即可 flock($fp, LOCK_EX);// 排他锁 $rs = mysql_query(&apos;SELECT id FROM a&apos;); $id = mysql_result($rs, 0, 0); if($id &gt; 0) {     --$id;     mysql_query(&apos;UPDATE a SET id=&apos;.$id); } # php的文件锁，释放锁 flock($fp, LOCK_UN); fclose($fp);</code></pre><h3 id="MYSQL中的锁："><a href="#MYSQL中的锁：" class="headerlink" title="MYSQL中的锁："></a>MYSQL中的锁：</h3><p>语法 ：<br>LOCK TABLE 表名1 READ|WRITE, 表名2 READ|WRITE ……………… 【锁表】<br>UNLOCK TABLES  【释放表】</p><ul><li>Read:读锁|共享锁 ： 所有的客户端只能读这个表不能写这个表</li><li>Write:写锁|排它锁： 所有当前锁定客户端可以操作这个表，其他客户端只能阻塞</li></ul><blockquote><p>注意：在锁表的过程中只能操作被锁定的表，如果要操作其他表，必须把所有要操作的表都锁定起来！</p></blockquote><h5 id="1-表级锁定（table-level）"><a href="#1-表级锁定（table-level）" class="headerlink" title="1.表级锁定（table-level）"></a>1.表级锁定（table-level）</h5><p>表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并大度大打折扣。使用表级锁定的主要是MyISAM等一些非事务性存储引擎。</p><h5 id="2-行级锁定（row-level）"><a href="#2-行级锁定（row-level）" class="headerlink" title="2.行级锁定（row-level）"></a>2.行级锁定（row-level）</h5><p>行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。<br>虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。使用行级锁定的主要是InnoDB存储引擎。</p><h5 id="3-页级锁定（page-level）"><a href="#3-页级锁定（page-level）" class="headerlink" title="3.页级锁定（page-level）"></a>3.页级锁定（page-level）</h5><p>页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。<br>在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。</p><h5 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h5><ul><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；  </li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；    </li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。  </li></ul><p>适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</p><h3 id="二、表级锁定"><a href="#二、表级锁定" class="headerlink" title="二、表级锁定"></a>二、表级锁定</h3><p>在mysql中，MyISAM引擎使用的锁定机制完全是mysql的表级锁定，下面将以MYISAM引擎作为示例</p><h5 id="1-MySQL表级锁的模式"><a href="#1-MySQL表级锁的模式" class="headerlink" title="1.MySQL表级锁的模式"></a>1.MySQL表级锁的模式</h5><blockquote><p>MySQL的表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。  </p></blockquote><ul><li>兼容性：  <ul><li>对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；  </li><li>对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；  </li><li>MyISAM表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。</li></ul></li></ul><h5 id="2-加锁"><a href="#2-加锁" class="headerlink" title="2.加锁"></a>2.加锁</h5><blockquote><p>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。</p></blockquote><h5 id="3-MyISAM锁的优化"><a href="#3-MyISAM锁的优化" class="headerlink" title="3.MyISAM锁的优化"></a>3.MyISAM锁的优化</h5><blockquote><p>对于MyISAM存储引擎，虽然使用表级锁定在锁定实现的过程中比实现行级锁定或者页级锁所带来的附加成本都要小，锁定本身所消耗的资源也是最少。但是由于锁定的颗粒度比较到，所以造成锁定资源的争用情况也会比其他的锁定级别都要多，从而在较大程度上会降低并发处理能力。所以，在优化MyISAM存储引擎锁定问题的时候，最关键的就是如何让其提高并发度。由于锁定级别是不可能改变的了，所以我们首先需要尽可能让锁定的时间变短，然后就是让可能并发进行的操作尽可能的并发。</p></blockquote><ul><li>（1）查询表锁争用情况</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like &apos;table%&apos;;</span><br><span class="line">+----------------------------+---------+</span><br><span class="line">| Variable_name              | Value   |</span><br><span class="line">+----------------------------+---------+</span><br><span class="line">| Table_locks_immediate      | 100     |</span><br><span class="line">| Table_locks_waited         | 11      |</span><br><span class="line">+----------------------------+---------+</span><br></pre></td></tr></table></figure><p>这里有两个状态变量记录MySQL内部表级锁定的情况，两个变量说明如下：</p><ul><li>Table_locks_immediate：产生表级锁定的次数;  </li><li>Table_locks_waited：出现表级锁定争用而发生等待的次数；</li></ul><p>两个状态值都是从系统启动后开始记录，出现一次对应的事件则数量加1。如果这里的Table_locks_waited状态值比较高，那么说明系统中表级锁定争用现象比较严重，就需要进一步分析为什么会有较多的锁定资源争用了</p><ul><li>（2）缩短锁定时间</li></ul><p>如何让锁定时间尽可能的短呢？唯一的办法就是让我们的Query执行时间尽可能的短。</p><pre><code>+ a)尽两减少大的复杂Query，将复杂Query分拆成几个小的Query分布进行；  + b)尽可能的建立足够高效的索引，让数据检索更迅速；  + c)尽量让MyISAM存储引擎的表只存放必要的信息，控制字段类型；  + d)利用合适的机会优化MyISAM表数据文件</code></pre><ul><li>(3)分离并行的操作</li></ul>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL两种存储引擎- MyISAM和InnoDB 简单总结</title>
      <link href="/2019/05/03/MySQL%E4%B8%A4%E7%A7%8D%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%20MyISAM%E5%92%8CInnoDB%20%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
      <url>/2019/05/03/MySQL%E4%B8%A4%E7%A7%8D%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%20MyISAM%E5%92%8CInnoDB%20%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<ul><li><p>MyISAM是MySQL的默认数据库引擎（5.5版之前），由早期的ISAM（Indexed Sequential Access Method：有索引的顺序访问方法）所改良。虽然性能极佳，但却有一个缺点：不支持事务处理（transaction）。不过，在这几年的发展下，MySQL也导入了InnoDB（另一种数据库引擎），以强化参考完整性与并发违规处理机制，后来就逐渐取代MyISAM。</p></li><li><p>InnoDB，是MySQL的数据库引擎之一，为MySQL AB发布binary的标准之一。InnoDB由Innobase Oy公司所开发，2006年五月时由甲骨文公司并购。与传统的ISAM与MyISAM相比，InnoDB的最大特色就是支持了ACID兼容的事务（Transaction）功能，类似于PostgreSQL。目前InnoDB采用双轨制授权，一是GPL授权，另一是专有软件授权。</p></li></ul><a id="more"></a><p>MyISAM和InnoDB两者之间有着明显区别，简单梳理如下:</p><h5 id="1-事务支持"><a href="#1-事务支持" class="headerlink" title="1) 事务支持"></a>1) 事务支持</h5><p>MyISAM不支持事务，而InnoDB支持。InnoDB的AUTOCOMMIT默认是打开的，即每条SQL语句会默认被封装成一个事务，自动提交，这样会影响速度，所以最好是把多条SQL语句显示放在begin和commit之间，组成一个事务去提交。</p><p>MyISAM是非事务安全型的，而InnoDB是事务安全型的，默认开启自动提交，宜合并事务，一同提交，减小数据库多次提交导致的开销，大大提高性能。</p><h5 id="2-存储结构"><a href="#2-存储结构" class="headerlink" title="2) 存储结构"></a>2) 存储结构</h5><p>MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。</p><p>InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</p><h5 id="3-存储空间"><a href="#3-存储空间" class="headerlink" title="3) 存储空间"></a>3) 存储空间</h5><p>MyISAM：可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。</p><p>InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。</p><h5 id="4-可移植性、备份及恢复"><a href="#4-可移植性、备份及恢复" class="headerlink" title="4) 可移植性、备份及恢复"></a>4) 可移植性、备份及恢复</h5><p>MyISAM：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。</p><p>InnoDB：免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。</p><h5 id="5-事务支持"><a href="#5-事务支持" class="headerlink" title="5) 事务支持"></a>5) 事务支持</h5><p>MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。</p><p>InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</p><h5 id="6-AUTO-INCREMENT"><a href="#6-AUTO-INCREMENT" class="headerlink" title="6) AUTO_INCREMENT"></a>6) AUTO_INCREMENT</h5><p>MyISAM：可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。</p><p>InnoDB：InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。</p><h5 id="7-表锁差异"><a href="#7-表锁差异" class="headerlink" title="7) 表锁差异"></a>7) 表锁差异</h5><p>MyISAM：只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。</p><p>InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</p><p>MyISAM锁的粒度是表级，而InnoDB支持行级锁定。简单来说就是, InnoDB支持数据行锁定，而MyISAM不支持行锁定，只支持锁定整个表。即MyISAM同一个表上的读锁和写锁是互斥的，MyISAM并发读写时如果等待队列中既有读请求又有写请求，默认写请求的优先级高，即使读请求先到，所以MyISAM不适合于有大量查询和修改并存的情况，那样查询进程会长时间阻塞。因为MyISAM是锁表，所以某项读操作比较耗时会使其他写进程饿死。</p><h5 id="8-全文索引"><a href="#8-全文索引" class="headerlink" title="8) 全文索引"></a>8) 全文索引</h5><p>MyISAM：支持(FULLTEXT类型的)全文索引</p><p>InnoDB：不支持(FULLTEXT类型的)全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。</p><p>全文索引是指对char、varchar和text中的每个词（停用词除外）建立倒排序索引。MyISAM的全文索引其实没啥用，因为它不支持中文分词，必须由使用者分词后加入空格再写到数据表里，而且少于4个汉字的词会和停用词一样被忽略掉。</p><blockquote><p>另外，MyIsam索引和数据分离，InnoDB在一起，MyIsam天生非聚簇索引，最多有一个unique的性质，InnoDB的数据文件本身就是主键索引文件，这样的索引被称为“聚簇索引”</p></blockquote><h5 id="9-表主键"><a href="#9-表主键" class="headerlink" title="9) 表主键"></a>9) 表主键</h5><p>MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。</p><p>InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。InnoDB的主键范围更大，最大是MyISAM的2倍。</p><h5 id="10-表的具体行数"><a href="#10-表的具体行数" class="headerlink" title="10) 表的具体行数"></a>10) 表的具体行数</h5><p>MyISAM：保存有表的总行数，如果select count(*) from table;会直接取出出该值。</p><p>InnoDB：没有保存表的总行数(只能遍历)，如果使用select count(*) from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。</p><h5 id="11-CURD操作"><a href="#11-CURD操作" class="headerlink" title="11) CURD操作"></a>11) CURD操作</h5><p>MyISAM：如果执行大量的SELECT，MyISAM是更好的选择。</p><p>InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。</p><h5 id="12-外键"><a href="#12-外键" class="headerlink" title="12) 外键"></a>12) 外键</h5><p>MyISAM：不支持</p><p>InnoDB：支持</p><h5 id="13-查询效率"><a href="#13-查询效率" class="headerlink" title="13) 查询效率"></a>13) 查询效率</h5><p>没有where的count(<em>)使用MyISAM要比InnoDB快得多。因为MyISAM内置了一个计数器，count(</em>)时它直接从计数器中读，而InnoDB必须扫描全表。所以在InnoDB上执行count(<em>)时一般要伴随where，且where中要包含主键以外的索引列。为什么这里特别强调“主键以外”？因为InnoDB中primary index是和raw data存放在一起的，而secondary index则是单独存放，然后有个指针指向primary key。所以只是count(</em>)的话使用secondary index扫描更快，而primary key则主要在扫描索引同时要返回raw data时的作用较大。MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM。</p><p>通过上述的分析，基本上可以考虑使用InnoDB来替代MyISAM引擎了，原因是InnoDB自身很多良好的特点，比如事务支持、存储 过程、视图、行级锁定等等，在并发很多的情况下，相信InnoDB的表现肯定要比MyISAM强很多。另外，任何一种表都不是万能的，只用恰当的针对业务类型来选择合适的表类型，才能最大的发挥MySQL的性能优势。如果不是很复杂的Web应用，非关键应用，还是可以继续考虑MyISAM的，这个具体情况可以自己斟酌。</p><h3 id="MyISAM和InnoDB两者的应用场景："><a href="#MyISAM和InnoDB两者的应用场景：" class="headerlink" title="MyISAM和InnoDB两者的应用场景："></a>MyISAM和InnoDB两者的应用场景：</h3><ul><li><p>1) MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。</p></li><li><p>2) InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。</p></li></ul><p>但是实际场景中，针对具体问题需要具体分析，一般而言可以遵循以下几个问题：</p><ul><li>数据库是否有外键？</li><li>是否需要事务支持？</li><li>是否需要全文索引？</li><li>数据库经常使用什么样的查询模式？在写多读少的应用中还是Innodb插入性能更稳定，在并发情况下也能基本，如果是对读取速度要求比较快的应用还是选MyISAM。</li><li>数据库的数据有多大？ 大尺寸倾向于innodb，因为事务日志，故障恢复。</li></ul>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL索引优化策略与笔记</title>
      <link href="/2019/04/29/MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5%E4%B8%8E%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/04/29/MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5%E4%B8%8E%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>面试知识，数据库索引优化</p><h4 id="什么问题？"><a href="#什么问题？" class="headerlink" title="什么问题？"></a>什么问题？</h4><pre><code>索引有什么代价？哪些场景下你需要建索引？或者有时候反过来问，哪些场景下不推荐建索引。建好索引之后，怎么才能最高效地利用索引？或者反过来问，请说出一个无法有效利用已建索引的案例。</code></pre><h4 id="索引的好处？"><a href="#索引的好处？" class="headerlink" title="索引的好处？"></a>索引的好处？</h4><blockquote><p>快速查询数据。</p></blockquote><a id="more"></a><h4 id="代价是什么？"><a href="#代价是什么？" class="headerlink" title="代价是什么？"></a>代价是什么？</h4><pre><code>索引需要占硬盘空间，这是空间方面的代价。一旦插入新的数据，就需要重新建索引，这是时间上的代价。</code></pre><h4 id="不同场景，不同对待。"><a href="#不同场景，不同对待。" class="headerlink" title="不同场景，不同对待。"></a>不同场景，不同对待。</h4><h5 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h5><blockquote><p>数据表规模不大，就几千行，即使不建索引，查询语句的返回时间也不长，这时建索引的意义就不大。当然，若就几千行，索引所占的空间也不多，所以这种情况下，顶多属于“性价比”不高。</p></blockquote><h4 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h4><blockquote><p> 某个商品表里有几百万条商品信息，同时每天会在一个时间点，往其中更新大概十万条左右的商品信息，现在用where语句查询特定商品时（比如where name = ‘XXX’）速度很慢。为了提升查询效率可以建索引，但当每天更新数据时，又会重建索引，这是要耗费时间的。这时就需要综合考虑，甚至可以在更新前删除索引，更新后再重建。</p></blockquote><h4 id="场景三"><a href="#场景三" class="headerlink" title="场景三"></a>场景三</h4><blockquote><p>因为在数据表里ID值都不相同，所以索引能发挥出比较大的作用。相反，如果某个字段重复率很高，如性别字段，或者某个字段大多数值是空（null），那么不建议对该字段建索引。</p></blockquote><h3 id="建立索引原则"><a href="#建立索引原则" class="headerlink" title="建立索引原则"></a>建立索引原则</h3><p>一定是有业务需求了才会建索引。比如在一个商品表里，我们经常要根据name做查询，如果没有索引，查询速度会很慢，这时就需要建索引。但在项目开发中，如果不经常根据商品编号查询，那么就没必要对编号建索引。</p><p>最后再强调一次，建索引是要付出代价的，没事别乱建着玩，同时在一个表上也不能建太多的索引。<br>具体的例子来看索引的正确用法</p><pre><code>语句一：select name from 商品表。不会用到索引，因为没有where语句。语句二：select * from 商品表 where name = ‘Java书’，会用到索引，如果项目里经常用到name来查询，且商品表的数据量很大，而name值的重复率又不高，那么建议建索引。语句三：select * from 商品表 where name like ‘Java%’ 这是个模糊查询，会用到索引，请大家记住，用like进行模糊查询时，如果第一个就是模糊的匹配符，比如where name like ‘%java’，那么在查询时不会走索引。在其他情况下，不论用了多少个%，也不论%的位置，只要不出现在第一个位置，那么都能用到索引。</code></pre><p>学生成绩表里有两个字段：姓名和成绩。现在对成绩这个整数类型的字段建索引。</p><pre><code>第一种情况，当数字型字段遇到非等值操作符时，无法用到索引。比如：</code></pre><p>​ select name from 学生成绩表 where 成绩&gt;95 , 一旦出现大于符号，就不能用到索引，为了用到索引，我们应该改一下SQL语句里的where从句：where 成绩 in (96,97,98,99,100)</p><pre><code>第二种情况，如果对索引字段进行了某种左值操作，那么无法用到索引。</code></pre><p>​ 能用到索引的写法：select name from 学生成绩表 where 成绩 = 60</p><p>​ 不能用到索引的写法：select name from 学生成绩表 where 成绩+40 = 100</p><pre><code>第三种情况，如果对索引字段进行了函数操作，那么无法用到索引。</code></pre><p>​ 比如SQL语句：select * from 商品表 where substr(name) = ‘J’，我们希望查询商品名首字母是J的记录，可一旦针对name使用函数，即使name字段上有索引，也无法用到。<br>​ </p><blockquote><p>非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据。</p></blockquote><p>不管以任何方式查询表， 最终都会利用主键通过聚集索引来定位到数据， 聚集索引（主键）是通往真实数据所在的唯一路径。</p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何处理负载、高并发问题</title>
      <link href="/2019/04/27/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%B4%9F%E8%BD%BD%E3%80%81%E9%AB%98%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/"/>
      <url>/2019/04/27/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%B4%9F%E8%BD%BD%E3%80%81%E9%AB%98%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>从低成本、高性能和高扩张性的角度来说有如下处理方案：</p><h5 id="1、HTML静态化"><a href="#1、HTML静态化" class="headerlink" title="1、HTML静态化"></a>1、HTML静态化</h5><p>其实大家都知道，效率最高、消耗最小的就是纯静态化的html页面，所以我们尽可能使我们的  网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。</p><h5 id="2、图片服务器分离"><a href="#2、图片服务器分离" class="headerlink" title="2、图片服务器分离"></a>2、图片服务器分离</h5><p>​    把图片单独存储，尽量减少图片等大流量的开销，可以放在一些相关的平台上，如骑牛等</p><a id="more"></a><h5 id="3、数据库集群和库表散列及缓存"><a href="#3、数据库集群和库表散列及缓存" class="headerlink" title="3、数据库集群和库表散列及缓存"></a>3、数据库集群和库表散列及缓存</h5><p>数据库的并发连接为100，一台数据库远远不够，可以从读写分离、主从复制，数据库集群方面来着手。另外尽量减少数据库的访问，可以使用缓存数据库如memcache、redis。</p><h5 id="4、镜像："><a href="#4、镜像：" class="headerlink" title="4、镜像："></a>4、镜像：</h5><p>   尽量减少下载，可以把不同的请求分发到多个镜像端。</p><h5 id="5、负载均衡："><a href="#5、负载均衡：" class="headerlink" title="5、负载均衡："></a>5、负载均衡：</h5><p>   Apache的最大并发连接为1500，只能增加服务器，可以从硬件上着手，如F5服务器。当然硬件的成本比较高，我们往往从软件方面着手。</p><p>   负载均衡 （Load Balancing） 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力，同时能够提高网络的灵活性和可用性。目前使用最为广泛的负载均衡软件是Nginx、LVS、HAProxy。我分别来说下三种的优缺点:</p><h5 id="Nginx的优点是："><a href="#Nginx的优点是：" class="headerlink" title="Nginx的优点是："></a>Nginx的优点是：</h5><ol><li><p>工作在网络的7层之上，可以针对http应用做一些分流的策略，比如针对域名、目录结构，它的正则规则比HAProxy更为强大和灵活，这也是它目前广泛流行的主要原因之一，Nginx单凭这点可利用的场合就远多于LVS了。 </p></li><li><p>Nginx对网络稳定性的依赖非常小，理论上能ping通就就能进行负载功能，这个也是它的优势之一；相反LVS对网络稳定性依赖比较大，这点本人深有体会； </p></li><li><p>Nginx安装和配置比较简单，测试起来比较方便，它基本能把错误用日志打印出来。LVS的配置、测试就要花比较长的时间了，LVS对网络依赖比较大。 </p></li><li><p>可以承担高负载压力且稳定，在硬件不差的情况下一般能支撑几万次的并发量，负载度比LVS相对小些。 </p></li><li><p>Nginx可以通过端口检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点，不过其中缺点就是不支持url来检测。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而不满。 </p></li><li><p>Nginx不仅仅是一款优秀的负载均衡器/反向代理软件，它同时也是功能强大的Web应用服务器。LNMP也是近几年非常流行的web架构，在高流量的环境中稳定性也很好。 </p></li><li><p>Nginx现在作为Web反向加速缓存越来越成熟了，速度比传统的Squid服务器更快，可以考虑用其作为反向代理加速器。 </p></li><li><p>Nginx可作为中层反向代理使用，这一层面Nginx基本上无对手，唯一可以对比Nginx的就只有 lighttpd了，不过 lighttpd目前还没有做到Nginx完全的功能，配置也不那么清晰易读，社区资料也远远没Nginx活跃。 </p></li><li><p>Nginx也可作为静态网页和图片服务器，这方面的性能也无对手。还有Nginx社区非常活跃，第三方模块也很多。</p></li></ol><h5 id="Nginx的缺点是："><a href="#Nginx的缺点是：" class="headerlink" title="Nginx的缺点是："></a>Nginx的缺点是：</h5><ol><li>Nginx仅能支持http、https和Email协议，这样就在适用范围上面小些，这个是它的缺点。</li><li>对后端服务器的健康检查，只支持通过端口来检测，不支持通过url来检测。不支持Session的直接保持，但能通过ip_hash来解决。</li></ol><h4 id="LVS：使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability-、可靠性（Reliability-和可管理性（Manageability-。"><a href="#LVS：使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability-、可靠性（Reliability-和可管理性（Manageability-。" class="headerlink" title="LVS：使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability)、可靠性（Reliability)和可管理性（Manageability)。"></a>LVS：使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability)、可靠性（Reliability)和可管理性（Manageability)。</h4><h5 id="LVS的优点是："><a href="#LVS的优点是：" class="headerlink" title="LVS的优点是："></a>LVS的优点是：</h5><ol><li>抗负载能力强、是工作在网络4层之上仅作分发之用，没有流量的产生，这个特点也决定了它在负载均衡软件里的性能最强的，对内存和cpu资源消耗比较低。</li><li>配置性比较低，这是一个缺点也是一个优点，因为没有可太多配置的东西，所以并不需要太多接触，大大减少了人为出错的几率。</li><li>工作稳定，因为其本身抗负载能力很强，自身有完整的双机热备方案，如LVS+Keepalived，不过我们在项目实施中用得最多的还是LVS/DR+Keepalived。</li><li>无流量，LVS只分发请求，而流量并不从它本身出去，这点保证了均衡器IO的性能不会受到大流量的影响。</li><li>应用范围比较广，因为LVS工作在4层，所以它几乎可以对所有应用做负载均衡，包括http、数据库、在线聊天室等等。</li></ol><h5 id="LVS的缺点是："><a href="#LVS的缺点是：" class="headerlink" title="LVS的缺点是："></a>LVS的缺点是：</h5><ol><li>软件本身不支持正则表达式处理，不能做动静分离；而现在许多网站在这方面都有较强的需求，这个是Nginx/HAProxy+Keepalived的优势所在。</li><li>如果是网站应用比较庞大的话，LVS/DR+Keepalived实施起来就比较复杂了，特别后面有 Windows Server的机器的话，如果实施及配置还有维护过程就比较复杂了，相对而言，Nginx/HAProxy+Keepalived就简单多了。</li></ol><h5 id="HAProxy的特点是："><a href="#HAProxy的特点是：" class="headerlink" title="HAProxy的特点是："></a>HAProxy的特点是：</h5><ol><li>HAProxy也是支持虚拟主机的。</li><li>HAProxy的优点能够补充Nginx的一些缺点，比如支持Session的保持，Cookie的引导；同时支持通过获取指定的url来检测后端服务器的状态。</li><li>HAProxy跟LVS类似，本身就只是一款负载均衡软件；单纯从效率上来讲HAProxy会比Nginx有更出色的负载均衡速度，在并发处理上也是优于Nginx的。</li><li>HAProxy支持TCP协议的负载均衡转发，可以对MySQL读进行负载均衡，对后端的MySQL节点进行检测和负载均衡，大家可以用LVS+Keepalived对MySQL主从做负载均衡。</li><li>HAProxy负载均衡策略非常多，HAProxy的负载均衡算法现在具体有如下8种：</li></ol><p>① roundrobin，表示简单的轮询，这个不多说，这个是负载均衡基本都具备的；<br>② static-rr，表示根据权重，建议关注；<br>③ leastconn，表示最少连接者先处理，建议关注；<br>④ source，表示根据请求源IP，这个跟Nginx的IP_hash机制类似，我们用其作为解决session问题的一种方法，建议关注；<br>⑤ ri，表示根据请求的URI；<br>⑥ rl_param，表示根据请求的URl参数’balance url_param’ requires an URL parametername；<br>⑦ hdr(name)，表示根据HTTP请求头来锁定每一次HTTP请求；<br>⑧ rdp-cookie(name)，表示根据据cookie(name)来锁定并哈希每一次TCP请求。</p><h5 id="Nginx和LVS对比的总结："><a href="#Nginx和LVS对比的总结：" class="headerlink" title="Nginx和LVS对比的总结："></a>Nginx和LVS对比的总结：</h5><ol><li><p>Nginx工作在网络的7层，所以它可以针对http应用本身来做分流策略，比如针对域名、目录结构等，相比之下LVS并不具备这样的功能，所以Nginx单凭这点可利用的场合就远多于LVS了；但Nginx有用的这些功能使其可调整度要高于LVS，所以经常要去触碰触碰，触碰多了，人为出问题的几率也就会大。   </p></li><li><p>Nginx对网络稳定性的依赖较小，理论上只要ping得通，网页访问正常，Nginx就能连得通，这是Nginx的一大优势！Nginx同时还能区分内外网，如果是同时拥有内外网的节点，就相当于单机拥有了备份线路；LVS就比较依赖于网络环境，目前来看服务器在同一网段内并且LVS使用direct方式分流，效果较能得到保证。另外注意，LVS需要向托管商至少申请多一个ip来做Visual IP，貌似是不能用本身的IP来做VIP的。要做好LVS管理员，确实得跟进学习很多有关网络通信方面的知识，就不再是一个HTTP那么简单了。</p></li><li><p>Nginx安装和配置比较简单，测试起来也很方便，因为它基本能把错误用日志打印出来。LVS的安装和配置、测试就要花比较长的时间了；LVS对网络依赖比较大，很多时候不能配置成功都是因为网络问题而不是配置问题，出了问题要解决也相应的会麻烦得多。 </p></li><li><p>Nginx也同样能承受很高负载且稳定，但负载度和稳定度差LVS还有几个等级：Nginx处理所有流量所以受限于机器IO和配置；本身的bug也还是难以避免的。 </p></li><li><p>Nginx可以检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点。目前LVS中 ldirectd也能支持针对服务器内部的情况来监控，但LVS的原理使其不能重发请求。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而恼火。 </p></li><li><p>Nginx对请求的异步处理可以帮助节点服务器减轻负载，假如使用 apache直接对外服务，那么出现很多的窄带链接时apache服务器将会占用大量内存而不能释放，使用多一个Nginx做apache代理的话，这些窄带链接会被Nginx挡住，apache上就不会堆积过多的请求，这样就减少了相当多的资源占用。这点使用squid也有相同的作用，即使squid本身配置为不缓存，对apache还是有很大帮助的。 </p></li><li><p>Nginx能支持http、https和email（email的功能比较少用），LVS所支持的应用在这点上会比Nginx更多。在使用上，一般最前端所采取的策略应是LVS，也就是DNS的指向应为LVS均衡器，LVS的优点令它非常适合做这个任务。重要的ip地址，最好交由LVS托管，比如数据库的 ip、webservice服务器的ip等等，这些ip地址随着时间推移，使用面会越来越大，如果更换ip则故障会接踵而至。所以将这些重要ip交给 LVS托管是最为稳妥的，这样做的唯一缺点是需要的VIP数量会比较多。Nginx可作为LVS节点机器使用，一是可以利用Nginx的功能，二是可以利用Nginx的性能。当然这一层面也可以直接使用squid，squid的功能方面就比Nginx弱不少了，性能上也有所逊色于Nginx。Nginx也可作为中层代理使用，这一层面Nginx基本上无对手，唯一可以撼动Nginx的就只有lighttpd了，不过lighttpd目前还没有能做到 Nginx完全的功能，配置也不那么清晰易读。另外，中层代理的IP也是重要的，所以中层代理也拥有一个VIP和LVS是最完美的方案了。具体的应用还得具体分析，如果是比较小的网站（日PV小于1000万），用Nginx就完全可以了，如果机器也不少，可以用DNS轮询，LVS所耗费的机器还是比较多的；大型网站或者重要的服务，机器不发愁的时候，要多多考虑利用LVS。</p></li></ol>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 高负载 </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MYSQL 事务处理常见有两种方法</title>
      <link href="/2019/04/26/MYSQL%20%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%B8%B8%E8%A7%81%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2019/04/26/MYSQL%20%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%B8%B8%E8%A7%81%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p> MYSQL在操作大量的数据或者比较重要的数据的时候，事务处理很重要，比如银行的转账，支付，等等，作为开发人员事务是必须的一步。</p><h5 id="1、用-BEGIN-ROLLBACK-COMMIT来实现"><a href="#1、用-BEGIN-ROLLBACK-COMMIT来实现" class="headerlink" title="1、用 BEGIN, ROLLBACK, COMMIT来实现"></a>1、用 BEGIN, ROLLBACK, COMMIT来实现</h5><ul><li>BEGIN 开始一个事务</li><li>ROLLBACK 事务回滚</li><li>COMMIT 事务确认</li></ul><a id="more"></a><h5 id="2、直接用-SET-来改变-MySQL-的自动提交模式"><a href="#2、直接用-SET-来改变-MySQL-的自动提交模式" class="headerlink" title="2、直接用 SET 来改变 MySQL 的自动提交模式:"></a>2、直接用 SET 来改变 MySQL 的自动提交模式:</h5><ul><li>SET AUTOCOMMIT=0 禁止自动提交</li><li>SET AUTOCOMMIT=1 开启自动提交</li></ul><blockquote><p>注意的是，在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</p></blockquote><p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p><h3 id="一、php事务处理概述："><a href="#一、php事务处理概述：" class="headerlink" title="一、php事务处理概述："></a>一、php事务处理概述：</h3><ul><li><p>事务:是若干事件的集合</p></li><li><p>事务处理:当所有事件执行成功,事务才执行;若有任何一个事件不能成功执行,事务的其它事件也不被执行。</p></li></ul><p>只要你的MySQL版本支持BDB或InnoDB表类型，那么你的MySQL就具有事务处理的能力。这里面，又以InnoDB表类型用的最多，虽然后来发生了诸如Oracle收购InnoDB等令MySQL不爽的事情，但是这类商业事件与技术无关，下面就以InnoDB表类型为例简单说一下MySQL中的事务处理。</p><h3 id="二、php事务处理代码："><a href="#二、php事务处理代码：" class="headerlink" title="二、php事务处理代码："></a>二、php事务处理代码：</h3><pre><code>&lt;?phptry{$pdo=new PDO(&quot;mysql:host=localhost;dbname=psp&quot;,&quot;root&quot;,&quot;&quot;);$pdo-&gt;exec(&quot;set names utf8&quot;);$pdo-&gt;setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_EXCEPTION);//设置异常处理模式$pdo-&gt;setAttribute(PDO::ATTR_AUTOCOMMIT,0);//关闭自动提交}catch(PDOException $e){echo &quot;数据库连接失败&quot;;exit;}try{$age=10;$pdo-&gt;beginTransaction();//开始事务$affected_rows1=$pdo-&gt;exec(&quot;update kfry set k_age=k_age+{$age} where k_name=&apos;user1&apos;&quot;);$affected_rows2=$pdo-&gt;exec(&quot;update kfry set k_age=k_age-{$age} where k_name=&apos;user2&apos;&quot;);//随意更改使之执行成功或失败/* if($affected_rows1&amp;&amp;$affected_rows2){$pdo-&gt;commit();echo &quot;操作成功&quot;;}else{$pdo-&gt;rollback();} */if(!$affected_rows1)throw new PDOException(&quot;加入错误&quot;);if(!$affected_rows2)throw new PDOException(&quot;减少错误&quot;);echo &quot;操作成功&quot;;$pdo-&gt;commit();//如果执行到此处前面两个更新sql语句执行成功，整个事务执行成功}catch(PDOException $e){echo &quot;操作失败：&quot;.$e-&gt;getMessage();$pdo-&gt;rollback();//执行事务中的语句出了问题，整个事务全部撤销}$pdo-&gt;setAttribute(PDO::ATTR_AUTOCOMMIT,1);//测试是否成功echo &quot;\n操作结果为:\n&quot;;$sql=&quot;select * from kfry&quot;;$result=$pdo-&gt;query($sql);foreach($result as $v){echo $v[&apos;k_name&apos;].&quot; &quot;.$v[&apos;k_age&apos;].&quot;\n&quot;;}?&gt;</code></pre><p>以上就是php 事务处理详解的详细内容，更多请关注php中文网其它相关文章！</p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Web安全的一次探讨</title>
      <link href="/2019/03/13/Web%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%80%E6%AC%A1%E6%8E%A2%E8%AE%A8/"/>
      <url>/2019/03/13/Web%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%80%E6%AC%A1%E6%8E%A2%E8%AE%A8/</url>
      <content type="html"><![CDATA[<h3 id="一、SQL注入攻击-SQL-Injection"><a href="#一、SQL注入攻击-SQL-Injection" class="headerlink" title="一、SQL注入攻击(SQL Injection)"></a>一、SQL注入攻击(SQL Injection)</h3><p>攻击者把sql命令插入到web表单的输入域或页面请求的字符串，欺骗服务器执行恶意的sql命令。常见的sql注入攻击类似：</p><h5 id="登录页面中输入内容直接用来构造动态的sql语句，例如："><a href="#登录页面中输入内容直接用来构造动态的sql语句，例如：" class="headerlink" title="登录页面中输入内容直接用来构造动态的sql语句，例如："></a>登录页面中输入内容直接用来构造动态的sql语句，例如：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$query = &apos;select * from users where login = &apos;. $username. &apos;and password = &apos;. $password;</span><br></pre></td></tr></table></figure><a id="more"></a><p>攻击者如果在用户名或者密码框输入<code>or &#39;1&#39; =1</code>，这样我们执行的sql语句就变成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where login = &apos;&apos; or &apos;1&apos; = 1 and ...</span><br></pre></td></tr></table></figure><p>这样就绕过了我们的登录验证。类似的还有很多，用户通过输入恶意的sql命令来绕过我们的验证，欺骗我们的系统。</p><h5 id="防范的方法："><a href="#防范的方法：" class="headerlink" title="防范的方法："></a>防范的方法：</h5><ol><li>检查变量数据类型和格式</li><li>过滤特殊的符号</li><li>绑定变量，使用预处理语句（当我们绑定变量的时候，就算有特殊字符sql也会认为是个变量而不是sql命令）</li></ol><h3 id="二、跨站脚本攻击-Cross-Site-Scripting-XSS；因为CSS被用了所以叫XSS"><a href="#二、跨站脚本攻击-Cross-Site-Scripting-XSS；因为CSS被用了所以叫XSS" class="headerlink" title="二、跨站脚本攻击(Cross Site Scripting, XSS；因为CSS被用了所以叫XSS)"></a>二、跨站脚本攻击(Cross Site Scripting, XSS；因为CSS被用了所以叫XSS)</h3><p>攻击者将恶意代码注入到网页上，其他用户在加载网页时就会执行代码，攻击者可能会得到各种私密的信息，如cookie等。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    echo &apos;你好！&apos;.$_GET[&apos;name&apos;];</span><br></pre></td></tr></table></figure><p>如果用户传入一段脚本<code>&lt;script&gt;[code]&lt;/script&gt;</code>，那么脚本也会执行，如果code的内容是获取到cookie并发送到某个指定的位置，获取了敏感的信息。亦或是利用用户的身份去执行一些不正当的操作。</p><h5 id="防范的方法：-1"><a href="#防范的方法：-1" class="headerlink" title="防范的方法："></a>防范的方法：</h5><ol><li>输出的时候过滤特殊的字符，转换成html编码，过滤输出的变量（PHP可以使用htmlspecialchars）</li></ol><h3 id="三、跨站请求伪造攻击-Cross-Site-Request-Forgeries-CSRF"><a href="#三、跨站请求伪造攻击-Cross-Site-Request-Forgeries-CSRF" class="headerlink" title="三、跨站请求伪造攻击(Cross Site Request Forgeries, CSRF)"></a>三、跨站请求伪造攻击(Cross Site Request Forgeries, CSRF)</h3><p>攻击者伪造目标用户的HTTP请求，然后此请求发送到有CSRF漏洞的网站，网站执行此请求后，引发跨站请求伪造攻击。攻击者利用隐蔽的HTTP连接，让目标用户在不注意的情况下单击这个链接，由于是用户自己点击的，而他又是合法用户拥有合法权限，所以目标用户能够在网站内执行特定的HTTP链接，从而达到攻击者的目的。  </p><blockquote><p>  用户刚刚登陆了银行A网站，建立了会话，A网站可以进行转账操作<code>http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000</code>在没有退出的情况下去访问危险网站B网站，B网站有一个图片是这样的<code>&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;</code>，不小心点了B网站，用户发现账上少了1000块。  </p></blockquote><p>可能有人会说，修改操作并不会用get请求。那么假设银行A网站的表单如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;Transfer.php&quot; method=&quot;POST&quot;&gt;</span><br><span class="line">    &lt;p&gt;ToBankId: &lt;input type=&quot;text&quot; name=&quot;toBankId&quot; /&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;Money: &lt;input type=&quot;text&quot; name=&quot;money&quot; /&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Transfer&quot; /&gt;&lt;/p&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>后台处理页面如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">session_start();</span><br><span class="line">if (isset($_REQUEST[&apos;toBankId&apos;] &amp;&amp; isset($_POST[&apos;money&apos;]))</span><br><span class="line">&#123;</span><br><span class="line">    buy_stocks($_REQUEST[&apos;toBankId&apos;],$_REQUEST[&apos;money&apos;]);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>B网站这时候也相应的改了代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">　　　　&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">　　　　　　function steal()</span><br><span class="line">　　　　　　&#123;</span><br><span class="line">          　　　　 iframe = document.frames[&quot;steal&quot;];</span><br><span class="line">　　     　　      iframe.document.Submit(&quot;transfer&quot;);</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&lt;/script&gt;</span><br><span class="line">　　&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">　　&lt;body onload=&quot;steal()&quot;&gt;</span><br><span class="line">　　　　&lt;iframe name=&quot;steal&quot; display=&quot;none&quot;&gt;</span><br><span class="line">　　　　　　&lt;form method=&quot;POST&quot; name=&quot;transfer&quot;　action=&quot;http://www.myBank.com/Transfer.php&quot;&gt;</span><br><span class="line">　　　　　　　　&lt;input type=&quot;hidden&quot; name=&quot;toBankId&quot; value=&quot;11&quot;&gt;</span><br><span class="line">　　　　　　　　&lt;input type=&quot;hidden&quot; name=&quot;money&quot; value=&quot;1000&quot;&gt;</span><br><span class="line">　　　　　　&lt;/form&gt;</span><br><span class="line">　　　　&lt;/iframe&gt;</span><br><span class="line">　　&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>用户一点到B网站，发现又少了1000块…….</p><h5 id="防范方法："><a href="#防范方法：" class="headerlink" title="防范方法："></a>防范方法：</h5><ul><li>对表单进行cookie hash校验，将一个随机值的hash写入cookie，每次提交表单，都在服务端对这个hash进行校验（建立在用户的cookie没有被盗取）</li></ul><h3 id="四、Session固定攻击-Session-Fixation"><a href="#四、Session固定攻击-Session-Fixation" class="headerlink" title="四、Session固定攻击(Session Fixation)"></a>四、Session固定攻击(Session Fixation)</h3><p>攻击者预先设定session id，让合法用户使用这个session id来访问被攻击的应用程序，一旦用户的会话ID被成功固定，攻击者就可以通过此session id来冒充用户访问应用程序。例如：  </p><ol><li>攻击者先访问目标网站，获得了自己的session_id，如SID=123</li><li>攻击者给目标用户发送链接，并带上了自己的session_id，如<code>http:///www.bank.com/?SID=123</code>，</li><li>目标用户点击了<code>http:///www.bank.com/?SID=123</code>，输入用户名密码登录，由于session_id不会变更，那么攻击者就可以通过访问<code>http:///www.bank.com/?SID=123</code>来获取目标用户的身份。</li></ol><h5 id="防范方法：-1"><a href="#防范方法：-1" class="headerlink" title="防范方法："></a>防范方法：</h5><ol><li>定期更改session_id</li><li>更改session_id的名字</li></ol><h3 id="五、Session劫持-Session-Hijacking"><a href="#五、Session劫持-Session-Hijacking" class="headerlink" title="五、Session劫持(Session Hijacking)"></a>五、Session劫持(Session Hijacking)</h3><p>攻击者利用各种手段来获取目标用户的session id。一旦获取到session id，那么攻击者可以利用目标用户的身份来登录网站，获取目标用户的操作权限。</p><h5 id="攻击者获取目标用户session-id的方法"><a href="#攻击者获取目标用户session-id的方法" class="headerlink" title="攻击者获取目标用户session id的方法:"></a>攻击者获取目标用户session id的方法:</h5><ol><li>暴力破解:尝试各种session id，直到破解为止;</li><li>计算:如果session id使用非随机的方式产生，那么就有可能计算出来;</li><li>窃取:使用网络截获，xss攻击等方法获得<br>防范方法：</li><li>定期更改session id</li><li>更改session的名称</li><li>关闭透明化session id</li><li>设置HttpOnly。通过设置Cookie的HttpOnly为true，可以防止客户端脚本访问这个Cookie，从而有效的防止XSS攻击。</li></ol><h3 id="六、文件上传漏洞-File-Upload-Attack"><a href="#六、文件上传漏洞-File-Upload-Attack" class="headerlink" title="六、文件上传漏洞(File Upload Attack)"></a>六、文件上传漏洞(File Upload Attack)</h3><p>攻击者利用程序缺陷绕过系统对文件的验证与处理策略将恶意代码上传到服务器并获得执行服务器端命令的能力。  </p><h5 id="常用的攻击手段有："><a href="#常用的攻击手段有：" class="headerlink" title="常用的攻击手段有："></a>常用的攻击手段有：</h5><ol><li>上传Web脚本代码，Web容器解释执行上传的恶意脚本；</li><li>上传Flash跨域策略文件crossdomain.xml，修改访问权限(其他策略文件利用方式类似)；</li><li>上传病毒、木马文件，诱骗用户和管理员下载执行；</li><li>上传包含脚本的图片，某些浏览器的低级版本会执行该脚本，用于钓鱼和欺诈。<br>总的来说，利用的上传文件要么具备可执行能力(恶意代码)，要么具备影响服务器行为的能力(配置文件)。<br>防范方法：  </li><li>文件上传的目录设置为不可执行；</li><li>判断文件类型，设置白名单。对于图片的处理，可以使用压缩函数或者resize函数，在处理图片的同时破坏图片中可能包含的HTML代码；</li><li>使用随机数改写文件名和文件路径：一个是上传后无法访问；再来就是像shell、.php 、.rar和crossdomain.xml这种文件，都将因为重命名而无法攻击；</li><li>单独设置文件服务器的域名：由于浏览器同源策略的关系，一系列客户端攻击将失效，比如上传crossdomain.xml、上传包含Javascript的XSS利用等问题将得到解决。</li></ol><h3 id="MYSQL安全"><a href="#MYSQL安全" class="headerlink" title="MYSQL安全"></a>MYSQL安全</h3><ol><li>使用预处理语句防止sql注入</li><li>写入数据库的数据要进行特殊字符转义</li><li>查询的错误信息不要返回给用户，将错误记录到日志   </li><li>定期做数据库备份</li><li>不给查询用户root权限，合理分配权限</li><li>关闭远程访问数据库的权限</li></ol>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于mysql最左前缀原则</title>
      <link href="/2019/03/01/%E5%85%B3%E4%BA%8Emysql%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99/"/>
      <url>/2019/03/01/%E5%85%B3%E4%BA%8Emysql%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99/</url>
      <content type="html"><![CDATA[<h4 id="背景知识："><a href="#背景知识：" class="headerlink" title="背景知识："></a>背景知识：</h4><ol><li>mysql中可以使用explain关键字来查看sql语句的执行计划。</li><li>最左前缀原则主要使用在联合索引中</li><li>数据库版本Mysql5.5.53</li></ol><a id="more"></a><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>mysql建立多列索引（联合索引）有最左前缀的原则，即最左优先，如：</p><ul><li>如果有一个2列的索引(col1,col2),则已经对(col1)、(col1,col2)上建立了索引；</li><li>如果有一个3列索引(col1,col2,col3)，则已经对(col1)、(col1,col2)、(col1,col2,col3)上建立了索引；</li></ul><p>1、b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+树是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道第一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。</p><p>2、比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。（这种情况无法用到联合索引）</p><p>关于最左前缀的使用，有下面两条说明：</p><ul><li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a  = 1 and b = 2 and c &gt; 3 and d = 4  如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li><li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li></ul><p>联合索引有一个最左前缀原则，所以建立联合索引的时候，这个联合索引的字段顺序非常重要</p><p>下面写了例子说明这个：</p><pre><code>CREATE TABLE `test_myisam` (`id` int(11) NOT NULL AUTO_INCREMENT,`conference_id` varchar(200) NOT NULL,`account` varchar(100) DEFAULT NULL,`status` int(2) DEFAULT NULL COMMENT &apos;0:invite,  1:cancel_invite,  2:decline,  3:connect&apos;,`duration` bigint(20) unsigned DEFAULT NULL,`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,PRIMARY KEY (`id`)) ENGINE=myisam AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</code></pre><p>以上表结构，我想通过三列进行查询 account ,status,create_time进行查询统计。</p><h5 id="如何建立索引？"><a href="#如何建立索引？" class="headerlink" title="如何建立索引？"></a>如何建立索引？</h5><p>因为我们有可能按照acccount单独统计，或者按照account status，或者是account，status，create_time进行统计，如何建立索引？？？</p><p>下面是建立索引前后的对比600万数据</p><p>如何生成：执行如下脚本，account和日期不同还有status不同，分别生成一百万。</p><pre><code>CREATE  PROCEDURE `add_data_myisam_cp_27`()begindeclare v_rows int(10) default 1000000;declare v_count int(10) default 0;id_loop:LOOPinsert into test_myisam values(null,round(rand()*1000000000),&apos;cloudp&apos;,round(rand()*3),round(rand()*100000),&apos;2016-07-27 00:00:22&apos;);set v_count= v_count + 1;if v_count&gt;v_rows thenleave id_loop;end if;end loop id_loop;end;</code></pre><p>测试结果利用建立的索引性能提高了三倍：</p><pre><code>MariaDB [prf]&gt; select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and date(create_time)=&apos;2016-07-27&apos;;+----------+| count(1) |+----------+|   167400 |+----------+1 row in set (1.28 sec)MariaDB [prf]&gt; create index as_index on test_myisam(account,status,create_time);Query OK, 6000006 rows affected (31.60 sec)Records: 6000006  Duplicates: 0  Warnings: 0MariaDB [prf]&gt; select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and date(create_time)=&apos;2016-07-27&apos;;+----------+| count(1) |+----------+|   167400 |+----------+1 row in set (0.42 sec)MariaDB [prf]&gt; explain select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and date(create_time)=&apos;2016-07-27&apos;;+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+| id   | select_type | table       | type | possible_keys | key      | key_len | ref         | rows   | Extra                    |+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+|    1 | SIMPLE      | test_myisam | ref  | as_index      | as_index | 308     | const,const | 520216 | Using where; Using index |+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+1 row in set (0.00 sec)</code></pre><p>从1.28秒下降到0.42秒<br>但是这个date(create_time)会对每一列都会转换后对比，这里会比较消耗性能；</p><h5 id="如何利用上索引？？"><a href="#如何利用上索引？？" class="headerlink" title="如何利用上索引？？"></a>如何利用上索引？？</h5><p>修改为：</p><pre><code>MariaDB [prf]&gt; explain select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and date(create_time)=&apos;2016-07-27&apos;;+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+| id   | select_type | table       | type | possible_keys | key      | key_len | ref         | rows   | Extra                    |+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+|    1 | SIMPLE      | test_myisam | ref  | as_index      | as_index | 308     | const,const | 520216 | Using where; Using index |+------+-------------+-------------+------+---------------+----------+---------+-------------+--------+--------------------------+1 row in set (0.00 sec)MariaDB [prf]&gt; select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and create_time  between &apos;2016-07-27&apos; and &apos;2016-07-28&apos;;+----------+| count(1) |+----------+|   167400 |+----------+1 row in set (0.15 sec)MariaDB [prf]&gt; explain select count(1) from test_myisam where account=&apos;cloudp&apos; and status =3 and create_time  between &apos;2016-07-27&apos; and &apos;2016-07-28&apos;;+------+-------------+-------------+-------+---------------+----------+---------+------+--------+--------------------------+| id   | select_type | table       | type  | possible_keys | key      | key_len | ref  | rows   | Extra                    |+------+-------------+-------------+-------+---------------+----------+---------+------+--------+--------------------------+|    1 | SIMPLE      | test_myisam | range | as_index      | as_index | 312     | NULL | 174152 | Using where; Using index |+------+-------------+-------------+-------+---------------+----------+---------+------+--------+--------------------------+1 row in set (0.00 sec)</code></pre><p>如上效率又提高了三倍，是因为扫描的数据行数减少了，最后一个create_time如果不用索引需要扫描52016行，如果使用了索引扫描174152行，命中的行数为：167400行，命中率非常高了。</p><h5 id="这里有个疑问："><a href="#这里有个疑问：" class="headerlink" title="这里有个疑问："></a>这里有个疑问：</h5><blockquote><p> 如果按照天进行统计，create_time作为联合索引的第一列，如何使用上这个索引呢？？？？</p></blockquote><p>至今没有想清楚，如果这一列是date类型可以直接用上索引，如果在oracle中可以date(create_time)建立函数式索引。但是mysql貌似不支持函数式索引。</p><h5 id="一个解决方式是："><a href="#一个解决方式是：" class="headerlink" title="一个解决方式是："></a>一个解决方式是：</h5><blockquote><p>create_time定义为 date类型，在每一列存入的时候，通过触发器自动把这一行修改为date类型。</p></blockquote><p>如果有好的注意欢迎留言探讨，目前没有好的方式加上create_time，可以从业务上解决，就是每天的统计计算完成以后，直接把数据推到历史表中，统计结果单独存放。</p><h5 id="最后说一下关于索引失效的问题："><a href="#最后说一下关于索引失效的问题：" class="headerlink" title="最后说一下关于索引失效的问题："></a>最后说一下关于索引失效的问题：</h5><ol><li>如果条件中有or，即使其中有条件带索引也不会使用(<strong>这也是为什么尽量少用or的原因</strong>)。<strong>注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引</strong></li><li>对于多列索引，不是使用的第一部分，则不会使用索引（即不符合最左前缀原则）</li><li>like查询是以%开头</li><li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引</li><li>如果mysql估计使用全表扫描要比使用索引快,则不使用索引</li></ol><h6 id="此外，查看索引的使用情况"><a href="#此外，查看索引的使用情况" class="headerlink" title="此外，查看索引的使用情况"></a>此外，查看索引的使用情况</h6><ul><li><p>show status like ‘Handler_read%’;</p></li><li><p>handler_read_key:这个值越高越好，越高表示使用索引查询到的次数</p></li><li>handler_read_rnd_next:这个值越高，说明查询低效</li></ul>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 最佳左前缀 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>高并发大流解决量方案</title>
      <link href="/2019/02/17/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%A4%A7%E6%B5%81%E8%A7%A3%E5%86%B3%E9%87%8F%E6%96%B9%E6%A1%88/"/>
      <url>/2019/02/17/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%A4%A7%E6%B5%81%E8%A7%A3%E5%86%B3%E9%87%8F%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><ul><li>QPS:每秒钟请求或者查询的数量，通常是指每秒相应请求数（http）<ul><li>QPS不等于并发连接数，QPS是每秒的HTTP请求数量，并发连接数是指系统同时处理的请求数量  </li><li>峰值的每秒请求数（QPS）= (总PV数 <em> 80%)/(6小时秒数 </em> 20%)  </li><li>峰值QPS的计算规律主要是80%的访问量集中在20%的访问时间</li></ul></li><li>吞吐量：单位时间内处理请求的数量</li><li>响应时间：从请求发出到收到响应花费的时间</li><li>PV(page view)综合浏览量，即页面点击数。通常日PV在千万级就是高并发的网站</li><li>UV(unique visitor)独立访客，一定时间内相同访客访问网站，只计算为1个独立访客</li></ul><a id="more"></a><ul><li><p>带宽：计算带宽大小，我们需要关注两个指标，峰值流量和平均大小</p><blockquote><p>日网站的带宽 = PV/统计时间（秒） <em> 平均页面大小（KB） </em> 8  </p></blockquote></li><li><p>压力测试</p><ul><li>1.测试能承受的最大并发  </li><li>2.测试最大承受QPS值  </li></ul></li></ul><h5 id="ab-apache-benchmark-工具使用"><a href="#ab-apache-benchmark-工具使用" class="headerlink" title="ab(apache benchmark)工具使用:"></a>ab(apache benchmark)工具使用:</h5><p>ab会创建多个并发访问线程，模拟多个访问者同时对一个URL地址进行访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ab的基本使用</span><br><span class="line">ab -c 100 -n 5000 url</span><br><span class="line">并发请求100次，总共5000次</span><br><span class="line"></span><br><span class="line">测试时注意被测试机器的CPU、内存、网络都不超过最高限度的75%</span><br></pre></td></tr></table></figure><p>此处介绍一些QPS的数值：</p><ol><li>50：小型网站，一般服务器即可应付</li><li>100：假设数据库每次请求都在0.01秒内完成，单个页面只有一个sql，100QPS意味着1秒钟要完成100次请求，但是我们数据库不一定能完成100次查询。此时优化方案为：数据库缓存、数据库负载均衡</li><li>800：假设网站有百兆带宽，意味着实际出口的带宽为8M左右，如果每个页面只有10K，在这个QPS下，带宽已经吃完。此时的方案：CDN加速，负载均衡</li><li>1000： 假设使用nosql来缓存数据库查询（memcache或redis），每个页面对nosql的请求远大于直接对DB的请求</li><li>2000： 业务分离，做分布式存储</li></ol><h3 id="二、优化方案"><a href="#二、优化方案" class="headerlink" title="二、优化方案"></a>二、优化方案</h3><ul><li>流量优化：  </li></ul><ol><li>防盗链处理 </li><li>减少前端http请求（合并css、js等静态资源）</li><li>添加异步请求，减少http请求的并发量</li><li>启用浏览器的缓存和使用文件压缩</li><li>CDN加速，减轻服务器压力和带宽压力<ul><li>服务端优化  </li></ul><ol><li>页面静态化</li><li>并发处理</li></ol><ul><li>数据库优化  </li></ul><ol><li>数据库缓存</li><li>分库分表，分区操作</li><li>读写分离</li><li>负载均衡</li></ol><ul><li>web服务器优化  </li></ul><ol><li>负载均衡</li></ol></li></ol>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入理解PHP之：Nginx 与 FPM 的工作机制</title>
      <link href="/2019/02/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E4%B9%8B%EF%BC%9ANginx-%E4%B8%8E-FPM-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/02/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E4%B9%8B%EF%BC%9ANginx-%E4%B8%8E-FPM-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>网络上有很多关于如何配置 Nginx + FPM 的文章，但它们更多从操作的角度出发，告诉我们怎么做，但却没有告诉我们为什么要这么做，本文从 Nginx 与 FPM 的工作机制出发，探讨配置背后的原理，让我们真正理解 Nginx 与 PHP 是如何协同工作的。</p><h4 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h4><p>要说 Nginx 与 PHP 是如何协同工作的，首先得说 CGI (Common Gateway Interface) 和 FastCGI 这两个协议。</p><a id="more"></a><blockquote><p>CGI 是 Web Server 与后台语言交互的协议，有了这个协议，开发者可以使用任何语言处理 Web Server 发来的请求，动态的生成内容。但 CGI 有一个致命的缺点，那就是每处理一个请求都需要 fork 一个全新的进程，随着 Web 的兴起，高并发越来越成为常态，这样低效的方式明显不能满足需求。就这样，FastCGI 诞生了，CGI 很快就退出了历史的舞台。FastCGI，顾名思义为更快的 CGI，它允许在一个进程内处理多个请求，而不是一个请求处理完毕就直接结束进程，性能上有了很大的提高。</p></blockquote><p>FPM (FastCGI Process Manager)，它是 FastCGI 的实现，任何实现了 FastCGI 协议的 Web Server 都能够与之通信。FPM 之于标准的 FastCGI，也提供了一些增强功能，具体可以参考官方文档：PHP: FPM Installation。</p><pre><code>FPM 是一个 PHP 进程管理器，包含 master 进程和 worker 进程两种进程：master 进程只有一个，负责监听端口，接收来自 Web Server 的请求，而 worker 进程则一般有多个 (具体数量根据实际需要配置)，每个进程内部都嵌入了一个 PHP 解释器，是 PHP 代码真正执行的地方，下图是我本机上 fpm 的进程情况，1一个 master 进程，3个 worker 进程：</code></pre><p><img src="http://img0.ph.126.net/WMv1Zu5I-rlmKMoUTc68-Q==/6631597730303787300.png" alt="fpm进程"></p><p>从 FPM 接收到请求，到处理完毕，其具体的流程如下：</p><pre><code>1. FPM 的 master 进程接收到请求2. master 进程根据配置指派特定的 worker进程进行请求处理，如果没有可用进程，返回错误，这也是我们配合 Nginx 遇到502错误比较多的原因。3. worker 进程处理请求，如果超时，返回504错误4. 请求处理结束，返回结果</code></pre><p>FPM 从接收到处理请求的流程就是这样了，那么 Nginx 又是如何发送请求给 fpm 的呢？这就需要从 Nginx 层面来说明了。</p><p>Nginx 不仅仅是一个 Web 服务器，也是一个功能强大的 Proxy 服务器，除了进行 http 请求的代理，也可以进行许多其他协议请求的代理，包括本文与 fpm 相关的 fastcgi 协议。为了能够使 Nginx 理解 fastcgi 协议，Nginx 提供了 fastcgi 模块来将 http 请求映射为对应的 fastcgi 请求。</p><blockquote><p>Nginx 的 fastcgi 模块提供了 fastcgi_param 指令来主要处理这些映射关系，下面 Ubuntu 下 Nginx 的一个配置文件，其主要完成的工作是将 Nginx 中的变量翻译成 PHP 中能够理解的变量。</p></blockquote><p><img src="http://img2.ph.126.net/QWqq90MIXEcQnTA7ft1WVg==/6631819831652599451.jpg" alt="fastcgi_param"></p><p>除此之外，非常重要的就是 fastcgi_pass 指令了，这个指令用于指定 fpm 进程监听的地址，Nginx 会把所有的 php 请求翻译成 fastcgi 请求之后再发送到这个地址。下面一个简单的可以工作的 Nginx 配置文件：</p><p><img src="http://img0.ph.126.net/tLal8xnxIanLB_mfp2dHUQ==/6631751661931678563.jpg" alt="nginx配置"></p><p>在这个配置文件中，我们新建了一个虚拟主机，监听在 80 端口，Web 根目录为 /home/rf/projects/wordpress。然后我们通过 location 指令，将所有的以 .php 结尾的请求都交给 fastcgi 模块处理，从而把所有的 php 请求都交给了 fpm 处理，从而完成 Nginx 到 fpm 的闭环。</p><p>如此以来，Nginx 与 FPM 通信的整个流程应该比较清晰了吧。</p><ol><li>nginx是web服务器，提供http服务。</li><li>php代码需要php解析器解析。所以这里要有个nginx和php解析器通信的问题。就出现了一个fastcgi的协议来解决通信问题。</li></ol>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Nginx </tag>
            
            <tag> FPM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LVS负载均衡（LVS简介、三种工作模式、十种调度算法）</title>
      <link href="/2019/01/25/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%88LVS%E7%AE%80%E4%BB%8B%E3%80%81%E4%B8%89%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E3%80%81%E5%8D%81%E7%A7%8D%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%89/"/>
      <url>/2019/01/25/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%88LVS%E7%AE%80%E4%BB%8B%E3%80%81%E4%B8%89%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E3%80%81%E5%8D%81%E7%A7%8D%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="一、LVS简介"><a href="#一、LVS简介" class="headerlink" title="一、LVS简介"></a>一、LVS简介</h3><p>LVS（Linux Virtual Server）即Linux虚拟服务器，是由章文嵩博士主导的开源负载均衡项目，目前LVS已经被集成到Linux内核模块中。</p><p>该项目在Linux内核中实现了基于IP的数据请求负载均衡调度方案，终端互联网用户从外部访问公司的外部负载均衡服务器，终端用户的Web请求会发送给LVS调度器，调度器根据自己预设的算法决定将该请求发送给后端的某台Web服务器，比如，轮询算法可以将外部的请求平均分发给后端的所有服务器，终端用户访问LVS调度器虽然会被转发到后端真实的服务器，但如果真实服务器连接的是相同的存储，提供的服务也是相同的服务，最终用户不管是访问哪台真实服务器，得到的服务内容都是一样的，整个集群对用户而言都是透明的。</p><a id="more"></a><blockquote><p> 最后根据LVS工作模式的不同，真实服务器会选择不同的方式将用户需要的数据发送到终端用户，LVS工作模式分为NAT模式、TUN模式、以及DR模式。</p></blockquote><h3 id="二、三种工作模式的解析。"><a href="#二、三种工作模式的解析。" class="headerlink" title="二、三种工作模式的解析。"></a>二、三种工作模式的解析。</h3><h5 id="1、基于NAT的LVS模式负载均衡"><a href="#1、基于NAT的LVS模式负载均衡" class="headerlink" title="1、基于NAT的LVS模式负载均衡"></a>1、基于NAT的LVS模式负载均衡</h5><p> NAT（Network Address Translation）即网络地址转换，其作用是通过数据报头的修改，使得位于企业内部的私有IP地址可以访问外网，以及外部用用户可以访问位于公司内部的私有IP主机。VS/NAT工作模式拓扑结构如图2所示，LVS负载调度器可以使用两块网卡配置不同的IP地址，eth0设置为私钥IP与内部网络通过交换设备相互连接，eth1设备为外网IP与外部网络联通。</p><ul><li>第一步，用户通过互联网DNS服务器解析到公司负载均衡设备上面的外网地址，相对于真实服务器而言，LVS外网IP又称VIP（Virtual IP Address），用户通过访问VIP，即可连接后端的真实服务器（Real Server），而这一切对用户而言都是透明的，用户以为自己访问的就是真实服务器，但他并不知道自己访问的VIP仅仅是一个调度器，也不清楚后端的真实服务器到底在哪里、有多少真实服务器。</li><li>第二步，用户将请求发送至124.126.147.168，此时LVS将根据预设的算法选择后端的一台真实服务器（192.168.0.1~192.168.0.3），将数据请求包转发给真实服务器，并且在转发之前LVS会修改数据包中的目标地址以及目标端口，目标地址与目标端口将被修改为选出的真实服务器IP地址以及相应的端口。</li><li>第三步，真实的服务器将响应数据包返回给LVS调度器，调度器在得到响应的数据包后会将源地址和源端口修改为VIP及调度器相应的端口，修改完成后，由调度器将响应数据包发送回终端用户，另外，由于LVS调度器有一个连接Hash表，该表中会记录连接请求及转发信息，当同一个连接的下一个数据包发送给调度器时，从该Hash表中可以直接找到之前的连接记录，并根据记录信息选出相同的真实服务器及端口信息。</li></ul><h5 id="2、基于TUN的LVS负载均衡"><a href="#2、基于TUN的LVS负载均衡" class="headerlink" title="2、基于TUN的LVS负载均衡"></a>2、基于TUN的LVS负载均衡</h5><p>在LVS（NAT）模式的集群环境中，由于所有的数据请求及响应的数据包都需要经过LVS调度器转发，如果后端服务器的数量大于10台，则调度器就会成为整个集群环境的瓶颈。我们知道，数据请求包往往远小于响应数据包的大小。因为响应数据包中包含有客户需要的具体数据，所以LVS（TUN）的思路就是将请求与响应数据分离，让调度器仅处理数据请求，而让真实服务器响应数据包直接返回给客户端。</p><p>VS/TUN工作模式拓扑结构如图3所示。其中，IP隧道（IP tunning）是一种数据包封装技术，它可以将原始数据包封装并添加新的包头（内容包括新的源地址及端口、目标地址及端口），从而实现将一个目标为调度器的VIP地址的数据包封装，通过隧道转发给后端的真实服务器（Real Server），通过将客户端发往调度器的原始数据包封装，并在其基础上添加新的数据包头（修改目标地址为调度器选择出来的真实服务器的IP地址及对应端口），LVS（TUN）模式要求真实服务器可以直接与外部网络连接，真实服务器在收到请求数据包后直接给客户端主机响应数据。</p><h5 id="3、基于DR的LVS负载均衡"><a href="#3、基于DR的LVS负载均衡" class="headerlink" title="3、基于DR的LVS负载均衡"></a>3、基于DR的LVS负载均衡</h5><p>在LVS（TUN）模式下，由于需要在LVS调度器与真实服务器之间创建隧道连接，这同样会增加服务器的负担。与LVS（TUN）类似，DR模式也叫直接路由模式，其体系结构如图4所示，该模式中LVS依然仅承担数据的入站请求以及根据算法选出合理的真实服务器，最终由后端真实服务器负责将响应数据包发送返回给客户端。与隧道模式不同的是，直接路由模式（DR模式）要求调度器与后端服务器必须在同一个局域网内，VIP地址需要在调度器与后端所有的服务器间共享，因为最终的真实服务器给客户端回应数据包时需要设置源IP为VIP地址，目标IP为客户端IP，这样客户端访问的是调度器的VIP地址，回应的源地址也依然是该VIP地址（真实服务器上的VIP），客户端是感觉不到后端服务器存在的。由于多台计算机都设置了同样一个VIP地址，所以在直接路由模式中要求调度器的VIP地址是对外可见的，客户端需要将请求数据包发送到调度器主机，而所有的真实服务器的VIP地址必须配置在Non-ARP的网络设备上，也就是该网络设备并不会向外广播自己的MAC及对应的IP地址，真实服务器的VIP对外界是不可见的，但真实服务器却可以接受目标地址VIP的网络请求，并在回应数据包时将源地址设置为该VIP地址。调度器根据算法在选出真实服务器后，在不修改数据报文的情况下，将数据帧的MAC地址修改为选出的真实服务器的MAC地址，通过交换机将该数据帧发给真实服务器。整个过程中，真实服务器的VIP不需要对外界可见。</p><h3 id="三、LVS负载均衡调度算法"><a href="#三、LVS负载均衡调度算法" class="headerlink" title="三、LVS负载均衡调度算法"></a>三、LVS负载均衡调度算法</h3><p>根据前面的介绍，我们了解了LVS的三种工作模式，但不管实际环境中采用的是哪种模式，调度算法进行调度的策略与算法都是LVS的核心技术，LVS在内核中主要实现了一下十种调度算法。</p><h5 id="1-轮询调度"><a href="#1-轮询调度" class="headerlink" title="1.轮询调度"></a>1.轮询调度</h5><p>轮询调度（Round Robin 简称’RR’）算法就是按依次循环的方式将请求调度到不同的服务器上，该算法最大的特点就是实现简单。轮询算法假设所有的服务器处理请求的能力都一样的，调度器会将所有的请求平均分配给每个真实服务器。</p><h5 id="2-加权轮询调度"><a href="#2-加权轮询调度" class="headerlink" title="2.加权轮询调度"></a>2.加权轮询调度</h5><p>加权轮询（Weight Round Robin 简称’WRR’）算法主要是对轮询算法的一种优化与补充，LVS会考虑每台服务器的性能，并给每台服务器添加一个权值，如果服务器A的权值为1，服务器B的权值为2，则调度器调度到服务器B的请求会是服务器A的两倍。权值越高的服务器，处理的请求越多。</p><h5 id="3-最小连接调度"><a href="#3-最小连接调度" class="headerlink" title="3.最小连接调度"></a>3.最小连接调度</h5><p>最小连接调度（Least Connections 简称’LC’）算法是把新的连接请求分配到当前连接数最小的服务器。最小连接调度是一种动态的调度算法，它通过服务器当前活跃的连接数来估计服务器的情况。调度器需要记录各个服务器已建立连接的数目，当一个请求被调度到某台服务器，其连接数加1；当连接中断或者超时，其连接数减1。</p><p>（集群系统的真实服务器具有相近的系统性能，采用最小连接调度算法可以比较好地均衡负载。)</p><h5 id="4-加权最小连接调度"><a href="#4-加权最小连接调度" class="headerlink" title="4.加权最小连接调度"></a>4.加权最小连接调度</h5><p>加权最少连接（Weight Least Connections 简称’WLC’）算法是最小连接调度的超集，各个服务器相应的权值表示其处理性能。服务器的缺省权值为1，系统管理员可以动态地设置服务器的权值。加权最小连接调度在调度新连接时尽可能使服务器的已建立连接数和其权值成比例。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。</p><h5 id="5-基于局部的最少连接"><a href="#5-基于局部的最少连接" class="headerlink" title="5.基于局部的最少连接"></a>5.基于局部的最少连接</h5><p>基于局部的最少连接调度（Locality-Based Least Connections 简称’LBLC’）算法是针对请求报文的目标IP地址的 负载均衡调度，目前主要用于Cache集群系统，因为在Cache集群客户请求报文的目标IP地址是变化的。这里假设任何后端服务器都可以处理任一请求，算法的设计目标是在服务器的负载基本平衡情况下，将相同目标IP地址的请求调度到同一台服务器，来提高各台服务器的访问局部性和Cache命中率，从而提升整个集群系统的处理能力。LBLC调度算法先根据请求的目标IP地址找出该目标IP地址最近使用的服务器，若该服务器是可用的且没有超载，将请求发送到该服务器；若服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则使用’最少连接’的原则选出一个可用的服务器，将请求发送到服务器。</p><h5 id="6-带复制的基于局部性的最少连接"><a href="#6-带复制的基于局部性的最少连接" class="headerlink" title="6.带复制的基于局部性的最少连接"></a>6.带复制的基于局部性的最少连接</h5><p>带复制的基于局部性的最少连接（Locality-Based Least Connections with Replication  简称’LBLCR’）算法也是针对目标IP地址的负载均衡，目前主要用于Cache集群系统，它与LBLC算法不同之处是它要维护从一个目标IP地址到一组服务器的映射，而LBLC算法维护从一个目标IP地址到一台服务器的映射。按’最小连接’原则从该服务器组中选出一一台服务器，若服务器没有超载，将请求发送到该服务器；若服务器超载，则按’最小连接’原则从整个集群中选出一台服务器，将该服务器加入到这个服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。</p><h5 id="7-目标地址散列调度"><a href="#7-目标地址散列调度" class="headerlink" title="7.目标地址散列调度"></a>7.目标地址散列调度</h5><p>目标地址散列调度（Destination Hashing 简称’DH’）算法先根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且并未超载，将请求发送到该服务器，否则返回空。</p><h5 id="8-源地址散列调度U"><a href="#8-源地址散列调度U" class="headerlink" title="8.源地址散列调度U"></a>8.源地址散列调度U</h5><p>源地址散列调度（Source Hashing  简称’SH’）算法先根据请求的源IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且并未超载，将请求发送到该服务器，否则返回空。它采用的散列函数与目标地址散列调度算法的相同，它的算法流程与目标地址散列调度算法的基本相似。</p><h5 id="9-最短的期望的延迟"><a href="#9-最短的期望的延迟" class="headerlink" title="9.最短的期望的延迟"></a>9.最短的期望的延迟</h5><p>最短的期望的延迟调度（Shortest Expected Delay 简称’SED’）算法基于WLC算法。举个例子吧，ABC三台服务器的权重分别为1、2、3 。那么如果使用WLC算法的话一个新请求进入时它可能会分给ABC中的任意一个。使用SED算法后会进行一个运算</p><p>A：（1+1）/1=2   B：（1+2）/2=3/2   C：（1+3）/3=4/3   就把请求交给得出运算结果最小的服务器。</p><h5 id="10-最少队列调度"><a href="#10-最少队列调度" class="headerlink" title="10.最少队列调度"></a>10.最少队列调度</h5><p>最少队列调度（Never Queue 简称’NQ’）算法，无需队列。如果有realserver的连接数等于0就直接分配过去，不需要在进行SED运算。</p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于流量优化方案</title>
      <link href="/2019/01/11/%E5%85%B3%E4%BA%8E%E6%B5%81%E9%87%8F%E4%BC%98%E5%8C%96/"/>
      <url>/2019/01/11/%E5%85%B3%E4%BA%8E%E6%B5%81%E9%87%8F%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h3 id="一、防盗链"><a href="#一、防盗链" class="headerlink" title="一、防盗链"></a>一、防盗链</h3><h5 id="盗链"><a href="#盗链" class="headerlink" title="盗链"></a>盗链</h5><blockquote><p>在自己的页面上展示一些并不在自己服务器上的内容。<br>获取他人服务器上的资源地址，绕过别人的资源展示页面，直接在自己的页面上向用户输出<br>防盗链则是防止别人通过技术手段盗取本站的资源，让不是本站展示的资源链接失效</p></blockquote><a id="more"></a><h5 id="防盗链原理："><a href="#防盗链原理：" class="headerlink" title="防盗链原理："></a>防盗链原理：</h5><p>通过referer或者签名（在资源地址后面带上一串签名，每次收到请求验证签名），网站可以检测目标访问的来源网页，如果是资源文件，则可以跟踪到他显示的网页地址。一旦检测到来源不是本站则进行组织或者返回指定页面。</p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><blockquote><p>Referer</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Nginx模块 ngx_http_referer_module 用来阻挡来源非法的域名请求</span><br><span class="line">Nginx指令 valid_referers 全局变量$invalid_referer</span><br><span class="line"></span><br><span class="line">valid_referers none|blocked|server_names|string....;</span><br><span class="line">none: referer 来源头部为空</span><br><span class="line">blocked: referer不为空，但是里面的值被代理或者防火墙删除了，这些值并不以http：//或者https://开头</span><br><span class="line">server_names: referer来源头部包含当前的server_names</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">location ~ .*\.(gif|jpeg|png|flv|swf|rar|zip)$</span><br><span class="line">&#123;</span><br><span class="line">    valid_referer none blocked haobin.com *.haobin.com;</span><br><span class="line">    if($invalid_referer)</span><br><span class="line">    &#123;</span><br><span class="line">        #return 403;</span><br><span class="line">        rewrite ^/http://www.haobin.com/403.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="如果有人伪造referer，可以通过签名的方法解决"><a href="#如果有人伪造referer，可以通过签名的方法解决" class="headerlink" title="如果有人伪造referer，可以通过签名的方法解决"></a>如果有人伪造referer，可以通过签名的方法解决</h5><blockquote><p>加密签名</p></blockquote><p>通过第三方模块HttpAccessKeyModule实现Nginx防盗链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">首先安装这个模块</span><br><span class="line">accesskey on|off    模块开关</span><br><span class="line">accesskey_hashmethod md5 | sha-1    指定签名加密方式</span><br><span class="line">accesskey_arg    GET参数的名称</span><br><span class="line">accesskey_signature     加密规则</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">location ~ .*\.(gif|jpeg|png|flv|swf|zip|rar)$</span><br><span class="line">&#123;</span><br><span class="line">    accesskey on;</span><br><span class="line">    accesskey_hashmethod md5;</span><br><span class="line">    accesskey_arg &quot;key&quot;;</span><br><span class="line">    accesskey_signature &quot;sign$remote_addr&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、减少HTTP请求"><a href="#二、减少HTTP请求" class="headerlink" title="二、减少HTTP请求"></a>二、减少HTTP请求</h3><h5 id="性能黄金法则："><a href="#性能黄金法则：" class="headerlink" title="性能黄金法则："></a>性能黄金法则：</h5><p>只有10%-20%的最终用户响应时间花在接受请求的HTML文档上，剩下的80%-90%时间花在HTML文档所引用的组件（图片、css、script等）进行的http请求上</p><h5 id="1-图片地图：允许在一个图片上关联多个url，目标的url选择取决于用户单击了图片上的哪个位置。"><a href="#1-图片地图：允许在一个图片上关联多个url，目标的url选择取决于用户单击了图片上的哪个位置。" class="headerlink" title="1.图片地图：允许在一个图片上关联多个url，目标的url选择取决于用户单击了图片上的哪个位置。"></a>1.图片地图：允许在一个图片上关联多个url，目标的url选择取决于用户单击了图片上的哪个位置。</h5><p>例如有五张图片，每张图片对应一个超链接。此时就产生了五个http请求，我们将五张图片合成为一张图片，然后以图片的位置定位超链接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">实现</span><br><span class="line">&lt;map&gt;</span><br><span class="line">    &lt;area&gt;&lt;/area&gt;</span><br><span class="line">    &lt;area&gt;&lt;/area&gt;</span><br><span class="line">    &lt;area&gt;&lt;/area&gt;</span><br><span class="line">    ........</span><br><span class="line">&lt;/map&gt;</span><br></pre></td></tr></table></figure><h5 id="2-CSS-Sprites（CSS-精灵）"><a href="#2-CSS-Sprites（CSS-精灵）" class="headerlink" title="2.CSS Sprites（CSS 精灵）"></a>2.CSS Sprites（CSS 精灵）</h5><p>通过使用合并图片，指定css的background-image和background-position来显示元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background-position属性</span><br><span class="line">background-position:x,y; x和y可以写正值也可以写负值，我们可以想象图片左上方(0,0)，以(0,0)坐标向右的是负数的x轴，以(0,0)坐标向下的是负数的y轴</span><br></pre></td></tr></table></figure><h5 id="3-合并脚本和样式表"><a href="#3-合并脚本和样式表" class="headerlink" title="3.合并脚本和样式表"></a>3.合并脚本和样式表</h5><h5 id="4-图片使用base64编码减少页面请求数"><a href="#4-图片使用base64编码减少页面请求数" class="headerlink" title="4.图片使用base64编码减少页面请求数"></a>4.图片使用base64编码减少页面请求数</h5><blockquote><p>采用Base64编码直接将图片嵌入网页当中</p></blockquote><h3 id="三、浏览器缓存和压缩技术"><a href="#三、浏览器缓存和压缩技术" class="headerlink" title="三、浏览器缓存和压缩技术"></a>三、浏览器缓存和压缩技术</h3><h5 id="1-HTTP缓存分类"><a href="#1-HTTP缓存分类" class="headerlink" title="1.HTTP缓存分类"></a>1.HTTP缓存分类</h5><blockquote><p>http缓存类型中，请求成功会有三种情况：</p></blockquote><pre><code>200 from cache：直接从本地缓存中获取相应，最快速，最省流量（network的size字段）  304 not modify： 协商缓存，浏览器在没有命中的情况下请求头中发送一定的校验数据到服务端，如果服务端没有改变，浏览器从本地缓存相应，返回304。 该方式，只返回一些基本的头信息，不发送实际的相应体200 ok： 以上两种缓存失败，服务器返回完整的相应。 该方式没有用到缓存，是最慢的。</code></pre><h5 id="2-本地缓存"><a href="#2-本地缓存" class="headerlink" title="2.本地缓存"></a>2.本地缓存</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Pragma： HTTP1.0的属性，该字段设置为no-cache，会告知浏览器禁用本地缓存</span><br><span class="line"></span><br><span class="line">Expires: HTTP1.0的属性，用来启用本地缓存。expires的值对应为一个类似</span><br><span class="line">Thu, 31 Dec 2017 20:11:20 GMT的格林威治时间，告诉浏览器如果还没有到该时间，则缓存有效，无须发送请求。这个时间是服务器返回的，是以服务器的时间为基准，如果服务器和客户端的时间不一致就可能产生差错。</span><br><span class="line"></span><br><span class="line">Cache-Control: 告知浏览器缓存过期的时间间隔。</span><br><span class="line">no-store: 禁止浏览器缓存</span><br><span class="line">no-cache: 不允许直接使用本地缓存，先发起请求和服务器协商</span><br><span class="line">max-age=delta-seconds: 告知浏览器响应本地缓存的最长期限，以秒为单位</span><br><span class="line"></span><br><span class="line">优先级：Pragrma &gt; Cache-Control &gt; Expires</span><br></pre></td></tr></table></figure><h5 id="3-协商缓存"><a href="#3-协商缓存" class="headerlink" title="3.协商缓存"></a>3.协商缓存</h5><blockquote><p>浏览器没有命中本地缓存，如果本地缓存过期或者响应不允许直接使用本地缓存，那么浏览器会发起服务端请求，服务端会验证数据是否被修改，如果没有被修改就通知浏览器使用本地缓存</p></blockquote><p>相关的Header：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: 通知浏览器资源的最后修改时间（一个格林威治时间）</span><br><span class="line">If-Modified-Since: 得到资源最后修改时间后，会将这个If-Modified-Since（Last-Modified的值）提交到服务器做检查，如果没有修改，就返回304</span><br><span class="line"></span><br><span class="line">ETag: HTTP1.1属性，指纹标识符，如果文件发生更改，指纹会改变</span><br><span class="line">If-None_Match: 本地缓存失效，会携带此值（ETage 的值）去请求服务端，服务端判断资源是否改变，如果没有改变，直接使用本地缓存，返回304</span><br></pre></td></tr></table></figure><h5 id="4-缓存对象的选择"><a href="#4-缓存对象的选择" class="headerlink" title="4.缓存对象的选择"></a>4.缓存对象的选择</h5><ul><li>不变的内容适合本地缓存：图像，js，css，可下载的媒体文件等</li><li>适合协商缓存的文件：HTML文件，经常替换的图片，经常修改的js、css等文件</li></ul><h5 id="5-Nginx配置缓存策略"><a href="#5-Nginx配置缓存策略" class="headerlink" title="5.Nginx配置缓存策略"></a>5.Nginx配置缓存策略</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*****通过PHP模拟Last-Modified-&gt;If-Modified-Since模式******</span><br><span class="line">// 读取上一次修改时间</span><br><span class="line">$since = $_SERVER[&apos;HTTP_IF_MODIFIED-SINCE&apos;];</span><br><span class="line">$lifetime = 3600; // 模拟缓存一分钟</span><br><span class="line">// 如果没过期就返回304</span><br><span class="line">if(strtotime($since) + $lifetiem &gt; time())&#123;</span><br><span class="line">    header(&apos;HTTP/1.1 304 NOT MODIFIED&apos;);</span><br><span class="line">    exit;</span><br><span class="line">&#125;</span><br><span class="line">// 返回Last-Modified相应头</span><br><span class="line">header(&apos;Last-Modified: &apos;.gmdate(&apos;D, d M Y H:i:s&apos;, time())). &apos;GMT&apos;);</span><br></pre></td></tr></table></figure><h5 id="Nginx缓存配置："><a href="#Nginx缓存配置：" class="headerlink" title="Nginx缓存配置："></a>Nginx缓存配置：</h5><blockquote><p>本地缓存配置指令：  </p></blockquote><pre><code>add_header： 添加状态码为2XX和3XX的响应头  add_header name value \[always]; 语法格式  可以通过该指令来设置Pragma/Expires/Cache-Control</code></pre><blockquote><p>expires指令： 通知浏览器过期时长  </p></blockquote><pre><code>expires time;  语法格式  为负值表示Cache-Control: no-cache   为正直表示Cache-Control:max-age=指定时间 </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Nginx缓存配置：</span><br><span class="line"># 遇到图片等资源就缓存30天</span><br><span class="line">location ~ .*\.(gif|jpeg|png|flv|swf|zip|rar)$</span><br><span class="line">&#123;</span><br><span class="line">    expires     30d;</span><br><span class="line">&#125;</span><br><span class="line">$ 遇到js/css等资源就缓存12小时</span><br><span class="line">location ~ .*\.(js|css)?$</span><br><span class="line">&#123;</span><br><span class="line">    expires     12h;</span><br><span class="line">&#125;</span><br><span class="line"># expires   max; 代表设置十年的缓存</span><br></pre></td></tr></table></figure><blockquote><p>Nginx协商缓存配置：  </p></blockquote><ul><li>ETage指令： 指定签名 </li><li>etage: on|off; 开关，默认是on</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.(gif|jpeg|png|flv|swf|zip|rar)$</span><br><span class="line">&#123;</span><br><span class="line">    # 默认是开启的</span><br><span class="line">    etag     off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-前端代码和资源的压缩"><a href="#6-前端代码和资源的压缩" class="headerlink" title="6.前端代码和资源的压缩"></a>6.前端代码和资源的压缩</h5><ul><li>JavaScript压缩：去掉多余的空格和回车，替换长变量名，简写代码等</li><li>CSS压缩： 同样是去掉空白符、注释并且优化CSS语义规则</li><li>图片压缩： 借助压缩工具压缩（tinypng、jpegMini、imageoption等）</li><li>Gzip压缩</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Nginx配置:</span><br><span class="line">gizp on|off;    #是否开启gzip</span><br><span class="line">gzip_buffers 32 4K|16 8k #缓冲（在内存中有几块 每块多大）</span><br><span class="line">gzip_comp_level [1-9] #压缩级别（推荐使用6） 级别越高，压缩越小，越占用CPU资源</span><br><span class="line">gzip_disable #正则表达式匹配UA 什么样的uri不进行gzip </span><br><span class="line">gzip_min_length 200 #开始压缩的最小长度</span><br><span class="line">gzip_http_version 1.0|1.1 #开始压缩的http版本协议</span><br><span class="line">gzip_types text/plain application/xml #对那些类型进行压缩，如text、css、html等</span><br></pre></td></tr></table></figure><p>现在前端有很多工具可以对资源进行压缩，打包等。如grunt、webpack等已经很流行了。比较流行的前端框架也有相应的脚手架来帮助打包：vue-cli、angular-cli等</p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> 流量 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分区、分表、分库、分片入门</title>
      <link href="/2018/12/23/%E5%88%86%E5%8C%BA%E3%80%81%E5%88%86%E8%A1%A8%E3%80%81%E5%88%86%E5%BA%93%E3%80%81%E5%88%86%E7%89%87%E5%85%A5%E9%97%A8/"/>
      <url>/2018/12/23/%E5%88%86%E5%8C%BA%E3%80%81%E5%88%86%E8%A1%A8%E3%80%81%E5%88%86%E5%BA%93%E3%80%81%E5%88%86%E7%89%87%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h3 id="一、分区的概念"><a href="#一、分区的概念" class="headerlink" title="一、分区的概念"></a>一、分区的概念</h3><p>数据分区是一种物理数据库的设计技术，它的目的是为了在特定的SQL操作中减少数据读写的总量以缩减响应时间。</p><p>分区并不是生成新的数据表，而是将表的数据均衡分摊到不同的硬盘，系统或是不同服务器存储介子中，实际上还是一张表。另外，分区可以做到将表的数据均衡到不同的地方，提高数据检索的效率，降低数据库的频繁IO压力值，分区的优点如下：</p><a id="more"></a><ul><li>1、相对于单个文件系统或是硬盘，分区可以存储更多的数据；</li><li>2、数据管理比较方便，比如要清理或废弃某年的数据，就可以直接删除该日期的分区数据即可；</li><li>3、精准定位分区查询数据，不需要全表扫描查询，大大提高数据检索效率；</li><li>4、可跨多个分区磁盘查询，来提高查询的吞吐量；</li><li>5、在涉及聚合函数查询时，可以很容易进行数据的合并；</li></ul><h3 id="二、分类-（row-行-，column-列）"><a href="#二、分类-（row-行-，column-列）" class="headerlink" title="二、分类 （row 行 ，column 列）"></a>二、分类 （row 行 ，column 列）</h3><ul><li>1、水平分区</li></ul><p>这种形式分区是对表的行进行分区，通过这样的方式不同分组里面的物理列分割的数据集得以组合，从而进行个体分割（单分区）或集体分割（1个或多个分区）。所有在表中定义的列在每个数据集中都能找到，所以表的特性依然得以保持。</p><blockquote><p>举个简单例子：一个包含十年发票记录的表可以被分区为十个不同的分区，每个分区包含的是其中一年的记录。（朋奕注：这里具体使用的分区方式我们后面再说，可以先说一点，一定要通过某个属性列来分割，譬如这里使用的列就是年份）</p></blockquote><ul><li>2、垂直分区</li></ul><p>这种分区方式一般来说是通过对表的垂直划分来减少目标表的宽度，使某些特定的列被划分到特定的分区，每个分区都包含了其中的列所对应的行。</p><blockquote><p>举个简单例子：一个包含了大text和BLOB列的表，这些text和BLOB列又不经常被访问，这时候就要把这些不经常使用的text和BLOB了划分到另一个分区，在保证它们数据相关性的同时还能提高访问速度。</p></blockquote><p>在数据库供应商开始在他们的数据库引擎中建立分区（主要是水平分区）时，DBA和建模者必须设计好表的物理分区结构，不要保存冗余的数据（不同表中同时都包含父表中的数据）或相互联结成一个逻辑父对象（通常是视图）。这种做法会使水平分区的大部分功能失效，有时候也会对垂直分区产生影响。</p><h3 id="三、分片、分区、分表、分库的详细理解"><a href="#三、分片、分区、分表、分库的详细理解" class="headerlink" title="三、分片、分区、分表、分库的详细理解"></a>三、分片、分区、分表、分库的详细理解</h3><h5 id="一、什么是分片、分区、分表、分库"><a href="#一、什么是分片、分区、分表、分库" class="headerlink" title="一、什么是分片、分区、分表、分库"></a>一、什么是分片、分区、分表、分库</h5><ul><li>分片</li></ul><p>当数据库数据达到上亿级别时，数据库压力会很大，存不下，可以考虑使用数据库分片。</p><ul><li>分区</li></ul><p>就是把一张表的数据分成N个区块，在逻辑上看最终只是一张表，但底层是由N个物理区块组成的</p><ul><li>分表</li></ul><p>就是把一张表按一定的规则分解成N个具有独立存储空间的实体表。系统读写时需要根据定义好的规则得到对应的字表明，然后操作它。</p><ul><li>分库</li></ul><p>一旦分表，一个库中的表会越来越多</p><blockquote><p>将整个数据库比作图书馆，一张表就是一本书。当要在一本书中查找某项内容时，如果不分章节，查找的效率将会下降。而同理，在数据库中就是分区。</p></blockquote><h5 id="常用的单机数据库的瓶颈"><a href="#常用的单机数据库的瓶颈" class="headerlink" title="常用的单机数据库的瓶颈"></a>常用的单机数据库的瓶颈</h5><ul><li>问题描述<ul><li>单个表数据量越大，读写锁，插入操作重新建立索引效率越低。</li><li>单个库数据量太大（一个数据库数据量到1T-2T就是极限）</li><li>单个数据库服务器压力过大</li><li>读写速度遇到瓶颈（并发量几百）</li></ul></li></ul><h3 id="二、分片"><a href="#二、分片" class="headerlink" title="二、分片"></a>二、分片</h3><p>不同的表放到不同的 数据库中—垂直切割。</p><pre><code>数据量小，查询性能会提高。 不同数据库位于不同服务器上时，会减小服务器压力。</code></pre><p>单张表数据量也很大，如用户量大产生操作量也会很大。单独查询时，压力也会很大。此时垂直分割也无济于事。可以考虑–水平分割。</p><pre><code>一张表放到不同数据库中。用户表，放到不同数据库，每个数据库存储部分数据，单表数据量不大。</code></pre><h3 id="三、分区"><a href="#三、分区" class="headerlink" title="三、分区"></a>三、分区</h3><h5 id="什么时候考虑使用分区？"><a href="#什么时候考虑使用分区？" class="headerlink" title="什么时候考虑使用分区？"></a>什么时候考虑使用分区？</h5><ul><li>一张表的查询速度已经慢到影响使用的时候。</li><li>sql经过优化</li><li>数据量大</li><li>表中的数据是分段的</li><li>对数据的操作往往只涉及一部分数据，而不是所有的数据</li></ul><h5 id="分区解决的问题"><a href="#分区解决的问题" class="headerlink" title="分区解决的问题"></a>分区解决的问题</h5><p>​    </p><p>​    主要可以提升查询效率</p><h5 id="分区的实现方式（简单）"><a href="#分区的实现方式（简单）" class="headerlink" title="分区的实现方式（简单）"></a>分区的实现方式（简单）</h5><p>mysql5 开始支持分区功能</p><pre><code>CREATE TABLE sales (id INT AUTO_INCREMENT,amount DOUBLE NOT NULL,order_day DATETIME NOT NULL,PRIMARY KEY(id, order_day)) ENGINE=Innodb PARTITION BY RANGE(YEAR(order_day)) (PARTITION p_2010 VALUES LESS THAN (2010),PARTITION p_2011 VALUES LESS THAN (2011),PARTITION p_2012 VALUES LESS THAN (2012),PARTITION p_catchall VALUES LESS THAN MAXVALUE);</code></pre><blockquote><p> MySQL5.1提供的分区(Partition)功能确实可以实现表的分区，但是这种分区是局限在单个数据库范围里的，它不能跨越服务器的限制。</p></blockquote><p>如果能够保证数据量很难超过现有数据库服务器的物理承载量，那么只需利用MySQL5.1提供的分区(Partition)功能来改善数据库性能即可；否则，还是考虑应用Sharding理念吧，spider  storage engine就是一个不错的选择。</p><h5 id="Sharding与数据库分区-Partition-的区别"><a href="#Sharding与数据库分区-Partition-的区别" class="headerlink" title="Sharding与数据库分区(Partition)的区别　　"></a>Sharding与数据库分区(Partition)的区别　　</h5><blockquote><p> 有的时候，Sharding 也被近似等同于水平分区(Horizontal Partitioning)，网上很多地方也用水平分区来指代  Sharding，但我个人认为二者之间实际上还是有区别的。的确，Sharding  的思想是从分区的思想而来，但数据库分区基本上是数据对象级别的处理，比如表和索引的分区，每个子数据集上能够有不同的物理存储属性，还是单个数据库范围内的操作，而 Sharding 是能够跨数据库，甚至跨越物理机器的。</p></blockquote><h3 id="四、分表"><a href="#四、分表" class="headerlink" title="四、分表"></a>四、分表</h3><h5 id="什么时候考虑分表？"><a href="#什么时候考虑分表？" class="headerlink" title="什么时候考虑分表？"></a>什么时候考虑分表？</h5><ul><li>一张表的查询速度已经慢到影响使用的时候。</li><li>sql经过优化</li><li>数据量大</li><li>当频繁插入或者联合查询时，速度变慢</li></ul><h5 id="分表解决的问题"><a href="#分表解决的问题" class="headerlink" title="分表解决的问题"></a>分表解决的问题</h5><p>分表后，单表的并发能力提高了，磁盘I/O性能也提高了，写操作效率提高了</p><ul><li>查询一次的时间短了</li><li>数据分布在不同的文件，磁盘I/O性能提高</li><li>读写锁影响的数据量变小</li><li>插入数据库需要重新建立索引的数据减少</li></ul><h5 id="分表的实现方式（复杂）"><a href="#分表的实现方式（复杂）" class="headerlink" title="分表的实现方式（复杂）"></a>分表的实现方式（复杂）</h5><p>​    需要业务系统配合迁移升级，工作量较大</p><p>#####分区和分表的区别与联系</p><ul><li>分区和分表的目的都是减少数据库的负担，提高表的增删改查效率。</li><li>分区只是一张表中的数据的存储位置发生改变，分表是将一张表分成多张表。</li><li>当访问量大，且表数据比较大时，两种方式可以互相配合使用。</li><li>当访问量不大，但表数据比较多时，可以只进行分区。</li></ul><h5 id="常见分区分表的规则策略（类似）"><a href="#常见分区分表的规则策略（类似）" class="headerlink" title="常见分区分表的规则策略（类似）"></a>常见分区分表的规则策略（类似）</h5><ul><li>Range（范围）</li><li>Hash（哈希）</li><li>List（链表）</li><li>按照时间拆分</li><li>Hash之后按照分表个数取模</li><li>在认证库中保存数据库配置，就是建立一个DB，这个DB单独保存user_id到DB的映射关系</li></ul><h3 id="五、分库"><a href="#五、分库" class="headerlink" title="五、分库"></a>五、分库</h3><h5 id="什么时候考虑使用分库？"><a href="#什么时候考虑使用分库？" class="headerlink" title="什么时候考虑使用分库？"></a>什么时候考虑使用分库？</h5><ul><li>单台DB的存储空间不够</li><li>随着查询量的增加单台数据库服务器已经没办法支撑</li></ul><h5 id="分库解决的问题"><a href="#分库解决的问题" class="headerlink" title="分库解决的问题"></a>分库解决的问题</h5><p>​    其主要目的是为突破单节点数据库服务器的 I/O 能力限制，解决数据库扩展性问题。 </p><h5 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h5><p>将系统中不存在关联关系或者需要join的表可以放在不同的数据库不同的服务器中。</p><blockquote><p>按照业务垂直划分。比如：可以按照业务分为资金、会员、订单三个数据库。</p></blockquote><p>需要解决的问题：跨数据库的事务、jion查询等问题。</p><h5 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h5><p>例如，大部分的站点。数据都是和用户有关，那么可以根据用户，将数据按照用户水平拆分。</p><blockquote><p>按照规则划分，一般水平分库是在垂直分库之后的。比如每天处理的订单数量是海量的，可以按照一定的规则水平划分。需要解决的问题：数据路由、组装。</p></blockquote><h5 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h5><p>对于时效性不高的数据，可以通过读写分离缓解数据库压力。需要解决的问题：在业务上区分哪些业务上是允许一定时间延迟的，以及数据同步问题。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><blockquote><p>垂直分库–&gt;水平分库–&gt;读写分离</p></blockquote><h3 id="六、拆分之后面临新的问题"><a href="#六、拆分之后面临新的问题" class="headerlink" title="六、拆分之后面临新的问题"></a>六、拆分之后面临新的问题</h3><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ul><li>事务的支持，分库分表，就变成了分布式事务</li><li>join时跨库，跨表的问题</li><li>分库分表，读写分离使用了分布式，分布式为了保证强一致性，必然带来延迟，导致性能降低，系统的复杂度变高。</li></ul><h5 id="常用的解决方案："><a href="#常用的解决方案：" class="headerlink" title="常用的解决方案："></a>常用的解决方案：</h5><p>对于不同的方式之间没有严格的界限，特点不同，侧重点不同。需要根据实际情况，结合每种方式的特点来进行处理。</p><p>选用第三方的数据库中间件（Atlas，Mycat，TDDL，DRDS），同时业务系统需要配合数据存储的升级。</p><h3 id="七、数据存储的演进"><a href="#七、数据存储的演进" class="headerlink" title="七、数据存储的演进"></a>七、数据存储的演进</h3><h5 id="单库单表"><a href="#单库单表" class="headerlink" title="单库单表"></a>单库单表</h5><p>单库单表是最常见的数据库设计，例如，有一张用户(user)表放在数据库db中，所有的用户都可以在db库中的user表中查到。</p><h5 id="单库多表"><a href="#单库多表" class="headerlink" title="单库多表"></a>单库多表</h5><p>随着用户数量的增加，user表的数据量会越来越大，当数据量达到一定程度的时候对user表的查询会渐渐的变慢，从而影响整个DB的性能。如果使用mysql, 还有一个更严重的问题是，当需要添加一列的时候，mysql会锁表，期间所有的读写操作只能等待。</p><blockquote><p> 可以通过某种方式将user进行水平的切分，产生两个表结构完全一样的user_0000,user_0001等表，user_0000 + user_0001 + …的数据刚好是一份完整的数据。</p></blockquote><h5 id="多库多表"><a href="#多库多表" class="headerlink" title="多库多表"></a>多库多表</h5><p>随着数据量增加也许单台DB的存储空间不够，随着查询量的增加单台数据库服务器已经没办法支撑。这个时候可以再对数据库进行水平拆分。</p><h3 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h3><p>总的来说，优先考虑分区。当分区不能满足需求时，开始考虑分表，合理的分表对效率的提升会优于分区。</p><h5 id="基础数据存储"><a href="#基础数据存储" class="headerlink" title="基础数据存储"></a>基础数据存储</h5><p>Mysql：只存储非文本的基础信息。包括：评论状态，用户，时间等基础数据。以及图片，标签，点赞等附加信息。数据组织形式（不同的数据又可选择不同的库表拆分方案）：</p><ul><li>评论基础数据按用户ID进行拆库并拆表</li><li>图片及标签处于同一数据库下，根据商品编号分别进行拆表</li><li>其它的扩展信息数据，因数据量不大、访问量不高，处理于同一库下且不做分表即可</li></ul><h5 id="文本存储"><a href="#文本存储" class="headerlink" title="文本存储"></a>文本存储</h5><p>文本存储（评论的内容）使用了mongodb、hbase</p><ul><li>选择nosql而非mysql</li><li>减轻了mysql存储压力，释放msyql，庞大的存储也有了可靠的保障</li><li>nosql的高性能读写大大提升了系统的吞吐量并降低了延迟</li></ul>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 拓展 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JWT（JSON Web Token]）入门简介</title>
      <link href="/2018/12/16/JWT%EF%BC%88JSON-Web-Token-%EF%BC%89%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B/"/>
      <url>/2018/12/16/JWT%EF%BC%88JSON-Web-Token-%EF%BC%89%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="Jwt"><a href="#Jwt" class="headerlink" title="Jwt"></a>Jwt</h1><p><code>JWT</code>是（JSON Web Token]）的缩写，主要用来做用户身份验证的。</p><p>随着当前分布式应用、前后端分离的技术广泛使用，早年通过session管理用户状态的成本越来越高，session共享问题以及之后出现的token认证基本都是通过如Redis之类的中间件实现的。</p><blockquote><p>JWT通过将数据保存在客户端，每次请求时将token发送至服务端校验，服务端无需存储token，实现完全无状态化。</p></blockquote><a id="more"></a><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul><li>客户端登录请求认证</li><li>服务端认证通过后，生成包含数据的<code>JSON</code>对象，并将此对象进行签名生成<code>token</code></li><li>服务端将<code>token</code>返回客户端，客户端存储在本地，如cookie或localStorage</li><li>客户端下次请求时携带<code>token</code>到服务端，常用的是放在 HTTP 请求的头的Authorization字段中，<code>Authorization: Bearer &lt;token&gt;</code></li><li>服务端验证<code>token</code>有效性</li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><code>Token</code>是一个使用<code>.</code>分割的三部分组成的长字符串，<code>Header.Payload.Signature</code></p><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header是一个Base64URL之后的json对象，<code>{&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;}</code>，<code>alg</code>表示签名的算法（algorithm），默认是 <code>HMAC SHA256</code>（HS256），<code>typ</code>表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。</p><h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><p>Payload 也是一个Base64URL之后的JSON对象，用来存放传递的数据。JWT 规定了7个官方字段可用：</p><ul><li>iss (issuer)：签发人</li><li>iat (Issued At)：签发时间</li><li>exp (expiration time)：过期时间</li><li>nbf (Not Before)：生效时间</li><li>jti (JWT ID)：编号</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li></ul><p>除了官方字段，还可以在这个部分定义私有字段，比如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sub"</span>: <span class="string">"101"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"ruesin"</span>,</span><br><span class="line">  <span class="attr">"LoginToken"</span>:<span class="string">"abcd123"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为默认是Base64URL编码不加密的，所以客户端是可以解码读取这些数据，不要把秘密信息放在这个部分。</p><h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><blockquote><p>Signature 是对前两部分的签名，校验tonken的有效性，防止数据篡改。</p></blockquote><p>签名是通过服务端指定的密钥（secret）及Header中指定的签名算法产生的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS——HTTPS接入与配置实战</title>
      <link href="/2018/11/28/iOS%E2%80%94%E2%80%94HTTPS%E6%8E%A5%E5%85%A5%E4%B8%8E%E9%85%8D%E7%BD%AE%E5%AE%9E%E6%88%98/"/>
      <url>/2018/11/28/iOS%E2%80%94%E2%80%94HTTPS%E6%8E%A5%E5%85%A5%E4%B8%8E%E9%85%8D%E7%BD%AE%E5%AE%9E%E6%88%98/</url>
      <content type="html"><![CDATA[<h4 id="这里粗略的说一下关于HTTPS"><a href="#这里粗略的说一下关于HTTPS" class="headerlink" title="这里粗略的说一下关于HTTPS"></a>这里粗略的说一下关于HTTPS</h4><h5 id="https简单说明"><a href="#https简单说明" class="headerlink" title="https简单说明"></a>https简单说明</h5><pre><code>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。</code></pre><a id="more"></a><h5 id="HTTPS和HTTP的区别主要为以下四点："><a href="#HTTPS和HTTP的区别主要为以下四点：" class="headerlink" title="HTTPS和HTTP的区别主要为以下四点："></a>HTTPS和HTTP的区别主要为以下四点：</h5><ul><li>一、https协议需要到ca申请证书，一般免费证书很少，需要交费。</li><li>二、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。</li><li>三、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>四、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ul><p>关于更多HTTPS可以看看这篇文章：</p><p><a href="https://blog.51cto.com/11883699/2160032" target="_blank" rel="noopener">HTTPS原理和CA证书申请（满满的干货）</a></p><h5 id="具体流程就是"><a href="#具体流程就是" class="headerlink" title="具体流程就是"></a>具体流程就是</h5><p>当客户端给服务器发送请求时, 服务器中有一对钥匙(公钥,私钥). 服务器会返回给客户端一个公钥,并把两者的传输通道变为受保护空间(安全证书).</p><blockquote><p>此时 客户端拥有公钥,服务器拥有私钥. 当服务器返回数据给客户端时,数据是使用私钥加密过的. 客户端需要使用 公钥解密. 客户端发请求也是通过公钥加密. 服务器使用私钥来解密.(从某种意义上来说. 安全证书 就是公钥)</p></blockquote><h5 id="关于如下类型错误请自行百度："><a href="#关于如下类型错误请自行百度：" class="headerlink" title="关于如下类型错误请自行百度："></a>关于如下类型错误请自行百度：</h5><blockquote><p>App Transport Security has blocked a cleartext HTTP (http://) resource load since it is insecure. Temporary exceptions can be configured via your app’s Info.plist file.</p></blockquote><p>接下来就开始进行实战处理</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>iOS做https适配时对服务器是有一定要求的，服务端必须要是一个符合ATS（App Transport Security）要求的HTTPS。简单说要满足以下几个要求：</p><ul><li>1.Transport Layer Security协议版本要求TLS1.2以上</li><li>2.服务的Ciphers配置要求支持Forward Secrecy等</li><li>3.证书签名算法符合ATS要求等</li></ul><h2 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h2><p>关于Swif目前要么使用Alamofire，要么使用Moya，这里只接受Moya，关于Alamofire可以看这篇文章，相对Moya会复杂一点点，但是原理其实差不多是一样的</p><ul><li><a href="https://www.jianshu.com/p/cbad827eeed7" target="_blank" rel="noopener">Alamofire https自签名证书验证</a></li></ul><h5 id="Moya对应版本"><a href="#Moya对应版本" class="headerlink" title="Moya对应版本"></a>Moya对应版本</h5><ul><li>Moya版本号：Moya (12.0.1)</li><li>Alamofire版本号：Alamofire (4.8.1)</li></ul><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><h5 id="1、默认非HTTPS实现方法："><a href="#1、默认非HTTPS实现方法：" class="headerlink" title="1、默认非HTTPS实现方法："></a>1、默认非HTTPS实现方法：</h5><p>默认情况下定义Manager：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoyaProvider&lt;MultiTarget&gt;.defaultAlamofireManager()</span><br></pre></td></tr></table></figure><p>该方法不需要做任何处理，Moya默认已经实现</p><h5 id="2、HTTPS免证书实现方法（校验证书，可以抓包）："><a href="#2、HTTPS免证书实现方法（校验证书，可以抓包）：" class="headerlink" title="2、HTTPS免证书实现方法（校验证书，可以抓包）："></a>2、HTTPS免证书实现方法（校验证书，可以抓包）：</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> manager: Manager = MoyaProvider&lt;MultiTarget&gt;.defaultAlamofireManager()</span><br><span class="line">manager.delegate.sessionDidReceiveChallenge = &#123;</span><br><span class="line">        session,challenge <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">return</span>    (URLSession.AuthChallengeDisposition.useCredential,URLCredential(trust:challenge.protectionSpace.serverTrust!))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：需要导入：import Alamofire</p></blockquote><h5 id="3、HTTPS-证书实现方法（校验证书，不可以抓包）"><a href="#3、HTTPS-证书实现方法（校验证书，不可以抓包）" class="headerlink" title="3、HTTPS+证书实现方法（校验证书，不可以抓包）"></a>3、HTTPS+证书实现方法（校验证书，不可以抓包）</h5><p>在实现本方法前，首先需要服务器端提供“*.crt”证书,然后进入证书所在的路径，控制台执行以下命令：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -<span class="keyword">in</span> *.crt -out *.cer -outform der</span><br></pre></td></tr></table></figure><p>得到cer类型证书后，双击，导入电脑或者直接让服务器提供.cer，然后把cer文件拖动到工程中。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> configuration = URLSessionConfiguration.default</span><br><span class="line">configuration.httpAdditionalHeaders = Manager.defaultHTTPHeaders</span><br><span class="line"><span class="built_in">let</span> path: String = Bundle.main.path(forResource: <span class="string">"xxx"</span>, ofType: <span class="string">"cer"</span>) ?? <span class="string">""</span></span><br><span class="line"><span class="built_in">let</span> certificationData = try? Data(contentsOf: URL(fileURLWithPath: path)) as CFData</span><br><span class="line"> </span><br><span class="line"><span class="built_in">let</span> certificate = SecCertificateCreateWithData(nil, certificationData!)</span><br><span class="line"><span class="built_in">let</span> certificates: [SecCertificate] = [certificate!]</span><br><span class="line"> </span><br><span class="line"><span class="built_in">let</span> policies: [String: ServerTrustPolicy] = [<span class="string">"domain"</span>: ServerTrustPolicy.pinCertificates(certificates: certificates, validateCertificateChain: <span class="literal">true</span>, validateHost: <span class="literal">true</span>)]</span><br><span class="line"> </span><br><span class="line"><span class="built_in">let</span> manager = Manager(configuration: configuration, serverTrustPolicyManager: ServerTrustPolicyManager(policies: policies))</span><br></pre></td></tr></table></figure><h6 id="最后把manager当参数传递给MoyaProvider"><a href="#最后把manager当参数传递给MoyaProvider" class="headerlink" title="最后把manager当参数传递给MoyaProvider"></a>最后把manager当参数传递给MoyaProvider</h6> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoyaProvider&lt;MultiTarget&gt;(endpointClosure: endpoint, requestClosure: requestEndpoint, stubClosure: stubClosure, manager: manager, plugins: plugins)</span><br></pre></td></tr></table></figure><h2 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective-C"></a>Objective-C</h2><h5 id="以上主要是Swift实现Https请求和验证支持"><a href="#以上主要是Swift实现Https请求和验证支持" class="headerlink" title="以上主要是Swift实现Https请求和验证支持"></a>以上主要是Swift实现Https请求和验证支持</h5><p>下面看看OC的实现，OC的实现其实，由于现在OC几乎都是利用AFN或者AFN的衍生库实现网络请求，老项目的ASI这里就不提了，所以这里只是简单介绍AFN支持                                       </p><h4 id="1-首先定义一个安全协议，和帧数相关验证支持"><a href="#1-首先定义一个安全协议，和帧数相关验证支持" class="headerlink" title="1. 首先定义一个安全协议，和帧数相关验证支持"></a>1. 首先定义一个安全协议，和帧数相关验证支持</h4> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (AFSecurityPolicy*)customSecurityPolicy &#123;</span><br><span class="line">    // /先导入证书</span><br><span class="line">    NSString *cerPath = [[NSBundle mainBundle] pathForResource:@<span class="string">"jmt"</span> ofType:@<span class="string">"cer"</span>];//证书的路径</span><br><span class="line">    NSData *certData = [NSData dataWithContentsOfFile:cerPath];</span><br><span class="line"></span><br><span class="line">    // AFSSLPinningModeCertificate 使用证书验证模式</span><br><span class="line">    AFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];</span><br><span class="line"></span><br><span class="line">    // allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO</span><br><span class="line">    // 如果是需要验证自建证书，需要设置为YES</span><br><span class="line">    securityPolicy.allowInvalidCertificates = YES;</span><br><span class="line"></span><br><span class="line">    //validatesDomainName 是否需要验证域名，默认为YES；</span><br><span class="line">    //假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。</span><br><span class="line">    //置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。</span><br><span class="line">    //如置为NO，建议自己添加对应域名的校验逻辑。</span><br><span class="line">    securityPolicy.validatesDomainName = NO;</span><br><span class="line"></span><br><span class="line">    securityPolicy.pinnedCertificates = [NSSet setWithObject:certData];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> securityPolicy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在网络请求，初始化Manager的时候，根据配置HTTPS支持</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isDeveloperEnvironment) &#123;</span><br><span class="line">    //配置https</span><br><span class="line">    manager.securityPolicy = [self customSecurityPolicy];</span><br><span class="line">    manager.securityPolicy.allowInvalidCertificates = YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>1）HTTPS的主要思想是在不安全的网络上创建一安全信道，并可在使用适当的加密包和服务器证书可被验证且可被信任时，对窃听和中间人攻击提供合理的保护。</li><li>2）HTTPS的信任继承基于预先安装在浏览器中的证书颁发机构（如VeriSign、Microsoft等）（意即“我信任证书颁发机构告诉我应该信任的”）。</li><li>3）因此，一个到某网站的HTTPS连接可被信任，如果服务器搭建自己的https 也就是说采用自认证的方式来建立https信道，这样一般在客户端是不被信任的。</li><li>4）所以我们一般在浏览器访问一些https站点的时候会有一个提示，问你是否继续。</li></ul><p>到此，拜了个拜……</p><p>推荐：关于https的简介和说明我都是参考下面的文章：(谢谢文章作者)</p><ol><li><a href="http://my.oschina.net/vimfung/blog/494687" target="_blank" rel="noopener">http://my.oschina.net/vimfung/blog/494687</a></li><li><a href="http://oncenote.com/2014/10/21/Security-1-HTTPS/" target="_blank" rel="noopener">http://oncenote.com/2014/10/21/Security-1-HTTPS/</a></li><li><a href="http://blog.csdn.net/dachao_me/article/details/48624685?ref=myread" target="_blank" rel="noopener">http://blog.csdn.net/dachao_me/article/details/48624685?ref=myread</a></li></ol>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTPS </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Apache配置文件(httpd.conf)详解</title>
      <link href="/2018/11/16/Apache%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-httpd-conf-%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/11/16/Apache%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-httpd-conf-%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id="配置文件位置"><a href="#配置文件位置" class="headerlink" title="配置文件位置"></a>配置文件位置</h3><ul><li>Apache的主配置文件：/etc/httpd/conf/httpd.conf</li><li>默认站点主目录：/var/www/html/</li></ul><p>Apache服务器的配置信息全部存储在主配置文件/etc/httpd/conf/httpd.conf中，这个文件中的内容非常多，用wc命令统计一共有1009行，其中大部分是以#开头的注释行。</p><a id="more"></a><pre><code>[root@justin ~]# wc -l /etc/httpd/conf/httpd.conf /etc/httpd/conf/httpd.conf [root@justin ~]#</code></pre><p>配置文件包括三部分：</p><pre><code>[root@justin ~]# grep &apos;\&lt;Section\&gt;&apos; /etc/httpd/conf/httpd.conf -n 33:### Section 1: Global Environment 245:### Section 2: &apos;Main&apos; server configuration 973:### Section 3: Virtual Hosts [root@justin ~]#</code></pre><ul><li>1）Global Environment—全局环境配置，决定Apache服务器的全局参数</li><li>2）Main server configuration—主服务配置，相当于是Apache中的默认Web站点，如果我们的服务器中只有一个站点，那么就只需在这里配置就可以了。</li><li>3）Virtual Hosts—虚拟主机，虚拟主机不能与Main Server主服务器共存，当启用了虚拟主机之后，Main Server就不能使用了</li></ul><h4 id="1）Global-Environment"><a href="#1）Global-Environment" class="headerlink" title="1）Global Environment"></a>1）Global Environment</h4><blockquote><p>ServerTokens OS</p></blockquote><p>在出现错误页的时候是否显示服务器操作系统的名称，ServerTokens Prod为不显示</p><pre><code>ServerRoot &quot;/etc/httpd&quot;</code></pre><p>用于指定Apache的运行目录，服务启动之后自动将目录改变为当前目录，在后面使用到的所有相对路径都是想对这个目录下</p><pre><code>PidFile run/httpd.pid</code></pre><p>记录httpd守护进程的pid号码，这是系统识别一个进程的方法，系统中httpd进程可以有多个，但这个PID对应的进程是其他的父进程</p><pre><code>Timeout 60</code></pre><p>服务器与客户端断开的时间</p><pre><code>KeepAlive Off</code></pre><p>是否持续连接（因为每次连接都得三次握手，如果是访问量不大，建议打开此项，如果网站访问量比较大关闭此项比较好），修改为：KeepAlive On 表示允许程序性联机</p><pre><code>MaxKeepAliveRequests 100</code></pre><p>表示一个连接的最大请求数</p><pre><code>KeepAliveTimeout 15</code></pre><p>断开连接前的时间</p><pre><code>&lt;IfModule prefork.c&gt; StartServers      8 MinSpareServers    5 MaxSpareServers  20 ServerLimit      256 MaxClients      256 MaxRequestsPerChild  4000 &lt;/IfModule&gt;</code></pre><p>系统默认的模块，表示为每个访问启动一个进程（即当有多个连接公用一个进程的时候，在同一时刻只能有一个获得服务）。</p><ul><li>StartServer开始服务时启动8个进程，最小空闲5个进程，最多空闲20个进程。</li><li>MaxClient限制同一时刻客户端的最大连接请求数量超过的要进入等候队列。</li><li><p>MaxRequestsPerChild每个进程生存期内允许服务的最大请求数量，0表示永不结束</p>  <ifmodule worker.c=""><br>  StartServers        4<br>  MaxClients        300<br>  MinSpareThreads    25<br>  MaxSpareThreads    75<br>  ThreadsPerChild    25<br>  MaxRequestsPerChild  0<br>  </ifmodule></li></ul><p>为Apache配置线程访问，即每对WEB服务访问启动一个线程，这样对内存占用率比较小。</p><ul><li>ServerLimit服务器允许配置进程数的上限。</li><li>ThreadLimit每个子进程可能配置的线程上限</li><li>StartServers启动两个httpd进程，</li><li>MaxClients同时最多能发起250个访问，超过的要进入队列等待，其大小有ServerLimit和ThreadsPerChild的乘积决定</li><li>ThreadsPerChild每个子进程生存期间常驻执行线程数，子线程建立之后将不再增加</li><li>MaxRequestsPerChild每个进程启动的最大线程数，如达到限制数时进程将结束，如置为0则子线程永不结束</li></ul><blockquote><p>Listen 80</p></blockquote><p>监听的端口，如有多块网卡，默认监听所有网卡</p><pre><code>150 LoadModule auth_basic_module modules/mod_auth_basic.so ...... LoadModule version_module modules/mod_version.so</code></pre><p>启动时加载的模块 mod_access已经更名为mod_authz_host</p><pre><code>Include conf.d/*.conf</code></pre><p>加载的配置文件</p><pre><code>User apache Group apache</code></pre><p>启动服务后转换的身份，在启动服务时通常以root身份，然后转换身份，这样增加系统安全</p><h4 id="2）Main-server-configuration"><a href="#2）Main-server-configuration" class="headerlink" title="2）Main server configuration"></a>2）Main server configuration</h4><blockquote><p>ServerAdmin root@localhost</p></blockquote><p>管理员的邮箱</p><pre><code>#ServerName www.example.com:80</code></pre><p>默认是不需要指定的，服务器通过名字解析过程来获得自己的名字，但如果解析有问题（如反向解析不正确），或者没有DNS名字，也可以在这里指定IP地址，当这项不正确的时候服务器不能正常启动。前面启动Apache时候提示正在启动 httpd：httpd: apr_sockaddr_info_get() failed forjustin httpd: Could not reliably determine the server’s fully qualified domain name, using 127.0.0.1forServerName，解决方法就是启动该项把<a href="http://www.example.com:80修改为自己的域名或者直接修改为localhost" target="_blank" rel="noopener">www.example.com:80修改为自己的域名或者直接修改为localhost</a></p><pre><code>285 UseCanonicalName Off</code></pre><p>如果客户端提供了主机名和端口，Apache将会使用客户端提供的这些信息来构建自引用URL。这些值与用于实现基于域名的虚拟主机的值相同，并且对于同样的客户端可用。CGI变量SERVER_NAME和SERVER_PORT也会由客户端提供的值来构建</p><pre><code>DocumentRoot &quot;/var/www/html&quot;</code></pre><p>网页文件存放的目录</p><pre><code>&lt;Directory /&gt; Options FollowSymLinks AllowOverride None &lt;/Directory&gt;</code></pre><p>对根目录的一个权限的设置</p><pre><code>&lt;Directory &quot;/var/www/html&quot;&gt; Options Indexes FollowSymLinks AllowOverride None Order allow,deny Allow from all &lt;/Directory&gt;</code></pre><p>对/var/www/html目录的一个权限的设置，options中Indexes表示当网页不存在的时候允许索引显示目录中的文件，FollowSymLinks是否允许访问符号链接文件。有的选项有ExecCGI表是否使用CGI，如Options Includes ExecCGI FollowSymLinks表示允许服务器执行CGI及SSI，禁止列出目录。SymLinksOwnerMatch表示当符号链接的文件和目标文件为同一用户拥有时才允许访问。</p><p>AllowOverrideNone表示不允许这个目录下的访问控制文件来改变这里的配置，这也意味着不用查看这个目录下的访问控制文件，修改为：AllowOverride All 表示允许.htaccess。Order对页面的访问控制顺序后面的一项是默认选项，如allow，deny则默认是deny，Allowfromall表示允许所有的用户，通过和上一项结合可以控制对网站的访问控制</p><pre><code>&lt;IfModule mod_userdir.c&gt; UserDir disabled &lt;/IfModule&gt;</code></pre><p>是否允许用户访问其家目录，默认是不允许</p><pre><code>#&lt;Directory /home/*/public_html&gt; #    AllowOverride FileInfo AuthConfig Limit #    Options MultiViews Indexes SymLinksIfOwnerMatch IncludesNoExec #    &lt;Limit GET POST OPTIONS&gt; #        Order allow,deny #        Allow from all #    &lt;/Limit&gt; #    &lt;LimitExcept GET POST OPTIONS&gt; #        Order deny,allow #        Deny from all #    &lt;/LimitExcept&gt; #&lt;/Directory&gt;</code></pre><p>如果允许访问用户的家目录中的网页文件，则取消以上注释，并对其中进行修改</p><pre><code>DirectoryIndex index.html index.html.var</code></pre><p>指定所要访问的主页的默认主页名字，默认首页文件名为index.html</p><pre><code>AccessFileName .htaccess</code></pre><p>定义每个目录下的访问控制文件名，缺省为.htaccess</p><pre><code>&lt;Files ~ &quot;^\.ht&quot;&gt; Order allow,deny Deny from all Satisfy All &lt;/Files&gt;</code></pre><p>控制不让web上的用户来查看.htpasswd和.htaccess这两个文件</p><pre><code>TypesConfig /etc/mime.types</code></pre><p>用于设置保存有不同MIME类型数据的文件名</p><pre><code>DefaultType text/plain</code></pre><p>默认的网页的类型</p><pre><code>&lt;IfModule mod_mime_magic.c&gt; #  MIMEMagicFile /usr/share/magic.mime MIMEMagicFile conf/magic&lt;/IfModule&gt;</code></pre><p>指定判断文件真实MIME类型功能的模块</p><pre><code>HostnameLookups Off</code></pre><p>当打开此项功能时，在记录日志的时候同时记录主机名，这需要服务器来反向解析域名，增加了服务器的负载，通常不建议开启</p><pre><code>#EnableMMAP off</code></pre><p>是否允许内存映射：如果httpd在传送过程中需要读取一个文件的内容，它是否可以使用内存映射。如果为on表示如果操作系统支持的话，将使用内存映射。在一些多核处理器的系统上，这可能会降低性能，如果在挂载了NFS的DocumentRoot上如果开启此项功能，可能造成因为分段而造成httpd崩溃</p><pre><code>#EnableSendfile off</code></pre><p>这个指令控制httpd是否可以使用操作系统内核的sendfile支持来将文件发送到客户端。默认情况下，当处理一个请求并不需要访问文件内部的数据时(比如发送一个静态的文件内容)，如果操作系统支持，Apache将使用sendfile将文件内容直接发送到客户端而并不读取文件</p><pre><code>484 ErrorLog logs/error_log</code></pre><p>错误日志存放的位置</p><pre><code>LogLevel warn</code></pre><p>Apache日志的级别</p><pre><code>LogFormat &quot;%h %l %u %t \&quot;%r\&quot; %&gt;s %b \&quot;%{Referer}i\&quot; \&quot;%{User-Agent}i\&quot;&quot; combined LogFormat &quot;%h %l %u %t \&quot;%r\&quot; %&gt;s %b&quot; common LogFormat &quot;%{Referer}i -&gt; %U&quot; referer LogFormat &quot;%{User-agent}i&quot; agent</code></pre><p>定义了日志的格式，并用不同的代号表示</p><pre><code>#CustomLog logs/access_log common CustomLog logs/access_log combined</code></pre><p>说明日志记录的位置，这里面使用了相对路径，所以ServerRoot需要指出，日志位置就存放在/etc/httpd/logs</p><pre><code>ServerSignature On</code></pre><p>定义当客户请求的网页不存在，或者错误的时候是否提示apache的版本的一些信息</p><pre><code>Alias /icons/ &quot;/var/www/icons/&quot;</code></pre><p>定义一些不在DocumentRoot下的文件，而可以将其映射到网页根目录中，这也是访问其他目录的一种方法，但在声明的时候切记目录后面加”/”</p><pre><code>&lt;Directory &quot;/var/www/icons&quot;&gt; Options Indexes MultiViews FollowSymLinks AllowOverride None Order allow,deny Allow from all &lt;/Directory&gt;</code></pre><p>定义对/var/www/icons/的权限，修改为 Options MultiViews FollowSymLinks表示不在浏览器上显示树状目录结构</p><pre><code>&lt;IfModule mod_dav_fs.c&gt; # Location of the WebDAV lock database. DAVLockDB /var/lib/dav/lockdb&lt;/IfModule&gt;</code></pre><p>对mod_dav_fs.c模块儿的管理</p><pre><code>ScriptAlias /cgi-bin/ &quot;/var/www/cgi-bin/&quot;</code></pre><p>对CGI模块儿的的别名，与Alias相似。</p><pre><code>&lt;Directory &quot;/var/www/cgi-bin&quot;&gt; AllowOverride None Options None Order allow,deny Allow from all &lt;/Directory&gt;</code></pre><p>对/var/www/cgi-bin文件夹的管理，方法同上</p><pre><code># Redirect old-URI new-URL</code></pre><p>Redirect参数是用来重写URL的，当浏览器访问服务器上的一个已经不存在的资源的时候，服务器返回给浏览器新的URL，告诉浏览器从该URL中获取资源。这主要用于原来存在于服务器上的文档改变位置之后，又需要能够使用老URL能访问到原网页</p><pre><code>IndexOptions FancyIndexing VersionSort NameWidth=* HTMLTable Charset=UTF-8 AddIconByEncoding (CMP,/icons/compressed.gif) x-compress x-gzip... IndexIgnore .??* *~ *# HEADER* README* RCS CVS *,v *,t</code></pre><p>当一个HTTP请求的URL为一个目录的时候，服务器返回这个目录中的索引文件，如果目录中不存在索引文件，并且服务器有许可显示目录文件列表的时候，就会显示这个目录中的文件列表，为了使得这个文件列表能具有可理解性，而不仅仅是一个简单的列表，就需要前这些参数。如果使用了IndexOptionsFancyIndexing选项，可以让服务器针对不同的文件引用不同的图标。如果没有就使用DefaultIcon定义缺省图标。同样，使用AddDescription可以为不同类型的文档介入描述</p><pre><code>AddLanguage ca .ca ...... AddLanguage zh-TW .zh-tw</code></pre><p>添加语言</p><pre><code>LanguagePriority en ca cs da de el eo es et fr he hr it ja ko ltz nl nn no pl pt pt-BR ru sv zh-CN zh-TW</code></pre><p>Apache支持的语言</p><pre><code>AddDefaultCharset UTF-8</code></pre><p>默认支持的语言</p><pre><code>#AddType application/x-tar .tgz</code></pre><p>支持的应用如果想支持对php的解析添加这样一行</p><pre><code>#AddEncoding x-compress .Z #AddEncoding x-gzip .gz .tgz</code></pre><p>支持对以.Z和.gz.tgz结尾的文件</p><pre><code>AddType application/x-compress .Z AddType application/x-gzip .gz .tgz</code></pre><p>添加对上述两种文件的应用</p><pre><code>#AddHandler cgi-script .cgi</code></pre><p>修改为：AddHandler cgi-script .cgi .pl 表示允许扩展名为.pl的CGI脚本运行</p><pre><code>AddType text/html .shtml AddOutputFilter INCLUDES .shtml</code></pre><p>添加动态处理类型为server-parsed由服务器预先分析网页内的标记，将标记改为正确的HTML标识</p><pre><code>#ErrorDocument 404 /missing.html</code></pre><p>当服务器出现404错误的时候，返回missing.html页面</p><pre><code>Alias /error/ &quot;/var/www/error/&quot;</code></pre><p>赋值别名</p><pre><code>&lt;IfModule mod_negotiation.c&gt; &lt;IfModule mod_include.c&gt; &lt;Directory &quot;/var/www/error&quot;&gt; AllowOverride None Options IncludesNoExec AddOutputFilter Includes html AddHandler type-map var Order allow,deny Allow from all LanguagePriority en es de fr ForceLanguagePriority Prefer Fallback &lt;/Directory&gt;</code></pre><p>对/var/www/error网页的权限及操作</p><pre><code>BrowserMatch &quot;Mozilla/2&quot; nokeepalive BrowserMatch &quot;MSIE 4\.0b2;&quot; nokeepalive downgrade-1.0 force-response-1.0 BrowserMatch &quot;RealPlayer 4\.0&quot; force-response-1.0 BrowserMatch &quot;Java/1\.0&quot; force-response-1.0 BrowserMatch &quot;JDK/1\.0&quot; force-response-1.0 .....</code></pre><p>设置特殊的参数，以保证对老版本浏览器的兼容，并支持新浏览器的特性</p><h4 id="3）Virtual-Hosts"><a href="#3）Virtual-Hosts" class="headerlink" title="3）Virtual Hosts"></a>3）Virtual Hosts</h4><pre><code>#NameVirtualHost *:80</code></pre><p>如果启用虚拟主机的话，必须将前面的注释去掉，而且，第二部分的内容都可以出现在每个虚拟主机部分。</p><pre><code># VirtualHost example: #&lt;VirtualHost *:80&gt; #    ServerAdmin webmaster@www.linuxidc.com #    DocumentRoot /www/docs/www.linuxidc.com #    ServerName www.linuxidc.com #    ErrorLog logs/www.linuxidc.com-error_log #    CustomLog logs/www.linuxidc.com-access_log common #&lt;/VirtualHost&gt;</code></pre><h5 id="常用配置指令说明"><a href="#常用配置指令说明" class="headerlink" title="常用配置指令说明"></a><a href="https://www.cnblogs.com/jxl1996/p/10119184.html" target="_blank" rel="noopener">常用配置指令说明</a></h5>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 配置文件 </tag>
            
            <tag> Apache </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nginx配置文件(nginx.conf)详解</title>
      <link href="/2018/11/16/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-nginx-conf-%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/11/16/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-nginx-conf-%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>Nginx 总的 配置文件 位置 /usr/local/nginx/conf/nginx.conf<br>nginx 正则匹配</p><h3 id="一．正则表达式匹配，其中："><a href="#一．正则表达式匹配，其中：" class="headerlink" title="一．正则表达式匹配，其中："></a>一．正则表达式匹配，其中：</h3><ol><li>~ 为区分大小写匹配</li><li>~* 为不区分大小写匹配</li><li>!~和!~*分别为区分大小写不匹配及不区分大小写不匹配</li></ol><a id="more"></a><h3 id="二．文件及目录匹配，其中："><a href="#二．文件及目录匹配，其中：" class="headerlink" title="二．文件及目录匹配，其中："></a>二．文件及目录匹配，其中：</h3><ol><li>-f和!-f用来判断是否存在文件</li><li>-d和!-d用来判断是否存在目录</li><li>-e和!-e用来判断是否存在文件或目录</li><li>-x和!-x用来判断文件是否可执行</li></ol><h3 id="三．rewrite指令的最后一项参数为flag标记，flag标记有："><a href="#三．rewrite指令的最后一项参数为flag标记，flag标记有：" class="headerlink" title="三．rewrite指令的最后一项参数为flag标记，flag标记有："></a>三．rewrite指令的最后一项参数为flag标记，flag标记有：</h3><ol><li>last    相当于apache里面的[L]标记，表示rewrite。</li><li>break本条规则匹配完成后，终止匹配，不再匹配后面的规则。</li><li>redirect  返回302临时重定向，浏览器地址会显示跳转后的URL地址。</li><li>permanent  返回301永久重定向，浏览器地址会显示跳转后的URL地址。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用last和break实现URI重写，浏览器地址栏不变。</span><br><span class="line">使用alias指令必须用last标记;</span><br><span class="line">使用proxy_pass指令时，需要使用break标记。</span><br><span class="line">Last标记在本条rewrite规则执行完毕后，会对其所在server&#123;......&#125;标签重新发起请求</span><br><span class="line">break标记则在本条规则匹配完成后，终止匹配。</span><br></pre></td></tr></table></figure><h3 id="四．NginxRewrite-规则相关指令"><a href="#四．NginxRewrite-规则相关指令" class="headerlink" title="四．NginxRewrite 规则相关指令"></a>四．NginxRewrite 规则相关指令</h3><h5 id="1-break指令"><a href="#1-break指令" class="headerlink" title="1. break指令"></a>1. break指令</h5><ul><li>使用环境：server,location,if;</li><li>该指令的作用是完成当前的规则集，不再处理rewrite指令。</li></ul><h5 id="2-if指令"><a href="#2-if指令" class="headerlink" title="2.if指令"></a>2.if指令</h5><ul><li>使用环境：server,location</li><li>该指令用于检查一个条件是否符合，如果条件符合，则执行大括号内的语句。If指令不支持嵌套，不支持多个条件&amp;&amp;和||处理。</li></ul><h5 id="3-return指令"><a href="#3-return指令" class="headerlink" title="3.return指令"></a>3.return指令</h5><ul><li>语法：return code ;</li><li>使用环境：server,location,if;</li></ul><p>该指令用于结束规则的执行并返回状态码给客户端。<br>示例：如果访问的URL以”.sh”或”.bash”结尾，则返回403状态码</p><pre><code>location ~ .*\.(sh|bash)?${　　　　return 403;}</code></pre><h5 id="4-rewrite-指令"><a href="#4-rewrite-指令" class="headerlink" title="4.rewrite 指令"></a>4.rewrite 指令</h5><ul><li>语法：rewriteregex replacement flag</li><li>使用环境：server,location,if</li></ul><p>该指令根据表达式来重定向URI，或者修改字符串。指令根据配置文件中的顺序来执行。注意重写表达式只对相对路径有效。如果你想配对主机名，你应该使用if语句，示例如下：</p><pre><code>if ( $host ~* www\.(.*) ){　　　　set  $host_without_www $1;　　　　rewrite  ^(.*)$   http://$host_without_www$1 permanent;}</code></pre><h5 id="5-Set指令"><a href="#5-Set指令" class="headerlink" title="5.Set指令"></a>5.Set指令</h5><ul><li>语法：setvariable value ; 默认值:none; 使用环境：server,location,if;</li><li>该指令用于定义一个变量，并给变量赋值。变量的值可以为文本、变量以及文本变量的联合。<br>　<br>示例：set $varname “hello world”;</li></ul><h5 id="6-Uninitialized-variable-warn指令"><a href="#6-Uninitialized-variable-warn指令" class="headerlink" title="6.Uninitialized_variable_warn指令"></a>6.Uninitialized_variable_warn指令</h5><ul><li>语法：uninitialized_variable_warnon|off</li><li>使用环境：http,server,location,if</li></ul><p>该指令用于开启和关闭未初始化变量的警告信息，默认值为开启。</p><h3 id="五．Nginx的Rewrite规则编写实例"><a href="#五．Nginx的Rewrite规则编写实例" class="headerlink" title="五．Nginx的Rewrite规则编写实例"></a>五．Nginx的Rewrite规则编写实例</h3><h5 id="1-当访问的文件和目录不存在时，重定向到某个php文件"><a href="#1-当访问的文件和目录不存在时，重定向到某个php文件" class="headerlink" title="1.当访问的文件和目录不存在时，重定向到某个php文件"></a>1.当访问的文件和目录不存在时，重定向到某个php文件</h5><pre><code>if ( !-e $request_filename ){    Rewrite ^/(.*)$ index.php last;}</code></pre><h5 id="2-目录对换-123456-xxxx-gt-xxxx-id-123456"><a href="#2-目录对换-123456-xxxx-gt-xxxx-id-123456" class="headerlink" title="2.目录对换 /123456/xxxx  ====&gt;  /xxxx?id=123456"></a>2.目录对换 /123456/xxxx  ====&gt;  /xxxx?id=123456</h5><pre><code>rewrite ^/(\d+)/(.+)/  /$2?id=$1 last;</code></pre><h5 id="3-如果客户端使用的是IE浏览器，则重定向到-ie目录下"><a href="#3-如果客户端使用的是IE浏览器，则重定向到-ie目录下" class="headerlink" title="3.如果客户端使用的是IE浏览器，则重定向到/ie目录下"></a>3.如果客户端使用的是IE浏览器，则重定向到/ie目录下</h5><pre><code>if( $http_user_agent  ~ MSIE){</code></pre><p>Rewrite ^(.*)$ /ie/$1 break;<br>    }</p><h5 id="4-禁止访问多个目录"><a href="#4-禁止访问多个目录" class="headerlink" title="4.禁止访问多个目录"></a>4.禁止访问多个目录</h5><pre><code>location ~ ^/(cron|templates)/{    deny all;    break;}</code></pre><h5 id="5-禁止访问以-data开头的文件"><a href="#5-禁止访问以-data开头的文件" class="headerlink" title="5.禁止访问以/data开头的文件"></a>5.禁止访问以/data开头的文件</h5><pre><code>location ~ ^/data{    deny all;}</code></pre><h5 id="6-禁止访问以-sh-flv-mp3为文件后缀名的文件"><a href="#6-禁止访问以-sh-flv-mp3为文件后缀名的文件" class="headerlink" title="6.禁止访问以.sh,.flv,.mp3为文件后缀名的文件"></a>6.禁止访问以.sh,.flv,.mp3为文件后缀名的文件</h5><pre><code>location ~ .*\.(sh|flv|mp3)${    return 403;}</code></pre><h5 id="7-设置某些类型文件的浏览器缓存时间"><a href="#7-设置某些类型文件的浏览器缓存时间" class="headerlink" title="7.设置某些类型文件的浏览器缓存时间"></a>7.设置某些类型文件的浏览器缓存时间</h5><pre><code>location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)${    expires 30d;}location ~ .*\.(js|css)${    expires 1h;}</code></pre><h5 id="8-给favicon-ico和robots-txt设置过期时间"><a href="#8-给favicon-ico和robots-txt设置过期时间" class="headerlink" title="8.给favicon.ico和robots.txt设置过期时间;"></a>8.给favicon.ico和robots.txt设置过期时间;</h5><p>这里为favicon.ico为99天,robots.txt为7天并不记录404错误日志</p><pre><code>location ~(favicon.ico){    log_not_found off;    expires 99d;    break;}location ~(robots.txt) {    log_not_found off;    expires 7d;    break;}</code></pre><h5 id="9-设定某个文件的过期时间-这里为600秒，并不记录访问日志"><a href="#9-设定某个文件的过期时间-这里为600秒，并不记录访问日志" class="headerlink" title="9.设定某个文件的过期时间;这里为600秒，并不记录访问日志"></a>9.设定某个文件的过期时间;这里为600秒，并不记录访问日志</h5><pre><code>location ^~ /html/scripts/loadhead_1.js {    access_log  off;    root /opt/lampp/htdocs/web;    expires 600;    break;}</code></pre><h5 id="10-文件反盗链并设置过期时间"><a href="#10-文件反盗链并设置过期时间" class="headerlink" title="10.文件反盗链并设置过期时间"></a>10.文件反盗链并设置过期时间</h5><p>　<br>这里的return412 为自定义的http状态码，默认为403，方便找出正确的盗链的请求</p><pre><code>“rewrite ^/ http://img.linuxidc.net/leech.gif;” 显示一张防盗链图片“access_log off;” 不记录访问日志，减轻压力“expires 3d”  所有文件3天的浏览器缓存location ~*^.+\.(jpg|jpeg|gif|png|swf|rar|zip|css|js)$ {    valid_referers none blocked *.linuxidc.com*.linuxidc.net localhost 208.97.167.194;    if ($invalid_referer)     {　　　　　　rewrite ^/ http://img.linuxidc.net/leech.gif;　　　　　　return 412;　　　　　　break;    }    access_log  off;    root /opt/lampp/htdocs/web;    expires 3d;    break;}</code></pre><h5 id="11-只允许固定ip访问网站，并加上密码"><a href="#11-只允许固定ip访问网站，并加上密码" class="headerlink" title="11.只允许固定ip访问网站，并加上密码"></a>11.只允许固定ip访问网站，并加上密码</h5><pre><code>root /opt/htdocs/www;allow  208.97.167.194; allow  222.33.1.2; allow  231.152.49.4;deny  all;auth_basic “C1G_ADMIN”;auth_basic_user_file htpasswd;</code></pre><h5 id="12将多级目录下的文件转成一个文件，增强seo效果"><a href="#12将多级目录下的文件转成一个文件，增强seo效果" class="headerlink" title="12将多级目录下的文件转成一个文件，增强seo效果"></a>12将多级目录下的文件转成一个文件，增强seo效果</h5><pre><code>/job-123-456-789.html 指向/job/123/456/789.htmlrewrite ^/job-([0-9]+)-([0-9]+)-([0-9]+)\.html$ /job/$1/$2/jobshow_$3.html last;</code></pre><h5 id="13-文件和目录不存在的时候重定向："><a href="#13-文件和目录不存在的时候重定向：" class="headerlink" title="13.文件和目录不存在的时候重定向："></a>13.文件和目录不存在的时候重定向：</h5><pre><code>if (!-e $request_filename){    proxy_pass http://127.0.0.1;}</code></pre><h5 id="14-将根目录下某个文件夹指向2级目录"><a href="#14-将根目录下某个文件夹指向2级目录" class="headerlink" title="14.将根目录下某个文件夹指向2级目录"></a>14.将根目录下某个文件夹指向2级目录</h5><p>如/shanghaijob/ 指向 /area/shanghai/<br>如果你将last改成permanent，那么浏览器地址栏显是/location/shanghai/</p><pre><code>　　rewrite ^/([0-9a-z]+)job/(.*)$ /area/$1/$2last;</code></pre><p>面例子有个问题是访问/shanghai时将不会匹配</p><pre><code>　　rewrite ^/([0-9a-z]+)job$ /area/$1/ last;</code></pre><p>Rewrite ^/([0-9a-z]+)job/(.*)$ /area/$1/$2last;</p><p>这样/shanghai 也可以访问了，但页面中的相对链接无法使用，</p><blockquote><p>如./list_1.html真实地址是/area/shanghia/list_1.html会变成/list_1.html,导至无法访问。<br>那我加上自动跳转也是不行咯</p></blockquote><pre><code>(-d $request_filename)它有个条件是必需为真实目录，而我的rewrite不是的，所以没有效果if (-d $request_filename){rewrite ^/(.*)([^/])$ http://$host/$1$2/permanent;}</code></pre><p>知道原因后就好办了，让我手动跳转吧</p><pre><code>rewrite ^/([0-9a-z]+)job$ /$1job/permanent;rewrite ^/([0-9a-z]+)job/(.*)$ /area/$1/$2last;</code></pre><h5 id="15-域名跳转"><a href="#15-域名跳转" class="headerlink" title="15.域名跳转"></a>15.域名跳转</h5><pre><code>server{    listen      80;    server_name  jump.linuxidc.com;    index index.html index.htm index.php;    root  /opt/lampp/htdocs/www;    rewrite ^/ http://www.linuxidc.com/;    access_log  off;}</code></pre><h5 id="16-多域名转向"><a href="#16-多域名转向" class="headerlink" title="16.多域名转向"></a>16.多域名转向</h5><pre><code>server_name  www.linuxidc.com www.linuxidc.net;index index.html index.htm index.php;root  /opt/lampp/htdocs;if ($host ~ &quot;linuxidc\.net&quot;) {    rewrite ^(.*) http://www.linuxidc.com$1permanent;}</code></pre><h3 id="六．nginx全局变量"><a href="#六．nginx全局变量" class="headerlink" title="六．nginx全局变量"></a>六．nginx全局变量</h3><pre><code>​arg_PARAMETER    #这个变量包含GET请求中，如果有变量PARAMETER时的值。args                    #这个变量等于请求行中(GET请求)的参数，如：foo=123&amp;bar=blahblah;binary_remote_addr #二进制的客户地址。body_bytes_sent    #响应时送出的body字节数数量。即使连接中断，这个数据也是精确的。content_length    #请求头中的Content-length字段。content_type      #请求头中的Content-Type字段。cookie_COOKIE    #cookie COOKIE变量的值document_root    #当前请求在root指令中指定的值。document_uri      #与uri相同。host                #请求主机头字段，否则为服务器名称。hostname          #Set to themachine’s hostname as returned by gethostnamehttp_HEADERis_args              #如果有args参数，这个变量等于”?”，否则等于”&quot;，空值。http_user_agent    #客户端agent信息http_cookie          #客户端cookie信息limit_rate            #这个变量可以限制连接速率。query_string          #与args相同。request_body_file  #客户端请求主体信息的临时文件名。request_method    #客户端请求的动作，通常为GET或POST。remote_addr          #客户端的IP地址。remote_port          #客户端的端口。remote_user          #已经经过Auth Basic Module验证的用户名。request_completion #如果请求结束，设置为OK. 当请求未结束或如果该请求不是请求链串的最后一个时，为空(Empty)。request_method    #GET或POSTrequest_filename  #当前请求的文件路径，由root或alias指令与URI请求生成。request_uri          #包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。不能修改。scheme                #HTTP方法（如http，https）。server_protocol      #请求使用的协议，通常是HTTP/1.0或HTTP/1.1。server_addr          #服务器地址，在完成一次系统调用后可以确定这个值。server_name        #服务器名称。server_port          #请求到达服务器的端口号。</code></pre><h3 id="七．Apache和Nginx规则的对应关系"><a href="#七．Apache和Nginx规则的对应关系" class="headerlink" title="七．Apache和Nginx规则的对应关系"></a>七．Apache和Nginx规则的对应关系</h3><pre><code>Apache的RewriteCond对应Nginx的ifApache的RewriteRule对应Nginx的rewriteApache的[R]对应Nginx的redirectApache的[P]对应Nginx的lastApache的[R,L]对应Nginx的redirectApache的[P,L]对应Nginx的lastApache的[PT,L]对应Nginx的last</code></pre><p>例如：允许指定的域名访问本站，其他的域名一律转向<a href="http://www.linuxidc.net" target="_blank" rel="noopener">www.linuxidc.net</a></p><h5 id="Apache"><a href="#Apache" class="headerlink" title="Apache:"></a>Apache:</h5><pre><code>RewriteCond %{HTTP_HOST} !^(.*?)\.aaa\.com$[NC]RewriteCond %{HTTP_HOST} !^localhost$ RewriteCond %{HTTP_HOST}!^192\.168\.0\.(.*?)$RewriteRule ^/(.*)$ http://www.linuxidc.net[R,L]</code></pre><h5 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx:"></a>Nginx:</h5><pre><code>if( $host ~* ^(.*)\.aaa\.com$ ){    set $allowHost &apos;1&apos;;}if( $host ~* ^localhost ){    set $allowHost &apos;1&apos;;}if( $host ~* ^192\.168\.1\.(.*?)$ ){    set $allowHost &apos;1&apos;;}if( $allowHost !~ &apos;1&apos; ){    Rewrite ^/(.*)$ http://www.linuxidc.netredirect ;} </code></pre><h5 id="nginx-conf-配置文件"><a href="#nginx-conf-配置文件" class="headerlink" title="nginx conf 配置文件"></a>nginx conf 配置文件</h5><pre><code>nginx进程数，建议设置为等于CPU总核心数.worker_processes 8;全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]error_log /var/log/nginx/error.log info;进程文件pid /var/run/nginx.pid;一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。worker_rlimit_nofile 65535;工作模式与连接数上限events{        #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ];  epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。    　　use epoll;    　　#单个进程最大连接数（最大连接数=连接数*进程数）    　　worker_connections 65535;}设定http服务器http{​    include mime.types; #文件扩展名与文件类型映射表    default_type application/octet-stream; #默认文件类型    #charset utf-8; #默认编码    server_names_hash_bucket_size 128; #服务器名字的hash表大小    client_header_buffer_size 32k; #上传文件大小限制    large_client_header_buffers 4 64k; #设定请求缓    client_max_body_size 8m; #设定请求缓     sendfile on; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为  on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。    autoindex on; #开启目录列表访问，合适下载服务器，默认关闭。    tcp_nopush on; #防止网络阻塞    tcp_nodelay on; #防止网络阻塞    keepalive_timeout 120; #长连接超时时间，单位是秒​    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。    fastcgi_connect_timeout 300;    fastcgi_send_timeout 300;    fastcgi_read_timeout 300;    fastcgi_buffer_size 64k;    fastcgi_buffers 4 64k;    fastcgi_busy_buffers_size 128k;    fastcgi_temp_file_write_size 128k;​    #gzip模块设置    gzip on; #开启gzip压缩输出    gzip_min_length 1k; #最小压缩文件大小    gzip_buffers 4 16k; #压缩缓冲区    gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）    gzip_comp_level 2; #压缩等级    gzip_types text/plain application/x-javascript text/css application/xml;    #压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。    gzip_vary on;    #limit_zone crawler $binary_remote_addr 10m; #开启限制IP连接数的时候需要使用​    upstream blog.ha97.com {        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。        server 192.168.80.121:80 weight=3;        server 192.168.80.122:80 weight=2;        server 192.168.80.123:80 weight=3;    }    虚拟主机的配置    server    {    ​    listen 80;　　　　#监听端口    　　　　server_name aa.cn www.aa.cn ; #server_name end  #域名可以有多个，用空格隔开    ​    index index.html index.htm index.php;  # 设置访问主页    　　　　set $subdomain &apos;&apos;;  # 绑定目录为二级域名 bbb.aa.com  根目录 /bbb  文件夹         　　　　if ( $host ~* &quot;(?:(\w+\.){0,})(\b(?!www\b)\w+)\.\b(?!(com|org|gov|net|cn)\b)\w+\.[a-zA-Z]+&quot; ) { set $subdomain &quot;/$2&quot;; }    root /home/wwwroot/aa.cn/web$subdomain;# 访问域名跟目录      include rewrite/dedecms.conf; #rewrite end   #载入其他配置文件    ​    location ~ .*.(php|php5)?$        {            　　fastcgi_pass 127.0.0.1:9000;            　　fastcgi_index index.php;            　　include fastcgi.conf;        }        #图片缓存时间设置        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$        {            　　expires 10d;        }        #JS和CSS缓存时间设置        location ~ .*.(js|css)?$        {            　　expires 1h;        }    }​    日志格式设定​    log_format access &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;    &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;    &apos;&quot;$http_user_agent&quot; $http_x_forwarded_for&apos;;    #定义本虚拟主机的访问日志    access_log /var/log/nginx/ha97access.log access;​    #对 &quot;/&quot; 启用反向代理    location / {​        proxy_pass http://127.0.0.1:88;        proxy_redirect off;        proxy_set_header X-Real-IP $remote_addr;        #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        #以下是一些反向代理的配置，可选。        proxy_set_header Host $host;        client_max_body_size 10m; #允许客户端请求的最大单文件字节数        client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数，        proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时)        proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时)        proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时)        proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小        proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的设置        proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2）        proxy_temp_file_write_size 64k;        #设定缓存文件夹大小，大于这个值，将从upstream服务器传​    }​        设定查看Nginx状态的地址​    location /NginxStatus {​        stub_status on;        access_log on;        auth_basic &quot;NginxStatus&quot;;        auth_basic_user_file conf/htpasswd;        #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。​    }​    #本地动静分离反向代理配置    #所有jsp的页面均交由tomcat或resin处理    location ~ .(jsp|jspx|do)?$ {​        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_pass http://127.0.0.1:8080;​    }​        #所有静态文件由nginx直接读取不经过tomcat或resin    location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$    {　　 expires 15d;　　 }    location ~ .*.(js|css)?$    { 　　expires 1h;　　 }}</code></pre><h5 id="nginx-在thinkphp-的url-重写"><a href="#nginx-在thinkphp-的url-重写" class="headerlink" title="nginx 在thinkphp  的url 重写"></a>nginx 在thinkphp  的url 重写</h5><p>在/usr/local/nginx/conf/vhost/你的域名配置文件 中添加</p><pre><code>location / {　　if (!-e $request_filename) {　　rewrite ^/(.*)/(.*)/(.*)/*$ /index.php?m=$1&amp;c=$2&amp;a=$3 last;  # thinkphp 的配置文件中 &apos;URL_MODEL&apos; =&gt; 1   PATHINFO模式​       #或者  rewrite  ^(.*)$  /index.php?s=$1  last;　　　　 # thinkphp 的配置文件中 &apos;URL_MODEL&apos; =&gt;3   兼容模式​       #或者  rewrite  /(.*)$  /index.php/$1  last;          # thinkphp 的配置文件中 &apos;URL_MODEL&apos; =&gt; 2  REWRITE模式　　break;　　}} </code></pre><h5 id="路径-pathinfo-模式-thinkphp-添加"><a href="#路径-pathinfo-模式-thinkphp-添加" class="headerlink" title="路径 pathinfo 模式[ thinkphp ] 添加"></a>路径 pathinfo 模式[ thinkphp ] 添加</h5><pre><code>location ~ \.php(.*)$ {　　fastcgi_pass   127.0.0.1:9000;　　fastcgi_index  index.php;　　fastcgi_split_path_info  ^((?U).+\.php)(/?.+)$;　　fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;　　fastcgi_param  PATH_INFO  $fastcgi_path_info;　　fastcgi_param  PATH_TRANSLATED  $document_root$fastcgi_path_info;　　include        fastcgi_params;}</code></pre><h5 id="重写-url-省略index-php"><a href="#重写-url-省略index-php" class="headerlink" title="重写 url +省略index.php"></a>重写 url +省略index.php</h5><pre><code>location / {　　try_files $uri /index.php?$uri;}</code></pre><p>nginx -s reload 或者 /usr/local/nginx/sbin/nginx -s reload 重新加载Nginx配置文件</p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 配置文件 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cocos2dx lua 热更新原理与实战</title>
      <link href="/2018/10/30/cocos2dx-lua-%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/"/>
      <url>/2018/10/30/cocos2dx-lua-%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/</url>
      <content type="html"><![CDATA[<p>首先，如果有过cocos2dx lua开发经验的朋友都知道，为什么使用Lua而不是C++,最重要的原因就是因为下面这三个原因</p><ul><li>热更新(在线更新代码和资源)</li><li>比C++简单很多,入门和实战</li><li>轻量级，最小最轻的脚本语言</li></ul><p>今天就从Lua热更新，捣鼓一下其中的原理，并具体实战一下！</p><a id="more"></a><h3 id="什么是热更新？"><a href="#什么是热更新？" class="headerlink" title="什么是热更新？"></a>什么是热更新？</h3><p>热更新也叫不停机更新，是在游戏服务器运行期间对游戏进行更新。实现不停机修正bug、修改游戏数据等操作。也可以这样讲：一辆车以时速150km跑着，突然爆胎了，然后司机告诉你，我不停车，你去把轮胎换了，小心点。</p><h3 id="热更新的作用"><a href="#热更新的作用" class="headerlink" title="热更新的作用"></a>热更新的作用</h3><p>Lua模块热更新原理，能很好的支持代码热更新机制，是大部分选择要嵌入脚本语言的原因之一。好处很简单，脚本代码可以热更新的话，调试和线上解决问题都可以不用重启程序了，对开发效率有很大的帮助。</p><h3 id="热更新原理"><a href="#热更新原理" class="headerlink" title="热更新原理"></a>热更新原理</h3><p>Lua内部提供了一个require函数，来实现模块的加载，它做的事情主要是以下几个：</p><blockquote><p>在registry[“_LOADED”]表中判断该模块是否已经加载过了，如果是则返回，避免重复加载某个模块代码。</p></blockquote><p>依次调用注册的loader来加载模块,将加载过的模块赋值给registry[“_LOADED”]表。</p><p>而如果要实现Lua的代码热更新，其实也就是需要重新加载某个模块，因此就要想办法让Lua认为它之前没有加载过。查看Lua代码发现，registry[“_LOADED”]表，实际上对应的是package.loaded表，这在以下函数中有体现：</p><pre><code>(loadlib.c)627 LUALIB_API int luaopen_package (lua_State *L) {655   /* set field `loaded&apos; */656   luaL_findtable(L, LUA_REGISTRYINDEX, &quot;_LOADED&quot;, 2);657   lua_setfield(L, -2, &quot;loaded&quot;);</code></pre><p>因此事情就很简单了，需要提供一个require_ex函数，可以理解为require的增强版，使用这个函数可以动态更新某个模块的代码:</p><pre><code>function require_ex( _mname )print( string.format(&quot;require_ex = %s&quot;, _mname) )if package.loaded[_mname] thenprint( string.format(&quot;require_ex module[%s] reload&quot;, _mname))endpackage.loaded[_mname] = nilrequire( _mname )end</code></pre><p>这个函数做的事情一目了然。首先判断是否曾经加载过这个模块，如果有则打印一条日志表示需要重新加载某个模块，然后将该模块原来在表中注册的值赋空，然后再次调用require进行模块的加载和注册。</p><h3 id="热更新实现细节"><a href="#热更新实现细节" class="headerlink" title="热更新实现细节"></a>热更新实现细节</h3><p>以上了解了Lua代码热更新的原理，但是还有一些细节需要提醒一下。</p><ul><li><p>如何组织你的项目中的Lua代码？</p><ul><li>我在qnode中使用的方式是，单独使用一个叫main.lua的文件调用require_ex函数来加载需要用到的lua模块，而Lua虚拟机创建之后执行的是这个文件，这样的话，当你需要热更新项目中的Lua代码时，只需要重新执行这个main.lua就行了。</li></ul></li><li><p>如何通知热更新代码呢？</p><ul><li>我在qnode中使用的信号机制，当服务器收到USR1信号时，通知所有工作进程，由工作进程来重新对main.lua进行重新加载，这样就完成了lua代码的热更新，为此我写了一个简单的脚本reload.sh，就是根据当前qnode的服务器进程ID来对其发送USR1信号量的。</li></ul></li><li><p>一般热更新的都是函数的实现，所以需要对全局变量做一些保护。</p><ul><li>比如当前某全局变量为100，表示某个操作已经进行了100次，它不能因为热更新重新置0，所以要对这些不能改变的全局变量做一个保护，最简单的方式就是这样:</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = a or 0</span><br></pre></td></tr></table></figure><p>很简单的原理，只有当前a这个变量没有初始值的时候才会赋值为0，而后面不管这个Lua文件被加载多少次，a都不会因为重新加载了Lua代码发生改变了。</p><h3 id="热更新实战"><a href="#热更新实战" class="headerlink" title="热更新实战"></a>热更新实战</h3><p>其实我们平时开发中，可以用简单易懂的方式来理解热更新</p><ul><li><ol><li>客户端向服务器发送请求，服务器告诉客户端，没更新，你是最新的啦，那就直接跳过喽</li></ol></li><li><ol start="2"><li>如果是告诉你有更新，那就要告诉我哪些需要更新对吧，你可能需要更新的东西，放在一个文件里，一并发送给客户端</li></ol></li><li><ol start="3"><li>客户端拿到这个文件，就一个一个去向服务器要，最后把要更新的内容都下载到本地了</li></ol></li></ul><blockquote><p>cocos2dx-lua中有assetmanagerex的c++实现类，也有绑定到lua。</p><blockquote><p>3.10之前有缺陷，问题是当有文件下载失败时会陷入死循环，导致业务链断裂。不过网上有解决办法，可简单修改源码解决。<br>建议把高于3.10版本以后的assetmanagerex代码移植到旧的3.x版本，也可以选择新项目使用3.10以后版本。</p></blockquote></blockquote><h4 id="网上有提到两种热更新的方法"><a href="#网上有提到两种热更新的方法" class="headerlink" title="网上有提到两种热更新的方法"></a>网上有提到两种热更新的方法</h4><ul><li><p>1.只存在一套资源，用一个文件记录所有文件的信息（文件名，路径，大小，MD5）。游戏启动时下载这个文件与本地文件MD5进行对比，不同的和新增的下载下来，没有的删掉。（最好再做个简要信息文件，因为资源多了记录文件信息的文件会有上百KB大小）</p></li><li><p>2.第二种存在多套资源，客户端每更新一个版本都会有一个内部版本号。更新服务端会有多套压缩包，如1.0-1.5， 1.1-1.5 ，1.2-1.5 ，1.3-1.5，1.4-1.5。此方法需要保留每个版本的文件资源，依次生成每一个版本到最新版本的增量压缩包（依据是文件名和MD5）</p></li></ul><p>但是结合实战第一种和优点是方便管理，从始到终只有一套资源。缺点是玩家下载时流量多一点，因为没有压缩。第二种优点是玩家下载流量小，但每次升级需要保留历史版本为升级依据，版本越多越不好管理。</p><h5 id="具体代码实战"><a href="#具体代码实战" class="headerlink" title="具体代码实战"></a>具体代码实战</h5><pre><code>local AutoUpdateScene = class(&quot;AutoUpdateScene&quot;, cc.load(&quot;mvc&quot;).ViewBase)local manifestPath = &quot;project.manifest&quot;local storagePath = &quot;update&quot;function AutoUpdateScene:onCreate()self._update_failed_count = 0local layer  = cc.Layer:create()local am = nillocal function onEnter()local ttfConfig = {}ttfConfig.fontFilePath = &quot;fonts/arial.ttf&quot;ttfConfig.fontSize = 80local  progress = cc.Label:createWithTTF(ttfConfig, &quot;0%&quot;, cc.VERTICAL_TEXT_ALIGNMENT_CENTER)progress:setPosition(cc.p(display.center.x, display.center.y + 50))layer:addChild(progress)am = cc.AssetsManagerEx:create(manifestPath, cc.FileUtils:getInstance():getWritablePath() .. storagePath)am:retain()if not am:getLocalManifest():isLoaded() thenprint(&quot;Fail to update assets, step skipped.&quot;)self:onFail(&quot;本地资源错误，请重新下载游戏。&quot;)elselocal function onUpdateEvent(event)local eventCode = event:getEventCode()print(&quot;====== assetsmanagerex error code:&quot;, eventCode)--[[ cc.EventAssetsManagerEx.EventCode = {ERROR_NO_LOCAL_MANIFEST = 0,ERROR_DOWNLOAD_MANIFEST = 1,ERROR_PARSE_MANIFEST = 2,NEW_VERSION_FOUND = 3,ALREADY_UP_TO_DATE = 4,UPDATE_PROGRESSION = 5,ASSET_UPDATED = 6,ERROR_UPDATING = 7,UPDATE_FINISHED = 8,UPDATE_FAILED = 9,ERROR_DECOMPRESS = 10} ]]if eventCode == cc.EventAssetsManagerEx.EventCode.ERROR_NO_LOCAL_MANIFEST thenprint(&quot;No local manifest file found, skip assets update.&quot;)self:onFail(string.format(&quot;本地资源错误，请重新下载游戏。(错误码:%d)&quot;, eventCode))elseif eventCode == cc.EventAssetsManagerEx.EventCode.UPDATE_PROGRESSION thenlocal assetId = event:getAssetId()local percent = event:getPercent()local strInfo = &quot;&quot;if assetId == cc.AssetsManagerExStatic.VERSION_ID thenstrInfo = string.format(&quot;Version file: %d%%&quot;, percent)elseif assetId == cc.AssetsManagerExStatic.MANIFEST_ID thenstrInfo = string.format(&quot;Manifest file: %d%%&quot;, percent)elsestrInfo = string.format(&quot;%d%%&quot;, percent)endprogress:setString(strInfo)self:setLoadingProgress(event:getPercentByFile())elseif eventCode == cc.EventAssetsManagerEx.EventCode.ERROR_DOWNLOAD_MANIFEST oreventCode == cc.EventAssetsManagerEx.EventCode.ERROR_PARSE_MANIFEST thenprint(&quot;Fail to download manifest file, update skipped.&quot;)self:onFail(string.format(&quot;更新失败，请检查网络配置。(错误码:%d)&quot;, eventCode))elseif eventCode == cc.EventAssetsManagerEx.EventCode.ALREADY_UP_TO_DATE oreventCode == cc.EventAssetsManagerEx.EventCode.UPDATE_FINISHED thenprint(&quot;Update finished.&quot;)self:onSuccess()elseif eventCode == cc.EventAssetsManagerEx.EventCode.ERROR_UPDATING thenprint(&quot;Asset &quot;, event:getAssetId(), &quot;, &quot;, event:getMessage())-- self:onFail(string.format(&quot;更新资源失败，请检查网络后重试。(%d)&quot;, eventCode))elseif eventCode == cc.EventAssetsManagerEx.EventCode.UPDATE_FAILED thenprint(&quot;Fail to download resource files.&quot;)self._update_failed_count = self._update_failed_count + 1if self._update_failed_count &lt;= 3 thenprint(&quot;try again&quot;)am:downloadFailedAssets()elseself:onFail(string.format(&quot;更新失败，请检查网络配置。(错误码:%d)&quot;, eventCode))endelseif eventCode == cc.EventAssetsManagerEx.EventCode.NEW_VERSION_FOUND thenprint(&quot;new version found.&quot;)--am:update()elseif eventCode == cc.EventAssetsManagerEx.EventCode.ASSET_UPDATED thenprint(&quot;assets updated.&quot;)elseif eventCode == cc.EventAssetsManagerEx.EventCode.ERROR_DECOMPRESS thenprint(&quot;decompress error.&quot;)endendlocal listener = cc.EventListenerAssetsManagerEx:create(am, onUpdateEvent)cc.Director:getInstance():getEventDispatcher():addEventListenerWithFixedPriority(listener, 1)am:update()--am:checkUpdate()endendlocal function onExit()am:release()endlocal function onNodeEvent(event)if &quot;enter&quot; == event thenonEnter()elseif &quot;exit&quot; == event thenonExit()endendlayer:registerScriptHandler(onNodeEvent)self:addChild(layer)endfunction AutoUpdateScene:onFail(msg)print(&quot;====== update fail ======&quot;, msg)-- 热更新失败处理endfunction AutoUpdateScene:onSuccess()print(&quot;====== update success ======&quot;)local writablePath = cc.FileUtils:getInstance():getWritablePath()package.path = writablePath .. &quot;update/src/?.lua;./?.lua;&quot;-- 启动热更新后的场景endreturn AutoUpdateScene</code></pre><ul><li>推荐<ul><li><a href="https://blog.csdn.net/weixin_37730482/article/details/73299286" target="_blank" rel="noopener">https://blog.csdn.net/weixin_37730482/article/details/73299286</a></li><li><a href="https://blog.csdn.net/qq_32319583/article/details/53223452" target="_blank" rel="noopener">https://blog.csdn.net/qq_32319583/article/details/53223452</a></li><li><a href="https://blog.csdn.net/q277055799/article/details/8463835?utm_source=blogxgwz3****" target="_blank" rel="noopener">https://blog.csdn.net/q277055799/article/details/8463835?utm_source=blogxgwz3<em>**</em></a></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> cocos2dx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocos2dx </tag>
            
            <tag> 事件 </tag>
            
            <tag> cocos2dx lua 热更新原理与实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cocos2dx lua 多线程之协成理解与实战</title>
      <link href="/2018/10/29/cocos2dx-lua-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%8D%8F%E6%88%90%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98/"/>
      <url>/2018/10/29/cocos2dx-lua-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%8D%8F%E6%88%90%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98/</url>
      <content type="html"><![CDATA[<p>lua是不支持多线程的，一般都是协同来调用的。但是lua却可以调用c函数。于是，我们通过lua调用C接口起一个线程，实现lua多线程的使用。子线程再调用lua中的function。就可以通过子线程获取一些数据。单纯的人儿，以为一切都是美好的。</p><blockquote><p>问题就出现C调用lua中的function, 将数据传给lua。</p></blockquote><a id="more"></a><h3 id="lua的运行"><a href="#lua的运行" class="headerlink" title="lua的运行"></a>lua的运行</h3><p>首先我们需要知道，lua是解释性语言。是在执行的时候才分配堆栈空间。通过查看lua的源码，我们可以知道，在main函数的开端，lua就创建了一个全局的L（状态机），这个状态机可以说是lua的核心所在。它保存了栈的地址。</p><p>当执行lua脚本时，lua会将全局的变量和function记录在堆中，当执行代码段是，就会将一些局部变量和参数压到栈中进行处理。这一切和c语言的解析是一样的。</p><blockquote><p>我们知道C也是可以调用lua的function的，一般的操作是：</p><blockquote><ol><li>在lua中调用C函数，将需要注册的function，作为参数传给C函数</li><li>C将获取到的function和L（状态机）进行保存。</li><li>C通过向L压栈，将function和一些参数压入。通过lua_call函数进行调用。</li></ol></blockquote></blockquote><blockquote><p>根据上述的解释，我们可以知道。其中C和lua通过通信的是L（状态机）。压入栈之后，通过lua_call,就会进入lua的状态中。lua会处理栈中的内容。</p></blockquote><h3 id="问题所在"><a href="#问题所在" class="headerlink" title="问题所在"></a>问题所在</h3><p>核心问题就是C调用lua的L和lua的L是同一个L。这样就出现一个问题，当主线程的lua脚本才进行压栈操作，而子线程中也进行压栈操作，那岂不是乱了套？在一开始就不应该成功的，为什么会这样呢？通过查看代码，发现lua对进行堆操作的函数中，都加上了线程锁。当主线程进行栈操作时，子线程是不可以对栈进行操作的。</p><p>也就是说，子线程理论上是不会运行的，会卡在栈操作的函数那里。</p><blockquote><p>但是为什么我们在运行的时候并没有出现这个现象呢？通过代码的查询，发现是主线程中有sleep函数，并且子线程中有阻塞，所以能够在几个线程中切换。 如果主线程的while循环中没有sleep，那么就会很快的出现问题。因此，lua从底层就是不支持多线程的。</p></blockquote><h3 id="为什么使用协同"><a href="#为什么使用协同" class="headerlink" title="为什么使用协同"></a>为什么使用协同</h3><p>如果你搜索lua多线程，大多数都会写搜索到协同程序。</p><pre><code>每一个协程有自己的堆栈，自己的局部变量，可以通过yield-resume实现在协程间的切换。不同之处是：Lua协程是非抢占式的多线程，必须手动在不同的协程间切换，且同一时刻只能有一个协程在运行。并且Lua中的协程无法在外部将其停止，而且有可能导致程序阻塞。</code></pre><p>正如上诉，协同拥有自己的堆栈，那是用来避免和其他堆栈冲突的。但是两者之间想要通信，就不能通过栈了。因为栈的不同，压入的数据在另一端是无法接收到的。</p><p>但是，我们可以通过一个全局变量进行通信。比如，子线程通过协同的堆栈进行调用lua里面的function。在function中获取传入的值，将它赋值给一个全局变量。那么主线程也能够调用了。</p><h3 id="线程与协同"><a href="#线程与协同" class="headerlink" title="线程与协同"></a>线程与协同</h3><p>协同程序与线程thread差不多，也就是一条执行序列，拥有自己独立的栈、局部变量和命令指针，同时又与其他协同程序共享全局变量和其他大部分东西。可以通过yield-resume实现在协程间的切换。</p><blockquote><p>从概念上讲线程与协同程序的主要区别在于，一个具有多个线程的程序可以同时运行几个线程，而协同程序却需要彼此协作的运行。也就是说多个协同程序在任意时刻只能运行一个协同程序，只有当正在运行的协同程序显式的要求挂起时，它的执行才会暂停。</p></blockquote><ul><li><p>总结区别：</p><ul><li>不同之处是：Lua协程是非抢占式的多线程，必须手动在不同的协程间切换，且同一时刻只能有一个协程在运行。并且Lua中的协程无法在外部将其停止，而且有可能导致程序阻塞。</li></ul></li><li><p>关于更多区别和介绍，可以查看这里</p><ul><li><a href="https://www.cnblogs.com/work115/p/5620272.html" target="_blank" rel="noopener">https://www.cnblogs.com/work115/p/5620272.html</a></li><li><a href="https://www.cnblogs.com/lxmhhy/p/6041001.html" target="_blank" rel="noopener">https://www.cnblogs.com/lxmhhy/p/6041001.html</a></li></ul></li></ul><h3 id="协同程序coroutine"><a href="#协同程序coroutine" class="headerlink" title="协同程序coroutine"></a>协同程序coroutine</h3><p>Lua将所有关于协同程序的函数放置在一个名为“coroutine”的table中。</p><ul><li>1、coroutine.create创建一个thread类型的值表示新的协同程序，返回一个协同程序。</li><li>2、coroutine.status检查协同程序的状态（挂起suspended、运行running、死亡dead、正常normal）。</li><li>3、coroutine.resume启动或再次启动一个协同程序，并将其状态由挂起改为运行。</li><li>4、coroutine.yield让一个协同程序挂起。</li><li>5、coroutine.wrap同样创建一个新的协同程序，返回一个函数。</li></ul><blockquote><p>注意coroutine的三个状态：<br>suspended（挂起，协同刚创建完成时或者yield之后）、<br>running（运行）、<br>dead（函数走完后的状态，这时候不能再重新resume）。</p></blockquote><h5 id="创建协同程序："><a href="#创建协同程序：" class="headerlink" title="创建协同程序："></a>创建协同程序：</h5><p>create函数，接受一个函数值作为协同程序的执行内容，并返回一个协同程序。</p><pre><code>function func( ... ) print(&quot;iCocos&quot;) -- thread: 0x79f721d4 -- [Finished in 0.0s]endlocal  cor  = coroutine.create(func)print(cor)</code></pre><h5 id="启动或再次启动一个协同程序："><a href="#启动或再次启动一个协同程序：" class="headerlink" title="启动或再次启动一个协同程序："></a>启动或再次启动一个协同程序：</h5><p>resume函数，接受一个协同程序及一个或多个参数用于值传递给协同程序。</p><pre><code>function funcA(  _cor, ... ) print(&quot;A: status_1&quot;,coroutine.status(_cor), ...) -- A: status_1  running 1   2   3endlocal corA = coroutine.create(funcA)coroutine.resume(corA, corA, 1,2,3)print(&quot;A: status_2&quot;, coroutine.status(corA))-- A: status_2   dead</code></pre><h5 id="resume-yield数据交换"><a href="#resume-yield数据交换" class="headerlink" title="resume-yield数据交换"></a>resume-yield数据交换</h5><p>Lua中协同的强大能力，还在于通过resume-yield来交换数据：</p><ul><li>（1）resume把参数传给程序（相当于函数的参数调用）；</li><li>（2）数据由yield传递给resume;</li><li>（3）resume的参数传递给yield；</li><li>（4）协同代码结束时的返回值，也会传给resume</li></ul><p>协同中的参数传递形势很灵活，一定要注意区分，在启动coroutine的时候，resume的参数是传给主程序的；在唤醒yield的时候，参数是传递给yield的。 　　</p><blockquote><p>挂起协同程序：yield函数，让一个协同程序挂起，并等待下次恢复它的运行。它可以接受resume函数传递进来的所有参数。</p></blockquote><pre><code>-- resume  yield 参数传递function funcB( _cor )print(&quot;A: status_1&quot;, coroutine.status(_cor))ptint(&quot;A: status_2&quot;, coroutine.yield()) -- 挂起endlocal funcB = coroutine.create(funcB) -- wrap: wrap函数比create函数更易使用。它提供了一个对于协同程序编程实际所需的功能，即一个可以唤醒协同程序的函数。但也缺乏灵活性。无法检查wrap所创建的协同程序的状态，此外，也无法检测出运行时的错误。coroutine.resume(funcB, funcB) -- 启动，没有yield，参数属于主函数print(&quot;A: status_3&quot;, coroutine.status(funcB))coroutine.resume(funcB, 1,2,3) -- 从挂起出启动，并给yield传递参数print(&quot;A: status_4&quot;, coroutine.status(funcB))</code></pre><p>Lua提供的是一种：”非对称的协同程序“。也就是说，Lua提供了两个函数来控制协同程序的执行，一个用于挂起执行，另一个用于恢复执行。而一些其他的语言则提供了”对称的协同程序“，其中只有一个函数用于转让协同程序之间的执行权。</p><h3 id="管道与过滤器filter"><a href="#管道与过滤器filter" class="headerlink" title="管道与过滤器filter"></a>管道与过滤器filter</h3><p>关于协同程序的示例就是”生产者–消费者“的问题。其中涉及到两个函数，一个函数不断的产生值，另一个函数不断的消费这些值。</p><blockquote><p>当消费者需要一个新的值时，它唤醒生产者。生产者返回一个新值后停止运行，等待消费者的再次唤醒。这种设计称为”消费者驱动“。通过resume—yield 函数之间的值交换可以轻易的实现程序。</p></blockquote><p>过滤器filter，是一种位于生产者与消费者之间的处理功能，可以进行数据转换。它既是消费者又是生产者，它唤醒生产者促使其生产新值，然后又将变换后的值传递给消费者。</p><pre><code>--管道与过滤器filter--生产者与消费者通过过滤器进行值传递--这种模式通过消费者驱动生产者进行产生。--计数器函数function getCount( x )return function()x=x+1return xendend--创建闭合计数器local count = getCount(0)--发送新值function send(x)coroutine.yield(x)end--启动一个协同程序function receive( pro )local status,value = coroutine.resume( pro )return valueend--生产者function producter()while true dosend( count() )endend--过滤器，接受一个生产者function filter( pro )local x = 0return function()while true dox = receive( pro )send(x)endendend--消费者，接受一个生产者协同程序及控制条件，控制条件防止死循环--假设有100个消费者，驱动生产者来生产function consumer( pro,num )local x = 0while x &lt; num dox = receive( pro )print( x )endendlocal pro = coroutine.create( producter )local fil = coroutine.create( filter( pro ) )consumer( fil,100 )print( &quot;消费者协同程序状态：&quot;,coroutine.status(pro) )print( &quot;生产者协同程序状态：&quot;,coroutine.status(fil) )</code></pre><p>打印结果</p><pre><code>123...-- 消费者协同程序状态：   suspended-- 生产者协同程序状态：   suspended</code></pre><ul><li>推荐<ul><li><a href="https://github.com/lichuang/Lua-Source-Internal/blob/master/doc/ch09-%E5%8D%8F%E7%A8%8B.md" target="_blank" rel="noopener">https://github.com/lichuang/Lua-Source-Internal/blob/master/doc/ch09-%E5%8D%8F%E7%A8%8B.md</a></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> cocos2dx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocos2dx </tag>
            
            <tag> 事件 </tag>
            
            <tag> cocos2dx lua 多线程之协成理解与实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cocos2dx lua 安全之加密与解密实现</title>
      <link href="/2018/10/27/cocos2dx-lua-%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/10/27/cocos2dx-lua-%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<pre><code>非常多使用cocos2dx+lua做游戏的同学。都会想到一个问题，我的游戏一旦公布，如何才干保证的我脚本代码不被破解。不泄露代码。尽管这和开源、共享的原则不合。可是代码也是coder的劳动成果，理应得到保护。</code></pre><p>特别是商业游戏更是如此，不希望被别人破解掉源代码而且进行改动。</p><p>今天的话题就是怎样实现lua脚本文件的加密和解密。</p><a id="more"></a><p>我在网络上查过，都没有成熟的解决方式。然后我经过考虑之后，总结出两种解决方式，供大家參考。</p><ul><li><p>1、轻量级的解决方式。APK打包之前，用工具把全部的lua文件加密，详细是将lua文件读到内存，然后使用zip等压缩加密库进行压缩加密，然后将压缩加密之后的数据保存为和源文件同名的文件。</p><ul><li>打包之后执行lua文件的时候。则先读出lua数据。然后进行解密。将解密后的流数据传给lua虚拟机。</li></ul></li><li><p>2、重量级的解决方式，此方案是上一种方案的扩展。也是商用游戏的方案，实现一个游戏文件包，打包前将资源和脚本都使用工具打包到一个文件。能够在打包的时候加密压缩，也能够不加密压缩。</p><ul><li>然后在执行的时候直接从包内读出对应文件的数据。然后解密解压缩。然后提供给游戏引擎使用。这也是端游普遍使用的技术，手游眼下大部分也開始使用此技术。</li></ul></li></ul><p>本文主要简要解说第一种方案，另外一种方案则有时间再写一篇博客。好了。我们開始进入正题吧。</p><p>首先是压缩lua文件。代码例如以下：     </p><pre><code>int write_file_content(const char* folder){    //获得文件数据，并压缩文件    FILE* fpin = fopen(folder, &quot;wb+&quot;);    if (fpin == NULL)    {        printf(&quot;无法读取文件: %s\n&quot;, folder);        return 0;    }    //得到文件大小    fseek(fpin, 0, SEEK_END);    unsigned int size = ftell(fpin);    //读出文件内容    fseek(fpin, 0, SEEK_SET);    void* con = malloc(size);    int r = fread(con, size, 1, fpin);        //进行加密操作    unsigned long zip_con_size = size * 2;    void* zip_con = malloc(zip_con_size);    if (Z_OK != compress((Bytef*)zip_con, &amp;zip_con_size, (Bytef*)con, size))     {        printf(&quot;压缩 %s 时错误发生\n&quot;,folder);    }    printf(&quot;%s 压缩前大小：%ld 压缩后大小：%ld\n&quot;, folder,  size,  zip_con_size);    //写文件内容    fseek(fpin, 0, SEEK_SET);    int len = fwrite(zip_con, zip_con_size, 1, fpin);    //释放资源    fclose(fpin);    free(zip_con);    free(con);        return 0;}</code></pre><p>然后是解密操作。代码例如以下：</p><pre><code>void* read_file_content(const char* folder, int&amp; bufflen){    FILE* file = fopen(folder, &quot;wb+&quot;);    if (file)    {        {        printf(&quot;无法读取文件: %s\n&quot;, folder);        return 0;    }    //获取文件大小    fseek(file, 0, SEEK_END);    unsigned int size = ftell(file);    //读出文件内容    void* con = malloc(size);    fseek(file, 0, SEEK_SET);    int len = fread(con, size, 1, file);    //解压缩操作    unsigned long zip_size = size * 4;    void* zip_con = malloc(zip_size);    int code = uncompress((Bytef*)zip_con, &amp;zip_size, (Bytef*)con, size);    if (Z_OK != code)    {        printf(&quot;解压 %s 时错误发生 :%d\n&quot;, folder, code);        return 0;    }    //释放资源    fclose(file);    free(con);    //zip_con由外部释放    bufflen = zip_size;    return zip_con。}</code></pre><p>最后就把此流文件塞给lua的虚拟机就可以，即以流方式执行lua代码。</p><blockquote><p>当然更高级一点的方法是直接改写lua的文件载入策略</p></blockquote>]]></content>
      
      <categories>
          
          <category> cocos2dx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocos2dx </tag>
            
            <tag> 事件 </tag>
            
            <tag> cocos2dx lua 安全之加密与解密实现 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cocos2dx lua (伪)面向对象理解与实战应用</title>
      <link href="/2018/10/24/cocos2dx-lua-%E4%BC%AA-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"/>
      <url>/2018/10/24/cocos2dx-lua-%E4%BC%AA-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<blockquote><p>面向对象    </p></blockquote><pre><code>&gt;&gt; 把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class）&gt;&gt; 通过类的封装（encapsulation）隐藏内部细节&gt;&gt; 通过继承（inheritance）实现类的特化（specialization）／泛化（generalization）&gt;&gt; 通过多态（polymorphism）实现基于对象类型的动态分派（dynamic dispatch）</code></pre><a id="more"></a><h3 id="1-lua中的类"><a href="#1-lua中的类" class="headerlink" title="1.lua中的类"></a>1.lua中的类</h3><p>lua中其实是没有类的，有的只是表(table)，而类之间的继承也就是将父类的表连到了一起，派生类中没有找到的属性和方法就通过元表查找父类</p><h3 id="2-lua中类的属性"><a href="#2-lua中类的属性" class="headerlink" title="2.lua中类的属性"></a>2.lua中类的属性</h3><pre><code>classA = {width =10, height=10}classA={}classA.width=10classA.height=10</code></pre><p>两种方法都可以，通过点self.width统一调用</p><h3 id="3-类方法"><a href="#3-类方法" class="headerlink" title="3.类方法"></a>3.类方法</h3><pre><code>[cpp] view plaincopyfunction Box:collsion()-- 默认第一个参数隐藏传递self，可以通过self.xxx 调用属性和方法endfunction Box.create(self)--必须手动传递参数self,否则无法用self.xxx调用属性和方法end</code></pre><h3 id="4-类与元表的用法"><a href="#4-类与元表的用法" class="headerlink" title="4.类与元表的用法"></a>4.类与元表的用法</h3><ul><li>lua查找一个表元素时的规则，其实就是如下3个步骤:<ul><li>4.1.在表中查找，如果找到，返回该元素，找不到则继续</li><li>4.2.判断该表是否有元表，如果没有元表，返回nil，有元表则继续</li><li>4.3.判断元表有没有<strong>index方法，如果</strong>index方法为nil，则返回nil；如果<strong>index方法是一个表，则重复1、2、3；如果</strong>index方法是一个函数，则返回该函数的返回值</li></ul></li></ul><p>在Lua中，函数的声明和调用可以用”:”和”.”，属性调用全部用点”.”</p><blockquote><p>我们知道，对象由属性和方法组成。LUA中最基本的结构是table，所以需要用table来描述对象的属性。</p></blockquote><p>lua中的function可以用来表示方法。那么LUA中的类可以通过table + function模拟出来。</p><p>至于继承，可以通过metetable模拟出来（不推荐用，只模拟最基本的对象大部分时间够用了）。</p><blockquote><p>Lua中的表不仅在某种意义上是一种对象。像对象一样，表也有状态（成员变量）；也有与对象的值独立的本性，特别是拥有两个不同值的对象（table）代表两个不同的对象；一个对象在不同的时候也可以有不同的值，但他始终是一个对象；与对象类似，表的生命周期与其由什么创建、在哪创建没有关系。</p></blockquote><h5 id="1-初步面向对象"><a href="#1-初步面向对象" class="headerlink" title="1. 初步面向对象"></a>1. 初步面向对象</h5><pre><code>ObjectData = {balance = 0}function ObjectData.count( v )    -- body    print(&quot;value is :&quot;, v)enda = ObjectDataa.count(&quot;iCocos&quot;)-- value is :    iCocos</code></pre><h5 id="2-面向对象模拟"><a href="#2-面向对象模拟" class="headerlink" title="2. 面向对象模拟"></a>2. 面向对象模拟</h5><pre><code>ObjectData = {balance = 100}function ObjectData.count( self, v )    self.balance = self.balance + v    print(&quot;value is :&quot;, v, self.balance)enda = ObjectDataa.count(a, 99) -- 传递self-- value is :    99    199a:count(99) -- 不传self，直接把a作为self传递进入，-- value is :    99    298</code></pre><h3 id="Lua中的继承"><a href="#Lua中的继承" class="headerlink" title="Lua中的继承"></a>Lua中的继承</h3><h5 id="先来定义一个基类，"><a href="#先来定义一个基类，" class="headerlink" title="先来定义一个基类，"></a>先来定义一个基类，</h5><p>使用前面讲的setmetatable来实现基本的元表</p><pre><code>local _M = {}function _M:new(name)return setmetatable({ name = name}, { __index = _M })endfunction _M:show()print(self.name .. &quot;: show in parent:&quot;)endfunction _M:hello(arg)print(self.name .. &quot;: hello in parent:&quot; .. tostring(arg))endreturn  _M</code></pre><h5 id="子类的实现"><a href="#子类的实现" class="headerlink" title="子类的实现"></a>子类的实现</h5><pre><code>local parent = require(&quot;parent&quot;)local _M = {}function _M:new()local obj = parent:new(&quot;the child&quot;)local super_mt = getmetatable(obj)-- 当方法在子类中查询不到时，再去父类中去查找。setmetatable(_M, super_mt)-- 这样设置后，可以通过self.super.method(self, ...) 调用父类的已被覆盖的方法。obj.super = setmetatable({}, super_mt)return setmetatable(obj, { __index = _M })end-- 覆盖父类的方法。function _M:hello()-- 只能使用这种方法调用基类的方法。self.super.hello(self, &quot;call from child&quot;)print(tostring(self.name) .. &quot;: hello in child&quot;)endreturn _Mtest.lua (使用)-- local parent = require(&quot;parent&quot;)local child = require(&quot;child&quot;)local c = child:new()-- 从parent继承的show方法c:show()-- child自己的方法。c:hello()</code></pre><p>执行lua test.lua 后 输出：</p><pre><code>the child: show in parent:the child: hello in parent:call from childthe child: hello in child</code></pre><ul><li>可以看到：<ul><li>show是继承了父类的方法。</li><li>hello是由子类覆盖了，并且在hello中调用了父类的hello方法。</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> cocos2dx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocos2dx </tag>
            
            <tag> 事件 </tag>
            
            <tag> cocos2dx lua (伪)面向对象理解与实战应用 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cocos2dx lua cc &amp; ccs &amp; ccui区别和使用</title>
      <link href="/2018/10/22/cocos2dx-lua-cc-ccs-ccui%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/10/22/cocos2dx-lua-cc-ccs-ccui%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>最近遇到一个问题，网上一些教程，或者官方的一些教程，在对应使用cc，ccs ,ccui的时候，导致我这边没有提示，开始以为是编辑器的问题，然后硬写上去之后，在调试的时候直接报错，经过多次查看Api文档发现，我使用的Api中，并没有这个方法，那么问题来了！</p><ul><li>我应该怎么去调用这个对应的Api呢？</li><li>如何验证使用cocos2dx lua调用Api是正常的呢？</li><li>遇到一个功能或者一个需求，应该如何查找对应的Api呢？</li></ul><a id="more"></a><h5 id="网上有个朋友说了这么一段原话："><a href="#网上有个朋友说了这么一段原话：" class="headerlink" title="网上有个朋友说了这么一段原话："></a>网上有个朋友说了这么一段原话：</h5><blockquote><p>同一个框架里Api名字大小不统一我也就忍了（setBackGround…和setBackground…），可是同一个类名却表达两个不同的东西这个实在让我非常气愤，刚才瞎研究半天ScrollView才发现我程序里用的是ccui.ScrollView对象，而我盯着cc.ScrollView看了半天，我说怎么Api对不上号！</p></blockquote><p>其实大概的意思就是cocos2dx lua对应Api版本号的问题,因为以前cocos用cocos2d-lua写，后来带领大家往quick转，现在合并之后，又带领大家回到cocos2d-lua，所以必定会产生一些规范和版本号的区别。</p><blockquote><p>尤其在2.x和3.x之间的变化比较大，或者是<a href="https://github.com/fusijie/Cocos-Resource" target="_blank" rel="noopener">quick版本和整合版</a>的多种调整。</p></blockquote><ul><li><p>这里主要介绍关于cc，ccs ,ccui的区别，使用和注意点，如果要了解更多2.x和3.x版本之前的问题和区别，可以参考这里：</p><ul><li><a href="https://github.com/cocos2d/cocos2d-x/blob/cocos2d-x-3.0/docs/RELEASE_NOTES.md#user-content-use-ccccsccui-gl-and-sp-as-module-name" target="_blank" rel="noopener">cocos2d-x v3.0 Release Notes</a></li></ul></li></ul><h2 id="cc-amp-ccs-amp-ccui"><a href="#cc-amp-ccs-amp-ccui" class="headerlink" title="cc &amp; ccs &amp; ccui"></a>cc &amp; ccs &amp; ccui</h2><p>经过可靠资料和官方提供的信息我们可以得出一个大概的结论：</p><ul><li>cc代表Cocos核心: Cocos2DConstants.lua 储存</li><li>ccs代表CocoStudio: StudioConstants.lua 储存</li><li>ccui代表CocoStudio的UI控件: GuiConstants.lua 储存</li></ul><p>cc和ccui倒是很好理解，那么ccs这么理解呢？</p><blockquote><p>其实应该说相当于C++的命名空间，ccs是cocostudio的缩写，代表在CocoStudio的命名空间（只是类似）。</p></blockquote><h5 id="比如我们发现"><a href="#比如我们发现" class="headerlink" title="比如我们发现"></a>比如我们发现</h5><ul><li>之前的cc.ui.xxx是quick自己封装过的控件，</li><li>而ccs里面的对象是c++里面的原生控件</li><li>若使用cc.ui.xxx将出现在ccs里面有交互的时候无法响应touch事件的问题</li><li>必须用ccui.xxx，这个是c++里面的控件，touchEvent也是同一体系的。</li><li>并且ccui.ScrollView 对应 cocos2d::ui::ScrollView，cc.ScrollView 对应 cocos2d::extension::ScrollView</li></ul><h3 id="我们来看看，最简单而且最常用的Button按钮的创建："><a href="#我们来看看，最简单而且最常用的Button按钮的创建：" class="headerlink" title="我们来看看，最简单而且最常用的Button按钮的创建："></a>我们来看看，最简单而且最常用的Button按钮的创建：</h3><h4 id="这是老版的-quick"><a href="#这是老版的-quick" class="headerlink" title="这是老版的(quick)"></a>这是老版的(quick)</h4><pre><code>cc.ui.UIPushButton.new({ normal = &quot;comm_btnGreenBackBack.png&quot;, pressed = &quot;comm_btnGreenBackBack_sel.png&quot; })    :onButtonClicked(function()        print(&quot;start&quot;)    end)    :pos( display.cx / 2, display.cy )    :addTo(self)</code></pre><ul><li><p>在Quick中有三种不同的Button控件，分别是：UIPushButton (按钮控件)、UICheckBoxButton ( CheckButton 控件)和 UICheckBoxButtonGroup ( CheckButton 组控件)。</p><ul><li>其中 UIPushButton 是最常用的按钮控件，它继承自UIButton，我们可以通过 cc.ui.UIPushButton.new(images, options) 方法来创建 UIPushButton。</li><li>参数 images 是 table 类型，它代表各个按钮状态（正常、按下、禁用）下的图片；options 为可选参数，也是 tabl e类型，包含了是否scale9缩放，偏移flipX、flipY值等设置。</li></ul></li></ul><p>onButtonClicked 方法用于监听按钮的点击事件，当点击按钮时，将调用该方法中的代码。如上例中，当我们点击按钮时，会在控制台窗口中打印“start”的字段。同 onButtonClicked 方法类似的还有：</p><pre><code>onButtonPressed(callback)：用于监听按钮的按下事件onButtonRelease(callback)：用于监听按钮的释放事件onButtonStateChanged(callback)：用于监听按钮的状态改变事件</code></pre><h4 id="新版本Button"><a href="#新版本Button" class="headerlink" title="新版本Button"></a>新版本Button</h4><pre><code>    --这是一个按钮local btn = ccui.Button:create(&quot;button/btnDog_N.png&quot;, &quot;button/btnDog_P.png&quot;, &quot;button/btnDog_D.png&quot;, 0)    :pos(display.cx, 100)    :addTo(self)    --按钮文字    btn:setTitleText(&quot;按钮&quot;)    --字体大小    btn:setTitleFontSize(25)    --偏移    btn:setTitleOffset(20, 100)    --字体颜色    btn:setTitleColor(cc.c3b(255, 255, 255))    --按钮的回调函数    btn:addTouchEventListener(function(sender, eventType)    if (0 == eventType)  then        print(&quot;pressed&quot;)    elseif (1 == eventType)  then          print(&quot;move&quot;)    elseif  (2== eventType) then          print(&quot;up&quot;)    elseif  (3== eventType) then        print(&quot;cancel&quot;)    endend)--按钮无效--btn:setEnabled(false)</code></pre><p>以上就是基本按钮的创建，所以平时在开发中要注意一下API的问题，不然很多错误都不知道问题出在哪里！   </p><h5 id="在我们平时使用控件的时候，也同样会遇到一些问题，比如"><a href="#在我们平时使用控件的时候，也同样会遇到一些问题，比如" class="headerlink" title="在我们平时使用控件的时候，也同样会遇到一些问题，比如"></a>在我们平时使用控件的时候，也同样会遇到一些问题，比如</h5><ul><li>quick中的cc.ui.UIPushButton和ccui.Layout是不能共存的，在layout存在的情况下UIPushButton是不能被监听到的</li><li>如果在quick中使用ccui.Button，那么ccui.Button是不能被屏蔽的，也就是说，无论quick中怎么处理不让ccui.Button被点击都无效，只要他存在，就会被点击。</li><li>同时cc.ui.UIScrollView也存在问题，其不能被缩放，但是其父节点可以缩放。</li><li>cc.ui.UIListView也存在不能缩放的问题。</li></ul><blockquote><p>也就是说，以上API中，一旦按设计的分辨率来设计，就不能再被缩放。</p></blockquote><h3 id="Api官方文档验证"><a href="#Api官方文档验证" class="headerlink" title="Api官方文档验证"></a>Api官方文档验证</h3><p>为了验证这个问题我们查看官方文档发现这样的内容：</p><pre><code>Misc Api changesUse cc、ccs、ccui gl and sp as module nameNow classes are bound into different modules instead of using global module. This will avoid conflicts with other codes.    classes in cocos2d、cocos2d::extension、CocosDenshion and cocosbuilder were bound to cc module    classes in cocos2d::ui were bound to ccui module    classes in spine were bound to sp module    classes in cocostudio were bound to ccs module    global variables are bound to corresponding modules    all funcionts and constants about openGl were bound to gl moduleExamples:    | v2.1                    | v3.0                    |    | CCDirector              | cc.Director             |    | CCArmature              | ccs.Armature            |    | kCCTextAlignmentLeft    | cc.kCCTextAlignmentLeft |</code></pre><p>最终所表达的意思其实就是</p><ul><li>现在，类被绑定到不同的模块中，而不是使用全局模块。这将避免与其他代码发生冲突。</li><li>CCOS2D、COCOS2D:：扩展、COCOSDENSHION和COCOSUBIDER绑定到CC模块</li><li>CCOS2D:：UI绑定到CCUI模块</li><li>脊柱类与SP模块结合</li><li>COStudio中的类绑定到CCS模块</li><li>全局变量绑定到相应模块。</li><li>OpenGL的所有函数和常数都绑定到GL模块。</li></ul><blockquote><p>OpenGL和SP可以忽略</p></blockquote><h3 id="实战与代码验证"><a href="#实战与代码验证" class="headerlink" title="实战与代码验证"></a>实战与代码验证</h3><p>最后，我们为了cc，ccs，ccui专门去寻找了一些关于Api所提供的支持和规律。</p><h5 id="cc在Cocos2dConstants-lua中-用来存储cc-模块的常量"><a href="#cc在Cocos2dConstants-lua中-用来存储cc-模块的常量" class="headerlink" title="cc在Cocos2dConstants.lua中,用来存储cc 模块的常量"></a>cc在Cocos2dConstants.lua中,用来存储cc 模块的常量</h5><pre><code>cc = cc or {}</code></pre><ul><li>并且每个可调用的文件对应的最前面也有同样的定义,比如有<ul><li>Action.lua</li><li>Animation.lua</li><li>Director.lua</li><li>EventDispatcher.lua</li><li>GLView.lua</li><li>Hide.lua</li><li>Image.lua</li><li>Node.lua</li><li>Scene.lua</li><li>Scheduler.lua</li><li>SpriteFrame.lua</li><li>SpriteFrameCache.lua</li><li>TextureCache.lua</li><li>Timer.lua</li><li>Touch.lua</li><li>UserDefault.lua</li><li>src/cocos/cocos2d/Cocos2d.lua</li><li>src/cocos/cocos2d/Cocos2dConstants.lua</li><li>src/cocos/controller/ControllerConstants.lua</li><li>……</li></ul></li></ul><h5 id="ccs在StudioConstants-lua中-用来存储ccs模块的常量"><a href="#ccs在StudioConstants-lua中-用来存储ccs模块的常量" class="headerlink" title="ccs在StudioConstants.lua中,用来存储ccs模块的常量"></a>ccs在StudioConstants.lua中,用来存储ccs模块的常量</h5><pre><code>ccs = ccs or {}</code></pre><ul><li>并且每个可调用的文件对应的最前面也有同样的定义,比如有<ul><li>ActionFrame.lua</li><li>ActionObject.lua</li><li>Armature.lua</li><li>Bone.lua</li><li>ColorFrame.lua</li><li>ComAttribute.lua</li><li>ComController.lua</li><li>Frame.lua</li><li>Skin.lua</li><li>TextureFrame.lua</li><li>Timeline.lua</li><li>VisibleFrame.lua</li><li>……</li></ul></li></ul><h5 id="ccui在GuiConstants-lua中-用来存储ccui模块的常量"><a href="#ccui在GuiConstants-lua中-用来存储ccui模块的常量" class="headerlink" title="ccui在GuiConstants.lua中,用来存储ccui模块的常量"></a>ccui在GuiConstants.lua中,用来存储ccui模块的常量</h5><pre><code>ccui = ccui or {}</code></pre><ul><li>并且每个可调用的文件对应的最前面也有同样的定义,比如有<ul><li>Button.lua</li><li>CheckBox.lua</li><li>EditBox.lua</li><li>Helper.lua</li><li>ImageView.lua</li><li>Layout.lua</li><li>ListView.lua</li><li>LoadingBar.lua</li><li>PageView.lua</li><li>ScrollView.lua</li><li>Slider.lua</li><li>Text.lua</li><li>TextField.lua</li><li>……</li></ul></li></ul><h6 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h6><ul><li><a href="https://blog.csdn.net/blackzhangwei/article/details/80088314?utm_source=blogxgwz0" target="_blank" rel="noopener">https://blog.csdn.net/blackzhangwei/article/details/80088314?utm_source=blogxgwz0</a><ul><li><a href="https://github.com/fusijie/Cocos2dx-Release-Note/blob/master/cocos2d-x_v3.0_release_notes.md" target="_blank" rel="noopener">cocos2d-x_v3.0_release_notes.md</a></li><li><a href="http://blog.csdn.net/ls1122/article/details/38339851" target="_blank" rel="noopener">C++11 新特性</a></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> cocos2dx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocos2dx </tag>
            
            <tag> 游戏 </tag>
            
            <tag> cocos2dx lua cc &amp; ccs &amp; ccui区别和使用 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cocos2dx lua 常见错误汇总与解决方案</title>
      <link href="/2018/10/21/cocos2dx-lua-%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E6%B1%87%E6%80%BB%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2018/10/21/cocos2dx-lua-%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E6%B1%87%E6%80%BB%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<p>cocos2dx lua开比较苦恼的是，没办法断点或者直接一步一步调试处理，但是幸好官方有点良心，给了一个打印的调试Log，我们可以使用它调试和查找对应的错误。</p><p>这里就记录一些，个人学习和实战中遇到的一些错误和问题的总结</p><a id="more"></a><ul><li>not found view “ApiTest” in search paths “app.views”  <ul><li>ApiTest不在Views里面或者名字写错了，或者没有初始化</li></ul></li></ul><ul><li>attempt to index upvalue ‘HttpSingleton’ (a boolean value)<ul><li>末尾没有返回HttpSingleton</li></ul></li></ul><ul><li>attempt to index local ‘self’ (a nil value) <ul><li>参数传错了或者将逗号(.)与冒号(:)搞混了</li></ul></li></ul><ul><li>attempt to call method ‘schedulerScriptFunc’ (a nil value)<ul><li>方法写错了</li></ul></li></ul><ul><li>attempt to call global ‘getScheduler’ (a nil value)<ul><li>代码或者语法错误</li></ul></li></ul><ul><li>syntax error during pre-compilation<ul><li>严重的语法错误</li></ul></li></ul><ul><li>invalid ‘cobj’ in function ‘lua_cocos2dx_Node_getLocalZOrder’<ul><li>这个报错是lua的变量还在，但是他底层对应的C++对象已被销毁。</li></ul></li></ul><ul><li>InterpolationMissingOptionError: Bad value substitution:<ul><li>在执行genbindings.py脚本文件时，不要在该文件的外部路径执行，需要CD到该文件目录下执行./genbindings.py</li></ul></li></ul><ul><li>TranslationUnitLoadError: Error parsing translation unit.<ul><li>基本都是.ini文件没有配置正确，仔细检查一下 .ini文件里的 “headers = ”指向的路径是否正确</li></ul></li></ul><ul><li>Xcode编译错误，header error<ul><li>再此外，把.hpp和.cpp加进cocos2d_lua_bindings.xcodeproj时，target需要勾选ios。在设置 UserHeaderSearchPaths 时，注意选择该proj的Ios target进行设置 ，不要选择了mac target 选项，否则ios环境编译不过</li></ul></li></ul><ul><li>mportError: No module named yaml<ul><li>安装了yaml模块，如果还是报错找不到这个模块，这个就是是路径问题，因为我从新安装了python，然而：这里使用的python是系统默认的#!/usr/bin/python，处理好python版本和当前匹配的版本<ul><li>网上说还有其他方式解决(待验证)<ul><li>import sys</li><li>sys.path.append(‘/xxx/xxxxx/‘) 加进去也行。</li></ul></li></ul></li></ul></li></ul><ul><li>attempt to perform arithmetic on local ‘x’ (a nil value)<ul><li>忘了记录…..</li></ul></li></ul><p>这里专门说需要关于cocos2dx lua开发中的错误，其实cocos2dx lua中也和iOS中一样，分为两种错误：编译时错误和运行时错误</p><ul><li>编译错误，一般是语法上存在问题，编译过不去;</li><li>运行错误，是指程序在运行过程中出现错误，只能说是程序存在一定的边界bug;</li></ul><h3 id="编译时错误和运行时错误"><a href="#编译时错误和运行时错误" class="headerlink" title="编译时错误和运行时错误"></a>编译时错误和运行时错误</h3><h4 id="编译错误，"><a href="#编译错误，" class="headerlink" title="编译错误，"></a>编译错误，</h4><p>比如上面一条</p><pre><code>error:syntax error during pre-compliation</code></pre><p>就属于编译语法错误，这里报错其实还会有一些提示信息，如果我们可以通过提示信息，找到LuaStack，在LuaStack中有个LuaStack::luaLoadBuffer(…)，然后查看源码如下：</p><pre><code>switch (r){　　case LUA_ERRSYNTAX:     // 编译出错　　CCLOG(&quot;[LUA ERROR] load \&quot;%s\&quot;, error: syntax error during pre-compilation.&quot;, chunkName);　　break;　　case LUA_ERRMEM:        // 内存分配错误　　CCLOG(&quot;[LUA ERROR] load \&quot;%s\&quot;, error: memory allocation error.&quot;, chunkName);　　break;　　case LUA_ERRRUN:        // 运行错误　　CCLOG(&quot;[LUA ERROR] load \&quot;%s\&quot;, error: run error.&quot;, chunkName);　　break;　　case LUA_YIELD:         // 线程被挂起　　CCLOG(&quot;[LUA ERROR] load \&quot;%s\&quot;, error: thread has suspended.&quot;, chunkName);　　break;　　case LUA_ERRFILE:　　CCLOG(&quot;[LUA ERROR] load \&quot;%s\&quot;, error: cannot open/read file.&quot;, chunkName);　　break;　　case LUA_ERRERR:        // 运行错误处理函数时发生错误　　CCLOG(&quot;[LUA ERROR] load \&quot;%s\&quot;, while running the error handler function.&quot;, chunkName);　　break;　　default:　　CCLOG(&quot;[LUA ERROR] load \&quot;%s\&quot;, error: unknown.&quot;, chunkName);}</code></pre><p>所以，无论怎样，出现错误时，都能将错误信息返回到堆栈的最顶层</p><h5 id="如果遇到编译错误是，可以通过如下的代码来打印错误信息：在以上-之外的后面加"><a href="#如果遇到编译错误是，可以通过如下的代码来打印错误信息：在以上-之外的后面加" class="headerlink" title="如果遇到编译错误是，可以通过如下的代码来打印错误信息：在以上{}之外的后面加"></a>如果遇到编译错误是，可以通过如下的代码来打印错误信息：在以上{}之外的后面加</h5><pre><code>const char* error = lua_tostring(L, -1);CCLOG(&quot;[LUA ERROR] error result: %s&quot;,error);lua_pop(L, 1);</code></pre><p>　　</p><h4 id="运行错误"><a href="#运行错误" class="headerlink" title="运行错误"></a>运行错误</h4><p>而针对于运行错误，一般情况下，你可以参考如下代码(此代码在main.lua中)：</p><pre><code>-- lua提供，调用其他函数，可以捕捉到错误，第一个参数为要调用的函数， 第二个参数为捕捉到错误时所调用的函数-- 返回的参数status为错误状态， msg为错误信息local status, msg = xpcall(main, __G__TRACKBACK__)if not status thenprint(msg)end</code></pre><ul><li>推荐<ul><li><a href="http://www.cocoachina.com/bbs/read.php?tid=200145" target="_blank" rel="noopener">http://www.cocoachina.com/bbs/read.php?tid=200145</a></li><li><a href="https://blog.csdn.net/msdb198901/article/details/52128175" target="_blank" rel="noopener">https://blog.csdn.net/msdb198901/article/details/52128175 </a></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> cocos2dx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocos2dx </tag>
            
            <tag> 事件 </tag>
            
            <tag> cocos2dx lua 常见错误汇总与解决方案 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cocos2dx lua TableView(ScrollView, ListView)介绍与使用实战</title>
      <link href="/2018/10/19/cocos2dx-lua-TableView-ScrollView-ListView-%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%AE%9E%E6%88%98/"/>
      <url>/2018/10/19/cocos2dx-lua-TableView-ScrollView-ListView-%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%AE%9E%E6%88%98/</url>
      <content type="html"><![CDATA[<p>在众多移动应用中，能看到各式各样的列表/表格数据</p><blockquote><p>不管是iOS中的UITableView/UICollectionView/UIScrollView,还是Android中的ListView/CircleView，都是实际项目开发中使用最平凡，也是最重要的功能。</p></blockquote><p>为了用户考虑，也为了性能考虑， 我们一般都会重复利用所创建的列表项，这样就避免了界面卡顿。cocos2dx lua 3.x中有一个TabeView，效果和上面列举的那些做列表的一样，尤其与iOS中UITableView方法属性，使用方式都有很多相似的地方。</p><a id="more"></a><blockquote><p>游戏开发中，虽然没有和普通应用那么多列表，但是也会有些消息列表，用户，排行榜等，所以，这篇我们就来看看如何用TableView以及解决在实际开发中的一些问题。</p></blockquote><h3 id="TableView使用"><a href="#TableView使用" class="headerlink" title="TableView使用"></a>TableView使用</h3><p>直接上代码，这里我们使用cocos2dx lua提供TableView实现水平和垂直的列表，基本满足常见功能，具体细节，可以根据注释或者代码逻辑，结合实际需求进行调整和优化</p><pre><code>local TableScene = class(&quot;TableScene&quot;)TableScene.__index = TableScene--这里是为了让layer能调用TableViewTestLayer的方法function TableScene.extend(target)    local t = tolua.getpeer(target)    if not t then        t = {}        tolua.setpeer(target, t)    end    setmetatable(t, TableScene)    return targetend--滚动事件function TableScene.scrollViewDidScroll(view)    --print(&quot;滚动事件&quot;)endfunction TableScene.scrollViewDidZoom(view)    print(&quot;scrollViewDidZoom&quot;)end--cell点击事件function TableScene.tableCellTouched(table,cell)    print(&quot;点击了cell：&quot; .. cell:getIdx())end--cell的大小，注册事件就能直接影响界面，不需要主动调用function TableScene.cellSizeForTable(table,idx)    return 150,150end--显示出可视部分的界面，出了裁剪区域的cell就会被复用function TableScene.tableCellAtIndex(table, idx)    local strValue = string.format(&quot;%d&quot;,idx)    print(&quot;数据加载&quot;..strValue)    local cell = table:dequeueCell()    local label = nil    if nil == cell then        print(&quot;创建了新的cell&quot;)        cell = cc.TableViewCell:new()        --添加cell内容        local sprite = display.newSprite(&quot;res/apple.png&quot;)        sprite:setAnchorPoint(cc.p(0,0))        sprite:setPosition(cc.p(0, 0))        cell:addChild(sprite)        label = cc.Label:createWithSystemFont(strValue, &quot;Helvetica&quot;, 40)        label:setPosition(cc.p(0,0))        label:setAnchorPoint(cc.p(0,0))        label:setColor(cc.c3b(255,0,0))        label:setTag(123)        cell:addChild(label)    else        print(&quot;使用已经创建过的cell&quot;)        label = cell:getChildByTag(123)        if nil ~= label then            label:setString(strValue)        end    end    return cellend--设置cell个数，注册就能生效，不用主动调用function TableScene.numberOfCellsInTableView(table)    return 100endfunction TableScene:init()    local visiableSize = cc.Director:getInstance():getVisibleSize()    local origin = cc.Director:getInstance():getVisibleOrigin()    local winSize = cc.Director:getInstance():getWinSize()    local isVERTICAL = false    if isVERTICAL then        -----------------------------------------------------------        --创建TableView        local tableView = cc.TableView:create(cc.size(winSize.width - 20,150))        --设置滚动方向  水平滚动        tableView:setDirection(cc.SCROLLVIEW_DIRECTION_HORIZONTAL)        tableView:setPosition(cc.p(10, winSize.height / 2))        tableView:setDelegate()        self:addChild(tableView)        --registerScriptHandler functions must be before the reloadData funtion        --注册脚本编写器函数必须在reloadData函数之前（有道自动翻译）        --cell个数        tableView:registerScriptHandler(TableScene.numberOfCellsInTableView,cc.NUMBER_OF_CELLS_IN_TABLEVIEW)        --滚动事件        tableView:registerScriptHandler(TableScene.scrollViewDidScroll,cc.SCROLLVIEW_SCRIPT_SCROLL)        tableView:registerScriptHandler(TableScene.scrollViewDidZoom,cc.SCROLLVIEW_SCRIPT_ZOOM)        --cell点击事件        tableView:registerScriptHandler(TableScene.tableCellTouched,cc.TABLECELL_TOUCHED)        --cell尺寸、大小        tableView:registerScriptHandler(TableScene.cellSizeForTable,cc.TABLECELL_SIZE_FOR_INDEX)        --显示出可视部分的cell        tableView:registerScriptHandler(TableScene.tableCellAtIndex,cc.TABLECELL_SIZE_AT_INDEX)        --调用这个才会显示界面        tableView:reloadData()        -----------------------------------------------------------    else        -----------------------------------------------------------        --跟上面差不多，这里是创建一个“垂直滚动”的TableView        tableView = cc.TableView:create(cc.size(200, winSize.height - 20))        tableView:setDirection(cc.SCROLLVIEW_DIRECTION_VERTICAL)        tableView:setPosition(cc.p(winSize.width / 2, 10))        tableView:setDelegate()        tableView:setVerticalFillOrder(cc.TABLEVIEW_FILL_TOPDOWN)        self:addChild(tableView)        --registerScriptHandler functions must be before the reloadData funtion        --注册脚本编写器函数必须在reloadData函数之前（有道自动翻译）        --cell个数        tableView:registerScriptHandler(TableScene.numberOfCellsInTableView,cc.NUMBER_OF_CELLS_IN_TABLEVIEW)        --滚动事件        tableView:registerScriptHandler(TableScene.scrollViewDidScroll,cc.SCROLLVIEW_SCRIPT_SCROLL)        tableView:registerScriptHandler(TableScene.scrollViewDidZoom,cc.SCROLLVIEW_SCRIPT_ZOOM)        --cell点击事件        tableView:registerScriptHandler(TableScene.tableCellTouched,cc.TABLECELL_TOUCHED)        --cell尺寸、大小        tableView:registerScriptHandler(TableScene.cellSizeForTable,cc.TABLECELL_SIZE_FOR_INDEX)        --显示出可视部分的cell        tableView:registerScriptHandler(TableScene.tableCellAtIndex,cc.TABLECELL_SIZE_AT_INDEX)        --调用这个才会显示界面        tableView:reloadData()        -----------------------------------------------------------    end    return trueend--这里是为了让layer能调用TableViewTestLayer的方法function TableScene.create()    local layer = TableScene.extend(cc.Layer:create())    if nil ~= layer then        layer:init()    end    return layerendreturn TableScene</code></pre><h3 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h3><pre><code>--[LUA-print] 数据加载0--[LUA-print] 创建了新的cell--[LUA-print] 数据加载1--[LUA-print] 创建了新的cell--[LUA-print] 数据加载2--[LUA-print] 创建了新的cell--[LUA-print] 数据加载3--[LUA-print] 创建了新的cell--[LUA-print] 数据加载4--[LUA-print] 创建了新的cell--[LUA-print] 数据加载5--[LUA-print] 创建了新的cell--[LUA-print] 数据加载6--[LUA-print] 创建了新的cell--[LUA-print] 数据加载7--[LUA-print] 创建了新的cell--[LUA-print] 数据加载8--[LUA-print] 创建了新的cell--[LUA-print] 数据加载9--[LUA-print] 使用已经创建过的cell--[LUA-print] 数据加载10--[LUA-print] 使用已经创建过的cell--[LUA-print] 数据加载11--[LUA-print] 使用已经创建过的cell--[LUA-print] 数据加载12--[LUA-print] 使用已经创建过的cell--[LUA-print] 数据加载13--[LUA-print] 使用已经创建过的cell--[LUA-print] 数据加载14--[LUA-print] 使用已经创建过的cell--[LUA-print] 数据加载15--[LUA-print] 使用已经创建过的cell--[LUA-print] 数据加载16--[LUA-print] 使用已经创建过的cell--[LUA-print] 数据加载17--[LUA-print] 使用已经创建过的cell--[LUA-print] 数据加载18--[LUA-print] 使用已经创建过的cell--[LUA-print] 数据加载19--[LUA-print] 使用已经创建过的cell--[LUA-print] 数据加载20</code></pre><p>基本上重用了iOS中的UITableView机制，并且非常流畅的滑动显示一个完整的列表</p><blockquote><p>注意点：reloadData()的调用和上面图层之前的关系</p></blockquote><p>美中不足的是cocos创建的这个tableView也是有bug的，如果你的这个tableView有点击事件，不妨你上下滑动几下item，然后在隐藏的上下方点击，是不是仍然有点击事件呢。简单一招，添加Panel遮挡，勾上交互性轻松搞定。</p><p>cocos2dx lua中老版的listView也可以实现统一的功能，但是只能加载少量的item,多了就会很卡，所以推荐以后直接使用TableView。</p><h3 id="其他拓展"><a href="#其他拓展" class="headerlink" title="其他拓展"></a>其他拓展</h3><p>网上有其他相关的一些教程，可以省去UI的搭建</p><ol><li>先用CocosStudio或CocosCreator制作UI界面<ul><li>看这篇文章：<a href="http://blog.csdn.net/fjdmy001/article/details/52982515" target="_blank" rel="noopener">http://blog.csdn.net/fjdmy001/article/details/52982515</a></li></ul></li></ol><ol start="2"><li><p>然后修改config.json,</p><blockquote><p>窗口的配置文件，想设置模拟器的大小就在这里设置</p></blockquote><p> 竖屏：”isLandscape” = false<br> 尺寸：”width” = 540, “height” = 960</p></li><li><p>修改config.lua</p><blockquote><p>游戏的配置文件</p></blockquote><p> 开启全局变量：CC_DISABLE_GLOBAL = false<br> 设计尺寸：width = 1080，height = 1920，autoscale = “FIXED_HEIGHT”    </p></li></ol><p>使用cocos2dx的相关方法加载对应的文件，然后类似的方法去加载对应的内容(和iOS中定义tableview与cell类似)</p><p>具体可参考这里：</p><ul><li>排行榜之ScrollView：<a href="https://blog.csdn.net/fjdmy001/article/details/52997012" target="_blank" rel="noopener">https://blog.csdn.net/fjdmy001/article/details/52997012</a></li><li>排行榜之TableView：<a href="https://blog.csdn.net/fjdmy001/article/details/52998376" target="_blank" rel="noopener">https://blog.csdn.net/fjdmy001/article/details/52998376</a></li></ul>]]></content>
      
      <categories>
          
          <category> cocos2dx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocos2dx lua TableView(ScrollView, ListView)介绍与使用实战 </tag>
            
            <tag> cocos2dx </tag>
            
            <tag> 事件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cocos2dx lua 绑定详解与实战</title>
      <link href="/2018/10/18/cocos2dx-lua-%E7%BB%91%E5%AE%9A%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98/"/>
      <url>/2018/10/18/cocos2dx-lua-%E7%BB%91%E5%AE%9A%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98/</url>
      <content type="html"><![CDATA[<p>我们平时在开发cocos2dx lua游戏的时候的，会遇到这样的情况：</p><ul><li>在c++层定义了一些类，我们需要将这些类导出给Lua来使用，从而完成在c++层实现起来容易的需求，这个时候就需要将整个类作为模块导出。</li></ul><p>而Cocos2d-x正是采用的这种思想，将Cocos中的类导出供用户使用，而不是再写一套Lua代码，用户使用Cocos导出的这套接口，在Lua脚本层写游戏代码。</p><a id="more"></a><blockquote><p>为了更好的理解这部分的内容，可以先了解c++中调用Lua的机制。</p></blockquote><h6 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h6><ul><li><a href="https://www.cnblogs.com/chevin/p/5954948.html" target="_blank" rel="noopener">手动绑定自定义类中的函数</a></li><li><a href="https://www.cnblogs.com/chevin/p/5899516.html" target="_blank" rel="noopener">自动绑定自定义类中的函数</a></li></ul><p>前面文章中，我们说到了，Lua的本质是C，不是C++，Lua提供给C用的API也都是基于面向过程的C函数来用的，要把C++类注册进Lua形成一个一个的table环境是不太容易一下子办到的事。</p><p>为了实现我们的需求，同样也是官方的需求，在Cocos 2.x版本的时候，使用的是tolua++这个工具，但是这个工具用起来相当的麻烦，耗费体力，所以现在使用的是<a href="https://github.com/cocos2d/bindings-generator" target="_blank" rel="noopener">bindings-generator</a>工具（官方用Python写的一个工具），这个东西底层使用的也应该是tolua++。</p><blockquote><p>这里只针对iOS平台，Android和其他平台在tolua中README.mdown中有具体介绍，其他步骤基本上一样！</p></blockquote><p>在项目跟目录framework/cocos2d-x/cocos中创建mybinding文件夹，里面创建一个MyBinding.h文件(mybinding, MyBinding自定义)，输入如下测试代码</p><pre><code>#include &quot;cocos2d.h&quot;namespace cocos2d {class MyBinding: public Ref {public:virtual bool init() {return true;}void sayBinding() {log(&quot;Hello Binding Lua&quot;);}MyBinding();~MyBinding();}}</code></pre><p>在framework/cocos2d-x/tools/tolua，新建一个配置文件，这里命名cocos2dx_binding.ini</p><p>输入下面代码：（处理标记修改处其他所有都一样）</p><pre><code>[cocos2dx_binding] # 标记修改# the prefix to be added to the generated functions. You might or might not use this in your own# templatesprefix = cocos2dx_binding # 标记修改# create a target namespace (in javascript, this would create some code like the equiv. to `ns = ns || {}`)# all classes will be embedded in that namespacetarget_namespace = cc # 标记修改# --------- ?#android_headers = -I%(androidndkdir)s/platforms/android-19/arch-arm/usr/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.7/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.7/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.8/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.8/includeandroid_headers = -I%(androidndkdir)s/platforms/android-19/arch-arm/usr/lib -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/include# --------- ?android_flags = -D_SIZE_T_DEFINED_#clang_headers = -I%(clangllvmdir)s/lib/clang/%(clang_version)s/includeclang_headers = -I%(clangllvmdir)s/lib64/clang/5.0/includeclang_flags = -nostdinc -x c++ -std=c++11 -U __SSE__# --------- ?# -I%(cocosdir)s/jsext -I%(cocosdir)s/jsext/system -I%(cocosdir)s/jsext/alipay  -I%(cocosdir)s/jsext/video -I%(cocosdir)s/jsext/webview -I%(cocosdir)s/jsext/umengcocos_headers = -I%(cocosdir)s -I%(cocosdir)s/cocos -I%(cocosdir)s/cocos/base -I%(cocosdir)s/cocos/platform/android -I%(cocosdir)s/extensions -I%(cocosdir)s/external -I%(cocosdir)s/cocos/editor-support -I%(cocosdir)s/cocos/network -I%(cocosdir)s/cocos/ui/UIEditBox -I%(cocosdir)s/cocos/ui#cocos_headers = -I%(cocosdir)s -I%(cocosdir)s/cocos -I%(cocosdir)s/cocos/platform/androidcocos_flags = -DANDROIDcxxgenerator_headers =# extra arguments for clangextra_arguments = %(android_headers)s %(clang_headers)s %(cxxgenerator_headers)s %(cocos_headers)s %(android_flags)s %(clang_flags)s %(cocos_flags)s %(extra_flags)s# what headers to parse 头文件路径headers = %(cocosdir)s/cocos/mybinding/MyBinding.h # 标记修改# what classes to produce code for. You can use regular expressions here. When testing the regular# expression, it will be enclosed in &quot;^$&quot;, like this: &quot;^Menu*$&quot;.#包含的类，新添加文件需要修改classes = MyBinding.* # 标记修改#需要在js里面派生的类#classes_need_extend = MyBinding # 标记修改# what should we skip? in the format ClassName::[function function]# ClassName is a regular expression, but will be used like this: &quot;^ClassName$&quot; functions are also# regular expressions, they will not be surrounded by &quot;^$&quot;. If you want to skip a whole class, just# add a single &quot;*&quot; as functions. See bellow for several examples. A special class name is &quot;*&quot;, which# will apply to all class names. This is a convenience wildcard to be able to skip similar named# functions from all classes.skip =rename_functions =rename_classes =# for all class names, should we remove something when registering in the target VM?remove_prefix =# classes for which there will be no &quot;parent&quot; lookupclasses_have_no_parents =# base classes which will be skipped when their sub-classes found them.base_classes_to_skip = Ref# classes that create no constructor# Set is special and we will use a hand-written constructorabstract_classes =# Determining whether to use script object(js object) to control the lifecycle of native(cpp) object or the other way around. Supported values are &apos;yes&apos; or &apos;no&apos;.script_control_cpp = no</code></pre><p>注意检查一下三个头文件对应的路径及文件问题</p><ul><li>android_headers</li><li>clang_headers</li><li>cocos_headers</li></ul><h5 id="说明内容："><a href="#说明内容：" class="headerlink" title="说明内容："></a>说明内容：</h5><pre><code>+ •[title]：要配置将被使用的工具/ tolua的/ gengindings.py脚本的称号。一般来说，标题可以是文件名。+ •prefix：要配置一个函数名的前缀，通常，我们还可以使用文件名作为前缀。+ •target_namespace：要配置在脚本层模块的名字。在这里，我们使用cc作为模块名，当你想在脚本层REF的名称，您必须将一个名为前缀，CC在名称的前面。例如，CustomClass可以参考作为cc.CustomClass。+ •headers：要配置所有需要解析的头文件和％（cocosdir）s是的Cocos2d-x的引擎的根路径。+ •classes：要配置所有绑定所需的类。在这里，它支持正则表达式。因此，我们可以设置MyCustomClass。*在这里，用于查找多个特定的用法，你可以对照到tools/tolua/cocos2dx.ini。+ •skip：要配置需要被忽略的功能。现在绑定发电机无法解析的void *类型，并委托类型，所以这些类型的需要进行手动绑定。而在这种情况下，你应该忽略所有这些类型，然后再手动将它们绑定。你可以对照到配置文件路径下的cocos/scripting/lua-bindings/auto 。+ •rename_functions：要配置的功能需要在脚本层进行重命名。由于某些原因，开发者希望更多的脚本友好的API，所以配置选项就是为了这个目的。+ •rename_classes：不在使用。+ •remove_prefix：不在使用。+ •classes_have_no_parents：要配置是过滤器所需要的父类。这个选项是很少修改。+ •abstract_classes：要配置的公共构造并不需要导出的类。+ •script_control_cpp：是的。要配置脚本层是否管理对象的生命周期。如果没有，那么C++层关心他们的生命周期。现在，它是不完善的，以控制原生对象的续航时间在脚本层。所以，你可以简单地把它设置为no</code></pre><p>修改framework/cocos2d-x/tools/tolua里面的genbindings.py。有个cmd_args键值对的配置，增加下面代码，作为自定义绑定配置</p><pre><code>&apos;cocos2dx_binding.ini&apos; : (&apos;cocos2dx_binding&apos;, &apos;lua_cocos2dx_binding_auto&apos;), \</code></pre><blockquote><p>注：python注释为#，这里将cmd_args其他的元素注释掉是因为这些文件都是生成过得，没必要再生成浪费时间<br>这行代码表示在cocos2dx_custom中找到cocos2dx_custom的模块，然后生成lua_cocos2dx_custom_auto文件</p></blockquote><p>这里要确保NDK_ROOT，和PYTHON_BIN安装切配置好了,然后在framework/cocos2d-x/tools/tolua执行</p><pre><code>./genbindings.py</code></pre><p>之前./genbindings.py之前，请先查看官方tolua中README文件，按照对应的流程，安装好需要的依赖，和相应的库，下面是我这边3.17最新的README</p><pre><code>* The OSX 10.1&lt;!--0 has a built-in python2.7 and if your os don&apos;t have python2.7 then use [Homebrew](http://brew.sh/) to install the python and use pip install the python dependencies.&lt;pre&gt;brew install python&lt;/pre&gt;* Install python dependices by pip.&lt;pre&gt;sudo easy_install pipsudo pip install PyYAMLsudo pip install Cheetah&lt;/pre&gt;* Download NDK 64bit r10c or later from [Android Ndk](https://developer.android.com/ndk/downloads/index.html)* Run&lt;pre&gt;export NDK_ROOT=/path/to/android-ndk-10c./genbindings.py&lt;/pre&gt;--&gt;</code></pre><p>大概意思就是下载r10c之后版的NDK本，然后安装python(这一步一般Mac都有，但是最好安装到2.x)。</p><p>大概意思就是安装，pip， PyYAML， Cheetah</p><p>…….</p><p>执行./genbindings.py之后生成在</p><pre><code>工程目录\frameworks\cocos2d-x\cocos\scripting\lua-bindings\auto</code></pre><p>下便有了两个生成的文件</p><pre><code>lua_cocos2dx_custom_auto.cpplua_cocos2dx_custom_auto.hpp</code></pre><p>进入到文件夹</p><pre><code>C:\Users\user\Documents\Cocos\Link\frameworks\cocos2d-x\cocos\scripting\lua-bindings\manual打开CCLuaStack.cpp，添加#include &quot;lua_cocos2dx_custom_auto.hpp&quot;register_all_cocos2dx_custom(_state);</code></pre><h3 id="期间遇到的错误"><a href="#期间遇到的错误" class="headerlink" title="期间遇到的错误"></a>期间遇到的错误</h3><h5 id="错误一"><a href="#错误一" class="headerlink" title="错误一"></a>错误一</h5><pre><code>Traceback (most recent call last):File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1799, in &lt;module&gt;main()File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1772, in main&apos;clang_args&apos;: (config.get(s, &apos;extra_arguments&apos;, 0, dict(userconfig.items(&apos;DEFAULT&apos;))) or &quot;&quot;).split(&quot; &quot;),File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/ConfigParser.py&quot;, line 623, in getreturn self._interpolate(section, option, value, d)File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/ConfigParser.py&quot;, line 691, in _interpolateself._interpolate_some(option, L, rawval, section, vars, 1)File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/ConfigParser.py&quot;, line 726, in _interpolate_somesection, map, depth + 1)File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/ConfigParser.py&quot;, line 723, in _interpolate_someoption, section, rest, var)InterpolationMissingOptionError: Bad value substitution:section: [cocos2dx_custom]option : extra_argumentskey    : clang_versionrawval : /include</code></pre><p>路径错误</p><pre><code>#clang_headers = -I%(clangllvmdir)s/lib/clang/%(clang_version)s/includeclang_headers = -I%(clangllvmdir)s/lib64/clang/5.0/include  # --------- ?</code></pre><h5 id="错误二"><a href="#错误二" class="headerlink" title="错误二"></a>错误二</h5><pre><code>Traceback (most recent call last):File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1799, in &lt;module&gt;main()File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1795, in maingenerator.generate_code()File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1444, in generate_codeself._parse_headers()File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1487, in _parse_headersraise Exception(&quot;Fatal error in parsing headers&quot;)Exception: Fatal error in parsing headers---------------------------------Generating lua bindings fails.---------------------------------</code></pre><p>C++语法错误</p><h5 id="错误三"><a href="#错误三" class="headerlink" title="错误三"></a>错误三</h5><pre><code>Generating bindings for cocos2dx_custom...Using userconfig[(&apos;androidndkdir&apos;, &apos;/Users/iCocos/tools/android-ndk-r16b&apos;), (&apos;clangllvmdir&apos;, &apos;/Users/iCocos/tools/android-ndk-r16b/toolchains/llvm/prebuilt/darwin-x86_64&apos;), (&apos;gcc_toolchain_dir&apos;, &apos;/Users/iCocos/tools/android-ndk-r16b/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64&apos;), (&apos;cocosdir&apos;, &apos;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x&apos;), (&apos;cxxgeneratordir&apos;, &apos;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator&apos;), (&apos;extra_flags&apos;, &apos;&apos;)].... Generating bindings for target lua.... .... Processing section cocos2dx_customTraceback (most recent call last):File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1799, in &lt;module&gt;main()File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1795, in maingenerator.generate_code()File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1444, in generate_codeself._parse_headers()File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1478, in _parse_headerstu = self.index.parse(header, self.clang_args)File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/clang/cindex.py&quot;, line 2602, in parseself)File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/clang/cindex.py&quot;, line 2714, in from_sourceraise TranslationUnitLoadError(&quot;Error parsing translation unit.&quot;)TranslationUnitLoadError: Error parsing translation unit.---------------------------------Generating lua bindings fails.---------------------------------</code></pre><p>路径错误</p><pre><code>#android_headers = -I%(androidndkdir)s/platforms/android-19/arch-arm/usr/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.7/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.7/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.8/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.8/includeandroid_headers = -I%(androidndkdir)s/platforms/android-19/arch-arm/usr/lib -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/include</code></pre><h5 id="错误四"><a href="#错误四" class="headerlink" title="错误四"></a>错误四</h5><pre><code>====Errors in parsing headers:1. &lt;severity = Fatal,location = &lt;SourceLocation file &apos;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/cocos/platform/android/CCPlatformDefine-android.h&apos;, line 33, column 10&gt;,details = &quot;&apos;android/log.h&apos; file not found&quot;&gt;====</code></pre><p>…..</p><h3 id="提示成功"><a href="#提示成功" class="headerlink" title="提示成功"></a>提示成功</h3><pre><code>---------------------------------Generating lua bindings succeeds.---------------------------------</code></pre><h4 id="拓展推荐"><a href="#拓展推荐" class="headerlink" title="拓展推荐"></a>拓展推荐</h4><ul><li><p>lua： <a href="http://www.lua.org/" target="_blank" rel="noopener">http://www.lua.org/</a></p><ul><li>lua是个脚本语言，脚本语言！！就是脚本文件加解释器。之后你就可以看效果了。可是呢，lua如果正是靠自己独立完成点事情，那就是大材小用，需要和其他东西结合起来，比如C/C++.貌似主要也就是C/C++。</li></ul></li><li><p>tolua++： <a href="http://www.codenix.com/~tolua/#news" target="_blank" rel="noopener">http://www.codenix.com/~tolua/#news</a></p><ul><li>tolua++：首先看名字“到、lua、++”，就是把其他语言（C/C++函数对象转化为lua能调用形式，++这里理解为增强版），有了这个工具，我们就可以快速的将我们现成的C/C++代码封装成Lua接口形式。</li></ul></li><li><p>luajit： <a href="http://luajit.org/luajit.html" target="_blank" rel="noopener">http://luajit.org/luajit.html</a></p><ul><li>LuaJIT：LuaJIT is a Just-In-Time Compiler (JIT) for the  Lua programming language. 。。。。。。说了半天就一个lua的高效率版本。</li></ul></li><li><p>lua for windows： <a href="http://luaforge.net/projects/luaforwindows/" target="_blank" rel="noopener">http://luaforge.net/projects/luaforwindows/</a></p><ul><li>lua for windows：lua在windows下的打包版本，除了最基本的lua解释器，还包括了可用于和C/C++集成开发的【动态链接库、静态链接库、头文件】、文本编辑器、常用的lua module，帮助说明文档。</li></ul></li></ul><h6 id="致谢："><a href="#致谢：" class="headerlink" title="致谢："></a>致谢：</h6><ul><li><a href="https://blog.csdn.net/never_QH/article/details/45148835" target="_blank" rel="noopener">https://blog.csdn.net/never_QH/article/details/45148835</a></li><li><a href="http://geekgaoyang.herokuapp.com/blog/2015/02/11/cocos2d-x-tutorial-of-binding-c-plus-plus-class-to-lua-usage/" target="_blank" rel="noopener">http://geekgaoyang.herokuapp.com/blog/2015/02/11/cocos2d-x-tutorial-of-binding-c-plus-plus-class-to-lua-usage/</a></li><li><a href="https://www.cnblogs.com/ZhYQ-Note/p/5939783.html" target="_blank" rel="noopener">https://www.cnblogs.com/ZhYQ-Note/p/5939783.html</a></li><li><a href="http://www.bubuko.com/infodetail-1210197.html" target="_blank" rel="noopener">http://www.bubuko.com/infodetail-1210197.html</a></li><li><a href="https://www.jianshu.com/p/9bd4d5518d53" target="_blank" rel="noopener">https://www.jianshu.com/p/9bd4d5518d53</a></li></ul>]]></content>
      
      <categories>
          
          <category> cocos2dx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocos2dx </tag>
            
            <tag> 事件 </tag>
            
            <tag> cocos2dx lua 绑定详解与实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux命令--查找与统计（grep、awk、sort、uniq、wc）</title>
      <link href="/2018/10/16/linux%E5%91%BD%E4%BB%A4--%E6%9F%A5%E6%89%BE%E4%B8%8E%E7%BB%9F%E8%AE%A1%EF%BC%88grep%E3%80%81awk%E3%80%81sort%E3%80%81uniq%E3%80%81wc%EF%BC%89/"/>
      <url>/2018/10/16/linux%E5%91%BD%E4%BB%A4--%E6%9F%A5%E6%89%BE%E4%B8%8E%E7%BB%9F%E8%AE%A1%EF%BC%88grep%E3%80%81awk%E3%80%81sort%E3%80%81uniq%E3%80%81wc%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>在做日志分析时或者配置分析时，通常会遇到查找出符合某一条件的行，并统计，主要应用的就是grep、awk、sort、uniq、wc五个命令</p><h5 id="1-grep命令"><a href="#1-grep命令" class="headerlink" title="1. grep命令"></a>1. grep命令</h5><p>grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p><a id="more"></a><p>语法格式为：</p><pre><code>grep [option] pattern file //pattern 通常可以为正则表达式</code></pre><p>常见的参数为：</p><p>选项</p><pre><code>-a ：将 binary 文件以 text 文件的方式搜寻数据-c ：计算找到 &apos;搜寻字符串&apos; 的次数-i ：忽略大小写的不同，所以大小写视为相同-n ：顺便输出行号-v ：反向选择，亦即显示出没有 &apos;搜寻字符串&apos; 内容的那一行！--color=auto ：可以将找到的关键词部分加上颜色的显示喔！</code></pre><h5 id="2-awk命令"><a href="#2-awk命令" class="headerlink" title="2.awk命令"></a>2.awk命令</h5><p>  awk命令通常是将所列出的行，根据条件打印出某一列或几列</p><blockquote><p>常用形式为：awk  -F ‘:’  ‘BEGIN {print “name,shell”}  {if($1=”root”) print $1”,”$7} END {print “blue,/bin/nosh”}’  </p></blockquote><h5 id="3-sort命令"><a href="#3-sort命令" class="headerlink" title="3.sort命令"></a>3.sort命令</h5><p>sort排序原则：sort将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。</p><pre><code>sort [optional] filename</code></pre><p>常用参数：</p><pre><code>-u：去除重复行-r：默认是升序排序，-r是改为降序-o：将排序结果写入到源文件-n：默认是通过ASCII码值排序，但是这时会出现10比2小的情况，-n就是说要以数值进行排序-k和-t：-k是指定以哪一列进行排序，-t是指定分隔符</code></pre><p>举例：</p><ul><li><p>（1）sort -n -t “ “ -k 2 -k 3 facebook.txt  //人数相同的按照员工平均工资升序排序</p></li><li><p>（2） sort -n -t ‘ ‘ -k 3r -k 2 facebook.txt //按照员工工资降序排序，如果员工人数相同的，则按照公司人数升序排序</p></li><li><p>（3）sort -t ‘ ‘ -k 1.2 facebook.txt //从公司英文名称的第二个字母开始进行排序</p></li><li><p>（4）sort -t ‘ ‘ -k 1.2,1.2 -k 3,3nr facebook.txt //只针对公司英文名称的第二个字母进行排序，如果相同的按照员工工资进行降序排序</p></li></ul><h5 id="4-uniq命令"><a href="#4-uniq命令" class="headerlink" title="4.uniq命令"></a>4.uniq命令</h5><p>uniq命令可以去除排序过的文件中的重复行，因此uniq经常和sort合用。也就是说，为了使uniq起作用，所有的重复行必须是相邻的。</p><pre><code>-i   ：忽略大小写字符的不同；-c  ：进行计数,即统计该行的重复次数-u  ：显示不存在的行-d：显示存在重复的行</code></pre><h5 id="5-wc-命令"><a href="#5-wc-命令" class="headerlink" title="5.wc  命令"></a>5.wc  命令</h5><p>统计指定文件中的字节数、字数、行数，并将统计结果显示输出。该命令统计指定文件中的字节数、字数、行数。如果没有给出文件名，则从标准输入读取。wc同时也给出所指定文件的总统计数。</p><ul><li>-c 统计字节数。</li><li>-l 统计行数。</li><li>-m 统计字符数。这个标志不能与 -c 标志一起使用。</li><li>-w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。</li><li>-L 打印最长行的长度。</li><li>-help 显示帮助信息</li><li>–version 显示版本信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# wc test.txt</span><br><span class="line">7  8 70 test.txt</span><br></pre></td></tr></table></figure><ul><li>7 表示行数</li><li>8 表示单词数</li><li>70  字节数</li></ul>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cocos2dx lua 与 C/C++ 交互入门</title>
      <link href="/2018/10/16/cocos2dx-lua-%E4%B8%8E-C-C-%E4%BA%A4%E4%BA%92%E5%85%A5%E9%97%A8/"/>
      <url>/2018/10/16/cocos2dx-lua-%E4%B8%8E-C-C-%E4%BA%A4%E4%BA%92%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h5 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h5><ul><li>中间栈<ul><li>1.中间件栈<ul><li>C/C++访问Lua数据和函数</li><li>Lua访问C/C++数据和函数</li></ul></li></ul></li><li>集成Lua<ul><li>集成Lua环境到C_Cpp项目中</li></ul></li><li>C/C++ 调用Lua<ul><li>C/C++调用Lua之标准Lua读取类</li><li>C/C++调用Lua中的变量</li><li>C/C++调用Lua中的函数</li><li>C/C++调用Lua之遍历和获取Table的值</li></ul></li><li>Lua 调用 C/C++<ul><li>1.Lua调用C/C++函数<ul><li>深入理解编写C函数上</li><li>深入理解编写C函数下</li></ul></li><li>2.Lua调用C/C++之标准C模块</li></ul></li><li>待续</li></ul><a id="more"></a><h2 id="中间栈"><a href="#中间栈" class="headerlink" title="中间栈"></a>中间栈</h2><blockquote><p>lua(<a href="https://www.lua.org/)作为一种轻量级的脚本语言" target="_blank" rel="noopener">https://www.lua.org/)作为一种轻量级的脚本语言</a>, 以其简单的语法结构, 方便的c++集成能力, 高效的执行效率收到广大游戏开发者的热爱, 也是cocos2d-x官方首次引入的脚本语言.</p></blockquote><p>作为一种脚本语言, lua是在一个运行时环境(State)里执行的, 这个运行时环境保存了脚本运行所需的内存空间, 创建的全局变量, 加载的库文件等. 在这个运行时环境里还有一个栈空间(Stack), 其作用就是在lua和c语言进行数据传递和函数调用. lua原生实现了很多c api对栈空间进行操作, 让开发者能够方便地实现lua脚本代码与c编译代码的双向通信.</p><ul><li>推荐：<a href="https://blog.csdn.net/banruoju/article/details/75115061" target="_blank" rel="noopener">Lua中的栈概念</a></li></ul><p>Lua的栈是一个线性数组，栈中的每一项元素的类型都是TValue，它是Lua表示内部数据的数据结构。栈的最大空间在luaconf.h中给出：#define LUAI_MAXSTACK 1000000。</p><blockquote><p>栈包括：基指针、栈顶指针、栈大小。图中的stack-&gt;top表示栈顶指针。其实在Lua中栈的很多空间都留作它用，如call info也使用一部分的栈。</p></blockquote><h4 id="1-中间件栈"><a href="#1-中间件栈" class="headerlink" title="1.中间件栈"></a>1.中间件栈</h4><blockquote><p>背后其实是lua和c api的互相调用, 所有c++的功能都要通过一层c函数的包装, 这点是要牢记在心的, 这也正是lua-binding的核心.</p></blockquote><p>cocos2d-x提供的lua-bingding工具使用libclang分析c++源码, 提取语法树, 将c++的类成员函数封装为c函数, 然后根据参数类型自动调用lua c api, 实现对栈空间的操作, 将c++的数据传递给lua. lua脚本加载编译好的c++库, 就可以自由调用c++里面的类对象和成员函数了; c++的代码则可以直接使用lua c api, 执行一段lua脚本, 并通过栈空间获取返回结果.</p><ul><li>执行过程如下：<ul><li>1）C程序读取Lua脚本</li><li>2）lualib库解析脚本，并保存解析结果。</li><li>3）通过Lua API，将解析结果中的某一个值放入栈中。</li><li>4）C程序通过Lua提供的API到栈中取得数据。</li></ul></li></ul><h6 id="经过上面的过程C语言程序和Lua脚本就能相互传值了。"><a href="#经过上面的过程C语言程序和Lua脚本就能相互传值了。" class="headerlink" title="经过上面的过程C语言程序和Lua脚本就能相互传值了。"></a>经过上面的过程C语言程序和Lua脚本就能相互传值了。</h6><p>开始撸代码 ——————————- 华丽的分割线 ——————————-</p><h5 id="创建一个Lua管理类，"><a href="#创建一个Lua管理类，" class="headerlink" title="创建一个Lua管理类，"></a>创建一个Lua管理类，</h5><p>用利用栈的原理，使用C++简单访问Lua</p><h6 id="h文件"><a href="#h文件" class="headerlink" title=".h文件"></a>.h文件</h6><pre><code>#ifndef LuaInterface01_h#define LuaInterface01_h#include &lt;stdio.h&gt;#include &quot;lua.hpp&quot;class LuaInterface01 {public:static LuaInterface01 *shareInterface();private:static LuaInterface01 *i;void init();};#endif /* LuaInterface01_hpp */</code></pre><h6 id="cpp文件"><a href="#cpp文件" class="headerlink" title=".cpp文件"></a>.cpp文件</h6><pre><code>#include &quot;LuaInterface01.h&quot;#include &quot;cocos2d.h&quot;#include &lt;string&gt;USING_NS_CC;using namespace std;LuaInterface01 *LuaInterface01::i = NULL;LuaInterface01 *LuaInterface01::shareInterface() {if (!i) {i = new LuaInterface01;i -&gt; init();}return i;}void LuaInterface01::init() {// 创建一个Lua状态指针lua_State *luaState = luaL_newstate();luaL_openlibs(luaState);string path = CCFileUtils::sharedFileUtils()-&gt;fullPathForFilename(&quot;Interface01.lua&quot;);luaL_dofile(luaState, path.c_str());lua_pcall(luaState, 0, 0, 0); // Hello iCocos LuaInterface01!}</code></pre><h5 id="新建一个-lua的访问类文件，并且输入"><a href="#新建一个-lua的访问类文件，并且输入" class="headerlink" title="新建一个.lua的访问类文件，并且输入"></a>新建一个.lua的访问类文件，并且输入</h5><pre><code>print(&quot;Hello iCocos LuaInterface01!&quot;)</code></pre><h5 id="控制答应结果："><a href="#控制答应结果：" class="headerlink" title="控制答应结果："></a>控制答应结果：</h5><pre><code>Hello iCocos LuaInterface01!</code></pre><blockquote><p>下面用简单的Lua与C/C++互调，验证中间件栈， 如果想了解更多或者更详细的实现Lua与C/C++，请略过本小结，滑到第三部分，或者通过目录寻找需要的内容！</p></blockquote><h6 id="C-C-访问Lua数据和函数"><a href="#C-C-访问Lua数据和函数" class="headerlink" title="C/C++访问Lua数据和函数"></a>C/C++访问Lua数据和函数</h6><h5 id="创建一个Lua管理类，-1"><a href="#创建一个Lua管理类，-1" class="headerlink" title="创建一个Lua管理类，"></a>创建一个Lua管理类，</h5><h6 id="h文件-1"><a href="#h文件-1" class="headerlink" title=".h文件"></a>.h文件</h6><pre><code>#ifndef LuaInterface02_h#define LuaInterface02_h#include &lt;stdio.h&gt;#include &quot;lua.hpp&quot;#include &quot;cocos2d.h&quot;USING_NS_CC;class LuaInterface02 {public:LuaInterface02();~LuaInterface02();static LuaInterface02 *shareInterface();void init();void readVariable();void loadFunstion();private:static LuaInterface02 *i;lua_State *m_pLuaState;};#endif /* LuaInterface02_h */</code></pre><h6 id="cpp文件-1"><a href="#cpp文件-1" class="headerlink" title=".cpp文件"></a>.cpp文件</h6><pre><code>#include &quot;LuaInterface02.h&quot;#include &lt;string&gt;using namespace std;LuaInterface02 *LuaInterface02::i = NULL;LuaInterface02::LuaInterface02() {}LuaInterface02::~LuaInterface02() {if (m_pLuaState) {lua_close(m_pLuaState);m_pLuaState = NULL;}}LuaInterface02 *LuaInterface02::shareInterface() {if (!i) {i = new LuaInterface02;i -&gt; init();}return i;}void LuaInterface02::init() {m_pLuaState = luaL_newstate();luaL_openlibs(m_pLuaState);}void LuaInterface02::readVariable() {string path = CCFileUtils::sharedFileUtils()-&gt;fullPathForFilename(&quot;Interface02.lua&quot;);luaL_dofile(m_pLuaState, path.c_str());int err_relt = lua_pcall(m_pLuaState, 0, 0, 0);CCAssert(err_relt, &quot;读取Lua文件错误&quot;);lua_getglobal(m_pLuaState, &quot;username&quot;);char *rlt = (char*)lua_tostring(m_pLuaState, -1);  //lua_tonumber,lua_tobooleanCCLOG(&quot;rlt is : %s&quot;, rlt);lua_pop(m_pLuaState, 1);}void LuaInterface02::loadFunstion() {string path = CCFileUtils::sharedFileUtils()-&gt;fullPathForFilename(&quot;Interface02.lua&quot;);luaL_dofile(m_pLuaState, path.c_str());int err_relt = lua_pcall(m_pLuaState, 0, 0, -1);CCAssert(err_relt != -1, &quot;读取Lua文件错误&quot;);lua_getglobal(m_pLuaState, &quot;getResult&quot;);lua_pushnumber(m_pLuaState, 12);err_relt = lua_pcall(m_pLuaState, 1, 2, -1); // 1： 一个参数， 2：两个参数 ， -1：当出错的时候的返回值CCAssert(err_relt != -1, &quot;访问函数报错&quot;);char *rlt = (char*)lua_tostring(m_pLuaState, -1);  //lua_tonumber,lua_tobooleanCCLOG(&quot;rlt is : %s&quot;, rlt);char *rlt2 = (char*)lua_tostring(m_pLuaState, -2);  //lua_tonumber,lua_tobooleanCCLOG(&quot;rlt2 is : %s&quot;, rlt2);}</code></pre><h5 id="新建一个-lua的访问类文件，并且输入-1"><a href="#新建一个-lua的访问类文件，并且输入-1" class="headerlink" title="新建一个.lua的访问类文件，并且输入"></a>新建一个.lua的访问类文件，并且输入</h5><pre><code>username = &quot;iCocos&quot;function getResult(x)print(&quot;Enter Result&quot;)print(&quot;x:&quot;..x)return &quot;OK&quot;,&quot;Function&quot;end</code></pre><h5 id="控制答应结果：-1"><a href="#控制答应结果：-1" class="headerlink" title="控制答应结果："></a>控制答应结果：</h5><pre><code>rlt is : iCocosEnter Resultx:12rlt is : Functionrlt2 is : OK</code></pre><h6 id="Lua访问C-C-数据和函数"><a href="#Lua访问C-C-数据和函数" class="headerlink" title="Lua访问C/C++数据和函数"></a>Lua访问C/C++数据和函数</h6><h5 id="LuaInterface02-h中增加函数"><a href="#LuaInterface02-h中增加函数" class="headerlink" title="LuaInterface02.h中增加函数"></a>LuaInterface02.h中增加函数</h5><pre><code>// 调用C++static int l_show(lua_State * L) {lua_pushstring(L, &quot;String from C/C++&quot;);return 1;}</code></pre><h5 id="然后在init-中输入执行方法"><a href="#然后在init-中输入执行方法" class="headerlink" title="然后在init()中输入执行方法"></a>然后在init()中输入执行方法</h5><pre><code>// 调用C++lua_pushcfunction(m_pLuaState, l_show);lua_setglobal(m_pLuaState, &quot;show&quot;);</code></pre><h5 id="然后在-lua的访问类文件，并且输入"><a href="#然后在-lua的访问类文件，并且输入" class="headerlink" title="然后在.lua的访问类文件，并且输入"></a>然后在.lua的访问类文件，并且输入</h5><pre><code>print(show())</code></pre><h5 id="控制答应结果：-2"><a href="#控制答应结果：-2" class="headerlink" title="控制答应结果："></a>控制答应结果：</h5><pre><code>String from C/C++</code></pre><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote><p>简单点讲就是维护了一个堆栈，需要交互的数据通过入栈，出栈操作来传递数据。而具体脚本语言的实现机制，一般来说都会有一个编译模块、一个虚拟机（执行）模块、一套类型实现及数据管理模块，通常还会有一个供外部操作的接口，如lua c api，这个接口让嵌入方得以操作脚本状态（如访问变量、调用函数、管理内存），实现交互。</p></blockquote><p>最后，总结一下，所有程序最终都是以机器码的形式被硬件CPU执行，从这个角度去看，不同语言的代码并没有本质区别，最终都是被编译器编译从二进制机器码，而所谓交互，就是在处理共享数据而已。</p><ul><li>注意</li><li>Lua与C/C++或C/C++语言之前那通信过程中，实际上更多的时候是对栈顶的元素进行操作</li><li>从栈顶往下看索引是-1-2-3…</li><li>从栈底往上看索引是1，2，3…</li><li>无论从Lua调C/C++，还是C/C++调Lua，参数值都是最先被压入到栈顶的，最后结果值才会被压入到栈顶</li></ul><h2 id="集成Lua"><a href="#集成Lua" class="headerlink" title="集成Lua"></a>集成Lua</h2><h4 id="集成Lua环境到C-C-项目中"><a href="#集成Lua环境到C-C-项目中" class="headerlink" title="集成Lua环境到C/C++项目中"></a>集成Lua环境到C/C++项目中</h4><blockquote><p>下载并获取到Lua源代码(src文件夹就是lua源码)<a href="https://www.lua.org/" target="_blank" rel="noopener">https://www.lua.org/</a></p></blockquote><h5 id="在lua中文件类型有三种"><a href="#在lua中文件类型有三种" class="headerlink" title="在lua中文件类型有三种"></a>在lua中文件类型有三种</h5><ul><li>.c c文件</li><li>.h 头文件</li><li>.o 可执行文件</li></ul><h5 id="开始接入"><a href="#开始接入" class="headerlink" title="开始接入"></a>开始接入</h5><ul><li>接入Lua到C/C++的时候需要删除</li><li>lua.c</li><li>luac.c</li><li>MakeFile</li></ul><blockquote><p>新建一个Xcode项目，拷贝src文件夹到项目中就可以了</p></blockquote><h5 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h5><blockquote><p>在llex.c中trydecpoint, 修改里面decpoint=“getlocaldecpoint”</p><p>decpoint=’.’</p><p>如果不改会导致编译报错</p></blockquote><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><blockquote><p>新建一个C++文件，在头文件中输入</p></blockquote><pre><code>#include &lt;stdio.h&gt;#include &quot;lua.hpp&quot;#include &quot;cocos2d.h&quot;USING_NS_CC;class TestInportLua {public:void test() {lua_State *state = luaL_newstate();luaL_openlibs(state);luaL_dofile(state, &quot;res/test.lua&quot;);}}#endif /* TestInportLua_h */</code></pre><h2 id="C-C-调用Lua"><a href="#C-C-调用Lua" class="headerlink" title="C/C++ 调用Lua"></a>C/C++ 调用Lua</h2><h4 id="C-C-调用Lua之标准Lua读取类"><a href="#C-C-调用Lua之标准Lua读取类" class="headerlink" title="C/C++调用Lua之标准Lua读取类"></a>C/C++调用Lua之标准Lua读取类</h4><h5 id="创建一个Lua管理类，-2"><a href="#创建一个Lua管理类，-2" class="headerlink" title="创建一个Lua管理类，"></a>创建一个Lua管理类，</h5><h6 id="h文件-2"><a href="#h文件-2" class="headerlink" title=".h文件"></a>.h文件</h6><pre><code>#ifndef LuaInterface03_hpp#define LuaInterface03_hpp#include &quot;cocos2d.h&quot;#include &quot;lua.hpp&quot;#include &lt;string&gt;USING_NS_CC;using namespace std;class LuaInterface03 {public:LuaInterface03();~LuaInterface03();static LuaInterface03 *shareInterface();void readVailable();void loadFunciton();private:static LuaInterface03 *i;lua_State *m_pLuaState;void init();};#endif /* LuaInterface03_hpp */</code></pre><h6 id="cpp文件-2"><a href="#cpp文件-2" class="headerlink" title=".cpp文件"></a>.cpp文件</h6><pre><code>#include &quot;LuaInterface03.h&quot;LuaInterface03 *LuaInterface03::i = NULL;LuaInterface03::LuaInterface03(){}LuaInterface03::~LuaInterface03(){lua_close(m_pLuaState);m_pLuaState = NULL;}void LuaInterface03::init() {// 创建一个新的状态m_pLuaState = luaL_newstate();// 打开所有系统提供的库luaL_openlibs(m_pLuaState);// 完整路径string path = CCFileUtils::sharedFileUtils()-&gt;fullPathForFilename(&quot;LuaInterface03.lua&quot;);// 读取文件luaL_dofile(m_pLuaState, path.c_str());// 启动调用文件lua_pcall(m_pLuaState, 0, 0, -1);}LuaInterface03 *LuaInterface03::shareInterface() {if (!i) {i = new LuaInterface03;i -&gt; init();}return i;}</code></pre><h5 id="新建一个-lua的访问类文件，并且输入-2"><a href="#新建一个-lua的访问类文件，并且输入-2" class="headerlink" title="新建一个.lua的访问类文件，并且输入"></a>新建一个.lua的访问类文件，并且输入</h5><pre><code>print(&quot;=======&gt; I am Lua Config&quot;)</code></pre><h5 id="控制答应结果：-3"><a href="#控制答应结果：-3" class="headerlink" title="控制答应结果："></a>控制答应结果：</h5><pre><code>=======&gt; I am Lua Config</code></pre><h4 id="C-C-调用Lua中的变量"><a href="#C-C-调用Lua中的变量" class="headerlink" title="C/C++调用Lua中的变量"></a>C/C++调用Lua中的变量</h4><h5 id="增加方法和对应的实现，用来获取变量"><a href="#增加方法和对应的实现，用来获取变量" class="headerlink" title="增加方法和对应的实现，用来获取变量"></a>增加方法和对应的实现，用来获取变量</h5><pre><code>void configWindowContentSize();void LuaInterface03::configWindowContentSize() {lua_getglobal(m_pLuaState, &quot;width&quot;);// 是否能转换成numberif (lua_isnumber(m_pLuaState, -1)) {int width = (int)lua_tonumber(m_pLuaState, -1);CCLOG(&quot;width: %i&quot;, width);}lua_getglobal(m_pLuaState, &quot;height&quot;);if (lua_isnumber(m_pLuaState, -1)) {int height = (int)lua_tonumber(m_pLuaState, -1);CCLOG(&quot;height: %i&quot;, height);}}</code></pre><h5 id="Lua中增加变量"><a href="#Lua中增加变量" class="headerlink" title="Lua中增加变量"></a>Lua中增加变量</h5><pre><code>width = 320height = 640</code></pre><h5 id="控制答应结果：-4"><a href="#控制答应结果：-4" class="headerlink" title="控制答应结果："></a>控制答应结果：</h5><pre><code>width: 320height: 640</code></pre><h4 id="C-C-调用Lua中的函数"><a href="#C-C-调用Lua中的函数" class="headerlink" title="C/C++调用Lua中的函数"></a>C/C++调用Lua中的函数</h4><h5 id="增加方法和对应的实现，用来获取变量-1"><a href="#增加方法和对应的实现，用来获取变量-1" class="headerlink" title="增加方法和对应的实现，用来获取变量"></a>增加方法和对应的实现，用来获取变量</h5><pre><code>void callLuaFunctionContent();void LuaInterface03::callLuaFunctionContent() {lua_getglobal(m_pLuaState, &quot;test1&quot;);int err_relt = lua_pcall(m_pLuaState, 0, 0, -1);CCAssert(err_relt != -1, &quot;访问函数报错&quot;);lua_getglobal(m_pLuaState, &quot;test2&quot;);lua_pushstring(m_pLuaState, &quot;test2 调用&quot;);err_relt = lua_pcall(m_pLuaState, 1, 0, -1); // 1： 一个参数， 2：两个参数 ， -1：当出错的时候的返回值CCAssert(err_relt != -1, &quot;访问函数报错&quot;);lua_getglobal(m_pLuaState, &quot;test3&quot;);err_relt = lua_pcall(m_pLuaState, 0, 0, -1);CCAssert(err_relt != -1, &quot;访问函数报错&quot;);char* rlt = (char*)lua_tostring(m_pLuaState, -1);CCLOG(&quot;rlt is %s&quot;,rlt);lua_getglobal(m_pLuaState, &quot;test4&quot;);lua_pushnumber(m_pLuaState, 10);err_relt = lua_pcall(m_pLuaState, 1, 2, -1); // 1： 一个参数， 2：两个参数 ， -1：当出错的时候的返回值CCAssert(err_relt != -1, &quot;访问函数报错&quot;);int rlt2 = (int)lua_tonumber(m_pLuaState, -1);CCLOG(&quot;rlt is %i&quot;,rlt2);lua_getglobal(m_pLuaState, &quot;test5&quot;);lua_pushnumber(m_pLuaState, 100);err_relt = lua_pcall(m_pLuaState, 1, 2, -1); // 1： 一个参数， 2：两个参数 ， -1：当出错的时候的返回值CCAssert(err_relt != -1, &quot;访问函数报错&quot;);int rlt3 = (int)lua_tonumber(m_pLuaState, -1);int rlt4 = (int)lua_tonumber(m_pLuaState, -1);CCLOG(&quot;rlt is %i&quot;,rlt3);CCLOG(&quot;rlt is %i&quot;,rlt4);}</code></pre><h5 id="Lua中增加变量-1"><a href="#Lua中增加变量-1" class="headerlink" title="Lua中增加变量"></a>Lua中增加变量</h5><pre><code>function test1()print(&quot;call lua function&quot;)endfunction test2(var)print(&quot;call lua function&quot;, var)endfunction test3()return &quot;I am Lua test3&quot;endfunction test4(var)var = var + 10return varendfunction test5(var)t = 10var = var + 10return t, varend</code></pre><h5 id="控制答应结果：-5"><a href="#控制答应结果：-5" class="headerlink" title="控制答应结果："></a>控制答应结果：</h5><pre><code>call lua functioncall lua function test1 调用</code></pre><h4 id="C-C-调用Lua之遍历和获取Table的值"><a href="#C-C-调用Lua之遍历和获取Table的值" class="headerlink" title="C/C++调用Lua之遍历和获取Table的值"></a>C/C++调用Lua之遍历和获取Table的值</h4><h5 id="增加方法"><a href="#增加方法" class="headerlink" title="增加方法"></a>增加方法</h5><pre><code>char* getField(lua_State *L, const char* key);char* getField(lua_State *L, const char* key) {char *rlt = NULL;lua_pushstring(L, key);lua_gettable(L, -2);if (lua_isstring(L, -1)) {rlt = (char*)lua_tostring(L, -1);lua_pop(L, 1);return rlt;}return &quot;error&quot;;}</code></pre><h5 id="初始化方法-void-LuaInterface03-init-中增加如下代码"><a href="#初始化方法-void-LuaInterface03-init-中增加如下代码" class="headerlink" title="初始化方法(void LuaInterface03::init())中增加如下代码"></a>初始化方法(void LuaInterface03::init())中增加如下代码</h5><pre><code>lua_getglobal(m_pLuaState, &quot;application&quot;);if (lua_isnumber(m_pLuaState, -1)) {char *width = getField(m_pLuaState, &quot;width&quot;);char *height = getField(m_pLuaState, &quot;height&quot;);CCLOG(&quot;width:%s&quot;, width);CCLOG(&quot;height:%s&quot;, height);int nWidth = atoi(width);int nHeight = atoi(height);}</code></pre><h5 id="Lua中增加Table"><a href="#Lua中增加Table" class="headerlink" title="Lua中增加Table"></a>Lua中增加Table</h5><pre><code>application = {width = 320,height = 640,}</code></pre><h2 id="Lua-调用-C-C"><a href="#Lua-调用-C-C" class="headerlink" title="Lua 调用 C/C++"></a>Lua 调用 C/C++</h2><h4 id="1-Lua调用C-C-函数"><a href="#1-Lua调用C-C-函数" class="headerlink" title="1.Lua调用C/C++函数"></a>1.Lua调用C/C++函数</h4><h5 id="创建一个Lua管理类，-3"><a href="#创建一个Lua管理类，-3" class="headerlink" title="创建一个Lua管理类，"></a>创建一个Lua管理类，</h5><h6 id="h文件-3"><a href="#h文件-3" class="headerlink" title=".h文件"></a>.h文件</h6><pre><code>#ifndef LuaInterface04_hpp#define LuaInterface04_hpp#include &lt;stdio.h&gt;#include &quot;cocos2d.h&quot;#include &quot;lua.hpp&quot;#include &lt;string&gt;USING_NS_CC;using namespace std;class LuaInterface04 {public:LuaInterface04();~LuaInterface04();static LuaInterface04 *shareInterface();static int l_getMyName(lua_State * L)private:static LuaInterface04 *i;lua_State *m_pLuaState;void init();};#endif /* LuaInterface04_hpp */</code></pre><h6 id="cpp文件-3"><a href="#cpp文件-3" class="headerlink" title=".cpp文件"></a>.cpp文件</h6><pre><code>#include &quot;LuaInterface04.h&quot;LuaInterface04 *LuaInterface04::i = NULL;LuaInterface04::LuaInterface04(){}LuaInterface04::LuaInterface04(){if (m_pLuaState) {lua_close(m_pLuaState);m_pLuaState = NULL;}}// 调用C++static int l_getMyName(lua_State * L) {lua_pushstring(L, &quot;String from C/C++&quot;);return 1;}void LuaInterface04::init() {// 创建一个新的状态m_pLuaState = luaL_newstate();// 打开所有系统提供的库luaL_openlibs(m_pLuaState);// 调用C++lua_pushcfunction(m_pLuaState, l_getMyName);lua_setglobal(m_pLuaState, &quot;getMyName&quot;);string path = CCFileUtils::sharedFileUtils()-&gt;fullPathForFilename(&quot;Interface04.lua&quot;);luaL_dofile(m_pLuaState, path.c_str());lua_pcall(m_pLuaState, 0, 0, -1);}LuaInterface04 *LuaInterface04::shareInterface() {if (!i) {i = new LuaInterface04;i -&gt; init();}return i;}</code></pre><h5 id="新建一个-lua的访问类文件，并且输入-3"><a href="#新建一个-lua的访问类文件，并且输入-3" class="headerlink" title="新建一个.lua的访问类文件，并且输入"></a>新建一个.lua的访问类文件，并且输入</h5><pre><code>print(&quot;Begin&quot;)print(getMyName())print(&quot;End&quot;)</code></pre><h5 id="控制答应结果：-6"><a href="#控制答应结果：-6" class="headerlink" title="控制答应结果："></a>控制答应结果：</h5><pre><code>BeginString from C/C++End</code></pre><h6 id="深入理解编写C函数上"><a href="#深入理解编写C函数上" class="headerlink" title="深入理解编写C函数上"></a>深入理解编写C函数上</h6><h5 id="增加register-my-function方法"><a href="#增加register-my-function方法" class="headerlink" title="增加register_my_function方法"></a>增加register_my_function方法</h5><h6 id="h"><a href="#h" class="headerlink" title=".h"></a>.h</h6><pre><code>static int l_showName(lua_State *L);static int l_showYoueName(lua_State *L);static void register_my_function(lua_State *L);</code></pre><h6 id="cpp"><a href="#cpp" class="headerlink" title=".cpp"></a>.cpp</h6><pre><code>static int l_showName(lua_State *L) {const char * value1 = luaL_checkstring(L, -1);const char * value2 = luaL_checkstring(L, -2);const char * value3 = luaL_checkstring(L, -3);CCLOG(&quot;value1 is :%s&quot;, value1);CCLOG(&quot;value2 is :%s&quot;, value2);CCLOG(&quot;value3 is :%s&quot;, value3);//lua_pushstring(L, value1);return 1;}static int l_showYoueName(lua_State *L) {const char * value = luaL_checkstring(L, -1);lua_pushstring(L, value);return 1;}static void register_my_function(lua_State *L) {lua_pushcfunction(L, LuaInterface04::l_getMyName);lua_setglobal(L, &quot;getMyName&quot;);lua_pushcfunction(L, LuaInterface04::l_getMyName);lua_setglobal(L, &quot;showName&quot;);lua_pushcfunction(L, LuaInterface04::l_getMyName);lua_setglobal(L, &quot;show&quot;);}</code></pre><h5 id="在init中输入如下替换原始的调用方法"><a href="#在init中输入如下替换原始的调用方法" class="headerlink" title="在init中输入如下替换原始的调用方法"></a>在init中输入如下替换原始的调用方法</h5><pre><code>// 调用C++//lua_pushcfunction(m_pLuaState, l_getMyName);//lua_setglobal(m_pLuaState, &quot;getMyName&quot;);register_my_function(m_pLuaState);</code></pre><h5 id="新建一个-lua的访问类文件，并且输入-4"><a href="#新建一个-lua的访问类文件，并且输入-4" class="headerlink" title="新建一个.lua的访问类文件，并且输入"></a>新建一个.lua的访问类文件，并且输入</h5><pre><code>showName(&quot;Hello iCocos&quot;)show(&quot;Hello iCocos&quot;， &quot;Hello Lua&quot;)</code></pre><h6 id="深入理解编写C函数下"><a href="#深入理解编写C函数下" class="headerlink" title="深入理解编写C函数下"></a>深入理解编写C函数下</h6><h5 id="增加register-my-function方法-1"><a href="#增加register-my-function方法-1" class="headerlink" title="增加register_my_function方法"></a>增加register_my_function方法</h5><h6 id="h-1"><a href="#h-1" class="headerlink" title=".h"></a>.h</h6><pre><code>static int lua_showreturn1(lua_State * L);static int lua_showreturn2(lua_State * L);static int lua_showreturn3(lua_State * L);static int lua_showtable(lua_State * L);static int lua_showtable2(lua_State * L);</code></pre><h6 id="cpp-1"><a href="#cpp-1" class="headerlink" title=".cpp"></a>.cpp</h6><pre><code>//print(lua_showreturn1())static int lua_showreturn1(lua_State * L) {CCLOG(&quot;I am no return&quot;);return 0;}//print(lua_showreturn2())static int lua_showreturn2(lua_State * L) {CCLOG(&quot;I am one values&quot;);lua_pushstring(L, &quot;I am one values&quot;);return 1;}//print(lua_showreturn3())static int lua_showreturn3(lua_State * L) {CCLOG(&quot;I am two values&quot;);lua_pushstring(L, &quot;I am value one&quot;);lua_pushstring(L, &quot;I am value two&quot;);return 1;}//print(lua_showtable())static int lua_showtable(lua_State * L) {CCLOG(&quot;I am a table&quot;);lua_newtable(L);char str[20] = {0};for (int i = 1; i &lt;= 10; i++) {lua_pushnumber(L, i); // 压入keysprintf(str, &quot;numert is : %i&quot;, i);lua_pushstring(L, str); // 压入valuelua_settable(L, -3); // 将前面的key和value保存到table中}return 1;}//print(lua_showtable2())static int lua_showtable2(lua_State * L) {CCLOG(&quot;I am a table2&quot;);lua_newtable(L);char str[20] = {0};int looper = 1;while (looper &lt;= 10) {sprintf(str, &quot;key%i&quot;, looper);lua_pushstring(L, str); // 压入valuelooper++;lua_settable(L, -3); // 将前面的key和value保存到table中}return 1;}</code></pre><h5 id="在init中输入如下替换原始的调用方法-1"><a href="#在init中输入如下替换原始的调用方法-1" class="headerlink" title="在init中输入如下替换原始的调用方法"></a>在init中输入如下替换原始的调用方法</h5><pre><code>// 调用C++//lua_pushcfunction(m_pLuaState, l_getMyName);//lua_setglobal(m_pLuaState, &quot;getMyName&quot;);lua_pushcfunction(L, LuaInterface04::lua_showreturn1);lua_setglobal(L, &quot;showreturn1&quot;);lua_pushcfunction(L, LuaInterface04::lua_showreturn2);lua_setglobal(L, &quot;showreturn2&quot;);lua_pushcfunction(L, LuaInterface04::lua_showreturn3);lua_setglobal(L, &quot;showreturn3&quot;);lua_pushcfunction(L, LuaInterface04::lua_showtable);lua_setglobal(L, &quot;getMyTable&quot;);lua_pushcfunction(L, LuaInterface04::lua_showtable2);lua_setglobal(L, &quot;getMyTable2&quot;);</code></pre><h5 id="新建一个-lua的访问类文件，并且输入-5"><a href="#新建一个-lua的访问类文件，并且输入-5" class="headerlink" title="新建一个.lua的访问类文件，并且输入"></a>新建一个.lua的访问类文件，并且输入</h5><pre><code>print(showreturn1())print(showreturn2())print(showreturn3())local t = getMyTable()for k, v in pairs(t) doprint(k, v)endlocal t2 = getMyTable2()for k, v in pairs(t2) doprint(k, v)end</code></pre><h4 id="2-Lua调用C-C-之标准C模块"><a href="#2-Lua调用C-C-之标准C模块" class="headerlink" title="2.Lua调用C/C++之标准C模块"></a>2.Lua调用C/C++之标准C模块</h4><h5 id="在lua中init-c"><a href="#在lua中init-c" class="headerlink" title="在lua中init.c"></a>在lua中init.c</h5><pre><code>static int showResult1(lua_State * L) {lua_pushstring(L, &quot;I am showResult1&quot;);return 1;}static int showResult2(lua_State * L) {const char *value = luaL_checkstring(L, -1);//string rel = strcat(&quot;iCocos&quot;, value);lua_pushstring(L, value);return 1;}static const luaL_Reg myLibs[] = {{&quot;result1&quot;, showResult1},{&quot;result2&quot;, showResult2},{NULL, NULL},};int luaopen_my_lib(lua_State * L) {//luaL_newLib(L, myLibs);luaL_register(L, &quot;my_lib&quot;, myLibs);return 1;}</code></pre><h5 id="在static-const-luaL-Reg-loadedlibs-里面增加"><a href="#在static-const-luaL-Reg-loadedlibs-里面增加" class="headerlink" title="在static const luaL_Reg loadedlibs[] 里面增加"></a>在static const luaL_Reg loadedlibs[] 里面增加</h5><pre><code>{&quot;my_lib&quot;, luaopen_my_lib},</code></pre><h5 id="在lua中引入并调用方法"><a href="#在lua中引入并调用方法" class="headerlink" title="在lua中引入并调用方法"></a>在lua中引入并调用方法</h5><pre><code>--- 已入包local my_lib = require &quot;my_lib&quot;--- 调用方法print(my_lib.result1())print(my_lib.result2(&quot;I am showResult2&quot;))</code></pre><h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2><ul><li>后续的学习和开发，会相继介绍和分析一下totua，luajit，手动和自动绑定，第三个引入(支付，分析，分析，统计)，插件引入(sqlite，json,zlib)</li></ul><ul><li>推荐<ul><li><a href="https://blog.csdn.net/wu554513392/article/details/60594724" target="_blank" rel="noopener">https://blog.csdn.net/wu554513392/article/details/60594724</a></li><li><a href="https://blog.csdn.net/wyl1987527/article/details/77340896" target="_blank" rel="noopener">https://blog.csdn.net/wyl1987527/article/details/77340896</a></li><li><a href="https://www.cnblogs.com/zisou/p/cocos2dx-lua2.html" target="_blank" rel="noopener">https://www.cnblogs.com/zisou/p/cocos2dx-lua2.html</a></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> cocos2dx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocos2dx </tag>
            
            <tag> 游戏 </tag>
            
            <tag> cocos2dx lua 与 C/C++ 交互入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cocos2dx lua —— Http请求总结与实战(封装)</title>
      <link href="/2018/10/13/cocos2dx-lua-%E2%80%94%E2%80%94-Http%E8%AF%B7%E6%B1%82%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AE%9E%E6%88%98-%E5%B0%81%E8%A3%85/"/>
      <url>/2018/10/13/cocos2dx-lua-%E2%80%94%E2%80%94-Http%E8%AF%B7%E6%B1%82%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AE%9E%E6%88%98-%E5%B0%81%E8%A3%85/</url>
      <content type="html"><![CDATA[<p>今天的主题是关于cocos2dx lua实现短链接网络请求，使用Http实现基本的服务器网络数据获取，关于长链接（socket后续文件或者遇到需要的时候回特别实现与处理）</p><blockquote><p>关于Http这里就不多做介绍了，不过，作为一个程序员，网络请求是开发中最多也是最重要的一环节，这里比较建议，搞懂http的整个请求流程！</p></blockquote><p>推荐：<a href="https://blog.csdn.net/yezitoo/article/details/78193794" target="_blank" rel="noopener">一次完整的HTTP请求过程</a></p><a id="more"></a><p>在有了基本的Lua知识和cocos2dx lua基本的了解和学习之后，我有了一个初步的cocos2dx lua开发常识，然后就开始在上面实现基本的界面，并根据界面操作请求和响应数据！</p><h3 id="入口场景"><a href="#入口场景" class="headerlink" title="入口场景"></a>入口场景</h3><p>在main中初始化场景中必要的UI.</p><p>创建一个背景图片和一个按钮，实现点击按钮跳转到另外一个场景，进行网络请求和数据获取</p><pre><code>--- @class MainScenelocal MainScene = class(&quot;MainScene&quot;,cc.load(&quot;mvc&quot;).ViewBase)---onEnterfunction MainScene:onEnter()    print(&quot;onEnter&quot;)end---createStaticButton 通用创建按钮方法---@param node table---@param imageName table---@param x table---@param y table---@param callBack tablelocal function createStaticButton(node, imageName, x, y, callBack)    local btn = ccui.Button:create(imageName, imageName)    btn:move(x, y)    btn:addClickEventListener(callBack)    btn:addTo(node)end-------onCreatefunction MainScene:onCreate()    -- 初始化背景    display.newSprite(&quot;HelloWorld.png&quot;)        :move(display.center)        :addTo(self)    -- 初始化按钮    createStaticButton(self, &quot;button_start.png&quot;, display.cx, display.cy-150, function ()        self:getApp():enterScene(&quot;ApiRequest&quot;)    end)endreturn MainScene</code></pre><h3 id="网络应用场景-ApiRequest"><a href="#网络应用场景-ApiRequest" class="headerlink" title="网络应用场景(ApiRequest)"></a>网络应用场景(ApiRequest)</h3><p>然后开始处理跳转之后的ApiRequest，和相关请求逻辑，这里主要是使用我们封装好的CocosRequest实现基本上的请求逻辑，然后拿到数据之后我们就可以根据实际UI和具体业务逻辑做处理</p><blockquote><p>注意</p></blockquote><blockquote><p>测试的时候，将local url = “<a href="https://xxxx?cmd=501001&amp;uid=628941&amp;novelid=3782&quot;中的值换成自己的地址就可以" target="_blank" rel="noopener">https://xxxx?cmd=501001&amp;uid=628941&amp;novelid=3782&quot;中的值换成自己的地址就可以</a></p></blockquote><pre><code>require &quot;json&quot;local CocosRequest = require &quot;app.CocosRequest&quot;--- @class ApiRequestlocal ApiRequest = class(&quot;ApiRequest&quot;, cc.load(&quot;mvc&quot;).ViewBase)----local MainScene = class(&quot;MainScene&quot;, function() return display.newScene(&quot;MainScene&quot;) end)---onEnterfunction ApiRequest:onEnter()    print(&quot;onEnter&quot;)end-----onCreatefunction ApiRequest:onCreate()    ----------------------- 创建自定义事件 start    local function eventCustomListener1(event)        local str = &quot;response: &quot;..event._usedata        --labelStatusCode:setString(str)        -- 如果返回的是 json 数据，这里解析        local data =  json.decode(event._usedata)        table.foreach(data,         function(key, var)             print(&quot;-----&quot;..key)             table.foreach(var,                function(a, b)                   print(a..&quot;-&quot;..b)                end)         end)    end    local listener1 = cc.EventListenerCustom:create(&quot;customEvent1&quot;,eventCustomListener1)    cc.Director:getInstance():setNotificationNode(cc.Node:create())    local eventDispatcher = cc.Director:getInstance():getNotificationNode():getEventDispatcher()    eventDispatcher:addEventListenerWithFixedPriority(listener1, 6)    -- 将事件分配器赋值到CocosRequest.eventDispatcher    -- 用来在http请求返回的回调函数中使用，因为回调函数是在异步线程中执行，必须用自定义事件更新ui线程数据    local tmpHttp = CocosRequest:getInstance()    tmpHttp.eventDispatcher = eventDispatcher    ----------------------- 创建自定义事件 end    local tmp = CocosRequest:getInstance()    local function callback(xhr)        local event = cc.EventCustom:new(&quot;customEvent1&quot;)        event._usedata = xhr.response        eventDispatcher:dispatchEvent(event)        print(&quot;post callback code = &quot;..xhr.statusText)    end    local type = tmp.POST    local url = &quot;https://xxxx?cmd=501001&amp;uid=628941&amp;novelid=3782&quot;    local dataPost = {}    dataPost.data = &quot;hello&quot;    dataPost.aaa = &quot;world&quot;    dataPost.bbb = &quot;yang&quot;    tmp:send(type, url, dataPost, callback)endreturn ApiRequest</code></pre><h3 id="网络请求封装-CocosRequest"><a href="#网络请求封装-CocosRequest" class="headerlink" title="网络请求封装(CocosRequest)"></a>网络请求封装(CocosRequest)</h3><p>最后才是我们的重头戏，CocosRequest是直接使用cocos2dx lua提供的XMLHttpRequest实现，其实就是做了一套逻辑，具体细节可以根据项目调整(此处已经测试通过，可直接拷贝使用)</p><pre><code>require &quot;json&quot;CocosRequest = {}CocosRequest.__index = CocosRequestCocosRequest.instance = nilCocosRequest.callback = nilCocosRequest.POST = &quot;POST&quot;CocosRequest.GET = &quot;GET&quot;function CocosRequest:new()    local self = {}    setmetatable(self,CocosRequest)    return selfendfunction CocosRequest:getInstance()    if nil == self.instance then        self.instance = self:new()    end    return self.instanceend-- 数据转换，将请求数据由 table 型转换成 string，参数：tablefunction CocosRequest:dataParse(data)    if &quot;table&quot; ~= type(data) then        print(&quot;data is not a table&quot;)        return nil    end    local tmp = {}    for key, value in pairs(data) do        table.insert(tmp,key..&quot;=&quot;..value)    end    local newData = &quot;&quot;    for i=1,#tmp do        newData = newData..tostring(tmp[i])        if i&lt;#tmp then            newData = newData..&quot;&amp;&amp;&quot;        end    end    print(&quot;------- name is &quot;..newData)    return newDataend-- 发送数据，参数：string，string，tablefunction CocosRequest:send(type, url, data, callback)    local xhr = cc.XMLHttpRequest:new() --new 一个http request 实例    self.callback = callback    --设置需要执行的函数    local newData = self:dataParse(data)    if nil == newData or &quot;&quot; == newData then        return    end    -- response回调函数    local function responseCallback()        print(&quot;CocosRequest - &quot;..xhr.response)        if nil ~= self.callback then            self.callback(xhr)        else            print(&quot;callback is nil&quot;)        end    end    -- 设置返回值类型及回调函数    xhr.responseType = cc.XMLHTTPREQUEST_RESPONSE_STRING    xhr:registerScriptHandler(responseCallback)    -- 请求方式判断    if self.POST == type then        xhr:open(self.POST, url)        xhr:registerScriptHandler(responseCallback)        xhr:send(newData)    elseif self.GET == type then        xhr:open(self.GET, url..&quot;?&quot;..newData)        xhr:send()    else        print(&quot;ERROR : type only can be \&quot;Post\&quot; or \&quot;GET\&quot;&quot;)    endend---------------------return CocosRequest</code></pre><p>由于在Web中使用XMLHTTPRequest对象发出HTTP请求很普遍,Cocos2dx Lua对其进行了移植,可以在 Cocos2 d-x LumP中使用 XMLHTTPRequest对象</p><p>XMLHTTPRequest对象中几个常用的函数和属性如下</p><ul><li>(1)open(),与服务器连接,创建新的请求</li><li>(2)send(),向服务器发送请求</li><li>(3)abort(),退出当前请求</li><li>(4)readyState属性,提供当前请求的就绪状态,其中4表示准备就绪</li><li>(5)tatus属性,提供当前HTTP请求状态码,其中200表示成功请求</li><li>(6)respomseText属性,服务器返回的请求响应</li><li>(7) onreadystatechange属性。设置回调函数,当服务器处理完请求后就会自动调用该<br>函数。</li></ul><p>其中open和send函数,以及onreadystatechange属性是HTTP请求的关键。open函<br>数有以下5个参数可以使用</p><ul><li>(1) request-type:发送请求的类型。典型的值是GET或POST,也可以发送HEAD<br>请求</li><li>(2) url:要请求连接的URL</li><li>(3) asynch:如果希望使用异步连接则为true,否则为 false。该参数是可选的,默认为</li><li>(4) username:如果需要身份验证,则可以在此指定用户名。该可选参数没有默认值</li><li>(5) password:如果需要身份验证,则可以在此指定口令。该可选参数没有默认值。</li></ul><h3 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h3><p>下面是我们验证返回后的服务器数据(未做处理)</p><pre><code>[    {        &quot;code&quot;:1,        &quot;msg&quot;:&quot;操作成功&quot;,        &quot;data&quot;:[            {                &quot;novelid&quot;:&quot;3782&quot;,                &quot;uid&quot;:&quot;628875&quot;,                &quot;cid&quot;:&quot;5&quot;,                &quot;title&quot;:&quot;零下记忆&quot;,                &quot;cover&quot;:&quot;http://xxxx/img/cb/2f/f1/cb2ff155bbda8387f4b8efe917c46cd3.jpg&quot;,                &quot;scover&quot;:&quot;http://xxxx/img/cb/2f/f1/cb2ff155bbda8387f4b8efe917c46cd3.jpg&quot;,                &quot;shareimg&quot;:&quot;http://xxxx/img/ed/68/e6/ed68e67f77841ac76be189f0a04aa030.jpg&quot;,                &quot;intro&quot;:&quot;&quot;,                &quot;tags&quot;:&quot;悬疑&quot;,                &quot;reason&quot;:&quot;&quot;,                &quot;issingle&quot;:&quot;1&quot;,                &quot;sort&quot;:&quot;0&quot;,                &quot;hits&quot;:&quot;0&quot;,                &quot;reads&quot;:&quot;18753&quot;,                &quot;clues&quot;:20,                &quot;likes&quot;:&quot;1&quot;,                &quot;unlikes&quot;:&quot;0&quot;,                &quot;cmts&quot;:&quot;0&quot;,                &quot;favs&quot;:&quot;2&quot;,                &quot;words&quot;:&quot;18420&quot;,                &quot;chapters&quot;:&quot;35&quot;,                &quot;pub_chapters&quot;:&quot;35&quot;,                &quot;chapter_index&quot;:&quot;1&quot;,                &quot;pubtime&quot;:&quot;0&quot;,                &quot;updatetime&quot;:&quot;1539337440&quot;,                &quot;addtime&quot;:&quot;1534222233&quot;,                &quot;resversion&quot;:&quot;30&quot;,                &quot;isuser&quot;:&quot;0&quot;,                &quot;status&quot;:&quot;1&quot;,                &quot;wstatus&quot;:&quot;1&quot;,                &quot;offsale&quot;:&quot;0&quot;,                &quot;chapterstatus&quot;:&quot;-1&quot;,                &quot;leadrole&quot;:{                    &quot;roleid&quot;:&quot;8478&quot;,                    &quot;rolename&quot;:&quot;炽念&quot;                },                &quot;cname&quot;:&quot;推理&quot;,                &quot;isnew&quot;:0,                &quot;fatime&quot;:&quot;8月14日&quot;,                &quot;isreading&quot;:1,                &quot;iscomplete&quot;:1,                &quot;isfav&quot;:0,                &quot;liketype&quot;:0,                &quot;shareinfo&quot;:{                    &quot;type&quot;:1,                    &quot;title&quot;:&quot;零下记忆&quot;,                    &quot;intro&quot;:&quot;&quot;,                    &quot;img&quot;:&quot;http://xxxx/img/ed/68/e6/ed68e67f77841ac76be189f0a04aa030.jpg&quot;,                    &quot;url&quot;:&quot;http://xxxx/novel/startReading?novelid=3782&amp;chl=jmt&quot;                },                &quot;userinfo&quot;:{                    &quot;uid&quot;:&quot;628875&quot;,                    &quot;username&quot;:&quot;writer10&quot;,                    &quot;nickname&quot;:&quot;离经易道&quot;,                    &quot;headurl&quot;:&quot;http://xxxx/headimg/bb/d3/b6/628875_1_bbd3b631717ad615f38a6670573a375c_300x300.jpg?v=1526708983&quot;,                    &quot;sex&quot;:&quot;1&quot;,                    &quot;vtype&quot;:&quot;0&quot;,                    &quot;regtype&quot;:&quot;2&quot;,                    &quot;vname&quot;:&quot;&quot;,                    &quot;vicon&quot;:&quot;&quot;,                    &quot;isfollow&quot;:0                }            }        ],        &quot;cmd&quot;:501001,        &quot;time&quot;:1539677040    }]</code></pre>]]></content>
      
      <categories>
          
          <category> cocos2dx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocos2dx </tag>
            
            <tag> 游戏 </tag>
            
            <tag> cocos2dx lua —— Http请求总结与实战(封装) </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS游戏——渠道越狱打包流程</title>
      <link href="/2018/10/09/iOS%E6%B8%B8%E6%88%8F%E2%80%94%E2%80%94%E6%B8%A0%E9%81%93%E8%B6%8A%E7%8B%B1%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/"/>
      <url>/2018/10/09/iOS%E6%B8%B8%E6%88%8F%E2%80%94%E2%80%94%E6%B8%A0%E9%81%93%E8%B6%8A%E7%8B%B1%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>关于iOS普通ipa打包这里就不说了，只要注意苹果的一些协议条款，基本上步骤都是傻瓜式的，如果不知道如何打包iOS普通ipa包，请出门左转，度娘在哪里等你！</p><blockquote><p>那么，如何将app打包成越狱包，越狱iphone在cydia源上下载安装，这样的需求在互联网游戏行业是非常普遍的，尤其是各种马甲包横行的时代！</p></blockquote><h6 id="关于越狱相关内容，请看这里"><a href="#关于越狱相关内容，请看这里" class="headerlink" title="关于越狱相关内容，请看这里"></a>关于越狱相关内容，请看这里</h6><ul><li><a href="https://www.52pojie.cn/thread-683139-1-1.html" target="_blank" rel="noopener">iOS越狱解除工具</a></li><li><a href="https://www.baidu.com/link?url=1tVxiDdLIbOv2qstGpFdZEOf-18kIJHyyGSXt77CmMo8goYBtfcIYXJNkWePH5bR&amp;wd=&amp;eqid=88fc6288000136f6000000065bc81910" target="_blank" rel="noopener">ios越狱原理详解</a></li></ul><a id="more"></a><h3 id="常见deb包打包方式"><a href="#常见deb包打包方式" class="headerlink" title="常见deb包打包方式"></a>常见deb包打包方式</h3><h5 id="1、第一种方式："><a href="#1、第一种方式：" class="headerlink" title="1、第一种方式："></a>1、第一种方式：</h5><p>自定义目录下 如desktop创建文件夹，起名test，test内新建文件夹Payload<br>把xcode Build好的.app（Products目录中）拷到Payload目录中<br>打开终端，cd指令 到test文件目录下，执行 </p><pre><code>zip -r “xxx.ipa” *         注意里面的空格：(zip -r “xxx.ipa”[空格]* )</code></pre><p>ipa包就打好了，可以安装到越狱手机上试试看</p><blockquote><p>注意事项：Debug或Release的Any iOS SDK都设置为正式发布证书，经测试该越狱包可正常接收推送。</p></blockquote><h5 id="2、第二种方式："><a href="#2、第二种方式：" class="headerlink" title="2、第二种方式："></a>2、第二种方式：</h5><p>在xcode中点击Product-&gt;Archive,完成后会弹出Organizer，点右边的Distribute，弹出一个向导对话框，点击“Export as Xcode Archive”，选择位置，会在那个位置生成后缀名是.xcarchive的文件<br>右键“显示包内容”-&gt;”Products”-&gt;”applications” 然后找到那个应用程序，</p><blockquote><p>将其拖到iTunes里面，在itunes的【应用程序】里找到这个文件，然后右键“在Finder 中显示”，便可找到ipa文件了<br>….</p></blockquote><p>ipa包就打好了，可以安装到越狱手机上试试看</p><h3 id="最近发现了一种更好的方式"><a href="#最近发现了一种更好的方式" class="headerlink" title="最近发现了一种更好的方式"></a>最近发现了一种更好的方式</h3><p>致谢： <a href="http://www.zhaoxiaodan.com/" target="_blank" rel="noopener">胖梁的技术笔记</a></p><h5 id="1-修改编译选项重新打包"><a href="#1-修改编译选项重新打包" class="headerlink" title="1.修改编译选项重新打包"></a>1.修改编译选项重新打包</h5><p>在工程的Build Settings -&gt; Code Signing -&gt; Code Signing Identity选项, 将 Debug 和 Release 下的 Any iOS SDK都设置为 Don’t Code Sign然后在重新Archive</p><h5 id="2-准备目录"><a href="#2-准备目录" class="headerlink" title="2.准备目录"></a>2.准备目录</h5><p>创建一个目录用来打包,如tmp,tmp下建DEBIAN和Applications两个目录, DEBIAN下建一个文本文件control tmp目录结构如下:</p><pre><code>-DEBIAN---control-Applications</code></pre><p>control文件就是打包时的配置文件,它也会作为deb包的配置被打包到包中, 文件例子:</p><pre><code>Package: com.sharedream.gameName: 游戏测试Version: 0.1-1Description: 游戏测试游戏,开发中...Section: 游戏Depends: firmware (&gt;= 4.3)Priority: optionalArchitecture: iphoneos-armAuthor: liangwei &lt;http://weibo.com/iamliangwei&gt;Homepage: http://weibo.com/iamliangweiIcon: file:///Applications/game.app/Icon.pngMaintainer: liangwei &lt;http://weibo.com/iamliangwei&gt;</code></pre><p>然后将xcode打包出来的.app文件整个拷贝到Applications目录下, 结构如下:</p><pre><code>-DEBIAN---control-Applications---game.app</code></pre><h5 id="3-打包"><a href="#3-打包" class="headerlink" title="3.打包"></a>3.打包</h5><p>退出至tmp的上层目录</p><pre><code>dpkg-deb -b tmp game.deb</code></pre><p>看到如下几行就是打包完成了</p><pre><code>warning, `com.sull.sample/DEBIAN/control&apos; contains user-defined field `Name&apos;warning, `com.sull.sample/DEBIAN/control&apos; contains user-defined field `Author&apos;warning, `com.sull.sample/DEBIAN/control&apos; contains user-defined field `Sponsor&apos;dpkg-deb: ignoring 3 warnings about the control file(s)</code></pre><p>拷贝到cydia源中, 重新扫描包生成Packages列表文件, 并压缩成Packages.bz2就可以啦</p><pre><code>dpkg-scanpackages -m debs &gt;Packagesbzip2 -zkf Packages</code></pre><blockquote><p>contains ununderstood data member data.tar.xz” 的安装错误</p></blockquote><p>是因为自从1.17.0版本的dpkg-deb开始, 默认使用xz格式来压缩data.tar文件<br>但是,cydia在ios提供的dpkg是1.14版本, 还没有支持xz这种压缩格式<br>所以我们需要设置”-Zgzip”参数给dpkg-deb 进行打包, 类似命令:</p><pre><code>dpkg-deb -Zgzip -b tmp game.deb</code></pre><h6 id="关于iOS普通包打包可以参考这里："><a href="#关于iOS普通包打包可以参考这里：" class="headerlink" title="关于iOS普通包打包可以参考这里："></a>关于iOS普通包打包可以参考这里：</h6><ul><li><a href="https://blog.csdn.net/zhanghow/article/details/60603461?utm_source=blogxgwz8" target="_blank" rel="noopener">https://blog.csdn.net/zhanghow/article/details/60603461?utm_source=blogxgwz8</a></li></ul>]]></content>
      
      <categories>
          
          <category> Games </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
            <tag> iOS游戏——渠道越狱打包流程 </tag>
            
            <tag> 越狱 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cocos2dx lua注册事件详解</title>
      <link href="/2018/10/05/cocos2dx-lua%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/10/05/cocos2dx-lua%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>最近在学习cocos2dx lua的时候，遇到了一些关于事件注册的逻辑！</p><p>结合用户实际操作和游戏的真实需求，关于事件在游戏中还是使用非常多的，所以特此记录一下</p><blockquote><p>事件(源自网络)</p><blockquote><p>事件是可以被控件识别的操作。如按下确定按钮，选择某个单选按钮或者复选框。每一种控件有自己可以识别的事件，如窗体的加载、单击、双击等事件，编辑框（文本框）的文本改变事件，等等。</p></blockquote></blockquote><a id="more"></a><h6 id="事件是用户对窗口上各种组件的操作。"><a href="#事件是用户对窗口上各种组件的操作。" class="headerlink" title="事件是用户对窗口上各种组件的操作。"></a>事件是用户对窗口上各种组件的操作。</h6><ul><li>事件有系统事件和用户事件。<ul><li>1.系统事件由系统激发，如时间间隔24小时，银行储蓄的存款日期增加一天。</li><li>2.用户事件由用户激发，如用户点击按钮，在文本框中显示特定的文本。事件驱动控件执行某项功能。</li></ul></li></ul><h6 id="触发事件的对象称为事件发送者；接收事件的对象称为事件接受者；"><a href="#触发事件的对象称为事件发送者；接收事件的对象称为事件接受者；" class="headerlink" title="触发事件的对象称为事件发送者；接收事件的对象称为事件接受者；"></a>触发事件的对象称为事件发送者；接收事件的对象称为事件接受者；</h6><blockquote><p>注: 这里只针对用户事件！</p></blockquote><h4 id="cocos2dx中事件的类型"><a href="#cocos2dx中事件的类型" class="headerlink" title="cocos2dx中事件的类型"></a>cocos2dx中事件的类型</h4><ul><li>registerScriptTouchHandler             注册触屏事件</li><li>registerScriptTapHandler                  注册点击事件</li><li>registerScriptHandler                         注册基本事件 包括 触屏 层的进入 退出 事件</li><li>registerScriptKeypadHandler           注册键盘事件</li><li>registerScriptAccelerateHandler      注册加速事件</li></ul><p>在3.x之前事件的注册可以直接使用这些方式来注册，</p><ul><li>事件监听器主要有：<ul><li>触摸事件     : EventListenerTouchOneByOne、EventListenerTouchAllAtOnce</li><li>鼠标响应事件 : EventListenerMouse</li><li>键盘响应事件 : EventListenerKeyboard</li><li>加速计事件   : EventListenerAcceleration</li><li>自定义事件   : EventListenerCustom</li><li>物理碰撞事件 : EventListenerPhysicsContact</li><li>游戏手柄事件 : EventListenerController</li></ul></li></ul><p>而在3.x中由于加入了C++11的特性，而对事件的分发机制通过事件分发器EventDispatcher 来进行统一的管理。</p><blockquote><p>官方说明：触摸事件，键盘事件，加速器事件和自定义事件等所有事件都由 EventDispatcher 分发。 TouchDispatcher, KeypadDispatcher, KeyboardDispatcher, AccelerometerDispatcher 已经被移除。</p></blockquote><h3 id="【事件分发器】"><a href="#【事件分发器】" class="headerlink" title="【事件分发器】"></a>【事件分发器】</h3><p>事件分发器EventDispatcher，用于统一管理事件监听器的所有事件的分发。</p><ul><li><p>EventDispatcher 的特性主要有:</p><ul><li>事件的分发基于渲染顺序</li><li>所有的事件都由 EventDispatcher 分发</li><li>可以使用 EventDispatcher 来分发自定义事件</li><li>可以注册一个 lambda 表达式作为回调函数</li></ul></li></ul><h5 id="1、-eventDispatcher"><a href="#1、-eventDispatcher" class="headerlink" title="1、_eventDispatcher"></a>1、_eventDispatcher</h5><p>_eventDispatcher是Node的属性，通过Director::getInstance()-&gt;getEventDispatcher() 获得。</p><ul><li>_eventDispatcher的工作由三部分组成：<ul><li>（1）事件分发器 ：EventDispatcher。</li><li>（2）事件类型   ：EventTouch, EventKeyboard 等。</li><li>（3）事件监听器 ：EventListenerTouch, EventListenerKeyboard 等。</li></ul></li></ul><p>监听器实现了各种触发后的逻辑，在适当时候由事件分发器分发事件类型，然后调用相应类型的监听器。</p><h5 id="2、添加-删除监听器"><a href="#2、添加-删除监听器" class="headerlink" title="2、添加/删除监听器"></a>2、添加/删除监听器</h5><ul><li><p>添加监听器：</p><ul><li>addEventListenerWithSceneGraphPriority ，</li><li>addEventListenerWithFixedPriority 。</li></ul></li><li><p>删除监听器：</p><ul><li>removeEventListener ，</li><li>removeAllEventListeners 。</li></ul></li></ul><h5 id="3、主要函数"><a href="#3、主要函数" class="headerlink" title="3、主要函数"></a>3、主要函数</h5><p>包含监听器的添加、删除、暂停、恢复，优先级的设置，手动分发事件等。</p><pre><code>class EventDispatcher : public Ref{/*** 添加监听器*     - addEventListenerWithSceneGraphPriority*     - addEventListenerWithFixedPriority*     - addCustomEventListener*///使用 场景图的优先级 为指定事件添加一个监听.//listener : 指定要监听的事件.//node     : 这个节点的绘制顺序是基于监听优先级.//优先级   : 0void addEventListenerWithSceneGraphPriority(EventListener* listener, Node* node);//使用 一定的优先级 为指定事件添加一个监听.//listener      : 指定要监听的事件.//fixedPriority : 这个监听器的固定优先级.//优先级        : fixedPriority。(但是不能为0，因为他是场景图的基本优先级)void addEventListenerWithFixedPriority(EventListener* listener, int fixedPriority);//用户自定义监听器EventListenerCustom* addCustomEventListener(const std::string &amp;eventName, const std::function&lt;void(EventCustom*)&gt;&amp; callback);/*** 删除监听器*     - removeEventListener*     - removeEventListenersForType*     - removeEventListenersForTarget*     - removeCustomEventListeners*     - removeAllEventListeners*///删除指定监听器void removeEventListener(EventListener* listener);//删除某类型对应的所有监听器//EventListener::Type:://  单点触摸 : TOUCH_ONE_BY_ONE//  多点触摸 : TOUCH_ALL_AT_ONCE//  键盘     : KEYBOARD//  鼠标     : MOUSE//  加速计   : ACCELERATION//  自定义   : CUSTOMvoid removeEventListenersForType(EventListener::Type listenerType);//删除绑定在节点target上的所有监听器void removeEventListenersForTarget(Node* target, bool recursive = false);//删除名字为customEventName的所有自定义监听器void removeCustomEventListeners(const std::string&amp; customEventName);//移除所有监听器void removeAllEventListeners();/*** 暂停、恢复在节点target上的所有监听器*     - pauseEventListenersForTarget*     - resumeEventListenersForTarget*/void pauseEventListenersForTarget(Node* target, bool recursive = false);void resumeEventListenersForTarget(Node* target, bool recursive = false);/*** 其他*     - setPriority*     - setEnabled*     - dispatchEvent*     - dispatchCustomEvent*///设置某监听器的优先级void setPriority(EventListener* listener, int fixedPriority);//启用事件分发器void setEnabled(bool isEnabled);bool isEnabled() const;//手动派发自定义事件void dispatchEvent(Event* event);//给名字为eventName的自定义监听器, 绑定用户数据void dispatchCustomEvent(const std::string &amp;eventName, void *optionalUserData = nullptr);}</code></pre><h5 id="4、关于事件监听器的优先权"><a href="#4、关于事件监听器的优先权" class="headerlink" title="4、关于事件监听器的优先权"></a>4、关于事件监听器的优先权</h5><p>通过 addEventListenerWithSceneGraphPriority 添加的监听器，优先权为0。<br>通过 addEventListenerWithFixedPriority 添加的监听器，可以自定义优先权，但不能为0。</p><ul><li>优先级越低，越先响应事件。</li><li>如果优先级相同，则上层的（z轴）先接收触摸事件。</li></ul><h5 id="5、使用步骤"><a href="#5、使用步骤" class="headerlink" title="5、使用步骤"></a>5、使用步骤</h5><ul><li>（1）获取事件分发器：<ul><li>dispatcher = Director::getInstance()-&gt;getEventDispatcher();</li></ul></li><li>（2）创建监听器：<ul><li>auto listener = EventListenerTouchOneByOne::create();</li></ul></li><li>（3）绑定响应事件函数：<ul><li>listener-&gt;onTouchBegan = CC_CALLBACK_2(callback, this);</li></ul></li><li>（4）将监听器添加到事件分发器dispatcher中：<ul><li>dispatcher-&gt;addEventListenerWithSceneGraphPriority(Listener, this);</li></ul></li><li>（5）编写回调响应函数：<ul><li>bool callback(Touch<em> touch, Event</em> event) { … }</li></ul></li></ul><h3 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h3><p>先来看看项目用用到的一些简单时间的操作， 两种方式创建使用</p><h5 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h5><p>根据用户手机在屏幕触摸的位置，对场景或者场景中的精灵，控件的做一些处理，这种类型偏向于触摸屏的设备。</p><pre><code>local function onTouchBegan(touch, event)local location = touch:getLocation()local visiableSize = cc.Director:getInstance():getVisibleSize()local origin = cc.Director:getInstance():getVisibleOrigin()local finalX = location.x - (origin.x + visiableSize.width/2)local finalY = location.y - (origin.y + visiableSize.height/2)finalX, finalY 根据实际屏幕计算触摸点endlocal listener = cc.EventListenerTouchOneByOne:create()listener:registerScriptHandler(onTouchBegan, cc.Handler.EVENT_TOUCH_BEGAN)local eventDiapatcher = self:getEventDispatcher()eventDiapatcher:addEventListenerWithSceneGraphPriority(listener, self)</code></pre><h5 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h5><p>这里是coco2dx 定义的一套键盘字节码，每一个键盘上的键都对应一个数字，我们可以根据用户按键对精灵和界面做控制，这种偏向于桌面版的游戏！</p><h6 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h6><pre><code>-- 键盘监听器local listener = cc.EventListenerKeyboard:create()listener:registerScriptHandler(function(keyCode, event)if self.tank ~= nil then-- wif keyCode == 146 thenself.tank:MoveBegin(&quot;up&quot;)-- selseif keyCode == 142 thenself.tank:MoveBegin(&quot;down&quot;)-- aelseif keyCode == 124 thenself.tank:MoveBegin(&quot;left&quot;)-- delseif keyCode == 127 thenself.tank:MoveBegin(&quot;right&quot;)endendend, cc.Handler.EVENT_KEYBOARD_PRESSED) --- cc.Handler.EVENT_KEYBOARD_RELEASED)local eventDiapatcher = self:getEventDispatcher()eventDiapatcher:addEventListenerWithSceneGraphPriority(listener, self)</code></pre><h6 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h6><pre><code>local function keyboardPressed(keyCode, event)-- upif keyCode == 28 thenself:MoveCursor(0, 1)-- downelseif keyCode == 29 thenself:MoveCursor(0, -1)-- leftelseif keyCode == 26 thenself:MoveCursor(-1, 0)-- rightelseif keyCode == 27 thenself:MoveCursor(1, 0)-- page upelseif keyCode == 38 thenself:SwitchCursor(-1)-- page downelseif keyCode == 44 thenself:SwitchCursor(1)-- enterelseif keyCode == 38 thenself:Place()-- deleteelseif keyCode == 44 thenself:Delete()-- F3elseif keyCode == 49 thenself:Load()-- F4elseif keyCode == 50 thenself:Save()endprint(&quot;key board ???????? keyCode&quot;, keyCode)end-- 键盘监听器local listener = cc.EventListenerKeyboard:create()listener:registerScriptHandler(keyboardPressed, cc.Handler.EVENT_KEYBOARD_PRESSED)local eventDiapatcher = self:getEventDispatcher()eventDiapatcher:addEventListenerWithSceneGraphPriority(listener, self)</code></pre><p>这里主要说一下codeKey，codeKey是cocos2dx定义的一套键盘的代码，每个平台几乎是通用的</p><h3 id="【触摸事件】"><a href="#【触摸事件】" class="headerlink" title="【触摸事件】"></a>【触摸事件】</h3><h5 id="1、单点触摸：EventListenerTouchOneByOne"><a href="#1、单点触摸：EventListenerTouchOneByOne" class="headerlink" title="1、单点触摸：EventListenerTouchOneByOne"></a>1、单点触摸：EventListenerTouchOneByOne</h5><p>单点触摸监听器相关：</p><pre><code>static EventListenerTouchOneByOne* create();std::function&lt;bool(Touch*, Event*)&gt; onTouchBegan; //只有这个返回值为 boolstd::function&lt;void(Touch*, Event*)&gt; onTouchMoved;std::function&lt;void(Touch*, Event*)&gt; onTouchEnded;std::function&lt;void(Touch*, Event*)&gt; onTouchCancelled;</code></pre><p>使用举例：</p><pre><code>//获取事件分发器auto dispatcher = Director::getInstance()-&gt;getEventDispatcher();//创建单点触摸监听器 EventListenerTouchOneByOneauto touchListener = EventListenerTouchOneByOne::create();//单点触摸响应事件绑定touchListener-&gt;onTouchBegan     = CC_CALLBACK_2(HelloWorld::onTouchBegan, this);touchListener-&gt;onTouchMoved     = CC_CALLBACK_2(HelloWorld::onTouchMoved, this);touchListener-&gt;onTouchEnded     = CC_CALLBACK_2(HelloWorld::onTouchEnded, this);touchListener-&gt;onTouchCancelled = CC_CALLBACK_2(HelloWorld::onTouchCancelled, this);//在事件分发器中，添加触摸监听器，事件响应委托给 this 处理dispatcher-&gt;addEventListenerWithSceneGraphPriority(touchListener, this);//单点触摸事件响应函数bool onTouchBegan(Touch *touch, Event *unused_event)     { CCLOG(&quot;began&quot;); return true; }void onTouchMoved(Touch *touch, Event *unused_event)     { CCLOG(&quot;moved&quot;); }void onTouchEnded(Touch *touch, Event *unused_event)     { CCLOG(&quot;ended&quot;); }void onTouchCancelled(Touch *touch, Event *unused_event) { CCLOG(&quot;cancelled&quot;); }</code></pre><h5 id="2、多点触摸：EventListenerTouchAllAtOnce"><a href="#2、多点触摸：EventListenerTouchAllAtOnce" class="headerlink" title="2、多点触摸：EventListenerTouchAllAtOnce"></a>2、多点触摸：EventListenerTouchAllAtOnce</h5><p>多点触摸监听器相关：</p><pre><code>static EventListenerTouchAllAtOnce* create();std::function&lt;void(const std::vector&lt;Touch*&gt;&amp;, Event*)&gt; onTouchesBegan;std::function&lt;void(const std::vector&lt;Touch*&gt;&amp;, Event*)&gt; onTouchesMoved;std::function&lt;void(const std::vector&lt;Touch*&gt;&amp;, Event*)&gt; onTouchesEnded;std::function&lt;void(const std::vector&lt;Touch*&gt;&amp;, Event*)&gt; onTouchesCancelled;</code></pre><p>使用举例：</p><pre><code>//获取事件分发器auto dispatcher = Director::getInstance()-&gt;getEventDispatcher();//创建多点触摸监听器 EventListenerTouchAllAtOnceauto touchesListener = EventListenerTouchAllAtOnce::create();//多点触摸响应事件绑定touchesListener-&gt;onTouchesBegan     = CC_CALLBACK_2(HelloWorld::onTouchesBegan, this);touchesListener-&gt;onTouchesMoved     = CC_CALLBACK_2(HelloWorld::onTouchesMoved, this);touchesListener-&gt;onTouchesEnded     = CC_CALLBACK_2(HelloWorld::onTouchesEnded, this);touchesListener-&gt;onTouchesCancelled = CC_CALLBACK_2(HelloWorld::onTouchesCancelled, this);//在事件分发器中，添加触摸监听器，事件响应委托给 this 处理dispatcher-&gt;addEventListenerWithSceneGraphPriority(touchesListener, this);//多点触摸事件响应函数void onTouchesBegan(const std::vector&lt;Touch*&gt;&amp; touches, Event *unused_event)    { CCLOG(&quot;began&quot;); }void onTouchesMoved(const std::vector&lt;Touch*&gt;&amp; touches, Event *unused_event)    { CCLOG(&quot;moved&quot;); }void onTouchesEnded(const std::vector&lt;Touch*&gt;&amp; touches, Event *unused_event)    { CCLOG(&quot;ended&quot;); }void onTouchesCancelled(const std::vector&lt;Touch*&gt;&amp;touches, Event *unused_event) { CCLOG(&quot;cancelled&quot;); }</code></pre><h3 id="【鼠标事件】"><a href="#【鼠标事件】" class="headerlink" title="【鼠标事件】"></a>【鼠标事件】</h3><p>EventListenerMouse，主要用于监听鼠标的点击、松开、移动、滚轮的事件。</p><p>鼠标事件监听器相关：</p><pre><code>static EventListenerMouse* create();std::function&lt;void(Event* event)&gt; onMouseDown;     //按下鼠标, 单击鼠标std::function&lt;void(Event* event)&gt; onMouseUp;   //松开鼠标, 按下的状态下松开std::function&lt;void(Event* event)&gt; onMouseMove;  //移动鼠标, 在屏幕中移动std::function&lt;void(Event* event)&gt; onMouseScroll;//滚动鼠标, 滚动鼠标的滚轮</code></pre><p>使用举例：</p><pre><code>//获取事件分发器auto dispatcher = Director::getInstance()-&gt;getEventDispatcher();//创建鼠标事件监听器 EventListenerMouseEventListenerMouse* mouseListenter = EventListenerMouse::create();//鼠标事件响应函数mouseListenter-&gt;onMouseDown   = CC_CALLBACK_1(HelloWorld::onMouseDown,   this);mouseListenter-&gt;onMouseUp     = CC_CALLBACK_1(HelloWorld::onMouseUp,     this);mouseListenter-&gt;onMouseMove   = CC_CALLBACK_1(HelloWorld::onMouseMove,   this);mouseListenter-&gt;onMouseScroll = CC_CALLBACK_1(HelloWorld::onMouseScroll, this);//添加鼠标事件监听器，事件响应处理委托给thisdispatcher-&gt;addEventListenerWithSceneGraphPriority(mouseListenter, this);//事件响应函数void onMouseDown(Event* event)   { CCLOG(&quot;Down&quot;); }void onMouseUp(Event* event)     { CCLOG(&quot;UP&quot;); }void onMouseMove(Event* event)   { CCLOG(&quot;MOVE&quot;); }void onMouseScroll(Event* event) { CCLOG(&quot;Scroll&quot;); }</code></pre><h3 id="【键盘事件】"><a href="#【键盘事件】" class="headerlink" title="【键盘事件】"></a>【键盘事件】</h3><p>EventListenerKeyboard，主要用于监听键盘某个键的按下、松开的事件。</p><p>键盘事件监听器相关：</p><pre><code>static EventListenerKeyboard* create();std::function&lt;void(EventKeyboard::KeyCode, Event*)&gt; onKeyPressed;  //按下某键std::function&lt;void(EventKeyboard::KeyCode, Event*)&gt; onKeyReleased; //松开某键//键盘按键枚举类型 EventKeyboard::KeyCode//KeyCode的值对应的不是键盘的键值、也不是ASCII码，只是纯粹的枚举类型//如://  EventKeyboard::KeyCode::KEY_A//  EventKeyboard::KeyCode::KEY_1//  EventKeyboard::KeyCode::KEY_F1//  EventKeyboard::KeyCode::KEY_SPACE//  EventKeyboard::KeyCode::KEY_ALT//  EventKeyboard::KeyCode::KEY_SHIFT</code></pre><p>使用举例：</p><pre><code>////获取事件分发器auto dispatcher = Director::getInstance()-&gt;getEventDispatcher();//创建键盘按键事件监听器EventListenerKeyboard* keyboardListener = EventListenerKeyboard::create();//绑定事件响应函数keyboardListener-&gt;onKeyPressed = CC_CALLBACK_2(HelloWorld::onKeyPressed, this);keyboardListener-&gt;onKeyReleased = CC_CALLBACK_2(HelloWorld::onKeyReleased, this);//添加监听器dispatcher-&gt;addEventListenerWithSceneGraphPriority(keyboardListener, this);//事件响应函数void onKeyPressed(EventKeyboard::KeyCode keyCode, Event* event) {if (EventKeyboard::KeyCode::KEY_J == keyCode) {CCLOG(&quot;Pressed: J&quot;);}}void onKeyReleased(EventKeyboard::KeyCode keyCode, Event* event) {if (EventKeyboard::KeyCode::KEY_SPACE == keyCode) {CCLOG(&quot;Released: SPACE&quot;);}}</code></pre><h3 id="【加速计事件】"><a href="#【加速计事件】" class="headerlink" title="【加速计事件】"></a>【加速计事件】</h3><p>EventListenerAcceleration，主要用于监听移动设备的所受重力方向感应事件。</p><p>重力感应来自移动设备的加速计，通常支持 (X, Y, Z) 三个方向的加速度感应，所以又称为三向加速计。在实际应用中，可以根据3个方向的力度大小来计算手机倾斜的角度或方向。</p><h5 id="1、加速计信息类Acceleration"><a href="#1、加速计信息类Acceleration" class="headerlink" title="1、加速计信息类Acceleration"></a>1、加速计信息类Acceleration</h5><p>该类中每个方向的加速度，大小都为一个重力加速度大小。</p><pre><code>//加速计信息class Acceleration{double x; double y; double z;};</code></pre><h5 id="2、开启加速计感应"><a href="#2、开启加速计感应" class="headerlink" title="2、开启加速计感应"></a>2、开启加速计感应</h5><p>在使用加速计事件监听器之前，需要先启用此硬件设备：</p><pre><code>Device::setAccelerometerEnabled(true);</code></pre><h5 id="3、加速计监听器相关"><a href="#3、加速计监听器相关" class="headerlink" title="3、加速计监听器相关"></a>3、加速计监听器相关</h5><pre><code>static EventListenerAcceleration* create(const std::function&lt;void(Acceleration*, Event*)&gt;&amp; callback);std::function&lt;void(Acceleration*, Event*)&gt; onAccelerationEvent;</code></pre><h5 id="4、使用举例"><a href="#4、使用举例" class="headerlink" title="4、使用举例"></a>4、使用举例</h5><pre><code>//标签: 显示加速计信息label = Label::createWithTTF(&quot;no used&quot;, &quot;Marker Felt.ttf&quot;, 12);label-&gt;setPosition(visibleSize / 2);this-&gt;addChild(label);//小球: 可视化加速计ball = Sprite::create(&quot;ball.png&quot;);ball-&gt;setPosition(visibleSize / 2);this-&gt;addChild(ball);//获取事件分发器auto dispatcher = Director::getInstance()-&gt;getEventDispatcher();//需要开启移动设备的加速计Device::setAccelerometerEnabled(true);//创建加速计事件监听器auto accelerationListener = EventListenerAcceleration::create(CC_CALLBACK_2(HelloWorld::onAccelerationEvent, this));//添加加速计监听器dispatcher-&gt;addEventListenerWithSceneGraphPriority(accelerationListener, this);//事件响应函数void HelloWorld::onAccelerationEvent(Acceleration* acceleration, Event* event){char s[100];sprintf(s, &quot;X: %f; Y: %f; Z:%f; &quot;, acceleration-&gt;x, acceleration-&gt;y, acceleration-&gt;z);label-&gt;setString(s);//改变小球ball的位置float x = ball-&gt;getPositionX() + acceleration-&gt;x * 10;float y = ball-&gt;getPositionY() + acceleration-&gt;y * 10;Vec2 pos = Vec2(x, y);pos.clamp(ball-&gt;getContentSize() / 2, Vec2(288, 512) - ball-&gt;getContentSize() / 2);ball-&gt;setPosition(pos); //设置位置}</code></pre><h3 id="【自定义事件】"><a href="#【自定义事件】" class="headerlink" title="【自定义事件】"></a>【自定义事件】</h3><p>以上是系统自带的事件类型，事件由系统内部自动触发，如 触摸屏幕，键盘响应等。</p><p>EventListenerCustom 自定义事件，它不是由系统自动触发，而是人为的干涉。</p><p>它的出现，使得2.x中的 观察者模式 NotificationCenter（订阅发布消息） 被无情的遗弃了。</p><blockquote><p>在 3.x 中，使用EventListenerCustom来实现消息的订阅与发布。</p></blockquote><p>学习它之前，最好了解一下 NotificationCenter 这个类的用法。</p><blockquote><p>NotificationCenter 的用法参见：<a href="http://shahdza.blog.51cto.com/2410787/1611575" target="_blank" rel="noopener">http://shahdza.blog.51cto.com/2410787/1611575</a></p></blockquote><h5 id="1、创建自定义监听器"><a href="#1、创建自定义监听器" class="headerlink" title="1、创建自定义监听器"></a>1、创建自定义监听器</h5><p>该监听器，就相当于是订阅消息。即与NotificationCenter的 addObserver 类似。</p><pre><code>//eventName : 监听器名字，即消息的名称//callback  : 监听器函数，即消息的回调函数static EventListenerCustom* create(const std::string&amp; eventName, const std::function&lt;void(EventCustom*)&gt;&amp; callback);</code></pre><h5 id="2、分发自定义事件"><a href="#2、分发自定义事件" class="headerlink" title="2、分发自定义事件"></a>2、分发自定义事件</h5><p>自定义的事件监听器，需要通过手动的方式，将事件分发出去。</p><blockquote><p>通过 EventCustom(string eventName);       来设置需要发布消息的数据信息，eventName为消息名称。</p></blockquote><p>其中EventCustom可以通过setUserData来绑定想要传递的消息数据。</p><blockquote><p>通过 dispatcher-&gt;dispatchEvent(&amp;event); 来手动将事件分发出去。即发布消息。</p></blockquote><p>这与NotificationCenter的 postNotification 类似。</p><pre><code>EventCustom event(&quot;custom_event&quot;);event-&gt;setUserData((void*)123); // 绑定消息传递的数据，可以为任意类型void。dispatcher-&gt;dispatchEvent(&amp;event); // 发布名称为&quot;custom_event&quot;的消息。</code></pre><h5 id="3、使用举例"><a href="#3、使用举例" class="headerlink" title="3、使用举例"></a>3、使用举例</h5><pre><code>//获取事件分发器auto dispatcher = Director::getInstance()-&gt;getEventDispatcher();//创建自定义事件监听器//监听器名字  : &quot;custom_event&quot;//事件响应函数: HelloWorld::onCustomEventauto customListener = EventListenerCustom::create(&quot;custom_event&quot;, CC_CALLBACK_1(HelloWorld::onCustomEvent, this));//添加自定义事件监听器，优先权为1dispatcher-&gt;addEventListenerWithFixedPriority(customListener, 1);//手动分发监听器的事件，通过dispatchEvent发布名称为custom_event的消息。EventCustom event = EventCustom(&quot;custom_event&quot;);event-&gt;setUserData((void*)123); // 绑定消息传递的数据，可以为任意类型void。dispatcher-&gt;dispatchEvent(&amp;event);//消息事件回调函数void HelloWorld::onCustomEvent(EventCustom* event){// 获取消息传递的数据int* data = (int*)event-&gt;getUserData()CCLOG(&quot;onCustomEvent data = %d&quot;, data);}</code></pre><h5 id="4、说明"><a href="#4、说明" class="headerlink" title="4、说明"></a>4、说明</h5><blockquote><p>每个自定义的事件监听器，都有一个监听器名字eventName。即为订阅的消息名称。</p></blockquote><blockquote><p>需要通过 dispatcher-&gt;dispatchEvent(&amp;event); 来手动将事件分发出去。即为发布消息。</p></blockquote><blockquote><p>可以通过 dispatcher-&gt;dispatchCustomEvent(,); 来给自定义事件监听器绑定一个用户数据。</p></blockquote>]]></content>
      
      <categories>
          
          <category> cocos2dx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocos2dx </tag>
            
            <tag> 事件 </tag>
            
            <tag> cocos2dx lua注册事件详解 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cocos2dx lua 闭包(匿名函数)入门实战</title>
      <link href="/2018/09/28/cocos2dx-lua-%E9%97%AD%E5%8C%85-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0-%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98/"/>
      <url>/2018/09/28/cocos2dx-lua-%E9%97%AD%E5%8C%85-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0-%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98/</url>
      <content type="html"><![CDATA[<p>本文首先通过具体的例子讲解了Lua中闭包的概念，然后总结了闭包的应用场合，最后探讨了Lua中闭包的实现原理。</p><blockquote><p>闭包的概念</p><blockquote><p>在Lua中，闭包（closure）是由一个函数和该函数会访问到的非局部变量（或者是upvalue）组成的，其中非局部变量（non-local variable）是指不是在局部作用范围内定义的一个变量，但同时又不是一个全局变量，主要应用在嵌套函数和匿名函数里，因此若一个闭包没有会访问的非局部变量，那么它就是通常说的函数。也就是说，在Lua中，函数是闭包一种特殊情况。</p></blockquote></blockquote><a id="more"></a><p>不知道c++的lambda和lua的闭包是谁先谁后，不过就我来说，是先学了c++，最近才接触到现代lua。因此把一切向c++看齐，会不自觉地把一切和c++做对比。</p><p>就闭包来说，不就是c++的lambda嘛！</p><p>前面所说的upvalue，也就是一开始按引用捕获，在变量退出生命期时，拷贝到Functor的成员变量里来，变成了按值捕获。这算是解释性语言特有的灵活性吧，变量可以在运行时按解释器的便利来移动位置，而不必像苦哈哈的编译性语言，一旦决定好位置，就无法移动了。</p><blockquote><p>在Lua的C API中，所有关于Lua中的函数的核心API都是以closure来命名的，也可视为这一观点的延续。在Lua中，函数是一种第一类型值（First-Class Value），它们具有特定的词法域（Lexical Scoping）。</p></blockquote><ul><li>Lua使用结构体upvalue来实现闭包。外面的局部变量可以直接通过upvalue进行访问。</li><li>upvalue最开始的时候指向栈中的一个变量，此时这个变量还在它的生存周期内。</li><li>当变量离开作用域（译者注：就是函数返回后，变量的生存周期结束时），这个变量就从栈转移到了upvalue中。</li><li>虽然这个变量存储在upvalue中，但是访问这个变量还是间接通过upvalue中的一个指针进行的（译者注：和在栈中时候的访问方式一样）。</li><li>因此，变量位置的转移对任何试图读写这个变量的代码都是透明的。</li><li>有别于这个变量在一个函数内部时候的行为，函数声明、访问这个变量，就是直接对栈的操作。</li></ul><p>看下具体例子：</p><pre><code>function f1(n)--函数参数n也是局部变量local function f2()print(n)   --引用外部函数的局部变量endreturn f2endg1 = f1(2015)g1() -- 打印出2015g2 = f1(2016)g2() -- 打印出2016</code></pre><p>这里的n就是upvalue。upvalue实际指的是变量而不是值，这些变量可以在内部函数之间共享，即upvalue提供一种闭包之间共享数据的方法，</p><p>再看个例子：</p><pre><code>function Create(n)local function foo1()print(n)endlocal function foo2()n = n + 10endreturn foo1,foo2endf1,f2 = Create(2015)f1() -- 打印2015f2()f1() -- 打印2025f2()f1() -- 打印2035</code></pre><p>上面的例子中，闭包f1和f2共享同一个upvalue了，这是因为当Lua发现两个闭包的upvalue指向的是当前堆栈上的相同变量时，会聪明地只生成一个拷贝，然后让这两个闭包共享该拷贝，这样任一个闭包对该upvalue进行修改都会被另一个探知。</p><ul><li>为什么会这样，我们看下面的解释：<ul><li>通过为每个变量最多创建一个upvalue并按需要重复利用这个upvalue，保证了未决状态（未超过生命周期）的局部变量（pending vars）能够在闭包之间正确地共享。</li><li>为了保证这种唯一性，Lua维护这一条链表，该链表中每个节点对应一个打开的upvalue（opend upvalue）结构，打开的upvalue是指当前正指向栈局部变量的upvalue，如上图的未决状态的局部变量链表（the pending vars list）。</li><li>当Lua创建一个新的闭包时，Lua会遍历当前函数所有的外部的局部变量，对于每一个外部的局部变量，若在上面的链表中能找到该变量，则重复使用该打开的upvalue，否则，Lua会创建一个新的打开的upvalue，并把它插入链表中。</li><li>当局部变量离开作用域时（即超过变量生命周期），这个打开的upvalue就会变成关闭的upvalue（closed upvalue），并把它从链表中删除，一旦某个关闭的upvalue不再被任何闭包所引用，那么它的存储空间就会被回收。</li></ul></li></ul><p>最后看下闭包的应用。</p><p>闭包最常用的一个应用就是实现迭代器。所谓迭代器就是一种可以遍历一种集合中所谓元素的机制。每个迭代器都需要在每次成功调用之间保持一些状态，这样才能知道它所在的位置及如何进到下一个位置。闭包刚好适合这种场景。比如下面的代码：</p><pre><code>function values(t)local i = 0return function () i = i + 1 return t[i] endendt = {10, 20, 30}iter = values(t)while true dolocal element = iter()if element == nil then break endprint(element)end</code></pre><p>总结下lua闭包，关键点是upvalue，然后注意下如何申明一个背包，函数（A）里面返回的是函数（B），B引用了A的局部变量。</p>]]></content>
      
      <categories>
          
          <category> cocos2dx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocos2dx </tag>
            
            <tag> 事件 </tag>
            
            <tag> ocos2dx lua 闭包(匿名函数)入门实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cocos2d-x lua —— 元表metatable</title>
      <link href="/2018/09/22/cocos2d-x-lua-%E2%80%94%E2%80%94-%E5%85%83%E8%A1%A8metatable/"/>
      <url>/2018/09/22/cocos2d-x-lua-%E2%80%94%E2%80%94-%E5%85%83%E8%A1%A8metatable/</url>
      <content type="html"><![CDATA[<h2 id="Lua表"><a href="#Lua表" class="headerlink" title="Lua表"></a>Lua表</h2><p>关于Lua表的介绍，这里有一段出自网络的介绍：</p><blockquote><p>Lua的表本质其实是个类似HashMap的东西，其元素是很多的Key-Value对.<br>如果尝试访问了一个表中并不存在的元素时，就会触发Lua的一套查找机制，也是凭借这个机制，才能够实现“面向对象”的。</p></blockquote><a id="more"></a><p>那么有时候我们可能会遇到这样的一段代码：</p><pre><code>myTable = {}  print(myTable.A) --这里试图打印myTable并不存在的成员A  </code></pre><blockquote><p>执行结果：nil</p></blockquote><blockquote><blockquote><p>输出为nil的原因很简单，myTable中并没有A这个成员，这符合我们平时对HashMap的认知。但对于Lua表，如果myTable有元表，情况就不同了。</p></blockquote></blockquote><h2 id="Lua元表"><a href="#Lua元表" class="headerlink" title="Lua元表"></a>Lua元表</h2><blockquote><p>元表像是一个备用查找表，说白了假设表A的元表是B，那么如果在A中找不到的东西就会尝试在B中去找。</p></blockquote><ul><li>在Lua中，metatable是被译作元表，Lua 中的每个值都可以用一个 metatable。这个 metatable 就是一个原始的 Lua table ，它用来定义原始值在特定操作下的行为。</li><li>一个 metatable 可以控制一个对象做数学运算操作、比较操作、连接操作、取长度操作、取下标操作时的行为，metatable 中还可以定义一个函数，让 userdata 作垃圾收集时调用它。对于这些操作，Lua 都将其关联上一个被称作事件的指定健。</li><li>当 Lua 需要对一个值发起这些操作中的一个时，它会去检查值中 metatable 中是否有对应事件。如果有的话，键名对应的值（元方法）将控制 Lua 怎样做这个操作。</li></ul><p>#####metatable通过其包含的函数来给所挂接的table定义一些特殊的操作，包括:</p><ul><li>__add: 定义所挂接table的加法操作</li><li>__mul: 定义乘法操作</li><li>__div: 定义除法操作</li><li>__sub: 定义减法操作</li><li>__unm: 定义负操作, 即: -table的含义</li><li>__tostring: 定义当table作为tostring()函式之参数被呼叫时的行为(例如: print(table)时将呼叫tostring(table)作为输出结果)</li><li>__concat: 定义连接操作(“..”运算符)</li><li>__index: 定义当table中不存在的key值被试图获取时的行为</li><li>__newindex: 定义在table中产生新key值时的行为</li></ul><h5 id="这里主要说一下-index"><a href="#这里主要说一下-index" class="headerlink" title="这里主要说一下_index"></a>这里主要说一下_index</h5><h2 id="index："><a href="#index：" class="headerlink" title="__index："></a>__index：</h2><p>如果A的元表是B，那么如果访问了一个A中不存在的成员，就会访问查找B中有没有这个成员。</p><p>这个过程大体是这样，但却不完全是这样，实际上，即使将A的元表设置为B，而且B中也确实有这个成员，返回结果仍然会是nil</p><h5 id="原因就是"><a href="#原因就是" class="headerlink" title="原因就是"></a>原因就是</h5><blockquote><p>B的<strong>index元方法没有赋值。按照我的理解，</strong>index方法是用来确定一个表在被作为元表时的查找方法</p></blockquote><pre><code>father = {      house=1  }  son = {      car=1  }  setmetatable(son, father) --把son的metatable设置为father  print(son.house) </code></pre><p>输出的结果是nil，但如果把代码改为</p><pre><code>father = {      house=1  }  father.__index = father -- 把father的__index方法指向自己  son = {      car=1  }  setmetatable(son, father)  print(son.house) </code></pre><p>输出的结果为1，符合预期。</p><p>在上述例子中，访问son.house时，son中没有house这个成员，但Lua接着发现son有元表father，于是此时father被当做元表来查找.</p><p>此时，Lua并不是直接在father中找名为house的成员，而是调用father的<strong>index方法，如果</strong>index方法为nil，则返回nil，如果是一个表（上例中father的<strong>index方法等于自己，就是这种情况），那么就到</strong>index方法所指的这个表中查找名为house的成员，于是，最终找到了house成员。</p><blockquote><p>注：<strong>index方法除了可以是一个表，还可以是一个函数，如果是一个函数，</strong>index方法被调用时将返回该函数的返回值。</p></blockquote><p>相信到这里，应该已经很好理解了。</p><h5 id="总结一句就是：index是-当我们访问一个表中的元素不存在时，则会触发去寻找index元方法，如果不存在，则返回nil，如果存在，则返回结果。"><a href="#总结一句就是：index是-当我们访问一个表中的元素不存在时，则会触发去寻找index元方法，如果不存在，则返回nil，如果存在，则返回结果。" class="headerlink" title="总结一句就是：index是:当我们访问一个表中的元素不存在时，则会触发去寻找index元方法，如果不存在，则返回nil，如果存在，则返回结果。"></a>总结一句就是：<strong>index是:当我们访问一个表中的元素不存在时，则会触发去寻找</strong>index元方法，如果不存在，则返回nil，如果存在，则返回结果。</h5><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul><li>_newindex：当给你的表中不存在的值进行赋值时，lua解释器则会寻找__newindex元方法，发现存在该方法，则执行该方法进行赋值，注意，是使用rawset来进行赋值，至于原因，后面会讲到。</li><li>rawget是为了绕过<strong>index而出现的，直接点，就是让</strong>index方法的重写无效。</li></ul><h4 id="Lua查找一个表元素时的规则（出自网络）"><a href="#Lua查找一个表元素时的规则（出自网络）" class="headerlink" title="Lua查找一个表元素时的规则（出自网络）"></a>Lua查找一个表元素时的规则（出自网络）</h4><ul><li>1.在表中查找，如果找到，返回该元素，找不到则继续</li><li>2.判断该表是否有元表，如果没有元表，返回nil，有元表则继续</li><li>3.判断元表有没有<strong>index方法，如果</strong>index方法为nil，则返回nil；如果<strong>index方法是一个表，则重复1、2、3；如果</strong>index方法是一个函数，则返回该函数的返回值</li></ul><p>参考链接：<a href="https://blog.csdn.net/wangbin_jxust/article/details/12108189" target="_blank" rel="noopener">https://blog.csdn.net/wangbin_jxust/article/details/12108189</a></p>]]></content>
      
      <categories>
          
          <category> cocos2dx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocos2dx </tag>
            
            <tag> cocos2d-x lua —— 元表metatable </tag>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cocos2dx lua 语法糖之冒号(:)与点号(.)区别与使用</title>
      <link href="/2018/09/16/cocos2dx-lua-%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B9%8B%E5%86%92%E5%8F%B7-%E4%B8%8E%E7%82%B9%E5%8F%B7-%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/09/16/cocos2dx-lua-%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B9%8B%E5%86%92%E5%8F%B7-%E4%B8%8E%E7%82%B9%E5%8F%B7-%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>相信接触Lua或者做过cocos2dx lua的朋友，都遇到过这样的迷惑，关于Lua中冒号(:)与点号(.)语法糖，有时候会混乱，或者说一开始不太能适应和理解这里的区别和使用。</p><h5 id="今天，就主要围绕着两个点，实际对比一下，并结合案例进行实战，并进行一些相关的拓展！"><a href="#今天，就主要围绕着两个点，实际对比一下，并结合案例进行实战，并进行一些相关的拓展！" class="headerlink" title="今天，就主要围绕着两个点，实际对比一下，并结合案例进行实战，并进行一些相关的拓展！"></a>今天，就主要围绕着两个点，实际对比一下，并结合案例进行实战，并进行一些相关的拓展！</h5><a id="more"></a><p>先来看看下面这段代码：</p><pre><code>ObjectData = {}function ObjectData.count1( self )    print(&quot;ObjectData.count1&quot;, self)endfunction ObjectData:count2()    print(&quot;ObjectData:count2&quot;, self)enda = ObjectDataa.count1() -- nila:count1()a.count1(a)a:count1(a)a.count2() -- nila:count2()a.count2(a)a:count2(a)</code></pre><p>我们通过打印，得到下面的结果，是不是有点蒙圈了！</p><pre><code>-- ObjectData.count1    nil-- ObjectData.count1    table: 0x7c06d880-- ObjectData.count1    table: 0x7c06d880-- ObjectData.count1    table: 0x7c06d880-- ObjectData:count2    nil-- ObjectData:count2    table: 0x7c06d880-- ObjectData:count2    table: 0x7c06d880-- ObjectData:count2    table: 0x7c06d880</code></pre><p>有了上面的实例，我就可以通过简单的区分来实际应用和对比一下。</p><h4 id="方法的点号定义和点号调用。"><a href="#方法的点号定义和点号调用。" class="headerlink" title="方法的点号定义和点号调用。"></a>方法的点号定义和点号调用。</h4><pre><code>money = {count = 888}function money.getCount(money ,somecount)    money.count = money.count - somecountendmoney.getCount(money ,666)print(money.count)</code></pre><h4 id="冒号定义和冒号调用。"><a href="#冒号定义和冒号调用。" class="headerlink" title="冒号定义和冒号调用。"></a>冒号定义和冒号调用。</h4><pre><code>money = {count = 888}function money:getCount(somecount)    self.count = self.count - somecountendmoney:getCount(666)print(money.count)</code></pre><blockquote><p>以上的打印结果都是666。</p></blockquote><h5 id="可以看出，冒号定义和冒号调用其实跟上面的效果一样，只是把第一个隐藏参数省略了，而该参数self指向调用者自身"><a href="#可以看出，冒号定义和冒号调用其实跟上面的效果一样，只是把第一个隐藏参数省略了，而该参数self指向调用者自身" class="headerlink" title="可以看出，冒号定义和冒号调用其实跟上面的效果一样，只是把第一个隐藏参数省略了，而该参数self指向调用者自身"></a>可以看出，冒号定义和冒号调用其实跟上面的效果一样，只是把第一个隐藏参数省略了，而该参数self指向调用者自身</h5><p>当然了，我们也可以点号定义冒号调用，或者冒号定义点号调用</p><pre><code>money = {count = 888}function money.getCount(self ,somecount)    self.count = self.count - somecountendmoney:getCount(666)print(money.count)      </code></pre><p>冒号只是起了省略第一个参数self的作用，该self指向调用者本身，并没有其他特殊的地方。</p><blockquote><p>也有网友提出：用lua进行面向对象的编程,声明方法和调用方法统一用冒号,对于属性的调用全部用点号</p></blockquote><ul><li>由此总结就是：<ul><li>定义的时候冒号默认接收self参数</li><li>调用的时候冒号默认传递调用者自己为参数</li><li>而句号要显示传递或接收self参数</li><li>冒号会提供一个内置table供function之间通信。</li><li>一个点用来定义和取得一个变量，这个变量可能是个函数</li><li>两个点用来定义和调用一个函数，两个点会自动传入“调用者”这个table自身 </li></ul></li></ul><h5 id="如果是使用Cocos2d-x-lua来开发的话，大部分情况下都是使用冒号的。-原因很简单，因为大部分情况下我们都要使用到self参数，就像C-的this关键字一样。"><a href="#如果是使用Cocos2d-x-lua来开发的话，大部分情况下都是使用冒号的。-原因很简单，因为大部分情况下我们都要使用到self参数，就像C-的this关键字一样。" class="headerlink" title="如果是使用Cocos2d-x lua来开发的话，大部分情况下都是使用冒号的。 原因很简单，因为大部分情况下我们都要使用到self参数，就像C++的this关键字一样。"></a>如果是使用Cocos2d-x lua来开发的话，大部分情况下都是使用冒号的。 原因很简单，因为大部分情况下我们都要使用到self参数，就像C++的this关键字一样。</h5><ul><li>推荐：<ul><li><a href="https://blog.csdn.net/stormbjm/article/details/38532413" target="_blank" rel="noopener">https://blog.csdn.net/stormbjm/article/details/38532413</a></li><li><a href="https://www.cnblogs.com/youxilua/archive/2011/07/28/2119059.html" target="_blank" rel="noopener">https://www.cnblogs.com/youxilua/archive/2011/07/28/2119059.html</a></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> cocos2dx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocos2dx </tag>
            
            <tag> 游戏 </tag>
            
            <tag> cocos2dx lua 语法糖之冒号(:)与点号(.)区别与使用 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cocos2dx lua 常见命令行(编译&amp;调试&amp;运行&amp;打包)</title>
      <link href="/2018/09/15/cocos2dx-lua-%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E8%A1%8C-%E7%BC%96%E8%AF%91-%E8%B0%83%E8%AF%95-%E8%BF%90%E8%A1%8C-%E6%89%93%E5%8C%85/"/>
      <url>/2018/09/15/cocos2dx-lua-%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E8%A1%8C-%E7%BC%96%E8%AF%91-%E8%B0%83%E8%AF%95-%E8%BF%90%E8%A1%8C-%E6%89%93%E5%8C%85/</url>
      <content type="html"><![CDATA[<blockquote><p>cocos 命令</p><blockquote><p>Cocos2d-x 带有一个命令行工具：cocos 这是一个跨平台的工具，你可以用它创建项目、运行项目、发布项目。</p></blockquote></blockquote><blockquote><blockquote><p>命令行工具适用于所有 Cocos2d-x 支持的平台，包括：iOS、Android、Mac、Linux、Windows、Web。不用 IDE，只用命令行，你就能完成所有的工作！</p></blockquote></blockquote><p>本文选自<a href="http://docs.cocos2d-x.org/cocos2d-x/zh/editors_and_tools/cocosCLTool.html" target="_blank" rel="noopener">cocos2dx官方文档</a>，只做记录！</p><a id="more"></a><h3 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h3><p>使用 cocos new 命令创建新项目，命令格式如下：</p><pre><code>cocos new &lt;game name&gt; -p &lt;package identifier&gt; -l &lt;language&gt; -d &lt;location&gt;</code></pre><p>示例：</p><pre><code>cocos new MyGame -p com.MyCompany.MyGame -l cpp -d ~/MyCompanycocos new MyGame -p com.MyCompany.MyGame -l lua -d ~/MyCompanycocos new MyGame -p com.MyCompany.MyGame -l js -d ~/MyCompany</code></pre><p>使用命令 cocos new –help 可以查看到更多关于项目创建的帮助信息。</p><h3 id="项目编译"><a href="#项目编译" class="headerlink" title="项目编译"></a>项目编译</h3><p>我们都知道，程序从源码到二进制程序，有一个编译环节。我们来看下 Cocos2d-x 是如何编译项目的，命令格式如下：</p><pre><code>cocos compile -s &lt;path to your project&gt; -p &lt;platform&gt; -m &lt;mode&gt; -o &lt;output directory&gt;</code></pre><p>示例：</p><pre><code>cocos compile -s ~/MyCompany/MyGame -p ios -m release -o ~/MyCompany/MyGame/bincocos compile -s ~/MyCompany/MyGame -p android -m release -o ~/MyCompany/MyGame/bincocos compile -s c:\MyCompany\MyGame -p win32 -m release -o c:\MyCompany\MyGame\bin</code></pre><p>这里的参数有点多，让我们来一个一个说，-p 是编译的平台，-m 是模式：debug 或者 release。如果没指定模式，默认 debug。此外 -s 和 -o 参数是可选的，如果操作命令的当前路径就是工程的路径，那这两个参数都可以省掉。比如已经在 ~/MyCompany/MyGame 目录，那编译命令可以简化为：</p><pre><code>cocos compile . -p ios -m release</code></pre><p>你也可以增加一个可选的参数 -q，这样执行静默操作，控制台的输出信息会比较少。示例：</p><pre><code>cocos compile -q -s ~/MyCompany/MyGame -p ios -m release -o ~/MyCompany/MyGame/bin</code></pre><p>由于命令行工具支持很多平台，因此还有一些特定平台的参数，使用它们可以进行更多的控制，比如指定 SDK 版本，确定签名信息，添加一些 Lua 相关或专用于 Web 的选项。</p><p>使用命令 cocos compile –help 可以查看更多关于项目编译的帮助信息。</p><ul><li>Android 项目编译注意事项<ul><li>命令行工具是很灵活的，对于编译 Android 项目允许开发者使用特定版本的 API。比如你的系统上安装了 Android-22，你想使用它来编译，就在命令行的最后增加参数 –ap android-api-version。示例：<ul><li>cocos compile -p android –ap android-22</li></ul></li><li>你可以在项目的配置中，查看到目标 API 是什么版本。</li></ul></li></ul><h3 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h3><p>创建完项目后，你可以直接从命令行执行运行命令。cocos 会启动你指定平台的程序。命令行格式如下：</p><pre><code>cocos run -s &lt;path to your project&gt; -p &lt;platform&gt;</code></pre><p>示例:</p><pre><code>cocos run -s ~/MyCompany/MyGame -p ioscocos run -s ~/MyCompany/MyGame -p androidcocos run -s c:\MyCompany\MyGame -p win32</code></pre><p>当然，你也可以指定程序以 debug 还是 release 方式运行，默认的方式是 debug。示例：</p><pre><code>cocos run -s ~/MyCompany/MyGame -p ios -m release</code></pre><p>就好像 cocos compile 命令那样，如果你已经在项目目录了，-s 和 -o 参数就不是必须的，这对 cocos run 命令也一样。就以上面的为例，如果已经在工程目录，命令可以简化成：</p><pre><code>cocos run . -p ios -m release</code></pre><p>在运行 Web 程序时，还有可选的参数，允许你指定浏览器，例如指定 Google Chrome：</p><pre><code>cocos run -s ~/MyCompany/MyGame -p web -b /Applications/Google\ Chrome.appcocos run -s ~/MyCompany/MyGame -p web -b C:\Program Files\Google\Chrome\Application\chrome.execocos run -s ~/MyCompany/MyGame -p web -b /usr/local/bin/chrome</code></pre><p>你还可以指定 IP 地址和端口，更多关于项目运行的使用帮助，请运行 cocos run –help 命令。</p><h3 id="项目发布"><a href="#项目发布" class="headerlink" title="项目发布"></a>项目发布</h3><p>cocos 通过提供一系列项目发布的命令实现了简单的发布机制。这些命令，就像上面介绍的命令一样，通过一些参数指定需要的操作。命令格式如下：</p><pre><code>cocos deploy -s &lt;path to your project&gt; -p &lt;platform&gt; -m &lt;mode&gt;</code></pre><p>示例：</p><pre><code>cocos deploy -s ~/MyCompany/MyGame -p ios -m releasecocos deploy -s ~/MyCompany/MyGame -p android -m releasecocos deploy -s c:\MyCompany\MyGame -p win32 -m release</code></pre><p>你可以增加参数 -q，执行静默操作，这样控制台的输出信息会比较少。示例：</p><pre><code>cocos deploy -q -s ~/MyCompany/MyGame -p ios -m release</code></pre><p>运行 cocos deploy –help，可以查看更多关于项目发布的帮助信息。</p>]]></content>
      
      <categories>
          
          <category> cocos2dx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocos2dx </tag>
            
            <tag> 事件 </tag>
            
            <tag> cocos2dx lua 常见命令行(编译&amp;调试&amp;运行&amp;打包) </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cocos2dx——项目启动流程与跨平台原理</title>
      <link href="/2018/09/14/cocos2dx%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2018/09/14/cocos2dx%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>最近大部分空余时间都在开始学习cocos2d游戏开发相关技术，作为一个游戏行业菜鸟级别的选手，我觉得基础很重要，所以我决定从cocos2dx启动流程和快平台原理开始！</p><blockquote><p>注:这里只针对Lua做相关介绍，为什么是Lua，有过cocos2dx经验的朋友应该都知道Lua小，快，简单，而且比较大众化，而C++就不多多说了，大部分程序员都有畏惧心理，当然也有一些C++比较好，或者有独特爱好和专研朋友！</p></blockquote><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/cocos2dx/data/cocoslaunch001.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>关于其他平台基本上的流程和原理其实是一样的，可以直接参考！</p><a id="more"></a><h3 id="什么是Lua"><a href="#什么是Lua" class="headerlink" title="什么是Lua"></a>什么是Lua</h3><ul><li>百科:<ul><li>Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</li><li>Lua由标准C编写而成，几乎在所有操作系统和平台上都可以编译，运行。Lua并没有提供强大的库，这是由它的定位决定的。所以Lua不适合作为开发独立应用程序的语言。</li><li>Lua 有一个同时进行的JIT项目，提供在特定平台上的即时编译功能。</li></ul></li></ul><blockquote><p>很多应用程序、游戏使用LUA作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。这其中包括魔兽世界、博德之门、愤怒的小鸟、QQ三国、VOCALOID3、太阳神三国杀、游戏王ygocore等。</p></blockquote><h5 id="Cocos2d-lua，其实只是Cocos2d引擎添加了Lua绑定的版本。"><a href="#Cocos2d-lua，其实只是Cocos2d引擎添加了Lua绑定的版本。" class="headerlink" title="Cocos2d-lua，其实只是Cocos2d引擎添加了Lua绑定的版本。"></a>Cocos2d-lua，其实只是Cocos2d引擎添加了Lua绑定的版本。</h5><p>Cocos2d这里就不解释了，懒得拷贝，只是关于cocos创建和使用的时候需要注意的是</p><blockquote><p>cocos new TestProj -d Desktop/ -l lua，这里的引擎其实是同一套，只是创建工程时提供了不同语言的桥接层</p></blockquote><ul><li>使用C++语言和Cocos2d-x引擎进行开发时，我们写的代码是直接调用引擎的API的，因为引擎也是用C++语言编写，不需要进行语言转换</li><li>使用Lua语言和Cocos2d-x引擎进行开发时，我们写的代码通过LuaEngine执行，而LuaEngine封装了Cocos2d-x引擎的API，所以就相当于使用Lua脚本在调用Cocos2d-x的API了</li></ul><h3 id="各个平台的入口"><a href="#各个平台的入口" class="headerlink" title="各个平台的入口"></a>各个平台的入口</h3><h5 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h5><pre><code>#import &lt;UIKit/UIKit.h&gt;int main(int argc, char *argv[]) {    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];    int retVal = UIApplicationMain(argc, argv, nil, @&quot;AppController&quot;);    [pool release];    return retVal;}</code></pre><h5 id="Mac-OS"><a href="#Mac-OS" class="headerlink" title="Mac OS"></a>Mac OS</h5><pre><code>#import &lt;Cocoa/Cocoa.h&gt;int main(int argc, char *argv[]) {    return NSApplicationMain(argc, (const char **)argv);}</code></pre><h5 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h5><pre><code>int main(int argc,char *argv){    AppDelegate app;    return Application::getInstance()-&gt;run();}</code></pre><h5 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h5><pre><code>void cocos_android_app_init(JNIENV* env){    appDelegate.reset(new AppDelegate());    //新版本 : AppDelegate *pAppDelegate = new AppDelegate();}</code></pre><ul><li>Android启动流程概述<ul><li><ol><li>配置文件Manifest</li></ol></li><li><ol start="2"><li>AppActivity</li></ol></li><li><ol start="3"><li>onCreate</li></ol></li><li><ol start="4"><li>super.onCreate</li></ol></li><li><ol start="5"><li>onLoadNativeLibraries</li></ol></li><li><ol start="6"><li>System.loadLibrary(libName);</li></ol></li><li><ol start="7"><li>触发cocos_android_app_init（在main.cpp）中</li></ol></li><li><ol start="8"><li>再由库执行调用对应的Lua代码</li></ol></li><li>……</li></ul></li></ul><h5 id="由于笔者一直着力于iOS平台，所以这里以iOS为例，其他平台可参考："><a href="#由于笔者一直着力于iOS平台，所以这里以iOS为例，其他平台可参考：" class="headerlink" title="由于笔者一直着力于iOS平台，所以这里以iOS为例，其他平台可参考："></a>由于笔者一直着力于iOS平台，所以这里以iOS为例，其他平台可参考：</h5><h4 id="1-main函数入口"><a href="#1-main函数入口" class="headerlink" title="1. main函数入口"></a>1. main函数入口</h4><p>iOSApp中打开程序，加载完动态库，和一些必备的初始化和准备(rebase, bind,SetUp)之后,会回到main函数开始执行真正的程序代码</p><pre><code>int main(int argc, char *argv[]) {    @autoreleasepool {        return UIApplicationMain(argc, argv, nil, @&quot;AppController&quot;);    }}</code></pre><p>Main函数里面会调用UIApplicationMain， UIApplicationMain会一路走完这些流程</p><pre><code>+ 根据principalClassName传递的类名创建UIApplication对象+ 创建UIApplication代理对象，给UIApplication对象设置代理+ 开启主运行时间循环，处理事件，保持程序一直运行+ 加载info.plist，判断下是否指定了main，如果指定了，就会去加载</code></pre><p>我们可以看到这里设置的代理是AppController，然后看看AppController</p><h4 id="2-代理对象AppController"><a href="#2-代理对象AppController" class="headerlink" title="2. 代理对象AppController"></a>2. 代理对象AppController</h4><p>AppController里面有个    didFinishLaunchingWithOptions，这个是程序加载完毕的监听方法</p><pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {cocos2d::Application *app = cocos2d::Application::getInstance();// Initialize the GLView attributesapp-&gt;initGLContextAttrs();cocos2d::GLViewImpl::convertAttrs();// Override point for customization after application launch.// Add the view controller&apos;s view to the window and display.window = [[UIWindow alloc] initWithFrame: [[UIScreen mainScreen] bounds]];// Use RootViewController to manage CCEAGLView_viewController = [[RootViewController alloc]init];_viewController.wantsFullScreenLayout = YES;// Set RootViewController to windowif ( [[UIDevice currentDevice].systemVersion floatValue] &lt; 6.0){// warning: addSubView doesn&apos;t work on iOS6[window addSubview: _viewController.view];}else{// use this method on ios6[window setRootViewController:_viewController];}[window makeKeyAndVisible];[[UIApplication sharedApplication] setStatusBarHidden:true];// IMPORTANT: Setting the GLView should be done after creating the RootViewControllercocos2d::GLView *glview = cocos2d::GLViewImpl::createWithEAGLView((__bridge void *)_viewController.view);cocos2d::Director::getInstance()-&gt;setOpenGLView(glview);//run the cocos2d-x game sceneapp-&gt;run();return YES;}</code></pre><p>前面分别：获取Director，GLView设置GLView，最后执行run</p><h4 id="3-run-cocos2d-delegate"><a href="#3-run-cocos2d-delegate" class="headerlink" title="3. run cocos2d delegate"></a>3. run cocos2d delegate</h4><p>我们看看run方法里面，这里的run方法很关键，</p><pre><code>int Application::run(){    if (applicationDidFinishLaunching())    {        [[CCDirectorCaller sharedDirectorCaller] startMainLoop];    }    return 0;}</code></pre><p>有个applicationDidFinishLaunching，其实这里cocos2d默认的代理，在class中</p><h4 id="4-cocos2d配置，lua加载"><a href="#4-cocos2d配置，lua加载" class="headerlink" title="4. cocos2d配置，lua加载"></a>4. cocos2d配置，lua加载</h4><p>这里在coco2d的代理中，可以看到一堆的初始化配置和加载，然后就开始获取并执行脚本lua(通过lua脚本显示并处理Scene逻辑)</p><pre><code>bool AppDelegate::applicationDidFinishLaunching(){    // set default FPS    Director::getInstance()-&gt;setAnimationInterval(1.0 / 60.0f);    // register lua module    auto engine = LuaEngine::getInstance();    ScriptEngineManager::getInstance()-&gt;setScriptEngine(engine);    lua_State* L = engine-&gt;getLuaStack()-&gt;getLuaState();    lua_module_register(L);    register_all_packages();    LuaStack* stack = engine-&gt;getLuaStack();    stack-&gt;setXXTEAKeyAndSign(&quot;2dxLua&quot;, strlen(&quot;2dxLua&quot;), &quot;XXTEA&quot;, strlen(&quot;XXTEA&quot;));    //register custom function    //LuaStack* stack = engine-&gt;getLuaStack();    //register_custom_function(stack-&gt;getLuaState());    #if CC_64BITS        FileUtils::getInstance()-&gt;addSearchPath(&quot;src/64bit&quot;);    #endif        FileUtils::getInstance()-&gt;addSearchPath(&quot;src&quot;);        FileUtils::getInstance()-&gt;addSearchPath(&quot;res&quot;);        if (engine-&gt;executeScriptFile(&quot;main.lua&quot;))        {            return false;        }    return true;}</code></pre><h5 id="原生集成补充"><a href="#原生集成补充" class="headerlink" title="原生集成补充"></a>原生集成补充</h5><p>如果你是直接在原生嵌入而不是夸平台会看到这里其实是创建并返回Scene</p><pre><code>bool AppDelegate::applicationDidFinishLaunching() {    // initialize director    auto director = Director::getInstance();    auto glview = director-&gt;getOpenGLView();    if(!glview) {        glview = GLViewImpl::create(&quot;Fiction_Single&quot;);        director-&gt;setOpenGLView(glview);    }    // turn on display FPS    // director-&gt;setDisplayStats(true);    // set FPS. the default value is 1.0/60 if you don&apos;t call this    director-&gt;setAnimationInterval(1.0f / 60);    register_all_packages();    //SpriteFrameCache::getInstance()-&gt;removeSpriteFrames();    //SpriteFrameCache::getInstance()-&gt;removeUnusedSpriteFrames();    // create a scene. it&apos;s an autorelease object    // 初始化与运行主场景    auto scene = GameMainLayer::MainScene();    // 初始化与运行主场景    director-&gt;runWithScene(scene);    return true;}</code></pre><p>游戏逻辑就可以从这个Scene中的init函数开始，添加UI层，添加事件监听器，添加游戏层等等…如果我们有一些统计、资源管理器等，也可以在AppDelegate的applicationDidFinishLaunching函数中来进行。</p><h4 id="5-Lua脚本初始化"><a href="#5-Lua脚本初始化" class="headerlink" title="5. Lua脚本初始化"></a>5. Lua脚本初始化</h4><p>在这之前，我们先先看看，项目的配置文件config.json</p><pre><code>{    &quot;init_cfg&quot;:{       &quot;isLandscape&quot;: true,       &quot;isWindowTop&quot;: false,       &quot;name&quot;: &quot;MyDemo&quot;,       &quot;width&quot;: 960,       &quot;height&quot;: 640,       &quot;entry&quot;: &quot;src/main.lua&quot;,       &quot;consolePort&quot;: 6050,       &quot;uploadPort&quot;: 6060    },    &quot;simulator_screen_size&quot;: [        {            &quot;title&quot;: &quot;iPhone 3Gs (480x320)&quot;,            &quot;width&quot;: 480,            &quot;height&quot;: 320        },         ......    ]}</code></pre><blockquote><p>可以看到”entry”: “src/main.lua”,也就是说入口文件是main.lua，由此可以得知，即使我们不从iOS的启动流程来看，整个启动也会从这里开始，进入。</p></blockquote><h5 id="再来看”main-lua”，这个时候我们就开始开发查看main-lua文件"><a href="#再来看”main-lua”，这个时候我们就开始开发查看main-lua文件" class="headerlink" title="再来看”main.lua”，这个时候我们就开始开发查看main.lua文件"></a>再来看”main.lua”，这个时候我们就开始开发查看main.lua文件</h5><p>从MyApp开始，初始化，然后执行run运行程序</p><pre><code>cc.FileUtils:getInstance():setPopupNotify(false)require &quot;config&quot;require &quot;cocos.init&quot;local function main()    require(&quot;app.MyApp&quot;):create():run()endlocal status, msg = xpcall(main, __G__TRACKBACK__)if not status then    print(msg)end</code></pre><p>这里很重要的一个方法是run(),run()方法是设置启动View，执行main函数，main函数里加载MyApp创建并运行，进而打开MyApp.lua：</p><h4 id="6-MyApp-lua"><a href="#6-MyApp-lua" class="headerlink" title="6. MyApp.lua"></a>6. MyApp.lua</h4><p>我们看到MyApp仅仅是继承自AppBase，onCreate函数只是初始化了下随机数种子，也就意味着更多的操作在AppBase中，我们打开分析：</p><pre><code>local AppBase = class(&quot;AppBase&quot;)function AppBase:ctor(configs)    self.configs_ = {        viewsRoot  = &quot;app.views&quot;,        modelsRoot = &quot;app.models&quot;,        defaultSceneName = &quot;TitleScene&quot;,    }    for k, v in pairs(configs or {}) do        self.configs_[k] = v    end    if type(self.configs_.viewsRoot) ~= &quot;table&quot; then        self.configs_.viewsRoot = {self.configs_.viewsRoot}    end    if type(self.configs_.modelsRoot) ~= &quot;table&quot; then        self.configs_.modelsRoot = {self.configs_.modelsRoot}    end    if DEBUG &gt; 1 then        dump(self.configs_, &quot;AppBase configs&quot;)    end    if CC_SHOW_FPS then        cc.Director:getInstance():setDisplayStats(true)    end    -- event    self:onCreate()endfunction AppBase:run(initSceneName)    initSceneName = initSceneName or self.configs_.defaultSceneName    self:enterScene(initSceneName)endfunction AppBase:enterScene(sceneName, transition, time, more)    local view = self:createView(sceneName)    view:showWithScene(transition, time, more)    return viewendfunction AppBase:createView(name)    for _, root in ipairs(self.configs_.viewsRoot) do        local packageName = string.format(&quot;%s.%s&quot;, root, name)        local status, view = xpcall(function()                return require(packageName)            end, function(msg)            if not string.find(msg, string.format(&quot;&apos;%s&apos; not found:&quot;, packageName)) then                print(&quot;load view error: &quot;, msg)            end        end)        local t = type(view)        if status and (t == &quot;table&quot; or t == &quot;userdata&quot;) then            return view:create(self, name)        end    end    error(string.format(&quot;AppBase:createView() - not found view \&quot;%s\&quot; in search paths \&quot;%s\&quot;&quot;,        name, table.concat(self.configs_.viewsRoot, &quot;,&quot;)), 0)endfunction AppBase:onCreate()endreturn AppBase</code></pre><p>在前面的分析中知道main.lua是执行的是App的run函数，作为基类的AppBase，当然也要被调用run函数，因此直接看run函数：主要是创建并进入场景initSceneName，如果run的参数没有指定开始的场景则使用默认场景defaultSceneName，默认场景在构造函数的时候被初始化为MainScene，也就是说场景默认将从MainScene开始。</p><h4 id="7-指定Scene"><a href="#7-指定Scene" class="headerlink" title="7. 指定Scene"></a>7. 指定Scene</h4><p>如果想指定启动，而不是使用默认的Scene，那么项目启动后会直接进入该场景，这点有个好处是如果要调试设计某场景可以直接从这个场景进入，不必从其他场景进入了。</p><pre><code>local function main()    require(&quot;app.MyApp&quot;):create():run(&quot;StartScene&quot;)end</code></pre><p>默认不设置会选择MainScene，如果仔细再AppBase里面会看到这样一行代码</p><pre><code>function AppBase:ctor(configs)self.configs_ = {    viewsRoot  = &quot;app.views&quot;,    modelsRoot = &quot;app.models&quot;,    defaultSceneName = &quot;MainScene&quot;,}.....</code></pre><blockquote><p> 那么项目启动后会直接进入StartScene场景，而不再是默认的MainScene场景。</p></blockquote><h4 id="8-根据脚本指定Scene，"><a href="#8-根据脚本指定Scene，" class="headerlink" title="8. 根据脚本指定Scene，"></a>8. 根据脚本指定Scene，</h4><p>上面说了，如果没有设置就会试着用默认的Scene，run里面的逻辑就是去真正指定Scene，</p><pre><code>-- 创建完对象之后，就到了这一步function AppBase:run(initSceneName)    initSceneName = initSceneName or self.configs_.defaultSceneName    self:enterScene(initSceneName)  -- 如果没有指定第一个Scene，则第一个Scene为MainSceneend-- 生成并进入第一个Scenefunction AppBase:enterScene(sceneName, transition, time, more)    local view = self:createView(sceneName)     -- 前去生成View    view:showWithScene(transition, time, more)  -- 因为MainScene继承自ViewBase类，这里就吊用ViewBase的方法了    return viewend</code></pre><blockquote><p>建议仔细读一下AppBase，ViewBase！</p></blockquote><h4 id="9-自定义Scene-StartScene"><a href="#9-自定义Scene-StartScene" class="headerlink" title="9. 自定义Scene(StartScene)"></a>9. 自定义Scene(StartScene)</h4><p>这个时候就会首先从StartScene开始，</p><pre><code>local StartScene = class(&quot;StartScene&quot;, cc.load(&quot;mvc&quot;).ViewBase)function StartScene:onCreate()    display.newSprite(&quot;HelloWorld.png&quot;)    :move(display.center)    :addTo(self)    cc.Label:createWithSystemFont(&quot;cocos2dx Run StartScene&quot;, &quot;Arial&quot;, 60)    :move(display.cx, display.cy + 200)    :addTo(self)endreturn StartScene</code></pre><h4 id="然后后面步骤就是从StartScene开始，写脚本代码，处理UI，网络和逻辑等，"><a href="#然后后面步骤就是从StartScene开始，写脚本代码，处理UI，网络和逻辑等，" class="headerlink" title="然后后面步骤就是从StartScene开始，写脚本代码，处理UI，网络和逻辑等，"></a>然后后面步骤就是从StartScene开始，写脚本代码，处理UI，网络和逻辑等，</h4><p>到这里就基本上完成cocos2dx Lua启动流程，其他C++,JS原理和流程其实都差不多, 只是执行的方法或者代码不一样而已</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实关于coocs2dx之前的版本我不了解，就我目前了解到的，其实就是由通用程序入口到跨平台程序入口</p><p>基本的流程如下</p><ul><li>初始化Director</li><li>新建GLView，然后进行一些设置</li><li>新建Scene</li><li>使用Director运行这个场景</li></ul><hr><pre><code>bool AppDelegate::applicationDidFinishLaunching()//程序入口 -&gt; 跨平台程序入口{    auto director = Director::getInstance();    auto glview = director-&gt;getOpenGLView();    if(!glview)    {        glview = GLViewImpl::create(&quot;my test&quot;);        director-&gt;setOpenGLView(glview);    }    //初始化、资源适配、屏幕适配、运行第一个场景...    glview-&gt;setDesignResolutionSize();    auto scene = Hellow::scene();    director-&gt;runWithScene(scene);    return scene;}</code></pre><blockquote><p>通过上面我们其实可以知道，cocos2d_lua_bindings库提供了Lua对Cocos2d引擎的绑定，相当于通过注册Module的方式对Cocos2d引擎提供的（相关的）API进行了一次封装（把常用的功能封装成一个函数newScene）。</p></blockquote><p>相对于Cocos2d-x C++工程来说，Cocos2d-x生成的Lua语言工程提供了对Cocos2d引擎的Lua语言封装。将Cocos2d引擎API绑定到对应的Lua语言函数，在调用到这些函数时，会执行对应的Cocos2d引擎API, 其实最终还是调用的C++代码和对应的引擎代码。</p><h3 id="跨平台原理"><a href="#跨平台原理" class="headerlink" title="跨平台原理"></a>跨平台原理</h3><blockquote><ol><li>AppDelegate 作为跨平台程序入口，在这之上做了另一层的封装，封装了不同平台的不同实现。比如我们通常认为一个程序是由 main 函数开始运行，那我们就去找寻，我们看到了在 proj.linux 目录下存在 main.cpp 文件。</li></ol></blockquote><blockquote><ol start="2"><li>在main.cpp 中 CCApplication::sharedApplication()–&gt;run(); 这一句看起，这一句标志着， cocos2d-x 程序正式开始运行.</li></ol></blockquote><blockquote><ol start="3"><li>定位到 sharedApplication() 方法的实现，在CCAplication类中我们可以看到从 sharedApplication() 方法，在调用 run() 方法，在这之前，我们需要调用到它的构造函数，否则不能运行，这就是为什么在 CCApplication::sharedApplication()–&gt;run(); 之前，我们首先有语句 AppDelegate app; <blockquote><p>创建 AppDelegate 变量的原因是 AppDelegate 是 CCApplication 的子类，在创建子类对象的时候，调用其构造函数的同时，父类构造函数也会执行，然后就将 AppDelegate 的对象赋给了 CCApplication 的静态变量，而在 AppDelegate 之中我们实现了 applicationDidFinishLaunching方法，所以在 CCApplication 中 run 方法的开始处调用的就是 AppDelegate 之中的实现。</p></blockquote></li></ol></blockquote><blockquote><ol start="3"><li>我们在此方法中我们初始化了一些变量，创建了第一个 CCScene 场景等，之后的控制权，便全权交给了CCDirector::sharedDirector()–&gt;mainLoop(); 方法了。</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/cocos2dx/data/cocoalaunch002.jpg" alt="曹理鹏(iCocos)-梦工厂"></p><ul><li><p>在cocos2d-x的文件夹下，有一个platform文件夹，里面存放了跨平台的封装接口。</p></li><li><p>当前目录下有CCApplicationProtocol.h头文件，子目录有win32,Android,IOS三个文件夹，里面分别存放跨平台需要的函数，其中包括CCApplication。</p></li><li><p>而AppDelegate 类则是继承自CCApplication。CCApplication又继承自CCApplicationProtocol。</p></li><li><p>在CCApplicationProtocol中定义了applicationDidFinishLaunching虚方法,由CCApplication 继承， AppDelegate 实现的。以此实现了跨平台。</p></li></ul><blockquote><p>为了充分发挥硬件性能，手机游戏通常使用Native App开发模式，这就造成开发商要为iOS 和Android平台用户开发不同的应用，无论是产品迭代还是运行维护都非常麻烦。</p></blockquote><p>Cocos2d-x在iOS，Android等移动平台之上，封装了一层C++接口，从而屏蔽了平台的差异性，通过平台宏来控制使用哪个平台的代码，向开发者提供C++接口调用。这些接口主要包括UI、事件和网络，封装UI主要是使用OpenGL ES的接口来写UI，封装事件和网络，均是使用C++接口对原生接口进行一层封装。</p><h4 id="其实对应cocos2dx跨平台在说，我们这么理解就可以了"><a href="#其实对应cocos2dx跨平台在说，我们这么理解就可以了" class="headerlink" title="其实对应cocos2dx跨平台在说，我们这么理解就可以了"></a>其实对应cocos2dx跨平台在说，我们这么理解就可以了</h4><ul><li>Lua底层是通过C编写实现的</li><li>Android通过JNI技术调用C</li><li>iOS也是完全兼容C语言</li></ul><h5 id="我们打开对应的工程可以看到"><a href="#我们打开对应的工程可以看到" class="headerlink" title="我们打开对应的工程可以看到"></a>我们打开对应的工程可以看到</h5><ul><li><p>Java项目中，有些关于Lua的文件，</p><ul><li>luajava.jar是Java代码封装包，</li><li>libluajava-1.1.so在底层封装了.C 文件，实现了lua相关底层功能。</li></ul></li><li><p>但是在iOS项目中，我们发现</p><blockquote><p>iOS允许开发者使用C语言文件和objective-c文件混合编程。但是，如果你在Objective-C的代码中调用C文件中的函数，你不能直接将.c文件import到你的OC文件中，这样是不起作用的。你需要先创建一个.h 头文件 里面包含你的函数申明，同时将这个.h 头文件import到.c文件中，.c文件负责实现要调用的函数。最后将你新创建的.h头文件import到OC文件中，这样你就可以在OC的文件中调用C的方法了</p></blockquote></li><li><p>具体更多启动相关细节，可以参考这里</p><ul><li><a href="https://www.jianshu.com/p/781d835c88c9" target="_blank" rel="noopener">https://www.jianshu.com/p/781d835c88c9</a></li><li><a href="http://www.cocos2d-x.org/docs/cocos2d-x/zh/about/learn.html" target="_blank" rel="noopener">http://www.cocos2d-x.org/docs/cocos2d-x/zh/about/learn.html</a></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> cocos2dx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocos2dx </tag>
            
            <tag> 游戏 </tag>
            
            <tag> cocos2dx——项目启动流程与跨平台原理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS(OC+cocos2dx)游戏APP磁盘空间爆增(文稿与数据)</title>
      <link href="/2018/08/16/iOS-OC-cocos2dx-%E6%B8%B8%E6%88%8FAPP%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E7%88%86%E5%A2%9E-%E6%96%87%E7%A8%BF%E4%B8%8E%E6%95%B0%E6%8D%AE/"/>
      <url>/2018/08/16/iOS-OC-cocos2dx-%E6%B8%B8%E6%88%8FAPP%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E7%88%86%E5%A2%9E-%E6%96%87%E7%A8%BF%E4%B8%8E%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<p>这段时间在开发公司的新产品二次元游戏(<a href="https://zhongchou.modian.com/item/26767.html?_ga=2.202445201.1279037149.1534326302-1820221530.1531384229" target="_blank" rel="noopener">零下记忆</a>)，由于接触coco2dx不久，很多东西还在摸索，也没少加班，所以都没有时间整理和发文了。</p><p>但是最近(从周一开始),发现了一个特别其他的Bug，App磁盘数据报增，幸好我手机是64G的，不然估计会爆炸！</p><a id="more"></a><p>先来张爆图！</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/cocos2dx/data/cocos2dx_data001.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>这个产品是在Objective-C原生架构的基础上接入cocos2dx(C++)，所以导致部分文件或者类需要使用MRC模式。</p><h5 id="我曾尝试过"><a href="#我曾尝试过" class="headerlink" title="我曾尝试过"></a>我曾尝试过</h5><ol><li>使用模拟器针对不同时段操作，计算沙盒文件大小。</li><li>借助部门同事的越狱机导包寻找导致爆增的具体文件。</li><li>多次删除App，关闭可能存在问题原因的代码。</li><li>借助内存泄漏框架自动记录，内存变化与位置。</li><li>借助Xcode自带Instrument定点查找具体位置和代码。</li><li>通过Stack Overflow查询更多可能导致的原因。</li></ol><p>经过一次次排查，和一个个问题的处理，最终通过多次杀进程，和运行测试，终于处理完成，不过还有待优化！ </p><h6 id="下面是具体原因和流程。"><a href="#下面是具体原因和流程。" class="headerlink" title="下面是具体原因和流程。"></a>下面是具体原因和流程。</h6><h3 id="清理缓存："><a href="#清理缓存：" class="headerlink" title="清理缓存："></a>清理缓存：</h3><h5 id="清理cocos2dx缓存："><a href="#清理cocos2dx缓存：" class="headerlink" title="清理cocos2dx缓存："></a>清理cocos2dx缓存：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CCAnimationCache::purgeSharedAnimationCache();</span><br><span class="line">CCSpriteFrameCache::purgeSharedSpriteFrameCache();</span><br><span class="line">CCTextureCache::purgeSharedTextureCache();</span><br><span class="line">    </span><br><span class="line">CCSpriteFrameCache::sharedSpriteFrameCache()-&gt;removeUnusedSpriteFrames();</span><br><span class="line">CCTextureCache::sharedTextureCache()-&gt;removeUnusedTextures();</span><br><span class="line">CCTextureCache::sharedTextureCache()-&gt;removeAllTextures();</span><br><span class="line"></span><br><span class="line">Director::getInstance()-&gt;getTextureCache()-&gt;removeAllTextures();</span><br></pre></td></tr></table></figure><h5 id="清理运行磁盘，内存或者缓存"><a href="#清理运行磁盘，内存或者缓存" class="headerlink" title="清理运行磁盘，内存或者缓存"></a>清理运行磁盘，内存或者缓存</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">+ (void)clearAllCache &#123;</span><br><span class="line">    [[SDImageCache sharedImageCache] clearMemory];</span><br><span class="line">    [[SDImageCache sharedImageCache] clearDiskOnCompletion:nil];</span><br><span class="line">    // 拿到cachePath路径的下一级目录的子文件夹</span><br><span class="line">    // contentsOfDirectoryAtPath:error:递归</span><br><span class="line">    // subpathsAtPath:不递归</span><br><span class="line">    NSArray *subpathArray = [fileManager contentsOfDirectoryAtPath:cachePath error:nil];</span><br><span class="line">    // 如果数组为空，说明没有缓存或者用户已经清理过，此时直接<span class="built_in">return</span></span><br><span class="line">    <span class="keyword">if</span> (subpathArray.count == 0) &#123;</span><br><span class="line"><span class="comment">#ifdef DEBUG</span></span><br><span class="line">        NSLog(@<span class="string">"cachePath缓存清理完成"</span>);</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">    &#125;</span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    NSString *filePath = nil;</span><br><span class="line">    BOOL flag = NO;</span><br><span class="line">    <span class="keyword">for</span> (NSString *subpath <span class="keyword">in</span> subpathArray) &#123;</span><br><span class="line">        filePath = [cachePath stringByAppendingPathComponent:subpath];</span><br><span class="line">        <span class="keyword">if</span> ([fileManager fileExistsAtPath:cachePath]) &#123;</span><br><span class="line">            // 删除子文件夹</span><br><span class="line">            BOOL isRemoveSuccessed = [fileManager removeItemAtPath:filePath error:&amp;error];</span><br><span class="line">            <span class="keyword">if</span> (isRemoveSuccessed) &#123; // 删除成功</span><br><span class="line">                flag = YES;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (NO == flag) &#123;</span><br><span class="line"><span class="comment">#ifdef DEBUG</span></span><br><span class="line">        NSLog(@<span class="string">"已经清理了所有可以访问的文件,不可访问的文件无法删除"</span>);  // 调试阶段才打印</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>记忆中此处大概处理了1-3G</p></blockquote><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>通过Stack Overflow和相应代码调试最后发现：</p><blockquote><p>原来是把sprite和控件都retain了，需要手动release，才能释放图片。</p></blockquote><p>所以我得找到对应的cocos2dx项目代码，对创建和操作的对象进行release操作，这里比较蛋疼，得一个个找！</p><ul><li>处理中遇到个问题：<ul><li>removeTexture执行release后，不管有没有被gl释放掉，都从列表里删除。</li></ul></li></ul><p>但是如果load进来的node被addChild到场景中，应该是不需要retain的，addChild会自动retain，这里不清楚，cocos2dx引擎设计者在load里加retain是为了什么，</p><blockquote><p>这里所导致的问题，几乎是使用过程中内存暴涨</p></blockquote><h3 id="环境与配置-主要原因"><a href="#环境与配置-主要原因" class="headerlink" title="环境与配置(主要原因):"></a>环境与配置(主要原因):</h3><p>通过多次测试发现沙盒文件中的temp中有一堆文件stack-logs.xxxxx.index</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/cocos2dx/data/cocos2dx_data002.png" alt="曹理鹏(iCocos)-梦工厂"></p><ul><li>同时控制台也打印了一大堆看不懂也搜不到的内容</li></ul><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/cocos2dx/data/cocos2dx_data003.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>结合以上几点才初步猜测可能是因为配置环境的问题，查阅资料后发现这与Xcode设置有关,具体配置原因我也不记得了，印象中是当时配置接入cocos2dx的时候，遇到了一些问题，点过了一次，但是现在想想好像当时的操作并没有什么卵用！</p><ul><li>Edit Scheme中Diagnostics有个logging分类，下面有个Malloc Stack选项，将勾选取消。</li></ul><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/cocos2dx/data/cocos2dx_data004.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>处理完后立刻验证了一下,重装App,多次执行杀进程和实际测试用，在tmp下并没有产生那个文件stack-logs.xxxxx.index,磁盘占用也处于稳定状态,再打开手机设置查看存储空间，也很正常。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/cocos2dx/data/cocos2dx_data005.png" alt="曹理鹏(iCocos)-梦工厂"></p><blockquote><p>以上文稿与数据的15.7中有13M多属于App下载的资源文件。</p></blockquote><p>That’s all for today.</p>]]></content>
      
      <categories>
          
          <category> iOS游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS(OC+cocos2dx)游戏APP磁盘空间爆增(文稿与数据) </tag>
            
            <tag> iOS游戏 </tag>
            
            <tag> 磁盘管理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>游戏引擎——cocos2dx入门</title>
      <link href="/2018/08/09/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94cocos2dx%E5%85%A5%E9%97%A8/"/>
      <url>/2018/08/09/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94cocos2dx%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Cocos2d-x是一个开源的移动2D游戏框架，MIT许可证下发布的。这是一个C++ Cocos2d-iPhone项目的版本。Cocos2d-X发展的重点是围绕Cocos2d跨平台，Cocos2d-x提供的框架。</p><blockquote><p>手机游戏，可以写在C++或者Lua中，使用API是Cocos2d-iPhone完全兼容。Cocos2d-x项目可以很容易地建立和运行在iOS，Android，黑莓Blackberry等操作系统中。</p></blockquote><blockquote><p>Cocos2d-x还支持Windows、Mac和Linux等桌面操作系统，因此，开发者编写的源代码很容易在桌面操作系统中编辑和调试。</p></blockquote><h4 id="cocos2dx-与-UNITY3D"><a href="#cocos2dx-与-UNITY3D" class="headerlink" title="cocos2dx 与 UNITY3D"></a>cocos2dx 与 UNITY3D</h4><a id="more"></a><p>一、区别:</p><ul><li>1、COCOS2D开源,有文档支持,论坛资料庞杂博大；UNITY3D闭源,有强大的文档支持,论坛资料一样的庞杂博大。</li><li>2、COCOS2D免费；UNITY3D收费。</li><li>3、COCOS2D的跨平台,需要大量重写代码；UNITY3D的跨平台,程序员只需要选选按钮就淡定许多的搞定了。</li></ul><p>二、拓展:</p><ul><li>1、不同:<ul><li>COCOS2D拥有令人发指的可定制性；UNITY3D有一个专门为订制而写的类库。</li></ul></li><li>2、相同:<ul><li>UNITY3D和 COCOS2D-X都是跨平台的游戏开发引擎。</li></ul></li></ul><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>现代化的 C++ API</li><li>立足于 C++ 同时支持 JavaScript/Lua 作为开发语言</li><li>可以跨平台部署, 支持 iOS、Android、Windows、macOS 和 Linux</li><li>可以在 PC 端完成游戏的测试，最终发布到移动端</li><li>完善的游戏功能支持，包含精灵、动作、动画、粒子特效、场景转换、事件、文件 IO、数据持久化、骨骼动画、3D</li></ul><h4 id="家族成员"><a href="#家族成员" class="headerlink" title="家族成员"></a>家族成员</h4><blockquote><p>cocos2d是一个基于MIT协议的开源框架，用于构建游戏、应用程序和其他图形界面交互应用。可以让你在创建自己的多平台游戏时节省很多的时间。</p></blockquote><h6 id="Cocos2d-html5-："><a href="#Cocos2d-html5-：" class="headerlink" title="Cocos2d-html5 ："></a>Cocos2d-html5 ：</h6><ul><li>Cocos2d-HTML5 是基于 HTML5 规范集的 Cocos2d引擎分支，具有跨平台的能力和强大的性能，是 Cocos2d 系列引擎随着互联网技术演进而产生的一个分支，该分支基于 HTML5 规范集，目标是可对游戏进行跨平台部署，Cocos2d-HTML5 采用 MIT 开源协议，设计上保持Cocos2d家族的传统架构，并可联合 Cocos2d-x JavaScript-binding 接口，最大程度地实现游戏代码在不同平台上的复用。</li></ul><h6 id="JSB-："><a href="#JSB-：" class="headerlink" title="JSB ："></a>JSB ：</h6><ul><li>Cocos2d-x JavaScript-binding 是使用 SpiderMonkey 引擎实现 C++ 接口到 JavaSciprt 的绑定方案，它可以使用 Js 快速开发游戏，以更简单的语法实现功能，并且能与 Cocos2D-HTML5 相互兼容，使同一套代码，运行两个平台，这是相比使用 Lua 实现的一个明显优势。</li></ul><h6 id="Cocos-Studio-："><a href="#Cocos-Studio-：" class="headerlink" title="Cocos Studio ："></a>Cocos Studio ：</h6><ul><li>Cocos Studio 是一套基于 Cocos2d-x 引擎的工具集，包括 UI编辑器，动画编辑器，场景编辑器和数据编辑器。 UI 编辑器和动画编辑器主要面向美术，而场景编辑器和数据编辑器则面向游戏策划，这四个工具合在一起构成了一套完整的游戏开发体系，帮助开发者进一步降低开发难度，提高开发效率，减少开发成本。</li></ul><p>Cocos2d也拥有几个主要版本，包括Cocos2d-iPhone、Cocos2d-X，以及被社区普遍看好的Cocos2d-HTML5和JavaScript bindings for Cocos2d-X。</p><h4 id="关于lua，c-，JS"><a href="#关于lua，c-，JS" class="headerlink" title="关于lua，c++，JS"></a>关于lua，c++，JS</h4><p>允许开发人员使用 C++、Javascript 及 Lua 三种语言来进行游戏开发。</p><blockquote><p>支持所有常见平台，包括 iOS、Android、Windows、macOS、Linux。</p></blockquote><ol><li><p>运行效率：</p><blockquote><p>Lua 的性能在各种测试里都比 JavaScript 快不少。而移动设备上存在不支持 JIT 的情况（未越狱的 iOS 设备），Lua 对比 JavaScript 的性能优势就更明显。</p></blockquote></li><li><p>安全性：</p><blockquote><p>现在 cocos2d-x 使用 LuaJIT 来执行 Lua，所以可以把 Lua 代码编译为字节码再打包到游戏里。由于 LuaJIT 的字节码是高度优化过的，所以目前还没有反编译工具。而 JS 虽然也可以用字节码，但从目前的情况看还达不到 LuaJIT 的安全性。</p></blockquote></li><li><p>与 C/C++ 的交互：</p><blockquote><p>Lua 原本就是作为嵌入式语言来设计的，所以天然和 C/C++ 很容易交互。JS 这方面是个劣势。</p></blockquote></li><li><p>与 Java/Objective-C 的交互：</p><blockquote><p>不管是 quick-cocos2d-x 里提供的 luaoc/luaj 模块，还是 wax, luajava 这些开源项目，都让我们可以绕过 C/C++ 层实现 Lua 和 Java/Objc 的交互。这个优势在游戏发行阶段，集成各种第三方 SDK 时绝对会节约巨量时间！！！</p></blockquote></li></ol><p>游戏是非常消耗资源的每时每刻都要大量的计算，</p><ul><li>假如有个方法 让 C语言来实现 并且把它完成的时间定义为 1个单位 的时间</li><li>那么同样的数据结构的方法在其他语言中     <ul><li>java 需要 8个单位       </li><li>lua需要30个单位       </li><li>python需要200个单位       </li><li>php需要462个单位       </li><li>javascript需要621个单位</li></ul></li></ul><p>所以在需要大量计算的环节，代码的结构时间复杂度比较高的 情况下用 C++（肯没直接用C快，但一定比java快）来写，   现在的CPU计算能力都还是蛮高的，所以没必要完全用C++ ，用一些其他的语言开发速度可以大大加快。 </p><h6 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h6><ul><li>项目不需要热更新的时候用c++</li><li>lua，c++都可以用的时候c++更熟悉的用c++</li><li>c++效率比lua高</li><li>lua项目的底层框架还是要c++搭比较好</li><li>c++老司机转其他语言比较轻松。</li></ul><p>最终使用那种方式还是需要结合个人，语言，需求，性能综合考虑</p><ul><li>当然，cocos2d-x 目前明显是在主推 JS 的解决方案，因为 JS 可以跨越移动设备、桌面的界限，实现一套程序跑任意平台。不过我个人认为以当前 HTML5 的发展情况，对于要强调体验的游戏来说，HTML5 还要一些时间。</li></ul><blockquote><p>网友评价：<br>前面提到 JS 更容易面向对象，我想可能是因为大家对 Lua 还不够了解造成的错觉。实际上，Lua 和 JS 实现面向对象的机制几乎是一样的。JS 基于 prototype，Lua 基于 metatable，在我看来仅仅是名字不同而已。</p></blockquote><p>从目前的市场情况来说，Lua 明显是更理性的选择：成熟、安全性高、众多大作采用。</p><ul><li>推荐<ul><li>官方文档：<a href="http://www.cocos2d-x.org/docs/cocos2d-x/zh/about/learn.html" target="_blank" rel="noopener">http://www.cocos2d-x.org/docs/cocos2d-x/zh/about/learn.html</a></li><li>OC/Swift - C++交互与混编:<a href="http://edu.51cto.com/center/course/lesson/index?id=57316" target="_blank" rel="noopener">http://edu.51cto.com/center/course/lesson/index?id=57316</a></li><li>入门实战-飞机大战游戏：<a href="http://www.maiziedu.com/course/662-9914/" target="_blank" rel="noopener">http://www.maiziedu.com/course/662-9914/</a></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> cocos2dx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocos2dx </tag>
            
            <tag> 游戏 </tag>
            
            <tag> 游戏引擎——cocos2dx入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL拓展(extend)</title>
      <link href="/2018/07/28/MySQL%E6%8B%93%E5%B1%95(extend)/"/>
      <url>/2018/07/28/MySQL%E6%8B%93%E5%B1%95(extend)/</url>
      <content type="html"><![CDATA[<h3 id="一、分区表的原理"><a href="#一、分区表的原理" class="headerlink" title="一、分区表的原理"></a>一、分区表的原理</h3><blockquote><p>对用户来说，分区表是一个独立的逻辑表，但是底层mysql将其分成了多个物理的子表，这对用户来说是透明的，每一个分区表都会使用一个独立的表文件。  </p></blockquote><h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h5><blockquote><p>创建表的时候通过partition by子句定义每个分区存放的数据，执行查询的时候，优化器会根据分区定义过滤那些没有我们需要数据的分区，这样查询只查询所需的数据所在分区</p></blockquote><p>分区的主要目的是将数据按照一个比较粗的粒度分在不同的表中，这样可以将相关的数据存放在一起，而且要一次删除整个分区也十分方便</p><a id="more"></a><h6 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h6><ol><li>表非常大，无法全部存在内存，或者只在表的最后有热点数据，其他都是历史数据  </li><li>分区表的数据更易维护，可以对独立的分区进行独立的操作  </li><li>分区表的数据可以分布在不同的机器上，从而高效的使用资源</li></ol><h3 id="二、分库分表的原理"><a href="#二、分库分表的原理" class="headerlink" title="二、分库分表的原理"></a>二、分库分表的原理</h3><blockquote><p>通过一些HASH算法或者工具将一张数据表垂直或者水平的进行物理切分</p></blockquote><h6 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h6><ol><li>单表数据达到百万甚至千万的级别</li><li>解决表锁的问题</li></ol><h4 id="水平分割"><a href="#水平分割" class="headerlink" title="水平分割"></a>水平分割</h4><p>此时表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询效率  </p><h6 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h6><ol><li>表中的数据有独立性，例如表中记录各个地区或各个时间段的数据，有些数据常用，有些数据不常用 </li><li>需要把数据存放在多个介质上  </li></ol><h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><ol><li>给应用增加复杂度，通常查询需要多个表名，查询所有的数据都需要union操作</li></ol><h4 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h4><p>将主键和一些列放在一张表，然后把主键和其他列放在另外一张表  </p><h6 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h6><ol><li>表中一些列常用，一些列不常用  </li><li>可以使数据行变小，一个数据页能存储更多的数据，减少查询I/O次数</li></ol><h6 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h6><ol><li>管理冗余列，查询所有的数据都需要join操作</li></ol>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nginx负载均衡入门</title>
      <link href="/2018/07/24/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%85%A5%E9%97%A8/"/>
      <url>/2018/07/24/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>负载均衡（Load Balance）其意思就是分摊到多个操作单元上进行执行，从而共同完成工作任务。通过核心调度者，保证所有后端服务器都将性能充分发挥，从而保持服务器集群的整体性能最优。</p><a id="more"></a><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ol><li><p>[加权]随机算法</p><p> 通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。可以按后端机器的配置设置随机概率的权重。调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</p></li><li><p>[加权]轮询算法</p><p> 将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。可以按后端机器的配置为轮询中的服务器附加一定权重的算法。比如服务器1权重1，服务器2权重2，服务器3权重3，则顺序为1-2-2-3-3-3-1-2-2-3-3-3- ……</p><p> 当服务器群中各服务器的处理能力相同时，且每笔业务处理量差异不大时，最适合使用这种算法。 </p></li><li><p>[加权]最小连接算法</p><p> 在多个服务器中，与处理连接数(会话数)最少的服务器进行通信的算法。由于后端服务器的配置不尽相同，对于请求的处理有快有慢，最小连接数法根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</p><p> 可以事先为每台服务器分配处理连接的数量，并将客户端请求转至连接数最少的服务器上。</p></li><li><p>源地址哈希法</p><p> 根据获取客户端的IP地址，通过哈希函数计算得到一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，相同的IP客户端，如果服务器列表不变，将映射到同一个后台服务器进行访问。</p><p> 当客户端有一系列业务需要处理而必须和一个服务器反复通信时，该算法能够以流(会话)为单位，保证来自相同客户端的通信能够一直在同一服务器中进行处理。</p></li></ol><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># server1</span><br><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    server_name local.load.com;</span><br><span class="line">    index index.html;</span><br><span class="line">    root /home/www;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Load Balance</span><br><span class="line">upstream load.com.conf &#123;</span><br><span class="line">    server 192.168.1.101:80;</span><br><span class="line">    server 192.168.1.102:80;</span><br><span class="line">    server 127.0.0.1:8080;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"># web server</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name local.load.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass              http://load.com.conf;</span><br><span class="line">        #proxy_set_header        Host    $host;</span><br><span class="line">        #proxy_set_header        X-Real-IP       $remotr_addr;</span><br><span class="line">        #proxy_set_header        X-Forwarde-For  $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># server2 192.168.1.101</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name local.load.com;</span><br><span class="line">    root /home/www;</span><br><span class="line">    location / &#123;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># server3 192.168.1.102</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name local.load.com;</span><br><span class="line">    root /home/www;</span><br><span class="line">    location / &#123;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="详细配置"><a href="#详细配置" class="headerlink" title="详细配置"></a>详细配置</h3><p>轮询模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream load.com.conf &#123;</span><br><span class="line">   server 192.168.0.1;</span><br><span class="line">   server 192.168.0.2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加权轮询模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream load.com.conf &#123;</span><br><span class="line">   server 192.168.0.1 weight=3;</span><br><span class="line">   server 192.168.0.2 weight=2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源地址哈希法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream load.com.conf &#123;</span><br><span class="line">   ip_hash;</span><br><span class="line">   server 192.168.0.1 weight=3;</span><br><span class="line">   server 192.168.0.2 weight=2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fair（第三方）：按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream load.com.conf &#123;  </span><br><span class="line">  server server1;  </span><br><span class="line">  server server2;  </span><br><span class="line">  fair;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>url_hash（第三方）：按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</p><p>例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream load.com.conf &#123;  </span><br><span class="line">  server squid1:3128;  </span><br><span class="line">  server squid2:3128;  </span><br><span class="line">  hash $request_uri;  </span><br><span class="line">  hash_method crc32;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">upstream bakend &#123;</span><br><span class="line">  ip_hash;  </span><br><span class="line">  server 127.0.0.1:9090 down;  </span><br><span class="line">  server 127.0.0.1:8080 weight=2;  </span><br><span class="line">  server 127.0.0.1:6060;  </span><br><span class="line">  server 127.0.0.1:7070 backup;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要使用负载均衡的server中增加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_pass http://bakend/;</span><br></pre></td></tr></table></figure><p>每个设备的状态设置为：</p><ul><li>down 表示单前的server暂时不参与负载 </li><li>weight 默认为1.weight越大，负载的权重就越大。 </li><li>max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误 </li><li>fail_timeout:max_fails次失败后，暂停的时间。 </li><li>backup： 其它所有的非backup机器down或者忙的时候，请求backup</li></ul>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Nginx </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL索引与优化(explain)</title>
      <link href="/2018/07/17/MySQL%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BC%98%E5%8C%96(explain)/"/>
      <url>/2018/07/17/MySQL%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BC%98%E5%8C%96(explain)/</url>
      <content type="html"><![CDATA[<h3 id="一、-创建索引"><a href="#一、-创建索引" class="headerlink" title="一、 创建索引"></a>一、 创建索引</h3><h5 id="1-普通索引-最基本的索引，无任何限制"><a href="#1-普通索引-最基本的索引，无任何限制" class="headerlink" title="1.普通索引(最基本的索引，无任何限制)"></a>1.普通索引(最基本的索引，无任何限制)</h5><p>(1)创建索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name ON table(column(length))</span><br></pre></td></tr></table></figure></p><p>(2)删除索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX index_name ON table</span><br></pre></td></tr></table></figure></p><a id="more"></a><h5 id="2-唯一索引（索引列的值必须唯一，但允许有空值）"><a href="#2-唯一索引（索引列的值必须唯一，但允许有空值）" class="headerlink" title="2.唯一索引（索引列的值必须唯一，但允许有空值）"></a>2.唯一索引（索引列的值必须唯一，但允许有空值）</h5><p>创建索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX indexName ON table(column(length))</span><br></pre></td></tr></table></figure></p><h5 id="3-主键索引（一个表的主键）"><a href="#3-主键索引（一个表的主键）" class="headerlink" title="3.主键索引（一个表的主键）"></a>3.主键索引（一个表的主键）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `table` (</span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    `title` char(255) NOT NULL ,</span><br><span class="line">    PRIMARY KEY (`id`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="4-组合索引（将多个列组合在一起创建索引）"><a href="#4-组合索引（将多个列组合在一起创建索引）" class="headerlink" title="4.组合索引（将多个列组合在一起创建索引）"></a>4.组合索引（将多个列组合在一起创建索引）</h5><p>mysql执行查询中，只会使用到一个索引</p><p>最左前缀：意思是使用组合索引的时候，从左到右依次匹配，否则不会使用组合索引。  </p><blockquote><p>例如<code>ALTER TABLE people ADD INDEX lname_fname_age (lame,fname,age);</code>其实我们是建立了三个索引，分别是：单列索引lame，组合索引（lame，fname），组合索引（lame，fname，age），mysql索引的时候只会使用其中一个索引。</p></blockquote><p>所以创建组合索引的时候，尽量把使用频繁的放在左边</p><h3 id="二、索引创建的原则和注意事项"><a href="#二、索引创建的原则和注意事项" class="headerlink" title="二、索引创建的原则和注意事项"></a>二、索引创建的原则和注意事项</h3><ul><li>1.最适合创建索引的是出现在where子句中的列或是出现在连接子句中的列</li><li>2.对字符串类型进行索引的时候，应该指定一个前缀长度，比如索引前多少个字符  </li><li>3.根据业务情况创建组合索引（比如某个业务需要查询两个列）</li><li>4.组合索引遵循前缀原则（最左前缀原则）TODO  </li><li><p>5.like查询，%不能在前，可以使用全文检索引擎</p><ul><li>例如： where name like ‘%wang%’，查询姓名中有wang的，此时索引不会生效，还是会全表扫描，因为前面有个%，如果是like ‘wang%’这样会使用到索引，但是没有前缀匹配了，如果想达到索引的效果，可以使用全文检索引擎，例如es（Elasticsearch）</li></ul></li><li><p>6.如果mysql觉得全表扫描比索引扫描快，他会自动放弃使用索引</p></li><li><p>7.mysql查询只使用一个索引，如果where子句中使用了索引，那么order by中的列是不会使用索引的</p></li><li><p>8.列中包含null值是不会使用索引的，如果column_name is null还是会使用索引，但是建表的时候尽量设置一个非null的默认值。</p></li></ul><h1 id="explain分析sql语句"><a href="#explain分析sql语句" class="headerlink" title="explain分析sql语句"></a>explain分析sql语句</h1><p>现有如下的sql语句<code>EXPLAIN SELECT * FROM inventory WHERE item_id = 16102176;</code><br>打印结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">id: 1  </span><br><span class="line">select_type: SIMPLE  </span><br><span class="line">table: inventory  </span><br><span class="line">type: ref  </span><br><span class="line">possible_keys: item_id  </span><br><span class="line">key: item_id  </span><br><span class="line">key_len: 4  </span><br><span class="line">ref: const  </span><br><span class="line">rows: 1  </span><br><span class="line">Extra: Using where</span><br></pre></td></tr></table></figure><ul><li>1.key: 指出优化器使用的索引。</li><li>2.rows: mysql认为他查询必须要检查的行数，优化器估计值。</li><li>3.possible_keys: 支出优化器为查询选定的索引</li><li>4.key_len: sql语句的连接条件的键的长度</li><li>5.select_type: select使用的类型。  <pre><code>+ simple（简单的select不含union或子查询）、+ primary（最外面的select）、+ union（union中第二个或后面的select）、+ dependent union（union中第二个或后面的select，取决于外面的查询）、+ union result（union的结果）、 + subquery（子查询中第一个select）</code></pre></li><li>6.type： 连接类型。system（表仅有一行）、const（表最多有一个匹配行）、eq_ref(对于每个前面的表的行组合，从该表中读取一行)、ref（对于每个来自于前面表的行组合，所有匹配索引值将从这张表中读取）、index_merge(使用了索引合并优化方法)、all（完整的表扫描）</li><li>7.ref： 显示使用哪个列或常数与key一起从表中选择行</li></ul>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL慢查询机制</title>
      <link href="/2018/07/02/MySQL%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/07/02/MySQL%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>开启慢查询日志，可以让MySQL记录下查询超过指定时间的语句，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。</p><h3 id="二、参数说明"><a href="#二、参数说明" class="headerlink" title="二、参数说明"></a>二、参数说明</h3><ul><li>slow_query_log 慢查询开启状态</li><li>slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）</li><li>long_query_time 查询超过多少秒才记录</li></ul><a id="more"></a><p>###三、设置步骤</p><h5 id="1-查询慢查询相关的参数"><a href="#1-查询慢查询相关的参数" class="headerlink" title="1. 查询慢查询相关的参数"></a>1. 查询慢查询相关的参数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;slow_query%&apos;;</span><br><span class="line">+---------------------------+----------------------------------+</span><br><span class="line">| Variable_name             | Value                            |</span><br><span class="line">+---------------------------+----------------------------------+</span><br><span class="line">| slow_query_log            | OFF                              |</span><br><span class="line">| slow_query_log_file       | /mysql/data/localhost-slow.log   |</span><br><span class="line">+---------------------------+----------------------------------+</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;long_query_time&apos;;</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   | Value     |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| long_query_time | 10.000000 |</span><br><span class="line">+-----------------+-----------+</span><br></pre></td></tr></table></figure><h5 id="2-设置方法"><a href="#2-设置方法" class="headerlink" title="2. 设置方法"></a>2. 设置方法</h5><p>(1)全局变量设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">设置slow_query_log为on</span><br><span class="line">mysql&gt; set global slow_query_log=&apos;ON&apos;; </span><br><span class="line">设置慢查询日志存放位置</span><br><span class="line">mysql&gt; set global slow_query_log_file=&apos;/var/logs/mysql/data/slow.log&apos;;</span><br><span class="line">设置查询时间超过一秒就记录</span><br><span class="line">mysql&gt; set global long_query_time=1;</span><br></pre></td></tr></table></figure><p>(2)修改配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log = ON</span><br><span class="line">slow_query_log_file = /usr/local/mysql/data/slow.log</span><br><span class="line">long_query_time = 1</span><br></pre></td></tr></table></figure><h3 id="四、pt-query-digest分析慢查询日志"><a href="#四、pt-query-digest分析慢查询日志" class="headerlink" title="四、pt-query-digest分析慢查询日志"></a>四、pt-query-digest分析慢查询日志</h3><h5 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h5><p>pt-query-digest是用于分析mysql慢查询的一个工具，它可以分析binlog、General log、slowlog，也可以通过SHOWPROCESSLIST或者通过tcpdump抓取的MySQL协议数据来进行分析。可以把分析结果输出到文件中，分析过程是先对查询语句的条件进行参数化，然后对参数化以后的查询进行分组统计，统计出各查询的执行时间、次数、占比等，可以借助分析结果找出问题进行优化。</p><h5 id="2-安装-官网"><a href="#2-安装-官网" class="headerlink" title="2. 安装 官网"></a>2. 安装 <a href="http://www.cnblogs.com/luyucheng/p/6265873.html" target="_blank" rel="noopener">官网</a></h5><p>(1)安装perl的模块</p><pre><code>yum install -y perl-CPAN perl-Time-HiRes</code></pre><p>(2)安装步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rpm安装：</span><br><span class="line">cd /usr/local/src</span><br><span class="line">wget percona.com/get/percona-toolkit.rpm</span><br><span class="line">yum install -y percona-toolkit.rpm</span><br><span class="line"></span><br><span class="line">源码安装：</span><br><span class="line">cd /usr/local/src</span><br><span class="line">wget percona.com/get/percona-toolkit.tar.gz</span><br><span class="line">tar zxf percona-toolkit.tar.gz</span><br><span class="line">cd percona-toolkit-2.2.19</span><br><span class="line">perl Makefile.PL PREFIX=/usr/local/percona-toolkit</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>(3) <a href="https://www.percona.com/doc/percona-toolkit/2.2/index.html" target="_blank" rel="noopener">用法简介</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.慢查询日志分析</span><br><span class="line">pt-query-digest /var/logs/mysql/data/slow.log</span><br><span class="line">2.服务器摘要</span><br><span class="line">pt-summary</span><br><span class="line">3.服务器磁盘监测</span><br><span class="line">pt-diskstats</span><br><span class="line">4.mysql服务状态摘要</span><br><span class="line">pt-mysql-summary -- --user=root --password=root123</span><br></pre></td></tr></table></figure><h5 id="3-pt-query-digest语法及重要选项"><a href="#3-pt-query-digest语法及重要选项" class="headerlink" title="3. pt-query-digest语法及重要选项"></a>3. pt-query-digest语法及重要选项</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest [OPTIONS] [FILES] [DSN]</span><br><span class="line">--create-review-table  当使用--review参数把分析结果输出到表中时，如果没有表就自动创建。</span><br><span class="line">--create-history-table  当使用--history参数把分析结果输出到表中时，如果没有表就自动创建。</span><br><span class="line">--filter  对输入的慢查询按指定的字符串进行匹配过滤后再进行分析</span><br><span class="line">--limit    限制输出结果百分比或数量，默认值是20,即将最慢的20条语句输出，如果是50%则按总响应时间占比从大到小排序，输出到总和达到50%位置截止。</span><br><span class="line">--host  mysql服务器地址</span><br><span class="line">--user  mysql用户名</span><br><span class="line">--password  mysql用户密码</span><br><span class="line">--history 将分析结果保存到表中，分析结果比较详细，下次再使用--history时，如果存在相同的语句，且查询所在的时间区间和历史表中的不同，则会记录到数据表中，可以通过查询同一CHECKSUM来比较某类型查询的历史变化。</span><br><span class="line">--review 将分析结果保存到表中，这个分析只是对查询条件进行参数化，一个类型的查询一条记录，比较简单。当下次使用--review时，如果存在相同的语句分析，就不会记录到数据表中。</span><br><span class="line">--output 分析结果输出类型，值可以是report(标准分析报告)、slowlog(Mysql slow log)、json、json-anon，一般使用report，以便于阅读。</span><br><span class="line">--since 从什么时间开始分析，值为字符串，可以是指定的某个”yyyy-mm-dd [hh:mm:ss]”格式的时间点，也可以是简单的一个时间值：s(秒)、h(小时)、m(分钟)、d(天)，如12h就表示从12小时前开始统计。</span><br><span class="line">--until 截止时间，配合—since可以分析一段时间内的慢查询。</span><br></pre></td></tr></table></figure><h5 id="4-分析pt-query-digest输出结果"><a href="#4-分析pt-query-digest输出结果" class="headerlink" title="4. 分析pt-query-digest输出结果"></a>4. 分析pt-query-digest输出结果</h5><blockquote><p>第一部分：总体统计结果</p></blockquote><ul><li>Overall：总共有多少条查询</li><li>Time range：查询执行的时间范围</li><li>unique：唯一查询数量，即对查询条件进行参数化以后，总共有多少个不同的查询</li><li>total：总计   min：最小   max：最大  avg：平均</li><li>95%：把所有值从小到大排列，位置位于95%的那个数，这个数一般最具有参考价值</li><li>median：中位数，把所有值从小到大排列，位置位于中间那个数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 该工具执行日志分析的用户时间，系统时间，物理内存占用大小，虚拟内存占用大小</span><br><span class="line"># 340ms user time, 140ms system time, 23.99M rss, 203.11M vsz</span><br><span class="line"># 工具执行时间</span><br><span class="line"># Current date: Fri Nov 25 02:37:18 2016</span><br><span class="line"># 运行分析工具的主机名</span><br><span class="line"># Hostname: localhost.localdomain</span><br><span class="line"># 被分析的文件名</span><br><span class="line"># Files: slow.log</span><br><span class="line"># 语句总数量，唯一的语句数量，QPS，并发数</span><br><span class="line"># Overall: 2 total, 2 unique, 0.01 QPS, 0.01x concurrency ________________</span><br><span class="line"># 日志记录的时间范围</span><br><span class="line"># Time range: 2016-11-22 06:06:18 to 06:11:40</span><br><span class="line"># 属性               总计      最小    最大    平均    95%  标准    中等</span><br><span class="line"># Attribute          total     min     max     avg     95%  stddev  median</span><br><span class="line"># ============     ======= ======= ======= ======= ======= ======= =======</span><br><span class="line"># 语句执行时间</span><br><span class="line"># Exec time             3s   640ms      2s      1s      2s   999ms      1s</span><br><span class="line"># 锁占用时间</span><br><span class="line"># Lock time            1ms       0     1ms   723us     1ms     1ms   723us</span><br><span class="line"># 发送到客户端的行数</span><br><span class="line"># Rows sent              5       1       4    2.50       4    2.12    2.50</span><br><span class="line"># select语句扫描行数</span><br><span class="line"># Rows examine     186.17k       0 186.17k  93.09k 186.17k 131.64k  93.09k</span><br><span class="line"># 查询的字符数</span><br><span class="line"># Query size           455      15     440  227.50     440  300.52  227.50</span><br></pre></td></tr></table></figure><blockquote><p>第二部分：查询分组统计结果</p><ul><li>Rank：所有语句的排名，默认按查询时间降序排列，通过–order-by指定</li><li>Query ID：语句的ID，（去掉多余空格和文本字符，计算hash值）</li><li>Response：总的响应时间</li><li>time：该查询在本次分析中总的时间占比</li><li>calls：执行次数，即本次分析总共有多少条这种类型的查询语句</li><li>R/Call：平均每次执行的响应时间</li><li>V/M：响应时间Variance-to-mean的比率</li><li>Item：查询对象</li></ul></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Profile</span><br><span class="line"># Rank Query ID           Response time Calls R/Call V/M   Item</span><br><span class="line"># ==== ================== ============= ===== ====== ===== ===============</span><br><span class="line">#    1 0xF9A57DD5A41825CA  2.0529 76.2%     1 2.0529  0.00 SELECT</span><br><span class="line">#    2 0x4194D8F83F4F9365  0.6401 23.8%     1 0.6401  0.00 SELECT wx_member_base</span><br></pre></td></tr></table></figure><blockquote><p>第三部分：每一种查询的详细统计结果</p></blockquote><p>由下面查询的详细统计结果，最上面的表格列出了执行次数、最大、最小、平均、95%等各项目的统计。</p><ul><li>ID：查询的ID号，和上图的Query ID对应</li><li>Databases：数据库名</li><li>Users：各个用户执行的次数（占比）</li><li>Query_time distribution ：查询时间分布, 长短体现区间占比，本例中1s-10s之间查询数量是10s以上的两倍。</li><li>Tables：查询中涉及到的表</li><li>Explain：SQL语句</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># Query 1: 0 QPS, 0x concurrency, ID 0xF9A57DD5A41825CA at byte 802 ______</span><br><span class="line"># This item is included in the report because it matches --limit.</span><br><span class="line"># Scores: V/M = 0.00</span><br><span class="line"># Time range: all events occurred at 2016-11-22 06:11:40</span><br><span class="line"># Attribute    pct   total     min     max     avg     95%  stddev  median</span><br><span class="line"># ============ === ======= ======= ======= ======= ======= ======= =======</span><br><span class="line"># Count         50       1</span><br><span class="line"># Exec time     76      2s      2s      2s      2s      2s       0      2s</span><br><span class="line"># Lock time      0       0       0       0       0       0       0       0</span><br><span class="line"># Rows sent     20       1       1       1       1       1       0       1</span><br><span class="line"># Rows examine   0       0       0       0       0       0       0       0</span><br><span class="line"># Query size     3      15      15      15      15      15       0      15</span><br><span class="line"># String:</span><br><span class="line"># Databases    test</span><br><span class="line"># Hosts        192.168.8.1</span><br><span class="line"># Users        mysql</span><br><span class="line"># Query_time distribution</span><br><span class="line">#   1us</span><br><span class="line">#  10us</span><br><span class="line"># 100us</span><br><span class="line">#   1ms</span><br><span class="line">#  10ms</span><br><span class="line"># 100ms</span><br><span class="line">#    1s  ################################################################</span><br><span class="line">#  10s+</span><br><span class="line"># EXPLAIN /*!50100 PARTITIONS*/</span><br><span class="line">select sleep(2)\G</span><br></pre></td></tr></table></figure><h3 id="五、用法"><a href="#五、用法" class="headerlink" title="五、用法"></a>五、用法</h3><h5 id="1-直接分析慢查询文件"><a href="#1-直接分析慢查询文件" class="headerlink" title="1.直接分析慢查询文件"></a>1.直接分析慢查询文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest  slow.log &gt; slow_report.log</span><br></pre></td></tr></table></figure><h5 id="2-分析最近十二小时内的查询"><a href="#2-分析最近十二小时内的查询" class="headerlink" title="2.分析最近十二小时内的查询"></a>2.分析最近十二小时内的查询</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest  --since=12h  slow.log &gt; slow_report2.log</span><br></pre></td></tr></table></figure><h5 id="3-分析指定时间范围内的查询"><a href="#3-分析指定时间范围内的查询" class="headerlink" title="3.分析指定时间范围内的查询**"></a>3.分析指定时间范围内的查询**</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest slow.log --since &apos;2017-01-07 09:30:00&apos; --until &apos;2017-01-07 10:00:00&apos;&gt; &gt; slow_report3.log</span><br></pre></td></tr></table></figure><h5 id="4-分析含有select语句的慢查询"><a href="#4-分析含有select语句的慢查询" class="headerlink" title="4.分析含有select语句的慢查询"></a>4.分析含有select语句的慢查询</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest --filter &apos;$event-&gt;&#123;fingerprint&#125; =~ m/^select/i&apos; slow.log&gt; slow_report4.log</span><br></pre></td></tr></table></figure><h5 id="5-针对某个用户的查询"><a href="#5-针对某个用户的查询" class="headerlink" title="5.针对某个用户的查询"></a>5.针对某个用户的查询</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest --filter &apos;($event-&gt;&#123;user&#125; || &quot;&quot;) =~ m/^root/i&apos; slow.log&gt; slow_report5.log</span><br></pre></td></tr></table></figure><h5 id="6-查询所有-所有的全表扫描或full-join的慢查询"><a href="#6-查询所有-所有的全表扫描或full-join的慢查询" class="headerlink" title="6.查询所有 所有的全表扫描或full join的慢查询"></a>6.查询所有 所有的全表扫描或full join的慢查询</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest --filter &apos;(($event-&gt;&#123;Full_scan&#125; || &quot;&quot;) eq &quot;yes&quot;) ||(($event-&gt;&#123;Full_join&#125; || &quot;&quot;) eq &quot;yes&quot;)&apos; slow.log&gt; slow_report6.log</span><br></pre></td></tr></table></figure><h5 id="7-把查询保存到query-review表"><a href="#7-把查询保存到query-review表" class="headerlink" title="7.把查询保存到query_review表"></a>7.把查询保存到query_review表</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest --user=root –password=abc123 --review  h=localhost,D=test,t=query_review--create-review-table  slow.log</span><br></pre></td></tr></table></figure><h5 id="8-把查询结果保存到query-history表"><a href="#8-把查询结果保存到query-history表" class="headerlink" title="8.把查询结果保存到query_history表"></a>8.把查询结果保存到query_history表</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest  --user=root –password=abc123 --review  h=localhost,D=test,t=query_history--create-review-table  slow.log_0001</span><br><span class="line">pt-query-digest  --user=root –password=abc123 --review  h=localhost,D=test,t=query_history--create-review-table  slow.log_0002</span><br></pre></td></tr></table></figure><h5 id="9-通过tcpdump抓取mysql的tcp协议数据，然后分析"><a href="#9-通过tcpdump抓取mysql的tcp协议数据，然后分析" class="headerlink" title="9.通过tcpdump抓取mysql的tcp协议数据，然后分析"></a>9.通过tcpdump抓取mysql的tcp协议数据，然后分析</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -s 65535 -x -nn -q -tttt -i any -c 1000 port 3306 &gt; mysql.tcp.txt</span><br><span class="line">pt-query-digest --type tcpdump mysql.tcp.txt&gt; slow_report9.log</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务端数据（php代码+mysql数据库）迁移</title>
      <link href="/2018/06/19/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%95%B0%E6%8D%AE%EF%BC%88php%E4%BB%A3%E7%A0%81+mysql%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%89%E8%BF%81%E7%A7%BB/"/>
      <url>/2018/06/19/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%95%B0%E6%8D%AE%EF%BC%88php%E4%BB%A3%E7%A0%81+mysql%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%89%E8%BF%81%E7%A7%BB/</url>
      <content type="html"><![CDATA[<p>有时候难免会有服务器代码和数据的迁移。</p><blockquote><p>数据的迁移建议删除不必要的日志等文件压缩，数据库的迁移就简单一些。</p></blockquote><p>如果有中转服务器，可以考虑，不然就要下载到本地又上传。</p><h5 id="打包"><a href="#打包" class="headerlink" title="打包:"></a>打包:</h5><p> <a href="http://www.cnblogs.com/52linux/archive/2012/03/04/2379738.html" target="_blank" rel="noopener">http://www.cnblogs.com/52linux/archive/2012/03/04/2379738.html</a></p><a id="more"></a><pre><code>//压缩tar -czvf ***.tar.gztar -cjvf ***.tar.bz2//解压tar -xzvf ***.tar.gztar -xjvf ***.tar.bz2</code></pre><h5 id="mysql数据库导出和导入"><a href="#mysql数据库导出和导入" class="headerlink" title="mysql数据库导出和导入"></a>mysql数据库导出和导入</h5><p><a href="http://www.cnblogs.com/feichexia/p/MysqlDataBackup.html" target="_blank" rel="noopener">http://www.cnblogs.com/feichexia/p/MysqlDataBackup.html</a></p><pre><code>//导出mysqldump -uroot -pPassword [database name] &gt; [dump file],如mysqldump -uroot -p123 test &gt; /tmp/test.2017081801.sql//导入mysql -uroot -p //进入mysqlcreate database dbname;  //创建数据库//use dbname 使用数据库source  /tmp/test.2017081801.sql  //导入数据</code></pre><h5 id="SCP远程操作（类似通过FTP等下载到本地又上传的过程）"><a href="#SCP远程操作（类似通过FTP等下载到本地又上传的过程）" class="headerlink" title="SCP远程操作（类似通过FTP等下载到本地又上传的过程）"></a>SCP远程操作（类似通过FTP等下载到本地又上传的过程）</h5><p><a href="http://www.cnblogs.com/daizhuacai/archive/2013/02/01/2889544.html" target="_blank" rel="noopener">http://www.cnblogs.com/daizhuacai/archive/2013/02/01/2889544.html</a></p><p>如果有备份服务器，可以使用将代码和数据打包后放到远程服务器中转<br><code>scp /etc/mysql/my.cnf necok@192.168.1.136:/etc/mysql</code><br>将mysql配置文件上传到136服务器相应文件夹内</p><p><code>scp necok@192.168.1.136:/etc/mysql/my.cnf /etc/mysql</code><br>将136服务器上的mysql配置文件下载到本地的相应文件夹下面</p><h5 id="Tp5数据迁移："><a href="#Tp5数据迁移：" class="headerlink" title="Tp5数据迁移："></a>Tp5数据迁移：</h5><ul><li><a href="https://www.jianshu.com/p/5a37846c85ea" target="_blank" rel="noopener">https://www.jianshu.com/p/5a37846c85ea</a></li></ul>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>聚簇索引与非聚簇索引的区别</title>
      <link href="/2018/06/17/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/06/17/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>通常情况下，建立索引是加快查询速度的有效手段。但索引不是万能的，靠索 引并不能实现对所有数据的快速存取。事实上，如果索引策略和数据检索需求严重不符的话，建立索引反而会降低查询性能。因此在实际使用当中，应该充分考虑到 索引的开销，包括磁盘空间的开销及处理开销（如资源竞争和加锁）。例如，如果数据频繁的更新或删加，就不宜建立索引。</p><a id="more"></a><p>本文简要讨论一下聚簇索引的特点及其与非聚簇索引的区别。</p><h5 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h5><p>数据库表的索引从数据存储方式上可以分为聚簇索引和非聚簇索引（又叫二级索引）两种。Innodb的聚簇索引在同一个B-Tree中保存了索引列和具体的数据，在聚簇索引中，实际的数据保存在叶子页中，中间的节点页保存指向下一层页面的指针。“聚簇”的意思是数据行被按照一定顺序一个个紧密地排列在一起存储。一个表只能有一个聚簇索引，因为在一个表中数据的存放方式只有一种。</p><blockquote><p>一般来说，将通过主键作为聚簇索引的索引列，也就是通过主键聚集数据。</p></blockquote><h5 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h5><p>非聚簇索引，又叫二级索引。二级索引的叶子节点中保存的不是指向行的物理指针，而是行的主键值。当通过二级索引查找行，存储引擎需要在二级索引中找到相应的叶子节点，获得行的主键值，然后使用主键去聚簇索引中查找数据行，这需要两次B-Tree查找。</p><h5 id="建立索引："><a href="#建立索引：" class="headerlink" title="建立索引："></a>建立索引：</h5><p>在SQL语言中，建立聚簇索引使用CREATE INDEX语句，格式为：CREATE CLUSTER INDEX index_name ON table_name(column_name1,column_name2,…);</p><h5 id="存储特点："><a href="#存储特点：" class="headerlink" title="存储特点："></a>存储特点：</h5><ul><li>聚集索引。表数据按照索引的顺序来存储的，也就是说索引项的顺序与表中记录的物理顺序一致。对于聚集索引，叶子结点即存储了真实的数据行，不再有另外单独的数据页。 在一张表上最多只能创建一个聚集索引，因为真实数据的物理顺序只能有一种。</li><li>非聚集索引。表数据存储顺序与索引顺序无关。对于非聚集索引，叶结点包含索引字段值及指向数据页数据行的逻辑指针，其行数量与数据表行数据量一致。</li></ul><blockquote><p> 总结一下：聚集索引是一种稀疏索引，数据页上一级的索引页存储的是页指针，而不是行指针。而对于非聚集索引，则是密集索引，在数据页的上一级索引页它为每一个数据行存储一条索引记录。</p></blockquote><p>更新表数据</p><ul><li>1、向表中插入新数据行</li></ul><p>​    如果一张表没有聚集索引，那么它被称为“堆集”（Heap）。这样的表中的数据行没有特定的顺序，所有的新行将被添加到表的末尾位置。而建立了聚簇索引的数据表则不同：最简单的情况下，插入操作根据索引找到对应的数据页，然后通过挪动已有的记录为新数据腾出空间，最后插入数据。如果数据页已满，则需要拆分数据页，调整索引指针（且如果表还有非聚集索引，还需要更新这些索引指向新的数据页）。而类似于自增列为聚集索引的，数据库系统可能并不拆分数据页，而只是简单的新添数据页。</p><ul><li>2、从表中删除数据行</li></ul><p>对删除数据行来说：删除行将导致其下方的数据行向上移动以填充删除记录造成的空白。如果删除的行是该数据页中的最后一行，那么该数据页将被回收，相应的索 引页中的记录将被删除。对于数据的删除操作，可能导致索引页中仅有一条记录，这时，该记录可能会被移至邻近的索引页中，原索引页将被回收，即所谓的“索引 合并”。</p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>初识游戏——cocos2dx初探</title>
      <link href="/2018/06/15/%E5%88%9D%E8%AF%86%E6%B8%B8%E6%88%8F%E2%80%94%E2%80%94cocos2dx%E5%88%9D%E6%8E%A2/"/>
      <url>/2018/06/15/%E5%88%9D%E8%AF%86%E6%B8%B8%E6%88%8F%E2%80%94%E2%80%94cocos2dx%E5%88%9D%E6%8E%A2/</url>
      <content type="html"><![CDATA[<p>前端时间一直在忙项目，也提到了关于是一个AVG游戏项目，近期由于最新需求，需要开发iOS 游戏，之前做了这么久一直没有感觉到真正游戏或者游戏开发的存在，这一次，好像真的要步入游戏开发了。</p><p>所以整理了一下。</p><a id="more"></a><blockquote><p>具体概念和基本使用就不做介绍了，因为那些都太枯燥了，这里先说说整个环境搭建（以Mac为例），然后根据实际开发整理一些有意义的东西</p></blockquote><h5 id="先来看看官方"><a href="#先来看看官方" class="headerlink" title="先来看看官方"></a>先来看看官方</h5><p><a href="http://docs.cocos.com/cocos2d-x/manual/zh/" target="_blank" rel="noopener">http://docs.cocos.com/cocos2d-x/manual/zh/</a></p><h2 id="搭建开发环境-iOS"><a href="#搭建开发环境-iOS" class="headerlink" title="搭建开发环境 - iOS"></a>搭建开发环境 - iOS</h2><h4 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h4><pre><code>Cocos2d-x v3.17，下载后解压，下载参见：Cocos官网页面:http://www.cocos.com/downloadXcode 9 下载后安装，下载参见：Apple官网页面;https://developer.apple.com/download/more/或者前往App Store下载</code></pre><h4 id="配置步骤："><a href="#配置步骤：" class="headerlink" title="配置步骤："></a>配置步骤：</h4><ul><li><p>打开 cocos2d-x-3.17/build/cocos2d_tests.xcodeproj</p></li><li><p>在 Xcode 顶部工具栏选择 cpp-tests iOS，iPhone 7 Plus，点击运行，项目将自动编译运行，效果如图：</p></li></ul><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/18addimags/Golang/05/000001.png" alt="曹理鹏(iCocos)-梦工厂"></p><h4 id="如何调试-Debug"><a href="#如何调试-Debug" class="headerlink" title="如何调试(Debug)"></a>如何调试(Debug)</h4><ul><li>点击代码行左侧的空白，设置断点</li><li>运行 cpp-tests</li></ul><p>操作 App 触发断点，IDE 将卡在断点处，视图会自动变化，左侧导航栏可以查看运行堆栈，底部窗口可以查看变量的值：</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/18addimags/Golang/05/000002.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>这里严格来说，其实不算是环境搭建，而是下载引擎，运行官方demo而已，那么下面我们开始简单的搭建一个实际项目，并后续从零开始做一个真正的游戏</p><h2 id="实际开发配置"><a href="#实际开发配置" class="headerlink" title="实际开发配置"></a>实际开发配置</h2><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><pre><code>登录Cocos2d-x 的官网 http://www.cocos2d-x.org点击download 下载最新的版本</code></pre><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/18addimags/Golang/05/000003.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>点击超链接，将会下载得到一个Cocos2d-x-3.17.zip 压缩包</p><pre><code>将下载的压缩包进行解压，打开得到的文件夹，其结构目录如下</code></pre><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/18addimags/Golang/05/000004.png" alt="曹理鹏(iCocos)-梦工厂"></p><ul><li>build :多平台下的架构文件存放的目录</li><li>cocos 框架核心目录 里面存放了Cocos2d-x的核心代码。</li><li>docs：文档目录 可以使用该目录下的doxygen.config 文件创建离线文档</li><li>extensions:扩展目录 存放了一些官方的扩展 包括更多图形用户界面的控制功能 网络访问 CocosBuilder 等</li><li>external：存放扩展需要用到的物理引擎 包括box2d和chipmunk</li><li>licenses: cocos2d依赖很多开源项目，所有的授权许可文件都在这个目录</li><li>plugin:plugin-x 项目目录，plugin -x  是一个可以快速接入第三方idk的框架</li><li>templates：该目录包括在不同集成环境及不同平台中创建Cocos2d-x 新项目的模板</li><li>test：测试项目 这是我们最开始用到的文件 在 cpp-tests 项目中包含所有类的用法 lua 和js 样本也在这个目录</li><li>tools： 需要用到的工具 Cocos2d-console 目录中包含了创建Cocos2d-x项目的脚本 可以针对不同的平台进行开发环境的搭建 同时 还包括将c++绑定至lua 及JavaScript 的脚本文件</li></ul><h4 id="Cocos2d-x的安装和配置"><a href="#Cocos2d-x的安装和配置" class="headerlink" title="Cocos2d-x的安装和配置"></a>Cocos2d-x的安装和配置</h4><p>Cocos2d-x 从2.1.4 版 之后已经不再支持使用模板来生成项目 而是使用官方提供的python 直接创建项目 也就是说Cocos2d-x 不能安装到Xcode上面，不能使用Xcode的Cocos2d-x模板一步一步的生成项目，只能使用Xcode来打开已经创建好的项目</p><h4 id="创建项目的步骤如下："><a href="#创建项目的步骤如下：" class="headerlink" title="创建项目的步骤如下："></a>创建项目的步骤如下：</h4><ul><li>打开终端 进入Cocos2d-x3.14 目录执行./setup.py  运行该文件用来 配置系统的一些环境变量</li></ul><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/18addimags/Golang/05/000005.png" alt="曹理鹏(iCocos)-梦工厂"></p><ul><li>打开终端 执行Cocos new HelloCpp -p org.cocos2dx -l cpp -d codes</li></ul><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/18addimags/Golang/05/000006.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>如果一切正常 则项目创建成功 关闭终端 再次进入Cocos2d-3.14目录这时候 会发现新建的codes目录</p><p>进入该目录发现新建的HelloCpp项目 进入proj.ios_mac 双击HelloCPP.xcodeproj 文件 使用快捷键（command+run）运行程序 就可以在iOS模拟器上看到经典的hello world 画面</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/18addimags/Golang/05/000007.png" alt="曹理鹏(iCocos)-梦工厂"></p>]]></content>
      
      <categories>
          
          <category> cocos2dx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocos2dx </tag>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS游戏——关于马甲包与审核</title>
      <link href="/2018/05/26/iOS%E6%B8%B8%E6%88%8F%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8E%E9%A9%AC%E7%94%B2%E5%8C%85%E4%B8%8E%E5%AE%A1%E6%A0%B8/"/>
      <url>/2018/05/26/iOS%E6%B8%B8%E6%88%8F%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8E%E9%A9%AC%E7%94%B2%E5%8C%85%E4%B8%8E%E5%AE%A1%E6%A0%B8/</url>
      <content type="html"><![CDATA[<p>最近因为工作的原因，博客与公众号停了近一个月，网站也没有及时更新，实在抱歉！当初也不知道哪里来的冲动，脑子一热就离开了多年的城市@广州，去了一个鸟都不拉屎的地方@东莞（有点夸张了，老铁！）。</p><p>本以为是一个新的开始，本以为可以进入一个新的台阶，没料想，半年之久就遍体鳞伤的回到的这个梦想最开始的地方，其中的心酸就不便多说了，当然也让我学到了不少东西，认识了不少朋友和牛人……今天我们来聊的话题是：甲包与审核……</p><a id="more"></a><h2 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h2><p>离开东莞之后，来到广州的一家新公司（创业公司），开始从事小说类游戏开发，说来也惭愧，以前不怎么玩游戏，最多偶尔玩一下近期比较火的游戏，也没有从事过任何游戏开发的工作，有几次有朋友看到我的英文名@iCocos都会问我，你之前事做游戏开发吗？当时我也只能无奈的解释一下：</p><blockquote><p>iCocos的含义是 i+ Coco + s = 苹果 + Cocoa Touch + s</p></blockquote><p>取这个名字的原因是，一直以来都是从事iOS开发，而且对这一块比较喜欢，也很喜欢苹果的产品！</p><ul><li>接触iOS行业也有近四年多，第一次有幸进入游戏这个行业，以前很多同行（非游戏行业）朋友，包括我，一听到游戏行业和游戏开发就觉得很可怕。工资高，加班多——这是是很多人对游戏的行业的最初认识。</li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>项目启动不久，就接到公司内部关于游戏马甲包的整个对接与提审任务，后续也会一直负责这个任务，因为之前是由总部的一个多年Android开发并且有过一些iOS开发经验的同事负责，后面我进来之后iOS这一块也就有我对接处理了，当然其实有很多，我处理的只是其中一两个！</p></blockquote><p>因为之前上架过不少次，当时还是挺有自信的，但是经过了解和沟通之后发现其实并不是相信中的那么简单。</p><p>我还专门花时间在网上，群里，各大论坛和学习网站寻找相关的资料，希望能有一点帮忙！</p><ul><li>其中提到最多的就是关于审核的问题，而且这边同事也说了关于马甲包的审核，通过与否基本上靠运气，而且概率非常低！</li></ul><h2 id="关于马甲包"><a href="#关于马甲包" class="headerlink" title="关于马甲包"></a>关于马甲包</h2><h5 id="那么说了这么多，什么是马甲包呢？"><a href="#那么说了这么多，什么是马甲包呢？" class="headerlink" title="那么说了这么多，什么是马甲包呢？"></a>那么说了这么多，什么是马甲包呢？</h5><blockquote><p>马甲APP指的是为了让认识你的人猜不到,在常用的用户名外再注册的其他名字的APP。</p></blockquote><h5 id="马甲APP与真实APP的区别是什么-相同的地方是什么"><a href="#马甲APP与真实APP的区别是什么-相同的地方是什么" class="headerlink" title="马甲APP与真实APP的区别是什么?相同的地方是什么?"></a>马甲APP与真实APP的区别是什么?相同的地方是什么?</h5><ol><li>应用名称不一样。</li><li>关键词不一样。</li><li>应用图标。不一样。</li><li>应用截图。可以一样,也可以不一样,不做要求。</li><li>开屏图片。最好不一样。</li><li>其余的,比如主APP的一些品牌因素,最好去掉。因为马甲是要用来做坏事的,当然不能让人察觉咯。</li></ol><p>以上出自网络：关于为什么要做马甲APP? 马甲APP怎么做? 马甲APP需要事项? 可以查看下面网络来源说明:</p><ul><li><a href="http://www.chinaz.com/manage/2015/1102/465127.shtml" target="_blank" rel="noopener">什么是马甲APP？怎么用马甲APP导流</a></li></ul><h2 id="对接事项"><a href="#对接事项" class="headerlink" title="对接事项"></a>对接事项</h2><h5 id="一直以来我们做的APP一般都是这几种情况："><a href="#一直以来我们做的APP一般都是这几种情况：" class="headerlink" title="一直以来我们做的APP一般都是这几种情况："></a>一直以来我们做的APP一般都是这几种情况：</h5><ol><li>从零开始发一个完整的项目，然后提审上线。</li><li>接手一个已经开发到一部分或者已经上线的迭代项目，然后提审上线。</li><li>接手一个审核被拒，根据苹果给出的条款修改内容，然后提审上线</li><li>有一些外包或者项目和公司比较特殊的情况</li></ol><h5 id="但是正因为是马甲包，所以比较例外，例外在哪里呢？"><a href="#但是正因为是马甲包，所以比较例外，例外在哪里呢？" class="headerlink" title="但是正因为是马甲包，所以比较例外，例外在哪里呢？"></a>但是正因为是马甲包，所以比较例外，例外在哪里呢？</h5><ol><li>我拿不到源码，改不了App内部的任何界面与效果</li><li>我只要修改提审内容信息，然后向渠道回到进度</li><li>审核几率非常低，而且经常要切换Apple账户处理</li><li>……</li></ol><h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><h5 id="所以在处理之前我这边其实大概根据之前的上线经验整理了一下具体的对接事项和具体步骤："><a href="#所以在处理之前我这边其实大概根据之前的上线经验整理了一下具体的对接事项和具体步骤：" class="headerlink" title="所以在处理之前我这边其实大概根据之前的上线经验整理了一下具体的对接事项和具体步骤："></a>所以在处理之前我这边其实大概根据之前的上线经验整理了一下具体的对接事项和具体步骤：</h5><ol><li>使用（或新）apple账号 </li><li>apple developer生成并下载证书（开发与发布）</li><li>apple developer创建一个Bundle ID</li><li>apple developer添加设备ID</li><li>apple developer创建并下载描述文件（开发与发布）</li><li>itnues connect 创建一个对应ID的app</li><li>将证书导入到电脑钥匙串，右健对应证书到处P12</li><li>修改IAP支付信息（这种一般都是根据ID，不然会很麻烦）</li><li>提交或者修改App Icon，宣传图，应用名称,关键词,应用图标,文件等App和公司信息</li><li>将证书，描述文件，P12（+密码）和ID对应版本号ipa提供商</li><li>让他们根据重新出包，并提供新的ipa包</li><li>确认测试通过，并确认提审信息后，重新上传ipa</li><li>提交审核（使用手动发布模式）……</li><li>跟渠道那边及时反馈进度</li><li>审核没通过则重新以上步骤（不用换账号还好，换账号是最虐心的！！！）</li><li>审核通过则先完成以下两个步骤再点击：发布：<ul><li>1、通知CP切换到正式区服</li><li>2、通知我这边让后端把支付方式切换到第三方支付</li></ul></li></ol><blockquote><p>最后注意一点：</p><blockquote><p>有时候可能会涉及到SDK的处理，这个就要母包提前就准备好，并且根据实际需求替换对应的参数就可以<br>由于这里已经涉及到SDK开发与集成的基础，已经不属于马甲包的范围</p></blockquote></blockquote><h2 id="提审信息"><a href="#提审信息" class="headerlink" title="提审信息"></a>提审信息</h2><h4 id="以下是我提供的数据证书与App提审信息"><a href="#以下是我提供的数据证书与App提审信息" class="headerlink" title="以下是我提供的数据证书与App提审信息"></a>以下是我提供的数据证书与App提审信息</h4><h5 id="证书与ipa信息"><a href="#证书与ipa信息" class="headerlink" title="证书与ipa信息"></a>证书与ipa信息</h5><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/JMT/Games/证书与ipa信息.png" alt="曹理鹏(iCocos)-梦工厂"></p><h5 id="App提审信息"><a href="#App提审信息" class="headerlink" title="App提审信息"></a>App提审信息</h5><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/JMT/Games/提审信息.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>其实整个流程差不多就这么写，这里就不每一步网上都有对应的教程，而且很简单（傻瓜式），当然在整个过程也有可能遇到不少问题，这个就要根据个人经验和学习能力临时应变处理了，所以我就不一一介绍了。</p><h2 id="补充：Android流程与注意事项"><a href="#补充：Android流程与注意事项" class="headerlink" title="补充：Android流程与注意事项"></a>补充：Android流程与注意事项</h2><h5 id="以下是Android同事整理的流程与步骤，可能比较简洁，但是实际并没有这么简单，毕竟Android不像苹果那么多限制，仅供参考，具体流程还是要根据实际执行"><a href="#以下是Android同事整理的流程与步骤，可能比较简洁，但是实际并没有这么简单，毕竟Android不像苹果那么多限制，仅供参考，具体流程还是要根据实际执行" class="headerlink" title="以下是Android同事整理的流程与步骤，可能比较简洁，但是实际并没有这么简单，毕竟Android不像苹果那么多限制，仅供参考，具体流程还是要根据实际执行"></a>以下是Android同事整理的流程与步骤，可能比较简洁，但是实际并没有这么简单，毕竟Android不像苹果那么多限制，仅供参考，具体流程还是要根据实际执行</h5><ol><li>反编译 母包 并且 集成了渠道sdk的demo</li><li>打开两者 反编译之后的目录进行资源替换<ul><li>lib里面的so文件</li><li>smali源码</li><li>res的图片、value里面的资源</li><li>manifest的activity、权限等等，包名后面添加对应渠道的名字<blockquote><p>注意：(除了3011,其他的渠道包还要修改appId、clientKey、clientId)</p></blockquote></li></ul></li><li>在eclipse新建一个同包名的项目，</li><li>拷贝修改后母包的res覆盖进去，</li><li>修改冲突ids(游戏母包也要修改)，</li><li>编译得到apk，</li><li>再反编译这个apk，</li><li>拿到包名对应下面的R$xxxx.smail覆盖到母包里面</li></ol><blockquote><p>后面就是提交apk或者发包的内容了</p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><ul><li>那么说了这么多，好像里面学不到什么东西，我为什么还要写这篇文章呢？</li></ul><p>其实一开始不太想写，也确实没有太多有用的东西，但是我觉得写了还是会有一些用的！</p><ol><li>太久没有写博客和公众号了，有点手痒（哈哈！！！）</li><li>个人习惯，几乎接触第一次的领域，项目，技术都会简单记录一下</li><li>方便后面打算或者会负责此类任务的人，了解整个流程，也欢迎交流学习</li><li>最后一点其实也是最重要的，拒审多次，需求有经验的前辈，指点迷津！</li></ol>]]></content>
      
      <categories>
          
          <category> Games </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS游戏——关于马甲包与审核 </tag>
            
            <tag> Games </tag>
            
            <tag> 关于马甲包与审核 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入理解PHP之——LANMP原理详解</title>
      <link href="/2018/05/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E4%B9%8B%E2%80%94%E2%80%94LANMP%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/05/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E4%B9%8B%E2%80%94%E2%80%94LANMP%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id="LNMP的工作原理"><a href="#LNMP的工作原理" class="headerlink" title="LNMP的工作原理"></a>LNMP的工作原理</h3><p>浏览器发送http  request请求到服务器（Nginx）,服务器响应并处理web请求。如果是静态文本直接返回，否则将脚本（PHP）通过接口传输协议（网关协议）PHP-FCGI（fast-cgi）传输给PHP-FPM（进程管理程序）,然后PHP-FPM调用PHP解析器的其中一个进程PHP-CGI来解析php脚本信息。【PHP-FPM在启动时启动了多个PHP-CGI子进程，并发执行。】然后将解析后的脚本返回到PHP-FPM，PHP-FPM再通过fast-cgi的形式将脚本信息传送给Nginx。服务器再通过Http  response的形式传送给浏览器。浏览器再进行解析与渲染然后进行呈现。 </p><h3 id="LAMP的工作原理"><a href="#LAMP的工作原理" class="headerlink" title="LAMP的工作原理"></a>LAMP的工作原理</h3><p>浏览器向服务器发送http请求，服务器 (Apache)  接受请求,由于php作为Apache的组件模块也会一起启动，它们具有相同的生命周期。Apache会将一些静态资源保存，然后调用php去处理模块进行php脚本的处理。脚本处理完后，Apache将处理完的信息通过http  response的方式发送给浏览器，浏览器解析，渲染等一系列操作后呈现整个网页。</p><a id="more"></a><h3 id="LAMP-LNMP差别"><a href="#LAMP-LNMP差别" class="headerlink" title="LAMP LNMP差别"></a>LAMP LNMP差别</h3><ul><li>1、在LNMP中，Nginx本身对脚本不做任何的处理，而是把请求发fast-cgi管理进程处理，fast-cgi管理进程选择cgi子进程处理结果并返回，二者是相互独立的，通过管道进程通信。  </li><li>2、在LAMP中，PHP是Apache的一个模块，具有相同的生命周期。两者通过共享内存的方式通信。</li></ul><p>两者的PHP环境不相互适用<br>相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率</p><pre><code>nginx的的优势作为web服务器处理静态文件，索引文件，自动索引的效率非常高作为代理服务器，可以实现无缓存的反向代理，提高网站运行速度作为负载均衡服务器，可以在内部直接支持rails和php等性能方面，采用epoll模型，可以支持多并发并且占用低内存稳定方面，采取分段资源分配技术，CPU和内存占用率非常低,少量的dos攻击对nginx基本无作用，高可用方面,支持热部署，启动迅速，可以在不间断服务的情况下，直接升级7x24小时不间容灾nginx的模块和工作原理nginx由内核和模块组成，模块结构分为核心模块，基础模块，第三方模块核心模块: http模块，event模块，mail模块基础模块: http fastCGI模块，http proxy模块，http rewrite模块第三方模块: http upstream request hash 模块，notice模块，htttp access key 模块</code></pre><h3 id="Fast-CGI-介绍"><a href="#Fast-CGI-介绍" class="headerlink" title="Fast-CGI 介绍"></a>Fast-CGI 介绍</h3><p>cgi是通用网关接口，是外部应用程序与Web服务器之间的接口标准，cgi是为了保证web server传递过来的数据是标准格式的，方便cgi程序的编写者。</p><p>Fast-CGI是语言无关的、可伸缩架构的CGI开放扩展，其主要行为是将CGI解释器进程保持在内存中并因此获得较高的性能。众所周知，CGI解释器的反复加载是CGI性能低下的主要原因，如果CGI解释器保持在内存中并接受FastCGI进程管理器调度，则可以提供良好的性能、伸缩性、Fail-  Over特性等等。</p><p>Fast-cgi像是一个常驻(long-live)型的cgi，是用来提高cgi程序性能的。</p><blockquote><p>fast-CGI是nginx和php之间的一个通信接口，该接口实际处理过程通过启动php-fpm进程来解析php脚本，即php-fpm相当于一个动态应用服务器，从而实现nginx动态解析php。因此，如果nginx服务器需要支持php解析，需要在nginx.conf中增加php的配置；将php脚本转发到fastCGI进程监听的IP地址和端口（php-fpm.conf中指定）。同时，php安装的时候，需要开启支持fastCGI选项，并且编译安装php-fpm补丁/扩展，同时，需要启动php-fpm进程，才可以解析nginx通过fastCGI转发过来的php脚本。</p></blockquote><h3 id="Fast-CGI的工作原理"><a href="#Fast-CGI的工作原理" class="headerlink" title="Fast-CGI的工作原理"></a>Fast-CGI的工作原理</h3><ol><li>Web Server启动时载入Fast-CGI进程管理器（IIS ISAPI或Apache Module)</li><li>FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可见多个php-cgi)并等待来自Web Server的连接。</li><li>当客户端请求到达Web Server时，Fast-CGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到Fast-CGI子进程php-cgi。</li><li>Fast-CGI子进程完成处理后将标准输出和错误信息从同一连接返回Web  Server。当Fast-CGI子进程关闭连接时，请求便告处理完成。Fast-CGI子进程接着等待并处理来自Fast-CGI进程管理器(运行在Web  Server中)的下一个连接。 在CGI模式中，php-cgi在此便退出了。</li></ol><p>在上述情况中，你可以想象CGI通常有多慢。每一个Web请求PHP都必须重新解析php.ini、重新载入全部扩展并重初始化全部数据结构。使用Fast-CGI，所有这些都只在进程启动时发生一次。一个额外的好处是，持续数据库连接(Persistent  database connection)可以工作。</p><h3 id="Fast-CGI的不足"><a href="#Fast-CGI的不足" class="headerlink" title="Fast-CGI的不足"></a>Fast-CGI的不足</h3><p>因为是多进程，所以比CGI多线程消耗更多的服务器内存，PHP-CGI解释器每进程消耗7至25兆内存，将这个数字乘以50或100就是很大的内存数。</p><blockquote><p>Nginx 0.8.46+PHP  5.2.14(FastCGI)服务器在3万并发连接下，开启的10个Nginx进程消耗150M内存（15M<em>10=150M），开启的64个php-cgi进程消耗1280M内存（20M</em>64=1280M），加上系统自身消耗的内存，总共消耗不到2GB内存。如果服务器内存较小，完全可以只开启25个php-cgi进程，这样php-cgi消耗的总内存数才500M。</p></blockquote><p>上面的数据摘自Nginx 0.8.x + PHP 5.2.13(FastCGI)搭建胜过Apache十倍的Web服务器(第6版)</p><h3 id="PHP-FPM"><a href="#PHP-FPM" class="headerlink" title="PHP-FPM"></a>PHP-FPM</h3><p>PHP-FPM是一个实现了Fastcgi的程序，PHP-FPM的管理对象是php-cgi。被PHP官方收了。<br> 后来PHP内核集成了PHP-FPM之后就方便多了，使用–enalbe-fpm这个编译参数即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、php-fpm是一个完全独立的程序,不依赖php-cgi,也不依赖php。因为php-fpm是一个内置了php解释器的FastCGI服务,启动时能够自行读取php.ini配置和php-fpm.conf配置.</span><br><span class="line">2、一个master进程,支持多个pool,每个pool由master进程监听不同的端口,pool中有多个worker进程.</span><br><span class="line">3、每个worker进程都内置PHP解释器,并且进程常驻后台,支持prefork动态增加.</span><br><span class="line">4、每个worker进程支持在运行时编译脚本并在内存中缓存生成的opcode来提升性能.</span><br><span class="line">5、每个worker进程支持配置响应指定请求数后自动重启,master进程会重启挂掉的worker进程.</span><br><span class="line">6、每个worker进程能保持一个到MySQL/Memcached/Redis的持久连接,实现&quot;连接池&quot;,避免重复建立连接,对程序透明.</span><br><span class="line">7、master进程采用epoll模型异步接收和分发请求,listen监听端口,epoll_wait等待连接,</span><br><span class="line">8、然后分发给对应pool里的worker进程,worker进程accpet请求后poll处理连接,</span><br><span class="line">9、如果worker进程不够用,master进程会prefork更多进程,</span><br><span class="line">A、如果prefork达到了pm.max_children上限,worker进程又全都繁忙,这时master进程会把请求挂起到连接队列backlog里(默认值是511).12345678910</span><br></pre></td></tr></table></figure><h3 id="PHP-CGI"><a href="#PHP-CGI" class="headerlink" title="PHP-CGI"></a>PHP-CGI</h3><p>php-cgi 是解释PHP脚本的程序，只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理</p><h3 id="Nginx-FastCGI运行原理"><a href="#Nginx-FastCGI运行原理" class="headerlink" title="Nginx+FastCGI运行原理　"></a>Nginx+FastCGI运行原理　</h3><p>nginx不支持对外部程序的直接调用或者解析，所有的外部程序（包括PHP）必须通过FastCGI接口来调用。FastCGI接口在Linux下是socket（这个socket可以是文件socket，也可以是ip socket）。</p><blockquote><p>wrapper：  为了调用CGI程序，还需要一个FastCGI的wrapper（wrapper可以理解为用于启动另一个程序的程序），这个wrapper绑定在某个固定socket上，如端口或者文件socket。当Nginx将CGI请求发送给这个socket的时候，通过FastCGI接口，wrapper接收到请求，然后Fork(派生）出一个新的线程，这个线程调用解释器或者外部程序处理脚本并读取返回数据；接着，wrapper再将返回的数据通过FastCGI接口，沿着固定的socket传递给Nginx；最后，Nginx将返回的数据（html页面或者图片）发送给客户端。这就是Nginx+FastCGI的整个运作过程，</p></blockquote><p>所以，我们首先需要一个wrapper，这个wrapper需要完成的工作：</p><pre><code>1、通过调用fastcgi（库）的函数通过socket和ningx通信（读写socket是fastcgi内部实现的功能，对wrapper是非透明的） 2、调度thread，进行fork和kill 3、和application（php）进行通信 </code></pre>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> LNMP </tag>
            
            <tag> LAMP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入理解PHP之——HTTP请求全过程</title>
      <link href="/2018/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E4%B9%8B%E2%80%94%E2%80%94HTTP%E8%AF%B7%E6%B1%82%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E4%B9%8B%E2%80%94%E2%80%94HTTP%E8%AF%B7%E6%B1%82%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h5 id="一个完整的HTTP请求流程"><a href="#一个完整的HTTP请求流程" class="headerlink" title="一个完整的HTTP请求流程"></a>一个完整的HTTP请求流程</h5><blockquote><p>域名解析 —&gt; 与服务器建立连接 —&gt; 发起HTTP请求 —&gt; 服务器响应HTTP请求，浏览器得到html代码 —&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片） —&gt; 浏览器对页面进行渲染呈现给用户</p></blockquote><a id="more"></a><h4 id="1-域名解析"><a href="#1-域名解析" class="headerlink" title="1. 域名解析"></a>1. 域名解析</h4><p>以Chrome浏览器为例：</p><ul><li>① Chrome浏览器 会首先搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否有<a href="https://www.cnblogs.com" target="_blank" rel="noopener">https://www.cnblogs.com</a> 对应的条目，而且没有过期，如果有且没有过期则解析到此结束。</li></ul><p>注：我们怎么查看Chrome自身的缓存？可以使用 chrome://net-internals/#dns 来进行查看</p><ul><li>② 如果浏览器自身的缓存里面没有找到对应的条目，那么Chrome会搜索操作系统自身的DNS缓存,如果找到且没有过期则停止搜索解析到此结束.</li></ul><p>注：怎么查看操作系统自身的DNS缓存，以Windows系统为例，可以在命令行下使用 ipconfig /displaydns 来进行查看</p><ul><li>③ 如果在Windows系统的DNS缓存也没有找到，那么尝试读取hosts文件（位于C:\Windows\System32\drivers\etc），看看这里面有没有该域名对应的IP地址，如果有则解析成功。</li><li>④ 如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），找打根域的DNS地址，就会向其发起请求（请问<a href="http://www.cnblogs.com这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.cnblogs.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.cnblogs.com这个域名的IP地址，但是我知道cnblogs.com这个域的DNS地址，你去找它去，于是运营商的DNS又向cnblogs.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.cnblogs.com这个域名的IP地址是多少？），这个时候cnblogs.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.cnblogs.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.cnblogs.com" target="_blank" rel="noopener">www.cnblogs.com这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.cnblogs.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.cnblogs.com这个域名的IP地址，但是我知道cnblogs.com这个域的DNS地址，你去找它去，于是运营商的DNS又向cnblogs.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.cnblogs.com这个域名的IP地址是多少？），这个时候cnblogs.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.cnblogs.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.cnblogs.com</a> 对应的IP地址，该进行一步的动作了。</li></ul><p>注：一般情况下是不会进行以下步骤的</p><p>如果经过以上的4个步骤，还没有解析成功，那么会进行如下步骤（以下是针对Windows操作系统）：</p><ul><li>⑤ 操作系统就会查找NetBIOS name Cache（NetBIOS名称缓存，就存在客户端电脑中的），那这个缓存有什么东西呢？凡是最近一段时间内和我成功通讯的计算机的计算机名和Ip地址，就都会存在这个缓存里面。什么情况下该步能解析成功呢？就是该名称正好是几分钟前和我成功通信过，那么这一步就可以成功解析。</li><li>⑥ 如果第⑤步也没有成功，那会查询WINS 服务器（是NETBIOS名称和IP地址对应的服务器）</li><li>⑦ 如果第⑥步也没有查询成功，那么客户端就要进行广播查找</li><li>⑧ 如果第⑦步也没有成功，那么客户端就读取LMHOSTS文件（和HOSTS文件同一个目录下，写法也一样）</li></ul><p>如果第八步还没有解析成功，那么就宣告这次解析失败，那就无法跟目标计算机进行通信。只要这八步中有一步可以解析成功，那就可以成功和目标计算机进行通信。</p><h4 id="2-与服务器建立连接"><a href="#2-与服务器建立连接" class="headerlink" title="2. 与服务器建立连接"></a>2. 与服务器建立连接</h4><h5 id="2-1-TCP连接的建立"><a href="#2-1-TCP连接的建立" class="headerlink" title="2.1 TCP连接的建立"></a>2.1 TCP连接的建立</h5><p>客户端的请求到达服务器，首先就是建立TCP连接</p><ol><li><p>Client首先发送一个连接试探，ACK=0 表示确认号无效，SYN = 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，seq = x 表示Client自己的初始序号（seq = 0 就代表这是第0号包），这时候Client进入syn_sent状态，表示客户端等待服务器的回复</p></li><li><p>Server监听到连接请求报文后，如同意建立连接，则向Client发送确认。TCP报文首部中的SYN 和 ACK都置1 ，ack = x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到（ack=1其实是ack=0+1,也就是期望客户端的第1个包），seq = y 表示Server 自己的初始序号（seq=0就代表这是服务器这边发出的第0号包）。这时服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待client的确认。</p></li><li><p>Client收到确认后还需再次发送确认，同时携带要发送给Server的数据。ACK 置1 表示确认号ack= y + 1 有效（代表期望收到服务器的第1个包），Client自己的序号seq= x + 1（表示这就是我的第1个包，相对于第0个包来说的），一旦收到Client的确认之后，这个TCP连接就进入Established状态，就可以发起http请求了。</p></li></ol><h6 id="问题1：TCP-为什么需要3次握手？"><a href="#问题1：TCP-为什么需要3次握手？" class="headerlink" title="问题1：TCP 为什么需要3次握手？"></a>问题1：TCP 为什么需要3次握手？</h6><p>2个计算机通信是靠协议（目前流行的TCP/IP协议）来实现,如果2个计算机使用的协议不一样，那是不能进行通信的，所以这个3次握手就相当于试探一下对方是否遵循TCP/IP协议，协商完成后就可以进行通信了，当然这样理解不是那么准确。</p><h6 id="问题2：为什么HTTP协议要基于TCP来实现？"><a href="#问题2：为什么HTTP协议要基于TCP来实现？" class="headerlink" title="问题2：为什么HTTP协议要基于TCP来实现？"></a>问题2：为什么HTTP协议要基于TCP来实现？</h6><p>目前在Internet中所有的传输都是通过TCP/IP进行的，HTTP协议作为TCP/IP模型中应用层的协议也不例外，TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。</p><h5 id="2-2-常见TCP连接限制"><a href="#2-2-常见TCP连接限制" class="headerlink" title="2.2 常见TCP连接限制"></a>2.2 常见TCP连接限制</h5><ul><li>2.2.1 修改用户进程可打开文件数限制</li></ul><p>在Linux平台上，无论编写客户端程序还是服务端程序，在进行高并发TCP连接处理时，最高的并发数量都要受到系统对用户单一进程同时可打开文件数量的限制(这是因为系统为每个TCP连接都要创建一个socket句柄，每个socket句柄同时也是一个文件句柄)。可使用ulimit命令查看系统允许当前用户进程打开的文件数限制，windows上是256，linux是1024，这个博客的服务器是65535</p><ul><li>2.2.2 修改网络内核对TCP连接的有关限制</li></ul><p>在Linux上编写支持高并发TCP连接的客户端通讯处理程序时，有时会发现尽管已经解除了系统对用户同时打开文件数的限制，但仍会出现并发TCP连接数增加到一定数量时，再也无法成功建立新的TCP连接的现象。出现这种现在的原因有多种。<br>第一种原因可能是因为Linux网络内核对本地端口号范围有限制。此时，进一步分析为什么无法建立TCP连接，会发现问题出在connect()调用返回失败，查看系统错误提示消息是“Can’t assign requestedaddress”。同时，如果在此时用tcpdump工具监视网络，会发现根本没有TCP连接时客户端发SYN包的网络流量。这些情况说明问题在于本地Linux系统内核中有限制。</p><p>其实，问题的根本原因在于Linux内核的TCP/IP协议实现模块对系统中所有的客户端TCP连接对应的本地端口号的范围进行了限制(例如，内核限制本地端口号的范围为1024~32768之间)。当系统中某一时刻同时存在太多的TCP客户端连接时，由于每个TCP客户端连接都要占用一个唯一的本地端口号(此端口号在系统的本地端口号范围限制中)，如果现有的TCP客户端连接已将所有的本地端口号占满，则此时就无法为新的TCP客户端连接分配一个本地端口号了，因此系统会在这种情况下在connect()调用中返回失败，并将错误提示消息设为“Can’t assignrequested address”。</p><h5 id="2-3-TCP四次挥手"><a href="#2-3-TCP四次挥手" class="headerlink" title="2.3 TCP四次挥手"></a>2.3 TCP四次挥手</h5><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。</p><ul><li>第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</li><li>第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</li><li>第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</li><li>第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</li></ul><h6 id="问题1：为什么要四次分手？"><a href="#问题1：为什么要四次分手？" class="headerlink" title="问题1：为什么要四次分手？"></a>问题1：为什么要四次分手？</h6><blockquote><p> TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p></blockquote><h4 id="3-发起HTTP请求"><a href="#3-发起HTTP请求" class="headerlink" title="3. 发起HTTP请求"></a>3. 发起HTTP请求</h4><h5 id="3-1-HTTP协议"><a href="#3-1-HTTP协议" class="headerlink" title="3.1 HTTP协议"></a>3.1 HTTP协议</h5><p>HTTP是一个客户端和服务器端请求和应答的标准（TCP）。客户端是终端用户，服务器端是网站。通过使用Web浏览器、网络爬虫或者其它的工具，客户端发起一个到服务器上指定端口（默认端口为80）的HTTP请求。</p><blockquote><p>通俗来讲，他就是计算机通过网络进行通信的规则，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据。目前任何终端（手机，笔记本电脑。。）之间进行任何一种通信都必须按照Http协议进行，否则无法连接。</p></blockquote><ul><li>3.1.1 四个基于</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请求与响应：客户端发送请求，服务器端响应数据</span><br><span class="line">无状态的：协议对于事务处理没有记忆能力，客户端第一次与服务器建立连接发送请求时需要进行一系列的安全认证匹配等，因此增加页面等待时间，当客户端向服务器端发送请求，服务器端响应完毕后，两者断开连接，也不保存连接状态，一刀两断！恩断义绝！从此路人！下一次客户端向同样的服务器发送请求时，由于他们之前已经遗忘了彼此，所以需要重新建立连接。</span><br><span class="line">应用层： Http是属于应用层的协议，配合TCP/IP使用。</span><br><span class="line">TCP/IP： Http使用TCP作为它的支撑运输协议。HTTP客户机发起一个与服务器的TCP连接，一旦连接建立，浏览器（客户机）和服务器进程就可以通过套接字接口访问TCP。</span><br></pre></td></tr></table></figure><h5 id="3-2-HTTP请求报文"><a href="#3-2-HTTP请求报文" class="headerlink" title="3.2 HTTP请求报文"></a>3.2 HTTP请求报文</h5><p>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成.</p><ul><li>3.2.1 请求行</li></ul><p>请求行分为三个部分：请求方法、请求地址和协议版本</p><h6 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h6><p>HTTP/1.1 定义的请求方法有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。</p><p>最常的两种GET和POST，如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT。</p><pre><code>请求地址URL:统一资源定位符，是一种自愿位置的抽象唯一识别方法。组成：&lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt; 注：端口和路径有时可以省略（HTTP默认端口号是80）https://localhost:8080/index.html?key1=value1&amp;keys2=value2</code></pre><h6 id="协议版本"><a href="#协议版本" class="headerlink" title="协议版本"></a>协议版本</h6><p>协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1</p><ul><li>3.2.2 请求头部</li></ul><p>请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。</p><p>请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。</p><ul><li>3.2.3 请求数据</li></ul><p>可选部分，比如GET请求就没有请求数据。</p><p>下面是一个POST方法的请求报文：</p><pre><code>POST 　/index.php　HTTP/1.1 　　 请求行Host: localhostUser-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2　　请求头Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8Accept-Language: zh-cn,zh;q=0.5Accept-Encoding: gzip, deflateConnection: keep-aliveReferer: http://localhost/Content-Length：25Content-Type：application/x-www-form-urlencoded　　空行username=aa&amp;password=1234　　请求数据</code></pre><h4 id="4-服务器响应HTTP请求，浏览器得到html代码"><a href="#4-服务器响应HTTP请求，浏览器得到html代码" class="headerlink" title="4. 服务器响应HTTP请求，浏览器得到html代码"></a>4. 服务器响应HTTP请求，浏览器得到html代码</h4><h5 id="4-1-负载均衡"><a href="#4-1-负载均衡" class="headerlink" title="4.1 负载均衡"></a>4.1 负载均衡</h5><p>接收到HTTP请求之后，就轮到负载均衡登场了，它位于网站的最前端，把短时间内较高的访问量分摊到不同机器上处理。负载均衡方案有软件、硬件两种</p><ul><li>4.1.1 负载均衡硬件方案</li></ul><p>F5 BIG-IP是著名的硬件方案，但这里不作讨论</p><ul><li>4.1.2 负载均衡软件方案</li></ul><blockquote><p>有LVS HAProxy Nginx等，留作以后补充</p></blockquote><p>在典型的Rails应用部署方案中，Nginx的作用有两个</p><pre><code>处理静态文件请求转发请求给后端的Rails应用这是一个简单的Nginx配置文件</code></pre><p>后端的Rails服务器通过unix socket与Nginx通信，Nginx伺服public文件夹里的静态文件给用户</p><h5 id="4-2-Rails-应用服务器"><a href="#4-2-Rails-应用服务器" class="headerlink" title="4.2 Rails(应用服务器)"></a>4.2 Rails(应用服务器)</h5><h5 id="4-3-数据库（数据库服务器）"><a href="#4-3-数据库（数据库服务器）" class="headerlink" title="4.3 数据库（数据库服务器）"></a>4.3 数据库（数据库服务器）</h5><h5 id="4-4-Redis、Memercache（缓存服务器）"><a href="#4-4-Redis、Memercache（缓存服务器）" class="headerlink" title="4.4 Redis、Memercache（缓存服务器）"></a>4.4 Redis、Memercache（缓存服务器）</h5><h5 id="4-5-消息队列"><a href="#4-5-消息队列" class="headerlink" title="4.5 消息队列"></a>4.5 消息队列</h5><h5 id="4-6-搜索"><a href="#4-6-搜索" class="headerlink" title="4.6 搜索"></a>4.6 搜索</h5><h5 id="4-7-HTTP响应报文"><a href="#4-7-HTTP响应报文" class="headerlink" title="4.7 HTTP响应报文"></a>4.7 HTTP响应报文</h5><p>HTTP响应报文主要由状态行、响应头部、空行以及响应数据组成。</p><ul><li>4.7.1 状态行</li></ul><blockquote><p>由3部分组成，分别为：协议版本，状态码，状态码描述。</p></blockquote><p>其中协议版本与请求报文一致，状态码描述是对状态码的简单描述，所以这里就只介绍状态码。</p><ul><li>4.7.2 状态码</li></ul><p>状态代码为3位数字。</p><pre><code>1xx：指示信息–表示请求已接收，继续处理。2xx：成功–表示请求已被成功接收、理解、接受。3xx：重定向–要完成请求必须进行更进一步的操作。4xx：客户端错误–请求有语法错误或请求无法实现。5xx：服务器端错误–服务器未能实现合法的请求。</code></pre><ul><li>4.7.3 响应头部</li></ul><p>与请求头部类似，为响应报文添加了一些附加信息</p><ul><li>4.7.4 响应数据</li></ul><p>用于存放需要返回给客户端的数据信息。</p><p>下面是一个响应报文的实例：</p><pre><code>HTTP/1.1 200 OK　　状态行Date: Sun, 17 Mar 2013 08:12:54 GMT　　响应头部Server: Apache/2.2.8 (Win32) PHP/5.2.5X-Powered-By: PHP/5.2.5Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/Expires: Thu, 19 Nov 1981 08:52:00 GMTCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0Pragma: no-cacheContent-Length: 4393Keep-Alive: timeout=5, max=100Connection: Keep-AliveContent-Type: text/html; charset=utf-8空行响应数据</code></pre>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> HTTP </tag>
            
            <tag> 请求流程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>日志组件(Monolog)</title>
      <link href="/2018/05/05/%E6%97%A5%E5%BF%97%E7%BB%84%E4%BB%B6(Monolog)/"/>
      <url>/2018/05/05/%E6%97%A5%E5%BF%97%E7%BB%84%E4%BB%B6(Monolog)/</url>
      <content type="html"><![CDATA[<p>Monolog是php下比较全又容易扩展的记录日志组件。目前有包括Symfony 、Laravel、 CakePHP等诸多知名php框架都内置了Monolog。</p><p>Monolog可以把你的日志发送到文件，sockets，收件箱，数据库和各种web服务器上。一些特殊的组件可以给你带来特殊的日志策略。</p><a id="more"></a><pre><code>&lt;?phpuse Monolog\Logger;use Monolog\Handler\StreamHandler;// create a log channel$log = new Logger(&apos;name&apos;);$log-&gt;pushHandler(new StreamHandler(&apos;path/to/your.log&apos;, Logger::WARNING));// add records to the log$log-&gt;addWarning(&apos;Foo&apos;);$log-&gt;addError(&apos;Bar&apos;);​    &lt;?phpuse Monolog\Logger;use Monolog\Handler\StreamHandler;// create a log channel$log = new Logger(&apos;name&apos;);$log-&gt;pushHandler(new StreamHandler(&apos;path/to/your.log&apos;, Logger::WARNING));// add records to the log$log-&gt;addWarning(&apos;Foo&apos;);$log-&gt;addError(&apos;Bar&apos;);</code></pre><h5 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h5><p>每个Logger实例都有一个通道和日志处理器栈。每当你添加一条日志记录，它会被发送到日志处理器栈。 你可以创建很多Logger，每个Logger定义一个通道（db，请求，路由），每个Logger有很多日志处理器。这些通道会过滤日志。</p><blockquote><p> 每个日志处理器都有一个Formatter（内置的日志显示格式处理器）。你还可以设定日志级别。</p></blockquote><h6 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h6><ul><li>DEBUG：详细的debug信息</li><li>INFO：感兴趣的事件。像用户登录，SQL日志</li><li>NOTICE：正常但有重大意义的事件。</li><li>WARNING：发生异常，使用了已经过时的API。</li><li>ERROR：运行时发生了错误，错误需要记录下来并监视，但错误不需要立即处理。</li><li>CRITICAL：关键错误，像应用中的组件不可用。</li><li>ALETR：需要立即采取措施的错误，像整个网站挂掉了，数据库不可用。这个时候触发器会通过SMS通知你，</li></ul>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器配置——内网CentOS7/PHP/Apache/Nginx/SVN/Git/GitLab服务器实战</title>
      <link href="/2018/04/18/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E5%86%85%E7%BD%91CentOS7:PHP:Apache:Nginx:SVN:Git:GitLab%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E6%88%98/"/>
      <url>/2018/04/18/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E5%86%85%E7%BD%91CentOS7:PHP:Apache:Nginx:SVN:Git:GitLab%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E6%88%98/</url>
      <content type="html"><![CDATA[<p>完整实战，验证通过，可用…..</p><p>此文章看着好长，或者逼格好高的样子。其实很简单，只是因为这些是后端开发或者公司负责项目和内部服务器搭建人员必会的！</p><ul><li>适合人群：<ul><li>PHP后端开发</li><li>小团队或部门组负责人</li><li>服务器或相关运营负责人</li><li>想要学习PHP或者转型后端开发</li><li>业务学习，纯属搞着玩</li></ul></li></ul><a id="more"></a><p>这里就不对每一个模块和内容做解释了，只用实战记录，方便后期查阅也希望能得到更多前辈的点评和指点！</p><p>首先分享一份教程，这是慕课网实战阿里云主机(ECS)与CentOS7教程！</p><ul><li><a href="https://pan.baidu.com/s/1u3BPzu2dGXlXYhWpofjsbA" target="_blank" rel="noopener">阿里云主机(ECS)与CentOS7实战</a></li><li>提取码：389j</li></ul><blockquote><p>注：本文部分外部操作基于Mac系统</p></blockquote><h2 id="1-U盘制作Centos系统盘"><a href="#1-U盘制作Centos系统盘" class="headerlink" title="1.U盘制作Centos系统盘"></a>1.U盘制作Centos系统盘</h2><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><ul><li>U盘或者硬盘一个，需要大于8G</li><li>iso系统:(本文基础1708)<ul><li><a href="https://pan.baidu.com/s/1sC8JSuCzPk6BGbfof7vouQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1sC8JSuCzPk6BGbfof7vouQ</a></li><li>提取码: 4df8</li></ul></li><li>HFSExplorer：方面Windows系统访问Mac盘(U/硬盘)</li><li>UltraISO：光盘映像文件制作</li></ul><p>具体制作安装U盘的步骤由于过于简单，这里就过多说明，不知道的请出门左转找度娘。</p><h2 id="2-Centos安装"><a href="#2-Centos安装" class="headerlink" title="2.Centos安装"></a>2.Centos安装</h2><p>只要U盘正确制作，关于网上教程非常多，也是非常简单的！</p><ul><li>这里推荐被参考的比较多的教程：<ul><li><a href="https://www.osyunwei.com/archives/7829.html" target="_blank" rel="noopener">https://www.osyunwei.com/archives/7829.html</a></li></ul></li></ul><p>有些地方需要注意的：</p><ul><li><ol><li>可以的话，最好在安装信息摘要的时候连上网，方便一些相关的更新和下载。</li></ol></li><li><ol start="2"><li>出入学习推荐使用桌面版，当然如果比较喜欢专业或者非入门级的那就使用最小安装，最小安装是基本上很多东西都没有，连网络和相关需求都不支持。</li></ol></li><li><ol start="3"><li>关于分区可以使用自动分区，或者根据教程做相应的分配，建议不要自己随意配，不然后面难免出现问题。</li></ol></li></ul><p>期间遇到了一个问题</p><blockquote><p>/dev/root does not exist, could not boot</p></blockquote><p>网上都说直接修改</p><blockquote><p>vmlinuz initrd=initrd.imginst.stage2=hd:LABEL=CentOS\x207\x20x86_64 rd.live.check quiet </p></blockquote><ul><li>改为：</li></ul><blockquote><p>vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sda4 quite</p></blockquote><p>试了好几次都不行,最后发现是空格的问题，因为我格式化U盘之后直接命名为了Centos 7，导致产生了空格，而无法读取到U盘</p><h5 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h5><ol><li>到windows里面修改U盘名称（例如 ‘Centos7’）</li><li>进入U盘目录 进入 EFI/boot<ul><li>修改grub.cfg文件，CENTOS\x207 全部修改为U盘名称（CENTOS7）</li></ul></li><li>重启安装</li><li>正常安装并显示交互界面</li></ol><blockquote><p>总结：名称强烈不建议出现中文空格,容易出bug</p></blockquote><p>安装完成之后，进入Centos命令行查看IP地址，然后在ssh连接工具上尝试连接，并且进行一些操作</p><ul><li>CentOS7查看ip地址的方式为：<ul><li>ip addr</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/centos/config/install0001.png" alt="曹理鹏(iCocos)-梦工厂"> </p><p>这里有一点需要知道的是，阿里云或腾讯云或者其他说明鬼云，都是提供的最新的相关Linux系统，所以一般系统安装是不需要我们来做的，除非有一些特殊的情况。</p><blockquote><p>Ip地址也是直接对外提供，不需要我们去查的，所以就XXX云来说，我们做的事情就是从这里往后操作的流程。甚至有些会给你一些更完整或者更多的功能支持。</p></blockquote><p>如果有需要需要额外配置其他相关功能和服务，推荐看这里：</p><ul><li><a href="https://blog.csdn.net/myf12/article/details/78086189" target="_blank" rel="noopener">centos7 装机后的基本配置</a></li></ul><h2 id="3-Centos系统配置PHP服务器"><a href="#3-Centos系统配置PHP服务器" class="headerlink" title="3.Centos系统配置PHP服务器"></a>3.Centos系统配置PHP服务器</h2><blockquote><p>注意：以下安装，我都是用的root权限。</p></blockquote><h4 id="一、关闭防火墙"><a href="#一、关闭防火墙" class="headerlink" title="一、关闭防火墙"></a>一、关闭防火墙</h4><p>查了资料，说法是，CentOS7用的是Firewall-cmd，CentOS7之前用的是iptables防火墙；要想让外网能访问到apache主目录，就需要做以下的操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">停止firewall </span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line">禁止firewall开机启动 </span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br><span class="line">/**</span><br><span class="line">Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.                                             </span><br><span class="line">Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service. </span><br><span class="line">*/</span><br><span class="line">查看默认防火墙的状态 </span><br><span class="line">firewall-cmd --state</span><br><span class="line">/**</span><br><span class="line">not running </span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>或者可以这么做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-service=http</span><br><span class="line">firewall-cmd --permanent --zone=public --add-service=https</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h4 id="二、安装Apache"><a href="#二、安装Apache" class="headerlink" title="二、安装Apache"></a>二、安装Apache</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">安装Apache</span><br><span class="line">yum install httpd -y</span><br><span class="line">--- 一下httpd可以直接使用httpd.service --- </span><br><span class="line">启动Apache</span><br><span class="line">systemctl start httpd</span><br><span class="line">停止Apache</span><br><span class="line">systemctl stop httpd</span><br><span class="line">重启Apache</span><br><span class="line">systemctl restart httpd</span><br><span class="line">Apache开机自启 </span><br><span class="line">systemctl <span class="built_in">enable</span> httpd</span><br><span class="line">/**</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/httpd.service to /usr/lib/systemd</span><br><span class="line">/system/httpd.service.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>在本机浏览器中前面ip addr查到的ip地址，如果看到apache默认的页面–有Testing 123…字样，便是成功安装了apache服务</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/centos/config/testip0001.png" alt="曹理鹏(iCocos)-梦工厂"> </p><h4 id="三、安装php"><a href="#三、安装php" class="headerlink" title="三、安装php"></a>三、安装php</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">安装php</span><br><span class="line">yum install php php-devel或者yum -y install php</span><br><span class="line">安装Php扩展</span><br><span class="line">yum install php-mysql php-gd php-imap php-ldap php-odbc php-pear php-xml php-xmlrpc</span><br><span class="line">重启Apache: </span><br><span class="line">systemctl restart httpd或者systemctl restart httpd.service</span><br></pre></td></tr></table></figure><p>然后，你可以写一个php文件在浏览器中运行一下了;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /var/www/html/info.php</span><br><span class="line">&lt;?php phpinfo(); ?&gt;</span><br></pre></td></tr></table></figure><p>然后，在自己电脑浏览器输入 <a href="http://172.20.10.2/info.php" target="_blank" rel="noopener">http://172.20.10.2/info.php</a><br>运行，会出现php的一些信息,如果出现如下界面，说明已经成功了</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/centos/config/infophp.png" alt="曹理鹏(iCocos)-梦工厂"> </p><h4 id="四、安装mysql"><a href="#四、安装mysql" class="headerlink" title="四、安装mysql"></a>四、安装mysql</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">安装MySQL</span><br><span class="line">yum install mariadb mariadb-server -y</span><br><span class="line">启动MariaDB </span><br><span class="line">systemctl start mariadb  </span><br><span class="line">停止MariaDB </span><br><span class="line">systemctl stop mariadb  </span><br><span class="line">重启MariaDB </span><br><span class="line">systemctl restart mariadb</span><br><span class="line">设置开机启动 </span><br><span class="line">systemctl <span class="built_in">enable</span> mariadb</span><br><span class="line">/**</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/mariadb.service to /usr/lib/syste</span><br><span class="line">md/system/mariadb.service.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>设置root帐户的密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql_secure_installation</span><br></pre></td></tr></table></figure><p>然后会出现一串东西，可以仔细读一下，如果你懒得读，就在提示出来的时候，按Enter就好了，让你设置密码的时候，你就输入你想要的密码就行，然后继续在让你选择y/n是，Enter就好了；当一切结束的时候，你可以输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root</span><br></pre></td></tr></table></figure></p><p>验证一下,输入密码，正常连接并可进行mysql操作</p><p>有时候由于安装命令的问题，会出现下面的报错，建议重现使用上面的操作一遍</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR 2002 (HY000): Can<span class="string">'t connect to local MySQL server through socket '</span>/var/run/mysqld/mysqld.sock</span><br><span class="line"><span class="string">' (2)</span></span><br></pre></td></tr></table></figure><h4 id="五、配置Mysql，设置MySQL密码"><a href="#五、配置Mysql，设置MySQL密码" class="headerlink" title="五、配置Mysql，设置MySQL密码"></a>五、配置Mysql，设置MySQL密码</h4><h6 id="1-连接MySQL"><a href="#1-连接MySQL" class="headerlink" title="1.连接MySQL"></a>1.连接MySQL</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root</span><br></pre></td></tr></table></figure><h6 id="2-设置密码"><a href="#2-设置密码" class="headerlink" title="2.设置密码"></a>2.设置密码</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> password <span class="keyword">for</span> <span class="string">'root'</span>@<span class="string">'localhost'</span> = password(<span class="string">'root'</span>);</span><br><span class="line">mysql&gt; <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h6 id="3-远程授权连接mysql"><a href="#3-远程授权连接mysql" class="headerlink" title="3.远程授权连接mysql"></a>3.远程授权连接mysql</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO <span class="string">'root'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'root'</span> WITH GRANT OPTION;</span><br><span class="line">配置生效：FLUSH   PRIVILEGES;</span><br></pre></td></tr></table></figure><h6 id="再次连接线使用："><a href="#再次连接线使用：" class="headerlink" title="再次连接线使用："></a>再次连接线使用：</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><blockquote><p>然后输入上面的root密码</p></blockquote><h4 id="六、将PHP和MySQL关联起来"><a href="#六、将PHP和MySQL关联起来" class="headerlink" title="六、将PHP和MySQL关联起来"></a>六、将PHP和MySQL关联起来</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum search php</span><br></pre></td></tr></table></figure><p>选择你需要的安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install php-mysql</span><br></pre></td></tr></table></figure><h4 id="七、安装常用的PHP模块"><a href="#七、安装常用的PHP模块" class="headerlink" title="七、安装常用的PHP模块"></a>七、安装常用的PHP模块</h4><p>例如，GD库，curl，mbstring,…</p><h6 id="1-安装："><a href="#1-安装：" class="headerlink" title="1.安装："></a>1.安装：</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install php-gd php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-snmp php-soap curl curl-devel</span><br></pre></td></tr></table></figure><h6 id="2-重启apache服务"><a href="#2-重启apache服务" class="headerlink" title="2.重启apache服务"></a>2.重启apache服务</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart httpd.service</span><br></pre></td></tr></table></figure><p>然后，再次在浏览器中运行info.php，你会看到安装的模块的信息；</p><p>至此，LAMP环境就搭建好了……</p><h2 id="4-nginx安装与配置"><a href="#4-nginx安装与配置" class="headerlink" title="4. nginx安装与配置"></a>4. nginx安装与配置</h2><ul><li><a href="https://www.jianshu.com/p/d55aa0bdb280" target="_blank" rel="noopener">Nginx从安装到入门，基础篇</a></li></ul><p>Nginx有三种安装方式</p><ol><li>安装包编译安装(相对麻烦)</li><li>yum源安装</li><li>使用docker安装</li></ol><p>需确认80端口是否开放，如果是阿里云，得在控制台那边设置端口组开放</p><pre><code>#确保防火墙是否开放80端口 如果没有firewall-cmd --permanent --zone=public --add-port=80/tcp #重新加载firewall-cmd --reload#查看列表firewall-cmd --list-all</code></pre><p>这里推荐直接使用yum源安装，因为比较快捷，方便</p><pre><code>#yum安装nginxsudo yum install -y nginx#启动nginxsudo systemctl start nginx.service#设置开机自启动sudo systemctl enable nginx.service#yum安装的nginx配置文件默认存放在 /etc/nginx/nginx.conf 查看vi /etc/nginx/nginx.conf #卸载yum remove nginx</code></pre><p>如果可以你也可以直接使用安装包编译安装</p><pre><code># 下载源码$ wget http://nginx.org/download/nginx-1.13.0.tar.gz# 解压源码$ tar xvf nginx-1.13.0.tar.gz# 进入源码目录$ cd nginx-1.13.0# 配置、编译、安装$ ./configure$ make$ make install</code></pre><p>有时候回遇到，输入网址之后不是官方默认界面，可能是因为</p><blockquote><p>有epel源的时候并且用yum install nginx 安装就会显示Welcome to nginx on Fedora!，因为epel源就是Fedora维护的</p></blockquote><h2 id="5-Centos配置Git服务器"><a href="#5-Centos配置Git服务器" class="headerlink" title="5.Centos配置Git服务器"></a>5.Centos配置Git服务器</h2><h4 id="1、安装Git"><a href="#1、安装Git" class="headerlink" title="1、安装Git"></a>1、安装Git</h4><p>首先需要安装Git，可以使用yum源在线安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y git</span><br></pre></td></tr></table></figure><h4 id="2、用户操作"><a href="#2、用户操作" class="headerlink" title="2、用户操作"></a>2、用户操作</h4><p>创建一个git用户，用来运行git服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adduser git</span><br><span class="line">passwd git</span><br><span class="line">/*输入git用户密码*/</span><br></pre></td></tr></table></figure><h4 id="3、git初始化"><a href="#3、git初始化" class="headerlink" title="3、git初始化"></a>3、git初始化</h4><p>初始化git仓库：这里我们选择/git/icocos.git来作为我们的git仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /git -p</span><br><span class="line"><span class="built_in">cd</span> /git</span><br><span class="line">git init --bare icocos.git  <span class="comment">#初始化仓库</span></span><br></pre></td></tr></table></figure><p>执行以上命令，会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。</p><h4 id="4、然后，把owner改为git"><a href="#4、然后，把owner改为git" class="headerlink" title="4、然后，把owner改为git"></a>4、然后，把owner改为git</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown git:git icocos.git  -R</span><br></pre></td></tr></table></figure><h4 id="5、clone远程仓库"><a href="#5、clone远程仓库" class="headerlink" title="5、clone远程仓库"></a>5、clone远程仓库</h4><p>在这里，Git服务器就已经搭得差不多了。下面我们在客户端clone一下远程仓库。</p><blockquote><p>Mysql可以直接使用命令行，或者使用Tower</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@172.20.10.2:/git/icocos.git</span><br><span class="line">Cloning into <span class="string">'icocos'</span>...</span><br><span class="line">git@172.20.10.2<span class="string">'s password: </span></span><br><span class="line"><span class="string">remote: Counting objects: 6, done.</span></span><br><span class="line"><span class="string">remote: Compressing objects: 100% (6/6), done.</span></span><br><span class="line"><span class="string">remote: Total 6 (delta 0), reused 0 (delta 0)</span></span><br><span class="line"><span class="string">Receiving objects: 100% (6/6), 2.63 MiB | 1.63 MiB/s, done.</span></span><br></pre></td></tr></table></figure><p>输入git账户对应的密码<br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/centos/config/gitconfig.png" alt="曹理鹏(iCocos)-梦工厂"> </p><p>然后就可以根据公司或者具体项目做相应拓展和配置</p><h4 id="Git实战记录总结"><a href="#Git实战记录总结" class="headerlink" title="Git实战记录总结"></a>Git实战记录总结</h4><h6 id="配置与初始化实战流程"><a href="#配置与初始化实战流程" class="headerlink" title="配置与初始化实战流程"></a>配置与初始化实战流程</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@centos /]<span class="comment"># yum install -y git                                                                                                    </span></span><br><span class="line">已加载插件：fastestmirror, langpacks                                                                                                   </span><br><span class="line">Loading mirror speeds from cached hostfile                                                                                             </span><br><span class="line"> * base: mirror.jdcloud.com                                                                                                            </span><br><span class="line"> * extras: mirrors.163.com                                                                                                             </span><br><span class="line"> * updates: mirrors.163.com                                                                                                            </span><br><span class="line">软件包 git-1.8.3.1-20.el7.x86_64 已安装并且是最新版本                                                                                  </span><br><span class="line">无须任何处理                                                                                                                           </span><br><span class="line">[root@centos /]<span class="comment"># adduser git                                                                                                                                                                                                                        </span></span><br><span class="line">[root@centos /]<span class="comment"># passwd git                                                                                                            </span></span><br><span class="line">更改用户 git 的密码 。                                                                                                                 </span><br><span class="line">新的 密码：                                                                                                                            </span><br><span class="line">重新输入新的 密码：                                                                                                                    </span><br><span class="line">passwd：所有的身份验证令牌已经成功更新。                                                                                                </span><br><span class="line">[root@centos /]<span class="comment"># mkdir git                                                                                                    </span></span><br><span class="line">[root@centos /]<span class="comment"># cd git                                                                                                                </span></span><br><span class="line">[root@centos git]<span class="comment"># ls                                                                                                                                                                                                                     </span></span><br><span class="line">[root@centos git]<span class="comment"># mkdir SwiftProject                                                                                                  </span></span><br><span class="line">[root@centos git]<span class="comment"># cd SwiftProject/                                                                                                    </span></span><br><span class="line">[root@centos SwiftProject]<span class="comment"># ls                                                                                                         </span></span><br><span class="line">[root@centos SwiftProject]<span class="comment"># git init --bare SwiftProject.git  #初始化仓库                                                              </span></span><br><span class="line">初始化空的 Git 版本库于 /git/SwiftProject/SwiftProject.git/                                                                            </span><br><span class="line">[root@centos SwiftProject]<span class="comment"># chown git:git SwiftProject.git  -R</span></span><br></pre></td></tr></table></figure><h6 id="内外网访问和Clone"><a href="#内外网访问和Clone" class="headerlink" title="内外网访问和Clone"></a>内外网访问和Clone</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git@172.20.10.2:/git/SwiftProject/SwiftProject.git</span><br></pre></td></tr></table></figure><blockquote><p>然后就是根据需求创建项目提交或拉去代码</p></blockquote><h2 id="6-Centos配置SVN服务器"><a href="#6-Centos配置SVN服务器" class="headerlink" title="6.Centos配置SVN服务器"></a>6.Centos配置SVN服务器</h2><h4 id="1、subversion安装"><a href="#1、subversion安装" class="headerlink" title="1、subversion安装"></a>1、subversion安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos /]<span class="comment"># yum install subversion</span></span><br></pre></td></tr></table></figure><h4 id="2、新建一个目录用于存储SVN目录"><a href="#2、新建一个目录用于存储SVN目录" class="headerlink" title="2、新建一个目录用于存储SVN目录"></a>2、新建一个目录用于存储SVN目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos /]mkdir /svn</span><br></pre></td></tr></table></figure><h4 id="3、SVN方式创建SVN项目目录"><a href="#3、SVN方式创建SVN项目目录" class="headerlink" title="3、SVN方式创建SVN项目目录"></a>3、SVN方式创建SVN项目目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos svn]<span class="comment"># svnadmin create /svn/SwiftProject/</span></span><br></pre></td></tr></table></figure><h4 id="4、SVN项目目录查看内容"><a href="#4、SVN项目目录查看内容" class="headerlink" title="4、SVN项目目录查看内容"></a>4、SVN项目目录查看内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@centos svn]<span class="comment"># ll SwiftProject</span></span><br><span class="line">总用量 8</span><br><span class="line">drwxr-xr-x. 2 root root  54 1月  12 01:09 conf</span><br><span class="line">drwxr-sr-x. 6 root root 233 1月  12 01:09 db</span><br><span class="line">-r--r--r--. 1 root root   2 1月  12 01:09 format</span><br><span class="line">drwxr-xr-x. 2 root root 231 1月  12 01:09 hooks</span><br><span class="line">drwxr-xr-x. 2 root root  41 1月  12 01:09 locks</span><br><span class="line">-rw-r--r--. 1 root root 229 1月  12 01:09 README.txt</span><br></pre></td></tr></table></figure><ul><li>以下关于目录的说明：<ul><li>hooks目录：放置hook脚步文件的目录</li><li>locks目录：用来放置subversion的db锁文件和db_logs锁文件的目录，用来追踪存取文件库的客户端</li><li>format目录：是一个文本文件，里边只放了一个整数，表示当前文件库配置的版本号</li><li>conf目录：是这个仓库配置文件（仓库用户访问账户，权限）</li></ul></li></ul><h4 id="5、SVN配置文件"><a href="#5、SVN配置文件" class="headerlink" title="5、SVN配置文件"></a>5、SVN配置文件</h4><p>cd conf/进入conf目录（该svn版本库配置文件），一共有三个文件</p><ul><li>authz文件是权限控制文件</li><li>passwd是帐号密码文件</li><li>svnserve.conf SVN服务配置文件</li></ul><h6 id="a、编辑用户文件passwd，新增两个用户：svn。"><a href="#a、编辑用户文件passwd，新增两个用户：svn。" class="headerlink" title="a、编辑用户文件passwd，新增两个用户：svn。"></a>a、编辑用户文件passwd，新增两个用户：svn。</h6><blockquote><p>vim conf/passwd</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[users]</span><br><span class="line">svn = svn</span><br></pre></td></tr></table></figure><h6 id="b、编辑权限文件authz，用户admin设置可读写权限，guest设置只读权限。"><a href="#b、编辑权限文件authz，用户admin设置可读写权限，guest设置只读权限。" class="headerlink" title="b、编辑权限文件authz，用户admin设置可读写权限，guest设置只读权限。"></a>b、编辑权限文件authz，用户admin设置可读写权限，guest设置只读权限。</h6><blockquote><p>vim conf/authz</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[/]</span><br><span class="line">svn = rw</span><br></pre></td></tr></table></figure><h6 id="c-进入所建立仓库的配置目录-svn-project-conf修改文件svnserve-conf"><a href="#c-进入所建立仓库的配置目录-svn-project-conf修改文件svnserve-conf" class="headerlink" title="c,进入所建立仓库的配置目录/svn/project/conf修改文件svnserve.conf"></a>c,进入所建立仓库的配置目录/svn/project/conf修改文件svnserve.conf</h6><blockquote><p>vim conf/svnserve.conf</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">anon-access = none     //匿名访问权限</span><br><span class="line">auth-access = write    //认证用户权限</span><br><span class="line">password-db = passwd   //密码配置文件路径，默认为同目录的passwd文件</span><br><span class="line">realm = My First Repository //认证标记而已</span><br></pre></td></tr></table></figure><h4 id="6、启动SVN服务器"><a href="#6、启动SVN服务器" class="headerlink" title="6、启动SVN服务器"></a>6、启动SVN服务器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svnserve -d -r /svn --listen-host 172.20.10.2</span><br></pre></td></tr></table></figure><p>-d表示在后台运行，-r指定了服务器的根目录，这样在SVN客户端就可以用svn://172.20.10.2/SwiftProject来访问SVN服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">svn co svn://172.20.10.2/SwiftProject</span><br><span class="line">Checked out revision 0.</span><br><span class="line">ls</span><br><span class="line">SwiftProject</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/centos/config/svnconfig.png" alt="曹理鹏(iCocos)-梦工厂"> </p><blockquote><p>注意</p><blockquote><p>使用以下命令可以查看正在运行的SVN进程<br>ps -ef | grep svn<br>使用命令 killall svnserve 来停止SVN服务器。</p></blockquote></blockquote><h4 id="SVN实战记录总结"><a href="#SVN实战记录总结" class="headerlink" title="SVN实战记录总结"></a>SVN实战记录总结</h4><h6 id="配置与初始化实战流程-1"><a href="#配置与初始化实战流程-1" class="headerlink" title="配置与初始化实战流程"></a>配置与初始化实战流程</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@centos /]<span class="comment"># yum install subversion                                                                                                </span></span><br><span class="line">已加载插件：fastestmirror, langpacks                                                                                                   </span><br><span class="line">Loading mirror speeds from cached hostfile                                                                                             </span><br><span class="line"> * base: mirror.jdcloud.com                                                                                                            </span><br><span class="line"> * extras: mirrors.163.com                                                                                                             </span><br><span class="line"> * updates: mirrors.163.com                                                                                                            </span><br><span class="line">软件包 subversion-1.7.14-14.el7.x86_64 已安装并且是最新版本                                                                            </span><br><span class="line">无须任何处理                                                                                                                           </span><br><span class="line">[root@centos /]<span class="comment"># svnadmin create /svn/project</span></span><br><span class="line">[root@centos /]<span class="comment"># cd /svn/SwiftProject      </span></span><br><span class="line">[root@centos SwiftProject]<span class="comment"># pwd                                                                                                        </span></span><br><span class="line">/svn/SwiftProject                                                                                                                      </span><br><span class="line">[root@centos SwiftProject]<span class="comment"># ls                                                                                                         </span></span><br><span class="line">conf  db  format  hooks  locks  README.txt                                                                                             </span><br><span class="line">[root@centos SwiftProject]<span class="comment"># cd conf/                                                                                                   </span></span><br><span class="line">[root@centos conf]<span class="comment"># ls                                                                                                                 </span></span><br><span class="line">authz  passwd  svnserve.conf                                                                                                           </span><br><span class="line">[root@centos conf]<span class="comment"># vi svnserve.conf                                                                                                   </span></span><br><span class="line">[root@centos conf]<span class="comment"># vim authz                                                                                                          </span></span><br><span class="line">[root@centos conf]<span class="comment"># vim passwd                                                                                                    </span></span><br><span class="line">[root@centos conf]<span class="comment"># cd /                                                                                                    </span></span><br><span class="line">[root@centos /]<span class="comment"># svnserve -d -r /svn --listen-host 172.20.10.2</span></span><br></pre></td></tr></table></figure><h6 id="内外网访问和Co"><a href="#内外网访问和Co" class="headerlink" title="内外网访问和Co"></a>内外网访问和Co</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn co svn://172.20.10.2/SwiftProject</span><br></pre></td></tr></table></figure><p>然后就是根据需求创建项目提交或拉去代码</p><h2 id="7-Centos配置GitLab服务器"><a href="#7-Centos配置GitLab服务器" class="headerlink" title="7.Centos配置GitLab服务器"></a>7.Centos配置GitLab服务器</h2><ul><li><ol><li>安装依赖软件</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install policycoreutils openssh-server openssh-clients postfix</span><br></pre></td></tr></table></figure><ul><li>2.设置postfix开机自启，并启动，postfix支持gitlab发信功能</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> postfix &amp;&amp; systemctl start postfix</span><br></pre></td></tr></table></figure><ul><li><p>3.下载gitlab安装包，然后安装</p><ul><li><a href="https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el6" target="_blank" rel="noopener">centos 6系统的下载地址</a></li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7" target="_blank" rel="noopener">centos 7系统的下载地址</a></li></ul></li></ul><p>我的是centos7,所以我在<a href="https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7中找了个gitlab8.0.0版本,建议下载一个比较新的版本,我这里选了一个比较旧的版本仅仅是实验" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7中找了个gitlab8.0.0版本,建议下载一个比较新的版本,我这里选了一个比较旧的版本仅仅是实验</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">下载rpm包并安装:</span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/gitlab-ce-8.0.0-ce.0.el7.x86_64.rpm</span><br><span class="line">rpm -i gitlab-ce-8.0.0-ce.0.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><ul><li>4.修改gitlab配置文件指定服务器ip和自定义端口：</li></ul><blockquote><p>vim  /etc/gitlab/gitlab.rb</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Url on which GitLab will be reachable.                                  </span></span><br><span class="line"><span class="comment">## For more details on configuring external_url see:                       </span></span><br><span class="line"><span class="comment">## https://gitlab.com/gitlab-org/omnibus-gitlab/blob/629def0a7a26e7c2326566</span></span><br><span class="line">f0758d4a27857b52a3/README.md<span class="comment">#configuring-the-external-url-for-gitlab       </span></span><br><span class="line">external_url <span class="string">'http://172.20.10.2:8081'</span></span><br></pre></td></tr></table></figure><p>最后，退出并保存</p><blockquote><p>注: 这里设置的端口不能被占用，默认是8080端口，如果8080已经使用，请自定义其它端口，并在防火墙设置开放相对应得端口</p></blockquote><ul><li>5.重置并启动GitLab</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br><span class="line">gitlab-ctl restart</span><br></pre></td></tr></table></figure><p>提示“ok: run:”表示启动成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ok: run: gitlab-git-http-server: (pid 3922) 1s</span><br><span class="line">ok: run: logrotate: (pid 3929) 0s</span><br><span class="line">ok: run: nginx: (pid 3936) 1s</span><br><span class="line">ok: run: postgresql: (pid 3941) 0s</span><br><span class="line">ok: run: redis: (pid 3950) 0s</span><br><span class="line">ok: run: sidekiq: (pid 3955) 0s</span><br><span class="line">ok: run: unicorn: (pid 3961) 1s</span><br></pre></td></tr></table></figure><ul><li>6.访问 GitLab页面</li></ul><p>如果没有域名，直接输入服务器ip和指定端口进行访问,会出现如下页面并提示：You need to sign in before continuing. </p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/centos/config/gitlabcreate.png" alt="曹理鹏(iCocos)-梦工厂"> </p><h5 id="初始账户-root-密码-5iveL-fe"><a href="#初始账户-root-密码-5iveL-fe" class="headerlink" title="初始账户: root 密码: 5iveL!fe"></a>初始账户: root 密码: 5iveL!fe</h5><p>注意，第一次登录最好修改密码</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/centos/config/gitlabcreate1.png" alt="曹理鹏(iCocos)-梦工厂"> </p><p>修改完成之后，就可以创建项目或者根据具体需求创建分组</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/centos/config/gitlabcreate2.png" alt="曹理鹏(iCocos)-梦工厂"> </p><ul><li>7.设置gitlab发信功能，需要注意一点：</li></ul><blockquote><p>发信系统用的默认的postfix，smtp是默认开启的，两个都启用了，两个都不会工作。</p></blockquote><p>我这里设置关闭smtp，开启postfix</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">关闭smtp方法：vim /etc/gitlab/gitlab.rb</span><br><span class="line">找到<span class="comment">#gitlab_rails['smtp_enable'] = true 改为 gitlab_rails['smtp_enable'] = false</span></span><br></pre></td></tr></table></figure><h5 id="修改后执行gitlab-ctl-reconfigure"><a href="#修改后执行gitlab-ctl-reconfigure" class="headerlink" title="修改后执行gitlab-ctl reconfigure"></a>修改后执行gitlab-ctl reconfigure</h5><p>另一种是关闭postfix，设置开启smtp</p><pre><code>+ 相关教程请参考[官网](https://doc.gitlab.cc/omnibus/settings/smtp.html)</code></pre><h4 id="测试是否可以邮件通知："><a href="#测试是否可以邮件通知：" class="headerlink" title="测试是否可以邮件通知："></a>测试是否可以邮件通知：</h4><p>登录并添加一个用户，我这里使用qq邮箱添加一个用户</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/centos/config/gitlabcreate3.png" alt="曹理鹏(iCocos)-梦工厂"> </p><p>创建成功后，就可以去对应的邮箱查看邮件并设置密码</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/centos/config/gitlabcreate4.png" alt="曹理鹏(iCocos)-梦工厂"> </p><p>登录qq邮箱，可以收到邮件通知（如果收不到，请查看垃圾邮箱或者检查邮件是否被拦截并删除，如果有请添加到白名单并删除用户再重新添加用户就可以收到了，否则请检查邮件日志并做好相关设置）</p><blockquote><p>到此，GitLab就基本配置完毕，如果有需要和可以结合GitLab，Jenkins，Fastlane实现CI和CD，当然这些一般的小公司不太会用到……</p></blockquote><h5 id="错误一：报错502"><a href="#错误一：报错502" class="headerlink" title="错误一：报错502"></a>错误一：报错502</h5><blockquote><p>gitlab报502 Whoops, GitLab is taking too much time to respond</p></blockquote><p>配置启动后，访问gitlab，出现：502 ，Whoops, GitLab is taking too much time to respond. 出现这个问题，一般都是你本机的8080端口已经被其他的应用程序占用。</p><ul><li>方法一：</li></ul><blockquote><p>GitLab在使用的过程中，会开启8080端口，但是如果8080端口被其他的应用程序占用，则GitLab的该项服务不能使用，所以访问GitLab会失败。</p></blockquote><ul><li>方法二：</li></ul><blockquote><p>一般是权限问题，解决方法：chmod -R 755 /var/log/gitlab</p></blockquote><p>如果还不行，请检查你的内存，安装使用GitLab需要至少4GB可用内存(RAM + Swap)! 由于操作系统和其他正在运行的应用也会使用内存, 所以安装GitLab前一定要注意当前服务器至少有4GB的可用内存. 少于4GB内存会出现各种诡异的问题, 而且在使用过程中也经常会出现500错误.</p><h5 id="错误二：gitlab-ctl-reconfigure"><a href="#错误二：gitlab-ctl-reconfigure" class="headerlink" title="错误二：gitlab-ctl reconfigure"></a>错误二：gitlab-ctl reconfigure</h5><p> 报错n itdb: could not obtain information about current user: Permission denied</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error executing action `run` on resource <span class="string">'execute[/opt/gitlab/embedded/bin/initdb -D /var/opt/gitlab/postgresql/data -E UTF8]'</span></span><br></pre></td></tr></table></figure><p>根据报错信息大概锁定用户的权限问题,安装gitlab-ce会自动添加用户四个用户:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gitlab-www:x:497:498::/var/opt/gitlab/nginx:/bin/<span class="literal">false</span></span><br><span class="line">git:x:496:497::/var/opt/gitlab:/bin/sh</span><br><span class="line">gitlab-redis:x:495:496::/var/opt/gitlab/redis:/bin/nologin</span><br><span class="line">gitlab-psql:x:494:495::/var/opt/gitlab/postgresql:/bin/sh</span><br></pre></td></tr></table></figure><p>google和百度都搜索不到解决方法,既然出错提示到权限问题，那么按照这个方向去查就不会有问题，后来查了文件/etc/passwd的权限是600,给予644权限后,成功解决报错问题</p><h6 id="改成8081"><a href="#改成8081" class="headerlink" title="改成8081"></a>改成8081</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gitlab-ctl stop </span></span><br><span class="line"><span class="comment"># vi /etc/gitlab/gitlab.rb   (取消注释并修改端口) unicorn['port'] = 8801 </span></span><br><span class="line"><span class="comment"># gitlab-ctl reconfigure  (重新生成配置) </span></span><br><span class="line"><span class="comment"># gitlab-ctl restart </span></span><br><span class="line"><span class="comment"># lsof -i:8081(check whether unicorn has started properly)</span></span><br></pre></td></tr></table></figure><h2 id="8-Centos配置PHP各种拓展-Composer"><a href="#8-Centos配置PHP各种拓展-Composer" class="headerlink" title="8.Centos配置PHP各种拓展: Composer"></a>8.Centos配置PHP各种拓展: Composer</h2><p>推荐composer官方更多教程与配置：<a href="https://www.phpcomposer.com/" target="_blank" rel="noopener">https://www.phpcomposer.com/</a></p><p>需要使用到curl，如果没有的话需要 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum  -y install curl     <span class="comment">###安装</span></span><br></pre></td></tr></table></figure><h5 id="下载composer-phar"><a href="#下载composer-phar" class="headerlink" title="下载composer.phar"></a>下载composer.phar</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sS https://getcomposer.org/installer | php</span><br></pre></td></tr></table></figure><h5 id="把composer-phar移动到环境下让其变成可执行"><a href="#把composer-phar移动到环境下让其变成可执行" class="headerlink" title="把composer.phar移动到环境下让其变成可执行"></a>把composer.phar移动到环境下让其变成可执行</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv composer.phar /usr/<span class="built_in">local</span>/bin/composer</span><br></pre></td></tr></table></figure><h5 id="测试composer"><a href="#测试composer" class="headerlink" title="测试composer"></a>测试composer</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">composer -V </span><br><span class="line">/** 输出：Composer version 1.0-dev (e64470c987fdd6bff03b85eed823eb4b865a4152) 2015-05-28 14:52:12 */</span><br></pre></td></tr></table></figure><h5 id="实战操作"><a href="#实战操作" class="headerlink" title="实战操作"></a>实战操作</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@centos /]<span class="comment"># curl -sS https://getcomposer.org/installer | php</span></span><br><span class="line">All settings correct <span class="keyword">for</span> using Composer                                    </span><br><span class="line">Downloading...</span><br><span class="line"></span><br><span class="line">Composer (version 1.8.0) successfully installed to: //composer.phar</span><br><span class="line">Use it: php composer.phar</span><br><span class="line"></span><br><span class="line">[root@centos /]<span class="comment"># mv composer.phar /usr/local/bin/composer</span></span><br><span class="line">[root@centos ~]<span class="comment"># composer -V </span></span><br><span class="line">Do not run Composer as root/super user! See https://getcomposer.org/root <span class="keyword">for</span> details</span><br><span class="line">Composer version 1.8.0 2018-12-03 10:31:16</span><br></pre></td></tr></table></figure><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><ul><li><a href="http://blog.51cto.com/ixdba/806622" target="_blank" rel="noopener">实战Nginx与PHP（FastCGI）的安装、配置与优化</a></li><li><a href="https://www.cnblogs.com/chensiqiqi/p/9162958.html" target="_blank" rel="noopener">Nginx站点目录及文件URL访问控制</a></li></ul>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器配置——实战验证与补充</title>
      <link href="/2018/03/09/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81%E4%B8%8E%E8%A1%A5%E5%85%85/"/>
      <url>/2018/03/09/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81%E4%B8%8E%E8%A1%A5%E5%85%85/</url>
      <content type="html"><![CDATA[<p> 下面关于之前一些流程（Ngnix，Php，Go，Mysql）安装配置与使用的一些总结，和遇到的一个坑，其中也有关于服务器配置与部署，代码上传与发布相关内容，主要是为了熟悉整个流程……</p><a id="more"></a><blockquote><p>这里补充一下前面没有提到，但是实际操作会用到或者能提升效率的东西</p></blockquote><h2 id="安装ftp"><a href="#安装ftp" class="headerlink" title="安装ftp"></a>安装ftp</h2><p>大家看到了，所有的文件操作在ssh中可以通过vim方法来实现，但是，你知道在windows中用惯了，还是喜欢看图形界面，所以在这里我安装了ftp可以远程来上传修改文件</p><pre><code>软件：winscp（百度下载就好了）</code></pre><h3 id="安装vsftpd"><a href="#安装vsftpd" class="headerlink" title="安装vsftpd"></a>安装vsftpd</h3><pre><code>yum install vsftpd</code></pre><h3 id="启动-重启-关闭vsftpd服务器"><a href="#启动-重启-关闭vsftpd服务器" class="headerlink" title="启动/重启/关闭vsftpd服务器"></a>启动/重启/关闭vsftpd服务器</h3><pre><code>[root@localhost ftp]# /sbin/service vsftpd restartShutting down vsftpd: [ OK ]Starting vsftpd for vsftpd: [ OK ] </code></pre><p>OK表示重启成功了.</p><p>这里现在就可以直接使用root及你的密码来查看了，当然这样的是超级用户，留给自己用的，要配置指定要文件夹的用户，我就在不在这里写了，大家继续百度下吧</p><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><pre><code>sudo apt-get updatesudo apt-get install git</code></pre>]]></content>
      
      <categories>
          
          <category> Server </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Server </tag>
            
            <tag> 服务器配置——实战验证与补充 </tag>
            
            <tag> 实战验证与补充 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器配置——Redis安装，配置，简单使用</title>
      <link href="/2018/03/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94Redis%E5%AE%89%E8%A3%85%EF%BC%8C%E9%85%8D%E7%BD%AE%EF%BC%8C%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/03/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94Redis%E5%AE%89%E8%A3%85%EF%BC%8C%E9%85%8D%E7%BD%AE%EF%BC%8C%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>本文是因为在做API接口开发的时候，要数据每次都需要从数据读取而写，那样太耗性能了，其实类型iOS中的Cache或者NSUserDefault，用法都和NSUserDefault类似….</p><a id="more"></a><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载安装包 redis-3.2.8.tar.gz</p><pre><code>官网地址：http://redis.io/download</code></pre><p>解压：</p><pre><code>tar -zvxf redis-3.2.8.tar.gz  将解压后的文件夹放到 /Users/local目录下</code></pre><p>编译测试:接下来在终端中切换到/Users/local/redis目录下,输入：sudo make test</p><pre><code>编译安装：在终端中输入命令：sudo make install</code></pre><p>启动Redis,输入命令redis-server</p><pre><code>redis-server78407:C 18 Apr 21:32:31.361 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf78407:M 18 Apr 21:32:31.362 * Increased maximum number of open files to 10032 (it was originally set to 256)._._                                                  _.-``__ &apos;&apos;-._                                             _.-``    `.  `_.  &apos;&apos;-._           Redis 3.2.8 (00000000/0) 64 bit.-`` .-```.  ```\/    _.,_ &apos;&apos;-._                                   (    &apos;      ,       .-`  | `,    )     Running in standalone mode|`-._`-...-` __...-.``-._|&apos;` _.-&apos;|     Port: 6379|    `-._   `._    /     _.-&apos;    |     PID: 78407`-._    `-._  `-./  _.-&apos;    _.-&apos;                                   |`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|                                  |    `-._`-._        _.-&apos;_.-&apos;    |           http://redis.io        `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;                                   |`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|                                  |    `-._`-._        _.-&apos;_.-&apos;    |                                  `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;                                   `-._    `-.__.-&apos;    _.-&apos;                                       `-._        _.-&apos;                                           `-.__.-&apos;                                               78407:M 18 Apr 21:32:31.363 # Server started, Redis version 3.2.878407:M 18 Apr 21:32:31.364 * DB loaded from disk: 0.001 seconds78407:M 18 Apr 21:32:31.364 * The server is now ready to accept connections on port 6379</code></pre><p>看到这个界面表示我们已经成功的安装Redis。</p><h2 id="二配置"><a href="#二配置" class="headerlink" title="二配置"></a>二配置</h2><h3 id="1、在-Users-local-redis目录下建立bin，etc，db三个目录"><a href="#1、在-Users-local-redis目录下建立bin，etc，db三个目录" class="headerlink" title="1、在 /Users/local/redis目录下建立bin，etc，db三个目录"></a>1、在 /Users/local/redis目录下建立bin，etc，db三个目录</h3><h3 id="2、把-Users-local-redis-src目录下的mkreleasehdr-sh，redis-benchmark，-redis-cli，-redis-server拷贝到bin目录"><a href="#2、把-Users-local-redis-src目录下的mkreleasehdr-sh，redis-benchmark，-redis-cli，-redis-server拷贝到bin目录" class="headerlink" title="2、把/Users/local/redis/src目录下的mkreleasehdr.sh，redis-benchmark， redis-cli， redis-server拷贝到bin目录"></a>2、把/Users/local/redis/src目录下的mkreleasehdr.sh，redis-benchmark， redis-cli， redis-server拷贝到bin目录</h3><h3 id="3、在etc下，参考原-Users-local-redis目录下的redis-conf，新建一个redis-conf"><a href="#3、在etc下，参考原-Users-local-redis目录下的redis-conf，新建一个redis-conf" class="headerlink" title="3、在etc下，参考原/Users/local/redis目录下的redis.conf，新建一个redis.conf"></a>3、在etc下，参考原/Users/local/redis目录下的redis.conf，新建一个redis.conf</h3><p>修改redis.conf，具体如下：</p><pre><code>#修改为守护模式daemonize yes#设置进程锁文件pidfile /Users/local/redis/redis.pid#端口port 6379#客户端超时时间timeout 300#日志级别loglevel debug#日志文件位置logfile /Users/local/redis/log-redis.log#设置数据库的数量，默认数据库为16，可以使用SELECT 命令在连接上指定数据库iddatabases 16##指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合#save#Redis默认配置文件中提供了三个条件：save 900 1save 300 10save 60 10000#指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，#可以关闭该#选项，但会导致数据库文件变的巨大rdbcompression yes#指定本地数据库文件名dbfilename dump.rdb#指定本地数据库路径dir /Users/local/redis/db/#指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能#会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有#的数据会在一段时间内只存在于内存中appendonly no#指定更新日志条件，共有3个可选值：#no：表示等操作系统进行数据缓存同步到磁盘（快）#always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）#everysec：表示每秒同步一次（折衷，默认值）appendfsync everysec</code></pre><p>其实只需要拷贝，然后修改对应的值就可以</p><h3 id="4、保存后，启动redis：-bin-redis-server-etc-redis-conf"><a href="#4、保存后，启动redis：-bin-redis-server-etc-redis-conf" class="headerlink" title="4、保存后，启动redis：./bin/redis-server etc/redis.conf"></a>4、保存后，启动redis：./bin/redis-server etc/redis.conf</h3><p>注意这里log-redis.log文件需要我自己创建</p><pre><code>iCocosdeMacBook-Pro:redis icocos$ redis-server etc/redis.conf回车之后没有输出说明成功了</code></pre><h3 id="5、查看日志文件：tail-f-log-redis-log"><a href="#5、查看日志文件：tail-f-log-redis-log" class="headerlink" title="5、查看日志文件：tail -f log-redis.log"></a>5、查看日志文件：tail -f log-redis.log</h3><pre><code>|    `-._`-._        _.-&apos;_.-&apos;    |                                  `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;                                   `-._    `-.__.-&apos;    _.-&apos;                                       `-._        _.-&apos;                                           `-.__.-&apos;                                               78584:M 18 Apr 21:48:02.777 # Server started, Redis version 3.2.878584:M 18 Apr 21:48:02.777 * The server is now ready to accept connections on port 637978584:M 18 Apr 21:48:02.779 - 0 clients connected (0 slaves), 957072 bytes in use</code></pre><p>到这里，我们已经完成redis安装和配置。</p><h2 id="三使用"><a href="#三使用" class="headerlink" title="三使用"></a>三使用</h2><h3 id="1、检查是否启动：redis-cli-ping"><a href="#1、检查是否启动：redis-cli-ping" class="headerlink" title="1、检查是否启动：redis-cli ping"></a>1、检查是否启动：redis-cli ping</h3><h3 id="2、redis-cli"><a href="#2、redis-cli" class="headerlink" title="2、redis-cli"></a>2、redis-cli</h3><h3 id="3、ping"><a href="#3、ping" class="headerlink" title="3、ping"></a>3、ping</h3><h3 id="4、redis-cli-跟上命令会将参数发送到本地redis-6379-的端口，下面来看看基本操作："><a href="#4、redis-cli-跟上命令会将参数发送到本地redis-6379-的端口，下面来看看基本操作：" class="headerlink" title="4、redis-cli 跟上命令会将参数发送到本地redis 6379 的端口，下面来看看基本操作："></a>4、redis-cli 跟上命令会将参数发送到本地redis 6379 的端口，下面来看看基本操作：</h3><p>使用方式</p><pre><code>iCocosdeMacBook-Pro:redis icocos$ redis-cli127.0.0.1:6379&gt; pingPONG127.0.0.1:6379&gt; set key1 nameOK127.0.0.1:6379&gt; get key1&quot;name&quot;</code></pre><h3 id="5、关闭命令：redis-cli-shutdown"><a href="#5、关闭命令：redis-cli-shutdown" class="headerlink" title="5、关闭命令：redis-cli shutdown"></a>5、关闭命令：redis-cli shutdown</h3><pre><code>上面我们演示了redis安装与配置，接下来后面的工作在真实上线之前只需要熟练redis的使用就差不多了，注意细节，并应用到实战，没错就这么简单！</code></pre><h2 id="四-服务器配置"><a href="#四-服务器配置" class="headerlink" title="四.服务器配置"></a>四.服务器配置</h2><p>上面只是基本的安装，如果要用到生产环境，得配置一些文件</p><h3 id="1-首先把redis-cli-移动到-Users-local-bin-目录，方便执行，和JAVA-HOME-类似"><a href="#1-首先把redis-cli-移动到-Users-local-bin-目录，方便执行，和JAVA-HOME-类似" class="headerlink" title="1.首先把redis-cli 移动到/Users/local/bin 目录，方便执行，和JAVA_HOME 类似"></a>1.首先把redis-cli 移动到/Users/local/bin 目录，方便执行，和JAVA_HOME 类似</h3><pre><code>默认install 的时候已经有了</code></pre><h3 id="2-创建你存放配置文件和数据文件的目录"><a href="#2-创建你存放配置文件和数据文件的目录" class="headerlink" title="2.创建你存放配置文件和数据文件的目录"></a>2.创建你存放配置文件和数据文件的目录</h3><pre><code>sudomkdir /etc/redissudo mkdir /var/redis</code></pre><h3 id="3-复制初始化脚本到-etc-init-d-目录-建议默认只有这个端口-作开机启动"><a href="#3-复制初始化脚本到-etc-init-d-目录-建议默认只有这个端口-作开机启动" class="headerlink" title="3.复制初始化脚本到/etc/init.d 目录,建议默认只有这个端口,作开机启动"></a>3.复制初始化脚本到/etc/init.d 目录,建议默认只有这个端口,作开机启动</h3><pre><code>$ sudocp utils/redis_init_script /etc/init.d/redis_6379</code></pre><h3 id="4-进入脚本-确保你的REDISPORT-是你正在使用的"><a href="#4-进入脚本-确保你的REDISPORT-是你正在使用的" class="headerlink" title="4.进入脚本,确保你的REDISPORT 是你正在使用的"></a>4.进入脚本,确保你的REDISPORT 是你正在使用的</h3><pre><code>sudovi /etc/init.d/redis_6379</code></pre><h3 id="5-复制redis-conf-和脚本保持一致"><a href="#5-复制redis-conf-和脚本保持一致" class="headerlink" title="5.复制redis.conf ,和脚本保持一致"></a>5.复制redis.conf ,和脚本保持一致</h3><pre><code>sudocp redis.conf /etc/redis/6379.conf</code></pre><h3 id="6-创建一个存放工作数据的目录"><a href="#6-创建一个存放工作数据的目录" class="headerlink" title="6.创建一个存放工作数据的目录"></a>6.创建一个存放工作数据的目录</h3><pre><code>sudomkdir /var/redis/6379</code></pre><p>同时可以对redis.conf配置其他属性</p><pre><code># 来源：http://www.cnblogs.com/shanyou/archive/2012/01/28/2330451.htmldaemonize：是否以后台daemon方式运行pidfile：pid文件位置port：监听的端口号timeout：请求超时时间loglevel：log信息级别logfile：log文件位置databases：开启数据库的数量save **：保存快照的频率，第一个*表示多长时间，第三个*表示执行多少次写操作。在一定时间内执行一定数量的写操作时，自动保存快照。可设置多个条件。rdbcompression：是否使用压缩dbfilename：数据快照文件名（只是文件名，不包括目录）dir：数据快照的保存目录（这个是目录）appendonly：是否开启appendonlylog，开启的话每次写操作会记一条log，这会提高数据抗风险能力，但影响效率。appendfsync：appendonlylog如何同步到磁盘（三个选项，分别是每次写都强制调用fsync、每秒启用一次fsync、不调用fsync等待系统自己同步）</code></pre><h3 id="7-最后将脚本设置默认启动"><a href="#7-最后将脚本设置默认启动" class="headerlink" title="7.最后将脚本设置默认启动"></a>7.最后将脚本设置默认启动</h3><pre><code>sudoupdate-rc.d redis_6379 defaults</code></pre><h3 id="8-现在可以执行脚本了"><a href="#8-现在可以执行脚本了" class="headerlink" title="8.现在可以执行脚本了"></a>8.现在可以执行脚本了</h3><pre><code>/etc/init.d/redis_6379start</code></pre><h2 id="五-MAC-版本差异"><a href="#五-MAC-版本差异" class="headerlink" title="五.MAC 版本差异"></a>五.MAC 版本差异</h2><p>一个不幸的事实是：mac 上是没有init.d 目录的，mac启动脚本是 以.plist 结尾了，</p><p>好吧，我在 ~/Library/LaunchAgents 目录下自己建立一个 redis.plist</p><p>参考：<a href="http://www.js2node.com/redis-io/install-redis-io-2-4-17-on-mac-osx-as-service" target="_blank" rel="noopener">http://www.js2node.com/redis-io/install-redis-io-2-4-17-on-mac-osx-as-service</a></p><pre><code>$ sudovi redis.plist</code></pre><p>然后输入以下内容</p><pre><code>Labelio.redis.redis-serverProgramArguments/Users/local/bin/redis-server/Users/local/etc/redis.confRunAtLoad</code></pre><p>执行命令</p><pre><code>$ sudo launchctlload/Library/LaunchDaemons/io.redis.redis-server.plist</code></pre><p>打开关闭：</p><pre><code>$ sudo launchctlstartio.redis.redis-server$ sudo launchctl stop io.redis.redis-server</code></pre><h2 id="六-brew-进行安装"><a href="#六-brew-进行安装" class="headerlink" title="六.brew 进行安装"></a>六.brew 进行安装</h2><p>下面我用brew来操作，关于brew 的安装我看的：<a href="http://my.oschina.net/liygheart/blog/284668" target="_blank" rel="noopener">http://my.oschina.net/liygheart/blog/284668</a></p><p>安装好了，然后 参考：<a href="https://gist.github.com/tonypujals/9631143" target="_blank" rel="noopener">https://gist.github.com/tonypujals/9631143</a></p><pre><code>$brew info redis</code></pre><p>会有提示，然后输入</p><pre><code>$ln -nfs /Users/local/opt/redis/*.plist ~/Library/LaunchAgents</code></pre><p>和</p><pre><code>$load ~/Library/LaunchAgents/homebrew.mxcl.redis.plist</code></pre><h2 id="网上还找到一种方式，貌似可以成功"><a href="#网上还找到一种方式，貌似可以成功" class="headerlink" title="网上还找到一种方式，貌似可以成功"></a>网上还找到一种方式，貌似可以成功</h2><p>1.获取github中的redis-php扩展代码：<br>    git clone <a href="https://github.com/phpredis/phpredis.git" target="_blank" rel="noopener">https://github.com/phpredis/phpredis.git</a></p><p>2.cd phpredis/</p><p>3.phpize mac os 如果这里有</p><pre><code>Cannot find autoconf. Please check your autoconf installation and the$PHP_AUTOCONF environment variable. Then, rerun this script.的问题，那么：执行：brew install autoconf</code></pre><p>4.之后执行phpize</p><p>5../configure</p><p>6.make &amp;&amp; sudo make install 输入密码就会提示成功</p><pre><code>Password:Installing shared extensions:     /usr/lib/php/extensions/no-debug-non-zts-20131226/</code></pre><p>7.之后在php.ini中加一句 extension=redis.so 就ok了</p><pre><code>路径：/etc/php.ini</code></pre><p>然后重启 apache/nginx 和 php-fpm ，输入命令：php -m |grep redis 或者通过 phpinfo() 输出php信息查看redis是否安装成功。</p><h3 id="期间我在执行install的时候出现这样的问题"><a href="#期间我在执行install的时候出现这样的问题" class="headerlink" title="期间我在执行install的时候出现这样的问题"></a>期间我在执行install的时候出现这样的问题</h3><p>装不了PHP的扩展，make install失败</p><pre><code>RudonMacBook:igbinary-master rudon$ make installInstalling shared extensions:     /usr/lib/php/extensions/no-debug-non-zts-20131226/cp: /usr/lib/php/extensions/no-debug-non-zts-20131226/#INST@12567#: Operation not permittedmake: *** [install-modules] Error 1cp: /usr/lib/php/extensions/no-debug-non-zts-20121212/#INST@17000#: Operation not permitted</code></pre><p>原因是</p><pre><code>原来是OSX 10.11 El Capitan（或更高）新添加了一个新的安全机制叫系统完整性保护System Integrity Protection (SIP)，所以对于目录/System/sbin/usr不包含(/usr/local/)仅仅供系统使用，其它用户或者程序无法直接使用，而我们的/usr/lib/php/extensions/刚好在受保护范围内</code></pre><p>所以解决方法就是禁掉SIP保护机制，步骤是：</p><pre><code>重启系统按住Command + R   （重新亮屏之后就开始按，象征地按几秒再松开，出现苹果标志，ok）菜单“实用工具” ==&gt;&gt; “终端” ==&gt;&gt; 输入csrutil disable；执行后会输出：Successfully disabled System Integrity Protection. Please restart the machine for the changes to take effect.再次重启系统禁止掉SIP后，就可以顺利的安装了，当然装完了以后你可以重新打开SIP，方法同上，只是命令是csrutil enable</code></pre><h2 id="平时使用"><a href="#平时使用" class="headerlink" title="平时使用"></a>平时使用</h2><pre><code>iCocosdeMacBook-Pro:redis icocos$ cd /Users/local/redisiCocosdeMacBook-Pro:redis icocos$ redis-server78728:C 18 Apr 22:00:25.105 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf78728:M 18 Apr 22:00:25.107 * Increased maximum number of open files to 10032 (it was originally set to 256)._._                                                  _.-``__ &apos;&apos;-._                                             _.-``    `.  `_.  &apos;&apos;-._           Redis 3.2.8 (00000000/0) 64 bit.-`` .-```.  ```\/    _.,_ &apos;&apos;-._                                   (    &apos;      ,       .-`  | `,    )     Running in standalone mode|`-._`-...-` __...-.``-._|&apos;` _.-&apos;|     Port: 6379|    `-._   `._    /     _.-&apos;    |     PID: 78728`-._    `-._  `-./  _.-&apos;    _.-&apos;                                   |`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|                                  |    `-._`-._        _.-&apos;_.-&apos;    |           http://redis.io        `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;                                   |`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|                                  |    `-._`-._        _.-&apos;_.-&apos;    |                                  `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;                                   `-._    `-.__.-&apos;    _.-&apos;                                       `-._        _.-&apos;                                           `-.__.-&apos;                                               78728:M 18 Apr 22:00:25.108 # Server started, Redis version 3.2.878728:M 18 Apr 22:00:25.108 * DB loaded from disk: 0.000 seconds78728:M 18 Apr 22:00:25.108 * The server is now ready to accept connections on port 6379^C78728:signal-handler (1492524027) Received SIGINT scheduling shutdown...78728:M 18 Apr 22:00:27.286 # User requested shutdown...78728:M 18 Apr 22:00:27.286 * Saving the final RDB snapshot before exiting.78728:M 18 Apr 22:00:27.288 * DB saved on disk78728:M 18 Apr 22:00:27.288 # Redis is now ready to exit, bye bye...iCocosdeMacBook-Pro:redis icocos$ redis-cli127.0.0.1:6379&gt; pingPONG127.0.0.1:6379&gt; set key1 nameOK127.0.0.1:6379&gt; get key1&quot;name&quot;127.0.0.1:6379&gt; </code></pre><h3 id="PHP中使用的话"><a href="#PHP中使用的话" class="headerlink" title="PHP中使用的话"></a>PHP中使用的话</h3><pre><code>&lt;?php$redis = new Redis();$redis-&gt;connect(&apos;127.0.0.1&apos;, 6379);$redis-&gt;set(&apos;iCocos&apos;,1234);$redis-&gt;get(&apos;iCocos&apos;);</code></pre><p>执行PHP文件，可以直接网页执行，也可以直接命令执行，方法基本上类似.</p><h2 id="Redis基本命令"><a href="#Redis基本命令" class="headerlink" title="Redis基本命令"></a>Redis基本命令</h2><p>Redis数据类型及操作:</p><pre><code>String:指令:{    set    setnx       :如果key已经存在, 返回0    setex       :指定键值对的有效期, setex [key] [expire] [value]   /类似于:set [key] [value] [EX expire]    setrange    :设置key-value值的子字符串,下标从0开始到第i位置,不包含i    mset    msetnx    get    getset    getrange    mget    incr    incrby    decr    decrby    append    strlen}</code></pre><p>Hash:是一个string类型的field-value的映射表,它的添加删除平均都是O(1)的效率</p><pre><code>指令:{    hset    hsetnx    hmset    hget    hmget    hincrby    hexists    hlen    hdel    hkeys    hvals    hgetall}</code></pre><p>List:是一个链表结构, 主要功能是pop,push,获取一个范围的所有值等,key理解为链表的名字<br>list类型其实就是每一个子元素都是string类型的双向链表.</p><pre><code>指令:{    lpush       rpush    linsert   : linsert key [BEFORE|AFTER] [pivot] [value]    在list的特定的值的位置之前或之后添加字符串元素    lset      : lset key [index] [value] 设置list中指定下标的元素值    lrem      : lrem key [count] [value] 从list中删除count个和value相同的元素    count&gt;0,从头删除;    count=0,全部删除;    count&lt;0,从尾删除;    ltrim     : ltrim key [start] [stop] 保留key的值中指定范围内的数据    lpop      : 从list的头部删除元素    rpop      : 从list的尾部删除元素    rpoplpush : rpoplpush [source] [destination], 整个操作是原子的    从source的尾部移除元素,并添加到destination的头部,返回被移除的元素值    lindex    : lindex key [index] 取list中index位置的元素    llen      : 返回key对应list的长度}</code></pre><p>Set: 指令:{}</p><p>键值指令:</p><pre><code>[     keys :返回给定pattern的所有key    exists: 确认一个key是否存在    del : 删除一个key    expire : 设置一个key的过期时间(秒为单位)    ttl : 用于获取key的有效时长    persist : 移除给定key的过期时间    move : 把当前数据库中的key移动到其它库中    rename : 重命名key]</code></pre><p>服务指令:</p><pre><code>[    select :选择数据库存取, redis数据库编号从 0~15 默认16个库    dbsize :获取当前数据库的key    info :  获取服务器的信息和统计,用于说明服务器的基础信息,包括版本启动时间等;    config get: 获取服务器配置信息    flushdb : 删除当前选择数据库中的所有key    flushall : 删除所有库中的所有key]</code></pre><p>主从复制基本配置:</p><pre><code>Redis主从复制中一个主服务可以有多个服务, 一个从服务可以有多个从服务;对应配置,只需要修改redis.conf中的slaveof参数#slaveof &lt;masterip&gt; &lt;masterport&gt;slaveof 127.0.0.1 6379</code></pre><p>启动master</p><pre><code>#redis-server /usr/local/redis/conf/redis_6379.conf#redis-cli启动slave(假设端口3689)#redis-server /usr/local/redis/conf/slave.conf#redis-cli -p 6389</code></pre><p>如果master服务设置有密码,则需要配置masterauth参数</p><pre><code>masterauth &lt;master-password&gt;</code></pre><p>查看redis连接数</p><pre><code>redis-cli info | grep connected</code></pre><p>如果客户端的idle空闲时间太长,连接池维持了太多的连接,则需要把不用的连接及时释放掉;</p><pre><code>redis 127.0.0.1:6379&gt; client listredis 127.0.0.1:6379&gt; CONFIG SET timeout 30</code></pre><p>Cluster集群配置</p><pre><code>cluster-enabled yes 开启</code></pre><p>每一个集群节点有一个集群配置文件;它不是手工创建的,是redis节点创建和更新的;</p><h3 id="确保同一系统上运行的redis集群节点的配置文件名不重叠"><a href="#确保同一系统上运行的redis集群节点的配置文件名不重叠" class="headerlink" title="确保同一系统上运行的redis集群节点的配置文件名不重叠"></a>确保同一系统上运行的redis集群节点的配置文件名不重叠</h3><ol><li><p>redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件,</p><p> 并且在此基础上实现了master-slave(主从)同步</p></li><li><p>pipeline 压缩请求数量</p><p> pipeline机制将多个命令汇聚到一个请求中,可以有效减少请求数量,减少网络延时。</p></li><li><p>script 压缩复杂请求</p><p> script核心思想是在redis命令里嵌入Lua脚本,来实现一些复杂操作。</p></li><li><p>cluster</p><p> Redis 集群不像单机版本的 Redis 那样支持多个数据库，集群只有数据库 0，而且也不支持 SELECT 命令。</p></li></ol><p>学习Redis命令请参考</p><p><a href="http://www.redis.cn/" target="_blank" rel="noopener">http://www.redis.cn/</a><br><a href="http://www.cnblogs.com/woshimrf/p/5198361.html" target="_blank" rel="noopener">http://www.cnblogs.com/woshimrf/p/5198361.html</a></p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器配置——Php安装与配置</title>
      <link href="/2018/02/19/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94Php%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/02/19/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94Php%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p> 由于之前学过一段时间的Php，偶尔看到一个不错的东西也会尝试一下，虽然可能最终结果和意义并不大，但是此次我还是觉决定让服务器支持Php，同时也会适当的更新一些Php的内容（能力有限，都是比较基础的内容）……</p> <a id="more"></a><blockquote><p>说了服务器第一步Ngnix安装与配置之后，就要开始说说关于PHP和Go的安装与配置</p></blockquote><h2 id="配置php-fpm部分"><a href="#配置php-fpm部分" class="headerlink" title="配置php-fpm部分"></a>配置php-fpm部分</h2><p>要让 nginx 能够执行 php 文件，需要去安装一下 php-fpm，它直接包含在了 CentOS 资源库里，所以直接使用 yum 命令可以安装它：</p><pre><code>yum install php-fpm</code></pre><p>完成以后，可以检查一下 php-fpm 的运行状态，使用 service 命令：</p><pre><code>service php-fpm status</code></pre><p>返回：</p><pre><code>php-fpm is stopped（php-fpm 已停止）</code></pre><p>启动 php-fpm 同样可以使用 service 命令：</p><pre><code>service php-fpm start</code></pre><h2 id="让-nginx-可以执行-php"><a href="#让-nginx-可以执行-php" class="headerlink" title="让 nginx 可以执行 php"></a>让 nginx 可以执行 php</h2><p>现在我们应该就可以让 nginx 去执行 php 了。不过你需要修改一下 nginx 的配置文件，之前我们在配置虚拟主机的时候，创建了一个 nginx.ninghao.net.conf 的配置文件，需要去修改下 nginx 的这个配置文件，才能去执行 php 。使用 vim 命令去编辑它：</p><pre><code>vim /etc/nginx/conf.d/nginx.ninghao.net.conf</code></pre><p>注意你的配置文件不一定叫 nginx.ninghao.net.conf，应该是你自己命名的配置文件。打开以后，找到下面这段字样的代码：</p><pre><code># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000##location ~ \.php$ {#    root           html;#    fastcgi_pass   127.0.0.1:9000;#    fastcgi_index  index.php;#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;#    include        fastcgi_params;#}</code></pre><p>这是 nginx 默认给我们的用来执行 php 的配置，从 location 开始取消注释，会让这个配置生效，然后我们还得简单去修改一下：</p><pre><code># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000#location ~ \.php$ {#   root           html;    fastcgi_pass   127.0.0.1:9000;    fastcgi_index  index.php;    fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;    include        fastcgi_params;}</code></pre><p>注意 root 那里仍然是被注释掉的，还有 SCRIPT_FILENAME 后面修改了一下，把 /scripts 换成了 $document_root 。保存并退出。然后重新启动 nginx：</p><pre><code>service nginx restart</code></pre><h2 id="测试是否可以执行-php"><a href="#测试是否可以执行-php" class="headerlink" title="测试是否可以执行 php"></a>测试是否可以执行 php</h2><p>现在，我们已经安装了 php-fpm，并修改了 nginx 的配置文件让它可以去执行 php，下面，我们得去测试一下，可以使用 php 的 phpinfo(); 函数，方法是在你的虚拟主机根目录下面，创建一个 php 文件，命名为 phpinfo.php，然后在这个文件里输入：</p><pre><code>&lt;?php phpinfo(); ?&gt;</code></pre><p>保存文件并退出。在浏览器里打开刚才创建的这个 php 文件。我这里应该是 <code>http://nginx.ninghao.net/phpinfo.php</code>。打开以后，你应该能看到像下面这样的界面，如果能，说明 nginx 已经可以执行 php 了。</p><h2 id="配置扩展"><a href="#配置扩展" class="headerlink" title="配置扩展"></a>配置扩展</h2><blockquote><p>现在，我们有了可以提供 web 服务的 nginx ，并且安装了 php-fpm ，配置了 nginx 可以让它去执行 php ，也安装了数据库管理系统。</p></blockquote><p>不过在运行真正的网站的时候，我们还需要为 php 安装一些额外的扩展，比如 处理 mysql 数据库的 mysql 扩展，缓存功能的 apc 扩展，处理图像的 gd 扩展等等。安装它们同样可以使用 yum 命令。</p><pre><code>yum install php-pecl-apc php-mysql php-gd php-mcrypt php-pear php-mbstring php-xmlrpc php-dom</code></pre><p>上面安装了一些 php 的扩展，如果你发现在安装网站的时候提示需要安装其它的扩展，同样可以使用 yum 命令去安装。安装完成以后，需要重启一下 php-fpm ：</p><pre><code>service php-fpm restart</code></pre>]]></content>
      
      <categories>
          
          <category> Server </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Server </tag>
            
            <tag> 服务器配置——Php安装与配置 </tag>
            
            <tag> Php安装与配置 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器配置——MySql安装与配置</title>
      <link href="/2018/02/05/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94MySql%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/02/05/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94MySql%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>服务器好了之后，首先我们应该从数据库入手，因为一切没有数据交互与存储的服务器和客户端都只是娱乐，这里我们选择大部分人都熟知而且与PHP成为天和之作的Mysql，当然他和Go也一样兼容……</p><a id="more"></a><h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><p>mysql 可以管理网站用到的数据库，WordPress 和 Drupal 也都支持 mysql 数据库。所以我们的 Web 运行环境里，需要安装一个 mysql 。之前我们已经添加了资源库，所以可以直接使用 yum 命令去安装  mysql ：</p><pre><code>yum install mysql-server</code></pre><p>安装完成后，使用 service 命令启动 mysql 服务：</p><pre><code>service mysqld start</code></pre><p>然后我们需要简单配置一下 mysql ，默认安装以后 mysql 的 root 用户是没有密码的，对于生产环境来说，这肯定是不行的.</p><p>另外还有一些安全相关的设置，可以使用下面这行命令去配置一下，它是一个向导，问你一些问题，你要给出答案，比如是否要设置 root 用户的密码， 密码是什么等等。</p><pre><code>mysql_secure_installation</code></pre><p>然后根据实际情况进行配置，也可以看看下面比较常用的配置方案</p><pre><code>Enter current password for root (enter for none):解释：输入当前 root 用户密码，默认为空，直接回车。Set root password? [Y/n]  y解释：要设置 root 密码吗？输入 y 表示愿意。Remove anonymous users? [Y/n]  y解释：要移除掉匿名用户吗？输入 y 表示愿意。Disallow root login remotely? [Y/n]  n解释：不想让 root 远程登陆吗？输入 y 表示愿意。Remove test database and access to it? [Y/n]  y解释：要去掉 test 数据库吗？输入 y 表示愿意。Reload privilege tables now? [Y/n]  y解释：想要重新加载权限吗？输入 y 表示愿意。</code></pre>]]></content>
      
      <categories>
          
          <category> Server </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器配置——MySql安装与配置 </tag>
            
            <tag> Server </tag>
            
            <tag> MySql安装与配置 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器配置——Nginx安装与配置</title>
      <link href="/2018/01/23/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94Nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/01/23/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94Nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p> 配置完阿里控制台之后，首先我们开始配置服务器，我的服务器各种配置都需要自己重新配，这里我现在Ngnix，不要问我为什么选择他，可能是之前用过Apache，对他印象不好吧……</p> <a id="more"></a><p>前面说了关于阿里云主机操作，这里打算开始一步一步搭建和配置服务器，并且开始Go语言和后台学习，并且徐后续更新，直到后面的后台实战开发</p><blockquote><p>关于域名解析，实例，和安全组相关请自行参考阿里官方教程</p></blockquote><h2 id="如何连接服务器执行环境配置"><a href="#如何连接服务器执行环境配置" class="headerlink" title="如何连接服务器执行环境配置"></a>如何连接服务器执行环境配置</h2><blockquote><p>我使用的是centos6.8 64位版本，如果您不是第一次接触linux那一定知道，linux不是一个可视化界面的系统，所以要摒弃windows的操作习惯，我使用的xshell这个软件链接的服务器，连接语句是 ssh root@ip地址</p></blockquote><p>地址处就是写入你的ip地址，然后回车鞋面就会自动连接，弹框提示输入密码</p><ul><li>输入服务器的密码，点击确定即链接上了</li></ul><p>ok，下面就可以开始配置环境了，第一步我们先配置nginx</p><h2 id="nginx安装部分"><a href="#nginx安装部分" class="headerlink" title="nginx安装部分"></a>nginx安装部分</h2><p>想在 CentOS 系统上安装 Nginx ，你得先去添加一个资源库，像这样：</p><pre><code>vim /etc/yum.repos.d/nginx.repo</code></pre><p>使用 vim 命令去打开 <code>/etc/yum.repos.d/nginx.repo</code> ，如果 nginx.repo 不存在，就会去创建一个这样的文件，打开以后按一下小 i 键，进入编辑模式，然后复制粘贴下面这几行代码，完成以后按 esc 键退出，再输入 :wq （保存并退出）</p><pre><code>[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=0enabled=1</code></pre><p>完成以后，我们就可以使用 yum 命令去安装 nginx 了，像这样：</p><pre><code>yum install nginx</code></pre><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/18addimags/servers/ngnix0001.png" alt="HYMBA"></p><p>安装好以后测试一下 nginx 服务：</p><pre><code>service nginx status</code></pre><p>应该会返回：</p><pre><code>nginx is stopped （nginx 已停止）</code></pre><p>再测试一下 nginx 的配置文件：</p><pre><code>nginx -t</code></pre><p>应该会返回：</p><pre><code>nginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful</code></pre><p>… syntax is ok，… test is successful，说明配置文件没问题，同时这个结果里你可以找到 nginx 的配置文件 nginx.conf 所在的位置。</p><h2 id="操纵-nginx-服务"><a href="#操纵-nginx-服务" class="headerlink" title="操纵 nginx 服务"></a>操纵 nginx 服务</h2><p>操纵服务，可以使用使用 service 命令，它可以启动（start），重启（restart），或停止服务（stop），比如要启动 nginx 服务：</p><pre><code>service nginx start</code></pre><p>服务启动以后，你就可以在浏览器上使用服务器的 IP 地址，或者指向这个地址的域名访问服务器指定的目录了。你会看到类似下面的这些文字。</p><pre><code>Welcome to nginx! If you see this page, the nginx web server is successfully installed and working. Further configuration is required. For online documentation and support please refer to nginx.org. Commercial support is available at nginx.com. Thank you for using nginx.</code></pre><h2 id="nginx配置部分"><a href="#nginx配置部分" class="headerlink" title="nginx配置部分"></a>nginx配置部分</h2><p>下面来看一下为 nginx 配置虚拟主机。先进入到 nginx 配置文件目录：</p><pre><code>cd /etc/nginx/conf.d</code></pre><p>复制这个目录里的 default.conf ，复制以后的名字可以使用你的虚拟主机名字。比如创建一个 nginx.ninghao.net 的虚拟主机。复制文件可以使用 cp 命令，像这样：</p><pre><code>cp default.conf nginx.ninghao.net.conf</code></pre><p>再去编辑一下这个复制以后的配置文件，可以使用 vim 命令：</p><pre><code>vim nginx.ninghao.net.conf</code></pre><p>你会看到像这样的代码：</p><pre><code>server { listen 80; server_name localhost; #charset koi8-r; #access_log   /var/log/nginx/log/host.access.log main; location / { root /usr/share/nginx/html; index index.html index.htm;}...}</code></pre><blockquote><p>server_name 就是主机名，也就是跟这个虚拟主机绑定在一块儿的域名，我事先把 nginx.ninghao.net 指向了服务器，这个虚拟主机就是为它准备的，所以，server_name 后面的东西就是 nginx.ninghao.net 。</p><p>紧接着 server_name 下面可以是一个root，就是这个虚拟主机的根目录，也就是网站所在的目录。比如我们要把 nginx.ninghao.net 这个网站的文件放在/home/www/nginx.ninghao.net 下面，那么这个 root 就是这个路径。</p></blockquote><p>然后去掉 location / 里面的 root 这行代码。再在 index 后面加上一种索引文件名，也就是默认打开的文件，这里要加上一个 index.php ，这样访问 nginx.ninghao.net 就可以直接打开 root 目录下面的 index.php 了。稍后我们再去安装 php 。修改之后，看起来像这样：</p><pre><code>server { listen 80; server_name nginx.ninghao.net; root /home/www/nginx.ninghao.net; #charset koi8-r; #access_log /var/log/nginx/log/host.access.log main; location / { index index.php index.html index.htm; }...}</code></pre><p>这个配置文件先修改到这，稍后，我们再回来继续修改一下它。保存一下，按 esc ，输入 :wp（保存并退出）。现在虚拟主机应该就可以使用了。主机的域名是 nginx.ninghao.net，访问它的时候，打开的是 /home/www/nginx.ninghao.net 这个目录里面的东西，你可以在这个目录下放点东西。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/18addimags/servers/ngnix0003.png" alt="HYMBA"></p><p>重启 nginx 或者重新加载 nginx 可以让配置文件生效。</p><pre><code>service nginx reload</code></pre><p>现在，打开浏览器，输入你为虚拟主机设置的域名，看看是否能打开你指定的目录里的东西。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/18addimags/servers/ngnix0002.png" alt="HYMBA"></p>]]></content>
      
      <categories>
          
          <category> Server </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Server </tag>
            
            <tag> 服务器配置——Nginx安装与配置 </tag>
            
            <tag> Nginx安装与配置 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器配置——阿里云主机配置与操作</title>
      <link href="/2018/01/11/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%BB%E6%9C%BA/"/>
      <url>/2018/01/11/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%BB%E6%9C%BA/</url>
      <content type="html"><![CDATA[<p>前几年在阿里买了一个属于自己的个性域名(笔者英文)：<a href="http://www.icocos.cn，虽然是CN，但是这都不是重点，重点是为了更全面的接触后台，更好的学习与实战后台开发与PHP，前天又在阿里买了个主机，打算开发玩弄一番，毕竟第一次，期间可能会遇到不少坑和不对的地方，望谅解与指出一起交流，谢谢....." target="_blank" rel="noopener">www.icocos.cn，虽然是CN，但是这都不是重点，重点是为了更全面的接触后台，更好的学习与实战后台开发与PHP，前天又在阿里买了个主机，打算开发玩弄一番，毕竟第一次，期间可能会遇到不少坑和不对的地方，望谅解与指出一起交流，谢谢.....</a>.</p><a id="more"></a><h2 id="阿里云（先声明我不是来给阿里大广告的，😂😂😂😂😂😂）"><a href="#阿里云（先声明我不是来给阿里大广告的，😂😂😂😂😂😂）" class="headerlink" title="阿里云（先声明我不是来给阿里大广告的，😂😂😂😂😂😂）"></a>阿里云（先声明我不是来给阿里大广告的，😂😂😂😂😂😂）</h2><ol><li>阿里云主机</li><li>域名：<a href="http://www.icocos.cn" target="_blank" rel="noopener">www.icocos.cn</a></li></ol><p>这里关于阿里云主机和域名的购买很简单，准备钱，一路点下去就可以了,具体操作强查看阿里文档……</p><h2 id="备案"><a href="#备案" class="headerlink" title="备案"></a>备案</h2><p>关于备案确实是不少人蛋疼的事情，说麻烦也没有多麻烦，说不麻烦但是搞起来又不是点几下就可以的，所以也有不少人选择了不需要备案的或者国外的主机，我当时也有这种想法，但是后来放弃了，投资嘛，自己都不舍得投资还怎么学东西，怎么提升呢！</p><pre><code>本案分个人备案和企业备案，具体详情阿里也有教程，或者网上也有相关教程</code></pre><h2 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h2><p>在链接之前可能需要做一些配置，但是有些事必须的有些可以后面备案成功之后再做，我就是第一次弄所以一直不懂，以为需要备案以后才能操作的。</p><h3 id="添加安全组织，允许22端口访问"><a href="#添加安全组织，允许22端口访问" class="headerlink" title="添加安全组织，允许22端口访问"></a>添加安全组织，允许22端口访问</h3><p>这里其实就是进入阿里控制台的云服务ECS，找到安全组，添加安全组，配置规则就可以.</p><p>这里只要注意</p><pre><code>端口:22/22授权对象：0.0.0.0/0</code></pre><p>初步的这样就可以了，我是为了方便链接访问</p><blockquote><p>然后就可以链接了</p></blockquote><h2 id="连接，并操作"><a href="#连接，并操作" class="headerlink" title="连接，并操作"></a>连接，并操作</h2><p>连接的话当然首选ssh，不要问我为什么，我也不知道，大家都用它，哈哈！</p><h3 id="关于SSH"><a href="#关于SSH" class="headerlink" title="关于SSH"></a>关于SSH</h3><p>SSH是每一台Linux电脑的标准配置。</p><pre><code>简单说，SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。</code></pre><h3 id="最基本的用法"><a href="#最基本的用法" class="headerlink" title="最基本的用法"></a>最基本的用法</h3><p>SSH主要用于远程登录。假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。</p><p>　　$ ssh user@host</p><p>如果本地用户名与远程用户名一致，登录时可以省略用户名。</p><p>　　$ ssh host</p><p>SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。</p><p>　　$ ssh -p 2222 user@host</p><p>上面这条命令表示，ssh直接连接远程主机的2222端口。</p><h3 id="这里我使用的是SSH-shell这个工具，Windows用什么不知道，网上应该一大堆"><a href="#这里我使用的是SSH-shell这个工具，Windows用什么不知道，网上应该一大堆" class="headerlink" title="这里我使用的是SSH shell这个工具，Windows用什么不知道，网上应该一大堆"></a>这里我使用的是SSH shell这个工具，Windows用什么不知道，网上应该一大堆</h3><p>命令行步骤</p><pre><code>输入 ssh root@ip地址输入yes输入密码</code></pre><p>就可以看到显示</p><pre><code>[root@iZwz92qgus0ln1nx5dftjd2rZ ~]#</code></pre><p>SSH工具使用也很简单，进后点击Add Server输入ip，端口是默认22，输入root用户名，输入后台配置的密码，对了这里的密码是需要在控制台配置的</p><p>一切顺利的话可以看到一个和terminal一样的终端界面，并且已经连接成功的显示</p><pre><code>[root@iZwz92qgus0ln1nx5dftjd2rZ ~]#</code></pre><p>然后就可以使用命令操作主机文件了。</p><h2 id="密码登录：Mac-客户端"><a href="#密码登录：Mac-客户端" class="headerlink" title="密码登录：Mac 客户端"></a>密码登录：Mac 客户端</h2><h3 id="进入-ssh-文件夹，如果没有就创建一个-ssh文件夹"><a href="#进入-ssh-文件夹，如果没有就创建一个-ssh文件夹" class="headerlink" title="进入.ssh 文件夹，如果没有就创建一个.ssh文件夹"></a>进入.ssh 文件夹，如果没有就创建一个.ssh文件夹</h3><pre><code>mkdir ~/.sshcd ~/.ssh/</code></pre><h3 id="生成rsa秘钥：这个相信大部分人都弄过，github就需要"><a href="#生成rsa秘钥：这个相信大部分人都弄过，github就需要" class="headerlink" title="生成rsa秘钥：这个相信大部分人都弄过，github就需要"></a>生成rsa秘钥：这个相信大部分人都弄过，github就需要</h3><pre><code>ssh-keygen -t rsa</code></pre><h3 id="在该文件夹下就会产生三个文件夹：id-rsa-id-rsa-pub-know-hosts。"><a href="#在该文件夹下就会产生三个文件夹：id-rsa-id-rsa-pub-know-hosts。" class="headerlink" title="在该文件夹下就会产生三个文件夹：id_rsa,id_rsa.pub,know_hosts。"></a>在该文件夹下就会产生三个文件夹：id_rsa,id_rsa.pub,know_hosts。</h3><pre><code>id_rsa：存储私钥，记得只能自己看哦。别人那到这个文件就完蛋蛋咯。id_rsa.pub:存储公钥，用来通信加密使用，有了这个人家才能确定这是你。</code></pre><h3 id="公钥拷贝到云主机"><a href="#公钥拷贝到云主机" class="headerlink" title="公钥拷贝到云主机"></a>公钥拷贝到云主机</h3><pre><code>scp id_rsa.pub  root@78.129.23.45:/root/.ssh/id_rsa.pub</code></pre><h3 id="Note-云主机上没有-ssh-文件时，你要自己建立一个。"><a href="#Note-云主机上没有-ssh-文件时，你要自己建立一个。" class="headerlink" title="Note:云主机上没有.ssh/文件时，你要自己建立一个。"></a>Note:云主机上没有.ssh/文件时，你要自己建立一个。</h3><p>终端连接后输入ls只能看到default.pass文件，ls -a发现也是没有.ssh文件夹的，所以需要输入下面命令创建.ssh文件夹</p><pre><code>mkdir .ssh #回车没有提示就成功再次ls -a就可以看到一个蓝色的隐藏文件夹</code></pre><h2 id="登录到云主机"><a href="#登录到云主机" class="headerlink" title="登录到云主机"></a>登录到云主机</h2><h3 id="进入-ssh-文件夹"><a href="#进入-ssh-文件夹" class="headerlink" title="进入.ssh/文件夹"></a>进入.ssh/文件夹</h3><pre><code>cd  /root/.ssh/</code></pre><h3 id="将客户端公钥放入云主机识别keys文件夹中"><a href="#将客户端公钥放入云主机识别keys文件夹中" class="headerlink" title="将客户端公钥放入云主机识别keys文件夹中"></a>将客户端公钥放入云主机识别keys文件夹中</h3><pre><code>cat id_rsa.pub &gt;&gt; authorized_keys</code></pre><h3 id="销毁公钥"><a href="#销毁公钥" class="headerlink" title="销毁公钥"></a>销毁公钥</h3><pre><code>rm id_rsa.pub</code></pre><p>再次输入ssh root@ip地址就可以直接连接了，当然如果你使用工具的话就不用这么麻烦。</p><blockquote><p>到这里就基本上初步，而且是很简单的实现的主机的查看与操作，具体更多操作和命令请查看相关资料，后期也会有一些配置，操作与实战，请期待</p></blockquote>]]></content>
      
      <categories>
          
          <category> Server </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Server </tag>
            
            <tag> 服务器配置——阿里云主机配置与操作 </tag>
            
            <tag> 阿里云主机配置与操作 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swoole由浅入深指南</title>
      <link href="/2017/12/26/Swoole%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E6%8C%87%E5%8D%97/"/>
      <url>/2017/12/26/Swoole%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<blockquote><p>PHP语言的高性能网络通信框架，提供了PHP语言的异步多线程服务器，异步TCP/UDP网络客户端，异步MySQL，数据库连接池，AsyncTask，消息队列，毫秒定时器，异步文件读写，异步DNS查询。<br>Swoole可以广泛应用于互联网、移动通信、企业软件、云计算、网络游戏、物联网、车联网、智能家居等领域。 使用PHP+Swoole作为网络通信框架，可以使企业IT研发团队的效率大大提升，更加专注于开发创新产品。</p></blockquote><p>以上的定义是 Swoole 作者给出的。</p><p>Swoole 是以 PHP 扩展的形式工作的。就像诸如 mysql、memcache等扩展一样。安装了此扩展，你就能使用该扩展提供的所有功能。那么 Swoole 到底可以用来干啥呢？</p><a id="more"></a><h3 id="Swoole功能特性："><a href="#Swoole功能特性：" class="headerlink" title="Swoole功能特性："></a>Swoole功能特性：</h3><ul><li>实现 Socket 通信机制的服务器层。用它封装之后可以用于 HTTP WEB开发、游戏开发等工作。</li><li>实现 Socket 通信机制的客户端层。用它可以模拟 socket请求，以及模板HTTP客户端请求。</li><li>实现了一个比PHP进程管理更先进易用的模块。</li><li>异步IO。就是指：类crontab定时器、事件循环、异步文件读取。</li><li>内存操作。内存锁、数据共享、数据缓存。实现高并发。</li><li>HTTPS Server。通过对 socket 封装实现 http协议的server。无须web server即可以运行。性能出众。</li><li>Web Socket。</li></ul><h2 id="一、环境依赖"><a href="#一、环境依赖" class="headerlink" title="一、环境依赖"></a>一、环境依赖</h2><ul><li>仅支持Linux，FreeBSD，MacOS，3类操作系统</li><li>Linux内核版本2.3.32以上</li><li>PHP5.3.10以上版本</li><li>gcc4.4以上版本或者clang</li><li>cmake2.4+，编译为libswoole.so作为C/C++库时需要使用cmake</li></ul><h2 id="二、安装-Swoole-扩展"><a href="#二、安装-Swoole-扩展" class="headerlink" title="二、安装 Swoole 扩展"></a>二、安装 Swoole 扩展</h2><p>swoole扩展安装非常简单。最常见的方式是通过到 <a href="http://pecl.php.net/" target="_blank" rel="noopener">http://pecl.php.net/</a> 网站下载。但是，由于swoole社区非常活跃，导致版本迭代非常之快。所以，推荐去swoole官方的github上下载。下载地址：<a href="https://github.com/swoole/swoole-src" target="_blank" rel="noopener">https://github.com/swoole/swoole-src</a></p><blockquote><p>swoole有很多个版本，推荐下载 tags 中版本号最大的那个且是stable的版本。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> wget https://github.com/swoole/swoole-src/archive/swoole-1.7.14-stable.zip</span><br><span class="line"><span class="meta">$</span> unzip swoole-1.7.14-stable.zip</span><br><span class="line"><span class="meta">$</span> phpize</span><br><span class="line"><span class="meta">$</span> make</span><br><span class="line"><span class="meta">$</span> make install</span><br></pre></td></tr></table></figure><p>修改php.ini。在文件末尾增加以下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[swoole]</span><br><span class="line">extension=swoole.so</span><br></pre></td></tr></table></figure><ul><li>更多扩展编译参数说明文档：<a href="http://wiki.swoole.com/wiki/page/6.html" target="_blank" rel="noopener">http://wiki.swoole.com/wiki/page/6.html</a></li></ul><h2 id="三、Linux内核调整"><a href="#三、Linux内核调整" class="headerlink" title="三、Linux内核调整"></a>三、Linux内核调整</h2><p>要想swoole稳定且高性能运行，需要对Linux内核进行调整。</p><ul><li>关于内核的调整文档，官方网站说得非常详细：<a href="http://wiki.swoole.com/wiki/page/11.html" target="_blank" rel="noopener">http://wiki.swoole.com/wiki/page/11.html</a></li></ul><h2 id="四、基于swoole的周边项目"><a href="#四、基于swoole的周边项目" class="headerlink" title="四、基于swoole的周边项目"></a>四、基于swoole的周边项目</h2><p>swoole是一个偏底层的网络框架。基于它可以开发出更多的高级应用框架。</p><ul><li>基于swoole的项目：<a href="http://wiki.swoole.com/wiki/page/303.html" target="_blank" rel="noopener">我去</a></li></ul><h2 id="五、示例展示"><a href="#五、示例展示" class="headerlink" title="五、示例展示"></a>五、示例展示</h2><p>swoole提供了非常完整的示例。需要配合其文档来进行学习理解。</p><ul><li><a href="https://github.com/swoole/swoole-src/tree/swoole-1.7.14-stable/examples" target="_blank" rel="noopener">官方示例地址：https://github.com/swoole/swoole-src/tree/swoole-1.7.14-stable/examples</a></li><li><a href="http://wiki.swoole.com/" target="_blank" rel="noopener">方官文档地址：http://wiki.swoole.com/</a></li><li><a href="https://github.com/LinkedDestiny/swoole-doc" target="_blank" rel="noopener">非常官方文档：https://github.com/LinkedDestiny/swoole-doc</a></li></ul><blockquote><p>注意：建议所有示例在Linux系统下运行。不推荐在windows或Mac系统下运行。</p></blockquote><h2 id="六、swoole-其它"><a href="#六、swoole-其它" class="headerlink" title="六、swoole 其它"></a>六、swoole 其它</h2><ul><li>IDE自动提示工具：<a href="https://github.com/eaglewu/swoole-ide-helper" target="_blank" rel="noopener">必须看看</a></li><li>WEB IM :<a href="https://github.com/matyhtf/php-webim" target="_blank" rel="noopener">必须看看</a></li><li>swoole成员提示的视频：<a href="http://www.tudou.com/home/shenzhe/" target="_blank" rel="noopener">http://www.tudou.com/home/shenzhe/</a></li></ul>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> PHP面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>开发符合composer的包</title>
      <link href="/2017/12/16/%E5%BC%80%E5%8F%91%E7%AC%A6%E5%90%88composer%E7%9A%84%E5%8C%85/"/>
      <url>/2017/12/16/%E5%BC%80%E5%8F%91%E7%AC%A6%E5%90%88composer%E7%9A%84%E5%8C%85/</url>
      <content type="html"><![CDATA[<p>composer工具帮我们很好地管理了PHP依赖包的问题。但是，作为一名PHPer，我们总不能永远只使用别人的开发包。我们骄傲是程序员必须自己动手开发一个包给别人用或自用。</p><p>以下我将以github结合composer工具来进行示例讲解。</p><a id="more"></a><h3 id="一、创建一个github项目"><a href="#一、创建一个github项目" class="headerlink" title="一、创建一个github项目"></a>一、创建一个github项目</h3><h5 id="首先，你得有一个github账号。然后，创建一个github-项目。"><a href="#首先，你得有一个github账号。然后，创建一个github-项目。" class="headerlink" title="首先，你得有一个github账号。然后，创建一个github 项目。"></a>首先，你得有一个github账号。然后，创建一个github 项目。</h5><ul><li><p>1）登录github。点击顶部导航栏的“+”，选择“New repository”。跳转到创建页页。</p></li><li><p>2）Repository name 我填写的是”utils”。可以填写你想要的名字。Description 是可选的。这是对这个项目的描述。接着下面的选项是让我们填写该项目是“public”还是”private”。选择”public”。接着“Initialize this repository with a README”建议勾选，给我们创建初始化一个项目文档首页。其他选项保持默认即可。根据提示选择即可。</p></li></ul><ul><li>public：所有人都能访问您创建的项目。这也是github推荐的方式。免费。</li><li>private：收费。只有指定的人才能访问这个项目。</li></ul><ul><li>3）点击“Create Repository”按钮，即可创建成功。</li></ul><h5 id="其次，我们要将这个github项目clone到本地。"><a href="#其次，我们要将这个github项目clone到本地。" class="headerlink" title="其次，我们要将这个github项目clone到本地。"></a>其次，我们要将这个github项目clone到本地。</h5><ul><li><p>1）在本地电脑创建一个目录localgit（名字随意）且保证系统中已经安装了git命令。</p></li><li><p>2）已创建的github项目右下角有一个”HTTPS clone URL”，点击那里的复制按钮把 url 地址复制出来。我的是：</p></li></ul><blockquote><p><a href="https://github.com/winerQin/utils.git" target="_blank" rel="noopener">https://github.com/winerQin/utils.git</a></p></blockquote><ul><li>3）在localgit父目录下。执行如下命令：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/winerQin/utils.git localgit</span></span><br></pre></td></tr></table></figure><p>此命令会输出如下内容，代表执行成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Cloning into 'utils'...</span><br><span class="line">remote: Counting objects: 4, done.</span><br><span class="line">remote: Compressing objects: 100% (4/4), done.</span><br><span class="line">remote: Total 4 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (4/4), done.</span><br><span class="line">Checking connectivity... done.</span><br></pre></td></tr></table></figure><h3 id="二、创建composer-json"><a href="#二、创建composer-json" class="headerlink" title="二、创建composer.json"></a>二、创建composer.json</h3><p>用过composer命令安装第三方开发包的人一定对composer.json不陌生。composer.json文件定义了包名、包的描述、作者、授权协议等信息。总之，一个项目要调用这个开发包，通过composer.json可以知道该怎样去加载文件。</p><p>因为，我们在本地已经有了一个github项目localgit。进入这个目录。使用composer命令智能化生成composer.json。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> composer init</span></span><br></pre></td></tr></table></figure><p>此时，会提示我们输入包名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Package name (&lt;vendor&gt;/&lt;name&gt;) [root/localgit]:</span><br></pre></td></tr></table></figure><p>输入：winerqin/localgit 并回车确认。注意：不能用大写字母和特殊字符。</p><blockquote><p>因为，我们使用的是github。那么，推荐vendor为小写的用户名。name为仓库名称。</p></blockquote><p>回车之后会提示输入包描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Description []:</span><br></pre></td></tr></table></figure><p>这个你自己看着办。我比较懒。直接回车。</p><p>这个时候，会提示你输入作者和邮箱。默认是你初始安装git命令时配置的作者和邮箱。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Author [winerQin &lt;753814253@qq.com&gt;]:</span><br></pre></td></tr></table></figure><p>因为，我的就是这个，所以，我直接就回车了。接着会填写最低稳定版本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Minimum Stability []:</span><br></pre></td></tr></table></figure><p>我直接填写了dev。如果你乱填写，则会提示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invalid minimum stability &quot;sdfsd&quot;. Must be empty or one of: stable, RC, beta, alpha, dev</span><br></pre></td></tr></table></figure><p>接着：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">License []:</span><br></pre></td></tr></table></figure><p>直接回车。</p><p>接着:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Would you like to define your dependencies (require) interactively [yes]?</span><br></pre></td></tr></table></figure><p>输入No。</p><p>接着：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Would you like to define your dev dependencies (require-dev) interactively [yes]?</span><br></pre></td></tr></table></figure><p>输入No。</p><p>接着后面都输入Yes即可。其实，根据英文提示，都知道要干嘛了。</p><p>此时，在localgit目录下会生成一个composer.json文件。内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;winerqin/localgit&quot;,</span><br><span class="line">    &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line">    &quot;authors&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;winerQin&quot;,</span><br><span class="line">            &quot;email&quot;: &quot;753814253@qq.com&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;minimum-stability&quot;: &quot;dev&quot;,</span><br><span class="line">    &quot;require&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，这个文件完全可以手工创建，按照这个格式。</p><h3 id="三、创建项目内容"><a href="#三、创建项目内容" class="headerlink" title="三、创建项目内容"></a>三、创建项目内容</h3><p>创建项目内容很简单，按照既定目录结构去创建目录和文件即可。然后，再到composer.json里面修改一下让其知道即可。</p><p>一般情况下一个完整的开发包结构如下：</p><p>– src 源码目录。这个名称按照所有程序员的约定不会更改名称。必不可少的。虽然，可以改为其他名称。但是不推荐。<br>– tests 单元测试目录。此目录不是必须的。一些超高规格的开发者会提供这个目录让便让其他程序员测试协作。</p><p>在 src 目录我们创建一个类：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局数据验证类。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> winerQin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">winer</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否为合法的用户名。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $username</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int $min_len 最小长度。包含。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int $max_len 最大长度。包含。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $mode 用户名模式：digit、alpha、digit_alpha、chinese、digit_alpha_chinese、mix</span></span><br><span class="line"><span class="comment"> *digit：数字</span></span><br><span class="line"><span class="comment"> *aplha：字母</span></span><br><span class="line"><span class="comment"> *digit_alpha：数字和字母</span></span><br><span class="line"><span class="comment"> *chinese：中文</span></span><br><span class="line"><span class="comment"> *digit_alpha_chinese：数字字母中文</span></span><br><span class="line"><span class="comment"> *mix：混合型：数字字母中文下划线破折号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">is_username</span><span class="params">($username, $min_len, $max_len, $mode = <span class="string">'mix'</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> ($mode) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'digit'</span>:</span><br><span class="line"><span class="keyword">return</span> preg_match(<span class="string">"/^\d&#123;&#123;$min_len&#125;,&#123;$max_len&#125;&#125;$/"</span>, $username) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">'alpha'</span>:</span><br><span class="line"><span class="keyword">return</span> preg_match(<span class="string">"/^([a-zA-Z])&#123;&#123;$min_len&#125;,&#123;$max_len&#125;&#125;$/"</span>, $username) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">'digit_alpha'</span>:</span><br><span class="line"><span class="keyword">return</span> preg_match(<span class="string">"/^([a-z0-9_-])&#123;&#123;$min_len&#125;,&#123;$max_len&#125;&#125;$/"</span>, $username) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">'chinese'</span>:</span><br><span class="line"><span class="keyword">return</span> (preg_match(<span class="string">"/^[\x7f-\xff]&#123;&#123;$min_len&#125;,&#123;$max_len&#125;&#125;$/"</span>, $username)) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">'digit_alpha_chinese'</span>:</span><br><span class="line"><span class="keyword">return</span> (preg_match(<span class="string">"/^[\x7f-\xff|0-9a-zA-Z]&#123;&#123;$min_len&#125;,&#123;$max_len&#125;&#125;$/"</span>, $username)) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">'mix'</span>:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> (preg_match(<span class="string">"/^[\x7f-\xff|0-9a-zA-Z-_]&#123;&#123;$min_len&#125;,&#123;$max_len&#125;&#125;$/"</span>, $username)) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否为合法的密码。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $password</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int $min_len 最小长度。包含。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int $max_len 最大长度。包含。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $mode 用户名模式：digit_alpha、mix</span></span><br><span class="line"><span class="comment"> *digit_alpha：数字和字母</span></span><br><span class="line"><span class="comment"> *mix：混合型：数字字母下划线破折号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">is_password</span><span class="params">($password, $min_len, $max_len, $mode = <span class="string">'mix'</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> ($mode) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'digit_alpha'</span>:</span><br><span class="line"><span class="keyword">return</span> preg_match(<span class="string">"/^([a-z0-9])&#123;&#123;$min_len&#125;,&#123;$max_len&#125;&#125;$/"</span>, $password) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">'mix'</span>:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> (preg_match(<span class="string">"/^[0-9a-zA-Z-_]&#123;&#123;$min_len&#125;,&#123;$max_len&#125;&#125;$/"</span>, $password)) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否为QQ号码。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $qq</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">is_qq</span><span class="params">($qq)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> preg_match(<span class="string">'/^[1-9]\d&#123;4,12&#125;$/'</span>, $qq) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否为手机号码。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $mobilephone</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">is_mobilephone</span><span class="params">($mobilephone)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> preg_match(<span class="string">'/^13[\d]&#123;9&#125;$|14^[0-9]\d&#123;8&#125;|^15[0-9]\d&#123;8&#125;$|^18[0-9]\d&#123;8&#125;$/'</span>, $mobilephone) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否为座机号码。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $telphone</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">is_telphone</span><span class="params">($telphone)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> preg_match(<span class="string">'/^((\(\d&#123;2,3&#125;\))|(\d&#123;3&#125;\-))?(\(0\d&#123;2,3&#125;\)|0\d&#123;2,3&#125;-)?[1-9]\d&#123;6,7&#125;(\-\d&#123;1,4&#125;)?$/'</span>, $telphone) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否为邮政编码。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $zipcode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">is_zipcode</span><span class="params">($zipcode)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> preg_match(<span class="string">'/^[1-9]\d&#123;5&#125;$/'</span>, $zipcode) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断字母是否在某个区域内。用于判断某个字符只能介于[a-h](包含)之间的类似情况。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $alpha 原值。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $start_alpha 起始值。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $end_alpha 截止值。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">alpha_between</span><span class="params">($alpha, $start_alpha, $end_alpha)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Validator::is_alpha($alpha) === <span class="keyword">false</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Validator::is_alpha($start_alpha) === <span class="keyword">false</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Validator::is_alpha($end_alpha) === <span class="keyword">false</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ($start_alpha &gt;= $end_alpha) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ($alpha &lt; $start_alpha) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ($alpha &gt; $end_alpha) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断数字是否在某个区域之间。[2, 10],包含边界值。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int $value 原值。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int $start_value 起始值。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int $end_value 截止值。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">number_between</span><span class="params">($value, $start_value, $end_value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (is_numeric($value) === <span class="keyword">false</span> || is_numeric($start_value) === <span class="keyword">false</span> || is_numeric($end_value) === <span class="keyword">false</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ($start_value &gt;= $end_value) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ($value &lt; $start_value) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ($value &gt; $end_value) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证是否为中文。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $char</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">is_chinese</span><span class="params">($char)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (strlen($char) === <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (preg_match(<span class="string">"/^[\x7f-\xff]+$/"</span>, $char)) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否为字母、数字、下划线（_）、破折号（-）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $str</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">is_alpha_dash</span><span class="params">($str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> preg_match(<span class="string">'/^([a-z0-9_-])+$/i'</span>, $str) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证身份证号码是否合法。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $vStr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">is_idcard</span><span class="params">($vStr)</span> </span>&#123;</span><br><span class="line">$vCity = <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">'11'</span>,<span class="string">'12'</span>,<span class="string">'13'</span>,<span class="string">'14'</span>,<span class="string">'15'</span>,<span class="string">'21'</span>,<span class="string">'22'</span>,</span><br><span class="line">        <span class="string">'23'</span>,<span class="string">'31'</span>,<span class="string">'32'</span>,<span class="string">'33'</span>,<span class="string">'34'</span>,<span class="string">'35'</span>,<span class="string">'36'</span>,</span><br><span class="line">        <span class="string">'37'</span>,<span class="string">'41'</span>,<span class="string">'42'</span>,<span class="string">'43'</span>,<span class="string">'44'</span>,<span class="string">'45'</span>,<span class="string">'46'</span>,</span><br><span class="line">        <span class="string">'50'</span>,<span class="string">'51'</span>,<span class="string">'52'</span>,<span class="string">'53'</span>,<span class="string">'54'</span>,<span class="string">'61'</span>,<span class="string">'62'</span>,</span><br><span class="line">        <span class="string">'63'</span>,<span class="string">'64'</span>,<span class="string">'65'</span>,<span class="string">'71'</span>,<span class="string">'81'</span>,<span class="string">'82'</span>,<span class="string">'91'</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (!preg_match(<span class="string">'/^([\d]&#123;17&#125;[xX\d]|[\d]&#123;15&#125;)$/'</span>, $vStr)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!in_array(substr($vStr, <span class="number">0</span>, <span class="number">2</span>), $vCity)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    $vStr = preg_replace(<span class="string">'/[xX]$/i'</span>, <span class="string">'a'</span>, $vStr);</span><br><span class="line">    $vLength = strlen($vStr);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ($vLength == <span class="number">18</span>) &#123;</span><br><span class="line">        $vBirthday = substr($vStr, <span class="number">6</span>, <span class="number">4</span>) . <span class="string">'-'</span> . substr($vStr, <span class="number">10</span>, <span class="number">2</span>) . <span class="string">'-'</span> . substr($vStr, <span class="number">12</span>, <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $vBirthday = <span class="string">'19'</span> . substr($vStr, <span class="number">6</span>, <span class="number">2</span>) . <span class="string">'-'</span> . substr($vStr, <span class="number">8</span>, <span class="number">2</span>) . <span class="string">'-'</span> . substr($vStr, <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (date(<span class="string">'Y-m-d'</span>, strtotime($vBirthday)) != $vBirthday) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ($vLength == <span class="number">18</span>) &#123;</span><br><span class="line">        $vSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">17</span> ; $i &gt;= <span class="number">0</span> ; $i--) &#123;</span><br><span class="line">            $vSubStr = substr($vStr, <span class="number">17</span> - $i, <span class="number">1</span>);</span><br><span class="line">            $vSum += (pow(<span class="number">2</span>, $i) % <span class="number">11</span>) * (($vSubStr == <span class="string">'a'</span>) ? <span class="number">10</span> : intval($vSubStr, <span class="number">11</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>($vSum % <span class="number">11</span> != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证日期时间格式。</span></span><br><span class="line"><span class="comment"> * -- 1、验证$value是否为$format格式。</span></span><br><span class="line"><span class="comment"> * -- 2、只能验证格式，不能验证时间是否正确。比如：2014-22-22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $format 格式。格式如：Y-m-d 或H:i:s</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $value 日期。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">is_date_format</span><span class="params">($format, $value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> date_create_from_format($format, $value) !== <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否为整数。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $str</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">is_integer</span><span class="params">($str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> filter_var($str, FILTER_VALIDATE_INT) !== <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否为字母数字。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $str</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">is_alpha_number</span><span class="params">($str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> preg_match(<span class="string">'/^([a-z0-9])+$/i'</span>, $str) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否为字母。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $str</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">is_alpha</span><span class="params">($str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> preg_match(<span class="string">'/^([a-z])+$/i'</span>, $str) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证IP是否合法。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $ip</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">is_ip</span><span class="params">($ip)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> filter_var($ip, FILTER_VALIDATE_IP) !== <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证URL是否合法。</span></span><br><span class="line"><span class="comment"> * -- 合法的URL：http://www.baidu.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $url</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">is_url</span><span class="params">($url)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> filter_var($url, FILTER_VALIDATE_URL) !== <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断email格式是否正确。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $email</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is_email</span><span class="params">($email)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> filter_var($email, FILTER_VALIDATE_EMAIL) !== <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否必需。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $str</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">is_require</span><span class="params">($str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> strlen($str) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断字符串是否为utf8编码，英文和半角字符返回ture。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $string</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">is_utf8</span><span class="params">($string)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> preg_match(<span class="string">'%^(?:</span></span><br><span class="line"><span class="string">[\x09\x0A\x0D\x20-\x7E] # ASCII</span></span><br><span class="line"><span class="string">| [\xC2-\xDF][\x80-\xBF] # non-overlong 2-byte</span></span><br><span class="line"><span class="string">| \xE0[\xA0-\xBF][\x80-\xBF] # excluding overlongs</span></span><br><span class="line"><span class="string">| [\xE1-\xEC\xEE\xEF][\x80-\xBF]&#123;2&#125; # straight 3-byte</span></span><br><span class="line"><span class="string">| \xED[\x80-\x9F][\x80-\xBF] # excluding surrogates</span></span><br><span class="line"><span class="string">| \xF0[\x90-\xBF][\x80-\xBF]&#123;2&#125; # planes 1-3</span></span><br><span class="line"><span class="string">| [\xF1-\xF3][\x80-\xBF]&#123;3&#125; # planes 4-15</span></span><br><span class="line"><span class="string">| \xF4[\x80-\x8F][\x80-\xBF]&#123;2&#125; # plane 16</span></span><br><span class="line"><span class="string">)*$%xs'</span>, $string) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查字符串长度。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $str 字符串。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int $min 最小长度。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int $max 最大长度。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bool $is_utf8 是否UTF-8字符。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">len</span><span class="params">($str, $min = <span class="number">0</span>, $max = <span class="number">255</span>, $is_utf8 = false)</span> </span>&#123;</span><br><span class="line">$len = $is_utf8 ? mb_strlen($str) : strlen($str);</span><br><span class="line"><span class="keyword">if</span> (($len &gt;= $min) &amp;&amp; ($len &lt;= $max)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改composer.json。修改后的内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;winerqin/utils&quot;,</span><br><span class="line">    &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line">    &quot;authors&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;winerQin&quot;,</span><br><span class="line">            &quot;email&quot;: &quot;753814253@qq.com&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;minimum-stability&quot;: &quot;dev&quot;,</span><br><span class="line">    &quot;require&quot;: &#123;</span><br><span class="line">&quot;php&quot;: &quot;&gt;=5.3.0&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;autoload&quot;: &#123;</span><br><span class="line">        &quot;psr-4&quot;: &#123;</span><br><span class="line">            &quot;winer\\&quot;: &quot;src/&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于 PSR-4规范，请看文档：<a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-4-autoloader.md" target="_blank" rel="noopener">我去</a></p><p>关于composer.json说明请看此博文：<a href="http://my.oschina.net/u/248080/blog/359008" target="_blank" rel="noopener">我去</a></p><p>到此，我们的开发包已经搞定。接下来我们测试测试这个包是否可用。</p><h3 id="四、测试开发包"><a href="#四、测试开发包" class="headerlink" title="四、测试开发包"></a>四、测试开发包</h3><p>在localgit目录下，通过composer来安装测试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> composer install</span></span><br><span class="line">Loading composer repositories with package information</span><br><span class="line">Installing dependencies (including require-dev)</span><br><span class="line">Nothing to install or update</span><br><span class="line">Writing lock file</span><br><span class="line">Generating autoload files</span><br></pre></td></tr></table></figure><p>输出以上信息说明安装成功咯。</p><blockquote><p>在目录下会有一个vendor文件夹。</p></blockquote><p>此时会在vendor/composer/autoload_psr4.php中生成命名空间和目录的映射关系，被包在一个数组中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// autoload_psr4.php @generated by Composer</span></span><br><span class="line"></span><br><span class="line">$vendorDir = dirname(dirname(<span class="keyword">__FILE__</span>));</span><br><span class="line">$baseDir = dirname($vendorDir);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">'winer\\'</span> =&gt; <span class="keyword">array</span>($baseDir . <span class="string">'/src'</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果发布成packagist包然后进行安装的话，到时候这里就不是$baseDir了而是$vendorDir。稍后我们再发布到packagist。</p><p>在tests目录创建 ValidatorTest.php，内容如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'../vendor/autoload.php'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> \<span class="title">winer</span>;</span><br><span class="line"></span><br><span class="line">$mobilephone = <span class="string">'18665027895'</span>;</span><br><span class="line">$ok = winer\Validator::is_mobilephone($mobilephone);</span><br><span class="line"><span class="keyword">if</span> ($ok) &#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'是手机号码'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'不是手机号码'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过php命令来运行：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php ValidatorTest.php</span><br></pre></td></tr></table></figure><p>输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是手机号码</span><br></pre></td></tr></table></figure></p><h3 id="五、发布到packagist"><a href="#五、发布到packagist" class="headerlink" title="五、发布到packagist"></a>五、发布到packagist</h3><p>packagist指的是packagist.org。这个网站是composer默认下载开发包的资源引用网站。所以，我们得在此网站注册一个账号。然后添加我们开发包的github项目。</p><ul><li>1）将本地代码提交到github。<br>在发布之前，我们要把localgit的代码提交到github上去。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"composer.json教程代码"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push</span></span><br></pre></td></tr></table></figure><p>此时，访问github的utils仓库，发现我们的刚刚提交的代码都已经安静地在里面了。</p><ul><li>2）发布g到packagist</li></ul><p>请确认已经登录。在packagist.org首页的右上角有一个”Submit Package”按钮。点击即可进入开发包提交的界面。在页面最下方有一个输入框，输入我们github的utils项目地址：</p><blockquote><p><a href="https://github.com/winerQin/utils" target="_blank" rel="noopener">https://github.com/winerQin/utils</a></p></blockquote><p>再点击”Check -&gt;”，经过几秒钟的等待会显示验证成功，并显示出提交的按钮。点击提交即完成了开发包的提交了。</p><p>那么，接下来这个开发包就可以在任何支持composer的PHP框架中使用了。恭喜您！！！</p><ul><li>3）让我们的github代码更新能让packagist.org自动更新</li></ul><p>登录github。选择代码仓库。我的是utils。然后，右边选择”settings” -&gt; “Webhooks &amp; Services” -&gt; “Add Service” -&gt; 下拉列表中选择 “packagist” -&gt; 根据提示填写packagist账号，以及packagist提供的token。域名填写：<a href="http://packagist.org。" target="_blank" rel="noopener">http://packagist.org。</a></p><p>就这样，以后更新就会自动更新packagist.org上了。是不是好开心？是的。</p><blockquote><p>超级提示：我们可以模仿已有的第三方包进行开发。</p></blockquote><p>关于git中文文档请看：<a href="http://git.oschina.net/progit/index.html" target="_blank" rel="noopener">我去</a></p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> PHP面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Composer实战指南</title>
      <link href="/2017/12/15/Composer%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/"/>
      <url>/2017/12/15/Composer%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<p>Composer 是 PHP 用来管理依赖（dependency）关系的工具。你可以在自己的项目中声明所依赖的外部工具库（libraries），Composer 会帮你安装这些依赖的库文件。</p><p>PHP 开发过程中，难免会使用第三方包或自己的功能吧。那么，很容易出来第三方包之间的包名一样的情况。以及，同一包的不版本与其他包之间的依赖混乱的情况。</p><p>其它的语言也有类似的包依赖管理工具：Java有Maven，Python有pip，Ruby有gem，Nodejs有npm。</p><p>PHP的则是PEAR，不过PEAR坑不少：</p><ul><li>依赖处理容易出问题</li><li>配置非常复杂</li><li>难用的命令行接口</li></ul><a id="more"></a><p>既然有问题，那一定会有人跳出来解决。于是，Composer就出来了。</p><blockquote><p>运行 Composer 需要 PHP 5.3.2+ 以上版本。一些敏感的 PHP 设置和编译标志也是必须的，但对于任何不兼容项安装程序都会抛出警告。</p></blockquote><h2 id="一、Composer在各平台的安装"><a href="#一、Composer在各平台的安装" class="headerlink" title="一、Composer在各平台的安装"></a>一、Composer在各平台的安装</h2><p>事实上只要你使用的系统中已经开启或支持Curl命令或将php可执行文件添加到了系统PATH中。那么，安装composer是相当的简单的。</p><p>在你的客户端运行如下命令安装 composer。默认安装最新版。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sS https://getcomposer.org/installer | php</span><br></pre></td></tr></table></figure><p>如果你的系统没有curl,则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -r "readfile('https://getcomposer.org/installer');" | php</span><br></pre></td></tr></table></figure><p>官方英文安装文档：<a href="https://getcomposer.org/download/" target="_blank" rel="noopener">https://getcomposer.org/download/</a></p><h2 id="二、一些常用的-Composer-命令"><a href="#二、一些常用的-Composer-命令" class="headerlink" title="二、一些常用的 Composer 命令"></a>二、一些常用的 Composer 命令</h2><p>假定你已经有一个新项目对应的文件夹名称是 test 。那么，在 test 项目下你要创建一个composer.json。这样，在之后使用composer.json命令才能成功。</p><h3 id="1）安装扩展包"><a href="#1）安装扩展包" class="headerlink" title="1）安装扩展包"></a>1）安装扩展包</h3><p>以安装 monolog 扩展为例。这个包可以在 packagist.org 搜索得到。可以看到每个包的引入条件。</p><p>在composer.json里面增加引入配置，增加之后composer.json文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;require&quot;: &#123;</span><br><span class="line">        &quot;monolog/monolog&quot;: &quot;1.2.*&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，我们可以在命令行的 test 项目目录下执行如下命令安装它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer install</span><br></pre></td></tr></table></figure><p>这个时候在项目根目录下会生成一个 composer.lock 文件，以及一个 vendor 文件夹。在vendor文件夹下有一个 monolog 文件夹，说明我们已经安装成功。</p><h3 id="2）更新扩展包"><a href="#2）更新扩展包" class="headerlink" title="2）更新扩展包"></a>2）更新扩展包</h3><p>更新扩展包，可以一起更新，也可以单独更新某一个包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer update</span><br></pre></td></tr></table></figure><p>以上命令会将当前扩展包整体更新。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer update monolog/monolog</span><br></pre></td></tr></table></figure><p>以上命令只会更新monolog/monolog扩展包。</p><p>当修改了 composer.json 文件且已经存在composer.lock文件的时候，使用如下命令并不会更新：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer install</span><br></pre></td></tr></table></figure><p>必须使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer update</span><br></pre></td></tr></table></figure><h3 id="3）移除扩展包"><a href="#3）移除扩展包" class="headerlink" title="3）移除扩展包"></a>3）移除扩展包</h3><p>扩展包移动命令会将扩展包在vendor文件夹中彻底删除。命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer remove monolog/monolog</span><br></pre></td></tr></table></figure><h3 id="4）包版本号介绍"><a href="#4）包版本号介绍" class="headerlink" title="4）包版本号介绍"></a>4）包版本号介绍</h3><p>在前面的例子中，我们引入的 monolog 版本指定为 1.0.*。这表示任何从 1.0 开始的开发分支，它将会匹配 1.0.0、1.0.2 或者 1.0.20。</p><p>版本约束可以用几个不同的方法来指定。</p><table><thead><tr><th>名称</th><th>实例</th><th>描述</th></tr></thead><tbody><tr><td>确切的版本号</td><td>1.0.2</td><td>你可以指定包的确切版本。</td></tr><tr><td>范围</td><td>&gt;=1.0 &gt;=1.0,&lt;2.0 &gt;=1.0</td><td>通过使用比较操作符可以指定有效的版本范围。</td></tr><tr><td>有效的运算符：</td><td>&gt;、&gt;=、&lt;、&lt;=、!=。</td><td>你可以定义多个范围，用逗号隔开，这将被视为一个逻辑AND处理。 AND 的优先级高于 OR。</td></tr><tr><td>通配符</td><td>1.0.*</td><td>你可以使用通配符<em>来指定一种模式。1.0.</em>与&gt;=1.0,&lt;1.1是等效的。</td></tr><tr><td>赋值运算符</td><td>~1.2</td><td>这对于遵循语义化版本号的项目非常有用。~1.2相当于&gt;=1.2,&lt;2.0。想要了解更多，请阅读下一小节。</td></tr></tbody></table><h3 id="下一个重要版本（波浪号运算符）"><a href="#下一个重要版本（波浪号运算符）" class="headerlink" title="下一个重要版本（波浪号运算符）"></a>下一个重要版本（波浪号运算符）</h3><p>最好用例子来解释： ~1.2 相当于 &gt;=1.2,&lt;2.0，而 ~1.2.3 相当于 &gt;=1.2.3,&lt;1.3。正如你所看到的这对于遵循 语义化版本号 的项目最有用。一个常见的用法是标记你所依赖的最低版本，像 ~1.2 （允许1.2以上的任何版本，但不包括2.0）。由于理论上直到2.0应该都没有向后兼容性问题，所以效果很好。你还会看到它的另一种用法，使用 ~ 指定最低版本，但允许版本号的最后一位数字上升。</p><blockquote><p>注意： 虽然 2.0-beta.1 严格地说是早于 2.0，但是，根据版本约束条件， 例如 ~1.2 却不会安装这个版本。就像前面所讲的 ~1.2 只意味着 .2 部分可以改变，但是 1. 部分是固定的。</p></blockquote><h3 id="5）稳定性"><a href="#5）稳定性" class="headerlink" title="5）稳定性"></a>5）稳定性</h3><p>默认情况下只有稳定的发行版才会被考虑在内。如果你也想获得 RC、beta、alpha 或 dev 版本，你可以使用 稳定标志。你可以对所有的包做 最小稳定性 设置，而不是每个依赖逐一设置。</p><blockquote><p>稳定性对应 composer.json文件中的 “minimum-stability”: “dev”。</p></blockquote><h3 id="6）composer-lock-锁文件"><a href="#6）composer-lock-锁文件" class="headerlink" title="6）composer.lock - 锁文件"></a>6）composer.lock - 锁文件</h3><p>在安装依赖后，Composer 将把安装时确切的版本号列表写入 composer.lock 文件。这将锁定改项目的特定版本。</p><blockquote><p>请提交你应用程序的 composer.lock （包括 composer.json）到你的版本库中。</p></blockquote><p>这是非常重要的，因为 install 命令将会检查锁文件是否存在，如果存在，它将下载指定的版本（忽略 composer.json 文件中的定义）。</p><blockquote><p>这意味着，任何人建立项目都将下载与指定版本完全相同的依赖。你的持续集成服务器、生产环境、你团队中的其他开发人员、每件事、每个人都使用相同的依赖，从而减轻潜在的错误对部署的影响。即使你独自开发项目，在六个月内重新安装项目时，你也可以放心的继续工作，即使从那时起你的依赖已经发布了许多新的版本。</p></blockquote><p>如果不存在 composer.lock 文件，Composer 将读取 composer.json 并创建锁文件。</p><p>这意味着如果你的依赖更新了新的版本，你将不会获得任何更新。此时要更新你的依赖版本请使用 update 命令。这将获取最新匹配的版本（根据你的 composer.json 文件）并将新版本更新进锁文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php composer.phar update</span><br></pre></td></tr></table></figure><p>如果只想安装或更新一个依赖，你可以白名单它们：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php composer.phar update monolog/monolog [...]</span><br></pre></td></tr></table></figure><blockquote><p>注意： 对于库，并不一定建议提交锁文件 请参考：库的锁文件.</p></blockquote><p>更新文档，请参考：<a href="http://www.phpcomposer.com/" target="_blank" rel="noopener">http://www.phpcomposer.com/</a></p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> PHP面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>拓展篇——Zephir快速入门</title>
      <link href="/2017/12/07/%E6%8B%93%E5%B1%95%E7%AF%87%E2%80%94%E2%80%94Zephir%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2017/12/07/%E6%8B%93%E5%B1%95%E7%AF%87%E2%80%94%E2%80%94Zephir%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>如果你想自己编写PHP扩展，意味着你需要掌握C语言，因为PHP的扩展是通过C编写的，而且你还需要掌握PHP的Zend API，了解它的核心原理</p><h6 id="但是最近了解到一个新的技术：Zephir"><a href="#但是最近了解到一个新的技术：Zephir" class="headerlink" title="但是最近了解到一个新的技术：Zephir"></a>但是最近了解到一个新的技术：Zephir</h6><blockquote><p>它可以帮助你使用类PHP的语法，来生成C语言代码，并帮助你编译成PHP扩展。是不是很酷？很酷，有没有？</p></blockquote><p>根据 Zephir 的作者（出是phalcon的核心成员）的描述：Zephir是一门能使用语法与PHP相同且纯面向对象的编译型语言。它将代码编译为C语言，再生成PHP扩展。</p><a id="more"></a><h3 id="Zephir-有几个特性："><a href="#Zephir-有几个特性：" class="headerlink" title="Zephir 有几个特性："></a>Zephir 有几个特性：</h3><ul><li>类型可静可动。即支持PHP类似的动态类型、也可以支持类似C语言的静态类型。</li><li>减少程序执行时间提升运行性能。毕竟是把代码编译为静态类型的C语言。</li><li>采用面向对象OOP编译。</li><li>内存安全。即不需要操心内存的管理问题。</li><li>预编译器(AOT)提供可预测的性能。</li></ul><p>Zephir是开放源代码的项目。代码托管在github：<a href="https://github.com/phalcon/zephir" target="_blank" rel="noopener">https://github.com/phalcon/zephir</a></p><p>任何语言都有数据类型。Zephir与PHP和C的数据类型高度相关。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>Zephir 支持动态和静态两种类型。在这一章里,我们强调支持的类型和它的行为:</p><h3 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h3><p>与PHP动态变量是完全一样的,它们可以被分配和重新分配不同类型且没有限制。一个动态变量必须用关键字“var”声明,和PHP中的行为几乎是一样的:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b, c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize variables</span></span><br><span class="line">let a = <span class="string">"hello"</span>, b = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Change their values</span></span><br><span class="line">let a = <span class="number">10</span>, b = <span class="string">"140"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Perform operations between them</span></span><br><span class="line">let c = a + b;</span><br></pre></td></tr></table></figure><p>他们总共有八个数据类型：</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>boolean</td><td>布尔值。 true or false.</td></tr><tr><td>integer</td><td>整数的数字。整数的大小是与平台相关的。</td></tr><tr><td>float/double</td><td>浮点数。浮动的大小是与平台相关的。</td></tr><tr><td>string</td><td>一串字符组成的字符串。每个字符一个字节。</td></tr><tr><td>array</td><td>数组是有序的。</td></tr><tr><td>object</td><td>对象。与PHP对象一致。</td></tr><tr><td>resource</td><td>与PHP一致</td></tr><tr><td>null</td><td>与PHP一致</td></tr></tbody></table><h3 id="本节要点："><a href="#本节要点：" class="headerlink" title="本节要点："></a>本节要点：</h3><ul><li>代码文件组织结构。</li><li>命名空间。</li><li>语法习惯。</li><li>其他概念。</li></ul><h3 id="代码文件组织结构与命名空间"><a href="#代码文件组织结构与命名空间" class="headerlink" title="代码文件组织结构与命名空间"></a>代码文件组织结构与命名空间</h3><p>在PHP中，我们可以将代码放到任何文件中。且代码不局限于特定的形式。在Zephir中，每个文件必须包含一个类且只能有一个类。每个类必须有一个命名空间和目录结构相同。</p><p>例如，以下就是一个标准的Zephir组织结构：　　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mylibrary/</span><br><span class="line">        router/</span><br><span class="line">                exception.zep # MyLibrary\Router\Exception</span><br><span class="line">        router.zep # MyLibrary\Router</span><br></pre></td></tr></table></figure><p>MyLibrary\Router 类对应的代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MyLibrary</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类MyLibrary/Router/Exception代码如下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MyLibrary</span>\<span class="title">Router</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exception</span> <span class="keyword">extends</span> \<span class="title">Exception</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="语句分隔"><a href="#语句分隔" class="headerlink" title="语句分隔"></a>语句分隔</h3><p>不同语句表达式之间使用分号进行分隔。跟PHP、C/C++、Java一样。例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObject-&gt;myMethod(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="keyword">echo</span> <span class="string">"world"</span>;</span><br></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>Zephir 支持 C/C++ 风格的注释。如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this is one line comment</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * multi-line comment</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>在大多数语言中，注释会被编译器/解释器忽略。在 Zephir 中，注释会当作文档并输出到生成的代码中去。所以，它是代码的一部分。</p><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>Zephir,所有的变量在使用前都必须进行声明。编译器会根据提供的重要信息进行优化和验证。变量必须是惟一的标识符,他们不能是保留字。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在同一行代码中定义多个变量。</span></span><br><span class="line"><span class="keyword">var</span> a, b, c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在不同行中定义变量。</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> b;</span><br><span class="line"><span class="keyword">var</span> c;</span><br></pre></td></tr></table></figure><p>定义变量的时候，可以给变量一个默认值。您可以为变量设置一个您想要的值。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Declaring variables with default values</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"hello"</span>, b = <span class="number">0</span>, c = <span class="number">1.0</span>;</span><br><span class="line">int d = <span class="number">50</span>; bool some = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>变量名是区分大小写的,下面的变量是不同的:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Different variables</span></span><br><span class="line"><span class="keyword">var</span> somevalue, someValue, SomeValue;</span><br></pre></td></tr></table></figure><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>在方法中定义的变量的作用域都是局部的。例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Test</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">someMethod1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        int a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">someMethod2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        int a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="超全局变量"><a href="#超全局变量" class="headerlink" title="超全局变量"></a>超全局变量</h3><p>Zephir 不支持全局变量, 访问PHP中的全局变量是不允许的。然而,您可以访问PHP的超全局变量如下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 PHP 的 $_POST 中读取一个值。</span></span><br><span class="line">let price = _POST[<span class="string">"price"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 PHP 的 $_SERVER 中读取一个值。</span></span><br><span class="line">let requestMethod = _SERVER[<span class="string">"REQUEST_METHOD"</span>];</span><br></pre></td></tr></table></figure><blockquote><p>译注：在 Zephie的变量是没有PHP的$符号的。所以，就算要调用$_POST或$_SERVER等变量的时候，也不允许有$符号。</p></blockquote><h3 id="本地符号表-Local-Symbol-Table"><a href="#本地符号表-Local-Symbol-Table" class="headerlink" title="本地符号表(Local Symbol Table)"></a>本地符号表(Local Symbol Table)</h3><p>在PHP中，每个变量都当前的上下文中都有一个对应的符号表。所以，可以动态地调用或向里面写入值。（对应的PHP术语叫：可变变量）。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$b = <span class="number">100</span>;</span><br><span class="line">$a = <span class="string">"b"</span>;</span><br><span class="line"><span class="keyword">echo</span> $$a; <span class="comment">// prints 100</span></span><br></pre></td></tr></table></figure><p>Zephir没有实现这一功能,因为所有变量都被编译到低级变量，没有办法知道哪些变量存在于一个特定的上下文。如果你想创建一个变量在当前的PHP符号表,您可以使用下面的语法:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Set variable $name in PHP</span></span><br><span class="line">let &#123;<span class="string">"name"</span>&#125; = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Set variable $price in PHP</span></span><br><span class="line">let name = <span class="string">"price"</span>;</span><br><span class="line">let &#123;name&#125; = <span class="number">10.2</span>;</span><br></pre></td></tr></table></figure><h3 id="Zephir-依赖以下库："><a href="#Zephir-依赖以下库：" class="headerlink" title="Zephir 依赖以下库："></a>Zephir 依赖以下库：</h3><ul><li>json-c：C语言JSON库。github地址：<a href="https://github.com/phalcon/json-c" target="_blank" rel="noopener">https://github.com/phalcon/json-c</a></li><li>re2c : PHP语法解析器。官网地址：<a href="http://re2c.org/" target="_blank" rel="noopener">http://re2c.org/</a></li></ul><h3 id="环境要求："><a href="#环境要求：" class="headerlink" title="环境要求："></a>环境要求：</h3><ul><li>g++ &gt;= 4.4/clang++ &gt;= 3.x/vc++ 9</li><li>gnu make 3.81 or later</li><li>php development headers and tools</li></ul><h3 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h3><h4 id="1）安装依赖re2c："><a href="#1）安装依赖re2c：" class="headerlink" title="1）安装依赖re2c："></a>1）安装依赖re2c：</h4><p>因为，我的是Mac系统，所以。我使用的是如下命令安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install re2c</span><br></pre></td></tr></table></figure><p>如果你的是centos，那么应该使用如下命令安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install re2c</span><br></pre></td></tr></table></figure><h4 id="2）安装Zephir"><a href="#2）安装Zephir" class="headerlink" title="2）安装Zephir"></a>2）安装Zephir</h4><p>创建一个文件夹 zephir_test(名字随意)，然后，我们使用composer安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> composer require phalcon/zephir</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ./zephir_test/vendor/phalcon/zephir</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/json-c/json-c.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./install-json</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./install -c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./zephir_test/vendor/phalcon/zephir/bin/zephir compile</span></span><br></pre></td></tr></table></figure><p>通过以上步骤就算安装好了。测试安装是否成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ./zephir_test/vendor/phalcon/zephir/bin</span><br><span class="line">$ ./zephir</span><br></pre></td></tr></table></figure><p>如果没有报错，说明就安装成功了。</p><h4 id="3）将-zephir-命令添加到-PATH中"><a href="#3）将-zephir-命令添加到-PATH中" class="headerlink" title="3）将 zephir 命令添加到 PATH中"></a>3）将 zephir 命令添加到 PATH中</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim /etc/profile</span></span><br></pre></td></tr></table></figure><p>在文件末尾增加如下代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/Users/qlj/codespace/phpcode/zephir_test/vendor/phalcon/zephir/bin</span><br></pre></td></tr></table></figure><p>激活使其生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> /etc/profile</span></span><br></pre></td></tr></table></figure><h3 id="二、创建第一个Zephir扩展"><a href="#二、创建第一个Zephir扩展" class="headerlink" title="二、创建第一个Zephir扩展"></a>二、创建第一个Zephir扩展</h3><p>通过 Zephir 命令创建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> zephir init wlib</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> wlib/wlib</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim greeting.zep</span></span><br></pre></td></tr></table></figure><p>增加如下代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Wlib</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"hello world!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>greeting.zep路径为wlib/wlib/greeting.zep。</p></blockquote><p>则需要在greeting.zep上一级目录下执行如下命令编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> zephir build</span></span><br></pre></td></tr></table></figure><p>输入如下内容则编译成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Compiling...</span><br><span class="line">Installing...</span><br><span class="line">Password:</span><br><span class="line">Extension installed!</span><br><span class="line">Don&apos;t forget to restart your web server</span><br></pre></td></tr></table></figure><p>这个时候，就已经生成了so文件。则只需要在php.ini末尾增加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[wlib]</span><br><span class="line">extension=wlib.so</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim test.php</span></span><br></pre></td></tr></table></figure><p>增加如下代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> Wlib\Greeting::say(), <span class="string">"\n"</span>;</span><br></pre></td></tr></table></figure><p>执行输出如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> php test.php</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world!</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> PHP面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS——Swift 4.0 适配实战总结（Xcode9）</title>
      <link href="/2017/11/27/iOS%E2%80%94%E2%80%94Swift-4-0-%E9%80%82%E9%85%8D%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93%EF%BC%88Xcode9%EF%BC%89/"/>
      <url>/2017/11/27/iOS%E2%80%94%E2%80%94Swift-4-0-%E9%80%82%E9%85%8D%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93%EF%BC%88Xcode9%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>iOS的小伙伴有没有觉得今年特别与众不同，是因为iPhone X出来了吗？是的，但是不仅仅是因为iPhone X的面世。 还有 Xcode 9无线调试，Swift 4升级适配，iPhone X适配，前面介绍了iPhone X适配总结，这里整理一下Swift 4.0升级与适配处理…..</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h5 id="ios开发中，适配越来越多了："><a href="#ios开发中，适配越来越多了：" class="headerlink" title="ios开发中，适配越来越多了："></a>ios开发中，适配越来越多了：</h5><ul><li>Xcode适配</li><li>Swift升级适配</li><li>iPhone适配</li></ul><p>其中Xcode没有太多东西可说，最重要的是iPhone适配，尤其是最新的iPhone X的适配。</p><blockquote><p>iPhone X的适配之前有整理过一篇文章根据实际进行总结<a href="https://icocos.github.io/2017/11/18/iOS%E2%80%94%E2%80%94iPhone-X%E9%80%82%E9%85%8D%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/">iPhone X适配实战总结</a>，</p></blockquote><p>这里主要介绍一下最新版Swift 4适配，并简单的说一下关于Xcode9特性与适配的问题</p><blockquote><p>关于Swift新特性可以参考这里：<a href="http://www.jianshu.com/p/f35514ae9c1a" target="_blank" rel="noopener">http://www.jianshu.com/p/f35514ae9c1a</a></p></blockquote><p>Xcode 9 中同时集成了 Swift 3.2 和 Swift 4。</p><ol><li>Swift 3.2 完全兼容 Swift 3.1，并会在过时的语法或函数上报告警告。</li><li>Swift 3.2 具有 Swift 4 的一些写法，但是性能不如 Swift 4。</li><li>Swift 3.2 和 Swift 4 可以混合编译，可以指定一部分模块用 Swift 3.2 编译，一部分用 Swift 4 编译。</li><li>迁移到 Swift 4 后能获得 Swift 4 所有的新特性，并且性能比 Swift 3.2 好。</li></ol><blockquote><blockquote><p>当 Xcode 正式版发布后，现有的 Swift 代码可以直接升级到 Swift 3.2 而不用做任何改动，也可以后续再迁移到 Swift 4。<br>或者直接迁移到 Swift 4 也可以，Swift 4 相比 Swift 3 的 API 变化还是不大的，很多第三方库都可以直接用 Swift 4 编译。<br>Swift 1 到 2 和 Swift 2 到 3 的迁移的痛苦在 3 到 4 的迁移上已经大大改善了。</p></blockquote></blockquote><h2 id="适配"><a href="#适配" class="headerlink" title="适配"></a>适配</h2><p>关于Swift 4适配中OC与Swift混编的坑比较多</p><h3 id="查看当前版本"><a href="#查看当前版本" class="headerlink" title="查看当前版本"></a>查看当前版本</h3><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/17Images/11/0001.png" alt="曹理鹏(iCocos)-梦工厂"></p><h2 id="当前环境"><a href="#当前环境" class="headerlink" title="当前环境"></a>当前环境</h2><ul><li>Mac OS 10.12.6</li><li>XCode 9.1</li><li>当前Swift版本 3.2</li></ul><h2 id="一键升级"><a href="#一键升级" class="headerlink" title="一键升级"></a>一键升级</h2><p>这一特性非常6，印象中是swift2的时候出来的，具体时间也忘了。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/17Images/11/0002.png" alt="曹理鹏(iCocos)-梦工厂"></p><ul><li>然后勾选需要转换的 target （pod 引用不用勾选），Next </li><li>然后选择转换选项，Next<br>  这两个选项是关于 swift 的 @objc 推断特性的，如果使用了 swift4.0 显式的 @objc 属性，能减少整体代码的大小。此时我们选 Minimize Inference（recommend）<br>  <img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/17Images/11/0003.png" alt="曹理鹏(iCocos)-梦工厂"><ul><li>Minimize Inference（recommend）<ul><li>根据静态推断，仅在需要的地方添加@objc属性。使用此选项后，需要按照Completing a Swift 4 minimize inference migration来完成转换。</li></ul></li><li>Match Swift 3 Behavior<ul><li>在编译器隐式推断的任何地方向代码添加一个@objc属性。这个选项不会改变你的二进制文件的大小，因为被Swift 3隐式推断在所有的地方都添加了显式的@objc属性。</li></ul></li></ul></li></ul><h3 id="修改错误-细节"><a href="#修改错误-细节" class="headerlink" title="修改错误+细节"></a>修改错误+细节</h3><blockquote><p>完成上面之后，不会发现当前版本确实编程的Swift 4，但是好像跑步起来，到处报错。</p></blockquote><ul><li>对，毕竟是工具，不可能那么人性化，有些地方还是需要人工进行专门的适配</li></ul><h4 id="问题一：编译不通过"><a href="#问题一：编译不通过" class="headerlink" title="问题一：编译不通过"></a>问题一：编译不通过</h4><p>如果项目中之前有class和extension，有些也给OC调用。在OC的代码中，我们通过#import “ModuleName-Swift.h”导入了Swift文件。如果是Swift3.2，一切都能正常工作，但是在Swift4.0上，编译通不过了。</p><blockquote><p>如果你看了Swift 4特性的话应该知道</p><blockquote><p>swift4.0 最大的特性之一就是 @objc 修饰符的变化了，它主要处理 OC 和 swift 混编时一些方法的调用以及属性获取问题，swift4.0 将在 swift3.x 中一些隐式类型推断的特性去除以后，需要我们来手动管理 @objc 修饰符。 </p></blockquote></blockquote><h6 id="具体解决方案："><a href="#具体解决方案：" class="headerlink" title="具体解决方案："></a>具体解决方案：</h6><ul><li>一：在OC中调用一个Swift4.0类的方法（包括实例方法、static方法、class方法），你需要：<ul><li>在该Swift4.0类前加上修饰符@objc</li><li>该Swift4.0类必须继承NSObject(否则，无法在前面加上修饰符@objc。当然，这里指的是普通类，@objc也是可以修饰UI开头的一系列UIKit框架下的UI类，只是修饰了这些类，不会产生什么影响)</li><li>在需要调用的方法前加上修饰符@objc</li></ul></li><li>二：在OC中调用一个Swift4.0扩展的属性（包括实例属性、static属性、class属性）、方法（包括实例方法、static方法、class法），你有如下两种选择方式：<ul><li>在该Swift4.0扩展前加上修饰符@objc(这样的话，该扩展下的所有的属性、方法，都可被OC调用)。</li><li>在需要的属性、方法前直接加上@objc修饰，也可达到目的。</li></ul></li></ul><blockquote><p>注意一点：swift3 使用 #selector 指定的方法，只有当方法权限为 private 时需要加 @objc 修饰符，swift4.0 都要加 @objc 修饰符<br>swift4.0 不再允许重载 extension 中的方法(包括instance、static、class方法)</p></blockquote><h4 id="问题二：运行时找不到属性"><a href="#问题二：运行时找不到属性" class="headerlink" title="问题二：运行时找不到属性"></a>问题二：运行时找不到属性</h4><p>如果你有一个Swift类继承自UIViewController，OC中调用或者操作这个类[viewController valueForKey:@”userName”]这一KVC方法去获取这个自定义UIViewController中的iconURL这一属性的属性值。</p><p>这种方式，编译时是无法检查出问题的。但是在运行时，问题就来了，找不到这个属性。因为这个属性没有暴露给OC来进行调用。</p><h6 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h6><ul><li>仅需要在自定义的UIViewController类中给需要暴露给OC调用的属性前加上@objc修饰符便可。如此一来，在OC代码中就能访问到这个属性。<ul><li>(注意：这里可不像上面提到的extension一样，在这个已定义的UIViewController类前面加上@objc修饰符没有任何意义)。</li></ul></li></ul><h4 id="编译警告"><a href="#编译警告" class="headerlink" title="编译警告"></a>编译警告</h4><ul><li>swift 中编译的警告 <ul><li>“#selector” 参数指定的实例方法必须使用 @objc 修饰，因为swift4中弃用了 @objc属性推断。</li></ul></li><li>Objective-C 编译时警告<ul><li>在 OC 中调用的 swift 方法，在 swift 中需要追加 @objc 修饰，swift4 废弃了该类型推断。</li></ul></li></ul><h5 id="关于编译时也是直接增加-objc即可"><a href="#关于编译时也是直接增加-objc即可" class="headerlink" title="关于编译时也是直接增加@objc即可"></a>关于编译时也是直接增加@objc即可</h5><h4 id="运行时警告"><a href="#运行时警告" class="headerlink" title="运行时警告"></a>运行时警告</h4><p>运行时警告会打印在控制台：</p><pre><code>***Swift runtime: ClassName.swift:lineInFile:columnInLine: entrypoint -[ClassName methodName] generated by implicit @objc inference is deprecated and will be removed in Swift 4; add explicit @objc to the declaration to emit the Objective-C entrypoint in Swift 4 and suppress this message</code></pre><p>同样：想要修复运行时警告，需要添加 @objc 修饰符到对应的方法或者符号。</p><ul><li>运行时警告的常见原因:<ul><li>在 OC 中使用 SEL</li><li>在 swift 中使用了 perform methods</li><li>在 OC 中使用了 performSelector methods</li><li>使用了 @IBOutlet 或者 @IBAction</li></ul></li></ul><h4 id="NSAttributedStringKey"><a href="#NSAttributedStringKey" class="headerlink" title="NSAttributedStringKey"></a>NSAttributedStringKey</h4><pre><code>swift3.xpublic init(string str: String, attributes attrs: [AnyHashable : Any]? = nil)swift4.0public init(string str: String, attributes attrs: [NSAttributedStringKey : Any]? = nil)</code></pre><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><h5 id="废弃characters"><a href="#废弃characters" class="headerlink" title="废弃characters"></a>废弃characters</h5><pre><code>swift 3var count = string.characters.counterror&apos;characters&apos; is deprecated: Please use String or Substring directlyswift 4count = string.count</code></pre><h5 id="废弃addingPercentEscapes"><a href="#废弃addingPercentEscapes" class="headerlink" title="废弃addingPercentEscapes"></a>废弃addingPercentEscapes</h5><pre><code>swift 3var url = @&quot;http://www.example.com?username=姓名&quot;url = url.addingPercentEscapes(using: String.Encoding.utf8)!error&apos;addingPercentEscapes(using:)&apos; is unavailable: Use addingPercentEncoding(withAllowedCharacters:) instead, which always uses the recommended UTF-8 encoding, and which encodes for a specific URL component or subcomponent since each URL component or subcomponent has different rules for what characters are valid.swift 4uri = uri.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlQueryAllowed)!</code></pre><h5 id="废弃substring-to"><a href="#废弃substring-to" class="headerlink" title="废弃substring(to:)"></a>废弃substring(to:)</h5><pre><code>swift 3let index = tagText.index(tagText.startIndex, offsetBy: MPMultipleStyleListItemTagMaxLength)// 警告：&apos;substring(to:)&apos; is deprecated: Please use String slicing subscript with a &apos;partial range upto&apos; operator.let b = tagText.substring(to: index)Swift 4let a = tagText.prefix(upTo: index) //a 的类型是 Substring，不是 String</code></pre><h3 id="pod-引用"><a href="#pod-引用" class="headerlink" title="pod 引用"></a>pod 引用</h3><p>添加以下内容到 Podfile。</p><pre><code>post_install do |installer|    installer.pods_project.targets.each do |target|        if [&apos;WTCarouselFlowLayout&apos;, &apos;XSLRevenue&apos;, &apos;OHHTTPStubs/Swift&apos;].include? target.name            target.build_configurations.each do |config|                config.build_settings[&apos;SWIFT_VERSION&apos;] = &apos;3.2&apos;            end        end    endend</code></pre><h3 id="系统方法"><a href="#系统方法" class="headerlink" title="系统方法"></a>系统方法</h3><p>UITableViewDelegate 协议方法名变更，没有错误提示：</p><pre><code>// swift3.xfunc tableView(_ tableView: UITableView, heightForRowAtIndexPath indexPath: IndexPath) -&gt; CGFloat // swift4.0func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat </code></pre><h3 id="Xcode-9"><a href="#Xcode-9" class="headerlink" title="Xcode 9"></a>Xcode 9</h3><p>关于Xcode 9适配其实并没有太多可说的地方，具体可参考苹果官方Session,但是我相信有一点是很多开发都非常喜欢的特性：无线调试</p><h5 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h5><ul><li>不用经常买线，不用担心接口或者插口坏了</li><li>不用担心忘记带线，无法调试</li><li>不用每次都插着才能调试（嘿，测试的MM，我给你装个最新的包，你接好了）</li><li>…</li></ul><h5 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h5><ol><li>必须是Xcode9-beta以上</li><li>iPhone系统需iOS11以上</li></ol><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><ol><li>在Xcode9-beta菜单的Window选项中选择Devices and Simulators</li><li>通过连接线让你的Mac识别到你的iPhone</li><li>在Devices and Simulators面板的左侧Connected菜单中选择连接的设备</li><li>在顶部的Devices和Simulators选项中选择Devices(这里其实默认就是选择了Devices)，</li><li>勾选Connect via network选项。</li></ol><h6 id="关于Xcode无线调试可参考下面地址"><a href="#关于Xcode无线调试可参考下面地址" class="headerlink" title="关于Xcode无线调试可参考下面地址"></a>关于Xcode无线调试可参考下面地址</h6><blockquote><p>WWDC17惊喜——Xcode9无线调试<br><a href="https://icocos.github.io/2017/06/13/WWDC17%E6%83%8A%E5%96%9C%E2%80%94%E2%80%94Xcode9%E6%97%A0%E7%BA%BF%E8%B0%83%E8%AF%95/">https://icocos.github.io/2017/06/13/WWDC17%E6%83%8A%E5%96%9C%E2%80%94%E2%80%94Xcode9%E6%97%A0%E7%BA%BF%E8%B0%83%E8%AF%95/</a></p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Swift3.2到Swift4.0的改变(只是我项目中遇到的)：</p><ol><li><p>Swift4.0中对于扩展的属性(包括实例属性、static属性、class属性)，都只能使用get方法，不可使用set方法</p></li><li><p>Swift4.0中不再允许复写扩展中的方法(包括实例方法、static方法、class方法)</p></li><li><p>编译期与运行时警告处理，添加 @objc 修饰符到对应的方法或者符号。</p></li><li><p>swift3使用#selector指定的方法，只有当方法权限为private时需要加@objc修饰符，现在全都要加@objc修饰符</p></li><li><p>字体方面的一些重命名</p><ul><li>NSFontAttributeName重命名为NSAttributedStringKey.font、</li><li>NSForegroundColorAttributeName重命名为NSAttributedStringKey.foregroundColor、</li><li>NSStrikethroughStyleAttributeName重命名为NSAttributedStringKey.strikethroughStyle、</li><li>size(withAttributes:)方法重命名为size(withAttributes:))</li></ul></li></ol><ul><li>…</li></ul><h3 id="官方参考资料"><a href="#官方参考资料" class="headerlink" title="官方参考资料"></a>官方参考资料</h3><ul><li>《Swift Language Programming (Swift 4.0)》</li><li>WWDC 2017 Session 402 《What’s New in Swift》</li><li>WWDC 2017 Session 212 《What’s New in Foundation》</li><li>WWDC 2017 Session 102 《Platforms State of the Union》</li></ul>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> iOS——Swift 4.0 适配实战总结（Xcode9） </tag>
            
            <tag> Swift 4.0 适配实战总结（Xcode9） </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS——iPhone X适配实战总结</title>
      <link href="/2017/11/18/iOS%E2%80%94%E2%80%94iPhone-X%E9%80%82%E9%85%8D%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/"/>
      <url>/2017/11/18/iOS%E2%80%94%E2%80%94iPhone-X%E9%80%82%E9%85%8D%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>最近公司项目需要开始适配iPhone X了，之前在网上看到过很多讲解iPhone X适配的文章，也刷过几篇文章看了一遍，但是看完之后实在受不了各种假帖。甚至讲的都是一些理论和差异上的东西，真正讲解实际开发中适配iPhone的并没有多少，有些看完正片文章之后都不知道怎么开始。</p><blockquote><p>于是自己去根据官方提供的资料和指南写一篇只针对iPhone X适配的贴子……</p></blockquote><a id="more"></a><h5 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h5><ol><li>本文从实际开发着手iPhone X适配，关于相关理论与常识内容不会过多解释。</li><li>本文会分析iPhone X适配的几个不同方向和相关的处理方案</li><li>本文会分析并总结适配和测试过程中遇到的Bug，最终给出实际的适配方案或者代码</li><li>本文会尽量多的从实际项目与实际适配步骤会代码进行介绍</li></ol><h5 id="官方资料"><a href="#官方资料" class="headerlink" title="官方资料"></a>官方资料</h5><p><a href="https://developer.apple.com/ios/human-interface-guidelines/overview/iphone-x/" target="_blank" rel="noopener">HIG-Human Interface Guideline</a><br><a href="https://developer.apple.com/videos/play/fall2017/201/" target="_blank" rel="noopener">官方Session</a></p><h5 id="首先我们要明确一点："><a href="#首先我们要明确一点：" class="headerlink" title="首先我们要明确一点："></a>首先我们要明确一点：</h5><h6 id="iPhone-X适配的宗旨：我们要做的是让那些不能被遮挡的内容和控件在安全区域范围内显示"><a href="#iPhone-X适配的宗旨：我们要做的是让那些不能被遮挡的内容和控件在安全区域范围内显示" class="headerlink" title="iPhone X适配的宗旨：我们要做的是让那些不能被遮挡的内容和控件在安全区域范围内显示,"></a>iPhone X适配的宗旨：我们要做的是让那些不能被遮挡的内容和控件在安全区域范围内显示,</h6><h3 id="一-iPhone-X的规则"><a href="#一-iPhone-X的规则" class="headerlink" title="一.iPhone X的规则"></a>一.iPhone X的规则</h3><p>| <img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/115/iphoneX006.png"> |  <img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/115/iphoneX008.png"> |</p><ol><li>iPhone X是真正的3x标准，印象中7p是2.88x</li><li>iPhone X宽度和4.7的6，7，8一致（375），高度多出145pt（+20%）</li><li>iPhone X的比例是9：19.5，而4.7的6，7，8比例是9：16，</li><li>iPhone X（375<em>812-&gt;1125</em>2436-&gt;5.8英寸）Super Retina</li><li>状态栏20-&gt;44(留海H=30，W=209,耳朵W=83)，底脚0-&gt;34</li><li>实际上可有效利用的高度为：145 – 24 (Status Bar) – 34 (Home Indicator) = 87pt</li><li>键盘高度由 216pt 增长为 291pt，设计文字区域时要小心</li><li>Home Indicator，Tab Bar 高度由 49pt 增长为 83pt</li><li>横屏时Home Indicator的高度为21pt，需要格外注意</li></ol><p>| <img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/115/iphoneX002.png"> |  <img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/115/iphoneX003.png"> | </p><blockquote><p>iPhone X竖屏时占满整个屏幕的控制器的view的safeAreaInsets是（44，0，34，0），横屏是（0，44，21，44），inset后的区域正好是safeAreaLayoutGuide区域</p><p>如果你的 UI「顶部」有 Navigation Bar 或其它类似的UI控件，那么一般来说，在设计稿将 Navigation Bar 的背景色往上延伸 44pt，「垫在 Status Bar 后方」作为背景色即可<br>如果你的 UI「底部」有 Tab Bar、Toolbar 或其它类似的UI控件，在设计稿时将背景色往下延伸 34pt，「垫在 Home Indicator 后方」作为背景色即可。</p></blockquote><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/115/iphoneX001.png"></p><h3 id="二：-iOS11相关"><a href="#二：-iOS11相关" class="headerlink" title="二： iOS11相关"></a>二： iOS11相关</h3><ol><li><p>如果只是设置了titleView，没有设置barbutton，把titleview的宽度设置为屏幕宽度，则titleview距离屏幕的边距，iOS11之前，在iPhone6p上是20p，在iPhone6p之前是16p；iOS11之后，在iPhone6p上是12p，在iPhone6p之前是8p。</p></li><li><p>如果只是设置了barbutton，没有设置titleview，则在iOS11里，barButton距离屏幕的边距是20p和16p；在iOS11之前，barButton距离屏幕的边距也是20p和16p。</p></li><li><p>如果同时设置了titleView和barButton，则在iOS11之前，titleview和barbutton之间的间距是6p，在iOS11上titleview和barbutton之间无间距</p></li><li><p>estimatedRowHeight是一个预估高度，iOS11之前是为0，在iOS11下，这个值默认为44。</p></li><li><p>iOS11以前,我们布局时, 视图的 top 和 bottom 一般参照的是 Top Layout Guide 和 Bottom Layout Guide</p></li><li><p>iOS11为UIViewController和UIView增加了两个新的属性safeAreaInsets和safeAreaLayoutGuide, 通过这两个属性我们可以获得安全区域的范围</p><pre><code>safeAreaInsets 适用于手动计算.safeAreaLayoutGuide 适用于自动布局.</code></pre></li></ol><h3 id="三-iPhone环境判断"><a href="#三-iPhone环境判断" class="headerlink" title="三. iPhone环境判断"></a>三. iPhone环境判断</h3><ul><li>通过分辨率判断：<pre><code>#define kDevice_Is_iPhoneX ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(1125, 2436), [[UIScreen mainScreen] currentMode].size) : NO)</code></pre></li><li>通过设备名称判断：<pre><code>@&quot;iPhone10,1&quot; : @&quot;iPhone 8&quot;,@&quot;iPhone10,4&quot; : @&quot;iPhone 8&quot;,@&quot;iPhone10,2&quot; : @&quot;iPhone 8 Plus&quot;,@&quot;iPhone10,5&quot; : @&quot;iPhone 8 Plus&quot;,@&quot;iPhone10,3&quot; : @&quot;iPhone X&quot;,@&quot;iPhone10,6&quot; : @&quot;iPhone X&quot;,</code></pre></li><li>判断状态栏的高度（如果状态栏没有隐藏，且竖屏的情况）</li><li>判断屏幕的高度或者宽度（横屏的时候）</li><li>根据是否可执行或者获取对应API的值（safeAreaInseret）</li><li>根据系统框架</li></ul><h5 id="常用宏定义"><a href="#常用宏定义" class="headerlink" title="常用宏定义"></a>常用宏定义</h5><pre><code>#define IS_IPHONE_X_HEIGHT         ([[UIScreen mainScreen] bounds].size.height &gt;= 812.0f ? 812.0f : 667.0f)#define ScaleWidth(width)           width/ 375.0*KSCREEN_WIDTH#define ScaleHeigth(height)           height/IS_IPHONE_X_HEIGHT*KSCREEN_HEIGHT#define WKSW(width)           width/375.0*KSCREEN_WIDTH#define WKSH(height)           height/IS_IPHONE_X_HEIGHT*KSCREEN_HEIGHT#define SafeAreaTopHeight (kWJScreenHeight == 812.0 ? 88 : 64)#define VIEWSAFEAREAINSETS(view) ({UIEdgeInsets i; if(@available(iOS 11.0, *)) {i = view.safeAreaInsets;} else {i = UIEdgeInsetsZero;} i;})VIEWSAFEAREAINSETS(view).leftVIEWSAFEAREAINSETS(self.view).right</code></pre><h3 id="四-启动页的适配"><a href="#四-启动页的适配" class="headerlink" title="四.启动页的适配"></a>四.启动页的适配</h3><p>启动页的启动方式</p><ul><li>LaunchScreen(这里直接设置图片就可以)</li><li>LaunchImage</li></ul><blockquote><p>使用对应的设计图片：1125 * 2436</p></blockquote><p>如果使用的是Assets中的LaunchImage, 在增加了iPhone X尺寸的图片配置.<br>准备一张尺寸:1125 * 2436的启动图片, 移动到LaunchImage的Finder目录中, 并在LaunchImage中的Contents.json文件中增加 (注意Json格式):</p><pre><code>{    &quot;extent&quot; : &quot;full-screen&quot;,    &quot;idiom&quot; : &quot;iphone&quot;,    &quot;subtype&quot; : &quot;2436h&quot;,    &quot;filename&quot; : &quot;图片名.png&quot;,    &quot;minimum-system-version&quot; : &quot;11.0&quot;,    &quot;orientation&quot; : &quot;portrait&quot;,    &quot;scale&quot; : &quot;3x&quot;}</code></pre><h3 id="五-刷新框架的适配iOS11"><a href="#五-刷新框架的适配iOS11" class="headerlink" title="五.刷新框架的适配iOS11"></a>五.刷新框架的适配iOS11</h3><p>这里拿最有名的刷新框架,如果使用的类似的刷新框架并且隐藏导航那么你或许会遇到：刷新控件和留海重合且被挡住</p><h6 id="具体原因："><a href="#具体原因：" class="headerlink" title="具体原因："></a>具体原因：</h6><pre><code>iOS 11上面废除了automaticallyAdjustsScrollViewInsets，使用contentInsetAdjustmentBehavior代替</code></pre><p>适配具体代码：</p><pre><code>if (@available(iOS 11.0, *)) {    self.home_collectionView.contentInsetAdjustmentBehavior = UIApplicationBackgroundFetchIntervalNever;} else {    self.automaticallyAdjustsScrollViewInsets = false;    // Fallback on earlier versions}</code></pre><h5 id="宏定义："><a href="#宏定义：" class="headerlink" title="宏定义："></a>宏定义：</h5><pre><code>/// 第一个参数是当下的控制器适配iOS11 一下的，第二个参数表示scrollview或子类#define AdjustsScrollViewInsetNever(controller,view) if(@available(iOS 11.0, *)) {    view.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;} else if([controller isKindOfClass:[UIViewController class]]) {    controller.automaticallyAdjustsScrollViewInsets = false;}</code></pre><h3 id="六：导航栏"><a href="#六：导航栏" class="headerlink" title="六：导航栏"></a>六：导航栏</h3><p>在iOS11导航栏多了一个LargeTitleView，专门显示大字标题用的，整个导航栏的高度达到了96p，这不包括状态栏的高度，也就是说，整个app顶部高度达到了116p，其中statusbar=20，title=44，largetitle=52，不过默认是64p；</p><ul><li>当然，iPhoneX的高度会更高点，如果不显示大字标题，顶部的高度也达到了88，statusbar=44，title=44，如果显示大字标题，则高度变成了140，statusbar=44，title=44，largetitle=52，也就是说，iPhoneX的刘海高度为24p，</li></ul><h3 id="七：导航栏按钮间距变化-UIBarButtonItem-iPhoneX-amp-iOS-11"><a href="#七：导航栏按钮间距变化-UIBarButtonItem-iPhoneX-amp-iOS-11" class="headerlink" title="七：导航栏按钮间距变化(UIBarButtonItem) (iPhoneX &amp; iOS 11)"></a>七：导航栏按钮间距变化(UIBarButtonItem) (iPhoneX &amp; iOS 11)</h3><h6 id="iOS11以后，导航栏的层级发生了变化，也无法时使导航栏左右按钮边距为0了"><a href="#iOS11以后，导航栏的层级发生了变化，也无法时使导航栏左右按钮边距为0了" class="headerlink" title="iOS11以后，导航栏的层级发生了变化，也无法时使导航栏左右按钮边距为0了"></a>iOS11以后，导航栏的层级发生了变化，也无法时使导航栏左右按钮边距为0了</h6><blockquote><p>iOS11之前导航栏的title是添加在UINavigationItemView上面，而navigationBarButton则直接添加在UINavigationBar上面，如果设置了titleView，则titleView也是直接添加在UINavigationBar上面。iOS11之后，大概因为largeTitle的原因，视图层级发生了变化，如果没有给titleView赋值，则titleView会直接添加在_UINavigationBarContentView上面，如果赋值了titleView，则会把titleView添加在_UITAMICAdaptorView上，而navigationBarButton被加在了_UIButtonBarStackView上，然后他们都被加在了_UINavigationBarContentView上</p></blockquote><p>所以如果你的项目是自定义的navigationBar，那么在iOS11上运行就可能出现布局错乱的bug，解决办法是重写UINavigationBar的layoutSubviews方法，调整布局，上代码：</p><pre><code>- (void)layoutSubviews {    [super layoutSubviews];    //注意导航栏及状态栏高度适配    self.frame = CGRectMake(0, 0, CGRectGetWidth(self.frame), naviBarHeight);    for (UIView *view in self.subviews) {        if([NSStringFromClass([view class]) containsString:@&quot;Background&quot;]) {            view.frame = self.bounds;        }        else if ([NSStringFromClass([view class]) containsString:@&quot;ContentView&quot;]) {            CGRect frame = view.frame;            frame.origin.y = statusBarHeight;            frame.size.height = self.bounds.size.height - frame.origin.y;            view.frame = frame;        }    }}</code></pre><p>看了简书App适配iOS11发现titleView支持autolayout，这要求titleView必须是能够自撑开的或实现了- intrinsicContentSize方法</p><pre><code>- (CGSize)intrinsicContentSize {    return UILayoutFittingExpandedSize;}</code></pre><ol><li>导航栏新增了一种大标题样式，默认设置是不开启，所以不需要修改。</li><li>titleView支持autolayout，这要求titleView必须是能够自撑开的或实现了- intrinsicContentSize，</li></ol><p><a href="http://www.jianshu.com/p/352f101d6df1" target="_blank" rel="noopener">App需要实现导航栏左右按钮边距为0</a></p><h3 id="八：继承自UIScrollView的视图偏移问题"><a href="#八：继承自UIScrollView的视图偏移问题" class="headerlink" title="八：继承自UIScrollView的视图偏移问题"></a>八：继承自UIScrollView的视图偏移问题</h3><p>在iOS11设备上运行出现最多问题应该就是tableview莫名奇妙的偏移20pt或者64pt了。。原因是iOS11弃用了automaticallyAdjustsScrollViewInsets属性（前面有提到），取而代之的是UIScrollView新增了contentInsetAdjustmentBehavior属性，这一切的罪魁祸首都是新引入的safeArea，</p><h6 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h6><blockquote><p>原因是iOS 11中Controller的automaticallyAdjustsScrollViewInsets属性被废弃了，所以当tableView超出安全区域时系统自动调整了SafeAreaInsets值，进而影响adjustedContentInset值，在iOS 11中决定tableView的内容与边缘距离的是adjustedContentInset属性，而不是contentInset。adjustedContentInset的计算方式见本文第二部分内容。因为系统对adjustedContentInset值进行了调整，所以导致tableView的内容到边缘的距离发生了变化，导致tableView下移了20pt（statusbar高度）或64pt（navigationbar高度）。</p></blockquote><p>如果你的APP中使用的是自定义的navigationbar，隐藏掉系统的navigationbar，并且tableView的frame为(0,0,SCREEN_WIDTH, SCREEN_HEIGHT)开始，那么系统会自动调整SafeAreaInsets值为(20,0,0,0)，如果使用了系统的navigationbar，那么SafeAreaInsets值为(64,0,0,0)，如果也使用了系统的tabbar，那么SafeAreaInsets值为(64,0,49,0)</p><pre><code>if (@available(iOS 11.0, *)) {    self.tableView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;} else {    self.automaticallyAdjustsScrollViewInsets = NO;}</code></pre><p>这个问题的解决方法有哪些？</p><ul><li>重新设置tableView的contentInset值，来抵消掉SafeAreaInset值，因为内容下移偏移量 = contentInset + SafeAreaInset；</li></ul><blockquote><p>如果之前自己设置了contentInset值为(64,0,0,0),现在系统又设置了SafeAreaInsets值为(64,0,0,0)，那么tableView内容下移了64pt，这种情况下，可以设置contentInset值为(0,0,0,0)，也就是遵从系统的设置了。</p></blockquote><ul><li>设置tableView的contentInsetAdjustmentBehavior属性</li></ul><p>如果不需要系统为你设置边缘距离，可以做以下设置：</p><pre><code>//如果iOS的系统是11.0，会有这样一个宏定义“#define __IPHONE_11_0  110000”；如果系统版本低于11.0则没有这个宏定义#ifdef __IPHONE_11_0    if ([tableView respondsToSelector:@selector(setContentInsetAdjustmentBehavior:)]) {        tableView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;    }#endif</code></pre><p>contentInsetAdjustmentBehavior属性也是用来取代automaticallyAdjustsScrollViewInsets属性的，推荐使用这种方式。</p><ul><li>通过设置iOS 11新增的属性addtionalSafeAreaInset；</li></ul><p>iOS 11之前，大家是通过将Controller的automaticallyAdjustsScrollViewInsets属性设置为NO，来禁止系统对tableView调整contentInsets的。如果还是想从Controller级别解决问题，那么可以通过设置Controller的additionalSafeAreaInsets属性，如果SafeAreaInset值为(20,0,0,0)，那么设置additionalSafeAreaInsets属性值为(-20,0,0,0)，则SafeAreaInsets不会对adjustedContentInset值产生影响，tableView内容不会显示异常。</p><blockquote><p>这里需要注意的是addtionalSafeAreaInset是Controller的属性，要知道SafeAreaInset的值是由哪个Controller引起的，可能是由自己的Controller调整的，可能是navigationController调整的。是由哪个Controller调整的，则设置哪个Controller的addtionalSafeAreaInset值来抵消掉SafeAreaInset值。</p></blockquote><h3 id="九：UITableView，cell，header，footer高度异常-tableView顶部有留白"><a href="#九：UITableView，cell，header，footer高度异常-tableView顶部有留白" class="headerlink" title="九：UITableView，cell，header，footer高度异常,tableView顶部有留白"></a>九：UITableView，cell，header，footer高度异常,tableView顶部有留白</h3><p>在iOS 11中默认启用Self-Sizing，，Headers, footers, and cells都默认开启了Self-Sizing，所有estimated 高度默认值从iOS11之前的 0 改变为UITableViewAutomaticDimension<br>要解决此类异常的话，可通过以下代码解决</p><pre><code>_tableView.estimatedRowHeight = 0;_tableView.estimatedSectionHeaderHeight = 0;_tableView.estimatedSectionFooterHeight = 0;</code></pre><blockquote><p>这个配合estimatedRowHeight、estimatedSectionFooterHeight、estimatedSectionHeaderHeight使用，可以预估高度。之前，设置header或者footer高度为0时，需要设置height=0.1，才会起作用，如果直接设置为0，则会使用默认高度。iOS11由于自动使用预估高度，所以，忽略了设置的高度，使原来的高度增大了。只要把这几个属性设置为0就可以解决</p></blockquote><h6 id="在iOS11里面有时候在tableView的头部和尾部留白，因为苹果给滚动试图加进去了self-sizeing，开始计算逐步计算contentSize，默认如果不去实现viewForHeaderInSection就不会调用heightForHeaderInSection-尾部试图一样。"><a href="#在iOS11里面有时候在tableView的头部和尾部留白，因为苹果给滚动试图加进去了self-sizeing，开始计算逐步计算contentSize，默认如果不去实现viewForHeaderInSection就不会调用heightForHeaderInSection-尾部试图一样。" class="headerlink" title="在iOS11里面有时候在tableView的头部和尾部留白，因为苹果给滚动试图加进去了self-sizeing，开始计算逐步计算contentSize，默认如果不去实现viewForHeaderInSection就不会调用heightForHeaderInSection,尾部试图一样。"></a>在iOS11里面有时候在tableView的头部和尾部留白，因为苹果给滚动试图加进去了self-sizeing，开始计算逐步计算contentSize，默认如果不去实现viewForHeaderInSection就不会调用heightForHeaderInSection,尾部试图一样。</h6><pre><code>func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -&gt; UIView? { }func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -&gt; CGFloat {   return 0.001 }</code></pre><p>如果你不想实现viewForHeaderInSection也不想留白，那么只需要使用上面的三段代码把self-sizeing自动估高关闭即可</p><p>如果你使用了Masonry，某些界面需要适配需要适配safeArea，可以试试下面这段代码</p><pre><code>if (@available(iOS 11.0, *)) {    make.edges.equalTo()(self.view.safeAreaInsets)} else {    make.edges.equalTo()(self.view)}</code></pre><h3 id="十：适配iOS-11-列表的册数删除"><a href="#十：适配iOS-11-列表的册数删除" class="headerlink" title="十：适配iOS 11 列表的册数删除"></a>十：适配iOS 11 列表的册数删除</h3><p>在iOS8之后，苹果官方增加了UITableVIew的右滑操作接口，即新增了一个代理方法(tableView: editActionsForRowAtIndexPath:)和一个类(UITableViewRowAction)，代理方法返回的是一个数组，我们可以在这个代理方法中定义所需要的操作按钮(删除、置顶等)，这些按钮的类就是UITableViewRowAction。</p><p>这个类只能定义按钮的显示文字、背景色、和按钮事件。并且返回数组的第一个元素在UITableViewCell的最右侧显示，最后一个元素在最左侧显示。从iOS 11开始有了一些改变，首先是可以给这些按钮添加图片了，然后是如果实现了以下两个iOS 11新增的代理方法，将会取代(tableView: editActionsForRowAtIndexPath:)代理方法：</p><blockquote><p>注意：看的有的文章如果在iOS11上面调用老的删除，会崩溃，</p></blockquote><pre><code>- (nullable UISwipeActionsConfiguration *)tableView:(UITableView *)tableView leadingSwipeActionsConfigurationForRowAtIndexPath:(NSIndexPath *)indexPathfunc tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration?func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? {    let action = UIContextualAction(style: .destructive, title: &quot;Delete&quot;) {     (action, view, handler) in        handler(true)    }    let configuration = UISwipeActionsConfiguration(actions: [action])    return configuration}func tableView(_ tableView: UITableView, leadingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? {    let action = UIContextualAction(style: .normal, title: &quot;Mark&quot;) { (action, view, handler) in    handler(true)    }    action.backgroundColor = UIColor.init(red: 254/255.0, green: 175/255.0, blue: 254/255.0, alpha: 1);    let configuration = UISwipeActionsConfiguration(actions: [action])    return configuration}</code></pre><h3 id="十一：到底用viewSafeAreaInsetsDidChange还是viewWillLayoutSubviews"><a href="#十一：到底用viewSafeAreaInsetsDidChange还是viewWillLayoutSubviews" class="headerlink" title="十一：到底用viewSafeAreaInsetsDidChange还是viewWillLayoutSubviews"></a>十一：到底用viewSafeAreaInsetsDidChange还是viewWillLayoutSubviews</h3><p>先来看看下面一段代码，相信做过iPhone X适配的同学应该都不陌生，</p><pre><code>var safeArea: CGFloat = 0if #available(iOS 11.0, *) {    safeArea += self.view.safeAreaInsets.bottom || UIApplication.shared.keyWindow.rootViewController.view.safeAreaInsets.bottom}coding ... constant || originY || frame || height</code></pre><p>有时候，我们会发现这样的一段适配的代码，如果根据苹果的特性，和我们所了解情况，我们一般都会把他放到viewSafeAreaInsetsDidChange，<br>但是，并没有什么卵用，但是根据UI刷新的特性，我试着把他放在viewWillLayoutSubviews，却又正常了，很多人对此很是不解。</p><h5 id="首先我们要知道："><a href="#首先我们要知道：" class="headerlink" title="首先我们要知道："></a>首先我们要知道：</h5><ul><li>viewSafeAreaInsetsDidChange调用时机很早，在viewWillAppear后</li></ul><p>viewSafeAreaInsetsDidChange后面会调用两次viewDidLayoutSubviews，所以我们应该把改变高度或布局的代码都写在viewDidLayoutSubviews里，这样就不会有多余的动画效果了</p><blockquote><p>注意: viewDidLayoutSubviews可能会由别的操作频繁触发，所以如果调整safeArea布局的代码比较耗时，可以考虑加上一个状态标记，只在didChange后执行一次布局调整</p></blockquote><pre><code>- (void)viewDidLayoutSubviews {    [super viewDidLayoutSubviews];    UIEdgeInsets safeAreaInsets = sgm_safeAreaInset(self.view);    CGFloat height = 44.0; // 导航栏原本的高度，通常是44.0    height += safeAreaInsets.top &gt; 0 ? safeAreaInsets.top : 20.0; // 20.0是statusbar的高度，这里假设statusbar不消失    if (_navigationbar &amp;&amp; _navigationbar.height != height) {        _navigationbar.height = height;    }}</code></pre><h3 id="十二：纯代码的宽高比适配"><a href="#十二：纯代码的宽高比适配" class="headerlink" title="十二：纯代码的宽高比适配"></a>十二：纯代码的宽高比适配</h3><pre><code>/// 高度系数 812.0 是iPhoneX的高度尺寸，667.0表示是iPhone 8 的高度，如果你觉的它会变化，那我也很无奈#define kWJHeightCoefficient (kWJScreenHeight == 812.0 ? 667.0/667.0 : kWJScreenHeight/667.0)</code></pre><p>| <img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/115/iphoneX004.png"> |  <img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/115/iphoneX005.png"> |</p><h3 id="十三：纯代码适配iPhone-X脚底"><a href="#十三：纯代码适配iPhone-X脚底" class="headerlink" title="十三：纯代码适配iPhone X脚底"></a>十三：纯代码适配iPhone X脚底</h3><p>首先需要知道一点的是，底部脚底高度是34（tabBar之下所拓张的区域）适配规则：</p><ul><li>列表页面不去适配，底部有按钮的界面要适配</li></ul><p>viewSafeAreaInsetsDidChange方法里面打印NSLog(@”%@”,NSStringFromUIEdgeInsets(self.view.safeAreaInsets));</p><blockquote><p>注意：</p><blockquote><p>1.介绍viewSafeAreaInsetsDidChange方法系统调用或者你设置控制器的additionalSafeAreaInsets安全区域边界<br>2.顺序viewSafeAreaInsetsDidChange调用顺序实在viewWillAppear之后，在viewWillLayoutSubvies之前调用</p></blockquote></blockquote><pre><code>/// 底部宏，吃一见长一智吧，别写数字了#define SafeAreaBottomHeight (kWJScreenHeight == 812.0 ? 34 : 0)</code></pre><h3 id="十四：xib和SB适配"><a href="#十四：xib和SB适配" class="headerlink" title="十四：xib和SB适配"></a>十四：xib和SB适配</h3><p>安全区域：整个屏幕–导航栏–状态栏–tabbar（自己设定的安全区域除外</p><blockquote><p>xib的适配齐刘海和圆角，如果你们项目要求适配iOS 9一下的，就该一个一个好好拖，如果你们不要求适配iOS 9一下的，只需要给view打开安全区域。</p></blockquote><h3 id="十五：App-Store评论跳转问题"><a href="#十五：App-Store评论跳转问题" class="headerlink" title="十五：App Store评论跳转问题"></a>十五：App Store评论跳转问题</h3><p>在iOS11 之后，会跳的Today里面说无法连接到App Store</p><p>先来看看我们之前的写法</p><pre><code>NSString *appstoreUrlString = [NSString stringWithFormat: @&quot;itms-apps://itunes.apple.com/WebObjects/MZStore.woa/wa/viewContentsUserReviews?type=Purple+Software&amp;id=%@&quot;,AppStoreAppId ];NSURL * url = [NSURL URLWithString:appstoreUrlString];if ([[UIApplication sharedApplication] canOpenURL:url]){    [[UIApplication sharedApplication]openURL:url];}else{    WKLog(@&quot;can not open&quot;);}</code></pre><p>到iOS 11后，那样已经没有效果了，要改成:</p><pre><code>NSString *appstoreUrlString = [NSString stringWithFormat:@&quot;itms-apps://itunes.apple.com/cn/app/idXXXXXX?mt=8&amp;action=write-review&quot;, AppStoreAppId ];NSURL * url = [NSURL URLWithString:appstoreUrlString];if ([[UIApplication sharedApplication] canOpenURL:url]){    [[UIApplication sharedApplication]openURL:url];}else{    WKLog(@&quot;can not open&quot;);}</code></pre><h3 id="十六：导航栏设置透明问题"><a href="#十六：导航栏设置透明问题" class="headerlink" title="十六：导航栏设置透明问题"></a>十六：导航栏设置透明问题</h3><p>本来导航栏设置为不透明，如今却变成了透明(磨砂)模式，要知道导航栏透明与不透明的区别除了视觉差异外还有对屏幕左上角坐标点（0,0）的基准是不一样的。</p><blockquote><p>当导航栏设置为透明模式时—&gt;基准点为手机屏幕最左上角，也就是说如果你在（0,0）点放一个有色label时，你就会发现导航栏是挡住了你的方块的，因为是半透明，你能隐约间看到有色块<br>如果你需要设置导航栏透明度，切记把</p></blockquote><pre><code>self.navigationController.navigationBar.translucent = NO;</code></pre><p>写到ViewWillAppear里！</p><h3 id="十七：twitter"><a href="#十七：twitter" class="headerlink" title="十七：twitter"></a>十七：twitter</h3><p>今天刚发现的一个坑，那就是iOS11设置里并没有集成twitter等第三方应用了</p><p>一些系统的关于这些APP的API也申明被废弃了，并推荐使用官网SDK</p><pre><code>iOS 11 no longer supports using Twitter through the built-in social framework.</code></pre><p>]Instead,you can use Twitter Kit 3 to Tweet, log in users, and use the Twitter API.</p><p>所以APP里集成twitter分享同学要注意了，一定要检查下twitter分享功能。其它APP分享如Facebook，微博分享功能等应该是完好的。</p><h3 id="十八：AppIcon"><a href="#十八：AppIcon" class="headerlink" title="十八：AppIcon"></a>十八：AppIcon</h3><p>在iOS11上发现了一个奇怪的现象，APP在启动时图标会出现黑边，</p><blockquote><p>原因是iOS11修改了App启动动画，如果你的App图标有圆角那么就会变成这个鸟样了…所有图标都换成直角就好了</p></blockquote><h3 id="十九：相册访问权限"><a href="#十九：相册访问权限" class="headerlink" title="十九：相册访问权限"></a>十九：相册访问权限</h3><p>iOS11上系统默认打开了用户相册的访问权限，但是当你保存图片时APP就会crash，</p><blockquote><p>原因是需要在info.plist再申明一个NSPhotoLibraryAddUsageDescription的key，同时为了兼容iOS11以前的机型，保留以前NSPhotoLibraryUsageDescription的key</p></blockquote><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><h5 id="1-属性总结："><a href="#1-属性总结：" class="headerlink" title="1. 属性总结："></a>1. 属性总结：</h5><ul><li>self.additionalSafeAreaInsets</li><li>self.view.safeAreaInsets</li></ul><blockquote><p>self.additionalSafeAreaInsets  改变safeAreaInsets的值</p></blockquote><ul><li>self.viewSafeAreaInsetsDidChange()</li><li>self.view.safeAreaInsetsDidChange()<pre><code>- (void)viewSafeAreaInsetsDidChange在UIViewController中第一次调用的时间是在- (void)viewWillAppear:(BOOL)animated调用之后, 在- (void)viewWillLayoutSubviews调用之前.</code></pre></li></ul><blockquote><p>当你的viewController改变了它的safeAreaInsets值时，有两种方式获取到回调</p><blockquote><p>self.viewSafeAreaInsetsDidChange()<br>self.view.safeAreaInsetsDidChange()</p></blockquote></blockquote><ul><li>self.view.safeAreaLayoutGuide</li></ul><blockquote><p>self.view.safeAreaLayoutGuide UIView的一个只读属性，作为参照物，让view可以相对某个view的safeAreaLayoutGuide做布局，从而保证view能正常、安全地显示（相对的那个view不一定要是父view）</p><blockquote><p>把safeAreaLayoutGuide看成是一个“view”，这个“view”系统自动帮我们调整它的bounds，让它不会被各种奇奇怪怪的东西挡住，包括iPhone X的刘海区域和底部的一道杠区域，可以认为在这个“view”上一定能完整显示所有内容,safeAreaInsets来调整自己的bounds的</p></blockquote></blockquote><ul><li>self.view.insetsLayoutMarginsFromSafeArea</li></ul><blockquote><p>如果你不想让safeAreaInsets影响你的视图布局，则可以将insetsLayoutMarginsFromSafeArea设置为NO，所有的视图布局将会忽略safeAreaInsets这个属性了。</p><blockquote><p>要注意的是，insetsLayoutMarginsFromSafeArea仅用于AutoLayout，即使该属性为NO，视图的safeAreaInsets还是一样有值，而且安全区域变更方法safeAreaInsetsDidChange一样被调用。</p></blockquote></blockquote><ul><li>contentInsetAdjustmentBehavior</li></ul><blockquote><p>在iOS11 中, UIViewController的automaticallyAdjustsScrollViewInsets属性已经不再使用,我们需要使用UIScrollView的 contentInsetAdjustmentBehavior 属性来替代它.</p></blockquote><blockquote><p>UIScrollViewContentInsetAdjustmentBehavior 是一个枚举类型,值有以下几种:</p><blockquote><p>automatic 和scrollableAxes一样,scrollView会自动计算和适应顶部和底部的内边距并且在scrollView 不可滚动时,也会设置内边距.<br>scrollableAxes 自动计算内边距.<br>never不计算内边距<br>always 根据safeAreaInsets 计算内边距</p></blockquote></blockquote><h5 id="2-Safe-Area-与-Layout-Margins"><a href="#2-Safe-Area-与-Layout-Margins" class="headerlink" title="2. Safe Area 与 Layout Margins"></a>2. Safe Area 与 Layout Margins</h5><p>一般在做 UI 设计，背景色或较不重要的內容可完整地延伸至屏幕边缘；主要的内容呈现区域 (例如 Table View) 会往内缩 (indent) 一层，称为「Safe Area」；而通常文字或是按钮等更加关键的物件，考虑到美观及操作性，會再内缩一层，称之为「Layout Margins</p><pre><code>竖屏时的 Safe Area 可延伸至屏幕左右两侧，上部留 44pt 給 Status Bar；Layout Margins 通常左右再内缩 16pt。横屏时的 Safe Area 左右两侧皆内缩 44pt；Layout Margins 通常左右再内缩 16pt。</code></pre><h5 id="Home-Indicator"><a href="#Home-Indicator" class="headerlink" title="Home Indicator"></a>Home Indicator</h5><p>Home Indicator 为 iPhone X 屏幕下方的一个操控區域，外观是一条粗线 (手把)，由屏幕底部往上滑动可返回主界面 (Home Screen)，或进入多任务管理界面 (App Switcher)。</p><blockquote><p>注意：该“粗线”不可自定义外观，系统会自动判断背景颜色，深色背景时显示浅色 Bar，浅色背景时则显示深色 Bar。</p></blockquote><h5 id="3-Edge-Protection"><a href="#3-Edge-Protection" class="headerlink" title="3. Edge Protection"></a>3. Edge Protection</h5><p>如果你的 UI 带有由屏幕底部往上滑动 (Swipe) 的手势，可能会与系统的手势冲突，这时可告诉开发者该 UI界面需要启用「Edge Protection」。<br>启用时，Home Indicator 将会变得较为透明，并下降位置 (但还在)，让全屏体验更为完整。当使用者第一次由下往上滑动时，此手势将保留给你的 App 使用，而不会触发 Home Indicator；当使用者在这时进行第二次滑动，才会触发。</p><blockquote><p>注意：此选项将造成使用者不便，因此当真的有需要时再考虑启用</p></blockquote><h5 id="4-Auto-Hide"><a href="#4-Auto-Hide" class="headerlink" title="4. Auto-Hide"></a>4. Auto-Hide</h5><p>UI 中若是有影片播放等需要降低干扰的情况，需要完全隐藏 Home Indicator，可启用「Auto-Hide」选项，启用时，若是使用者数秒内沒有操纵行为，Home Indicator 将自动隐藏，直到使用者触碰界面才会再度出现。</p><blockquote><p>注意：此选项将造成使用者困惑，因此當真的有需要时再考虑启用。</p></blockquote><h3 id="推荐："><a href="#推荐：" class="headerlink" title="推荐："></a>推荐：</h3><ul><li><a href="http://www.10tiao.com/html/330/201707/2653579210/1.html" target="_blank" rel="noopener">你可能需要为你的 APP 适配 iOS 11</a></li><li><a href="http://blog.csdn.net/hou_manager/article/details/78119841?locationNum=1&amp;fps=1" target="_blank" rel="noopener">iOS 11 适配集锦</a></li><li><a href="http://www.jianshu.com/p/04a9d1008276" target="_blank" rel="noopener">iOS 11新特性与适配</a></li><li>iOS 11更新的内容(开发)<ul><li><a href="http://www.jianshu.com/p/370d82ba3939" target="_blank" rel="noopener">APP适配iOS11</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2017/204/" target="_blank" rel="noopener">WWDC:Updating Your App for iOS 11 </a></li><li><a href="https://devstreaming-cdn.apple.com/videos/wwdc/2017/204kty9amomlmk222/204/204_updating_your_app_for_ios_11.pdf" target="_blank" rel="noopener">PDF版：Updating Your App For iOS 11 </a></li></ul></li><li>iPhoneX人机交互指南(开发&amp;设计师)<ul><li><a href="https://developer.apple.com/ios/human-interface-guidelines/overview/iphone-x/" target="_blank" rel="noopener">官方iPhoneX人机交互指南 </a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&amp;mid=2651113572&amp;idx=1&amp;sn=32fe690fd14836a3a4e064d156ffab7d&amp;chksm=844c61b9b33be8afc8418e3edd25c7736f2998691ce2a4c29c3c18fa87b08b5fd384b87a0085&amp;mpshare=1&amp;scene=23&amp;srcid=0913HbB372J6KVHVmKfqcVST#rd" target="_blank" rel="noopener">中文版iPhoneX人际交互指南 </a></li><li><a href="https://medium.com/uxabc/iphone-x-ui-design-specs-696fd4f262b6" target="_blank" rel="noopener">强烈推荐UI 設計師需要知道的 iPhone X 細節  </a></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> iOS——iPhone X适配实战总结 </tag>
            
            <tag> iPhone X适配实战总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQL查询优化简介</title>
      <link href="/2017/10/29/SQL%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AE%80%E4%BB%8B/"/>
      <url>/2017/10/29/SQL%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>在了解MySQL查询优化之前，先来看看关于MySQL的执行流程，因为关于数据层优化来说，归根结底还是关于IO的优化，只有知道了关于MySQL的执行流程，我们才能把优化做的更好</p><h3 id="MySQL的流程分析"><a href="#MySQL的流程分析" class="headerlink" title="MySQL的流程分析"></a>MySQL的流程分析</h3><h4 id="1-连接"><a href="#1-连接" class="headerlink" title="1.连接"></a>1.连接</h4><pre><code>1. 客户端发起一条Query请求，监听客户端的‘连接管理模块’接收请求2. 将请求转发到‘连接进/线程模块’3. 调用‘用户模块’来进行授权检查4. 通过检查后，‘连接进/线程模块’从‘线程连接池’中取出空闲的被缓存的连接线程和客户端请求对接，如果失败则创建一个新的连接请求</code></pre><a id="more"></a><h4 id="2-处理"><a href="#2-处理" class="headerlink" title="2.处理"></a>2.处理</h4><pre><code>1. 先查询缓存，检查Query语句是否完全匹配，接着再检查是否具有权限，都成功则直接取数据返回2. 上一步有失败则转交给‘命令解析器’，经过词法分析，语法分析后生成解析树3. 接下来是预处理阶段，处理解析器无法解决的语义，检查权限等，生成新的解析树4. 再转交给对应的模块处理5. 如果是SELECT查询还会经由‘查询优化器’做大量的优化，生成执行计划6. 模块收到请求后，通过‘访问控制模块’检查所连接的用户是否有访问目标表和目标字段的权限7. 有则调用‘表管理模块’，先是查看table cache中是否存在，有则直接对应的表和获取锁，否则重新打开表文件8. 根据表的meta数据，获取表的存储引擎类型等信息，通过接口调用对应的存储引擎处理9. 上述过程中产生数据变化的时候，若打开日志功能，则会记录到相应二进制日志文件中</code></pre><h4 id="3-结果"><a href="#3-结果" class="headerlink" title="3.结果"></a>3.结果</h4><pre><code>1. Query请求完成后，将结果集返回给‘连接进/线程模块’2. 返回的也可以是相应的状态标识，如成功或失败等3. ‘连接进/线程模块’进行后续的清理工作，并继续等待请求或断开与客户端的连接</code></pre><h4 id="4-小结"><a href="#4-小结" class="headerlink" title="4:小结"></a>4:小结</h4><blockquote><p>用户模块校验用户,然后去线程连接池拿线程(连接足够的话),找命令分发器,到查询缓存模块查SQL语句,如果没有,走命令解析器,然后访问控制模块,设定用户的权限,设定好后走表管理模块,获取锁和缓存,然后获取各种信息,存储的方式:存储引擎,从存储引擎获取数据,然后返回</p></blockquote><!--more--><h3 id="一、优化的入手点"><a href="#一、优化的入手点" class="headerlink" title="一、优化的入手点"></a>一、优化的入手点</h3><ul><li><p>查找分析查询慢的原因</p><ul><li>1.记录慢查询日志（慢查询日志的使用以及分析见本章slow_query.md)  </li><li>2.show profile:  <ul><li>set profiling = 1;开启，服务器上执行的所有语句会检测消耗的时间，存到临时表  </li><li>show profiles 查看语句执行消耗的时间  </li><li>show profile for query 临时表ID  查看某个查询的详细消耗  </li></ul></li><li>3.分析单条语句使用explain（explain.md查看explain用法）</li></ul></li><li><p>优化查询中的数据访问</p><ul><li>1.访问数据太多导致查询性能下降，尽量不要使用select *  </li><li>2.确定应用程序逻辑需要的数据量，使用limit返回一部分即可  </li><li>3.确定MySQL是否检索了索引，避免全表扫描  </li><li>4.重复查询相同的数据，可以缓存数据，下次直接读缓存  </li><li>5.是否存在扫描额外的记录（使用explain分析发现需要扫描大量的数据，却只返回少数行）：  </li></ul></li></ul><p>使用索引覆盖扫描，把所用到的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果  </p><ul><li>优化长难语句</li></ul><p>一个复杂的查询和多个简单的查询相比较，mysql每秒可以查询上百万的数据，响应给客户端的速度就要慢得多，所以使用尽可能少的查询是好的，但是有时候把一个大查询分解为多个小的查询也是必要的。因为长时间的sql会产生临时表、锁表、占用数据连接等情况，影响其他的查询。  </p><ul><li>解决方案：  <ul><li>1.切分查询，将一条大的查询切分成多个小的查询，分批次执行  </li><li>2.分解关联查询， 将一个关联语句分解成多个sql来执行，减少锁的竞争，并且在应用层进行关联，以后更容易拆分数据库  </li></ul></li></ul><ul><li>优化特定类型的查询语句<ul><li>1.优化关联查询，确定on的子句有没有索引，避免全表扫描  </li><li>2.确保group by和order by中只有一个表中的列，这样才会使用到索引  </li><li>3.优化子查询，尽量使用关联查询来替代子查询(因为mysql对关联查询会有一些优化器，但是高性能mysql上说了，在mysql5.6以上版本或者MariaDB中，子查询和关联查询的效率是差不多的)  </li><li>4.优化limit分页，当limit偏移量大的时候，查询效率就会很低。此时我们可以记录上次查询的最大id，下次查询时直接根据该id来查询  </li></ul></li></ul><blockquote><p>比如每页需要显示10条数据，到limit 10000,10的时候，其实是查出了10010条结果集，返回了10条。如果我们记住上一次查询的最大id，10000.我们可以使用 where id &gt; 10000 limit 10，这样还是只在10条数据中返回，极大的提升了运行效率</p></blockquote>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>负载均衡和请求转发笔记总结</title>
      <link href="/2017/10/18/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/"/>
      <url>/2017/10/18/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="负载均衡，请求转发"><a href="#负载均衡，请求转发" class="headerlink" title="负载均衡，请求转发"></a>负载均衡，请求转发</h1><h3 id="七层负载均衡的实现"><a href="#七层负载均衡的实现" class="headerlink" title="七层负载均衡的实现"></a>七层负载均衡的实现</h3><blockquote><p>基于URL等应用层信息的负载均衡  </p></blockquote><p>用Nginx的proxy实现七层负载均衡，具有如下特点：</p><ul><li>功能强大，运行稳定  </li><li>配置简单灵活  </li><li>能够自动剔除工作不正常的后端服务器  </li><li>上传文件使用异步模式 </li><li>支持多种分配策略(内置策略，扩展策略)，可以分配权重  </li><li>内置策略：IP Hash 、 加权轮询  </li><li>扩展策略： fair策略、通用hash、一致性hash</li></ul><a id="more"></a><h6 id="加权轮询策略："><a href="#加权轮询策略：" class="headerlink" title="加权轮询策略："></a>加权轮询策略：</h6><blockquote><p>首先将请求都分给权重高的机器，知道机器权重降低到了比其他机器低，在将请求分配给下一个权重高的机器。当所有机器都down掉时，Nginx会将所有机器标志位清成初始状态，以避免所有机器都处在timeout状态</p></blockquote><h6 id="IP-Hash策略："><a href="#IP-Hash策略：" class="headerlink" title="IP Hash策略："></a>IP Hash策略：</h6><blockquote><p>与轮询很类似，只是算法做了一些修改，相当于变向的轮询策略</p></blockquote><h6 id="fair策略："><a href="#fair策略：" class="headerlink" title="fair策略："></a>fair策略：</h6><blockquote><p>根据后端的响应时间来判断负载的情况，从中选出负载最轻的机器，进行分流</p></blockquote><h6 id="通用hash、一致性hash策略："><a href="#通用hash、一致性hash策略：" class="headerlink" title="通用hash、一致性hash策略："></a>通用hash、一致性hash策略：</h6><blockquote><p>通用hash使用Nginx内置的变量key进行hash，一致性hash采用了Nginx内置的一致性hash环，支持memcache</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Nginx配置：</span><br><span class="line">http &#123;</span><br><span class="line">    upstream cluster &#123;</span><br><span class="line">        # ip hash; 指定策略为ip hash</span><br><span class="line">        server svr1; # 配置权重 weight = 10；</span><br><span class="line">        server svr2;</span><br><span class="line">        server svr3;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://cluster;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四层负载均衡的实现"><a href="#四层负载均衡的实现" class="headerlink" title="四层负载均衡的实现"></a>四层负载均衡的实现</h3><blockquote><p>四层负载均衡是通过报文中目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。  </p></blockquote><h5 id="软件-LVS-实现，LVS有三种方式：NAT、DR、TUN"><a href="#软件-LVS-实现，LVS有三种方式：NAT、DR、TUN" class="headerlink" title="软件(LVS)实现，LVS有三种方式：NAT、DR、TUN"></a>软件(LVS)实现，LVS有三种方式：NAT、DR、TUN</h5>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常用负载均衡调度算法实现</title>
      <link href="/2017/10/07/%E5%B8%B8%E7%94%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2017/10/07/%E5%B8%B8%E7%94%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>用 PHP 实现几种负载均衡调度算法，详细见 </p><blockquote><p>在分布式系统中，为了实现负载均衡，必然会涉及到负载调度算法，如 Nginx 和 RPC 服务发现等场景。常见的负载均衡算法有 轮询、源地址 Hash、最少连接数，而 轮询 是最简单且应用最广的算法。</p></blockquote><a id="more"></a><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/2019/phps/ngxin-loading.jpg"></p><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>3种常见的轮询调度算法，分别为 简单轮询、加权轮询、平滑加权轮询</p><h5 id="普通轮询（general-Round-Robin"><a href="#普通轮询（general-Round-Robin" class="headerlink" title="普通轮询（general Round Robin)"></a>普通轮询（general Round Robin)</h5><pre><code>namespace Robin;class Robin implements RobinInterface{    private $services = array();    private $total;    private $currentPos = -1;    public function init(array $services)    {        $this-&gt;services = $services;        $this-&gt;total = count($services);    }    public function next()    {        // 已调度完一圈,重置currentPos值为第一个实例位置        $this-&gt;currentPos = ($this-&gt;currentPos + 1) % $this-&gt;total;        return $this-&gt;services[$this-&gt;currentPos];    }}</code></pre><h5 id="加权轮询（Weighted-Round-Robin"><a href="#加权轮询（Weighted-Round-Robin" class="headerlink" title="加权轮询（Weighted Round Robin)"></a>加权轮询（Weighted Round Robin)</h5><pre><code>namespace Robin;class WeightedRobin implements RobinInterface{    private $services = array();    private $total;    private $currentPos = -1;    private $currentWeight;    public function init(array $services)    {        foreach ($services as $ip =&gt; $weight) {            $this-&gt;services[] = [                &apos;ip&apos; =&gt; $ip,                &apos;weight&apos; =&gt; $weight,            ];        }        $this-&gt;total = count($this-&gt;services);    }    public function next()    {        $i = $this-&gt;currentPos;        while (true) {            $i = ($i + 1) % $this-&gt;total;            // 已全部被遍历完一次            if (0 === $i) {                // 减currentWeight                $this-&gt;currentWeight -= $this-&gt;getGcd();                // 赋值currentWeight为0,回归到初始状态                if ($this-&gt;currentWeight &lt;= 0) {                    $this-&gt;currentWeight = $this-&gt;getMaxWeight();                }            }            // 直到当前遍历实例的weight大于或等于currentWeight            if ($this-&gt;services[$i][&apos;weight&apos;] &gt;= $this-&gt;currentWeight) {                $this-&gt;currentPos = $i;                return $this-&gt;services[$this-&gt;currentPos][&apos;ip&apos;];            }        }    }    /**     * 求两数的最大公约数(基于欧几里德算法,可使用gmp_gcd())     *     * @param integer $a     * @param integer $b     *     * @return integer     */    private function gcd($a, $b)    {        $rem = 0;        while ($b) {            $rem = $a % $b;            $a = $b;            $b = $rem;        }        return $a;    }    /**     * 获取最大公约数     *     * @return integer     */    private function getGcd()    {        $gcd = $this-&gt;services[0][&apos;weight&apos;];        for ($i = 0; $i &lt; $this-&gt;total; $i++) {            $gcd = $this-&gt;gcd($gcd, $this-&gt;services[$i][&apos;weight&apos;]);        }        return $gcd;    }    /**     * 获取最大权重值     *     * @return integer     */    private function getMaxWeight()    {        $maxWeight = 0;        foreach ($this-&gt;services as $node) {            if ($node[&apos;weight&apos;] &gt;= $maxWeight) {                $maxWeight = $node[&apos;weight&apos;];            }        }        return $maxWeight;    }}</code></pre><h5 id="平滑加权轮询（Smooth-Weighted-Round-Robin"><a href="#平滑加权轮询（Smooth-Weighted-Round-Robin" class="headerlink" title="平滑加权轮询（Smooth Weighted Round Robin)"></a>平滑加权轮询（Smooth Weighted Round Robin)</h5><pre><code>namespace Robin;class SmoothWeightedRobin implements RobinInterface{    /**     * 服务群组     * @var array     */    private $services = array();    /**     * 同时累加所有peer的effective_weight，保存为total     * @var     */    private $total;    /**     * 后端目前的权重     * @var int     */    private $currentPos = -1;    /**     * 初始化     * @param array $services     */    public function init(array $services)    {        foreach ($services as $ip =&gt; $weight) {            $this-&gt;services[] = [                &apos;ip&apos; =&gt; $ip,                &apos;weight&apos; =&gt; $weight,                &apos;current_weight&apos; =&gt; $weight,            ];        }        $this-&gt;total = count($this-&gt;services);    }    public function next()    {        // 获取最大当前有效权重的实例位置        $this-&gt;currentPos = $this-&gt;getMaxCurrentWeightPos();        // 当前权重减去权重和        $currentWeight = intval($this-&gt;getCurrentWeight($this-&gt;currentPos)) - intval($this-&gt;getSumWeight());        $this-&gt;setCurrentWeight($this-&gt;currentPos, $currentWeight);        // 每个实例的当前有效权重加上配置权重        $this-&gt;recoverCurrentWeight();        return $this-&gt;services[$this-&gt;currentPos][&apos;ip&apos;];    }    /**     * 获取最大当前有效权重实例位置     * @return int     */    public function getMaxCurrentWeightPos()    {        $currentWeight = $pos = 0;        foreach ($this-&gt;services as $index =&gt; $service) {            if ($service[&apos;current_weight&apos;] &gt; $currentWeight) {                $currentWeight = $service[&apos;current_weight&apos;];                $pos = $index;            }        }        return $pos;    }    /**     * 配置权重和，累加所有后端的effective_weight     *     * @return integer     */    public function getSumWeight()    {        $sum = 0;        foreach ($this-&gt;services as $service) {            $sum += intval($service[&apos;weight&apos;]);        }        return $sum;    }    /**     * 设置当前有效权重     * @param integer $pos     * @param integer $weight     */    public function setCurrentWeight($pos, $weight)    {        $this-&gt;services[$pos][&apos;current_weight&apos;] = $weight;    }    /**     * 获取当前有效权重     *     * @param integer $pos     * @return integer     */    public function getCurrentWeight($pos)    {        return $this-&gt;services[$pos][&apos;current_weight&apos;];    }    /**     * 用配置权重调整当前有效权重     */    public function recoverCurrentWeight()    {        foreach ($this-&gt;services as $index =&gt; &amp;$service) {            $service[&apos;current_weight&apos;] += intval($service[&apos;weight&apos;]);        }    }}</code></pre><h5 id="调度算法接口服务"><a href="#调度算法接口服务" class="headerlink" title="调度算法接口服务"></a>调度算法接口服务</h5><pre><code>namespace Robin;interface RobinInterface{    /**     * 初始化服务权重     *     * @param array $services     */    public function init(array $services);    /**     * 获取一个服务     *     * @return string     */    public function next();}</code></pre><blockquote><p>加权轮询 算法虽然通过配置实例权重，解决了 简单轮询 的资源利用问题，但是它还是存在一个比较明显的 缺陷。<br>为了解决加权轮询调度不均匀的缺陷，一些人提出了 平滑加权轮询 调度算法，它会生成的更均匀的调度序列 {a, a, b, a, c, a, a}。对于神秘的平滑加权轮询算法，我将在后续文章中详细介绍它的原理和实现。</p></blockquote><h3 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h3><figure class="highlight plain"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require tinywan/load-balancing</span><br></pre></td></tr></table></figure><h3 id="Basic-Usage"><a href="#Basic-Usage" class="headerlink" title="Basic Usage"></a>Basic Usage</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器数</span></span><br><span class="line">$services = [</span><br><span class="line">    <span class="string">'192.168.10.1'</span> =&gt; <span class="number">6</span>,</span><br><span class="line">    <span class="string">'192.168.10.2'</span> =&gt; <span class="number">2</span>,</span><br><span class="line">    <span class="string">'192.168.10.3'</span> =&gt; <span class="number">1</span>,</span><br><span class="line">    <span class="string">'192.168.10.4'</span> =&gt; <span class="number">1</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"> ------------- <span class="number">1.</span>简单轮询 ------------- </span><br><span class="line"></span><br><span class="line">$robin = <span class="keyword">new</span> \Robin\Robin();</span><br><span class="line">$robin-&gt;init($services);</span><br><span class="line">$nodes = [];</span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= count($services); $i++) &#123;</span><br><span class="line">    $node = $robin-&gt;next();</span><br><span class="line">    $nodes[$i] = $node;</span><br><span class="line">&#125;</span><br><span class="line">var_export($nodes);</span><br><span class="line"></span><br><span class="line"> ------------- <span class="number">2.</span>加权轮询 ------------- </span><br><span class="line"></span><br><span class="line">$robin = <span class="keyword">new</span> \Robin\WeightedRobin();</span><br><span class="line">$robin-&gt;init($services);</span><br><span class="line"></span><br><span class="line">$nodes = [];</span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= <span class="number">10</span>; $i++) &#123;</span><br><span class="line">    $node = $robin-&gt;next();</span><br><span class="line">    $nodes[$i] = $node;</span><br><span class="line">&#125;</span><br><span class="line">var_export($nodes);</span><br><span class="line"></span><br><span class="line"> ------------- <span class="number">3.</span>平滑加权轮询 ------------- </span><br><span class="line"></span><br><span class="line">$robin = <span class="keyword">new</span> \Robin\SmoothWeightedRobin();</span><br><span class="line">$robin-&gt;init($services);</span><br><span class="line"></span><br><span class="line">$nodes = [];</span><br><span class="line">$sumWeight = $robin-&gt;getSumWeight();</span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= $sumWeight; $i++) &#123;</span><br><span class="line">    $node = $robin-&gt;next();</span><br><span class="line">    $nodes[$i] = $node;</span><br><span class="line">&#125;</span><br><span class="line">var_export($nodes);</span><br></pre></td></tr></table></figure><h3 id="Composer管理"><a href="#Composer管理" class="headerlink" title="Composer管理"></a>Composer管理</h3><p>安装提示错误：</p><p><code>Could not find package tinywan/load-polling in a version matching 1.0</code></p><p>尝试改成Packagist的地址 <a href="https://packagist.org" target="_blank" rel="noopener">https://packagist.org</a></p><figure class="highlight plain"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;repositories&quot;: &#123;</span><br><span class="line">    &quot;packagist&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;composer&quot;,</span><br><span class="line">        &quot;url&quot;: &quot;https://packagist.org&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>要使你发布的最新包可以使用，请使用以上的镜像源，为了学习</p></blockquote><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://github.com/fan-haobai/load-balance" target="_blank" rel="noopener">负载均衡算法</a>  </li><li><a href="https://www.fanhaobai.com/2018/11/load-balance-round-robin.html" target="_blank" rel="noopener">负载均衡算法 — 轮询</a>  </li><li><a href="https://www.fanhaobai.com/2018/11/load-balance-smooth-weighted-round-robin.html" target="_blank" rel="noopener">负载均衡算法 — 平滑加权轮询</a>  </li><li><a href="https://blog.csdn.net/zhangskd/article/details/50194069" target="_blank" rel="noopener">Nginx的负载均衡 - 加权轮询 (Weighted Round Robin) 上篇</a>  </li><li><a href="https://blog.csdn.net/zhangskd/article/details/50197929" target="_blank" rel="noopener">Nginx的负载均衡 - 加权轮询 (Weighted Round Robin) 下篇</a>  </li><li><a href="https://www.chenjie.info/1880" target="_blank" rel="noopener">Composer/Packagist包</a>  </li></ul>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单点登录实现方案与流程</title>
      <link href="/2017/08/25/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E4%B8%8E%E6%B5%81%E7%A8%8B/"/>
      <url>/2017/08/25/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E4%B8%8E%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h1 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h1><p>再次之前要记录一下另一种形式，单个账号同时只能有一个用户登录，之前在乐望做开发的时候，每个账号的后台登录都只能一个人：  </p><ol><li>首先是把session存到redis而非服务器文件，登录后把session_id存到mysql某个字段</li><li>验证用户名密码登录后，取出mysql的session_id字段，然后删除redis下该session_id的key-value。这样就做到上一个登录的人，无法找到对应的session，也就是退出。然后把新的session_id更新到mysql相应的字段</li></ol><a id="more"></a><h5 id="单点登录（single-sign-on-简称SSO）"><a href="#单点登录（single-sign-on-简称SSO）" class="headerlink" title="单点登录（single sign on   简称SSO）"></a>单点登录（single sign on   简称SSO）</h5><blockquote><p>单点登录是指在多系统应用群中的一个登录系统，只要在系统应用群中登录一个，便可以在其他系统中得到授权而无需登录</p></blockquote><p>相比于单系统登录，单点登录需要一个独立的认证中心，只有认证中心能接受用户的用户名、密码等信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，sso认证中心验证用户名密码没问题，创建授权令牌，然后把令牌作为参数发给各个子系统，子系统拿到了令牌即得到了授权，可以借此创建局部会话，局部会话就与单系统登录相同。这个过程，也就是单点登录的原理。</p><p>一、登录  </p><p><img src="https://raw.githubusercontent.com/haobinaa/php-learn/master/img/sso.png" alt=""></p><p>上图中的流程：  </p><ol><li>用户访问系统1的受保护资源，系统1发现用户未登录，跳转到sso认证中心，并带上自己的地址作为参数</li><li>sso认证发现用户未登录，将用户引导至登录页面</li><li>用户输入用户名、密码提交申请登录</li><li>sso认证中心校验用户信息，创建用户与sso之间的会话，并创建令牌</li><li>sso认证中心带着令牌跳转到最初的请求地址（系统1）</li><li>系统1拿到令牌，去sso认证中心校验令牌是否有效</li><li>sso认证中心校验令牌，返回有效，注册系统1</li><li>系统1使用令牌创建与用户的会话，称为局部会话，返回用户请求的受保护资源</li><li>用户访问系统2的受保护资源，系统2发现用户未登录（第一种猜想通过ip来识别这个用户是否登录，假如发现已经存了这个ip代表已经登录，并返回这个ip对应的令牌；第二种猜想，第一次登录时，sso返回系统1并在客户端存一个cookie，比如tokenid，客户端第二次请求的时候，就会带上这个tokenid，sso就可以识别到底是哪个用户了），跳转至sso认证中心，并附带自己的地址，</li><li>sso认证中心发现用户已经登录，返回系统2，并带上令牌。</li><li>系统2拿到令牌，去sso验证令牌是否有效</li><li>sso认证令牌，返回有效，并注册系统2</li><li>系统2使用该令牌创建与用户的局部会话，返回用户请求的受保护资源</li></ol><p>二、注销  </p><p><img src="https://raw.githubusercontent.com/haobinaa/php-learn/master/img/logout.png" alt=""></p><ol><li>用户向系统1发起注销请求</li><li>系统1根据用户与系统1建立的会话拿到令牌，向sso认证中心发起注销请求</li><li>sso认证令牌有效，销毁全局会话，同时取出所有此令牌注册的系统 </li><li>sso向所有注册系统发起注销请求</li><li>各注册系统受到sso的注销请求，销毁局部会话</li></ol>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 单点登录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入理解PHP——内存管理垃圾回收</title>
      <link href="/2017/07/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2017/07/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      <content type="html"><![CDATA[<h3 id="一、内存管理机制"><a href="#一、内存管理机制" class="headerlink" title="一、内存管理机制"></a>一、内存管理机制</h3><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>1） 操作系统直接管理着内存，所以操作系统也需要进行内存管理，计算机中通常都有内存管理单元(MMU) 用于处理CPU对内存的访问。</li><li>2） 应用程序无法直接调用物理内存， 只能向系统申请内存。<ul><li>向操作系统申请内存空间会引发系统调用。</li><li>系统调用会将CPU从用户态切换到内核。</li><li>为了减少系统调用开销。通常在用户态进行内存管理。 申请大块内存备用。使用完的内存不马上释放，将内存复用，避免多次内存申请和释放所带来性能消耗。</li></ul></li><li>3） PHP不需要显示内存管理，由Zend引擎进行管理。</li></ul><a id="more"></a><h3 id="PHP内存限制"><a href="#PHP内存限制" class="headerlink" title="PHP内存限制"></a>PHP内存限制</h3><ul><li>1）php.ini中的默认32MB<ul><li>memory_limit = 32M</li></ul></li><li>2）动态修改内存<ul><li>ini_set (“memory_limit”, “128M”)</li></ul></li><li>3）获取目前内存占用<ul><li>memory_get_usage()    : 获取PHP脚本所用的内存大小</li><li>memory_get_peak_usage() ：返回当前脚本到目前位置所占用的内存峰值。</li></ul></li></ul><p>先看一段代码：</p><pre><code>&lt;?php//内存管理机制var_dump(memory_get_usage());//获取内存方法，加上true返回实际内存，不加则返回表现内存$a = &quot;laruence&quot;;var_dump(memory_get_usage());unset($a);var_dump(memory_get_usage());//输出(在我的个人电脑上, 可能会因为系统,PHP版本,载入的扩展不同而不同)://int 240552//int 240720//int 240552</code></pre><p>定义变量之后，内存增加，清除变量之后，内存恢复（有些可能不会恢复和以前一样），好像定义变量时申请了一次内存，其实不是这样的，php会预先申请一块内存，不会每次定义变量就申请内存。</p><blockquote><p>首先我们要打破一个思维: PHP不像C语言那样, 只有你显示的调用内存分配相关API才会有内存的分配. 也就是说, 在PHP中, 有很多我们看不到的内存分配过程.</p></blockquote><p>比如对于:</p><pre><code>$a = &quot;laruence&quot;;</code></pre><h5 id="隐式的内存分配点就有"><a href="#隐式的内存分配点就有" class="headerlink" title="隐式的内存分配点就有:"></a>隐式的内存分配点就有:</h5><ul><li>1.1. 为变量名分配内存, 存入符号表</li><li>2.2. 为变量值分配内存</li></ul><p>所以, PHP的unset确实会释放内存, 但这个释放不是C编程意义上的释放, 不是交回给OS.<br>对于PHP来说, 它自身提供了一套和C语言对内存分配相似的内存管理API:　</p><pre><code>emalloc(size_t size);efree(void *ptr);ecalloc(size_t nmemb, size_t size);erealloc(void *ptr, size_t size);estrdup(const char *s);estrndup(const char *s, unsigned int length);</code></pre><blockquote><p>这些API和C的API意义对应, 在PHP内部都是通过这些API来管理内存的.</p></blockquote><p>当我们调用emalloc申请内存的时候, PHP并不是简单的向OS要内存, 而是会像OS要一个大块的内存, 然后把其中的一块分配给申请者, 这样当再有逻辑来申请内存的时候, 就不再需要向OS申请内存了, 避免了频繁的系统调用.</p><p>比如如下的例子:</p><pre><code>var_dump(memory_get_usage(true));//注意获取的是real_size$a = &quot;laruence&quot;;var_dump(memory_get_usage(true));unset($a);var_dump(memory_get_usage(true));//输出//int 262144//int 262144//int 262144</code></pre><p>也就是我们在定义变量$a的时候, PHP并没有向系统申请新内存.同样的, 在我们调用efree释放内存的时候, PHP也不会把内存还给OS, 而会把这块内存, 归入自己维护的空闲内存列表. </p><p>对于小块内存来说, 更可能的是, 把它放到内存缓存列表中去(后记, 某些版本的PHP, 比如我验证过的PHP5.2.4, 5.2.6, 5.2.8, 在调用get_memory_usage()的时候, 不会减去内存缓存列表中的可用内存块大小, 导致看起来, unset以后内存不变).</p><p>$a = “hello”;</p><h5 id="定义变量时，存储两个方面："><a href="#定义变量时，存储两个方面：" class="headerlink" title="定义变量时，存储两个方面："></a>定义变量时，存储两个方面：</h5><ol><li>变量名，存储在符号表</li><li>变量值存储在内存空间</li><li>在删除变量的时候，会将变量值存储的空间释放，而变量名所在的符号表不会减小（只增不减）</li></ol><h4 id="只增不减的数组"><a href="#只增不减的数组" class="headerlink" title="只增不减的数组"></a>只增不减的数组</h4><p>Hashtable是PHP的核心结构, 数组也是用她来表示的, 而符号表也是一种关联数组, 对于如下代码:</p><pre><code>var_dump(memory_get_usage());for($i=0;$i&lt;100;$i++){$a = &quot;test&quot;.$i;$$a = &quot;hello&quot;;    }var_dump(memory_get_usage());for($i=0;$i&lt;100;$i++){$a = &quot;test&quot;.$i;unset($$a);    }var_dump(memory_get_usage());</code></pre><p>我们定义了100个变量, 然后又按个Unset了他们, 来看看输出:</p><pre><code>//int 242104//int 259768//int 242920</code></pre><p>Wow, 怎么少了这么多内存?<br>这是因为对于Hashtable来说, 定义它的时候, 不可能一次性分配足够多的内存块, 来保存未知个数的元素, 所以PHP会在初始化的时候, 只是分配一小部分内存块给HashTable, 当不够用的时候再RESIZE扩容。</p><p>Hashtable, 只能扩容, 不会减少, 对于上面的例子, 当我们存入100个变量的时候, 符号表不够用了, 做了一次扩容, 而当我们依次unset掉这100个变量以后, 变量占用的内存是释放了(118848 – 104448), 但是符号表并没有缩小, 所以这些少的内存是被符号表本身占去了…</p><h3 id="二、垃圾回收机制"><a href="#二、垃圾回收机制" class="headerlink" title="二、垃圾回收机制"></a>二、垃圾回收机制</h3><p>PHP变量存储在一个zval容器里面的</p><ul><li><ol><li>变量类型 </li></ol></li><li><ol start="2"><li>变量值 </li></ol></li><li><ol start="3"><li>is_ref 代表是否有地址引用 </li></ol></li><li><ol start="4"><li>refcount 指向该值的变量数量</li></ol></li></ul><p>变量赋值的时候：is_ref为false， refcount为1</p><pre><code>$a = 1;xdebug_debug_zval(&apos;a&apos;);echo PHP_EOL;//换行符，提高代码的源代码级可移植性</code></pre><p>输出：</p><pre><code>a:(refcount=1, is_ref=0),int1</code></pre><p>将变量a的值赋给变量b，变量b不会立刻去在内存中存储值，而是先指向变量a的值，一直到变量a有任何操作的时候</p><pre><code>$b = $a;xdebug_debug_zval(&apos;a&apos;);echo PHP_EOL;</code></pre><p>输出：</p><pre><code>a:(refcount=2, is_ref=0),int1</code></pre><h6 id="再来看一个"><a href="#再来看一个" class="headerlink" title="再来看一个"></a>再来看一个</h6><pre><code>$c = &amp;$a;xdebug_debug_zval(&apos;a&apos;);echo PHP_EOL;xdebug_debug_zval(&apos;b&apos;);echo PHP_EOL;</code></pre><p>输出：</p><pre><code>a:(refcount=2, is_ref=1),int1b:(refcount=1, is_ref=0),int1</code></pre><p>因为程序又操作了变量a，所以变量b会自己申请一块内存将值放进去。<br>所以变量a的zval容器中refcount会减1变为1，变量c指向a，所以refcount会加1变为2，is_ref变为true</p><h5 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h5><ol><li>在5.2版本或之前版本，PHP会根据refcount值来判断是不是垃圾</li></ol><ul><li>如果refcount值为0，PHP会当做垃圾释放掉</li><li>这种回收机制有缺陷，对于环状引用的变量无法回收</li></ul><h6 id="环状引用："><a href="#环状引用：" class="headerlink" title="环状引用："></a>环状引用：</h6><pre><code>$attr = array(&quot;hello&quot;);$attr[]= &amp;$attr;xdebug_debug_zval(&apos;attr&apos;);echo PHP_EOL;</code></pre><p>输出：</p><pre><code>attr:(refcount=2, is_ref=1),array (size=2)0 =&gt; (refcount=1, is_ref=0),string&apos;hello&apos; (length=5)1 =&gt; (refcount=2, is_ref=1),&amp;array</code></pre><p>2.在5.3之后版本改进了垃圾回收机制</p><ul><li>如果发现一个zval容器中的refcount在增加，说明不是垃圾</li><li>如果发现一个zval容器中的refcount在减少，如果减到了0，直接当做垃圾回收</li><li>如果发现一个zval容器中的refcount在减少，并没有减到0，PHP会把该值放到缓冲区，当做有可能是垃圾的怀疑对象</li><li>当缓冲区达到临界值，PHP会自动调用一个方法取遍历每一个值，如果发现是垃圾就清理</li></ul>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 内存管理 </tag>
            
            <tag> 垃圾回收 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kotlin——和Swift像得一塌糊涂</title>
      <link href="/2017/05/18/kotlin%E2%80%94%E2%80%94%E5%92%8CSwift%E5%83%8F%E5%BE%97%E4%B8%80%E5%A1%8C%E7%B3%8A%E6%B6%82/"/>
      <url>/2017/05/18/kotlin%E2%80%94%E2%80%94%E5%92%8CSwift%E5%83%8F%E5%BE%97%E4%B8%80%E5%A1%8C%E7%B3%8A%E6%B6%82/</url>
      <content type="html"><![CDATA[<p>今天大概看了一下网上关于Google I/O的详细内容，当然主要还是关于kotlin，随便找打之前的的小demo，突然又想到上周深圳的Swift大会，顿时感觉以后Swift和kotlin与占有很大一部分市场，就寻找了一份关于kotlin和Swift代码的异同之处，也好方便kotlin和Swift程序员区分与学习…..</p><p>| <img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/kotlin/kotlin-Swift001.jpg" alt="曹理鹏(iCocos)-梦工厂"> | <img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/kotlin/kotlin-Swift002.jpg" alt="曹理鹏(iCocos)-梦工厂"> |</p><a id="more"></a><p>下面是一些关于Swift和Kotlin语法和细节上的区别，出自网络！</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h3><pre><code>print(&quot;Hello, world!&quot;)</code></pre><h3 id="kotlin"><a href="#kotlin" class="headerlink" title="kotlin"></a>kotlin</h3><pre><code>println(&quot;Hello, world!&quot;)</code></pre><h2 id="Variables-And-Constants"><a href="#Variables-And-Constants" class="headerlink" title="Variables And Constants"></a>Variables And Constants</h2><h3 id="Swift-1"><a href="#Swift-1" class="headerlink" title="Swift"></a>Swift</h3><pre><code>var myVariable = 42myVariable = 50let myConstant = 42</code></pre><h3 id="kotlin-1"><a href="#kotlin-1" class="headerlink" title="kotlin"></a>kotlin</h3><pre><code>var myVariable = 42myVariable = 50val myConstant = 42</code></pre><h2 id="Explicit-Types"><a href="#Explicit-Types" class="headerlink" title="Explicit Types"></a>Explicit Types</h2><h3 id="Swift-2"><a href="#Swift-2" class="headerlink" title="Swift"></a>Swift</h3><pre><code>let explicitDouble: Double = 70</code></pre><h3 id="kotlin-2"><a href="#kotlin-2" class="headerlink" title="kotlin"></a>kotlin</h3><pre><code>val explicitDouble: Double = 70.0</code></pre><h2 id="Type-Coercion"><a href="#Type-Coercion" class="headerlink" title="Type Coercion"></a>Type Coercion</h2><h3 id="Swift-3"><a href="#Swift-3" class="headerlink" title="Swift"></a>Swift</h3><pre><code>let label = &quot;The width is &quot;let width = 94let widthLabel = label + String(width)</code></pre><h3 id="kotlin-3"><a href="#kotlin-3" class="headerlink" title="kotlin"></a>kotlin</h3><pre><code>val label = &quot;The width is &quot;val width = 94val widthLabel = label + width</code></pre><h2 id="String-Interpolation"><a href="#String-Interpolation" class="headerlink" title="String Interpolation"></a>String Interpolation</h2><h3 id="Swift-4"><a href="#Swift-4" class="headerlink" title="Swift"></a>Swift</h3><pre><code>let apples = 3let oranges = 5let fruitSummary = &quot;I have \(apples + oranges) &quot; +&quot;pieces of fruit.&quot;</code></pre><h3 id="kotlin-4"><a href="#kotlin-4" class="headerlink" title="kotlin"></a>kotlin</h3><pre><code>val apples = 3val oranges = 5val fruitSummary = &quot;I have ${apples + oranges} &quot; +&quot;pieces of fruit.&quot;</code></pre><h2 id="Range-Operator"><a href="#Range-Operator" class="headerlink" title="Range Operator"></a>Range Operator</h2><h3 id="Swift-5"><a href="#Swift-5" class="headerlink" title="Swift"></a>Swift</h3><pre><code>let names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;]let count = names.countfor i in 0..&lt;count {print(&quot;Person \(i + 1) is called \(names[i])&quot;)}// Person 1 is called Anna// Person 2 is called Alex// Person 3 is called Brian// Person 4 is called Jack</code></pre><h3 id="kotlin-5"><a href="#kotlin-5" class="headerlink" title="kotlin"></a>kotlin</h3><pre><code>val names = arrayOf(&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;)val count = names.count()for (i in 0..count - 1) {println(&quot;Person ${i + 1} is called ${names[i]}&quot;)}// Person 1 is called Anna// Person 2 is called Alex// Person 3 is called Brian// Person 4 is called Jack</code></pre><h2 id="Inclusive-Range-Operator"><a href="#Inclusive-Range-Operator" class="headerlink" title="Inclusive Range Operator"></a>Inclusive Range Operator</h2><h3 id="Swift-6"><a href="#Swift-6" class="headerlink" title="Swift"></a>Swift</h3><pre><code>for index in 1...5 {print(&quot;\(index) times 5 is \(index * 5)&quot;)}// 1 times 5 is 5// 2 times 5 is 10// 3 times 5 is 15// 4 times 5 is 20// 5 times 5 is 25</code></pre><h3 id="kotlin-6"><a href="#kotlin-6" class="headerlink" title="kotlin"></a>kotlin</h3><pre><code>for (index in 1..5) {println(&quot;$index times 5 is ${index * 5}&quot;)}// 1 times 5 is 5// 2 times 5 is 10// 3 times 5 is 15// 4 times 5 is 20// 5 times 5 is 25</code></pre><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><h3 id="Swift-7"><a href="#Swift-7" class="headerlink" title="Swift"></a>Swift</h3><pre><code>var shoppingList = [&quot;catfish&quot;, &quot;water&quot;,&quot;tulips&quot;, &quot;blue paint&quot;]shoppingList[1] = &quot;bottle of water&quot;### kotlin val shoppingList = arrayOf(&quot;catfish&quot;, &quot;water&quot;,&quot;tulips&quot;, &quot;blue paint&quot;)shoppingList[1] = &quot;bottle of water&quot;</code></pre><h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><h3 id="Swift-8"><a href="#Swift-8" class="headerlink" title="Swift"></a>Swift</h3><pre><code>var occupations = [&quot;Malcolm&quot;: &quot;Captain&quot;,&quot;Kaylee&quot;: &quot;Mechanic&quot;,]occupations[&quot;Jayne&quot;] = &quot;Public Relations&quot;</code></pre><h3 id="kotlin-7"><a href="#kotlin-7" class="headerlink" title="kotlin"></a>kotlin</h3><pre><code>val occupations = mutableMapOf(&quot;Malcolm&quot; to &quot;Captain&quot;,&quot;Kaylee&quot; to &quot;Mechanic&quot;)occupations[&quot;Jayne&quot;] = &quot;Public Relations&quot;</code></pre><h2 id="Empty-Collections"><a href="#Empty-Collections" class="headerlink" title="Empty Collections"></a>Empty Collections</h2><h3 id="Swift-9"><a href="#Swift-9" class="headerlink" title="Swift"></a>Swift</h3><pre><code>let emptyArray = [String]()let emptyDictionary = [String: Float]()</code></pre><h3 id="kotlin-8"><a href="#kotlin-8" class="headerlink" title="kotlin"></a>kotlin</h3><pre><code>val emptyArray = arrayOf&lt;String&gt;()val emptyMap = mapOf&lt;String, Float&gt;()</code></pre><h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><h3 id="Swift-10"><a href="#Swift-10" class="headerlink" title="Swift"></a>Swift</h3><pre><code>func greet(_ name: String,_ day: String) -&gt; String {return &quot;Hello \(name), today is \(day).&quot;}greet(&quot;Bob&quot;, &quot;Tuesday&quot;)</code></pre><h3 id="kotlin-9"><a href="#kotlin-9" class="headerlink" title="kotlin"></a>kotlin</h3><pre><code>fun greet(name: String, day: String): String {return &quot;Hello $name, today is $day.&quot;}greet(&quot;Bob&quot;, &quot;Tuesday&quot;)</code></pre><h2 id="Tuple-Return"><a href="#Tuple-Return" class="headerlink" title="Tuple Return"></a>Tuple Return</h2><h3 id="Swift-11"><a href="#Swift-11" class="headerlink" title="Swift"></a>Swift</h3><pre><code>func getGasPrices() -&gt; (Double, Double, Double) {return (3.59, 3.69, 3.79)}</code></pre><h3 id="kotlin-10"><a href="#kotlin-10" class="headerlink" title="kotlin"></a>kotlin</h3><pre><code>data class GasPrices(val a: Double, val b: Double,val c: Double)fun getGasPrices() = GasPrices(3.59, 3.69, 3.79)</code></pre><h2 id="Variable-Number-Of-Arguments"><a href="#Variable-Number-Of-Arguments" class="headerlink" title="Variable Number Of Arguments"></a>Variable Number Of Arguments</h2><h3 id="Swift-12"><a href="#Swift-12" class="headerlink" title="Swift"></a>Swift</h3><pre><code>func sumOf(_ numbers: Int...) -&gt; Int {var sum = 0for number in numbers {sum += number}return sum}sumOf(42, 597, 12)</code></pre><h3 id="kotlin-11"><a href="#kotlin-11" class="headerlink" title="kotlin"></a>kotlin</h3><pre><code>fun sumOf(vararg numbers: Int): Int {var sum = 0for (number in numbers) {sum += number}return sum}sumOf(42, 597, 12)// sumOf() can also be written in a shorter way:fun sumOf(vararg numbers: Int) = numbers.sum()</code></pre><h2 id="Function-Type"><a href="#Function-Type" class="headerlink" title="Function Type"></a>Function Type</h2><h3 id="Swift-13"><a href="#Swift-13" class="headerlink" title="Swift"></a>Swift</h3><pre><code>func makeIncrementer() -&gt; (Int -&gt; Int) {func addOne(number: Int) -&gt; Int {return 1 + number}return addOne}let increment = makeIncrementer()increment(7)</code></pre><h3 id="kotlin-12"><a href="#kotlin-12" class="headerlink" title="kotlin"></a>kotlin</h3><pre><code>fun makeIncrementer(): (Int) -&gt; Int {val addOne = fun(number: Int): Int {return 1 + number}return addOne}val increment = makeIncrementer()increment(7)// makeIncrementer can also be written in a shorter way:fun makeIncrementer() = fun(number: Int) = 1 + number</code></pre><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="Swift-14"><a href="#Swift-14" class="headerlink" title="Swift"></a>Swift</h3><pre><code>let numbers = [20, 19, 7, 12]numbers.map { 3 * $0 }</code></pre><h3 id="kotlin-13"><a href="#kotlin-13" class="headerlink" title="kotlin"></a>kotlin</h3><pre><code>val numbers = listOf(20, 19, 7, 12)numbers.map { 3 * it }</code></pre><p>Sort</p><h3 id="Swift-15"><a href="#Swift-15" class="headerlink" title="Swift"></a>Swift</h3><pre><code>var mutableArray = [1, 5, 3, 12, 2]mutableArray.sort()</code></pre><h3 id="kotlin-14"><a href="#kotlin-14" class="headerlink" title="kotlin"></a>kotlin</h3><pre><code>listOf(1, 5, 3, 12, 2).sorted()</code></pre><h2 id="Named-Arguments"><a href="#Named-Arguments" class="headerlink" title="Named Arguments"></a>Named Arguments</h2><h3 id="Swift-16"><a href="#Swift-16" class="headerlink" title="Swift"></a>Swift</h3><pre><code>func area(width: Int, height: Int) -&gt; Int {return width * height}area(width: 2, height: 3)</code></pre><h3 id="kotlin-15"><a href="#kotlin-15" class="headerlink" title="kotlin"></a>kotlin</h3><pre><code>fun area(width: Int, height: Int) = width * heightarea(width = 2, height = 3)// This is also possible with named argumentsarea(2, height = 2)area(height = 3, width = 2)</code></pre><h2 id="Declaration"><a href="#Declaration" class="headerlink" title="Declaration"></a>Declaration</h2><h3 id="Swift-17"><a href="#Swift-17" class="headerlink" title="Swift"></a>Swift</h3><pre><code>class Shape {var numberOfSides = 0func simpleDescription() -&gt; String {return &quot;A shape with \(numberOfSides) sides.&quot;}}</code></pre><h3 id="kotlin-16"><a href="#kotlin-16" class="headerlink" title="kotlin"></a>kotlin</h3><pre><code>class Shape {var numberOfSides = 0fun simpleDescription() =&quot;A shape with $numberOfSides sides.&quot;}</code></pre><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><h3 id="Swift-18"><a href="#Swift-18" class="headerlink" title="Swift"></a>Swift</h3><pre><code>var shape = Shape()shape.numberOfSides = 7var shapeDescription = shape.simpleDescription()</code></pre><h3 id="kotlin-17"><a href="#kotlin-17" class="headerlink" title="kotlin"></a>kotlin</h3><pre><code>var shape = Shape()shape.numberOfSides = 7var shapeDescription = shape.simpleDescription()</code></pre><h2 id="Subclass"><a href="#Subclass" class="headerlink" title="Subclass"></a>Subclass</h2><h3 id="Swift-19"><a href="#Swift-19" class="headerlink" title="Swift"></a>Swift</h3><pre><code>class NamedShape {var numberOfSides: Int = 0let name: Stringinit(name: String) {self.name = name}func simpleDescription() -&gt; String {return &quot;A shape with \(numberOfSides) sides.&quot;}}class Square: NamedShape {var sideLength: Doubleinit(sideLength: Double, name: String) {self.sideLength = sideLengthsuper.init(name: name)self.numberOfSides = 4}func area() -&gt; Double {return sideLength * sideLength}override func simpleDescription() -&gt; String {return &quot;A square with sides of length &quot; +sideLength + &quot;.&quot;}}let test = Square(sideLength: 5.2, name: &quot;square&quot;)test.area()test.simpleDescription()</code></pre><h3 id="kotlin-18"><a href="#kotlin-18" class="headerlink" title="kotlin"></a>kotlin</h3><pre><code>open class NamedShape(val name: String) {var numberOfSides = 0open fun simpleDescription() =&quot;A shape with $numberOfSides sides.&quot;}class Square(var sideLength: BigDecimal, name: String) :NamedShape(name) {init {numberOfSides = 4}fun area() = sideLength.pow(2)override fun simpleDescription() =&quot;A square with sides of length $sideLength.&quot;}val test = Square(BigDecimal(&quot;5.2&quot;), &quot;square&quot;)test.area()test.simpleDescription()</code></pre><h2 id="Checking-Type"><a href="#Checking-Type" class="headerlink" title="Checking Type"></a>Checking Type</h2><h3 id="Swift-20"><a href="#Swift-20" class="headerlink" title="Swift"></a>Swift</h3><pre><code>var movieCount = 0var songCount = 0for item in library {if item is Movie {movieCount += 1} else if item is Song {songCount += 1}}</code></pre><h3 id="kotlin-19"><a href="#kotlin-19" class="headerlink" title="kotlin"></a>kotlin</h3><pre><code>var movieCount = 0var songCount = 0for (item in library) {if (item is Movie) {++movieCount} else if (item is Song) {++songCount}}</code></pre><h2 id="Pattern-Matching"><a href="#Pattern-Matching" class="headerlink" title="Pattern Matching"></a>Pattern Matching</h2><h3 id="Swift-21"><a href="#Swift-21" class="headerlink" title="Swift"></a>Swift</h3><pre><code>let nb = 42switch nb {case 0...7, 8, 9: print(&quot;single digit&quot;)case 10: print(&quot;double digits&quot;)case 11...99: print(&quot;double digits&quot;)case 100...999: print(&quot;triple digits&quot;)default: print(&quot;four or more digits&quot;)}</code></pre><h3 id="kotlin-20"><a href="#kotlin-20" class="headerlink" title="kotlin"></a>kotlin</h3><pre><code>val nb = 42when (nb) {in 0..7, 8, 9 -&gt; println(&quot;single digit&quot;)10 -&gt; println(&quot;double digits&quot;)in 11..99 -&gt; println(&quot;double digits&quot;)in 100..999 -&gt; println(&quot;triple digits&quot;)else -&gt; println(&quot;four or more digits&quot;)}</code></pre><h2 id="Downcasting"><a href="#Downcasting" class="headerlink" title="Downcasting"></a>Downcasting</h2><h3 id="Swift-22"><a href="#Swift-22" class="headerlink" title="Swift"></a>Swift</h3><pre><code>for current in someObjects {if let movie = current as? Movie {print(&quot;Movie: &apos;\(movie.name)&apos;, &quot; +&quot;dir. \(movie.director)&quot;)}}</code></pre><h3 id="kotlin-21"><a href="#kotlin-21" class="headerlink" title="kotlin"></a>kotlin</h3><pre><code>for (current in someObjects) {if (current is Movie) {println(&quot;Movie: &apos;${current.name}&apos;, &quot; +&quot;dir. ${current.director}&quot;)}}</code></pre><h2 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h2><h3 id="Swift-23"><a href="#Swift-23" class="headerlink" title="Swift"></a>Swift</h3><pre><code>protocol Nameable {func name() -&gt; String}func f&lt;T: Nameable&gt;(x: T) {print(&quot;Name is &quot; + x.name())}</code></pre><h3 id="kotlin-22"><a href="#kotlin-22" class="headerlink" title="kotlin"></a>kotlin</h3><pre><code>interface Nameable {fun name(): String}fun f&lt;T: Nameable&gt;(x: T) {println(&quot;Name is &quot; + x.name())}</code></pre><h2 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h2><h3 id="Swift-24"><a href="#Swift-24" class="headerlink" title="### Swift"></a>### Swift</h3><pre><code>extension Double {var km: Double { return self * 1_000.0 }var m: Double { return self }var cm: Double { return self / 100.0 }var mm: Double { return self / 1_000.0 }var ft: Double { return self / 3.28084 }}let oneInch = 25.4.mmprint(&quot;One inch is \(oneInch) meters&quot;)// prints &quot;One inch is 0.0254 meters&quot;let threeFeet = 3.ftprint(&quot;Three feet is \(threeFeet) meters&quot;)// prints &quot;Three feet is 0.914399970739201 meters&quot;</code></pre><h3 id="kotlin-23"><a href="#kotlin-23" class="headerlink" title="kotlin"></a>kotlin</h3><pre><code>val Double.km: Double get() = this * 1000val Double.m: Double get() = thisval Double.cm: Double get() = this / 100val Double.mm: Double get() = this / 1000val Double.ft: Double get() = this / 3.28084val oneInch = 25.4.mmprintln(&quot;One inch is $oneInch meters&quot;)// prints &quot;One inch is 0.0254 meters&quot;val threeFeet = 3.0.ftprintln(&quot;Three feet is $threeFeet meters&quot;)// prints &quot;Three feet is 0.914399970739201 meters&quot;</code></pre>]]></content>
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> kotlin——和Swift像得一塌糊涂 </tag>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kotlin——要火了❤️，你还在等什么？</title>
      <link href="/2017/05/18/kotlin%E2%80%94%E2%80%94%E8%A6%81%E7%81%AB%E4%BA%86%E2%9D%A4%EF%B8%8F%EF%BC%8C%E4%BD%A0%E8%BF%98%E5%9C%A8%E7%AD%89%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2017/05/18/kotlin%E2%80%94%E2%80%94%E8%A6%81%E7%81%AB%E4%BA%86%E2%9D%A4%EF%B8%8F%EF%BC%8C%E4%BD%A0%E8%BF%98%E5%9C%A8%E7%AD%89%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>其实在去年我就开发在了解Kotlin，只是由于项目的原因，还有一些人根本不知道他的存在，然后推荐给了不少人，都被否决了！</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/kotlin/kotlin001.jpg" alt="曹理鹏(iCocos)-梦工厂"></p><a id="more"></a><p>百度发音：kotlin——科特林</p><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>今早睡一醒来打开手机一看，发现朋友圈被刷屏了！</p></blockquote><p>其实在去年我就开发在了解Kotlin，只是由于项目的原因，还有一些人根本不知道他的存在，然后推荐给了不少人，都被否决了！</p><blockquote><p>kotlin要火了，昨晚的Google I/O大会，Google宣布正式其实kotlin。</p></blockquote><p>这个小时对几乎所有Android的猿类来说，应该是最震惊的，为什么呢？</p><pre><code>因为你又有一门新的语言可以学习了，就像Swift对iOS程序员的意义意义！</code></pre><p>当然这个消息不仅对Android程序员比较震惊，对几乎所有做iOS开发的程序也是一个值得关注的消息？为什么呢？</p><pre><code>那你的问问Swift为什么和他长得这么像！</code></pre><h3 id="先来看看昨晚Google-I-O-2017有哪些亮点？"><a href="#先来看看昨晚Google-I-O-2017有哪些亮点？" class="headerlink" title="先来看看昨晚Google I/O 2017有哪些亮点？"></a>先来看看昨晚Google I/O 2017有哪些亮点？</h3><pre><code>TPU（用于深度学习的处理器）Google Lens （新API，摄像头直接支持图像识别）Google Assistan新功能Google Home新功能Google Photos新功能Android支持分屏Android支持Kotlin开发Tango（AR）进展Daydream（VR）进展Google工作搜索</code></pre><p>想了解更多请看官方发布视频与相关总结！</p><h3 id="有人用一句话总结"><a href="#有人用一句话总结" class="headerlink" title="有人用一句话总结"></a>有人用一句话总结</h3><pre><code>AI已经无处不在了</code></pre><blockquote><p>这里是主要阐述kotlin的，上面两点中“Android支持Kotlin开发”也是我非常关注和值得开心的一件！</p></blockquote><h2 id="所以，Let-s-Go"><a href="#所以，Let-s-Go" class="headerlink" title="所以，Let`s Go"></a>所以，Let`s Go</h2><p>首先有任何想了解kotlin的，建议最好先看官方教程：<a href="http://kotlinlang.org/" target="_blank" rel="noopener">http://kotlinlang.org/</a></p><h3 id="Kotlin是什么"><a href="#Kotlin是什么" class="headerlink" title="Kotlin是什么"></a>Kotlin是什么</h3><pre><code>Kotlin 是一个基于 JVM 的新的编程语言，由 JetBrains 开发。Kotlin可以编译成Java字节码，也可以编译成JavaScript，方便在没有JVM的设备上运行。JetBrains，作为目前广受欢迎的Java IDE IntelliJ 的提供商，在 Apache 许可下已经开源其Kotlin 编程语言。</code></pre><p>众所周知Android程序是运行在Java虚拟机之上的，因此从技术上来说，可以运行在JVM之上的一切都可用于开发Android应用。现在已经有很多可以生成JVM能够执行的字节码的语言，其中一些语言开始崭露头角并逐步流行起来。<br>现存的计算机编程语言有好几千种，JVM上的语言也有十几种(比如NBJL/Clojure/Groovy/Scala/Fantom)，所以大可不必为没听说过的编程语言感到惊奇,我也就听过Groovy/Scala/Kotlin，scala比较和C语言接近，而Groovy和java很相似你肯定对gradle不陌生吧，但是Kotlin就是其中的佼佼者。</p><pre><code>近日召开的 Google IO 2017 ， Google 将 Kotlin 列为 Android 官方开发语言了，Android Studio 3.0 也默认集成了 Kotlin plugin</code></pre><h3 id="kotlin的历史"><a href="#kotlin的历史" class="headerlink" title="kotlin的历史"></a>kotlin的历史</h3><p>历史2011 年 7 月，JetBrains 推出 Kotlin 项目，这是一个面向 JVM 的新语言，它已被开发一年之久。JetBrains 负责人Dmitry Jemerov 说，大多数语言没有他们正在寻找的特性，Scala 除外，他指出了 Scala 的编译时间慢这一明显缺陷。Kotlin 的既定目标之一是像 Java 一样快速编译。</p><blockquote><p>2012 年 2 月，JetBrains 以 Apache 2 许可证开源此项目，Jetbrains 希望这个新语言能够推动 IntelliJ IDEA 的销售。</p></blockquote><p>Kotlin v1.0 于 2016 年 2 月 15 日发布。这被认为是第一个官方稳定版本，并且 JetBrains 已准备从该版本开始的长期向后兼容性。</p><pre><code>在 Google I/O 2017 中，Google 宣布在 Android 上为 Kotlin 提供支持。</code></pre><h3 id="Kotlin设计的目的"><a href="#Kotlin设计的目的" class="headerlink" title="Kotlin设计的目的"></a>Kotlin设计的目的</h3><pre><code>创建一种兼容Java的语言让它比Java更安全，能够静态检测常见的陷阱。如：引用空指针让它比Java更简洁，通过支持variable type inference，higher-order functions (closures)，extension functions，mixins and first-class delegation等实现。让它比最成熟的竞争对手Scala语言更加简单</code></pre><h3 id="java的缺陷："><a href="#java的缺陷：" class="headerlink" title="java的缺陷："></a>java的缺陷：</h3><pre><code>对象可以赋值null造成NPE受检异常(checked exception)属性getter，setter太烦接口不能有实现（java8 fixed）缺乏Lambda(java8 fixed)方法Overloading对可读性和动态调用造成伤害。语言层缺乏模块化支持并发支持很糟糕原始类型不是对象&gt;</code></pre><h3 id="Kotlin优势："><a href="#Kotlin优势：" class="headerlink" title="Kotlin优势："></a>Kotlin优势：</h3><pre><code>创建一种兼容Java的语言让它比Java更安全，能够静态检测常见的陷阱。如：引用空指针让 它比Java更简洁，通过支持variable type inference，higher-order functions (closures)，extension functions，mixins and first-class delegation等实现。</code></pre><h3 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h3><p>轻量级：</p><pre><code>这一点对于Android来说非常重要。项目所需要的库应该尽可能的小。Android对于方法数量有严格的限制，Kotlin只额外增加了大约6000个方法。</code></pre><p>互操作：</p><pre><code>Kotlin可与Java语言无缝通信。这意味着我们可以在Kotlin代码中使用任何已有的Java库；因此，即便这门语言还很年轻，但却已经可以使用成百上千的库了。除此之外，Kotlin代码还可以为Java代码所用，这意味着我们可以使用这两种语言来构建软件。你可以使用Kotlin开发新特性，同时使用Java实现代码基的其他部分。</code></pre><p>强类型：</p><pre><code>我们很少需要在代码中指定类型，因为编译器可以在绝大多数情况下推断出变量或是函数返回值的类型。这样就能获得两个好处：简洁与安全。</code></pre><p>Null安全：</p><pre><code>Java最大的一个问题就是null。如果没有对变量或是参数进行null判断，那么程序当中就有可能抛出大量的NullPointerException，然而在编码时这些又是难以检测到的。Kotlin使用了显式的null，这会强制我们在必要时进行null检查。</code></pre><h3 id="适用平台"><a href="#适用平台" class="headerlink" title="适用平台"></a>适用平台</h3><pre><code>只要能用Java的地方就能用Kotlin， Kotlin支持所有主要的开发工具以及服务，比如：* IntelliJ IDEA、Android Studio和Eclipse；* Maven、Gradle和Ant；* spring Boot（Kotlin 支持今天正式发布！）；* GitHub，Slack，甚至Minecraft。 </code></pre><h2 id="分类整理一下-Kotlin-VS-Java"><a href="#分类整理一下-Kotlin-VS-Java" class="headerlink" title="分类整理一下 Kotlin VS Java"></a>分类整理一下 Kotlin VS Java</h2><h3 id="语法简单不啰嗦"><a href="#语法简单不啰嗦" class="headerlink" title="语法简单不啰嗦"></a>语法简单不啰嗦</h3><p>Kotlin的一个主要优点是它的简洁。 你用更少的代码获得更多的功能。</p><pre><code>① Kotlin 支持类型推断，没有 Java 那样的啰嗦。② 用 var 表示变量，val 表示常量更加的简洁③ 方法也很简单，连 function 都缩写成了 fun④ 类的继承和实现很简单，使用:即可⑤ Kotlin 每个句子都不需要加分号 (;)</code></pre><h3 id="避免空指针异常"><a href="#避免空指针异常" class="headerlink" title="避免空指针异常"></a>避免空指针异常</h3><p>在许多编程语言中最大的痛苦 - 空指针异常。 但是使用Kotlin，这个问题得到了很好的解决</p><pre><code>① 在类型上的处理，即在类型后面加上?，即表示这个变量或参数以及返回值可以为 null，否则不允许为变量参数赋值为 null 或者返回 null② 对于一个可能是 null 的变量或者参数，在调用对象方法或者属性之前，需要加上?，否则编译无法通过。</code></pre><h3 id="支持方法拓展"><a href="#支持方法拓展" class="headerlink" title="支持方法拓展"></a>支持方法拓展</h3><pre><code>Kotlin有一个聪明的解决方案 - 扩展功能 ，帮助你摆脱所有的util类一劳永逸。扩展函数几乎是一个通常的Kotlin函数。 但是当你声明它，你需要指定的实例将具有扩展功能的类。注意：Kotlin 的方法扩展并不是真正修改了对应的类文件，而是在编译器和 IDE 方面做得处理。使我们看起来像是扩展了方法。</code></pre><h3 id="高阶函数，-函数式编程支持"><a href="#高阶函数，-函数式编程支持" class="headerlink" title="高阶函数， 函数式编程支持"></a>高阶函数， 函数式编程支持</h3><pre><code>所谓的高阶函数就是：可以接受函数作为参数，也可以返回函数作为结果。Kotlin 支持了 Streams API 和方法引用，这样函数式编程更加方便。比如下面的代码就是我们结合 Jsoup，来抓取某个 proxy 网站的数据，代码更加简单，实现起来也快速。</code></pre><h3 id="关于性能"><a href="#关于性能" class="headerlink" title="关于性能"></a>关于性能</h3><pre><code>Kotlin 的执行效率和 Java 代码的执行效率理论上一致的。有时候 Kotlin 可能会显得高一些。比如 Kotlin 提供了方法的 inline 设置，可以设置某些高频方法进行 inline 操作，减少了运行时的进栈出栈和保存状态的开销。</code></pre><h3 id="与Java互操作"><a href="#与Java互操作" class="headerlink" title="与Java互操作"></a>与Java互操作</h3><pre><code>Kotlin 在设计时就考虑了 Java 互操作性。可以从 Kotlin 中自然地调用现存的 Java 代码，并且在 Java 代码中也可以 很顺利地调用 Kotlin 代码。</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code>Kotlin的特性有很多，总的来说， Kotlin这门语言简化了Java , 完全是从一个是实用派的角度，而不是学院派的角度。相比于JRuby , Jython这些一移植到JVM上的语言， Kotlin 和Java 和互操作感觉更加自然。每个语言的流行都需要一个引爆点，就像Ruby on Rails 引爆了Ruby 一样， Android 也许就是之前不那么流行的Kotlin的引爆点。</code></pre><p>这里有一篇不错的入门实战教程，非常简单：<a href="http://www.jianshu.com/p/cf1f96c56150" target="_blank" rel="noopener">http://www.jianshu.com/p/cf1f96c56150</a></p><blockquote><p>Kotlin这里就不说了，太乏味了，最后一句话总结一下kotlin</p></blockquote><pre><code>Android届的Swift（请深刻理解其中的含义）</code></pre><h2 id="各位Android的同仁们，是时候了，不管是为了喜好还是为了以后的规划，你都应该停下手上的活，抽出一切空余时间进攻kotlin，相信我，不学你会后悔的，哈哈！"><a href="#各位Android的同仁们，是时候了，不管是为了喜好还是为了以后的规划，你都应该停下手上的活，抽出一切空余时间进攻kotlin，相信我，不学你会后悔的，哈哈！" class="headerlink" title="各位Android的同仁们，是时候了，不管是为了喜好还是为了以后的规划，你都应该停下手上的活，抽出一切空余时间进攻kotlin，相信我，不学你会后悔的，哈哈！"></a>各位Android的同仁们，是时候了，不管是为了喜好还是为了以后的规划，你都应该停下手上的活，抽出一切空余时间进攻kotlin，相信我，不学你会后悔的，哈哈！</h2><p>当然有机会我也会去了解，接触一些kotlin开发的知识，哪怕我不会转到哪上面去，这就是我们所谓的广度优先！</p><p>如果想简单入门kotlin语法和一些特点可以看这里：<a href="http://www.jianshu.com/p/1ea733ea197d" target="_blank" rel="noopener">http://www.jianshu.com/p/1ea733ea197d</a></p><p>学习资源：</p><p><a href="https://www.kotlincn.net/docs/reference/" target="_blank" rel="noopener">1.kotlin官方中文翻译文档网址</a></p><p><a href="http://kotlinlang.org/" target="_blank" rel="noopener">2.Kotlin官网</a></p><p><a href="https://www.kotlincn.net/" target="_blank" rel="noopener">3.kotlin中文官网</a></p><p><a href="https://www.gitbook.com/book/hltj/kotlin-reference-chinese/details" target="_blank" rel="noopener">4.kotlin的gitbook网址</a></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/kotlin/kotlin002.jpg" alt="曹理鹏(iCocos)-梦工厂"></p><p><a href="https://try.kotlinlang.org/" target="_blank" rel="noopener">在线学习</a></p><p><a href="https://kotlinlang.org/docs/reference/" target="_blank" rel="noopener">Kotlin官方文档</a></p>]]></content>
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
            <tag> kotlin——要火了❤️，你还在等什么？ </tag>
            
            <tag> Google I/O </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2017@Swift——后感</title>
      <link href="/2017/05/15/2017-Swift%E2%80%94%E2%80%94%E5%90%8E%E6%84%9F/"/>
      <url>/2017/05/15/2017-Swift%E2%80%94%E2%80%94%E5%90%8E%E6%84%9F/</url>
      <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftHome001.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><p>2017@Swift——中国开发者大会（第二站）</p><pre><code>会议时间：2017年5月13日-5月14日，地址：深圳凯宾斯基酒店，人数：400人嘉宾：18人，其中8位国外，8位国内。</code></pre><blockquote><p>第一天所有外国嘉宾的演讲时间，第二天是国内大牛的演讲时间！</p></blockquote><a id="more"></a><p>记得第一站是去年在北京举行，当时项目太赶，就没有去，今年有幸能参加此次大会，并且收获真心不少。因此这里稍微整理了一下这两天最大的感触，和所学到的东西！</p><blockquote><p>当然关于技术的分享，后期会有专门的文章与结合简单的实战整理一并分享出来，敬请期待…….</p></blockquote><p>更多信息请点<a href="http://www.bagevent.com/event/378252" target="_blank" rel="noopener">2017@Swift——中国开发者大会</a>,同时后面也会抽空整理一下会议中讲到的内容，底层，细节与实现，敬请期待！</p><h2 id="2017-Swift——后感"><a href="#2017-Swift——后感" class="headerlink" title="2017@Swift——后感"></a>2017@Swift——后感</h2><blockquote><p>这种收获真不是一两句话或者一两篇文章就能说清楚的，如果你有事吗疑问或者想了解先关内容也可以直接关注我，联系我！</p></blockquote><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftHome002.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><p>第二届 @Swift 中国开发者大会</p><ol><li>英语能力</li><li>交友</li><li>技术</li></ol><h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><p>为什么这里我把英语能力放在最前面，肯定是有原因的。</p><pre><code>1. 开会第一天所有都是老外，所有人都直接用英语讲，几乎听不太懂，所以导致很多东西根本没有听到重点与细节2. 会后交流，与提问，人家都能听懂，甚至都能提出自己的问题与观点，甚至还能通嘉宾进行更多更加升入的交流与讨论，而我却只能翻译或者发呆3. 技术的学习，几乎所有的最好，最新的技术资料都是从英文开始的，当你开始看中文翻译资料或者开始研究的时候，人家已经换了一种技术4. 后期的规划问题，出国旅游，出国发展（有点长远，当然也不是没有可能的），或者有机会接触外国朋友。</code></pre><p>总结：针对程序员，哪怕只有一点基础的，技术这种东西都可以慢慢学，或者在实际项目中提高，如果你英文不好很多事情真的很难进行下去，除非你没有什么长远的目标或者没有自己个人的规划。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftHome003.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftHome004.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h2 id="交友"><a href="#交友" class="headerlink" title="交友"></a>交友</h2><p>经过这次会议之后，看到了很多牛人，也认识了不少牛人之后才知道自己的渺小，才知道自己原来离期望中太远太远。</p><pre><code>1. 最有名的Swift框架RXSwift的作者2. Google工程师3. 腾讯，美团，礼物说，阿里等一些非常厉害的架构师，同时也是技术迷4. 不少技术书籍的作者，其中有一位是我非常喜欢的巧哥@唐巧5. 不同公司的技术主管，开发人员，初入门的程序员6. 两天的会议中认识到了不少来自去全国各地参会者，也结下了不少好友！</code></pre><p>总结：永远不要觉得自己多牛逼，当你真的看到牛人之后你就会发现，其实自己真的很low，哪怕你做过再多项目，写过再多代码，不思考，不提升依然是个菜鸟。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftHome005.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftHome006.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftHome007.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><pre><code>1. 主题就是Swift：iOS，后台肯定是重心2. Swift实现AI，智能，机器学习，树莓派的结合，后期的转行。3. 实现属于自己的东西，小的方向比如小框架，静态或者动态库，大的话其中有人自己写了一个Swift转H5的编译器4. App性能的提升，多线程，锁，MVVM, 自动化（测试，脚本）5. 包括开发，集成，测试，发布，维护需要有一套完成的规范与流程。</code></pre><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftHome008.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftHome009.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><p>总之，程序员是一个需要时刻保持学习的职业，不学你就将被淘汰，不管学习技术，管理，社交，英语或者学习别人成功或失败的经验</p><p>未来的路还很长，希望一路上的坎坷能让我足够强大。</p><p>说说我接下来的规划（我只谈短期1-2年）：</p><pre><code>1. 学习英语，不管是自学还是报班这都是现阶段最最最重要的任务,同时也会长期的坚持下去。2. 着手Swift进行项目实战，对PHP实战后台开发进一步的提升，同时去了解Swift实现后台开发3. iOS深挖：深入解析Max OS X &amp; iOS操作系统4. 学习Python，了解机器学习等技术</code></pre><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftHome010.JPG" alt="曹理鹏(iCocos)-梦工厂"></p>]]></content>
      
      <categories>
          
          <category> 2017@Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2017@Swift——后感 </tag>
            
            <tag> Swift </tag>
            
            <tag> 大会后感 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2017@Swift——中国开发者大会（第二天）</title>
      <link href="/2017/05/15/2017-Swift%E2%80%94%E2%80%94%E4%B8%AD%E5%9B%BD%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%A4%A9%EF%BC%89/"/>
      <url>/2017/05/15/2017-Swift%E2%80%94%E2%80%94%E4%B8%AD%E5%9B%BD%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%A4%A9%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>首先介绍一下会议信息</p><pre><code>会议时间：2017年5月13日-5月14日，地址：深圳凯宾斯基酒店，人数：400人嘉宾：18人，其中8位国外，8位国内。</code></pre><blockquote><p>第一天所有外国嘉宾的演讲时间，第二天是国内大牛的演讲时间！</p></blockquote><a id="more"></a><p>更多信息请点<a href="http://www.bagevent.com/event/378252" target="_blank" rel="noopener">2017@Swift——中国开发者大会</a>,同时后面也会抽空整理一下会议中讲到的内容，底层，细节与实现，敬请期待！</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftMain000.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftMain001.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><p>=============================================================================</p><h2 id="唐巧（小猿搜题产品技术负责人）"><a href="#唐巧（小猿搜题产品技术负责人）" class="headerlink" title="唐巧（小猿搜题产品技术负责人）"></a>唐巧（小猿搜题产品技术负责人）</h2><p>Richards 和 Deltablue 是衡量语言运算速度的两个主流的评测代码。Swift 在这两个评测中，显示出远超 Objective-C 的性能。特别是 Richards 评测，Swift 比 Objective-C 快了 4 倍。那么，为什么 Swift 这么快呢？本次分享，我将从编译器优化，内存分配优化，引用计数优化，方法调用优化，面向协议编程的实现细节等方面来介绍 Swift 在性能上所做的努力。如果可能，我们也会一起看看编译器处理后的源码，加深我们对于这些优化的理解。</p><p>小猿搜题产品技术负责人，资深 iOS 开发者，曾开发过网易邮箱、网易微博、有道云笔记、猿题库、小猿搜题。喜欢写作和分享，维护着中国关注者最多的iOS领域的微信公众号「iOS开发by唐巧」，产出了超过 100 篇原创的 iOS 技术文章，出版了一本 iOS 进阶读物《iOS开发进阶》。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift100.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift101.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="Swift-为什么这么快"><a href="#Swift-为什么这么快" class="headerlink" title="Swift 为什么这么快"></a>Swift 为什么这么快</h3><pre><code>1. 第二天中，唯一一个使用英文演讲的国内大牛，挑战自我。2. 从不同方便说明为什么swift比OC好：引用数，struct的内存布局，性能优化，编译器、内存、消息转发机制、引用数和protocol。 </code></pre><p>=============================================================================</p><h2 id="戴铭（滴滴出行技术专家）"><a href="#戴铭（滴滴出行技术专家）" class="headerlink" title="戴铭（滴滴出行技术专家）"></a>戴铭（滴滴出行技术专家）</h2><blockquote><p>github.com/ming1016</p></blockquote><p>结合实例介绍如何用 LLVM IR 中间语言和编译前端的语法解析来设计一门简洁易用支持多平台的 DSL 语言，从而提高开发效率。介绍如何使用 Swift 开发一个类似 Clang 并且支持插件的简版编译前端，从而优化代码，提高工程质量。此外还会简单介绍一些有趣的实践。</p><p>微博@戴铭。滴滴出行技术专家，技术上主要负责滴滴出行 iOS 相关的开发工作。时常会将对新技术的深入研究和工作的经验总结发在微博上。对 ReactiveCocoa，RxSwift，软件架构，性能优化和算法有着浓厚的兴趣。最近正在研究iOS编译相关底层技术，用来解决工程优化问题，到时会将成果分享出来。 </p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift200.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift201.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="学习-iOS-编译原理能做哪些有意思的事情"><a href="#学习-iOS-编译原理能做哪些有意思的事情" class="headerlink" title="学习 iOS 编译原理能做哪些有意思的事情"></a>学习 iOS 编译原理能做哪些有意思的事情</h3><pre><code>1. 这哥们可谓是有着一双被编程耽误了的画手，不但主题，技术吸引人，所画出来的作品更是让人回味。2. 先讲了一个关于flexbox布局的web代码，自己使用swift写了一个解析器。3. 结合上面的实现个性化的讲解了一下编译器前后端，及编译的整个过程</code></pre><p>=============================================================================</p><h2 id="柯灵杰（腾讯公司iOS开发）"><a href="#柯灵杰（腾讯公司iOS开发）" class="headerlink" title="柯灵杰（腾讯公司iOS开发）"></a>柯灵杰（腾讯公司iOS开发）</h2><p>图片组件可以说是app开发中使用最多的组件之一，它既简单也不简单，如何设计和开发一个具有高扩展性，高性能的图片组件呢？本次分享将会从架构设计到性能优化等多方面，全面解析一个优秀图片组件的设计和开发原理，以及在性能优化和架构设计方面的一些经验和探索。</p><p>柯灵杰（lingtonke），腾讯公司 iOS 开发。腾讯学院认证讲师，主要讲授课程《设计模式》。曾参加过 QQ、QZone、微云、企鹅 MV、闪咖等的开发。他主导开发的图片组件，在腾讯内被多个项目使用，获得公司内多项优秀组件奖，目前已着手对业内开源。同时他还是数项技术发明专利的发明人，曾参加过程序员 LiveShow《有码的开发哥无码的直播》。目前是腾讯 QZone 团队 iOS 开发。 </p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift300.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift301.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="打造易扩展的高性能图片组件"><a href="#打造易扩展的高性能图片组件" class="headerlink" title="打造易扩展的高性能图片组件"></a>打造易扩展的高性能图片组件</h3><pre><code>1. 如何设计高性能易拓展的图片组件，一步一步的优化。2. 综合分析的不同框架，不同实现方案，不同技术的优缺点。3. 当时我会中问到是否开源，回答是会，并且预计年底会开源。</code></pre><p>=============================================================================</p><h2 id="王文槿（UC资深开发工程师）"><a href="#王文槿（UC资深开发工程师）" class="headerlink" title="王文槿（UC资深开发工程师）"></a>王文槿（UC资深开发工程师）</h2><p>来自 UC 浏览器的 iPhone 组，参与了 UC 浏览器，UC 头条和夸克浏览器相关产品的开发，工作中主要使用 OC 和 Weex 。不过业余是不折不扣的 Swift 爱好者，自诩 Swift 的函数式编程的布道师。曾经先后通过文章&amp;演讲的形式分享了 Swift 异步串行/并行编程以及函数式的设计模式等话题。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift400.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift401.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="一个轻量级-FRP-框架的诞生记"><a href="#一个轻量级-FRP-框架的诞生记" class="headerlink" title="一个轻量级 FRP 框架的诞生记"></a>一个轻量级 FRP 框架的诞生记</h3><pre><code>1. 之前UC面试过一次，可惜挂了2. 主要结合实际以一个很简单的Demo演示了MVVM，并且很清晰的解答了众多为止疑惑的参会者。</code></pre><p>=============================================================================</p><h2 id="赵恩生（美团点评高级工程师）"><a href="#赵恩生（美团点评高级工程师）" class="headerlink" title="赵恩生（美团点评高级工程师）"></a>赵恩生（美团点评高级工程师）</h2><p>随着业务拆分和组件化的完成，美团 iOS 客户端在集成和交付的道路上越发艰难。在业务代码下放后，如何能保证客户端的安全稳定；面对千万用户，如何能快速优雅地组建并交付一个完整的客户端，这一切的一切都值得思考和深究。</p><p>希望通过本次分享，和各位一起探讨如何玩转大业务体量下的众多组件、如何搭建整个客户端的发布流程。</p><p>美团点评高级工程师，曾维护美团 iOS 客户端，现负责 iOS 发布流程相关工作，专业打杂，通过对复杂业务下组件发布集成的踩坑总结，对 CI CD 有一定的认识和理解。闲暇时喜欢捣鼓乱七八糟的东西，自学习得包括疏通下水道，手机贴膜，设备维修在内的一些奇怪技能。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift500.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift501.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="组件-组建-美团-iOS-客户端"><a href="#组件-组建-美团-iOS-客户端" class="headerlink" title="组件 + 组建 = 美团 iOS 客户端"></a>组件 + 组建 = 美团 iOS 客户端</h3><pre><code>1. 美团开发，集成，打包，测试，发布整个流程的工作与注意点。2. 组件式的开发方式，规范性的流程与测试形成一个闭环3. 校验，避错，后期的修复的考虑及解决方案4. CI的基本流程介绍</code></pre><p>=============================================================================</p><h2 id="傅若愚（ThoughtWorks-高级咨询师）"><a href="#傅若愚（ThoughtWorks-高级咨询师）" class="headerlink" title="傅若愚（ThoughtWorks 高级咨询师）"></a>傅若愚（ThoughtWorks 高级咨询师）</h2><p>是的，你一定听说过 Metal，或者你还写过一些 Metal 的 Shader。不过，说实话，喝了两杯啤酒之后，面对 Xcode，我们能做点儿更有趣的东西么？要不要来试试？</p><p>来自 ThoughtWorks，刚睡醒的移动开发者，喝高了的 Tech Lead，SwiftyJSON 的作者（但这家伙已经弃坑……Oh，别担心，其他人还在维护）。业余喜读书，文史哲无所禁忌，爱美食与啤酒（最近爱上了 American Pale Ale），今年大概 17 岁的样子。 </p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift600.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift601.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="一些跟-Metal-有关系，肯定有趣但多半没用的东西"><a href="#一些跟-Metal-有关系，肯定有趣但多半没用的东西" class="headerlink" title="一些跟 Metal 有关系，肯定有趣但多半没用的东西"></a>一些跟 Metal 有关系，肯定有趣但多半没用的东西</h3><pre><code>1. 主要是机器学习，高逼格式的讲解了神经网络2. 输入图片，视频染色然后渲染并输出对应的效果。3. 主要是一些基础的概念，理论知识。</code></pre><p>=============================================================================</p><h2 id="尹航（Google-工程师）"><a href="#尹航（Google-工程师）" class="headerlink" title="尹航（Google 工程师）"></a>尹航（Google 工程师）</h2><p>深度学习总是让人联想到成吨的数据、笨重的服务器。但在移动端，我们能不能利用深度学习做一点有趣的事情呢？本次分享，让我们看看如何在iOS上运行起工业级的深度学习框架TensorFlow吧。</p><p>一个技能树歪掉的开发者。iOS 首个游戏辅助“叉叉助手”作者，也曾经编写《Cocos2d-x高级开发教程》，目前兴趣有移动安全和机器学习，Google 工程师，从事 Gmail 语义理解相关开发。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift700.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift701.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="TensorFlow-iOS-❤️-造一个颜文字输入法"><a href="#TensorFlow-iOS-❤️-造一个颜文字输入法" class="headerlink" title="TensorFlow+iOS=❤️: 造一个颜文字输入法"></a>TensorFlow+iOS=❤️: 造一个颜文字输入法</h3><pre><code>1. 机器学习，实战了一个emoji表情的输出。2. 介绍了TensorFlow，介绍了他的一些特性与简单的应用</code></pre><p>=============================================================================</p><h2 id="唐晓轩（礼物说联合创始人）"><a href="#唐晓轩（礼物说联合创始人）" class="headerlink" title="唐晓轩（礼物说联合创始人）"></a>唐晓轩（礼物说联合创始人）</h2><p>Live Coding</p><p>礼物说联合创始人，全栈打杂工程师，公众号糖炒小虾，热衷于折腾各种黑技术。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift800.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/TwoDay/Swift801.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="当-Swift-遇上树莓派"><a href="#当-Swift-遇上树莓派" class="headerlink" title="当 Swift 遇上树莓派"></a>当 Swift 遇上树莓派</h3><pre><code>1. swift和树莓派之间的交互。2. Swift+ARM，展示了一个watch跑的超级玛丽。3. 展示数个小Demo，演示怎么与实际相结合，并提到为了对小米设备的实际应用</code></pre><p>=============================================================================</p><h2 id="第二天尾声…"><a href="#第二天尾声…" class="headerlink" title="第二天尾声…"></a>第二天尾声…</h2><p>到此整个会议已经全部结束，这一天在技术，底层，架构等方面收获就完全不一样了，同时后期会有文章介绍相关内容！</p><p>随后，大家都纷纷离开准备回家或者会工作的城市！</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftMain002.JPG" alt="曹理鹏(iCocos)-梦工厂"> </p>]]></content>
      
      <categories>
          
          <category> 2017@Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 大会 </tag>
            
            <tag> 2017@Swift——中国开发者大会（第二天） </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2017@Swift——中国开发者大会（第一天）</title>
      <link href="/2017/05/15/2017-Swift%E2%80%94%E2%80%94%E4%B8%AD%E5%9B%BD%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A%EF%BC%88%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%89/"/>
      <url>/2017/05/15/2017-Swift%E2%80%94%E2%80%94%E4%B8%AD%E5%9B%BD%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A%EF%BC%88%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>首先介绍一下会议信息</p><pre><code>会议时间：2017年5月13日-5月14日，地址：深圳凯宾斯基酒店，人数：400人嘉宾：18人，其中8位国外，8位国内。</code></pre><blockquote><p>第一天所有外国嘉宾的演讲时间，第二天是国内大牛的演讲时间！</p></blockquote><a id="more"></a><p>更多信息请点<a href="http://www.bagevent.com/event/378252" target="_blank" rel="noopener">2017@Swift——中国开发者大会</a>,同时后面也会抽空整理一下会议中讲到的内容，底层，细节与实现，敬请期待！</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftMain000.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftMain001.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><p>=================================================================================================================================</p><h2 id="Tuomas-Artman（Uber-移动架构和框架组负责人）"><a href="#Tuomas-Artman（Uber-移动架构和框架组负责人）" class="headerlink" title="Tuomas Artman（Uber 移动架构和框架组负责人）"></a>Tuomas Artman（Uber 移动架构和框架组负责人）</h2><p>Uber 使用 Swift 重写了 app，在这个分享中，Tuomas 会介绍如何在上百人的团队中使用 Swift 进行开发，并介绍 Uber 重写过程中遇到的各种问题和解决方法。<br>Tuomas 是 Uber 移动架构和框架组的负责人。在来湾区之前，他创立了一家芬兰知名的数字资讯公司，还在上海的一家公司工作过一年，开发游戏和多用户技术平台。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift100.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift101.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="Swift-with-hundreds-of-engineers"><a href="#Swift-with-hundreds-of-engineers" class="headerlink" title="Swift with hundreds of engineers"></a>Swift with hundreds of engineers</h3><pre><code>1. 使用swift重构Uber的过程中good，bad，ugly。 2. 对架构重新设计了，并且将他成为router-&gt;interaction-&gt;builder简称RIBs。适用于Android和iOS双平台。3. 重构后Uber的崩溃率降到了0.01%，这确实是一个非常理想的数据。4. binary size关于Uber包的大小。5. 关于如何缩短Uber的编译时间6. 最后聊了一下unit test。﻿</code></pre><p>=================================================================================================================================</p><h2 id="Sam-Davies（RayWenderlich-CTO）"><a href="#Sam-Davies（RayWenderlich-CTO）" class="headerlink" title="Sam Davies（RayWenderlich CTO）"></a>Sam Davies（RayWenderlich CTO）</h2><p>从基础的 NSOperation 一直到 Grand Central Dispatch，彻底讲明白 iOS 并发。此外还会涉及一些高级内容，比如 dispatch group 和线程安全。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift200.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift201.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="Concurrency-on-iOS"><a href="#Concurrency-on-iOS" class="headerlink" title="Concurrency on iOS"></a>Concurrency on iOS</h3><pre><code>1. 异步并发。2. 提出了开发中经常遇到的一些问题和解决方案3. 提到了反转优先级 </code></pre><p>=================================================================================================================================</p><h2 id="Igor-Jerkovic（前-Facebook-资深开发者）"><a href="#Igor-Jerkovic（前-Facebook-资深开发者）" class="headerlink" title="Igor Jerkovic（前 Facebook 资深开发者）"></a>Igor Jerkovic（前 Facebook 资深开发者）</h2><p>Igor 在 Facebook 的视频团队工作了五年，非常熟悉国外大公司的那一套理论。他会在这次分享中介绍如何提高开发效率和代码质量。</p><p>我很喜欢编程，也喜欢学习新东西，尝试不同的方法。2011-2013 年我在 Facebook 实习，负责开发 iOS 项目。2014 年我正式加入 Facebook，一直在视频团队工作到 2016年。现在我在 Bellabeat 工作，这是一家和健康相关的创业公司，在旧金山、深圳和萨格勒布都有办公室。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift300.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift301.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="iOS-development-efficiency-at-Facebook"><a href="#iOS-development-efficiency-at-Facebook" class="headerlink" title="iOS development efficiency at Facebook"></a>iOS development efficiency at Facebook</h3><pre><code>1. Facebook的开发流程，包括各种开发中的规范2. 介绍了很多实用的工具Buck...</code></pre><p>=================================================================================================================================</p><h2 id="Sommer-Panage（Chorus-Fitness-核心-iOS）"><a href="#Sommer-Panage（Chorus-Fitness-核心-iOS）" class="headerlink" title="Sommer Panage（Chorus Fitness 核心 iOS）"></a>Sommer Panage（Chorus Fitness 核心 iOS）</h2><p>在这个分享中，我会介绍无障碍和 VoiceOver。首先说明为什么无障碍支持很重要，然后通过一个权威的 iOS 应用了解你可以实现哪些无障碍功能。接着我会介绍 iOS 无障碍 API 以及如何对接 VoiceOver。最后，我会补充一些有趣的无障碍知识，除了支持 VoiceOver，我们还能做得更好。</p><p>Sommer Panage 目前是 Chorus Fitness 的核心 iOS 开发。在这之前，她做了两年 iOS freelancer，与此同时她还成为了一名马戏表演者和教练。更早的时候，她在 Twitter 和 Apple 的无障碍团队工作。Sommer 对心理学和计算机科学两个领域都有涉猎。在编写代码之余，她还会做绳索训练、高空秋千、倒立、跑步和抱石。你可以在 Twitter 上关注她，@sommer。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift400.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift401.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="From-Zero-to-Hero-Making-your-iOS-App-Accessible-to-VoiceOver-and-Beyond"><a href="#From-Zero-to-Hero-Making-your-iOS-App-Accessible-to-VoiceOver-and-Beyond" class="headerlink" title="From Zero to Hero: Making your iOS App Accessible to VoiceOver and Beyond"></a>From Zero to Hero: Making your iOS App Accessible to VoiceOver and Beyond</h3><pre><code>1. 主要是无障碍应用开发2. 讲了iOS中的accessibility programing，并演示了对失明者的交互与使用。3. 通过code演示了一些使用方式</code></pre><p>=================================================================================================================================</p><h2 id="Krunoslav-Zaher（RxSwift-框架作者）"><a href="#Krunoslav-Zaher（RxSwift-框架作者）" class="headerlink" title="Krunoslav Zaher（RxSwift 框架作者）"></a>Krunoslav Zaher（RxSwift 框架作者）</h2><p>我会介绍开发 Rx 的初衷、我对 Rx 的看法、Rx 的特点以及 Rx 和传统编程方式的区别。我还会介绍 Rx 的性能、不同设计模式的实现方式以及如何关联 Rx 和状态机。</p><p>在行业内摸爬滚打了 16 年。做过很多东西，增强现实引擎、BPM 系统、手机应用、机器人……最近在研究函数式编程和链式编程。白天我会帮准妈妈们听婴儿的心跳，晚上我会哄自己的宝贝女儿睡觉。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift500.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift501.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="Thinking-in-Rx-way"><a href="#Thinking-in-Rx-way" class="headerlink" title="Thinking in Rx way"></a>Thinking in Rx way</h3><pre><code>1. 主要是对rx的用法介绍。2. 提到了他写RX的初衷</code></pre><p>﻿</p><p>=================================================================================================================================</p><h2 id="Marius-Rackwitz（CocoaPods、Realm-核心开发者）"><a href="#Marius-Rackwitz（CocoaPods、Realm-核心开发者）" class="headerlink" title="Marius Rackwitz（CocoaPods、Realm 核心开发者）"></a>Marius Rackwitz（CocoaPods、Realm 核心开发者）</h2><p>Marius 从大学毕业开始就从事移动端和 web 应用开发。最近他开始专注移动端开发，尤其是 iOS 和 Objective-C，以及后起之秀 Swift。当然，作为 CocoaPods 核心成员，他也没有抛弃 Ruby。加入 Realm 之后，他在社区中更加活跃，参与了很多大会。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift600.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift601.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="JavaScript-for-Swift-Developer"><a href="#JavaScript-for-Swift-Developer" class="headerlink" title="JavaScript for Swift Developer"></a>JavaScript for Swift Developer</h3><pre><code>1. 这哥们整个演讲的过程中很是激情，但是却让在场大部分参会者归为叛徒的了（哈哈，开个玩笑）。2. JavaScript for Swift Developer主要是两者之间的不同。 </code></pre><p>=================================================================================================================================</p><h2 id="Kyle-Jessup（Perfect-框架作者，CTO）"><a href="#Kyle-Jessup（Perfect-框架作者，CTO）" class="headerlink" title="Kyle Jessup（Perfect 框架作者，CTO）"></a>Kyle Jessup（Perfect 框架作者，CTO）</h2><p>Perfect 作者，Lasso 编程语言（被苹果的子公司 Claris 收购）的服务端核心开发者。Kyle 自学能力很强，对 Swift、Java 和 C++ 都有深入了解。 小时候，Kyle 的父亲——一名曾在美国海军潜艇上服役的核工程师——送给他一台雅达利 800 个人电脑。从那时起，他就对技术产生兴趣，一直延续到现在。 Kyle 在德克萨斯的达拉斯出生，2015 年搬到加拿大，加入 PerfectlySoft 团队。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift700.JPG" alt="曹理鹏(iCocos)-梦工厂"> </p><h3 id="Swift作为后端开发相关"><a href="#Swift作为后端开发相关" class="headerlink" title="Swift作为后端开发相关"></a>Swift作为后端开发相关</h3><pre><code>1. 演示并分享了Swift实现后端开发的利弊2. 介绍了了Perfect ﻿</code></pre><p>=================================================================================================================================</p><h2 id="Saul-Mora（流利说-iOS-工程师，MagicalRecord-作者）"><a href="#Saul-Mora（流利说-iOS-工程师，MagicalRecord-作者）" class="headerlink" title="Saul Mora（流利说 iOS 工程师，MagicalRecord 作者）"></a>Saul Mora（流利说 iOS 工程师，MagicalRecord 作者）</h2><p>从上古时代开始接触 iOS，熟悉手动内存管理、编译器宏、pthread 和 头文件。Saul Mora 为了表达对编程前辈的尊重，在 Swift 中使用带可选变量的 Nib 编写 UI。掌握了 Objective C 之后，Saul 开始环游世界，进行历练。为了应对前方的算法挑战，Saul 积极拥抱 Swift。最近，Saul 生活在现代中国的核心城市——上海。他在流利说寺修行，开发这款优秀的 app，帮助中国用户学习英语。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift800.JPG" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/OneDay/Swift801.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="Building-Confidence-Testing-iOS-applications"><a href="#Building-Confidence-Testing-iOS-applications" class="headerlink" title="Building Confidence: Testing iOS applications"></a>Building Confidence: Testing iOS applications</h3><pre><code>1. 以一个很滑稽很有乔布斯风格的开场吸引住了在场的参会者2. 分析并深入讲解了测试的重要性和原则</code></pre><p>=============================================================================</p><h2 id="第一天尾声…"><a href="#第一天尾声…" class="headerlink" title="第一天尾声…"></a>第一天尾声…</h2><p>第一天的会议也就这样结束了，整个会议中大家谈论最多的问题就是关于英语的能力，这个后面会有相关的文章详细说明！</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/iCocosImages/Swift/Main/SwiftMain002.JPG" alt="曹理鹏(iCocos)-梦工厂"> </p>]]></content>
      
      <categories>
          
          <category> 2017@Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 2017@Swift——中国开发者大会（第一天） </tag>
            
            <tag> 大会 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GC机制中GC算法</title>
      <link href="/2017/03/22/GC%E6%9C%BA%E5%88%B6%E4%B8%ADGC%E7%AE%97%E6%B3%95/"/>
      <url>/2017/03/22/GC%E6%9C%BA%E5%88%B6%E4%B8%ADGC%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="垃圾回收机制-garbage-collection"><a href="#垃圾回收机制-garbage-collection" class="headerlink" title="垃圾回收机制(garbage collection)"></a>垃圾回收机制(garbage collection)</h2><p>在高级语言中有个很重要的机制叫做垃圾回收(gc)，高级语言不需要手动释放变量，是由语言本身来判断什么时候释放某个变量，而我们需要了解某个变量什么时候被语言释放(回收)了。</p><blockquote><p>在PHP中没有任何变量指向一个对象时，这个对象就成了垃圾，PHP会将其在内存中销毁，这就是PHP的垃圾回收机制，防止内存溢出</p></blockquote><a id="more"></a><h3 id="一、引用计数"><a href="#一、引用计数" class="headerlink" title="一、引用计数"></a>一、引用计数</h3><p>我们知道，PHP变量是存在一个叫zval的变量容器里面，zval有两个变量，一个是<code>is_ref</code>来标识这个变量是否属于引用，一个是<code>refcount</code>用来统计指向这个变量容器的变量的个数</p><p>如下例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $a = &quot;String&quot;;</span><br><span class="line">    xdebug_debug_zval(&apos;a&apos;);</span><br><span class="line">    </span><br><span class="line">#       输出结果</span><br><span class="line">#       a: (refcount=1, is_ref=0)=&apos;String&apos;</span><br><span class="line"></span><br><span class="line">//  将$a赋给$b</span><br><span class="line">    $b = $a;</span><br><span class="line">    xdebug_debug_zval(&apos;a&apos;);</span><br><span class="line"></span><br><span class="line">#       输出结果</span><br><span class="line">#       a: (refcount=2, is_ref=0)=&apos;String&apos;</span><br><span class="line">//  此时我们可以看到refcount的值变为了2，也就是有两个变量指向了这个变量容器</span><br></pre></td></tr></table></figure><p>当变量不在指向变量容器，或者调用了unset（unset的真实含义并不是删除某个变量，而是让他不再指向某个变量容器）<code>refcount</code>的值就会减少</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $a = &quot;new string&quot;;</span><br><span class="line">    $c = $b = $a;</span><br><span class="line">    xdebug_debug_zval( &apos;a&apos; );</span><br><span class="line">    unset( $b, $c );</span><br><span class="line">    xdebug_debug_zval( &apos;a&apos; );</span><br><span class="line">    </span><br><span class="line">#       输出结果</span><br><span class="line">#       a: (refcount=3, is_ref=0)=&apos;new string&apos;</span><br><span class="line">#       a: (refcount=1, is_ref=0)=&apos;new string</span><br></pre></td></tr></table></figure><p>上面的例子只是简单的说明了字符串这种简单类型，PHP中array和Object这种复合类型的时候，就会稍微复杂一点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = array( &apos;meaning&apos; =&gt; &apos;life&apos;, &apos;number&apos; =&gt; 42 );</span><br><span class="line">xdebug_debug_zval( &apos;a&apos; );</span><br><span class="line"></span><br><span class="line">#       输出结果</span><br><span class="line">a: (refcount=1, is_ref=0)=array (</span><br><span class="line">   &apos;meaning&apos; =&gt; (refcount=1, is_ref=0)=&apos;life&apos;,</span><br><span class="line">   &apos;number&apos; =&gt; (refcount=1, is_ref=0)=42</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这个时候会产生三个变量容器分别是a、meaning、number。我们在对程序做一些修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = array( &apos;meaning&apos; =&gt; &apos;life&apos;, &apos;number&apos; =&gt; 42 );</span><br><span class="line">$a[&apos;life&apos;] = $a[&apos;meaning&apos;];</span><br><span class="line">xdebug_debug_zval( &apos;a&apos; );</span><br><span class="line"></span><br><span class="line">#   输出结果</span><br><span class="line">a: (refcount=1, is_ref=0)=array (</span><br><span class="line">   &apos;meaning&apos; =&gt; (refcount=2, is_ref=0)=&apos;life&apos;,</span><br><span class="line">   &apos;number&apos; =&gt; (refcount=1, is_ref=0)=42,</span><br><span class="line">   &apos;life&apos; =&gt; (refcount=2, is_ref=0)=&apos;life&apos;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们可以看到life和meaning是指向的同一个变量容器，所以他们的refcount都是2</p><p>如果我们将一个数组元素添加给自己本身:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = array( &apos;one&apos; );</span><br><span class="line">$a[] = &amp;$a;</span><br><span class="line">xdebug_debug_zval( &apos;a&apos; );</span><br><span class="line"></span><br><span class="line">#       输出结果</span><br><span class="line">a: (refcount=2, is_ref=1)=array (</span><br><span class="line">   0 =&gt; (refcount=1, is_ref=0)=&apos;one&apos;,</span><br><span class="line">       1 =&gt; (refcount=2, is_ref=1)=...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们看到了a本身和第二个元素1的refcount为2，这样形成了一个递归循环，a的第二个元素指向了他自己。如果对$a进行unset操作，$a的变量容器引用次数减一，变成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(refcount=1, is_ref=1)=array (</span><br><span class="line">   0 =&gt; (refcount=1, is_ref=0)=&apos;one&apos;,</span><br><span class="line">   1 =&gt; (refcount=1, is_ref=1)=...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>尽管没有变量指向这个容器，由于他自己的第二个元素始终指向他本身，就没有办法回收这个变量容器，造成了内存泄露</p><h3 id="二、回收周期-Collecting-Cycles"><a href="#二、回收周期-Collecting-Cycles" class="headerlink" title="二、回收周期(Collecting Cycles)"></a>二、回收周期(Collecting Cycles)</h3><p>我们可以从上面的例子看到，PHP的引用计数内存的机制，无法处理循环的引用内存泄露问题，在PHP5.3（或者是5.4）版本，使用了一种叫同步周期回收的算法，来处理这个内存泄露的问题。  </p><h5 id="这个算法的基础规则是："><a href="#这个算法的基础规则是：" class="headerlink" title="这个算法的基础规则是："></a>这个算法的基础规则是：</h5><blockquote><p>如果一个引用计数增加，它将继续被使用，当然就不再在垃圾中。如果引用计数减少到零，所在变量容器将被清除(free)。就是说，仅仅在引用计数减少到非零值时，才会产生垃圾周期(garbage cycle)。其次，在一个垃圾周期中，通过检查引用计数是否减1，并且检查哪些变量容器的引用次数是零，来发现哪部分是垃圾。  </p></blockquote>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于事务入门</title>
      <link href="/2017/02/19/%E5%85%B3%E4%BA%8E%E4%BA%8B%E5%8A%A1%E5%85%A5%E9%97%A8/"/>
      <url>/2017/02/19/%E5%85%B3%E4%BA%8E%E4%BA%8B%E5%8A%A1%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h3 id="一、事务的属性ACID"><a href="#一、事务的属性ACID" class="headerlink" title="一、事务的属性ACID"></a>一、事务的属性ACID</h3><ol><li>原子性(atomicity):事务是一个原子操作单元，要么全部执行，要么全部都不执行</li><li>一致性(consistent): 在事务开始和完成时，数据都必须保持一致性。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。</li><li>隔离性(lsolation): 数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的独立环境执行。这意味着事务处理过程中的中间状态对外部是不可见的。</li><li>持久性(Durable): 事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</li></ol><a id="more"></a><p>###二、并发事务带来的问题</p><h5 id="1-更新丢失"><a href="#1-更新丢失" class="headerlink" title="1.更新丢失"></a>1.更新丢失</h5><p>当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题－－最后的更新覆盖了由其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖另一个编辑人员所做的更改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题。</p><h5 id="2-脏读"><a href="#2-脏读" class="headerlink" title="2.脏读"></a>2.脏读</h5><p>一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做”脏读”。</p><h5 id="3-不可重复读"><a href="#3-不可重复读" class="headerlink" title="3.不可重复读"></a>3.不可重复读</h5><p>不可重复读（Non-Repeatable Reads）：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。</p><h5 id="4-幻读"><a href="#4-幻读" class="headerlink" title="4.幻读"></a>4.幻读</h5><p>一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。</p><p>###三、事务的隔离级别</p><h5 id="1-读取未提交的内容-Read-Uncommitted"><a href="#1-读取未提交的内容-Read-Uncommitted" class="headerlink" title="1.读取未提交的内容(Read Uncommitted)"></a>1.读取未提交的内容(Read Uncommitted)</h5><blockquote><p>(1)所有事务都可以看到其他未提交事务的执行结果</p></blockquote><blockquote><p>(2)该隔离级别引发的问题就是脏读：读取到了未提交的数据</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#首先，修改隔离级别</span><br><span class="line">set tx_isolation=&apos;READ-UNCOMMITTED&apos;;</span><br><span class="line">select @@tx_isolation;</span><br><span class="line">+------------------+</span><br><span class="line">| @@tx_isolation   |</span><br><span class="line">+------------------+</span><br><span class="line">| READ-UNCOMMITTED |</span><br><span class="line">+------------------+</span><br><span class="line">#事务A：启动一个事务</span><br><span class="line">start transaction;</span><br><span class="line">select * from tx;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | num  |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |    1 |</span><br><span class="line">|    2 |    2 |</span><br><span class="line">|    3 |    3 |</span><br><span class="line">+------+------+</span><br><span class="line">#事务B：也启动一个事务(那么两个事务交叉了)</span><br><span class="line">       在事务B中执行更新语句，且不提交</span><br><span class="line">start transaction;</span><br><span class="line">update tx set num=10 where id=1;</span><br><span class="line">select * from tx;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | num  |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |   10 |</span><br><span class="line">|    2 |    2 |</span><br><span class="line">|    3 |    3 |</span><br><span class="line">+------+------+</span><br><span class="line">#事务A：那么这时候事务A能看到这个更新了的数据吗?</span><br><span class="line">select * from tx;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | num  |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |   10 |   ---&gt;可以看到！说明我们读到了事务B还没有提交的数据</span><br><span class="line">|    2 |    2 |</span><br><span class="line">|    3 |    3 |</span><br><span class="line">+------+------+</span><br><span class="line">#事务B：事务B回滚,仍然未提交</span><br><span class="line">rollback;</span><br><span class="line">select * from tx;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | num  |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |    1 |</span><br><span class="line">|    2 |    2 |</span><br><span class="line">|    3 |    3 |</span><br><span class="line">+------+------+</span><br><span class="line">#事务A：在事务A里面看到的也是B没有提交的数据</span><br><span class="line">select * from tx;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | num  |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |    1 |      ---&gt;脏读意味着我在这个事务中(A中)，事务B虽然没有提交，但它任何一条数据变化我                             都可以看到！</span><br><span class="line">|    2 |    2 |</span><br><span class="line">|    3 |    3 |</span><br><span class="line">+------+------+</span><br></pre></td></tr></table></figure><h5 id="2-读取提交内容-Read-Committed"><a href="#2-读取提交内容-Read-Committed" class="headerlink" title="2.读取提交内容(Read Committed)"></a>2.读取提交内容(Read Committed)</h5><blockquote><p>它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。</p></blockquote><p>但是它出现的问题是：不可重复读，不可重复读意味着我们在同一个事务中执行完全相同的select语句看到的可能是完全不一样的结果。</p><p>导致这种情况的原因有：</p><ul><li>(1)有一个交叉的事务有新的commit，导致了数据的改变</li><li>（2）一个数据库被多个实例操作时，同一个事务的其他实例在该实例处理其间有可能会有新的commit</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#首先修改隔离级别</span><br><span class="line">set tx_isolation=&apos;read-committed&apos;;</span><br><span class="line">select @@tx_isolation;</span><br><span class="line">+----------------+</span><br><span class="line">| @@tx_isolation |</span><br><span class="line">+----------------+</span><br><span class="line">| READ-COMMITTED |</span><br><span class="line">+----------------+</span><br><span class="line">#事务A：启动一个事务</span><br><span class="line">start transaction;</span><br><span class="line">select * from tx;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | num  |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |    1 |</span><br><span class="line">|    2 |    2 |</span><br><span class="line">|    3 |    3 |</span><br><span class="line">+------+------+</span><br><span class="line">#事务B：也启动一个事务(那么两个事务交叉了)</span><br><span class="line">       在这事务中更新数据，且未提交</span><br><span class="line">start transaction;</span><br><span class="line">update tx set num=10 where id=1;</span><br><span class="line">select * from tx;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | num  |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |   10 |</span><br><span class="line">|    2 |    2 |</span><br><span class="line">|    3 |    3 |</span><br><span class="line">+------+------+</span><br><span class="line">#事务A：这个时候我们在事务A中能看到数据的变化吗?</span><br><span class="line">select * from tx; ---------------&gt;</span><br><span class="line">+------+------+                |</span><br><span class="line">| id   | num  |                |</span><br><span class="line">+------+------+                |</span><br><span class="line">|    1 |    1 |---&gt;并不能看到！  |</span><br><span class="line">|    2 |    2 |                |</span><br><span class="line">|    3 |    3 |                |</span><br><span class="line">+------+------+                |——&gt;相同的select语句，结果却不一样</span><br><span class="line">                               |</span><br><span class="line">#事务B：如果提交了事务B呢?        |</span><br><span class="line">commit;                        |</span><br><span class="line">                               |</span><br><span class="line">#事务A:                         |</span><br><span class="line">select * from tx; ---------------&gt;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | num  |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |   10 |---&gt;因为事务B已经提交了，所以在A中我们看到了数据变化</span><br><span class="line">|    2 |    2 |</span><br><span class="line">|    3 |    3 |</span><br><span class="line">+------+------+</span><br></pre></td></tr></table></figure><h5 id="3-可重读（Repeatable-Read）"><a href="#3-可重读（Repeatable-Read）" class="headerlink" title="3.可重读（Repeatable Read）"></a>3.可重读（Repeatable Read）</h5><ul><li>(1)这是MySQL的默认事务隔离级别</li><li>(2)它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行</li><li>(3)此级别可能出现的问题——幻读(Phantom Read)：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行</li><li>(4)InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#首先，更改隔离级别</span><br><span class="line">set tx_isolation=&apos;repeatable-read&apos;;</span><br><span class="line">select @@tx_isolation;</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br><span class="line"></span><br><span class="line">#事务A：启动一个事务</span><br><span class="line">start transaction;</span><br><span class="line">select * from tx;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | num  |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |    1 |</span><br><span class="line">|    2 |    2 |</span><br><span class="line">|    3 |    3 |</span><br><span class="line">+------+------+</span><br><span class="line"></span><br><span class="line">#事务B：开启一个新事务(那么这两个事务交叉了)</span><br><span class="line">       在事务B中更新数据，并提交</span><br><span class="line">start transaction;</span><br><span class="line">update tx set num=10 where id=1;</span><br><span class="line">select * from tx;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | num  |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |   10 |</span><br><span class="line">|    2 |    2 |</span><br><span class="line">|    3 |    3 |</span><br><span class="line">+------+------+</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line">#事务A：这时候即使事务B已经提交了,但A能不能看到数据变化？</span><br><span class="line">select * from tx;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | num  |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |    1 | ---&gt;还是看不到的！(这个级别2不一样，也说明级别3解决了不可重复读问题)</span><br><span class="line">|    2 |    2 |</span><br><span class="line">|    3 |    3 |</span><br><span class="line">+------+------+</span><br><span class="line"></span><br><span class="line">#事务A：只有当事务A也提交了，它才能够看到数据变化</span><br><span class="line">commit;</span><br><span class="line">select * from tx;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | num  |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |   10 |</span><br><span class="line">|    2 |    2 |</span><br><span class="line">|    3 |    3 |</span><br><span class="line">+------+------+</span><br></pre></td></tr></table></figure><h5 id="4-可串行化-Serializable"><a href="#4-可串行化-Serializable" class="headerlink" title="4.可串行化(Serializable)"></a>4.可串行化(Serializable)</h5><ul><li>(1)这是最高的隔离级别</li><li>(2)它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的数据行上加上共享锁。</li><li>(3)在这个级别，可能导致大量的超时现象和锁竞争</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#首先修改隔离界别</span><br><span class="line">set tx_isolation=&apos;serializable&apos;;</span><br><span class="line">select @@tx_isolation;</span><br><span class="line">+----------------+</span><br><span class="line">| @@tx_isolation |</span><br><span class="line">+----------------+</span><br><span class="line">| SERIALIZABLE   |</span><br><span class="line">+----------------+</span><br><span class="line"></span><br><span class="line">#事务A：开启一个新事务</span><br><span class="line">start transaction;</span><br><span class="line"></span><br><span class="line">#事务B：在A没有commit之前，这个交叉事务是不能更改数据的</span><br><span class="line">start transaction;</span><br><span class="line">insert tx values(&apos;4&apos;,&apos;4&apos;);</span><br><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br><span class="line">update tx set num=10 where id=1;</span><br><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL基本操作汇总</title>
      <link href="/2017/02/15/MySQL%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2017/02/15/MySQL%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>对于整型来说<code>TINYINT</code>、<code>SMALLINT</code>、<code>MEDIUMINT</code>、<code>INT</code>、<code>BIGINT</code>等<ul><li>指定长度是没有意义的，它不会限制值的范围，只会影响显示字符的个数，比如<code>int(10)</code> 如果不足十位的会补足0（通过zerofill属性来显示）。值得注意的是，如果字符少于位数则会补足0，如果超过了宽度则不受影响。</li></ul></li></ul><a id="more"></a><ul><li><p>对于实数类型来说<code>FLOAT</code>（四个字节）、<code>DOUBLE</code>（八个字节）、<code>DECIMAL</code>（可以存储比BIGINT还要大的整型，可以存储精确的小数，16字节，精度较高的运算一般用decimal）</p></li><li><p>字符串类型<code>VARCHAR</code>、<code>CHAR</code>、<code>TEXT</code>、<code>BLOB</code></p><ul><li>char的长度是固定的，最大为255个字符，而char的最大长度是255<em>每个字符占用的字节数，比如utf8编码就是255\</em>3,gbk就是255*2  </li><li>varchar代表变长，最大的长度为65535个字节，如果采用varchar的话需要用1-2个字节来存储长度信息（255个字节一下需要1个字节，超过255需要两个字节）。而varchar最大字符数也是根据编码来决定（注意：char和varchar后面跟的数字都是指字符数），如果是utf8编码，varchar最大字符数=65535/3约为21845个字符，如果是gbkvarchar最大字符数=65533/2约为32766个字符   </li><li>text和blob类型查询的时候会产生临时表，尽量不要使用</li></ul></li><li><p>日期和时间类型（尽量使用TIMESTAMP，比DATETIME空间效率高）</p></li></ul><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li>veresion();    //显示当前服务版本</li><li>now();     //显示当前时间</li><li>user();    //显示当前用户</li><li>concat(‘a’, ‘b’);     //字符链接</li><li>concat_ws(‘-‘, ‘a’, ‘b’); //使用指定分隔符连接</li><li>lower(‘MYSQL’) upper(‘mysql’) //大小写转换</li><li>left(‘mysql’, 2)  //左截取 right(‘mysql’, 2) //右截取</li><li>length(‘mysql’)   //获取字符串长度</li><li>replace(‘-my-sql’, ‘-‘, ‘+’)  //替换字符</li><li>substring(‘mysql’, 1 ,2)  //截取字符</li><li>date_format(‘2017-9-11’, ‘%Y-%m-%d’); //日期格式化</li><li>avg();    //平均值</li><li>count();  //总数</li><li>max(); min()   //最大值，最小值</li><li>sum();    //求和</li></ul><h3 id="常用数据库操作"><a href="#常用数据库操作" class="headerlink" title="常用数据库操作"></a>常用数据库操作</h3><h5 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1.创建数据库"></a>1.创建数据库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create &#123;database|schema&#125; [if not exists] db_name [default] character set [=] charset_name</span><br><span class="line">例：CREATE DATABASE test;</span><br></pre></td></tr></table></figure><h5 id="2-修改数据库"><a href="#2-修改数据库" class="headerlink" title="2.修改数据库"></a>2.修改数据库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter &#123;database|schema&#125; db_name [default] character set [=] charset_name</span><br><span class="line">例：ALTER DATABASE test CHARACTER SET utf8;</span><br></pre></td></tr></table></figure><h5 id="3-删除数据库"><a href="#3-删除数据库" class="headerlink" title="3.删除数据库"></a>3.删除数据库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drop &#123;database|schema&#125; [if exists] db_name</span><br><span class="line">例：DROP DATABASE test;</span><br></pre></td></tr></table></figure><h3 id="常用数据表操作"><a href="#常用数据表操作" class="headerlink" title="常用数据表操作"></a>常用数据表操作</h3><h5 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1.创建表"></a>1.创建表</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create table [if not exists] tbl_name(</span><br><span class="line">    age tinyint(2) unsigned not null auto_increment primary key</span><br><span class="line">);</span><br><span class="line">例：CREATE TABLE user(</span><br><span class="line">    id INT(10) UNSIGNED AUTO_INCREMENT PRIMARY KEY,//主键自增</span><br><span class="line">    name VARCHAR(20) NOT NULL UNIQUE KEY,//唯一</span><br><span class="line">    price DECIMAL(8,2) UNSIGNED DEFAULT 0.00,//默认</span><br><span class="line">    cid INT(10) UNSIGNED,</span><br><span class="line">    KEY cid(cid),</span><br><span class="line">    FOREIGN KEY (cid) REFERENCES cate (id) ON DELETE CASCADE//外键 （删除时执行CASCADE）</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><h5 id="2-查看表结构"><a href="#2-查看表结构" class="headerlink" title="2.查看表结构"></a>2.查看表结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show colums from tbl_name;</span><br><span class="line">例：SHOW COLUMUNS FROM user</span><br></pre></td></tr></table></figure><h5 id="3-修改表结构"><a href="#3-修改表结构" class="headerlink" title="3. 修改表结构"></a>3. 修改表结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alter table tbl_name op[add|drop|modify] [column] (col_name column_definition,..);</span><br><span class="line">例：</span><br><span class="line">ALTER TABLE user ADD num INT(10) UNSIGNED, time INT(10) UNSIGNED;  // 添加字段</span><br><span class="line">ALTER TABLE user DROP num,DROP time;    // 删除字段</span><br></pre></td></tr></table></figure><h5 id="4-插入"><a href="#4-插入" class="headerlink" title="4.插入"></a>4.插入</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）insert [into] tbl_name [(col_name,..)] &#123;values|value&#125; (&#123;expr|default&#125;,...),(...),...;</span><br><span class="line">例：INSERT user (id,name,price) VALUES (DEFAULT,tom&apos;,20);</span><br></pre></td></tr></table></figure><h5 id="5-更新"><a href="#5-更新" class="headerlink" title="5.更新"></a>5.更新</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update tbl_name set col_name1=&#123;expr1|default&#125; [,col_name2=&#123;expr2|default&#125;].. [where where_condition]</span><br><span class="line">例：UPDATE user SET num = num + id;</span><br></pre></td></tr></table></figure><h5 id="6-删除"><a href="#6-删除" class="headerlink" title="6.删除"></a>6.删除</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete from tbl_name [where where_condition]</span><br><span class="line">例：DELETE FROM user WHERE id=3;</span><br></pre></td></tr></table></figure><h3 id="约束性"><a href="#约束性" class="headerlink" title="约束性"></a>约束性</h3><h5 id="1-主键约束：primary-key"><a href="#1-主键约束：primary-key" class="headerlink" title="(1)主键约束：primary key"></a>(1)主键约束：primary key</h5><ol><li>每个表只存在一个</li><li>保证记录的唯一性</li><li>自动为not null</li><li>添加了主键约束</li></ol><h5 id="2-唯一约束：-unique-key"><a href="#2-唯一约束：-unique-key" class="headerlink" title="(2)唯一约束： unique key"></a>(2)唯一约束： unique key</h5><ol><li>每个表可以存在多个</li><li>保证记录的唯一性</li><li>可以存一个null</li><li>添加了唯一约束</li></ol><h5 id="3-默认约束：default"><a href="#3-默认约束：default" class="headerlink" title="(3)默认约束：default"></a>(3)默认约束：default</h5><ol><li>给列添加了默认值</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">ALTER TABLE user ALTER num SET DEFAULT 0;</span><br><span class="line">ALTER TABLE user ALTER num DROP DEFAULT;</span><br></pre></td></tr></table></figure><h5 id="4-非空约束"><a href="#4-非空约束" class="headerlink" title="(4)非空约束"></a>(4)非空约束</h5><h5 id="5-外键约束"><a href="#5-外键约束" class="headerlink" title="(5)外键约束"></a>(5)外键约束</h5><ol><li>保证了数据的一致性，实现了1对1,1对多的关系</li><li>cascade：从父表中删除或更新且自动删除或更新子表中的匹配行</li><li>set nul： 从父表删除或更新并设置子表中的外键列为null。如果使用该选项，必须保证子表没有指定not null</li><li>restrict：拒绝对父表的删除或更新操作</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">添加外键约束：</span><br><span class="line"> alter table tbl_name add [constraint [symbol]] foreign key [index_name] (index_col_name,...) reference_definition</span><br><span class="line"> 例：ALTER TABLE user ADD FOREIGN KEY (cid) REFERENCES cate (id)</span><br><span class="line"> 删除外键约束：</span><br><span class="line"> alter table tbl_name drop foreign key symbol</span><br><span class="line">  例：ALTER TABLE user DROP FOREIGN KEY cid;</span><br></pre></td></tr></table></figure><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><blockquote><p>嵌套在内部，始终出现在括号内;</p></blockquote><p>可以包含多个关键字或条件，如distinct，group by，order by，limit，函数等;<br>外层可以是：select，insert，update，set</p><h5 id="1-比较运算符-gt-lt-lt-gt-lt-gt"><a href="#1-比较运算符-gt-lt-lt-gt-lt-gt" class="headerlink" title="1.比较运算符:=,&gt;,&lt;,&lt;=,&gt;=,&lt;&gt;"></a>1.比较运算符:=,&gt;,&lt;,&lt;=,&gt;=,&lt;&gt;</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 where col_name1 &gt;= ANY (select col_name2 from t2);</span><br><span class="line">(1)any:符合任意一个</span><br><span class="line">(2)all:符合所有</span><br></pre></td></tr></table></figure><h5 id="2-（not）in-exists"><a href="#2-（not）in-exists" class="headerlink" title="2.（not）in/exists"></a>2.（not）in/exists</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 where col_name1 NOT IN ALL (select col_name2 from t2);</span><br></pre></td></tr></table></figure><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><h5 id="内连接（inner-join），左连接（left-join），-右连接（right-join）-全连接（full-join），-交叉连接（across-join）"><a href="#内连接（inner-join），左连接（left-join），-右连接（right-join）-全连接（full-join），-交叉连接（across-join）" class="headerlink" title="内连接（inner join），左连接（left join）， 右连接（right join）,全连接（full join）， 交叉连接（across join）"></a>内连接（inner join），左连接（left join）， 右连接（right join）,全连接（full join）， 交叉连接（across join）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">现有两张表A、B</span><br><span class="line">表A</span><br><span class="line">id   name  </span><br><span class="line">1    张</span><br><span class="line">2    李</span><br><span class="line">3    王</span><br><span class="line"></span><br><span class="line">表B</span><br><span class="line">id   address   A_id</span><br><span class="line">1    北京      1</span><br><span class="line">2    上海      3</span><br><span class="line">3    南京      10</span><br><span class="line"></span><br><span class="line">**************left join**********</span><br><span class="line">SELECT A.name, B.address</span><br><span class="line">FROM A</span><br><span class="line">LEFT JOIN B ON A.id = B.A_id </span><br><span class="line">结果是：</span><br><span class="line">name     address</span><br><span class="line">张     北京</span><br><span class="line">李     NULL</span><br><span class="line">王     上海</span><br><span class="line"></span><br><span class="line">可以看到A表（左边的表）的所有行都显示出来了，B表中没有匹配到的行是NULL值</span><br><span class="line"></span><br><span class="line">************right join***********</span><br><span class="line">SELECT A.name, B.address</span><br><span class="line">FROM A</span><br><span class="line">RIGHT JOIN B ON A.id = B.A_id</span><br><span class="line">结果是：</span><br><span class="line">name     address</span><br><span class="line">张     北京</span><br><span class="line">王     上海</span><br><span class="line">NULL     南京</span><br><span class="line">与left join相反，B表（右边的表）中的行全显示出来，A表中匹配不到的行显示NULL</span><br><span class="line"></span><br><span class="line">**********inner join************</span><br><span class="line">select A.name,B.address from A </span><br><span class="line">inner join B</span><br><span class="line">on A.id = B.A_id</span><br><span class="line">结果是：</span><br><span class="line">name     address</span><br><span class="line">张     北京</span><br><span class="line">王     上海</span><br><span class="line"></span><br><span class="line">内连接等价于：</span><br><span class="line">SELECT A.name, B.address</span><br><span class="line">FROM A, B</span><br><span class="line">WHERE A.id = B.A_id</span><br><span class="line"></span><br><span class="line">内连接只返回A、B两表都有的行，相当于A、B的交集</span><br><span class="line"></span><br><span class="line">*********full join**********</span><br><span class="line">全外连接返回参与连接的两个数据集合中的全部数据，无论它们是否具有与之</span><br><span class="line">相匹配的行。在功能上，它等价于对这两个数据集合分别进行左外连接和右外</span><br><span class="line">连接，然后再使用消去重复行的并操作将上述两个结果集合并为一个结果集</span><br><span class="line"></span><br><span class="line">select * from A </span><br><span class="line">full join B</span><br><span class="line">结果是：</span><br><span class="line">id     name     id     address A_id</span><br><span class="line">1     张     1     北京     1</span><br><span class="line">2     李     1     北京     1</span><br><span class="line">3     王     1     北京     1</span><br><span class="line">1     张     2     上海     3</span><br><span class="line">2     李     2     上海     3</span><br><span class="line">3     王     2     上海     3</span><br><span class="line">1     张     3     南京     10</span><br><span class="line">2     李     3     南京     10</span><br><span class="line">3     王     3     南京     10</span><br><span class="line"></span><br><span class="line">*********across join***********</span><br><span class="line">返回笛卡尔积，A*B</span><br><span class="line">SELECT * FROM A</span><br><span class="line">CROSS JOIN B</span><br><span class="line">结果是：</span><br><span class="line">id     name     id     address A_id</span><br><span class="line">1     张     1     北京     1</span><br><span class="line">2     李     1     北京     1</span><br><span class="line">3     王     1     北京     1</span><br><span class="line">1     张     2     上海     3</span><br><span class="line">2     李     2     上海     3</span><br><span class="line">3     王     2     上海     3</span><br><span class="line">1     张     3     南京     10</span><br><span class="line">2     李     3     南京     10</span><br><span class="line">3     王     3     南京     10</span><br><span class="line">等价于sql：</span><br><span class="line">select * from A,B</span><br></pre></td></tr></table></figure><h5 id="联合查询（union与union-all）"><a href="#联合查询（union与union-all）" class="headerlink" title="联合查询（union与union all）"></a>联合查询（union与union all）</h5><blockquote><p>把多个结果集集中在一起</p></blockquote>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nginx基本使用笔记</title>
      <link href="/2017/01/04/Nginx%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/01/04/Nginx%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="1-常见操作"><a href="#1-常见操作" class="headerlink" title="1.常见操作"></a>1.常见操作</h3><pre><code>`nginx -s signal`</code></pre><p>signal的值可以是：</p><ul><li>stop 快速关机</li><li>quit 正常关机</li><li>reload 重新加载配置文件</li><li>reopen 重新打开日志文件</li></ul><a id="more"></a><h3 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2.配置文件"></a>2.配置文件</h3><p>nginx是由模块组成的，这些模块在配置文件中又有指定的指令。 指令被分成简单指令和块指令。简单指令包括名称和用空格分割的参数以及用来结尾的分号(;)。 一个块指令和简单指令有相同的结构，但是它使用大括号({and})来包围一系列说明来替代使用分号作为结尾。</p><blockquote><p>放在配置文件最外面的指令的称之为主文，<code>event</code>,<code>http</code>指令在主文中；<code>server</code>在<code>http</code>中， <code>location</code>在<code>server</code>中。</p></blockquote><h3 id="3-静态服务"><a href="#3-静态服务" class="headerlink" title="3.静态服务"></a>3.静态服务</h3><p>Web服务器一个重要的任务就是提供文件（如图像或者静态html页面）。 根据需求，你将实现一个例子，文件被本地不同的目录服务着，如<code>/data/www</code> 包含html文件，<code>/data/images</code> 包含图片。这需要编辑配置文件，在<code>http</code>块中设置<code>server</code>块。</p><ul><li><p>首先，创建<code>/data/www</code> 目录并放置index.html文件（文件中可以是任意内容）。 然后创建<code>/data/images</code>目录并放置一些图片。</p></li><li><p>接下来，打开配置文件。默认的配置文件已经包含了几个server块的例子，大多数都被注释掉了。 现在注释掉所有的块，并开始一个新的server块。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，配置文件中包含多个server块，它们之间以监听的端口号和server name来区分。 一旦nginx决定了哪个server处理请求，它测试在请求的对server块内定义的位置指令的参数头中指定的URI。</p><h5 id="添加location到server中"><a href="#添加location到server中" class="headerlink" title="添加location到server中"></a>添加location到server中</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root /data/www;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与请求的URI相比，location块指定了“/”前缀。为了匹配请求，该URI会被添加到root指令指定的路径中， 即，到/data/www，在本地文件系统中组成请求文件的路径。如果有多个匹配的location块，nginx会选择前缀最长的。 上面的location块提供了最短的前缀，如果其他的location块匹配失败，这个location块就会被使用。</p><h5 id="现在来添加第二个location"><a href="#现在来添加第二个location" class="headerlink" title="现在来添加第二个location:"></a>现在来添加第二个location:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /images/ &#123;</span><br><span class="line">    root /data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它与带/images/的请求请求匹配。（location / ，当然也匹配，除非有更短的前缀。）</p><p>#####现在server中是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root /data/www;</span><br><span class="line">    &#125;</span><br><span class="line">    location /images/ &#123;</span><br><span class="line">        root /data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启配置文件，让配置生效 <code>nginx -s reload</code></p><blockquote><p>这已经是一个可以工作的服务器配置文件，它监听的是80端口，可在本地通过<code>http://localhost/</code>访问。 响应带<code>/images/</code>的URI路由请求时，服务器将会从<code>/data/images</code>目录发送文件。 例如，响应 <code>http://localhost/images/example.png</code> 路由请求，nginx将会发送<code>/data/images/example.png</code> 文件。如果这个文件不存在，nginx将会发出404错误的响应。不带<code>/images/</code>的URIs请求将会映射到<code>/data/www</code>目录。 例如，为了响应<code>http://localhost/some/example.html</code>请求，nginx将会发送<code>/data/www/some/example.html</code>文件。</p></blockquote><h3 id="3-代理服务器"><a href="#3-代理服务器" class="headerlink" title="3.代理服务器"></a>3.代理服务器</h3><p>服务器A接受到请求后，将请求转发给其他的服务器B，从服务器B处获得响应，并将取得的相应返回给客户端，服务器B则是服务器A的代理服务器</p><p>首先，我们新增一个server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    root /data/up1;</span><br><span class="line">    location / &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个简单的server块，监听8080端口（此前，listen指令没有被提起是由于已经使用了标准的80端口），并将所有的请求 映射到本地文件系统的/data/up1目录。创建这个目录，并将index.html文件放置其中。注意root指令已经被放置在server环境中。 当location块被选中服务请求时，root指令就会被使用，当然不包括自己的root指令。</p><p>修改第一个location块，放置<code>proxy_pass</code>指令与协议、名称和参数中指定的代理服务器端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:8080;</span><br><span class="line">    &#125;</span><br><span class="line">    location /images/ &#123;</span><br><span class="line">        root /data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改第二个location块，它目前映射所有带/images/前缀的请求到/data/images 目录下的文件，是为了使其符合典型的文件扩展的图像请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.(gif|jpg|png)$ &#123;</span><br><span class="line">    root /data/images;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>该参数是一个正则表达式，匹配所有.gif,.jpg,.png 结尾的路由。正则表达式应该优于～。相应的请求都会被映射到 /data/images目录。</p></blockquote><p>当nginx选择一个location块服务一个请求时，它首先检查location指令的指定前缀，记住location最长的前缀， 然后检查正则表达式。如果有一个匹配的正则表达式，nginx会挑选location块，否则它会选择之前的。<br>因此代理服务器的配置文件应该是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:8080/;</span><br><span class="line">    &#125;</span><br><span class="line">    location ~ \.(gif|jpg|png)$ &#123;</span><br><span class="line">        root /data/images;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此服务器会筛选出以.gif,.jpg,.png 结尾的请求，并将他们映射到/data/images目录下(通过添加URI到root指令的参数上)， 然后通过所有其它请求到代理服务器配置上</p><pre><code>`nginx -s reload` 重启配置使更改生效</code></pre><h3 id="4-FastCGI代理"><a href="#4-FastCGI代理" class="headerlink" title="4. FastCGI代理"></a>4. FastCGI代理</h3><p>nginx可用于路由请求FastCGI服务器，FastCGI服务器运行各种不同的框架和编程语言，如PHP，建立的应用。</p><blockquote><p>最常用与 FastCGI server工作的nginx配置，用fastcgi_pass指令替代了proxy_pass指令，并设置fastcgi_param 参数传递给FastCGI server。</p></blockquote><p>假设FastCGI server通过localhost:9000可以访问。 以上一节代理配置作为基础，用fastcgi_pass指令替换proxy_pass指令，并修改参数为localhost:9000。在PHP中， SCRIPT_FILENAME参数用来确定脚本名，QUERY_STRING参数用来传递请求参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    location / &#123;</span><br><span class="line">        fastcgi_pass  localhost:9000;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">        fastcgi_param QUERY_STRING    $query_string;</span><br><span class="line">    &#125;</span><br><span class="line">    location ~ \.(gif|jpg|png)$ &#123;</span><br><span class="line">        root /data/images;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nginx与PHP通信"><a href="#nginx与PHP通信" class="headerlink" title="nginx与PHP通信"></a>nginx与PHP通信</h2><p>首先我们先简单的看一份nginx server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80 default_server;</span><br><span class="line">    index index.php;</span><br><span class="line">    root /home/work/</span><br><span class="line">    </span><br><span class="line">    location ~[^/]\.php(/l$)</span><br><span class="line">    &#123;</span><br><span class="line">        fastcgi_pass unix:/tmp/php-cgi.sock;</span><br><span class="line">        fastcgi_index index.php;</span><br><span class="line">        include fastcgi.conf;</span><br><span class="line">    &#125;</span><br><span class="line">    access_log /home/work/logs/default.log;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CGI是通用网关协议，FastCGI则是一种常住进程的CGI模式程序。我们所熟知的PHP-FPM会通过用户配置来管理一批FastCGI进程，例如在PHP-FPM管理下的某个FastCGI进程挂了，PHP-FPM会根据用户配置来看是否要重启补全，PHP-FPM更像是管理器，而真正衔接Nginx与PHP的则是FastCGI进程。</p></blockquote><p>我们可以看到server中包含了<code>fastcgi.conf</code>，里面是一些fastcgi_param的配置项，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_param  QUERY_STRING       $query_string;</span><br><span class="line">fastcgi_param  REQUEST_METHOD     $request_method;</span><br><span class="line">fastcgi_param  CONTENT_TYPE       $content_type;</span><br><span class="line">fastcgi_param  CONTENT_LENGTH     $content_length;</span><br><span class="line"></span><br><span class="line">fastcgi_param  SCRIPT_NAME        $fastcgi_script_name;</span><br><span class="line">fastcgi_param  REQUEST_URI        $request_uri;</span><br><span class="line">fastcgi_param  DOCUMENT_URI       $document_uri;</span><br><span class="line">fastcgi_param  DOCUMENT_ROOT      $document_root;</span><br><span class="line">fastcgi_param  SERVER_PROTOCOL    $server_protocol;</span><br><span class="line">fastcgi_param  HTTPS              $https if_not_empty;</span><br><span class="line"></span><br><span class="line">fastcgi_param  GATEWAY_INTERFACE  CGI/1.1;</span><br><span class="line">fastcgi_param  SERVER_SOFTWARE    nginx/$nginx_version;</span><br><span class="line"></span><br><span class="line">fastcgi_param  REMOTE_ADDR        $remote_addr;</span><br><span class="line">fastcgi_param  REMOTE_PORT        $remote_port;</span><br><span class="line">fastcgi_param  SERVER_ADDR        $server_addr;</span><br><span class="line">fastcgi_param  SERVER_PORT        $server_port;</span><br><span class="line">fastcgi_param  SERVER_NAME        $server_name;</span><br><span class="line"></span><br><span class="line"># PHP only, required if PHP was built with --enable-force-cgi-redirect</span><br><span class="line">fastcgi_param  REDIRECT_STATUS    200;</span><br><span class="line">fastcgi_param  PHP_VALUE  &quot;open_basedir=$document_root:/usr/share/pear:/usr/share/php:/etc/phpMyAdmin:/tmp:/proc&quot;;</span><br></pre></td></tr></table></figure><p>fastcig_param中所声明的内容会传到php-fpm（或者其他fast-cgi server）所管理的fast-cgi进程。我们可以看到，fastcgi_param中都是一些服务器的信息，如remote_addr(访问用户的ip)等，他就可以把这些信息传递给后端程序，如PHP的$_SERVER</p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一步一步教你如何写开发文档</title>
      <link href="/2017/01/02/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E5%86%99%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/"/>
      <url>/2017/01/02/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E5%86%99%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/</url>
      <content type="html"><![CDATA[<p>你有没有遇到过，突然老板或者老大跟你说，你根据项目或者根据功能写一份开发文档，当时很开心的答应了，后来想想，既然懵了。</p><p>开发文档是什么鬼？写了这么多年代码都没写过什么开发文档，最多也就只是产品的需求文档，说明文档，代码的注释与规范文档，或者说过苹果的开发文档，因为之前刚好写过一次很简单的，最近公司又开始要写上面开发文档了，而且发现确实很多同学都不会，我在想，我是不是该做点什么……。</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>App开发过程中的文档分为很多种，比如最常见的就是官方的开发文档，这种比较倾向代码和接口，但是你可能还见过或者听过其他文档。</p><p>比如，这里根据个人理解整理了几个。</p><ol><li>开发文档</li><li>需求(原型)文档</li><li>需求(说明)文档</li><li>技术方案文档</li><li>Bug修复文档</li><li>注释文档</li><li>代码与UI规范文档</li><li>性能优化文档</li></ol><p>是不是有点晕了，哪有这么多鬼，其实按照之前的习惯，我都是一份开发文档就够了，基本上包含上面的东西，只是看你怎么细分。</p><h3 id="开发文档概述"><a href="#开发文档概述" class="headerlink" title="开发文档概述"></a>开发文档概述</h3><p>实际开发中如果真的遇到要写上面开发文档可以从下面几个角度写。</p><ul><li>一. 开发环境及工具</li><li>二. 项目或功能（需求）描述（最好有流程图或者UML）- 需求文档</li><li>三. 编写目的（用户特征和水平）</li><li>四. 项目或功能背景</li><li>五. 模块与关系</li><li>六. 类或术语说明</li><li>七. 参考资料（网络或公司内部资料，UI，原型，说明文档）</li><li>八. 项目进度预估</li><li>九. 难点预估（条件与限制）</li><li>十. 功能与所计划采用的技术 - 技术方案文档</li><li>十一. 用户界面与交互</li><li>十二. 软件（代码）接口 - 注释文档</li><li>十三. 通信（网络）接口 - 接口文档</li><li>十四. 问题与修复说明 - Bug修复文档</li><li>十五. 性能分析与优化</li></ul><p>当然也不是说这些全部要写，可以根据项目或者功能适当编写。</p><p>下面大概一个个的说明一些每一个步骤是什么意思，需要怎么写，这里主要以iOS开发中App开发文档为规范，并使用苹果最新的语言Swift作为唯一语言。</p><ul><li><p>一. 开发环境及工具</p><ul><li>Mac OX 10<ul><li>iPhone或者iPad 5+ 2+ 必须真机</li><li>iOS 8+</li><li>Xcode 8+</li><li>其他工具：Tower，cornerstone</li></ul></li></ul></li></ul><blockquote><p>主要指明开发在工具，开发平台，开发版本的支持。描述软件的运行环境，包括硬件平台、硬件要求、操作系统和版本，以及其他的软</p></blockquote><p>件或与其共存的应用程序等。</p><ul><li><p>二. 项目或功能（需求）描述（最好有流程图或者UML）- 需求文档</p><ul><li><p>顶层数据流图；</p></li><li><p>用例UseCase图；</p></li><li><p>系统流程图；</p></li><li><p>层次方框图。</p></li></ul></li></ul><blockquote><p>主要根据产品给出的需求结合原型进行描述，并适当给出相应的图。</p></blockquote><ul><li><p>三. 编写目的（用户特征和水平）</p><ul><li>描述最终用户应具有的受教育水平、工作经验及技术专长。</li></ul></li></ul><blockquote><p>次软件或者功能编写的目的，对项目，对用户，对公司有什么好处。</p></blockquote><ul><li><p>四. 项目或功能背景</p><ul><li><p>标识待开发软件产品的名称、代码；</p></li><li><p>列出本项目的任务提出者、项目负责人、系统分析员、系统设计员、程序设计员、程序员、资料员以及与本项目开展工作直接有关的人员和用户；</p></li><li><p>说明该软件产品与其他有关软件产品的相互关系。</p></li></ul></li></ul><blockquote><p>此项目或功能编写之前市面上的情况，公司和用户的情况</p></blockquote><ul><li>五. 模块与关系</li></ul><blockquote><p>项目或功能对应模块在位置，入口，和其他模块的关系</p></blockquote><ul><li>六. 类或术语说明</li></ul><blockquote><p>项目或功能对应类的说明，和开发中使用到的一些相关的术语的说明</p></blockquote><ul><li><p>七. 参考资料（网络或公司内部资料，UI，原型，说明文档）</p><ul><li><p>列举编写软件需求规格说明时所参考的资料，包括项目经核准的计划任务书、合同、引用的标准和规范、项目开发计划、需求规格说明、使用实例文档，以及相关产品的软件需求规格说明。</p></li><li><p>在这里应该给出详细的信息，包括标题、作者、版本号、发表日期、出版单位或资料来源。</p></li></ul></li></ul><blockquote><p>网络资料，尤其是苹果的，也可以群里或者博客，文章等。公司内部的UI，原型，说明，网络接口资料</p></blockquote><ul><li>八. 项目进度预估</li></ul><blockquote><p>预计从上面开始到指定的时间节点完成任务或者完成对应的部分</p></blockquote><ul><li>九. 难点预估（条件与限制）</li></ul><blockquote><p>其中考虑到或者可能会遇到什么技术或者实现难点</p></blockquote><ul><li><p>十. 功能与所计划采用的技术 - 技术方案文档</p><ul><li><p>将要采用的图形用户界面标准或产品系列的风格；</p></li><li><p>屏幕布局；</p></li><li><p>菜单布局；</p></li><li><p>输入输出格式；</p></li><li><p>错误信息显示格式；</p></li><li><p>建议采用RAD开发工具，    比如Visio，构造用户界面。</p></li></ul></li></ul><blockquote><p>根据项目或者功能需求，在代码层面所使用的技术或者实现方案，或者比如说ios中布局方式的使用。</p></blockquote><ul><li>十一. 用户界面与交互</li></ul><blockquote><p>根据用户界面和入口说明交互与使用步骤并</p></blockquote><ul><li>十二. 软件（代码）接口 - 注释文档</li></ul><blockquote><p>每一个方法和属性对应的注释，一般是私有的话使用private但是也要注释，公开的都会使用标准的注释说明，苹果有自带的快捷键（command+option+/），之前有个插件叫VVDocument</p></blockquote><ul><li>十三. 通信（网络）接口 - 接口文档</li></ul><blockquote><p>网络请求对应的说明包括对应的参数，字段和返回值，也可以是数据模型层对应的模型属性和方法的说明</p></blockquote><ul><li>十四. 问题与修复说明 - Bug修复文档</li></ul><blockquote><p>开发或者测试的过程中出现了什么比较重要的bug，不要什么bug都写上，然后说明解决的方案</p></blockquote><ul><li><p>十五. 性能分析与优化</p><ul><li><p>时间特性 </p><ul><li><p>响应时间；</p></li><li><p>更新处理时间；</p></li><li><p>数据转换与传输时间；</p></li><li><p>运行时间等。</p></li></ul></li><li><p>适应性</p><ul><li>在操作方式、运行环境、与其他软件的接口以及开发计划等发生变化时，软件的适应能力。</li></ul></li></ul></li></ul><blockquote><p>到此完成之后，根据实际需求和个人能力，个人理解分析项目或者功能那些地方需要进行优化一下，打算怎么去优化他。</p></blockquote><p>后期会继续完善(根据项目或功能整理一套完整的开发文档)…….</p><blockquote><p>注：这里是按照功能，并不是按照整个项目分，如果要写整个项目的开发文档也可以再根据功能细分。</p></blockquote>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 文档 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2016/09/22/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2016/09/22/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>系统安全</li><li>进程管理</li><li>用户管理</li><li>文件系统</li><li>网络测试</li><li>文件处理</li><li>压缩</li><li>定时任务（crontab）</li></ul><a id="more"></a><h3 id="系统安全"><a href="#系统安全" class="headerlink" title="系统安全"></a>系统安全</h3><ol><li>sudo</li><li>su</li><li>chmod</li><li>setfacl 对某个用户单独设置某个文件的权限</li></ol><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><ol><li>top</li><li>ps</li><li>kill -9强制杀死 -15正常杀死</li><li>pkill</li><li>killall</li></ol><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><ol><li>usermod 修改系统账户文件</li><li>useradd</li><li>groupadd</li><li>userdel</li></ol><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><ol><li>mount</li><li>umount</li><li>fsck</li><li>df</li><li>du</li></ol><h3 id="网络测试"><a href="#网络测试" class="headerlink" title="网络测试"></a>网络测试</h3><ol><li>netstat</li></ol><h3 id="文件查看"><a href="#文件查看" class="headerlink" title="文件查看"></a>文件查看</h3><ol><li>head</li><li>tail</li><li>less/more</li></ol><h3 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h3><ol><li>touch</li><li>unlink</li><li>rename</li><li>ln</li><li>cp</li></ol><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><ol><li>tar</li></ol><h3 id="定时任务（crontab）"><a href="#定时任务（crontab）" class="headerlink" title="定时任务（crontab）"></a>定时任务（crontab）</h3><ol><li>crontab的使用</li><li>at 命令  </li></ol>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux软件管理</title>
      <link href="/2016/09/07/Linux%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
      <url>/2016/09/07/Linux%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<p>包管理工具上，影响最大的两个系列，就是debian的dpkg包和Red Hat的rpm包两大系列。</p><ul><li>dpkg系的前端工具是apt，用于Debian系统及其衍生系统如Ubuntu系统，以及Ubuntu的衍生系统如LinuxMint。</li><li>rpm系的影响更广，主要有两大分支：</li><li>zypper：用于OpenSUSE系统。OpenSUSE上还有强大的yast2工具</li><li>yum：用于CentOS系统。</li><li>dnf：由于yum很久不维护，所以Fedora使用了yum的一个新的分支dnf</li></ul><a id="more"></a><h3 id="【1】软件包管理"><a href="#【1】软件包管理" class="headerlink" title="【1】软件包管理"></a>【1】软件包管理</h3><p>在系统管理中，软件包的管理是最重要的，是系统管理的基础的基础，只有我们学会软件包的管理才能谈得上其它的应用。 </p><h5 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h5><p>RPM是软件管理程序，提供软件的安装、升级、查询、反安装的功能。</p><ul><li>优点：<ul><li>a、安装方便，软件中所有数据都经过编译和打包</li><li>b、查询、升级、反安装方便</li></ul></li><li>缺点：<ul><li>a、缺乏灵活性</li><li>b、存在相依属性</li></ul></li></ul><h5 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h5><blockquote><p>rpm  参数   软件包</p></blockquote><pre><code>指令选项-i：安装。-U：升级安装，如果不存在也安装。-F：更新安装，如果不存在不安装。-v：查看信息。-h：有进度条。--replacepkgs：强制覆盖安装。 --nodeps：不考虑相依属性。 -q &lt;软件名&gt;：查询。-qa：查询所有。-ql &lt;软件名&gt;：列出软件的文件清单。-qi &lt;软件名&gt;：列出软件信息。-qf &lt;文件名&gt;：查询文件所属软件。-e &lt;软件名&gt;：删除软件。</code></pre><p>例子：</p><pre><code>rpm -ivh bind-9.3.6-4.P1.el5_4.2.i386.rpm#安装rpm -Uvh/Fvh bind-9.3.6-4.P1.el5_4.2.i386.rpm #升级安装rpm  -e  bind-9.3.6-4.P1.el5_4.2.i386 #删除软件包rpm -qpi *.rpm     #查看软件包里的内容rpm -qpl *.rpm  #查看软件包将会在系统里安装哪些部分rpm –qa   #列出所有被安装的rpm 软件包</code></pre><h3 id="【2】YUM"><a href="#【2】YUM" class="headerlink" title="【2】YUM"></a>【2】YUM</h3><p>yum = Yellow dog Updater, Modified主要功能是更方便的添加/删除/更新RPM包.它能自动解决包的倚赖性问题.</p><blockquote><p>它能便于管理大量系统的更新问题</p></blockquote><h5 id="yum特点"><a href="#yum特点" class="headerlink" title="yum特点"></a>yum特点</h5><ul><li>可以同时配置多个资源库(Repository)</li><li>简洁的配置文件(/etc/yum.conf)</li><li>自动解决增加或删除rpm包时遇到的倚赖性问题</li><li>使用方便</li><li>保持与RPM数据库的一致性</li></ul><h5 id="yum配置"><a href="#yum配置" class="headerlink" title="yum配置"></a>yum配置</h5><p>挂载光盘文件到硬盘</p><pre><code>mkdir –p /mnt/cdromchmod 777 /mntmount -t iso9660 /dev/cdrom /mnt/cdrom</code></pre><p>配置/etc/yum.repos.d/server.repo</p><pre><code>[cdrom]name=cdrombaseurl=file:///mnt/cdromenabled=1</code></pre><p>清除原有的yum信息</p><pre><code>[root@localhost ~]# yum clean all</code></pre><p>查看yum 信息</p><pre><code>[root@localhost ~]# yum list</code></pre><h5 id="创建本地YUM仓库"><a href="#创建本地YUM仓库" class="headerlink" title="创建本地YUM仓库"></a>创建本地YUM仓库</h5><ul><li>① 新建一个目录——该目录作为软件仓库，将光盘中的rpm包（位于Packages文件夹）保存到该目录下。</li><li>② 对该目录内的rpm软件包建立索引：createrepo -v /rpm-directory，创建该目录下的rpm包索引，索引创建完成后，会在该文件夹下出现一个repodata目录，里面保存了仓库索引信息。</li></ul><blockquote><p>注：第②步中的createrepo工具在默认情况下是没有安装的，需要自己手动安装（Packages中已包含createrepo安装包），安装方法如下：rpm -ivh createrepo-…….rpm。安装createrepo需要手动解决依赖关系。（createrepo工具主要用于收集目录中RPM包文件的头信息，以创建repodata软件仓库数据（经gzip压缩的xml文件））</p></blockquote><ul><li>③在/etc/yum.repos.d目录下 新建一个.repo文件，其中baseurl = file:///rpm-directory 绝对路径</li><li>④清理一下yum缓存yum clean all，列出所有的软件包yum list all，查看是否成功。</li></ul><h5 id="yum管理软件"><a href="#yum管理软件" class="headerlink" title="yum管理软件"></a>yum管理软件</h5><pre><code>yum  install –y   software   #安装软件yum  update  -y software    #更新软件yum  remove  -y  software   #删除软件yum  list     #列出资源库中特定的可以安装或更新以及已经安装的rpm包yum grouplist # 累出所有软件包群组yum groupinstall   ‘包群组名’ # 安装软件包群组yum groupremove  ‘包群组名yum  info    包名    #查看软件包信息yum search  包名 # 搜索yum clean all  #清除缓存</code></pre><h5 id="yum添加163源"><a href="#yum添加163源" class="headerlink" title="yum添加163源"></a>yum添加163源</h5><p>地址：</p><ul><li><a href="http://mirrors.163.com/.help/centos.html" target="_blank" rel="noopener">http://mirrors.163.com/.help/centos.html</a></li></ul><p>下载方式：</p><ul><li><a href="wget http://mirrors.163.com/.help/CentOS6-Base-163.repo">wget http://mirrors.163.com/.help/CentOS6-Base-163.repo</a></li></ul><h3 id="【3】apt-get"><a href="#【3】apt-get" class="headerlink" title="【3】apt-get"></a>【3】apt-get</h3><p>用Linux apt-get命令的第一步就是引入必需的软件库，Debian的软件库也就是所有Debian软件包的集合，它们存在互联网上的一些公共站点上。把它们的地址加入，apt-get就能搜索到我们想要的软件。/etc/apt/sources.list是存放这些地址列表的配置文件，其格式如下：</p><pre><code>deb [web或ftp地址] [发行版名字][main/contrib/non-free]</code></pre><p>我们常用的Ubuntu就是一个基于Debian的发行</p><pre><code>命令：apt-get update：在修改/etc/apt/sources.list或者/etc/apt/preferences之后运行该命令。此外您需要定期运行这一命令以确保您的软件包列表是最新的。apt-get install packagename：安装一个新软件包apt-get remove packagename：卸载一个已安装的软件包（保留配置文件）apt-get –purge remove packagename：卸载一个已安装的软件包（删除配置文件）apt-get autoclean apt：会把已装或已卸的软件都备份在硬盘上，所以如果需要空间的话，可以让这个命令来删除你已经删掉的软件apt-get clean：这个命令会把安装的软件的备份也删除，不过这样不会影响软件的使用的。apt-get upgrade：更新所有已安装的软件包apt-get dist-upgrade：将系统升级到新版本apt-get autoclean：定期运行这个命令来清除那些已经卸载的软件包的.deb文件。</code></pre>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS——Objective-C与Swift优缺点对比</title>
      <link href="/2016/05/19/iOS%E2%80%94%E2%80%94Objective-C%E4%B8%8ESwift%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94/"/>
      <url>/2016/05/19/iOS%E2%80%94%E2%80%94Objective-C%E4%B8%8ESwift%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94/</url>
      <content type="html"><![CDATA[<p>最近有个朋友（同事）在找工作，一起讨论关于面试过程中的面试题，有不少关于Objective-C的技术问题，尤其是关于一些技术的底层实现，当然这个在之前的文章中有整理.</p><p>其中有一个问题就是关于Objective-C和Swift区别，与优缺点的对比，由于我刚使用Swift实战开发并不久，过去三年多都都是搞Objective-C，所以对Swift和Objective-C优缺点还真没有多少简介，虽然网上也有不少相关的资料和回答，但是想想这个问题以后再很多打算或者还没有开始使用Swift的公司会被经常问到，所以就花了点时间整理一下……….</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Swift，苹果于2014年WWDC（苹果开发者大会）发布的新开发语言（已开源），可与Objective-C*共同运行于Mac OS和iOS平台，用于搭建基于苹果平台的应用程序。</p><h2 id="动态性"><a href="#动态性" class="headerlink" title="动态性"></a>动态性</h2><p>Swift 是一种强类型语言。类型静态，也就是说 Swift 的默认类型是非常安全的。</p><blockquote><ol><li>Swift 当中存在有这两个修饰符<code>@objc</code>和<code>@dynamic</code>，此外我们同样还可以访问NSObject。</li><li><code>@objc</code>将您的 Swift API 暴露给 Objective-C 运行时，但是它仍然不能保证编译器会尝试对其进行优化。</li><li>如果您真的想使用动态功能的话，就需要使用@dynamic。一旦您使用了@dynamic修饰符之后，就不需要添加<code>@objc</code>了，因为它已经隐含在其中。</li></ol></blockquote><h2 id="Swift比Objective-C有什么优势？"><a href="#Swift比Objective-C有什么优势？" class="headerlink" title="Swift比Objective-C有什么优势？"></a>Swift比Objective-C有什么优势？</h2><ol><li>Swift容易阅读，语法和文件结构简易化。</li><li>Swift更易于维护，文件分离后结构更清晰。</li><li>Swift更加安全，它是类型安全的语言。</li><li>Swift代码更少，简洁的语法，可以省去大量冗余代码</li><li>Swift速度更快，运算性能更高。</li></ol><h2 id="Swift目前存在的缺点"><a href="#Swift目前存在的缺点" class="headerlink" title="Swift目前存在的缺点"></a>Swift目前存在的缺点</h2><ol><li>版本不稳定，之前升级Swift3大动刀，苦了好多人，swift4目前还未知</li><li>使用人数比例偏低，目前还是OC的天下</li><li>社区的开源项目偏少，毕竟OC独大好多年，很多优秀的类库都不支持Swift，不过这种状况正在改变，现在有好多优秀的Swift的开源类库了</li><li>公司使用的比例不高，很多公司以稳为主，还是在使用OC开发，很少一些在进行混合开发，更少一些是纯Swift开发。</li><li>偶尔开发中遇到的一些问题，很难查找到相关资料，这是一个弊端。</li><li>纯Swift的运行时和OC有本质区别，一些OC中运行时的强大功能，在纯Swift中变无效了。</li><li>对于不支持Swift的一些第三方类库，如果非得使用，只能混合编程，利用桥接文件实现。</li></ol><h2 id="整体总结"><a href="#整体总结" class="headerlink" title="整体总结"></a>整体总结</h2><ul><li>String：<ul><li>Swift中String操作已经甩OC三百万条街</li></ul></li><li>泛型：<ul><li>Swift泛用性还是不够强，如果项目不止涉及常用的http啊xmpp啊之类的协议，而是要做一些SIP啊FFMPEG啊之类的干活，那明显是OC成熟得多</li></ul></li><li>Discriminated Union<ul><li>swift里的enum. 是静态语言独有的特性.</li></ul></li><li>安全：<ul><li>由于swift的strong static type system，编译器可帮你检查出更多问题，而不是在运行时突然boom，还有一个很牛逼的安全特性就是OptionalType。</li></ul></li><li>快速：    <ul><li>静态相对来说语言本身速度更快，swift编译期就能生成vtable，确定具体要调用的方法，比起oc的动态派发自然是更快，当然处理到与oc之间桥接部分，可能不一定比oc快</li></ul></li></ul><h2 id="细节使用区别"><a href="#细节使用区别" class="headerlink" title="细节使用区别"></a>细节使用区别</h2><ul><li>在 Swift 中没有了 main.m，@UIApplicationMain 是程序入口</li><li>swift不分.h和.m文件 ，一个类只有.swift一个文件，所以整体的文件数量比起OC有一定减少。</li><li>swift句尾不需要分号 ，除非你想在一行中写三行代码就加分号隔开。</li><li>在 Swift 中，一个类就是用一对 <code>{ }</code> 括起的，没有 @implementation 和 @end</li><li>swift数据类型都会自动判断 ， 只区分变量var 和常量let</li><li>强制类型转换格式不同   OC强转：<code>(int)a</code>      Swift强转：<code>Int(a)</code></li><li>关于BOOL类型更加严格 ，Swift不再是OC的非0就是真，而是true才是真false才是假</li><li>swift的 循环语句中必须加<code>{}</code>就算只有一行代码也必须要加</li><li>swift的switch语句后面可以跟各种数据类型了 ，如Int、字符串都行，并且里面不用写break（OC好像不能字符串）</li><li>swift  if后的括号可以省略: <code>if a&gt;b {}</code>，而OC里 if后面必须写括号。</li><li>swift打印  用<code>print(&quot;&quot;)</code>    打印变量时可以 <code>print(&quot;\(value)&quot;)</code>，不用像OC那样记很多<code>%@，d%</code>等。</li><li>Swift3的【Any】可以代表任何类型的值，无论是类、枚举、结构体还是任何其他Swift类型，这个对应OC中的【id】类型。</li><li>在 OC 中 <code>alloc / init</code>  对应<code>( )</code> </li><li>在 OC 中 alloc / initWithXXX 对应 (XXX: )</li><li>在 OC 中的类函数调用，在 Swift 中，直接使用 .</li><li>在 Swift 中，绝大多数可以省略 self.，建议一般不写，可以提高对语境的理解（闭包时会体会到）</li><li>在 OC 中的 枚举类型使用 UIButtonTypeContactAdd，而 Swift 中分开了，操作热键：回车<code>-&gt;</code> 向右 <code>-&gt;</code>.</li><li>Swift 中，枚举类型的前缀可以省略，如：<code>.ContactAdd</code>，但是：很多时候没有智能提示</li><li>监听方法，直接使用字符串引起</li></ul><h2 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h2><p>Objective-C中循环引用也是遇到比较多的，一不小心就会导致循环引用，甚至导致内存问题</p><h4 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h4><ul><li>[weak self]</li><li><p>self是可选项，如果self已经被释放，则为nil</p></li><li><p>[unowned self]</p></li><li>self不是可选项，如果self已经被释放，则出现野指针访问</li></ul><h4 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective-C"></a>Objective-C</h4><ul><li>__weak typeof(self) weakSelf;</li><li><p>如果self已经被释放，则为nil</p></li><li><p>__unsafe_unretained typeof(self) weakSelf;</p></li><li>如果self已经被释放，则出现野指针访问</li></ul><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>推荐几个Objective-C的框架</p><p><a href="http://www.jianshu.com/p/79d6a3a6a479" target="_blank" rel="noopener">FBRetainCycleDetector</a></p><p><a href="http://ios.jobbole.com/86719/" target="_blank" rel="noopener">PLeakSniffer</a></p><p><a href="http://www.jianshu.com/p/eb638ef69343" target="_blank" rel="noopener">MLeaksFinder</a></p>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> iOS——Objective-C与Swift优缺点对比 </tag>
            
            <tag> Objective-C与Swift优缺点对比 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS——App启动优化分析与总结</title>
      <link href="/2016/05/03/iOS%E2%80%94%E2%80%94App%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
      <url>/2016/05/03/iOS%E2%80%94%E2%80%94App%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>随着人们对App性能与实用要求越来越高，也随着大量iOS开发中的涌入，现如今已经不再是几年前会做简单App，然后开始开发，能写出一个可用功能的产品就可以了，于是，很多公司和开发者也开始关注和实战启动优化，因为App除了桌面Log，启动是也是夺得用户喜好最首要的条件，如果一个App每次启动都要几十秒甚至几分钟，你觉得你还会继续使用吗……</p><a id="more"></a><p>如果你对iOS开发中App的整个启动过程干兴趣，那么可以先看我之前分享的一个主题<br><a href="https://icocos.github.io/2017/06/28/iOS%E2%80%94%E2%80%94App%E6%95%B4%E4%B8%AA%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/">iOS——App整个启动过程分析 </a></p><p>当然关于启动优化，上面只是简单的提了一下，本文结合那篇文章进行详细分析</p><h2 id="启动优化准备"><a href="#启动优化准备" class="headerlink" title="启动优化准备"></a>启动优化准备</h2><h4 id="APP启动时间："><a href="#APP启动时间：" class="headerlink" title="APP启动时间："></a>APP启动时间：</h4><ul><li>t(App总启动时间) = t1(main()之前的加载时间) + t2(main()之后的加载时间)。</li></ul><blockquote><p>t1 = 系统dylib(动态链接库)和自身App可执行文件的加载；</p></blockquote><blockquote><p>t2 = main方法执行之后到AppDelegate类中的didFinishLaunchingWithOptions方法执行结束前这段时间，主要是构建第一个界面，并完成渲染展示。</p></blockquote><h3 id="前面我们分析了，Main之前和之后的加载过程"><a href="#前面我们分析了，Main之前和之后的加载过程" class="headerlink" title="前面我们分析了，Main之前和之后的加载过程"></a>前面我们分析了，Main之前和之后的加载过程</h3><h5 id="这里我们先简单介绍一下，之前没有详细说明的一些其中关联的技术："><a href="#这里我们先简单介绍一下，之前没有详细说明的一些其中关联的技术：" class="headerlink" title="这里我们先简单介绍一下，之前没有详细说明的一些其中关联的技术："></a>这里我们先简单介绍一下，之前没有详细说明的一些其中关联的技术：</h5><ul><li>App开始启动后，系统首先加载可执行文件（自身App的所有.o文件的集合），然后加载动态链接库dyld，dyld是一个专门用来加载动态链接库的库。<br>执行从dyld开始，dyld从可执行文件的依赖开始, 递归加载所有的依赖动态链接库。</li></ul><p>其实无论对于系统的动态链接库还是对于App本身的可执行文件而言，他们都算是image（镜像），而每个App都是以image(镜像)为单位进行加载的</p><blockquote><p>什么是image</p></blockquote><blockquote><p>1.executable可执行文件 比如.o文件。</p></blockquote><blockquote><p>2.dylib 动态链接库 framework就是动态链接库和相应资源包含在一起的一个文件夹结构。</p></blockquote><blockquote><p>3.bundle 资源文件 只能用dlopen加载，不推荐使用这种方式加载。</p></blockquote><p>注意：除了我们App本身的可行性文件，系统中所有的framework比如UIKit、Foundation等都是以动态链接库的方式集成进App中的。</p><blockquote><p>不同进程之间共用系统dylib的_TEXT区，但是各自维护对应的_DATA区。</p></blockquote><p>所有动态链接库和我们App中的静态库.a和所有类文件编译后的.o文件最终都是由dyld(the dynamic link editor)，Apple的动态链接器来加载到内存中。<br>每个image都是由一个叫做ImageLoader的类来负责加载（一一对应）</p><blockquote><p>是ImageLoader</p></blockquote><blockquote><p>image 表示一个二进制文件(可执行文件或 so 文件)，里面是被编译过的符号、代码等，</p></blockquote><blockquote><p>ImageLoader 作用是将这些文件加载进内存，且每一个文件对应一个ImageLoader实例来负责加载。</p></blockquote><h5 id="ImageLoader加载步骤分两步走："><a href="#ImageLoader加载步骤分两步走：" class="headerlink" title="ImageLoader加载步骤分两步走："></a>ImageLoader加载步骤分两步走：</h5><ul><li>在程序运行时它先将动态链接的 image 递归加载 (也就是上面测试栈中一串的递归调用的时刻)。</li><li>再从可执行文件 image 递归加载所有符号。</li></ul><h2 id="真正的启动优化："><a href="#真正的启动优化：" class="headerlink" title="真正的启动优化："></a>真正的启动优化：</h2><h3 id="Main之前："><a href="#Main之前：" class="headerlink" title="Main之前："></a>Main之前：</h3><p>检测方式：Apple提供了一种测量方法，在 Xcode 中 Edit scheme -&gt; Run -&gt; Auguments 将环境变量DYLD_PRINT_STATISTICS 设为1</p><blockquote><p>pre-main阶段</p><blockquote><p>1.1. 加载应用的可执行文件</p></blockquote></blockquote><blockquote><blockquote><p>1.2. 加载动态链接库加载器dyld（dynamic loader）</p></blockquote></blockquote><blockquote><blockquote><p>1.3. dyld递归加载应用所有依赖的dylib（dynamic library 动态链接库）</p></blockquote></blockquote><p>动态链接库的加载步骤具体分为5步：</p><ul><li>load dylibs image 读取库镜像文件</li><li>Rebase image</li><li>Bind image</li><li>Objc setup</li><li>initializers</li></ul><h4 id="load-dylibs-image"><a href="#load-dylibs-image" class="headerlink" title="load dylibs image"></a>load dylibs image</h4><p>在每个动态库的加载过程中， dyld需要：</p><ul><li>分析所依赖的动态库</li><li>找到动态库的mach-o文件</li><li>打开文件</li><li>验证文件</li><li>在系统核心注册文件签名</li><li>对动态库的每一个segment调用mmap()</li><li>通常的，一个App需要加载100到400个dylibs， 但是其中的系统库被优化，可以很快的加载。</li></ul><p>######&gt; 针对这一步骤的优化有：</p><ul><li>减少非系统库的依赖</li><li>尽量不使用内嵌（embedded）的dylib，加载内嵌dylib性能开销较大</li><li>合并已有的dylib和使用静态库（static archives），减少dylib的使用个数</li><li>使用静态资源，比如把代码加入主程序</li><li>懒加载dylib，但是要注意dlopen()可能造成一些问题，且实际上懒加载做的工作会更多</li></ul><h4 id="rebase-bind"><a href="#rebase-bind" class="headerlink" title="rebase/bind"></a>rebase/bind</h4><p>由于ASLR(address space layout randomization)的存在，可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不固定，所以需要这2步来修复镜像中的资源指针，来指向正确的地址。 rebase修复的是指向当前镜像内部的资源指针； 而bind指向的是镜像外部的资源指针。<br>rebase步骤先进行，需要把镜像读入内存，并以page为单位进行加密验证，保证不会被篡改，所以这一步的瓶颈在IO。bind在其后进行，由于要查询符号表，来指向跨镜像的资源，加上在rebase阶段，镜像已被读入和加密验证，所以这一步的瓶颈在于CPU计算。</p><p>通过命令行可以查看相关的资源指针:</p><p>xcrun dyldinfo -rebase -bind -lazy_bind myApp.App/myApp</p><p>优化该阶段的关键在于减少__DATA segment中的指针数量。</p><p>######&gt; 我们可以优化的点有：</p><ul><li>减少ObjC类（class）、方法（selector）、分类（category）的数量</li><li>减少C++虚函数数量（创建虚函数表有开销）</li><li>转而使用swift stuct（其实本质上就是为了减少符号的数量）</li></ul><h5 id="Objc-setup"><a href="#Objc-setup" class="headerlink" title="Objc setup"></a>Objc setup</h5><p>这一步主要工作是:</p><ul><li>注册Objc类 (class registration)</li><li>把category的定义插入方法列表 (category registration)</li><li>保证每一个selector唯一 (selctor uniquing)</li></ul><p>由于之前2步骤的优化，这一步实际上没有什么可做的。</p><h5 id="initializers"><a href="#initializers" class="headerlink" title="initializers"></a>initializers</h5><p>以上三步属于静态调整(fix-up)，都是在修改__DATA segment中的内容，而这里则开始动态调整，开始在堆和堆栈中写入内容。</p><p>在这里的工作有：</p><ul><li>Objc的+load()函数</li><li>C++的构造函数属性函数 形如attribute((constructor)) void DoSomeInitializationWork()</li><li>非基本类型的C++静态全局变量的创建(通常是类或结构体)(non-trivial initializer) 比如一个全局静态结构体的构建，如果在构造函数中有繁重的工作，那么会拖慢启动速度</li></ul><p>Objc的load函数和C++的静态构造函数采用由底向上的方式执行，来保证每个执行的方法，都可以找到所依赖的动态库。</p><p>+load方法断点的调用堆栈和顺序：</p><ul><li>dyld 开始将程序二进制文件初始化</li><li>交由 ImageLoader 读取 image，其中包含了我们的类、方法等各种符号</li><li>由于 runtime 向 dyld 绑定了回调，当 image 加载到内存后，dyld 会通知 runtime 进行处理</li><li>runtime 接手后调用 mapimages 做解析和处理，接下来 loadimages 中调用 callloadmethods 方法，遍历所有加载进来的 Class，按继承层级依次调用 Class 的 +load 方法和其 Category 的 +load 方法</li></ul><p>######&gt; 我们可以做的优化有：</p><ul><li>少在类的+load方法里做事情，尽量把这些事情推迟到+initiailize</li><li>减少构造器函数个数，在构造器函数里少做些事情</li><li>减少C++静态全局变量的个数</li></ul><p>至此，可执行文件中和动态库所有的符号(Class，Protocol，Selector，IMP，…)都已经按格式成功加载到内存中，被 runtime 所管理，再这之后，runtime 的那些方法(动态添加 Class、swizzle 等等才能生效)。</p><h4 id="到这里整个过程："><a href="#到这里整个过程：" class="headerlink" title="到这里整个过程："></a>到这里整个过程：</h4><blockquote><p>整个事件由 dyld 主导，完成运行环境的初始化后，配合 ImageLoader 将二进制文件按格式加载到内存， 动态链接依赖库，并由 runtime 负责加载成 objc 定义的结构，所有初始化工作结束后，dyld 调用真正的 main 函数。</p></blockquote><h3 id="总结优化点："><a href="#总结优化点：" class="headerlink" title="总结优化点："></a>总结优化点：</h3><ul><li>减少不必要的framework，因为动态链接比较耗时</li><li>check framework应当设为optional和required，如果该framework在当前App支持的所有iOS系统版本都存在，那么就设为required，否则就设为optional，因为optional会有些额外的检查</li><li>合并或者删减一些OC类，关于清理项目中没用到的类，使用工具AppCode代码检查功能，查到当前项目中没有用到的类如下：</li><li>删减一些无用的静态变量</li><li>删减没有被调用到或者已经废弃的方法</li><li>将不必须在+load方法中做的事情延迟到+initialize中</li><li>尽量不要用C++虚函数(创建虚函数表有开销)</li></ul><h3 id="Main之后："><a href="#Main之后：" class="headerlink" title="Main之后："></a>Main之后：</h3><p>检测方式：测量main()函数开始执行到didFinishLaunchingWithOptions执行结束的耗时，自己插入代码到工程。</p><blockquote><p>main()阶段</p><blockquote><p>2.1. dyld调用main()</p></blockquote></blockquote><blockquote><blockquote><p>2.2. 调用UIApplicationMain()</p></blockquote></blockquote><blockquote><blockquote><p>2.3. 调用applicationWillFinishLaunching</p></blockquote></blockquote><blockquote><blockquote><p>2.4. 调用didFinishLaunchingWithOptions</p></blockquote></blockquote><p>在main()被调用之后，App的主要工作就是初始化必要的服务，显示首页内容等。<br>而我们的优化也是围绕如何能够快速展现首页来开展。<br>App通常在AppDelegate类中的didFinishLaunchingWithOptions方法中创建首页需要展示的view，<br>然后在当前runloop的末尾，主动调用CA::Transaction::commit完成视图的渲染。</p><p>而视图的渲染主要涉及三个阶段：</p><ul><li>准备阶段 这里主要是图片的解码</li><li>布局阶段 首页所有UIView的- (void)layoutSubViews()运行</li><li>绘制阶段 首页所有UIView的- (void)drawRect:(CGRect)rect运行</li><li>再加上启动之后必要服务的启动、必要数据的创建和读取，这些就是我们可以尝试优化的地方</li></ul><h4 id="因此，对于main-函数调用之前我们可以优化的点有："><a href="#因此，对于main-函数调用之前我们可以优化的点有：" class="headerlink" title="因此，对于main()函数调用之前我们可以优化的点有："></a>因此，对于main()函数调用之前我们可以优化的点有：</h4><ul><li>不使用xib，直接视用代码加载首页视图</li><li>NSUserDefaults实际上是在Library文件夹下会生产一个plist文件，如果文件太大的话一次能读取到内存中可能很耗时，这个影响需要评估，如果耗时很大的话需要拆分(需考虑老版本覆盖安装兼容问题)</li><li>每次用NSLog方式打印会隐式的创建一个Calendar，因此需要删减启动时各业务方打的log，或者仅仅针对内测版输出log</li><li>梳理应用启动时发送的所有网络请求，是否可以统一在异步线程请求</li><li>梳理各个二方/三方库，找到可以延迟加载的库，做延迟加载处理，比如放到首页控制器的viewDidAppear方法里。</li><li>梳理业务逻辑，把可以延迟执行的逻辑，做延迟执行处理。比如检查新版本、注册推送通知等逻辑。</li><li>避免复杂/多余的计算。</li><li>避免在首页控制器的viewDidLoad和viewWillAppear做太多事情，这2个方法执行完，首页控制器才能显示，部分可以延迟创建的视图应做延迟创建/懒加载处理。</li><li>采用性能更好的API。</li><li>首页控制器用纯代码方式来构建。</li></ul><h3 id="总结：具体优化点"><a href="#总结：具体优化点" class="headerlink" title="总结：具体优化点"></a>总结：具体优化点</h3><ul><li>纯代码方式而不是storyboard加载首页UI。</li><li>对didFinishLaunching里的函数考虑能否挖掘可以延迟加载或者懒加载，需要与各个业务方pm和rd共同check 对于一些已经下线的业务，删减冗余代码。</li><li>对于一些与UI展示无关的业务，如微博认证过期检查、图片最大缓存空间设置等做延迟加载</li><li>对实现了+load()方法的类进行分析，尽量将load里的代码延后调用。</li><li>上面统计数据显示展示feed的导航控制器页面(NewsListViewController)比较耗时，对于viewDidLoad以及viewWillAppear方法中尽量去尝试少做，晚做，不做</li></ul><p>到这里之后其实已经差不多了，相信你应该有哪么写成就与收获。</p><h5 id="除了这些，我们还可以喂项目做一些缓存优化"><a href="#除了这些，我们还可以喂项目做一些缓存优化" class="headerlink" title="除了这些，我们还可以喂项目做一些缓存优化"></a>除了这些，我们还可以喂项目做一些缓存优化</h5><ul><li>ccache 等缓存方案</li><li>优化 Xcode 配置</li><li>加钱堆硬件</li></ul><p>以上优化方案出发点都是基础优化编译耗时来解决的。</p><p>哪有没有一个办法可以做到不编译就执行修改后的代码呢？</p><p>答案肯定是：有的</p><p>基于 Objective-C 的动态特性，是完全可以做到这一点的，这也是各种热修复框架的支撑原理之一。那么如果需要做到不编译就执行修改后的代码，我们可以这样做：</p><h5 id="获取本地修改后代码-gt-转-JavaScript-或-Lua-gt-模拟器执行修改后的脚本。"><a href="#获取本地修改后代码-gt-转-JavaScript-或-Lua-gt-模拟器执行修改后的脚本。" class="headerlink" title="获取本地修改后代码 -&gt; 转 JavaScript 或 Lua -&gt; 模拟器执行修改后的脚本。"></a>获取本地修改后代码 -&gt; 转 JavaScript 或 Lua -&gt; 模拟器执行修改后的脚本。</h5><ul><li>获取本地修改代码<ul><li>这里也有许多方法，可以手动复制，也可以自动获取。这里我是选择利用 Xcode Editor Extension 来获取到你选中的修改代码的。</li></ul></li><li>Objective-C 转 JavaScript<ul><li>由于整个流程我是基于 JSPatch 来开发的，所以是需要转为 JS 的脚本。这里我是写了个 node.js 的脚本来实现，转换算法是利用 <a href="https://github.com/bang590/JSPatchConvertor" target="_blank" rel="noopener">https://github.com/bang590/JSPatchConvertor</a> 中的开源代码。</li></ul></li><li>模拟器执行修改后的脚本<ul><li>由于已经有 JSPatch 完整的框架做支撑，这里只需要利用其中的方法 -[JPEngine evaluateScriptWithPath:] 去执行修改后的脚本即可。</li></ul></li></ul><blockquote><p>当然这种有一定的缺陷，不管是针对苹果审核，还是学习成本，或者是其他意向不到的问题</p></blockquote><blockquote><p>使用之前还是慎重考虑，可以适当的使用作为部分模块的优化，或者作为学习。</p></blockquote><p>至于后续的步骤就是，写好代码，逻辑，界面，优化……</p><h6 id="性能优化推荐：iOS应用性能调优的25个建议和技巧"><a href="#性能优化推荐：iOS应用性能调优的25个建议和技巧" class="headerlink" title="性能优化推荐：iOS应用性能调优的25个建议和技巧"></a>性能优化推荐：<a href="http://www.cocoachina.com/ios/20150408/11501.html" target="_blank" rel="noopener">iOS应用性能调优的25个建议和技巧</a></h6>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> iOS——App启动优化分析与总结 </tag>
            
            <tag> App启动优化分析与总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS——App整个启动过程分析</title>
      <link href="/2016/04/28/iOS%E2%80%94%E2%80%94App%E6%95%B4%E4%B8%AA%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
      <url>/2016/04/28/iOS%E2%80%94%E2%80%94App%E6%95%B4%E4%B8%AA%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>你想知道App是怎么显示到我们眼前的吗？你想知道点击Run之后发生了什么吗？你想知道在Main函数之前都还有那些你不知道操作吗？你想知道在Objective-C和Swift混编的时候这么处理AppDelegate吗？你想知道UIApplication都干了撒吗？你想知道怎么优化App启动过程吗？你想知道…..你撒都想知道，那还等什么？</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>本文的起因：</p></blockquote><blockquote><ol><li>前段时间在研究App启动相关内容，还有启动优化相关的东西，网上寻找了一下相关的资料并试着在整理，也自己试着去验证了其中的一些步骤。</li></ol></blockquote><blockquote><ol start="2"><li>公司项目是Objective-C版本的，大部分相关类都已经使用Swift重写了，后期新增的功能都使用的Swift混合开发。但是由于项目庞大又复杂，没有时间也没有精力去完全使用Swift重写。</li></ol></blockquote><blockquote><ol start="3"><li>因为从Swift一出来我就在学习，但是并没有在实际项目中应用到Swift，从1.0到2.0，再到3.0都有了解和学习相关的语法。但是近四年来一直都在使用OC和学习各种技术，以致于Swift其实该忘的也忘得差不多了。网上有句话：Swift从入门到入门。相信你既然都能看到这里，肯定明白其中的原因。所以我又开始重写学了一遍Swift，这一次是Swift3.1开始学，其实Swift4已经出来了，但是和3.1并没有太大的变化。</li></ol></blockquote><blockquote><ol start="4"><li>因为公司每个星期都有一个技术分享，所以我觉得去试一次，希望能把我知道的东西通过口述的方式分享出来。（不过分享的结果很差，毕竟是第一次，所以导致最后连我自己都不知道自己在说什么），同时这也是我在公司内部做的第一次技术分享的主题。</li></ol></blockquote><blockquote><ol start="5"><li>这一次，我希望能彻底从OC转到Swift进行实际开发。</li></ol></blockquote><h3 id="资料地址：-iOS——App整个启动过程分析。如果你觉得有用希望能给个star，或者有什么疑问欢迎issuse也欢迎联系我，谢谢！"><a href="#资料地址：-iOS——App整个启动过程分析。如果你觉得有用希望能给个star，或者有什么疑问欢迎issuse也欢迎联系我，谢谢！" class="headerlink" title="资料地址： iOS——App整个启动过程分析。如果你觉得有用希望能给个star，或者有什么疑问欢迎issuse也欢迎联系我，谢谢！"></a>资料地址：<a href="https://github.com/al1020119/iOS-App-Start-Up-Process" target="_blank" rel="noopener"> iOS——App整个启动过程分析</a>。如果你觉得有用希望能给个star，或者有什么疑问欢迎issuse也欢迎联系我，谢谢！</h3><p>首先申明，本文大部分会以理论和实际分析，不会涉及的太多的代码实战，也不会涉及到太多相关术语的解释，当然部分会给出链接地址，但是力求从下面几个问题并结合实际App的启动过程，让你了解代码之前所干的事情和处理实际开发中遇到的相关问题….</p><ul><li>点击Run之后发生了什么,以致App能够显示在我们的眼前？</li><li>Main函数之前苹果还为我们的App做了哪些操作？</li><li>OC项目中怎么使用Swift重写AppDelagate？</li><li>UIApplication&amp;UIApplicationMain背后做了什么？</li><li>如何优化App启动过程？<br>……</li></ul><p>本文篇幅会比较长，但是如果你能完全掌握里面的内容和应用，足以让你有一个质的提升，当然这是在你不了解上面我提到的情况下。</p><p>好了，废话说太多没有什么意思……开干！</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.001.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.002.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.003.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.004.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.005.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.006.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.007.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.008.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.009.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.010.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.011.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.012.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.013.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.014.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.015.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.016.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.017.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.018.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.019.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.020.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.021.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.022.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.023.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.024.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.025.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.026.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.027.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.028.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.029.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.030.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.031.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.032.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.033.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.034.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.035.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.036.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.037.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.038.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.039.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.040.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.041.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.042.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.043.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.044.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.045.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.046.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.047.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.048.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.049.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.050.png" alt="曹理鹏(iCocos)-梦工厂"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/launching/AppLaunchingiCocosLuanch.051.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>2016 WWDC（苹果提供的启动优化方案）</p><p><a href="https://developer.apple.com/videos/play/wwdc2016/406/" target="_blank" rel="noopener">https://developer.apple.com/videos/play/wwdc2016/406/</a>                                    </p><p>优化 App 的启动时间（各个阶段优化与处理）</p><p><a href="http://ios.jobbole.com/90331/" target="_blank" rel="noopener">http://ios.jobbole.com/90331/</a></p><p>iOS 程序 main 函数之前发生了什么</p><p><a href="http://blog.sunnyxx.com/2014/08/30/objc-pre-main/" target="_blank" rel="noopener">http://blog.sunnyxx.com/2014/08/30/objc-pre-main/</a></p><p>点击 Run 之后发生了什么？（Build类似）</p><p><a href="http://www.jianshu.com/p/d5cf01424e92" target="_blank" rel="noopener">http://www.jianshu.com/p/d5cf01424e92</a></p><p>Xcode编译性能优化（各个阶段优化实战与对比）</p><p><a href="http://blog.csdn.net/qq_25131687/article/details/52194034" target="_blank" rel="noopener">http://blog.csdn.net/qq_25131687/article/details/52194034</a></p>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> iOS——App整个启动过程分析 </tag>
            
            <tag> App整个启动过程分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS——CocoaPods私有化组件</title>
      <link href="/2016/04/25/iOS%E2%80%94%E2%80%94CocoaPods%E7%A7%81%E6%9C%89%E5%8C%96%E7%BB%84%E4%BB%B6/"/>
      <url>/2016/04/25/iOS%E2%80%94%E2%80%94CocoaPods%E7%A7%81%E6%9C%89%E5%8C%96%E7%BB%84%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>相信你能看到这里，就一定用过cocoapods，cocoapods是什么呢？怎么用？算了吧，都是本文的范围，这里只介绍怎么将自己的项目组件进行私有化，其实严格来说不算什么私有化，只是，想自己写好的框架放到github或者其他平台上让他支持cocoapods管理。这类文章网上已经随处可见，但是由于打算开始写自己的框架，就记录了一下…..</p><a id="more"></a><p>首推荐</p><p><a href="http://blog.devtang.com/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/" target="_blank" rel="noopener">用CocoaPods做iOS程序的依赖管理</a></p><p><a href="https://objccn.io/issue-6-4/" target="_blank" rel="noopener">深入理解 CocoaPods</a></p><p><a href="https://github.com/Draveness/analyze/blob/master/contents/CocoaPods/CocoaPods%20都做了什么？.md" target="_blank" rel="noopener">CocoaPods 都做了什么?</a></p><p>如果你还不知道sm是CocoaPods，或者想对CocoaPods了解更深入一点的，可以先看看上面的推荐</p><h2 id="1-在github创建仓库完成，然后将仓库检出到本地"><a href="#1-在github创建仓库完成，然后将仓库检出到本地" class="headerlink" title="1. 在github创建仓库完成，然后将仓库检出到本地"></a>1. 在github创建仓库完成，然后将仓库检出到本地</h2><p>注意创建事项：</p><ol><li>LICENSE(许可证)文件不可缺少，否则检测spec文件时，会有警告（选择MIT就OK）</li><li>不要使用中文，最好和库名字直接对应</li><li>其实也可以在其他平台，不一定是github</li></ol><h2 id="2-将写好开源框架-库的Demo或者Example放到Git仓库下，"><a href="#2-将写好开源框架-库的Demo或者Example放到Git仓库下，" class="headerlink" title="2. 将写好开源框架/库的Demo或者Example放到Git仓库下，"></a>2. 将写好开源框架/库的Demo或者Example放到Git仓库下，</h2><p>还要将要开源的文件夹也放入到git仓库中（该文件夹在后面会被用到）</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/cocoapods/cocoapods001.png"></p><h2 id="3-项目发布到github后，我们在工程根目录中初始化一个Podspec文件："><a href="#3-项目发布到github后，我们在工程根目录中初始化一个Podspec文件：" class="headerlink" title="3. 项目发布到github后，我们在工程根目录中初始化一个Podspec文件："></a>3. 项目发布到github后，我们在工程根目录中初始化一个Podspec文件：</h2><p>创建自己项目的Podspec描述文件:</p><blockquote><p>pod spec create iCocos</p></blockquote><h2 id="4-编辑修改iCocos-podspec对应信息"><a href="#4-编辑修改iCocos-podspec对应信息" class="headerlink" title="4. 编辑修改iCocos.podspec对应信息"></a>4. 编辑修改iCocos.podspec对应信息</h2><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/cocoapods/cocoapods002.png"></p><p>可以直接参照我的内容进行修改</p><p>具体内容不介绍</p><ul><li>s.name：名称，pod search 搜索的关键词,注意这里一定要和.podspec的名称一样,否则报错</li><li>s.version：版本号</li><li>s.ios.deployment_target:支持的pod最低版本</li><li>s.summary: 简介</li><li>s.homepage:项目主页地址</li><li>s.license:许可证</li><li>s.author:作者</li><li>s.social_media_url:社交网址,这里我写的微博默认是Twitter,如果你写Twitter的话,你的podspec发布成功后会@你</li><li>s.source:项目的地址<ul><li>s.source = { :git =&gt; “<a href="https://github.com/al1020119/iCocos.git&quot;" target="_blank" rel="noopener">https://github.com/al1020119/iCocos.git&quot;</a>, :commit =&gt; “68defea” }</li><li>s.source = { :git =&gt; “<a href="https://github.com/al1020119/iCocos.git&quot;" target="_blank" rel="noopener">https://github.com/al1020119/iCocos.git&quot;</a>, :tag =&gt; 1.0.0 }</li><li>s.source = { :git =&gt; “<a href="https://github.com/al1020119/iCocos.git&quot;" target="_blank" rel="noopener">https://github.com/al1020119/iCocos.git&quot;</a>, :tag =&gt; s.version }</li></ul></li></ul><blockquote><p>commit =&gt; “68defea” 表示将这个Pod版本与Git仓库中某个commit绑定</p></blockquote><blockquote><p>tag =&gt; 1.0.0 表示将这个Pod版本与Git仓库中某个版本的comit绑定</p></blockquote><blockquote><p>tag =&gt; s.version 表示将这个Pod版本与Git仓库中相同版本的comit绑定</p></blockquote><ul><li>s.source_files:需要包含的源文件</li><li>s.resources: 资源文件</li><li>s.requires_arc: 是否支持ARC</li><li>s.dependency：依赖库，不能依赖未发布的库，如 s.dependency = ‘AFNetworking’</li><li>s.dependency：依赖库，如有多个可以这样写。我这里是托管在github上,所以这里将地址copy过来就行了。</li><li>source_files: 核心代码的文件地址。<ul><li>这里是经常出错的地方！—如果使用的是这种方式来显示核心代码地址而不是下面的模块化的话，</li><li>需要将代码文件必须以仓库名命名（也就意味着最多只有两个文件.h和.m文件了，可以有一个.h文件，把它作为头文件就行），这种方式检验podspec文件有点严格，否则就会报错。</li></ul></li><li>source_files:写法及含义建议大家写第一种或者第二种<ul><li><code>&quot;YJSettingTableView/*</code></li><li><code>&quot;&quot;YJSettingTableView/YJSettingTableView/*.{h,m}&quot;</code></li><li><code>&quot;YJSettingTableView/**/*.h&quot;</code></li></ul></li></ul><blockquote><p><code>“*”</code> 表示匹配所有文件</p></blockquote><blockquote><p><code>“*.{h,m}”</code> 表示匹配所有以<code>.h</code>和<code>.m</code>结尾的文件</p></blockquote><blockquote><p><code>“**”</code> 表示匹配所有子目录</p></blockquote><h2 id="5-设置tag号，提交修改（注：只要spec文件被修改，就必须重新执行如下命令）"><a href="#5-设置tag号，提交修改（注：只要spec文件被修改，就必须重新执行如下命令）" class="headerlink" title="5. 设置tag号，提交修改（注：只要spec文件被修改，就必须重新执行如下命令）"></a>5. 设置tag号，提交修改（注：只要spec文件被修改，就必须重新执行如下命令）</h2><p>因为cocoapods是依赖tag版本的,所以必须打tag,<br>以后再次更新只需要把你的项目打一个tag<br>然后修改.podspec文件中的版本接着提交到cocoapods官方就可以了,提交命令请看下面</p><ul><li>git commit -m “Release 1.0.0”  (先提交当前修改)</li><li>git tag “v1.0.0”            (添加tag) //为git打tag, 第一次需要在前面加一个v</li><li>git push –tags         (推送tag到远程)</li><li>git push origin master  (推送到远程到代码仓库)</li></ul><p>或许可能有些没有加入的（执行 git add . 就可以）</p><h2 id="6-提交之前先验证-podspec文件是否合法"><a href="#6-提交之前先验证-podspec文件是否合法" class="headerlink" title="6. 提交之前先验证.podspec文件是否合法"></a>6. 提交之前先验证.podspec文件是否合法</h2><ul><li>pod spec lint iCocos.podspec –verbose</li><li>pod spec lint iCocos.podspec –allow-warnings     (忽略警告)</li></ul><p>我这边在验证的时候出现了下面错误</p><blockquote><p>LiudeMacBook:iCocos a115$ pod spec lint iCocos.podspec –verbose</p></blockquote><pre><code>-&gt; iCocos (1.0.0)- ERROR | license: Sample license type.- ERROR | description: The description is empty.- ERROR | [iOS] unknown: Encountered an unknown error (The `iCocos` pod failed to validate due to 2 errors.[!] The validator for Swift projects uses Swift 3.0 by default, if you are using a different version of swift you can use a `.swift-version` file to set the version for your Pod. For example to use Swift 2.3, run:`echo &quot;2.3&quot; &gt; .swift-version`:- ERROR | license: Sample license type.- ERROR | description: The description is empty.) during validation.Analyzed 1 podspec.[!] The spec did not pass validation, due to 3 errors.[!] The validator for Swift projects uses Swift 3.0 by default, if you are using a different version of swift you can use a `.swift-version` file to set the version for your Pod. For example to use Swift 2.3, run:`echo &quot;2.3&quot; &gt; .swift-version`.</code></pre><p>根据上面提示了三个错误（due to 3 errors），其实是两个，1，3是一个</p><h3 id="1-description-is-empty"><a href="#1-description-is-empty" class="headerlink" title="1. description is empty"></a>1. description is empty</h3><p>这里原始description是这样的</p><pre><code>`s.description  = &lt;&lt;-DESC``DESC`</code></pre><p>需要改成一段属于自己的描述，其他信息类型修改</p><ol start="2"><li>关于swift-version</li></ol><p>这里直接执行<code>echo &quot;2.3&quot; &gt; .swift-version</code>就正常的</p><p>但是据需验证又出现如下错误：</p><blockquote><p>LiudeMacBook:iCocos a115$ pod spec lint iCocos.podspec</p></blockquote><pre><code>-&gt; iCocos (1.0.0)- ERROR | [iOS] unknown: Encountered an unknown error ([!] /usr/bin/git clone https://github.com/al1020119/iCocos.git /var/folders/4z/d12mnyfx7c37vg91t8h0941h0000gp/T/d20171025-8857-1oau87 --template= --single-branch --depth 1 --branch 1.0.0Cloning into &apos;/var/folders/4z/d12mnyfx7c37vg91t8h0941h0000gp/T/d20171025-8857-1oau87&apos;...warning: Could not find remote branch 1.0.0 to clone.fatal: Remote branch 1.0.0 not found in upstream origin) during validation.Analyzed 1 podspec.[!] The spec did not pass validation, due to 1 error.</code></pre><p>这里其实不是错误，是没有更新处理，前面说了：</p><blockquote><p>（注：只要spec文件被修改，就必须重新执行如下命令）</p></blockquote><pre><code>git commit -m &quot;Release 1.0.0&quot;  (先提交当前修改)git tag 1.0.0            (添加tag)git push --tags         (推送tag到远程)git push origin master  (推送到远程到代码仓库)</code></pre><p>或许可能有些没有加入的（执行 git add . 就可以）</p><h2 id="7-然后再次验证就会成功"><a href="#7-然后再次验证就会成功" class="headerlink" title="7. 然后再次验证就会成功"></a>7. 然后再次验证就会成功</h2><blockquote><p>LiudeMacBook:iCocos a115$ pod spec lint iCocos.podspec  –verbose</p></blockquote><pre><code>-&gt; iCocos (1.0.0)Analyzed 1 podspec.iCocos.podspec passed validation.</code></pre><p>或许你还可能遇到下面的错误，不过不要慌，直接按照下面操作就可以</p><pre><code>先删除tag// 删除本地taggit tag -d 1.0.0// 删除远程taggit push origin -d tag 1.0.0</code></pre><p>修改spec文件（必须修改相应的version和source）<br>重新执行–&gt;设置tag号，提交修改的步骤</p><h2 id="8-trunk推送podspec文件"><a href="#8-trunk推送podspec文件" class="headerlink" title="8. trunk推送podspec文件"></a>8. trunk推送podspec文件</h2><p>podspec文件验证成功，通过trunk推送podspec文件</p><pre><code>pod trunk push iCocos.podspec</code></pre><p>如果你是第一次，并且没有帐号你会看到下面一段</p><blockquote><p>LiudeMacBook:iCocos a115$ pod trunk push iCocos.podspec</p></blockquote><pre><code>[!] You need to register a session first.Usage:$ pod trunk push [PATH]Publish the podspec at `PATH` to make it available to all users of the ‘master’spec-repo. If `PATH` is not provided, defaults to the current directory.Before pushing the podspec to cocoapods.org, this will perform a local lint ofthe podspec, including a build of the library. However, it remains *your*responsibility to ensure that the published podspec will actually work for yourusers. Thus it is recommended that you *first* try to use the podspec tointegrate the library into your demo and/or real application.If this is the first time you publish a spec for this pod, you willautomatically be registered as the ‘owner’ of this pod. (Note that ‘owner’ inthis case implies a person that is allowed to publish new versions and add other‘owners’, not necessarily the library author.)Options:--allow-warnings           Allows push even if there are lint warnings--use-libraries            Linter uses static libraries to install the spec--swift-version=VERSION    The SWIFT_VERSION that should be used to lint the spec.This takes precedence over a .swift-version file.--skip-import-validation   Lint skips validating that the pod can be imported--skip-tests               Lint skips building and running tests during validation--silent                   Show nothing--verbose                  Show more debugging information--no-ansi                  Show output without ANSI codes--help                     Show help banner of specified command</code></pre><p>根据上面的提示是告诉你：需要你用邮箱注册一个trunk</p><h2 id="9-我们直接使用终端注册"><a href="#9-我们直接使用终端注册" class="headerlink" title="9. 我们直接使用终端注册"></a>9. 我们直接使用终端注册</h2><pre><code>pod trunk register al10201119@163.com &quot;iCocos&quot; --description=&quot;iCocos&quot;</code></pre><p>之后会有一封带有验证链接的邮件发送到你输入的邮箱，点击验证后就可以回来终端继续提交操作了。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/cocoapods/cocoapods003.png"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/cocoapods/cocoapods004.png"></p><p>已经注册过的不需要注册,怎么看自己有没有注册</p><pre><code>pod trunk me</code></pre><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/cocoapods/cocoapods005.png"></p><h2 id="10-发布代码到cocoapods"><a href="#10-发布代码到cocoapods" class="headerlink" title="10. 发布代码到cocoapods"></a>10. 发布代码到cocoapods</h2><pre><code>pod trunk push iCocos.podspec --verbosepod trunk push iCocos.podspec --allow-warnings</code></pre><p>发布时会验证 Pod 的有效性，如果你在手动验证 Pod 时使用了 –use-libraries 或 –allow-warnings 等修饰符，那么发布的时候也应该使用相同的字段修饰，否则出现相同的报错。</p><p>pod trunk push iCocos.podspec –verbose</p><p>一段很长的描述，然后你会看到下面的成功提示</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/cocoapods/cocoapods006.png"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/cocoapods/cocoapods007.png"></p><h2 id="11-如果提交到cocoapods还有可能遇到下面错误："><a href="#11-如果提交到cocoapods还有可能遇到下面错误：" class="headerlink" title="11. 如果提交到cocoapods还有可能遇到下面错误："></a>11. 如果提交到cocoapods还有可能遇到下面错误：</h2><pre><code>Updating spec repo &apos;master&apos;warning: inexact rename detection was skipped due to too many files.warning: you may want yo set your diff.renameLimit variable to at least 3080 an retry the command...[!] There was an error pushing a new version to trunk: execution expired</code></pre><p>这里有解决方案：<a href="http://www.sw33tcode.com/?p=31" target="_blank" rel="noopener">http://www.sw33tcode.com/?p=31</a></p><pre><code>git config merge.renameLimit 999999git config --unset merge.renameLimit</code></pre><h2 id="12-然后开始去搜索我的库了"><a href="#12-然后开始去搜索我的库了" class="headerlink" title="12. 然后开始去搜索我的库了"></a>12. 然后开始去搜索我的库了</h2><p>但是发现既然没有，各种排查，最后发现由于延时的问题，不过如果还是不出现的，网上找到了相应的方案：</p><blockquote><p>删除<code>~/Library/Caches/CocoaPods</code>目录下的<code>search_index.json</code>文件</p></blockquote><blockquote><p><code>pod setup</code>成功后会生成<code>~/Library/Caches/CocoaPods/search_index.json</code>文件。</p></blockquote><blockquote><p>终端输入<code>rm ~/Library/Caches/CocoaPods/search_index.json</code></p></blockquote><blockquote><p>删除成功后再执行pod search</p></blockquote><p>稍等片刻，然后<code>pod search</code>就会出现你所要搜的类库了。</p>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> iOS——CocoaPods私有化组件 </tag>
            
            <tag> CocoaPods私有化组件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS——奇葩需求QQ号与QQ群添加与跳转</title>
      <link href="/2016/04/18/iOS%E2%80%94%E2%80%94%E5%A5%87%E8%91%A9%E9%9C%80%E6%B1%82QQ%E5%8F%B7%E4%B8%8EQQ%E7%BE%A4%E6%B7%BB%E5%8A%A0%E4%B8%8E%E8%B7%B3%E8%BD%AC/"/>
      <url>/2016/04/18/iOS%E2%80%94%E2%80%94%E5%A5%87%E8%91%A9%E9%9C%80%E6%B1%82QQ%E5%8F%B7%E4%B8%8EQQ%E7%BE%A4%E6%B7%BB%E5%8A%A0%E4%B8%8E%E8%B7%B3%E8%BD%AC/</url>
      <content type="html"><![CDATA[<p>最近在做一个新的二次元游戏App，说真的第一次做游戏一开始有点压力，但是后面了解到用到的技术其实跟游戏没有太多关系，就巴拉巴拉的开始写了，但是由于只有一个人，项目赶着上线，再加上之前需求的不明确和中途的调整，导致期间也浪费了不少时间，最近在实现最后一个功能的时候遇到了点问题，一开始是我想的太复杂了，后面群里一问，网上一了解，发现：MMP，这么简单，说多了都是尿，于是记录了这一切……..</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>本文的起因：</p></blockquote><blockquote><p>新项目，一个人纯swift开发，有个小功能第一次遇到，就是在用户中心有一行显示（群号+点击加群）文案，点击这一行拉起QQ App，如果QQ APP所登录的QQ已经加入了QQ号就直接到群聊页面，如果没有就跳到加群页面，可以点击申请加群。</p></blockquote><h5 id="注意：-这里其实是打开QQ后，使用QQ来去打开了一个网页。"><a href="#注意：-这里其实是打开QQ后，使用QQ来去打开了一个网页。" class="headerlink" title="注意： 这里其实是打开QQ后，使用QQ来去打开了一个网页。"></a>注意： 这里其实是打开QQ后，使用QQ来去打开了一个网页。</h5><p>下面上代码：</p><h3 id="一下是朋友提供的OC代码"><a href="#一下是朋友提供的OC代码" class="headerlink" title="一下是朋友提供的OC代码"></a>一下是朋友提供的OC代码</h3><pre><code>- (NSURL*)getQQQunUrl {    NSString *qq_number = @&quot;??&quot;    NSString* urlStr = [NSString stringWithFormat:@&quot;mqqapi://card/show_pslcard?src_type=internal&amp;version=1&amp;uin=%@&amp;key=%@&amp;card_type=group&amp;source=external&quot;, qq_number, @&quot;44a6e01f2dab126f87ecd2ec7b7e66ae259b30535fd0c2c25776271e8c0ac08f&quot;];    return [NSURL URLWithString:urlStr];}</code></pre><h4 id="调用方式："><a href="#调用方式：" class="headerlink" title="调用方式："></a>调用方式：</h4><pre><code>NSURL* url = [self getQQqunUrl];if ([[UIApplication sharedApplication] canOpenURL:url]) {    [[UIApplication sharedApplication] openURL:url];}</code></pre><h3 id="这是我最终Swift的实现方式"><a href="#这是我最终Swift的实现方式" class="headerlink" title="这是我最终Swift的实现方式"></a>这是我最终Swift的实现方式</h3><pre><code>func getQQQunUrl() -&gt; String {    let qq_number = &quot;??&quot;    let url_str = &quot;mqqapi://card/show_pslcard?src_type=internal&amp;version=1&amp;uin=\(qq_number)&amp;key=44a6e01f2dab126f87ecd2ec7b7e66ae259b30535fd0c2c25776271e8c0ac08f&amp;card_type=group&amp;source=external&quot;    return url_str}</code></pre><h4 id="调用方式：-1"><a href="#调用方式：-1" class="headerlink" title="调用方式："></a>调用方式：</h4><pre><code>let urlString = self.getQQQunUrl()if let url = URL(string: urlString) {    //根据iOS系统版本，分别处理    if #available(iOS 10, *) {        UIApplication.shared.open(url, options: [:], completionHandler: { (success) in })    } else {        UIApplication.shared.openURL(url)    }}</code></pre><blockquote><p>只要替换以上QQ好就可以，看着代码是不是很简单，算了不说了，我都想静一静……</p></blockquote><p>来看看效果图：</p><h5 id="加群之前的效果"><a href="#加群之前的效果" class="headerlink" title="加群之前的效果"></a>加群之前的效果</h5><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/JMT/0316/0002.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/JMT/0316/0003.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h5 id="加群之后的效果"><a href="#加群之后的效果" class="headerlink" title="加群之后的效果"></a>加群之后的效果</h5><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/JMT/0316/0004.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/JMT/0316/0005.JPG" alt="曹理鹏(iCocos)-梦工厂"></p><h2 id="QQ号调整"><a href="#QQ号调整" class="headerlink" title="QQ号调整"></a>QQ号调整</h2><p>最近又有一个新的需求，由于需求比较相似，于是我直接在这里追加了。</p><p>需要处理QQ号的跳转，点击直接打开QQ调用网页版加号或者聊天页面</p><blockquote><p>其实功能并没有任何难度在，其实寻找对应的链接，替换内部信息就可以。</p></blockquote><p>一下只提供OC和Swift的关键代码：</p><h3 id="OC的实现方式"><a href="#OC的实现方式" class="headerlink" title="OC的实现方式"></a>OC的实现方式</h3><pre><code>//qqNumber就是你要打开的QQ号码， 也就是你的客服号码。NSString  *qqNumber=@&quot;QQ号&quot;;if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;mqq://&quot;]]) {    UIWebView *webView = [[UIWebView alloc] initWithFrame:CGRectZero];    NSURL * url=[NSURL URLWithString:[NSString stringWithFormat:@&quot;mqq://im/chat?chat_type=wpa&amp;uin=%@&amp;version=1&amp;src_type=web&quot;,qqNumber]];    NSURLRequest *request = [NSURLRequest requestWithURL:url];    webView.delegate = self;    [webView loadRequest:request];    [self.view addSubview:webView];}</code></pre><h3 id="Swift的实现方式"><a href="#Swift的实现方式" class="headerlink" title="Swift的实现方式"></a>Swift的实现方式</h3><pre><code>// 打开Urlclass func openOuterUrl(_ url: String) {    if let url = URL(string: url) {        //根据iOS系统版本，分别处理        if UIApplication.shared.canOpenURL(url)  {            //根据iOS系统版本，分别处理            if #available(iOS 10, *) {                UIApplication.shared.open(url, options: [:],                completionHandler: { (success) in })            } else {                UIApplication.shared.openURL(url)            }        }    }}class func getQQUrl() -&gt; String {    let url_str = &quot;mqq://im/chat?chat_type=wpa&amp;uin=\(self.getQQ())&amp;version=1&amp;src_type=web&quot;    return url_str}</code></pre><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://www.jianshu.com/p/ac4981b634c2" target="_blank" rel="noopener">iOS调用QQ客户端,发起临时会话</a><br><a href="https://www.jianshu.com/p/d306a443bcc8" target="_blank" rel="noopener">IOS APP中打开指定qq聊天界面</a></p>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> iOS——奇葩需求QQ号与QQ群添加与跳转 </tag>
            
            <tag> QQ号与QQ群添加与调整功能 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Xcode Server完整教程</title>
      <link href="/2016/04/11/Xcode-Server%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/"/>
      <url>/2016/04/11/Xcode-Server%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>由于公司项目的需要，以及同事和测试人员的反馈，我们的打包服务器挂了，貌似之前经常挂（因为我桌旁的就是装有打包服务器的垃圾桶，在领用Mac之前，我都是用那个开发的）。其实之前我也一直想找个机会搞一下Xcode Server，记得还专门写过一篇总结，但是由于工作的原因，也由于帐号的原因就没去搞了，这一次刚好有这个机会，于是我专门放下手上所有的活，打算把这个东西弄好来………</p><a id="more"></a><blockquote><p>如果你对CI和CD已经足够了解，仅仅想知道怎么搞好Xcode Server，那么你可以直接从<code>准备</code>开始…</p></blockquote><h3 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h3><p>之前项目使用的是Jenkins，但是由于Jenkins的各种问题，配置，后面被换到了Xcode Server（当然除了他们我还可以选择Fantlane）。自从老大走了以后Xcode Server经常挂，导致测试人员不发打包测试，从而影响整体进度。而且这一次好像是彻底挂了，根本都进不去了…..</p><h3 id="常识："><a href="#常识：" class="headerlink" title="常识："></a>常识：</h3><h4 id="这里简单介绍一下Xcode-Server和常用的持续交付与继承工具（CI-amp-CD）。"><a href="#这里简单介绍一下Xcode-Server和常用的持续交付与继承工具（CI-amp-CD）。" class="headerlink" title="这里简单介绍一下Xcode Server和常用的持续交付与继承工具（CI&amp;CD）。"></a>这里简单介绍一下Xcode Server和常用的持续交付与继承工具（CI&amp;CD）。</h4><ul><li>xcodebuild - 由Apple开发，主要用于Xcode的构建和测试，有时可能难以想起，但可配置程度很高。</li><li>fastlane - 实际上并不是一个工具，而是一组可用于构建、测试、上传至iTunes Connect、供应配置文件管理、屏幕截图创建、dsym上传/下载至主要崩溃报告平台的一系列工具。</li><li>xctool和其他 - “其他”是指诸如nomad tools等工具，这些工具或者被弃用，或者逐渐缺少支持，或者即将被废弃。尽管Facebook在使用某种工具，但并不意味着这个工具依然可以得到妥善的维护。</li></ul><h4 id="服务器方面主要的选择包括："><a href="#服务器方面主要的选择包括：" class="headerlink" title="服务器方面主要的选择包括："></a>服务器方面主要的选择包括：</h4><ul><li>TravisCI/CircleCI - 托管式服务器，可免费用于开源项目，可随处访问，极为强大。相比Jenkins可配置的选项较少，仅支持与Github集成。用于私有代码库的价格高昂。</li><li>Xcode Server - 能与Xcode高度集成，实际上也是唯一可用于Xcode的服务器，由Apple开发，最有可能只需要少量配置即可投入使用。</li><li>Jenkins - CI服务器领域曾经的王者，有大量插件可用，可与各种其他产品集成，需要一定的配置和维护，但是非常强大。</li></ul><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>一般项目到了一定程度，或者公司和成员到了一定规模都会考虑自动化，当然也包括那些喜欢导致或者懒惰想一键打包发布的程序员。因此结合公司，项目或者个人的情况我们可以将整个过程进行拆分。</p><ul><li>构建并签署我们的所有不同特性的应用；</li><li>将我们的应用商店首选项上传至iTunes Connect；</li><li>将IPA、dSYM，以及变更日志上传至HockeyApp；</li><li>针对发布和开发分支持续不断地运行单元测试和UI测试；</li><li>构建每次合并请求（MR）并汇报测试结果；</li><li>进行持续不断地构建和签署，以确保没有引入新的问题。</li></ul><blockquote><p>由于时间的原因，也由于目前需求的原因，我们目前只需要进行打包发布相关操作，至于，分析，测试…</p></blockquote><p>看完上面之后，相信你知道我接下来要说的是什么，</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="OS-X工具下载"><a href="#OS-X工具下载" class="headerlink" title="OS X工具下载"></a>OS X工具下载</h3><ul><li>下载 OS X Server（付费开发者免费使用）</li><li>下载 Xcode</li></ul><p>这里就不多废话了，直接到苹果商店搜索就可以</p><h3 id="帐号与代码仓库地址"><a href="#帐号与代码仓库地址" class="headerlink" title="帐号与代码仓库地址"></a>帐号与代码仓库地址</h3><ul><li>开发者帐号（相关证书与描述文件）</li><li>git源代码仓库地址</li></ul><p>装备完了上面所需要的东西之后我们就可以开始配置和使用OS X Server了</p><h2 id="配置Xcode"><a href="#配置Xcode" class="headerlink" title="配置Xcode"></a>配置Xcode</h2><p>打开OS X Server，根据提示点击一步一步操作即可</p><ul><li>1 选择服务器主机：一般选自身，也可以指定IP</li><li>2 选择Xcode服务，开启服务（右上角）</li></ul><h4 id="老版配置页面"><a href="#老版配置页面" class="headerlink" title="老版配置页面"></a>老版配置页面</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/000.png"></p><p>这里需要注意，之前的配置方案是直接有</p><ul><li>权限和版本号：自己考虑，我这里默认设置不改了；</li><li>开发团队：使用自己的apple ID添加；</li><li>开发设备：需要用设备连接服务器后才能搜索到，初次连接，可能还需要在Status选项里面点击【Add to Teams】（比如设备不是你上面apple ID 的就需要）</li><li>查看Bot：会打开网页（Bot管理页面，默认127.0.01）,可以直接静态分析测试打包等，当然需要后面配置成功才能使用。</li></ul><h4 id="新版配置页面"><a href="#新版配置页面" class="headerlink" title="新版配置页面"></a>新版配置页面</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/001.png"></p><p>最新版本不知道为什么没有了对应的信息，根据提示信息应该的Xcode兼容性问题（因为：点击选择Xcode，选择指定Xcode之后提示是说版本不兼容）</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/002.png"></p><p>此时界面只有一个选择Xcode的按钮，点击进去就会直接进入到Server &amp; Bots</p><p>你会看到下面的界面</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/003.png"></p><blockquote><p>这里也可以直接在Xcode Preferences中打开，</p></blockquote><p>解锁后点击OFF&amp;ON进行开启服务，然后会提示Select Integration User（选择集成用户）</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/004.png"></p><p>这里我们一般都会新建一个用户，而不是直接使用服务器账户，然后填写对应的信息（帐号密码），这里要记住后面会有用</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/005.png"></p><p>点击创建之后就会执行一系列操作，对Xcode进行配置</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/006.png"></p><h5 id="具体执行操作有"><a href="#具体执行操作有" class="headerlink" title="具体执行操作有"></a>具体执行操作有</h5><ul><li>Saveing version information</li><li>Enableing developer model</li><li>Configuring SSL certificates</li><li>Starting Redis</li><li>initializing database</li><li>Starting API Server</li><li>Starting Apache</li><li>Starting control daemon</li><li>Starting Builder</li><li>Upgrading Xcode Server Data</li><li>Saveing version information</li></ul><p>完成后你会看到，一个提示新用户登录的提示，为了更好的进行测试和验证，我们都会先登录用户</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/007.png"></p><p>直接登录就可以，并且一步一步确认进入到子账户，子账户会提示：</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/008.png"></p><p>这里先不用管，切回到服务器账户就可以，这个时候，你就可以看到刚刚创建的账户已经出现了，并且处于登录状态，我们可以点击直接切换到对应账户，或者选择和重新创建多个账户，控制超时时间。</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/009.png"></p><h2 id="登录账户"><a href="#登录账户" class="headerlink" title="登录账户"></a>登录账户</h2><p>在Xcode Preferences中选择Account，点击右下角添加账户，分别登录Apple ID，GitHub，Xcode Server</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/10.png"></p><h4 id="Apple-ID：对应开发者帐号，要和本地证书与描述文件对应"><a href="#Apple-ID：对应开发者帐号，要和本地证书与描述文件对应" class="headerlink" title="Apple ID：对应开发者帐号，要和本地证书与描述文件对应"></a>Apple ID：对应开发者帐号，要和本地证书与描述文件对应</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/11.png"></p><h4 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/12.png"></p><blockquote><p>注意:Source Control 需要打开才能使用！具体下面的各种自动自己考虑勾选；</p></blockquote><h4 id="Xcode-Server（如果使用Xcode-9-1最新版本，这一步已经不需要了，也就是说Xcode-9-1已经自带了Bots功能）"><a href="#Xcode-Server（如果使用Xcode-9-1最新版本，这一步已经不需要了，也就是说Xcode-9-1已经自带了Bots功能）" class="headerlink" title="Xcode Server（如果使用Xcode 9.1最新版本，这一步已经不需要了，也就是说Xcode 9.1已经自带了Bots功能）"></a>Xcode Server（如果使用Xcode 9.1最新版本，这一步已经不需要了，也就是说Xcode 9.1已经自带了Bots功能）</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/13.png"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/14.png"></p><blockquote><p>注意：Accounts 添加 Servers，一般默认自己主机，也可以选择指定IP地址，按服务器配置时对应选择；需要填写用户名，密码，自己搞定；</p></blockquote><p>完成帐号登录以后，可以适当下载更新一下证书文件</p><h2 id="配置Xcode-Server（如果使用Xcode-9-1最新版本，这一步已经不需要了，也就是说Xcode-9-1已经自带了Bots功能）"><a href="#配置Xcode-Server（如果使用Xcode-9-1最新版本，这一步已经不需要了，也就是说Xcode-9-1已经自带了Bots功能）" class="headerlink" title="配置Xcode Server（如果使用Xcode 9.1最新版本，这一步已经不需要了，也就是说Xcode 9.1已经自带了Bots功能）"></a>配置Xcode Server（如果使用Xcode 9.1最新版本，这一步已经不需要了，也就是说Xcode 9.1已经自带了Bots功能）</h2><p>再次打开Xcode Server，进入Xcode服务页面，点击打开Xcode，会直接打开Xcode Preferences中的Server &amp; Bots并开启对应账户，这里和前面操作一样，如果没有就根据提示直接确定或者输入对应的账号信息就可以（如果没有登录帐号的话）</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/16.png"></p><h2 id="创建Bots"><a href="#创建Bots" class="headerlink" title="创建Bots"></a>创建Bots</h2><blockquote><p>注意：自己的项目必须是个git文件夹，比如github上clone下来的项目，或者是本地服务器git来的，总之需要git文件夹；（官方文档使用Xcode的Source Control 方式搞定，具体可以看官方指南。我直接用了第三方软件SourceTree管理的）</p></blockquote><blockquote><p>这里由于我们是直接使用GitLab的，所以我直接从GitLab克隆了一分项目源码到本地文件夹。</p></blockquote><p>打开Xcode，保证项目编译正常的情况下创建Bots（这里可以直接点击Products-&gt;Create Bots）</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/61.png"></p><p>1 Bot命名与服务器选择，基本默认不改；<br>2 选择项目内容，后面的master，可选其他分支，比如develop；<br>3 Bot 操作配置<br>Scheme：默认项目本身<br>Actions：1分析；2单元测试（测试项目没开单元测试所有没的选）；3打包；<br>Cleaning：可以选择，因为是自己的电脑做服务器的，所以选择了一周清理一次；<br>Configuation：项目配置；<br>4 环境变量？没用过，sorry；<br>5 添加脚本，比如完成后发送个邮件通知；<br>6 create！注意 需要一次验证 git 的用户名和密码！不是之前设置的用户名与密码。<br>7 成功；各种信息以及完成的打包等；通过IP地址也可以实时整合并下载；</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/62.png"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/63.png"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/64.png"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/65.png"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/67.png"></p><p>当你看到一个类型这样的界面，说明已经配置并且创建Bots完成，具体是否正确，需要进行打包验证或者根据日志进行查找具体问题</p><blockquote><p>注意：</p></blockquote><blockquote><blockquote><p>如果在使用Xcode Server对应的分析，测试功能，还需要额外进行一些配置，由于时间的问题，这里我们暂时只使用打包功能。</p></blockquote></blockquote><blockquote><blockquote><p>打包配置需要选择InHouse</p></blockquote></blockquote><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/30.png"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/31.png"></p><h2 id="打包验证"><a href="#打包验证" class="headerlink" title="打包验证"></a>打包验证</h2><p>输入网址或者点击Xcode Perferences中的Account，点击Xcode Server对应的地址链接，进入网址（这里是icocos.local对应ip是10.0.6.7），这里可以在当前服务器进行操作，也可以在配置Xcode的时候创建的那个帐号进行操作，同意可以在内网的其他端系统或者浏览器进行操作</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/32.png"></p><p>然后就会有一打包的进度……</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/33.png"></p><h2 id="错误总结"><a href="#错误总结" class="headerlink" title="错误总结"></a>错误总结</h2><h4 id="错误问题一："><a href="#错误问题一：" class="headerlink" title="错误问题一："></a>错误问题一：</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/40.png"></p><ul><li>问题原因：</li><li>因为没有登录对应的Git帐号或者没有打包对应项目的workspace</li></ul><h4 id="错误问题二："><a href="#错误问题二：" class="headerlink" title="错误问题二："></a>错误问题二：</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/41.png"></p><ul><li>问题原因：</li><li>同样是因为没有登录对应的Git帐号</li></ul><h4 id="错误问题三："><a href="#错误问题三：" class="headerlink" title="错误问题三："></a>错误问题三：</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/43.png"></p><ul><li>问题原因：</li><li>同样是因为没有登录对应的Git帐号</li></ul><h4 id="错误问题四："><a href="#错误问题四：" class="headerlink" title="错误问题四："></a>错误问题四：</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/42.png"></p><ul><li>问题原因：</li><li>这里是由于创建Bots进行配置的时候，只需要打包功能就行了，那些什么分析,测试不需要,还有打包配置要选InHouse，不然打不了的</li></ul><h4 id="错误问题五："><a href="#错误问题五：" class="headerlink" title="错误问题五："></a>错误问题五：</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/45.png"></p><ul><li>问题原因：</li><li>由于升级了Xcode 9.1，和对应的Xcode Server不兼容，这里需要输入xcsd密码（也不知道是sm鬼），根据2017@swift大会的朋友经验：</li><li><code>备份/Library/Developer/XcodeServer，然后删除XcodeServer文件夹内容，重新前面的步骤就正常了。</code></li></ul><h4 id="错误问题六："><a href="#错误问题六：" class="headerlink" title="错误问题六："></a>错误问题六：</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/46.png"></p><ul><li>问题原因：</li><li>这其实不是sm错误 ，只是一个安全警告，解决方案：点击显示详细信息-&gt;继续访问网址，就可以了</li></ul><h4 id="错误问题七："><a href="#错误问题七：" class="headerlink" title="错误问题七："></a>错误问题七：</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/47.png"></p><ul><li>问题原因：</li><li>此问题困扰了很久，由于加入了GZIP库，但是….</li></ul><h4 id="错误问题八："><a href="#错误问题八：" class="headerlink" title="错误问题八："></a>错误问题八：</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/48.png"></p><ul><li>问题原因：</li><li>此问题困扰了很久，由于加入了GZIP库，但是….</li></ul><h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/91.png"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/92.png"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/93.png"><br><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/94.png"></p><p>这些问题目前没有找到好的解决方案，根据提示查找发现，证书，前面都没有问题……</p><h2 id="总结一"><a href="#总结一" class="headerlink" title="总结一"></a>总结一</h2><p>最后根据最新经验总结，最新版本Xcode 9.1配置其实非常简单了</p><ol><li>配置Xcode Perferences中Server &amp; Bots</li><li>创建并登录帐号</li><li>Xcode Perferences登录git，app，server帐号</li><li>Clone远程Git源代码，并打开保证正常编译</li><li>Create Bots并配置</li><li>重启相关服务，Server，Bots，Xcode，开始打包</li></ol><blockquote><p>注意：</p></blockquote><blockquote><blockquote><p>关于代码提交，不管使用Xcode还是其他方式，是没有关系的，Xcode服务指向的是master或者其他分支的服务器资源；<br>关于打包，项目配置里就做好证书等配置文件的选择；<br>内测的ipa包，可以结合蒲公英等平台作分发也是很方便的；<br>考虑是不是可以搞个脚本上传。</p></blockquote></blockquote><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/87.png"></p><p>打包过程中</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/88.png"></p><blockquote><p>通过 Xcode 中的 Integrate 查看进度我们不难发现，其实整个过程和我们手动打包的过程是一样的</p></blockquote><p>打包完成</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/newImages/XcodeServer/89.png"></p><p>但是这样可能享受不到OS X Server那样多而且好用的服务，不过如果只是需要简单的进行打包，配合测试进行验证，简单的发布引用还是可以满足的……..</p><h3 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h3><p>想了解更过关于Xcode Server配置与使用的，可以参考与学习下面的文章，笔者也是从下面的文章中一点一点学习的，并结合了朋友指点进行实战。</p><h5 id="3个官方文档："><a href="#3个官方文档：" class="headerlink" title="3个官方文档："></a>3个官方文档：</h5><ul><li><p><a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/PublishYourCodetoaSourceRepository.html#//apple_ref/doc/uid/TP40013292-CH8-SW1" target="_blank" rel="noopener">官方配置教程</a></p></li><li><p><a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/index.html#//apple_ref/doc/uid/TP40013292-CH1-SW1" target="_blank" rel="noopener">苹果开发指南</a></p></li><li><p><a href="https://help.apple.com/serverapp/mac/4.0/#/apd9148CA5C-96E5-43AC-97CE-CB1B1002F4DE" target="_blank" rel="noopener">OS X Server 帮助</a></p></li></ul><h5 id="简书教程："><a href="#简书教程：" class="headerlink" title="简书教程："></a>简书教程：</h5><ul><li><a href="http://www.jianshu.com/p/80cf70edfe27" target="_blank" rel="noopener">OS X Server 之 Xcode服务</a></li></ul><h5 id="手动打包流程"><a href="#手动打包流程" class="headerlink" title="手动打包流程"></a>手动打包流程</h5><ul><li><a href="http://www.jianshu.com/p/817686897ec1?open_source=weibo_search" target="_blank" rel="noopener">iOS App打包上架超详细流程</a></li></ul>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Xcode Server </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS——重整iOS技术（Fastlane完整打包流程）</title>
      <link href="/2016/04/09/iOS%E2%80%94%E2%80%94%E9%87%8D%E6%95%B4iOS%E6%8A%80%E6%9C%AF%EF%BC%88Fastlane%E5%AE%8C%E6%95%B4%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B%EF%BC%89/"/>
      <url>/2016/04/09/iOS%E2%80%94%E2%80%94%E9%87%8D%E6%95%B4iOS%E6%8A%80%E6%9C%AF%EF%BC%88Fastlane%E5%AE%8C%E6%95%B4%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>自从去年中旬电脑被我整挂了之后，大部分插件和脚本配置都失效了，重新安装也试了好几次，最近上班要上线了，不得不重新整理和配置一下，还好没有遇到什么坑……</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>项目即将进入阶段，每次都要点击那么多，频繁的打包脑子都要晕了，习惯了之前一行命令就搞定的我，只能花一个晚上加班整回之前的Fastlane。</p></blockquote><blockquote><p> 本文采用的方案是：Fastlane + 蒲公英 + ……。</p><blockquote><p>关于具体发布状态可以在这里（app-store, package, ad-hoc, enterprise, development）改，<br>当然后面会结合App store发布最近本文内容，同时支持jenkins或者其他持续集成系统.</p></blockquote></blockquote><h3 id="Fastlane安装"><a href="#Fastlane安装" class="headerlink" title="Fastlane安装"></a>Fastlane安装</h3><p>Fastlane是一套使用Ruby写的自动化工具集，用于iOS和Android的自动化打包、发布等工作，可以节省大量的时间。</p><p>安装过程如下：</p><h4 id="1-检查Ruby版本，需要2-0及以上版本。在终端输入以下命令确认："><a href="#1-检查Ruby版本，需要2-0及以上版本。在终端输入以下命令确认：" class="headerlink" title="1.检查Ruby版本，需要2.0及以上版本。在终端输入以下命令确认："></a>1.检查Ruby版本，需要2.0及以上版本。在终端输入以下命令确认：</h4><pre><code>ruby -v</code></pre><p>需要注意的是需要将gem的source改为<a href="https://gems.ruby-china.org/。" target="_blank" rel="noopener">https://gems.ruby-china.org/。</a><br>如何检查?在终端输入以下命令:</p><pre><code>gem sources</code></pre><p>结果应为：</p><pre><code>*** CURRENT SOURCES ***https://gems.ruby-china.org/</code></pre><h4 id="2-检查Xcode命令行工具是否安装。在终端输入以下命令："><a href="#2-检查Xcode命令行工具是否安装。在终端输入以下命令：" class="headerlink" title="2.检查Xcode命令行工具是否安装。在终端输入以下命令："></a>2.检查Xcode命令行工具是否安装。在终端输入以下命令：</h4><pre><code>xcode-select --install</code></pre><p>如果没有安装会进行安装。如果已经安装了则会提示：</p><pre><code>xcode-select: error: command line tools are already installed, use &quot;Software Update&quot; to install updates</code></pre><p> <img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0001.png" alt="曹理鹏(iCocos)-梦工厂"></p><h4 id="3-安装Fastlane"><a href="#3-安装Fastlane" class="headerlink" title="3.安装Fastlane"></a>3.安装Fastlane</h4><pre><code>sudo gem install fastlane --verbose</code></pre><p>如果出现以下错误：</p><pre><code>ERROR:  While executing gem ... (Errno::EPERM)    Operation not permitted - /usr/bin/rougify</code></pre><p>则输入以下命令：</p><pre><code>sudo gem install -n /usr/local/bin fastlane</code></pre><p> <img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0002.png" alt="曹理鹏(iCocos)-梦工厂"></p><h4 id="4-检查Fastlane是否正确安装。输入以下命令："><a href="#4-检查Fastlane是否正确安装。输入以下命令：" class="headerlink" title="4.检查Fastlane是否正确安装。输入以下命令："></a>4.检查Fastlane是否正确安装。输入以下命令：</h4><pre><code>fastlane --version</code></pre><p> <img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0003.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>可以看到Fastlane版本信息，我的是2.85.0。</p><h3 id="蒲公英的Fastlane插件安装"><a href="#蒲公英的Fastlane插件安装" class="headerlink" title="蒲公英的Fastlane插件安装"></a>蒲公英的Fastlane插件安装</h3><p>打开终端，进入你的项目工程的根目录，输入以下命令：</p><pre><code>fastlane add_plugin pgyer</code></pre><p>出现</p><pre><code>Plugin &apos;fastlane-plugin-pgyer&apos; was added to &apos;./fastlane/Pluginfile&apos;It looks like fastlane plugins are not yet set up for this project.fastlane will create a new Gemfile at path &apos;Gemfile&apos;This change is necessary for fastlane plugins to workShould fastlane modify the Gemfile at path &apos;Gemfile&apos; for you?(y/n)</code></pre><p>输入y按回车，出现</p><pre><code>Installing plugin dependencies...Successfully installed plugins</code></pre><p>便是安装成功了。</p><p> <img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0004.png" alt="曹理鹏(iCocos)-梦工厂"></p><h3 id="Fastlane配置"><a href="#Fastlane配置" class="headerlink" title="Fastlane配置"></a>Fastlane配置</h3><h4 id="1-打开终端，进入你的项目工程的根目录，输入以下命令："><a href="#1-打开终端，进入你的项目工程的根目录，输入以下命令：" class="headerlink" title="1.打开终端，进入你的项目工程的根目录，输入以下命令："></a>1.打开终端，进入你的项目工程的根目录，输入以下命令：</h4><pre><code>fastlane init</code></pre><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0005.png" alt="曹理鹏(iCocos)-梦工厂"></p><p>中间会让你输入苹果开发者账号的账号和密码，之后会在你项目工程的目录下生成一个fastlane文件夹，里面有Fastlane的配置文件，一个是Appfile文件，一个是Fastfile文件(如果要上传AppStore的话还有Deliverfile文件)。Appfile保存苹果开发者的相关信息、项目的相关信息等。Fastfile是运行脚本。</p><p> <img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0006.png" alt="曹理鹏(iCocos)-梦工厂"></p><h4 id="2-编辑Fastfile文件"><a href="#2-编辑Fastfile文件" class="headerlink" title="2.编辑Fastfile文件"></a>2.编辑Fastfile文件</h4><p>有时候一天需要打好几个包，为了区分，我们这里实现一个递增build号的功能。</p><h5 id="1-修改项目工程配置"><a href="#1-修改项目工程配置" class="headerlink" title="(1)修改项目工程配置"></a>(1)修改项目工程配置</h5><ul><li>修改Build Settings中的Versioning配置，Current Project Version随便填一个，Versioning System选择Apple Generic。</li></ul><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0007.png" alt="曹理鹏(iCocos)-梦工厂"></p><ul><li><p>修改Info.plist File路径</p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0008.png" alt="曹理鹏(iCocos)-梦工厂"></p></li></ul><h5 id="2-定义一个递增build号的函数，添加到Fastfile中"><a href="#2-定义一个递增build号的函数，添加到Fastfile中" class="headerlink" title="(2)定义一个递增build号的函数，添加到Fastfile中"></a>(2)定义一个递增build号的函数，添加到Fastfile中</h5><pre><code>def updateProjectBuildNumbercurrentTime = Time.new.strftime(&quot;%Y%m%d&quot;)build = get_build_number()if build.include?&quot;#{currentTime}.&quot;# =&gt; 为当天版本 计算迭代版本号lastStr = build[build.length-2..build.length-1]lastNum = lastStr.to_ilastNum = lastNum + 1lastStr = lastNum.to_sif lastNum &lt; 10lastStr = lastStr.insert(0,&quot;0&quot;)endbuild = &quot;#{currentTime}.#{lastStr}&quot;else# =&gt; 非当天版本 build 号重置build = &quot;#{currentTime}.01&quot;endputs(&quot;*************| 更新build #{build} |*************&quot;)# =&gt; 更改项目 build 号increment_build_number(build_number: &quot;#{build}&quot;)end</code></pre><h6 id="实现自动打包的完整Fastfile如下：可以直接拷贝修改"><a href="#实现自动打包的完整Fastfile如下：可以直接拷贝修改" class="headerlink" title="实现自动打包的完整Fastfile如下：可以直接拷贝修改"></a>实现自动打包的完整Fastfile如下：可以直接拷贝修改</h6><pre><code># 定义fastlane版本号 ---- 修改fastlane_version &quot;2.85.0&quot;# 定义打包平台default_platform :iosdef updateProjectBuildNumbercurrentTime = Time.new.strftime(&quot;%Y%m%d&quot;)build = get_build_number()if build.include?&quot;#{currentTime}.&quot;# =&gt; 为当天版本 计算迭代版本号lastStr = build[build.length-2..build.length-1]lastNum = lastStr.to_ilastNum = lastNum + 1lastStr = lastNum.to_sif lastNum &lt; 10lastStr = lastStr.insert(0,&quot;0&quot;)endbuild = &quot;#{currentTime}.#{lastStr}&quot;else# =&gt; 非当天版本 build 号重置build = &quot;#{currentTime}.01&quot;endputs(&quot;*************| 更新build #{build} |*************&quot;)# =&gt; 更改项目 build 号increment_build_number(build_number: &quot;#{build}&quot;)end#指定项目的scheme名称 ---- 修改scheme=&quot;Fiction_iOS&quot;#蒲公英api_key和user_key ---- 修改api_key=&quot;264c007c340157969a5e4da77637e60f&quot;user_key=&quot;3fdffa475f545097333473b980765ce1&quot;# 任务脚本platform :ios dolane :development_build do|options|branch = options[:branch]puts &quot;开始打development ipa&quot;updateProjectBuildNumber #更改项目build号# 开始打包gym(#输出的ipa名称output_name:&quot;#{scheme}_#{get_build_number()}&quot;,# 是否清空以前的编译信息 true：是clean:true,# 指定打包方式，Release 或者 Debugconfiguration:&quot;Release&quot;,# 指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, developmentexport_method:&quot;development&quot;,# 指定输出文件夹output_directory:&quot;./fastlane/build&quot;,)puts &quot;开始上传蒲公英&quot;# 开始上传蒲公英pgyer(api_key: &quot;#{api_key}&quot;, user_key: &quot;#{user_key}&quot;)endend</code></pre><blockquote><p>注意：<br>蒲公英的 api_key 和 user_key，开发者在自己账号下的 账号设置-API信息 中可以找到。打其它类型的包的方法与development类似，可自定义一个新的lane实现。</p></blockquote><h4 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h4><ul><li><p>在终端输入</p><ul><li>fastlane development_build</li></ul></li></ul><p>便会进行自动打包并上传蒲公英了。</p><h4 id="下面以执行流程"><a href="#下面以执行流程" class="headerlink" title="下面以执行流程"></a>下面以执行流程</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0009.png" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0010.png" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0011.png" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0012.png" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0013.png" alt="曹理鹏(iCocos)-梦工厂"></p><h4 id="下面以执行结果"><a href="#下面以执行结果" class="headerlink" title="下面以执行结果"></a>下面以执行结果</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0015.png" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/0014.png" alt="曹理鹏(iCocos)-梦工厂"></p><h4 id="再来三张：入口，选项与结果"><a href="#再来三张：入口，选项与结果" class="headerlink" title="再来三张：入口，选项与结果"></a>再来三张：入口，选项与结果</h4><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/000.png" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/111.png" alt="曹理鹏(iCocos)-梦工厂"></p><p><img src="https://raw.githubusercontent.com/iCocos/icocos_hexo_images/master/201801Images/fastlane/222.png" alt="曹理鹏(iCocos)-梦工厂"></p>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> iOS——重整iOS技术（Fastlane完整打包流程） </tag>
            
            <tag> 重整iOS技术（Fastlane完整打包流程） </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS——自动打包上传</title>
      <link href="/2016/04/04/iOS%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0/"/>
      <url>/2016/04/04/iOS%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0/</url>
      <content type="html"><![CDATA[<p>为了不去每次都做这些繁琐的操作，我们只能做一个懒得程序狗，也就是将整个过程进行脚本化……</p><a id="more"></a><p>之前写过一篇关于自动打包上传代码的教程，最近又开始需要上线APP，发现新版的Mac对之前的教程不支持了，就换了一种方式，这次试用fir.</p><p><a href="http://al1020119.github.io/blog/2016/12/26/ios-daobao/" target="_blank" rel="noopener">http://al1020119.github.io/blog/2016/12/26/ios-daobao/</a></p><h2 id="工作中一般两种情况，"><a href="#工作中一般两种情况，" class="headerlink" title="工作中一般两种情况，"></a>工作中一般两种情况，</h2><pre><code>1.打包Ad-Hoc给测试人员，或者内部人员测试2.打包product发布到App Store</code></pre><p>所以，为了不去每次都做这些繁琐的操作，我们只能做一个懒得程序狗，也就是将整个过程进行脚本化</p><h3 id="大概的步骤是"><a href="#大概的步骤是" class="headerlink" title="大概的步骤是"></a>大概的步骤是</h3><pre><code>写个bash脚本，执行自动打包iOS版本，到指定的目录 （有条件的公司，可以自己搭个小服务器，这样谁都可以随时随地的打包）将打包好的文件上传到fir.im (当然上传到自己公司的服务器或者任何地方都行，只是fir.im我一直用，觉得比较方便)开发一个内部使用的类似APPStore，上面放着自己公司的所有APP,每次有更新的时候，测试童鞋直接通过这个自己下载新APP就可以了</code></pre><h2 id="主要命令"><a href="#主要命令" class="headerlink" title="主要命令"></a>主要命令</h2><h3 id="编译workspace"><a href="#编译workspace" class="headerlink" title="编译workspace"></a>编译workspace</h3><pre><code>xcodebuild -workspace workspacename -scheme schemename -configuration [-configuration configurationname] clean build SYMROOT=(SYMROOT)</code></pre><h3 id="编译project"><a href="#编译project" class="headerlink" title="编译project"></a>编译project</h3><pre><code>xcodebuild -target targetname -configuration [-configuration configurationname] clean build SYMROOT=(SYMROOT)</code></pre><h3 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h3><pre><code>xcodebuild -list</code></pre><h3 id="xcrun打包ipa"><a href="#xcrun打包ipa" class="headerlink" title="xcrun打包ipa"></a>xcrun打包ipa</h3><pre><code>xcrun -sdk iphoneos PackageApplication -v projectName.app -o ipaName.ipa</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><pre><code>在终端输入：xcodebuild –help 或 –h查看具体的选项显示xcodebuildversion：xcodebuild –version显示当前系统安装的sdk：xcodebuild –showsdks显示当前目录下project Information：xcodebuild –list</code></pre><h3 id="xcodebuild-amp-xcrun"><a href="#xcodebuild-amp-xcrun" class="headerlink" title="xcodebuild&amp;xcrun"></a>xcodebuild&amp;xcrun</h3><pre><code>xcodebuild-&gt;Buildxcrun-&gt;Api</code></pre><h3 id="终端查看对应版本"><a href="#终端查看对应版本" class="headerlink" title="终端查看对应版本"></a>终端查看对应版本</h3><pre><code>iCocosdeiMac:115科技 iCocos$ xcrun --versionxcrun version 31.iCocosdeiMac:115科技 iCocos$ xcodebuild -versionXcode 8.2.1Build version 8C1002</code></pre><h3 id="xcodebuild-是苹果提供的打包项目或者工程的命令"><a href="#xcodebuild-是苹果提供的打包项目或者工程的命令" class="headerlink" title="xcodebuild 是苹果提供的打包项目或者工程的命令"></a>xcodebuild 是苹果提供的打包项目或者工程的命令</h3><pre><code>需要在包含 name.xcodeproj 的目录下执行 xcodebuild 命令，且如果该目录下有多个 projects，那么需要使用 -project 指定需要 build 的项目。在不指定 build 的 target 的时候，默认情况下会 build project 下的第一个 target当 build workspace 时，需要同时指定 -workspace 和 -scheme 参数，scheme 参数控制了哪些 targets 会被 build 以及以怎样的方式 build。有一些诸如 -list, -showBuildSettings, -showsdks 的参数可以查看项目或者工程的信息，不会对 build action 造成任何影响，放心使用。</code></pre><h3 id="使用xcodebuild和xcrun打包签名"><a href="#使用xcodebuild和xcrun打包签名" class="headerlink" title="使用xcodebuild和xcrun打包签名"></a>使用xcodebuild和xcrun打包签名</h3><p>我这里就使用公司项目作为测试，方便查找问题和后续打包上传</p><h3 id="1-终端输入"><a href="#1-终端输入" class="headerlink" title="1. 终端输入"></a>1. 终端输入</h3><pre><code>xcodebuild -project T 115科技.xcodeproj -target 115科技 -configuration Release xcodebuild -project T 曹理鹏(iCocos)-梦工厂.xcodeproj -target 曹理鹏(iCocos)-梦工厂 -configuration Debug </code></pre><h3 id="这是骚等所有走完之后就能看到对应的信息，表示build成功"><a href="#这是骚等所有走完之后就能看到对应的信息，表示build成功" class="headerlink" title="这是骚等所有走完之后就能看到对应的信息，表示build成功"></a>这是骚等所有走完之后就能看到对应的信息，表示build成功</h3><pre><code>Signing Identity: &quot;iPhone Developer: xxx(59xxxxxx)&quot;Provisioning Profile: &quot;iOS Team Provisioning Profile: *&quot;</code></pre><h3 id="且在该目录下会多出一个-build-目录，该目录下有-Release-iphoneos-和-曹理鹏-iCocos-梦工厂-build-文件，根据我们-build-configuration-配置的参数不同，Release-iphoneos-的文件名会不同。"><a href="#且在该目录下会多出一个-build-目录，该目录下有-Release-iphoneos-和-曹理鹏-iCocos-梦工厂-build-文件，根据我们-build-configuration-配置的参数不同，Release-iphoneos-的文件名会不同。" class="headerlink" title="且在该目录下会多出一个 build 目录，该目录下有 Release-iphoneos 和 曹理鹏(iCocos)-梦工厂.build 文件，根据我们 build -configuration 配置的参数不同，Release-iphoneos 的文件名会不同。"></a>且在该目录下会多出一个 build 目录，该目录下有 Release-iphoneos 和 曹理鹏(iCocos)-梦工厂.build 文件，根据我们 build -configuration 配置的参数不同，Release-iphoneos 的文件名会不同。</h3><p>在 Release-iphoneos 文件夹下，有我们需要的曹理鹏(iCocos)-梦工厂.app文件，但是要安装到真机上，我们需要将该文件导出为ipa文件，这里使用 xcrun 命令。</p><pre><code>xcrun -sdk iphoneos -v PackageApplication ./build/Release-iphoneos/曹理鹏(iCocos)-梦工厂.app -o ~/Desktop/曹理鹏(iCocos)-梦工厂.ipa</code></pre><p>这个时候桌面上就会出现一个曹理鹏(iCocos)-梦工厂.ipa文件，这就是我们平时Archive之后的问题，也正是我们所需要的ipa包</p><h3 id="但是xcodebuild期间我出现了一个这样的错误"><a href="#但是xcodebuild期间我出现了一个这样的错误" class="headerlink" title="但是xcodebuild期间我出现了一个这样的错误"></a>但是xcodebuild期间我出现了一个这样的错误</h3><pre><code>ld: library not found for -lAFNetworkingclang: error: linker command failed with exit code 1 (use -v to see invocation)** BUILD FAILED **The following build commands failed:Ld build/曹理鹏(iCocos)-梦工厂.build/Release-iphoneos/曹理鹏(iCocos)-梦工厂.build/Objects-normal/armv7/曹理鹏(iCocos)-梦工厂 normal armv7Ld build/曹理鹏(iCocos)-梦工厂.build/Release-iphoneos/曹理鹏(iCocos)-梦工厂.build/Objects-normal/arm64/曹理鹏(iCocos)-梦工厂 normal arm64(2 failures)</code></pre><h3 id="貌似是linker-command-failed-with-exit-code-1经典错误，但是然并卵，于是看了一下pingpong从零开始写个自动打包IPA脚本中的build方式，也有类似的问题。多谢pingpong帮我解决了这个问题。"><a href="#貌似是linker-command-failed-with-exit-code-1经典错误，但是然并卵，于是看了一下pingpong从零开始写个自动打包IPA脚本中的build方式，也有类似的问题。多谢pingpong帮我解决了这个问题。" class="headerlink" title="貌似是linker command failed with exit code 1经典错误，但是然并卵，于是看了一下pingpong从零开始写个自动打包IPA脚本中的build方式，也有类似的问题。多谢pingpong帮我解决了这个问题。"></a>貌似是linker command failed with exit code 1经典错误，但是然并卵，于是看了一下pingpong<a href="http://www.jianshu.com/p/97c97c2ec1ca" target="_blank" rel="noopener">从零开始写个自动打包IPA脚本</a>中的build方式，也有类似的问题。多谢pingpong帮我解决了这个问题。</h3><pre><code>iCocosdeiMac ios (develop) $ xcodebuild2016-05-02 13:05:04.623 xcodebuild[1015:16272] [MT] PluginLoading: Required plug-in compatibility UUID ACA8656B-FEA8-4B6D-8E4A-93F4C95C362C for plug-in at path &apos;~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/XcodeColors.xcplugin&apos; not present in DVTPlugInCompatibilityUUIDs2016-05-02 13:05:04.625 xcodebuild[1015:16272] [MT] PluginLoading: Required plug-in compatibility UUID ACA8656B-FEA8-4B6D-8E4A-93F4C95C362C for plug-in at path &apos;~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/OMColorSense.xcplugin&apos; not present in DVTPlugInCompatibilityUUIDs=== BUILD TARGET xxx OF PROJECT xxx WITH THE DEFAULT CONFIGURATION (Release) ===Check dependenciesWrite auxiliary fileswrite-file /Users/iCocos/Documents/code/xxx/ios/build/xxx.build/Release-iphoneos/xxx.build/xxx.hmapwrite-file /Users/iCocos/Documents/code/xxx/ios/build/xxx.build/Release-iphoneos/xxx.build/xxx-own-target-headers.hmapwrite-file /Users/iCocos/Documents/code/xxx/ios/build/xxx.build/Release-iphoneos/xxx.build/Script-492B764475E022A63FB67F55.sh</code></pre><h3 id="解决方案是：执行xcodebuild需要指定你所需要对应的workspace和scheme"><a href="#解决方案是：执行xcodebuild需要指定你所需要对应的workspace和scheme" class="headerlink" title="解决方案是：执行xcodebuild需要指定你所需要对应的workspace和scheme"></a>解决方案是：执行xcodebuild需要指定你所需要对应的workspace和scheme</h3><pre><code>xcodebuild -workspace /Users/iCocos/Desktop/MBA/最新Git源代码/曹理鹏(iCocos)-梦工厂/曹理鹏(iCocos)-梦工厂.xcworkspace -scheme 曹理鹏(iCocos)-梦工厂</code></pre><h3 id="执行前，先查看下-list-这个可以知道xcodebuild命令下对应的参数需要填写的内容"><a href="#执行前，先查看下-list-这个可以知道xcodebuild命令下对应的参数需要填写的内容" class="headerlink" title="执行前，先查看下-list,这个可以知道xcodebuild命令下对应的参数需要填写的内容"></a>执行前，先查看下-list,这个可以知道xcodebuild命令下对应的参数需要填写的内容</h3><pre><code>iCocosdeiMac ios (develop) $ xcodebuild -list2016-05-02 15:24:26.656 xcodebuild[16535:154176] [MT] PluginLoading: Required plug-in compatibility UUID ACA8656B-FEA8-4B6D-8E4A-93F4C95C362C for plug-in at path &apos;~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/XcodeColors.xcplugin&apos; not present in DVTPlugInCompatibilityUUIDs2016-05-02 15:24:26.661 xcodebuild[16535:154176] [MT] PluginLoading: Required plug-in compatibility UUID ACA8656B-FEA8-4B6D-8E4A-93F4C95C362C for plug-in at path &apos;~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/OMColorSense.xcplugin&apos; not present in DVTPlugInCompatibilityUUIDsInformation about project &quot;xxx&quot;:Targets:xxxxxxTestsBuild Configurations:DebugReleaseIf no build configuration is specified and -scheme is not passed then &quot;Release&quot; is used.Schemes:xxx</code></pre><h3 id="然后，成功了-如下："><a href="#然后，成功了-如下：" class="headerlink" title="然后，成功了,如下："></a>然后，成功了,如下：</h3><pre><code>Entitlements:{&quot;application-identifier&quot; = &quot;L64TE3S9T9.com.曹理鹏(iCocos)-梦工厂.shaoshang&quot;;&quot;aps-environment&quot; = development;&quot;com.apple.developer.pass-type-identifiers&quot; =     (&quot;L64TE3S9T9.*&quot;);&quot;com.apple.developer.team-identifier&quot; = L64TE3S9T9;&quot;get-task-allow&quot; = 1;}builtin-productPackagingUtility -entitlements -format xml -o /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Intermediates/曹理鹏(iCocos)-梦工厂.build/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.build/曹理鹏(iCocos)-梦工厂.app.xcentCodeSign /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Products/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.appcd /Users/iCocos/Desktop/MBA/最新Git源代码/曹理鹏(iCocos)-梦工厂export CODESIGN_ALLOCATE=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/codesign_allocateexport PATH=&quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/Users/iCocos/.rvm/gems/ruby-2.3.0/bin:/Users/iCocos/.rvm/gems/ruby-2.3.0@global/bin:/Users/iCocos/.rvm/rubies/ruby-2.3.0/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/iCocos/.rvm/bin:/usr/local/mysql/bin/mysql&quot;Signing Identity:     &quot;iPhone Developer: Songbai He (73N6HPPJDP)&quot;Provisioning Profile: &quot;iOS Team Provisioning Profile: com.曹理鹏(iCocos)-梦工厂.shaoshang&quot;(34c1d23b-ade5-4d0f-9329-7b16009b30c2)/usr/bin/codesign --force --sign F8BAED0C84DB84AAA84769FED9FEAA9E80825C29 --entitlements /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Intermediates/曹理鹏(iCocos)-梦工厂.build/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.build/曹理鹏(iCocos)-梦工厂.app.xcent --timestamp=none /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Products/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.appValidate /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Products/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.appcd /Users/iCocos/Desktop/MBA/最新Git源代码/曹理鹏(iCocos)-梦工厂export PATH=&quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/Users/iCocos/.rvm/gems/ruby-2.3.0/bin:/Users/iCocos/.rvm/gems/ruby-2.3.0@global/bin:/Users/iCocos/.rvm/rubies/ruby-2.3.0/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/iCocos/.rvm/bin:/usr/local/mysql/bin/mysql&quot;export PRODUCT_TYPE=com.apple.product-type.applicationbuiltin-validationUtility /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Products/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.app** BUILD SUCCEEDED **</code></pre><h2 id="下面就是验证你全栈的时候到了，其实也没有那么难，就是一点脚本而已"><a href="#下面就是验证你全栈的时候到了，其实也没有那么难，就是一点脚本而已" class="headerlink" title="下面就是验证你全栈的时候到了，其实也没有那么难，就是一点脚本而已"></a>下面就是验证你全栈的时候到了，其实也没有那么难，就是一点脚本而已</h2><h3 id="先git-指令，pull到最新的分支"><a href="#先git-指令，pull到最新的分支" class="headerlink" title="先git 指令，pull到最新的分支"></a>先git 指令，pull到最新的分支</h3><pre><code># git updategit checkout $BRANCHNAMEif [ $? -ne 0 ]; thenexit 1figit pull #pod update --verbose --no-repo-updateif [ $? -ne 0 ]; thenexit 1fi</code></pre><h3 id="成功之后你同意会看到提示信息"><a href="#成功之后你同意会看到提示信息" class="headerlink" title="成功之后你同意会看到提示信息"></a>成功之后你同意会看到提示信息</h3><pre><code>logoutSaving session......copying shared history......saving history...truncating history files......completed.Deleting expired sessions...118 completed.</code></pre><h3 id="xcodebuild进行编译"><a href="#xcodebuild进行编译" class="headerlink" title="xcodebuild进行编译"></a>xcodebuild进行编译</h3><pre><code>xcodebuild \-workspace $SORCEPATH/曹理鹏(iCocos)-梦工厂.xcworkspace \-scheme $SCHEMENAMEPLQ \-configuration Debug \CODE_SIGN_IDENTITY=&quot;iPhone Developer: Songbai He(73N6HPPJDP)”  \PROVISIONING_PROFILE=&quot;com.曹理鹏(iCocos)-梦工厂.shaoshang&quot; \clean \build \-derivedDataPath $IPAPATH/$BRANCHNAME/$DATE</code></pre><h3 id="测试与发布只需要更改对应的参数即可"><a href="#测试与发布只需要更改对应的参数即可" class="headerlink" title="测试与发布只需要更改对应的参数即可"></a>测试与发布只需要更改对应的参数即可</h3><pre><code>-configuration Debug-configuration Release</code></pre><h2 id="用xcrun打包成ipa包"><a href="#用xcrun打包成ipa包" class="headerlink" title="用xcrun打包成ipa包"></a>用xcrun打包成ipa包</h2><pre><code>xcrun -sdk iphoneos PackageApplication \-v $IPAPATH/Build/Products/Debug-iphoneos/$SCHEMENAME.app \-o $IPAPATH/$IPANAME</code></pre><h2 id="生成ipa包，上传到fir-im"><a href="#生成ipa包，上传到fir-im" class="headerlink" title="生成ipa包，上传到fir.im"></a>生成ipa包，上传到fir.im</h2><h3 id="一：1-注册fir-拿到token"><a href="#一：1-注册fir-拿到token" class="headerlink" title="一：1.注册fir.拿到token"></a>一：1.注册fir.拿到token</h3><pre><code>fir.im官网：https://fir.im</code></pre><p>注册号账号，点击右上角个人信息，进入API token 拿到token，并保存</p><h3 id="二：安装fir-cli"><a href="#二：安装fir-cli" class="headerlink" title="二：安装fir-cli"></a>二：安装fir-cli</h3><pre><code>fir-cli 使用 Ruby 构建, 无需编译, 只要安装相应 gem 即可.$ ruby -v # &gt; 1.9.3$ gem install fir-cli</code></pre><h3 id="三：Mac新版之后可能由于源的问题导致无法安装（由于10-11引入了-rootless-无法直接安装-fir-cli）"><a href="#三：Mac新版之后可能由于源的问题导致无法安装（由于10-11引入了-rootless-无法直接安装-fir-cli）" class="headerlink" title="三：Mac新版之后可能由于源的问题导致无法安装（由于10.11引入了 rootless, 无法直接安装 fir-cli）"></a>三：Mac新版之后可能由于源的问题导致无法安装（由于10.11引入了 rootless, 无法直接安装 fir-cli）</h3><p>一般都是这么安装的：使用 Homebrew 及 RVM 安装 Ruby, 再安装 fir-cli</p><pre><code>Install Homebrew:$ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;Install RVM:$ \curl -sSL https://get.rvm.io | bash -s stable --rubyInstall fir-cli:$ gem install fir-cli</code></pre><h3 id="四：在终端登录并查看信息"><a href="#四：在终端登录并查看信息" class="headerlink" title="四：在终端登录并查看信息"></a>四：在终端登录并查看信息</h3><ol><li>$ fir login  </li></ol><p>按照提示输入token,然后</p><pre><code>iCocosdeiMac:曹理鹏(iCocos)-梦工厂 iCocos$ fir login  Please enter your fir.im API Token: 849ad212b94683b4c3087248d422d124I, [2017-04-18T13:58:01.184043 #14531]  INFO -- : Login succeed, previous user&apos;s email: al10201119@163.comI, [2017-04-18T13:58:01.185131 #14531]  INFO -- : Login succeed, current  user&apos;s email: al10201119@163.comI, [2017-04-18T13:58:01.185223 #14531]  INFO -- : </code></pre><ol start="2"><li><p>$fir me</p><p>登录成功,就会显示用户信息</p><p> I, [2017-04-18T13:58:21.876164 #14545]  INFO – : Login succeed, current user’s email: <a href="mailto:al10201119@163.com" target="_blank" rel="noopener">al10201119@163.com</a><br> I, [2017-04-18T13:58:21.876246 #14545]  INFO – : Login succeed, current user’s name:  al10201119<br> I, [2017-04-18T13:58:21.876261 #14545]  INFO – : </p></li></ol><ol start="3"><li>使用fir指令，上传我们的ipa包</li></ol><pre><code>fir login -T c525718a775b954882xxxxxxxx       # fir.im tokenfir publish $IPAPATH/Develop/xxx.ipa</code></pre><ol start="4"><li><p>最后你会看到</p><p> 恭喜！！！上传fir.im成功！</p></li></ol><h2 id="也可以直接使用执行脚本"><a href="#也可以直接使用执行脚本" class="headerlink" title="也可以直接使用执行脚本"></a>也可以直接使用执行脚本</h2><pre><code>#author iCocos#注意：脚本目录和xxxx.xcodeproj要在同一个目录，如果放到其他目录，请自行修改脚本。#工程名字(Target名字)Project_Name=&quot;Target名字，系统默认和工程名字一样&quot;#配置环境，Release或者DebugConfiguration=&quot;Release&quot;#AdHoc版本的Bundle IDAdHocBundleID=&quot;com.xxx&quot;#AppStore版本的Bundle IDAppStoreBundleID=&quot;com.xxx&quot;#enterprise的Bundle IDEnterpriseBundleID=&quot;com.xxx&quot;# ADHOC#证书名#描述文件ADHOCCODE_SIGN_IDENTITY=&quot;iPhone Distribution: xxxx&quot;ADHOCPROVISIONING_PROFILE_NAME=&quot;xxxx-xxxx-xxxx-xxxx&quot;#AppStore证书名#描述文件APPSTORECODE_SIGN_IDENTITY=&quot;iPhone Distribution: xxxx&quot;APPSTOREROVISIONING_PROFILE_NAME=&quot;xxxx-xxxx-xxxx-xxxx&quot;#企业(enterprise)证书名#描述文件ENTERPRISECODE_SIGN_IDENTITY=&quot;iPhone Distribution: xxxxx&quot;ENTERPRISEROVISIONING_PROFILE_NAME=&quot;xxxx-xxxx-xxxx-xxxx&quot;#加载各个版本的plist文件ADHOCExportOptionsPlist=./ADHOCExportOptionsPlist.plistAppStoreExportOptionsPlist=./AppStoreExportOptionsPlist.plistEnterpriseExportOptionsPlist=./EnterpriseExportOptionsPlist.plistADHOCExportOptionsPlist=${ADHOCExportOptionsPlist}AppStoreExportOptionsPlist=${AppStoreExportOptionsPlist}EnterpriseExportOptionsPlist=${EnterpriseExportOptionsPlist}echo &quot;~~~~~~~~~~~~选择打包方式(输入序号)~~~~~~~~~~~~~~~&quot;echo &quot;  1 appstore&quot;echo &quot;  2 adhoc&quot;echo &quot;  3 enterprise&quot;# 读取用户输入并存到变量里read parametersleep 0.5method=&quot;$parameter&quot;# 判读用户是否有输入if [ -n &quot;$method&quot; ]then#clean下xcodebuild clean -xcodeproj ./$Project_Name/$Project_Name.xcodeproj -configuration $Configuration -alltargetsif [ &quot;$method&quot; = &quot;1&quot; ]then#appstore脚本xcodebuild -project $Project_Name.xcodeproj -scheme $Project_Name -configuration $Configuration -archivePath build/$Project_Name-appstore.xcarchive clean archive build  CODE_SIGN_IDENTITY=&quot;${APPSTORECODE_SIGN_IDENTITY}&quot; PROVISIONING_PROFILE=&quot;${APPSTOREROVISIONING_PROFILE_NAME}&quot; PRODUCT_BUNDLE_IDENTIFIER=&quot;${AppStoreBundleID}&quot;xcodebuild -exportArchive -archivePath build/$Project_Name-appstore.xcarchive -exportOptionsPlist $AppStoreExportOptionsPlist -exportPath ~/Desktop/$Project_Name-appstore.ipaelif [ &quot;$method&quot; = &quot;2&quot; ]then#adhoc脚本xcodebuild -project $Project_Name.xcodeproj -scheme $Project_Name -configuration $Configuration -archivePath build/$Project_Name-adhoc.xcarchive clean archive build CODE_SIGN_IDENTITY=&quot;${ADHOCCODE_SIGN_IDENTITY}&quot; PROVISIONING_PROFILE=&quot;${ADHOCPROVISIONING_PROFILE_NAME}&quot; PRODUCT_BUNDLE_IDENTIFIER=&quot;${AdHocBundleID}&quot;xcodebuild -exportArchive -archivePath build/$Project_Name-adhoc.xcarchive -exportOptionsPlist $ADHOCExportOptionsPlist -exportPath ~/Desktop/$Project_Name-adhoc.ipaelif [ &quot;$method&quot; = &quot;3&quot; ]then#企业打包脚本xcodebuild -project $Project_Name.xcodeproj -scheme $Project_Name -configuration $Configuration -archivePath build/$Project_Name-enterprise.xcarchive clean archive build CODE_SIGN_IDENTITY=&quot;${ENTERPRISECODE_SIGN_IDENTITY}&quot; PROVISIONING_PROFILE=&quot;${ENTERPRISEROVISIONING_PROFILE_NAME}&quot; PRODUCT_BUNDLE_IDENTIFIER=&quot;${EnterpriseBundleID}&quot;xcodebuild -exportArchive -archivePath build/$Project_Name-enterprise.xcarchive -exportOptionsPlist $EnterpriseExportOptionsPlist -exportPath ~/Desktop/$Project_Name-enterprise.ipaelseecho &quot;参数无效....&quot;exit 1fifi</code></pre><p>这里还有一个大神使用PHP干了一票，虽然还在学习PHP中，但是有机会也要试一下</p><blockquote><p>这里目前只是实现了Ad-Hoc打包上传，关于App Store其实也就是更改参数，和对应的地址，后续会退出相应的文章界面具体实战……</p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> iOS——自动打包上传 </tag>
            
            <tag> 自动打包上传 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>带你简单理解block和__block的实现？</title>
      <link href="/2016/03/25/%E5%B8%A6%E4%BD%A0%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3block%E5%92%8C-block%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F/"/>
      <url>/2016/03/25/%E5%B8%A6%E4%BD%A0%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3block%E5%92%8C-block%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>其实类似block和__block的实现网上随便一搜就能找到无数篇，有些分析的确实非常不错，但是或许有些人刚好就没有那个耐心去看完，有些人就算最后看完也没有理解，甚至还是没能理解其中的核心,所以这里我就根据个人的理解和网上资料的整理，简单的总结一下……</p><a id="more"></a><h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><pre><code>1.Block其实是闭包2.Block是基于C语言的拓展3.Block是基于指针和函数指针实现的，4.同时他也是一种匿名函数，而且你会发现他和函数其实有很多相似的地方5.通过打印我们可以知道他其实是一种的结构体</code></pre><h3 id="block的实现"><a href="#block的实现" class="headerlink" title="block的实现"></a>block的实现</h3><pre><code>Block是被设为_NSConcreteStackBlock，在栈上生成。当我们把Block作为全局变量使用时，对应生成的Block将被设为_NSConcreteGlobalBlock</code></pre><h3 id="Block属性"><a href="#Block属性" class="headerlink" title="Block属性"></a>Block属性</h3><p>这里还有一点关于block类型的ARC属性。上文也说明了，ARC会自动帮strong类型且捕获外部变量的block进行copy，所以在定义block类型的属性时也可以使用strong，不一定使用copy。也就是以下代码：</p><pre><code>/** 假如有栈block赋给以下两个属性 **/// 这里因为ARC，当栈block中会捕获外部变量时，这个block会被copy进堆中// 如果没有捕获外部变量，这个block会变为全局类型// 不管怎么样，它都脱离了栈生命周期的约束@property (strong, nonatomic) Block *strongBlock;// 这里都会被copy进堆中@property (copy, nonatomic) Block *copyBlock;</code></pre><h3 id="block-1"><a href="#block-1" class="headerlink" title="__block"></a>__block</h3><pre><code>Block不允许修改外部变量的值，这里所说的外部变量的值，指的是栈中指针的内存地址。__block 所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。</code></pre><blockquote><p>总结就是：__block对象在block中是可以被修改、重新赋值的。</p></blockquote><h3 id="block的实现-1"><a href="#block的实现-1" class="headerlink" title="__block的实现"></a>__block的实现</h3><pre><code>__block其实是堆栈的拷贝，</code></pre><p>首先<strong>block修饰的变量会变成</strong>block_bref_val_0的结构体，它包含实例变量本身__forwarding(用于访问局部变量val)。</p><p>block拷贝到堆上的时候：</p><pre><code>_val_0也会拷贝到堆上，局部变量销毁，block任然能对堆上的局部变量操作__forwarding替换为堆上的__block变量的地址栈上的_val_0结构体中的__forwarding指针也会指向堆上的结构体main函数或者blcok释放的时候，只是释放了栈上的东西，所有对局部变量的操作都已经移到了对上。</code></pre>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>带你简单理解weak和__weak的实现？</title>
      <link href="/2016/03/21/%E5%B8%A6%E4%BD%A0%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3weak%E5%92%8C-weak%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F/"/>
      <url>/2016/03/21/%E5%B8%A6%E4%BD%A0%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3weak%E5%92%8C-weak%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>其实类似weak和__weak的实现网上随便一搜就能找到无数篇，有些分析的确实非常不错，但是或许有些人刚好就没有那个耐心去看完，有些人就算最后看完也没有理解，甚至还是没能理解其中的核心,所以这里我就根据个人的理解和网上资料的整理，简单的总结一下……</p><a id="more"></a><h3 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h3><pre><code>字面含义就是弱引用,Objective-C中默认都是强引用的（strong）</code></pre><h3 id="weak的实现"><a href="#weak的实现" class="headerlink" title="weak的实现"></a>weak的实现</h3><p>Runtime维护了一个weak表，用于存储指向某个对象的所有weak指针。weak表其实是一个hash（哈希）表，Key是所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象的地址）数组。</p><h4 id="weak-的实现原理可以概括一下三步："><a href="#weak-的实现原理可以概括一下三步：" class="headerlink" title="weak 的实现原理可以概括一下三步："></a>weak 的实现原理可以概括一下三步：</h4><pre><code>1、初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。2、添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。3、释放时，调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。</code></pre><h3 id="weak-1"><a href="#weak-1" class="headerlink" title="__weak"></a>__weak</h3><pre><code>__weak修饰符的对象，作用等同于定义为weak的property。他并不会导致循环引用问题（通过苹果文档我们可以得出这样的结论），当原对象没有任何强引用的时候，弱引用指针也会被设置为nil。</code></pre><h3 id="weak的实现-1"><a href="#weak的实现-1" class="headerlink" title="__weak的实现"></a>__weak的实现</h3><pre><code>简单来说，系统有一个全局的 CFMutableDictionary 实例，来保存每个对象的 weak 指针列表，因为每个对象可能有多个 weak 指针，所以这个实例的值是 CFMutableSet（Array） 类型。</code></pre><p>剩下我们要做的，就是在引用计数变成 0 的时候，去这个全局的字典里面，找到所有的 weak 指针，将其值设置成 nil。如何做到这一点呢？Friday QA 上介绍了一种类似 KVO 实现的方式。当对象存在 weak 指针时，我们可以将这个实例指向一个新创建的子类，然后修改这个子类的 release 方法，在 release 方法中，去从全局的</p><p>CFMutableDictionary 字典中找到所有的 weak 对象，并且设置成 nil。我摘抄了 Friday QA 上的实现的核心代码，如下：</p><pre><code>Class subclass = objc_allocateClassPair(class, newNameC, 0);Method release = class_getInstanceMethod(class, @selector(release));Method dealloc = class_getInstanceMethod(class, @selector(dealloc));class_addMethod(subclass, @selector(release), (IMP)CustomSubclassRelease, method_getTypeEncoding(release));class_addMethod(subclass, @selector(dealloc), (IMP)CustomSubclassDealloc, method_getTypeEncoding(dealloc));objc_registerClassPair(subclass);</code></pre><blockquote><p>总结一句就是：一个通俗的解释就是，在Objective-C的运行时环境中，维护了一种weak表，这张哈希表用对象的首地址作为键，将由若干个<strong>weak修饰的指针自身的地址组成的数组作为值。当一个Objective-C对象被释放后，通过这个对象的起始地址来找到所有指向它的</strong>weak指针，并将它们指向nil。</p></blockquote><h4 id="weak的作用"><a href="#weak的作用" class="headerlink" title="__weak的作用"></a>__weak的作用</h4><pre><code>在Objective-C中，用__weak修饰的指针，会在所指向的那个Objective-C对象被释放后，自动指向nil。使用__weak来修饰指针，相比于__unsafe_unretained，可以帮助程序员减小访问野指针的风险，方便了程序员对内存的管理。</code></pre><h3 id="block和weak的区别"><a href="#block和weak的区别" class="headerlink" title="block和weak的区别"></a><strong>block和</strong>weak的区别</h3><p>前面提到了<strong>block，也大概说了一下其简单实现，所以这里总结一下</strong>block和__weak修饰符的区别：</p><pre><code>1.__block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型。2.__weak只能在ARC模式下使用，也只能修饰对象（NSString），不能修饰基本数据类型（int）。3.__block对象可以在block中被重新赋值，__weak不可以。4.__block对象在ARC下可能会导致循环引用，非ARC下会避免循环引用，__weak只在ARC下使用，可以避免循环引用。</code></pre>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 带你简单理解weak和__weak的实现？ </tag>
            
            <tag> 底层分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分类能添加属性吗？成员变量呢？为什么？</title>
      <link href="/2016/03/18/%E5%88%86%E7%B1%BB%E8%83%BD%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E5%90%97%EF%BC%9F%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%91%A2%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2016/03/18/%E5%88%86%E7%B1%BB%E8%83%BD%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E5%90%97%EF%BC%9F%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%91%A2%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>在iOS开发中，如果你要在不改变原来的类内容的基础上，为类增加一些方法，那么苹果提供了一个很好机制，那就是分类，当然我们平时可能比较多的是直接给他添加方法，并且我们清楚一点的是，我们还能给一个分类添加属性（使用关联对象），但是并不能添加成员变量，可是为什么刚好成员变量就不能连接呢……</p><a id="more"></a><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>概念：</p><pre><code>Category  分类是OC特有的语言，依赖于类。</code></pre><p>分类的作用：</p><pre><code>在不改变原来的类内容的基础上，为类增加一些方法。</code></pre><h3 id="分类增加属性和方法"><a href="#分类增加属性和方法" class="headerlink" title="分类增加属性和方法"></a>分类增加属性和方法</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>方法</p><pre><code>这里其实就不用做过多介绍了，只需要知道分类增加方法其实就和一个类增加一个方法一样。</code></pre><p>属性</p><pre><code>至于分类增加属性，只要使用到的就是Objective-C里面比较底层的一个技术Runtime，Runtime里面有个里面有个关联对象的概念，具体请查看官方或者相关资料，很简单。</code></pre><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>NO，NO，NO，分类是不能增加属性的，一定没办法，如果你有可以来找我，哈哈….</p><h4 id="为什么不能增加成员变量呢？"><a href="#为什么不能增加成员变量呢？" class="headerlink" title="为什么不能增加成员变量呢？"></a>为什么不能增加成员变量呢？</h4><pre><code>首先我们不能混淆了成员变量和属性的概念.Property是Property，Ivar是Ivar。分类里面不能添加Ivar是因为分类本身并不是一个真正的类（Objective-C中真正的类是有一个isa存在的），但是分类并没有自己的ISA .类最开始生成了很多基本属性，比如IvarList，MethodList，分类只会将自己的method attach到主类，并不会影响到主类的IvarList。</code></pre><p>这就是为什么分类里面不能增加成员变量的原因”</p><h3 id="类和分类的初始化"><a href="#类和分类的初始化" class="headerlink" title="类和分类的初始化"></a>类和分类的初始化</h3><pre><code>1.当程序启动时，就会加载项目中所有的类和分类，而且加载后会调用每个类和分类的+load方法，只会调用一次；2.当第一次使用某个类时，就会调用当前类的+initialize方法；3.先加载父类，再加载子类（先调用父类的+load方法，再调用子类的+load方法，最后调用分类的+load方法），先初始化父类，再初始化子类（先调用父类的+initialize方法，再调用子类的+initialize方法）。4.注意：在初始化的时候，如果在分类中重写了+initialize方法，则会覆盖掉父类的。5.重写+initialize方法可以监听类的使用情况。</code></pre>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>为什么调用nil的任何方法都不会崩溃？</title>
      <link href="/2016/03/15/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B0%83%E7%94%A8nil%E7%9A%84%E4%BB%BB%E4%BD%95%E6%96%B9%E6%B3%95%E9%83%BD%E4%B8%8D%E4%BC%9A%E5%B4%A9%E6%BA%83%EF%BC%9F/"/>
      <url>/2016/03/15/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B0%83%E7%94%A8nil%E7%9A%84%E4%BB%BB%E4%BD%95%E6%96%B9%E6%B3%95%E9%83%BD%E4%B8%8D%E4%BC%9A%E5%B4%A9%E6%BA%83%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>我们知道，在Objective-C消息和转发机制的背后有这样一个说法：调用没有实现或者不存在的方法，会导致App崩溃，但是如果你比较细心或者专门研究过消息和转发机制那么你应该听过这样的结论：</p><blockquote><p>Objective-C中调用nil的任何方法都不会崩溃，但是，为什么就不会崩溃呢？这里就简单分析一下具体的原因和底层的实现方式……</p></blockquote><a id="more"></a><h3 id="访问了一个已经被释放的对象"><a href="#访问了一个已经被释放的对象" class="headerlink" title="访问了一个已经被释放的对象"></a>访问了一个已经被释放的对象</h3><p>我们知道在不使用 ARC 的时候，内存要自己管理，这时重复或过早释放都有可能导致 Crash。</p><pre><code>NSObject * aObj = [[NSObject alloc] init];[aObj release];NSLog(@&quot;%@&quot;, aObj);</code></pre><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><pre><code>aObj 这个对象已经被释放，但是指针没有置空，这时访问这个指针指向的内存就会 Crash。</code></pre><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>使用前要判断非空，释放后要置空。正确的释放应该是:</p><pre><code>[aObj release];aObj = nil;</code></pre><p>由于ObjC的特性，调用 nil 指针的任何方法相当于无作用，所以即使有人在使用这个指针时没有判断至少还不会挂掉。</p><h2 id="那么这里就有一个问题？"><a href="#那么这里就有一个问题？" class="headerlink" title="那么这里就有一个问题？"></a>那么这里就有一个问题？</h2><pre><code>为什么调用nil的任何方法都不会崩溃呢？</code></pre><p>首先在Objective-C里，nil对象被设计来跟NULL空指针关联的。他们的区别就是nil是一个对象，而NULL只是一个值。而且我们对于nil调用方法，不会产生crash或者抛出异常。这个技术被framework通过多种不同的方式使用。</p><pre><code>最主要的就是我们现在在调用方法之前根本无须去检查这个对象是否是nil。假如我们调了nil对象的一个有返回值的方法，那么我们会得到一个nil返回值。</code></pre><p>我们先来看看这断代码：</p><pre><code>- (void) dealloc{    self.caption = nil;    self.photographer = nil;    [super dealloc];}</code></pre><h2 id="具体原因"><a href="#具体原因" class="headerlink" title="具体原因"></a>具体原因</h2><p>　　之所以可以这么做是因为我们给把nil对象设给了一个成员变量，setter就会retain nil对象(当然了这个时候nil对象啥事情也不会做)然后release旧的对象。这个方式来释放对象其实更好，因为这样做的话，成员变量连指向随机数据的机会都没有，而通过别的方式，出现指向随机数据的情形机会不可避免。</p><p>注意到我们调用的self.VAR这样的语法，这表示我们正在用setter，而且不会引起任何内存问题。假如我们直接去设值的话，就会有内存溢出：</p><pre><code>// incorrect. causes a memory leak.// use self.caption to Go through settercaption = nil;</code></pre><h3 id="这里进入提到了崩溃，那么就大概整理一下开发中常见的崩溃问题和类型，方便提前预防和部分相关处理"><a href="#这里进入提到了崩溃，那么就大概整理一下开发中常见的崩溃问题和类型，方便提前预防和部分相关处理" class="headerlink" title="这里进入提到了崩溃，那么就大概整理一下开发中常见的崩溃问题和类型，方便提前预防和部分相关处理"></a>这里进入提到了崩溃，那么就大概整理一下开发中常见的崩溃问题和类型，方便提前预防和部分相关处理</h3><pre><code>一、访问了一个已经被释放的对象：nil，autorelease二、访问数组类对象越界或插入了空对象：分类或者runtime替换三、访问了不存在的方法：判断是否有，runtime修改四、字节对齐：使用 memcpy 来作内存拷贝，而不是直接对指针赋值五、堆栈溢出（过多的递归会导致栈溢出，过多的 alloc 变量会导致堆溢出。）六、多线程并发操作：加锁 ，原子，Operation Objects, GCD, Idle-time notifications, Asynchronous functions, Timers, Separate processes。七、Repeating NSTimer：写了个宏用来释放Timer</code></pre>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>生命之源-RunLoop</title>
      <link href="/2016/03/09/%E7%94%9F%E5%91%BD%E4%B9%8B%E6%BA%90-RunLoop/"/>
      <url>/2016/03/09/%E7%94%9F%E5%91%BD%E4%B9%8B%E6%BA%90-RunLoop/</url>
      <content type="html"><![CDATA[<p>iOS一切的生命之源都需要RunLoop的支持，关于RunLoop的界面和相关知识，网上想你一一搜一天也看不完，所以这里只为总结Runloop相关技术，适用于底层，面试，简单实战了解！</p><a id="more"></a><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ 一个线程只能执行一个任务，任务执行完之后，线程就会退出，但是主线程不会退出，因为我们需要让主线程等待接收事件</span><br></pre></td></tr></table></figure><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ 运行循环（<span class="keyword">do</span>-while）：不断处理各种事件</span><br><span class="line">+ 一个线程（唯一）对应一个RunLoop（可以嵌套子runloops），主线程默认启动，子线程手动启动（run）：获取RunLoop对象的时候，就会创建RunLoop</span><br><span class="line">+ RunLoop有多个Model，Model有多个timer（array）/<span class="built_in">source</span>（<span class="built_in">set</span>）/observer（array）。</span><br><span class="line">+ 每次启动只能启动一个，切换需要先推出在指定（分隔不同time/<span class="built_in">source</span>/observer）</span><br><span class="line">+ 当前Model没有任何timer/<span class="built_in">source</span>/observer就会推出（mode只能添加不能删除）</span><br><span class="line">+ 第一次获取创建，线程结束销毁</span><br></pre></td></tr></table></figure><h3 id="runloop退出的条件："><a href="#runloop退出的条件：" class="headerlink" title="runloop退出的条件："></a>runloop退出的条件：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app退出；线程关闭；设置最大时间到期；modeItem为空；</span><br></pre></td></tr></table></figure><h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ CFRunLoopTimerRef，基于时间触发（NSTimer），受Model影响，GCD不受Model影响</span><br><span class="line">+ CFRunLoopSourceRef，事件源，source0（非Port），source1（Port），跟Port密切联系</span><br><span class="line"></span><br><span class="line">source0：event事件，只含有回调，需要标记待处理（signal），然后手动将runloop唤醒（wakeup）；</span><br><span class="line">source1 ：包含一个 mach_port 和一个回调，被用于通过内核和其他线程发送的消息，能主动唤醒runloop。</span><br></pre></td></tr></table></figure><h3 id="Runloop本质：mach-port和mach-msg-。"><a href="#Runloop本质：mach-port和mach-msg-。" class="headerlink" title="Runloop本质：mach port和mach_msg()。"></a>Runloop本质：mach port和mach_msg()。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mach是XNU的内核，进程、线程和虚拟内存等对象通过端口发消息进行通信，Runloop通过mach_msg()函数发送消息，如果没有port 消息，内核会将线程置于等待状态 mach_msg_trap() 。如果有消息，判断消息类型处理事件，并通过modeItem的callback回调(处理事件的具体执行是在DoBlock里还是在回调里目前我还不太明白？？？)。</span><br><span class="line"></span><br><span class="line">Runloop有两个关键判断点，一个是通过msg决定Runloop是否等待，一个是通过判断退出条件来决定Runloop是否循环</span><br></pre></td></tr></table></figure><h3 id="定时源，输入源"><a href="#定时源，输入源" class="headerlink" title="定时源，输入源"></a>定时源，输入源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ 定时源，同步消息，特定或者一定时间间隔发生</span><br><span class="line">+ 输入源，来自起来线程或者程序</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ NSTimer，ImageView显示，PerformSelector，常驻线程，自动释放池，界面刷新，手势识别，GCD任务，timer：（与CADisplayLink），网络请求：</span><br></pre></td></tr></table></figure><h3 id="autorrelease释放时机："><a href="#autorrelease释放时机：" class="headerlink" title="autorrelease释放时机："></a>autorrelease释放时机：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ 手动干预释放：指定autorreleasepool,当前作用域大括号结束立即释放</span><br><span class="line">+ 系统自动释放：不指定，aut对象在当前RunLoop迭代结束释放</span><br></pre></td></tr></table></figure><h3 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">自动释放池寄生于Runloop：程序启动后，主线程注册了两个Observer监听runloop的进出与睡觉。一个最高优先级OB监测Entry状态；一个最低优先级OB监听BeforeWaiting状态和Exit状态。</span><br><span class="line">线程(创建)--&gt;runloop将进入--&gt;最高优先级OB创建释放池--&gt;runloop将睡--&gt;最低优先级OB销毁旧池创建新池--&gt;runloop将退出--&gt;最低优先级OB销毁新池--&gt;线程(销毁)</span><br></pre></td></tr></table></figure><h3 id="Timer注意"><a href="#Timer注意" class="headerlink" title="Timer注意"></a>Timer注意</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、如果是在主线程中运行timer，想要timer在某界面有视图滚动时，依然能正常运转，那么将timer添加到RunLoop中时，就需要设置mode 为NSRunLoopCommonModes。</span><br><span class="line">2、如果是在子线程中运行timer,那么将timer添加到RunLoop中后，Mode设置为NSDefaultRunLoopMode或NSRunLoopCommonModes均可，但是需要保证RunLoop在运行，且其中有任务。</span><br></pre></td></tr></table></figure><h3 id="runloop"><a href="#runloop" class="headerlink" title="runloop:"></a>runloop:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、（要让马儿跑）通过<span class="keyword">do</span>-while死循环让程序持续运行：接收用户输入，调度处理事件时间。</span><br><span class="line">2、（要让马儿少吃草）通过mach_msg()让runloop没事时进入<span class="built_in">trap</span>状态，节省CPU资源。</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 生命之源-RunLoop </tag>
            
            <tag> RunLoop </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前世-内存管理</title>
      <link href="/2016/03/03/%E5%89%8D%E4%B8%96-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2016/03/03/%E5%89%8D%E4%B8%96-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<p>最近越来越发觉，自己做了这么久iOS开发，似乎都是在瞎玩，回望这一路写的App，写的代码，以及上线的App，又有几个自己真的非常满意的？</p><blockquote><p>说道这里，不得不提的是：我相信不止我一个人有这种感触，代码写久了，自己都不知道自己在写撒，就连上线都是个意外。</p></blockquote><p>这一路走来我一直在总结，也在回望，到底自己哪里出了问题，终于发现：终究是自己不敢面对而已，底层不了解，只知道敲。</p><a id="more"></a><blockquote><p>因为换了电脑，换了工作，换了新的环境，也换了一个不一样的心情重新开始探索之路，所以之前的博客地址也停止更新了，如果你对iOS相关知识感兴趣或者有什么疑问和建议可以联系我，或者直接在下面评论，</p></blockquote><p>本来打算这个博客中不会再写iOS的东西，但是最近一直上班，也找了一段时间公司，总之感触不少，现在这个行情，大家都懂的。</p><p>前段时间也整理了一些东西，我相信值得一看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原则：没有强指针指向对象，对象就会被释放。</span><br></pre></td></tr></table></figure><h3 id="MRC-ARC"><a href="#MRC-ARC" class="headerlink" title="MRC-ARC"></a>MRC-ARC</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ARC：LLVM3.0（iOS5，Xcode4）</span><br><span class="line">前段编译器：方法内创建对象，末尾自动插入release销毁。类拥有对象，在dealloc内释放。更底层的C语言实现。objc_release,objc_retain优化调用过程</span><br><span class="line">ARC优化器：负责移除多余的插入，和一些引用的优化。包括运行期组件。</span><br></pre></td></tr></table></figure><h3 id="关于循环"><a href="#关于循环" class="headerlink" title="关于循环"></a>关于循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">weak：循环引用，自身强引用，IBOutlet。非拥有，不保留也不释放，置nil，weak必须用于OC对象，assign非OC对象</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>循环：只有当自动释放器被release，池中的表示autorrelease对象才会被释放===内存耗尽，没有释放-&gt;内存泄露</span><br><span class="line">1.i比较大：使用@autorreleasepool&#123;&#125;，在<span class="keyword">for</span>外面，循环结束，销毁创建对象，解决占据栈内存问题。</span><br><span class="line">2.i玩命大：一次循环都会自动释放池满，@autorreleasepool&#123;&#125;放在<span class="keyword">for</span>里面，每次循环前将上一次对象release。</span><br></pre></td></tr></table></figure><h3 id="关于内存"><a href="#关于内存" class="headerlink" title="关于内存"></a>关于内存</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">内存布局：没有多继承，所以布局简单</span><br><span class="line">最前面isa，指向类。父类实例变量在子类实例变量之前。</span><br></pre></td></tr></table></figure><h3 id="关于线程"><a href="#关于线程" class="headerlink" title="关于线程"></a>关于线程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">界面线程维护自己的线程池。自己创建的线程数据，需要创建线程的内存池。</span><br><span class="line"></span><br><span class="line">autorreleasepool实现：objc_autorreleasepool=Push,Pop,objc_autorrelease</span><br><span class="line"></span><br><span class="line">每次RunLoop完成一个循环的时候，都会检测对象的retainCount，为0则没有使用，释放。</span><br><span class="line"></span><br><span class="line">内存管理的范围：集成自NSObject对象，基本数据类型无效。因为存储空间不同，基本数据存在栈区。对象在堆中，代码块结束，涉及局部变量弹栈清空，指向对象指针回收，对象没有指针指向，但是还在堆中，所以内存泄露了。</span><br><span class="line"></span><br><span class="line">unowned（unsafe_unretained）：对象销毁不会为空，但是更快，因为weak需要unwrap。</span><br></pre></td></tr></table></figure><h3 id="常见状态管理"><a href="#常见状态管理" class="headerlink" title="常见状态管理"></a>常见状态管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">野指针:指针变量没有初始化，指向的空间被释放。调用方法报异常，崩溃。release后，地址nil，OC中没有空指针异常</span><br><span class="line">内存泄露：对象提前赋值nil，导致release不起作用。没有配对释放或者清空。栈区释放了，堆区没有释放。最终导致内存溢出</span><br><span class="line">内存溢出：容量超出使用限制</span><br><span class="line">僵尸对象：堆中已经被释放的对象count=0</span><br><span class="line">空指针：指针赋值为nil</span><br><span class="line"></span><br><span class="line">判断对象销毁：dealloc（需要super一下），已经释放的对象无法复活</span><br></pre></td></tr></table></figure><h3 id="对象关系"><a href="#对象关系" class="headerlink" title="对象关系"></a>对象关系</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">集成：</span><br><span class="line">组合：（包含关系），确保成员连边不被提前释放，重写<span class="built_in">set</span>方法，retain一下。成员变量在dealloc中配对释放。内存泄露：1.set没有retain对象，2.没有release旧对象，3.没有判断<span class="built_in">set</span>方法传入是否是同一对象</span><br><span class="line">依赖：（对象作为方法参数传递）</span><br></pre></td></tr></table></figure><h3 id="autorrelease（pool）-垃圾回收机制"><a href="#autorrelease（pool）-垃圾回收机制" class="headerlink" title="autorrelease（pool）/垃圾回收机制"></a>autorrelease（pool）/垃圾回收机制</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">autorrelease：把该对象放入自动释放池，自动释放池释放时，内部对象引用计数-1。</span><br><span class="line">NSAutorreleasePool：通过接受对象向他发送的release消息，记录该对象的release消息，自动释放池销毁时，向池中记录release的对象发送release消息。</span><br><span class="line"> </span><br><span class="line">垃圾回收机制：autorrelease只是延迟释放，GC是每隔一段时间询问程序，是否有无指针指向的对象，没有就释放</span><br></pre></td></tr></table></figure><h3 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">自动释放池：</span><br><span class="line">    1.存储多想对象类型的指针变量（可以嵌套）</span><br><span class="line">    2.作用：将对象与自动释放池建议关系，池子内调用autorrelease，在自动释放池销毁时销毁对象，延迟release销毁时间</span><br><span class="line">    3.对池内对象作用：存入池中的对象，池销毁，全部对象release一次</span><br><span class="line">    4.调用autorrelease将对象加入自动释放池，多次调用导致野指针异常</span><br><span class="line">    5.释放时机：简单：autorrelease的&#125;执行完后。实际：Autorrelease对象是在当前RunLoop迭代结束时释放，原因是：系统在每个RunLoop迭代中加入了自动释放池Push，Pop</span><br></pre></td></tr></table></figure><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">block中多次使用weakSelf（延迟操作，导致取不到弱指针），可以block种先使用strongSelf，防止执行是weakSelf意外释放，对于非ARCweak改为block就可以</span><br><span class="line"></span><br><span class="line">release和drain：ARC中一样，GC中release无效操作，所以无论是否为GC使用drain没有问题。</span><br><span class="line"></span><br><span class="line">copy：OC对象类型如果有mutable，深拷贝，新对象为count=1，没有为浅拷贝，count+1.</span><br></pre></td></tr></table></figure><h3 id="其他总结"><a href="#其他总结" class="headerlink" title="其他总结"></a>其他总结</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">通过Observer监听RunLoop状态，一旦监听到RunLoop即将进入休眠等状态，就释放自动释放池。</span><br><span class="line"></span><br><span class="line">FIFO：新访问的数据插入队列尾部，数据在队列中移动，淘汰头部数据。LRU（FIFO相反），LFU</span><br><span class="line"></span><br><span class="line">循环引用：定时器（timer作为类的成员变量，self-target,不使用记得invalidate），Blcok（block在copy时对内部对象强引用（ARC）或者引用计数+1（MRC）），代理：（assign（MRC），weak（ARC））</span><br><span class="line"></span><br><span class="line">通知：多对多，主要跨层传值。对象加入到通知中心后，对象被销毁前没有将对象从通知中心移除，当再次发送通知的时候，会崩溃。</span><br><span class="line"></span><br><span class="line">默认关键字：基本数据类型（atomic，readwrite，assign），OC对象类型（atomic，readwrite，strong）</span><br><span class="line"></span><br><span class="line">TableView代理用assign：控制器对内部的View进行了一次retain，TableView对代理控制器也retain一次就会循环引用。</span><br></pre></td></tr></table></figure><h3 id="其实知道了这个并不证明就能写出好的代码，还需要时间的沉淀，不断的尝试，不断的思考与总结。感谢你能看到最后，希望对你有用，我们下次再见！"><a href="#其实知道了这个并不证明就能写出好的代码，还需要时间的沉淀，不断的尝试，不断的思考与总结。感谢你能看到最后，希望对你有用，我们下次再见！" class="headerlink" title="其实知道了这个并不证明就能写出好的代码，还需要时间的沉淀，不断的尝试，不断的思考与总结。感谢你能看到最后，希望对你有用，我们下次再见！"></a>其实知道了这个并不证明就能写出好的代码，还需要时间的沉淀，不断的尝试，不断的思考与总结。感谢你能看到最后，希望对你有用，我们下次再见！</h3>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>温馨提示</title>
      <link href="/2016/03/01/%E6%B8%A9%E9%A6%A8%E6%8F%90%E7%A4%BA/"/>
      <url>/2016/03/01/%E6%B8%A9%E9%A6%A8%E6%8F%90%E7%A4%BA/</url>
      <content type="html"><![CDATA[<p>嗨，欢迎来到梦工厂，我是曹理鹏 (@iCocos)，一名 PHP开发工程师，前iOS(+游戏)/ 前端 开发者，希望做点有意义的事情。现居广州，正在修行，探求创意之源。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">微信：clpaial10201119 / QQ：2211523682</span><br><span class="line">博客(前后端)：https://icocos.github.io/</span><br><span class="line">github：https://github.com/al1020119</span><br><span class="line">个人网站：http://www.icocos.cn/</span><br></pre></td></tr></table></figure><a id="more"></a><p>由于学习，技术方向的原因，本人之前<a href="http://al1020119.github.io/" target="_blank" rel="noopener">github博客</a>将会停止更新，之前所有文章偏向技术，并且主要针对iOS基础，底层，面试与实战，此后将会停止更新此博客，并将所有新发布文章，更新至当前<a href="https://icocos.github.io/">博客</a>地址，届时会不定时在公众号，和微博发布相关动态。</p><ul><li>此博客将会保函以下内容：<ul><li>iOS实战经验(+游戏)</li><li>前端开发相关技术</li><li>后端开发实战/架构/优化</li><li>读书笔记与后感</li><li>个人业余爱好</li><li>其他原创杂文</li></ul></li></ul><p>如果你想了解更多关于作者，或者关于PHP后端开发，iOS/前后端，和个人关注内容，请关注我的个人公众号，也可以通过微信，QQ，Github联系我，也可以直接在这里评论留言。</p><p>同时，如果对我的文章有一些意见或者建议，也欢迎联系我，我们一起共进退！</p>]]></content>
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 温馨提示 </tag>
            
            <tag> iCocos </tag>
            
            <tag> 提示 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
