<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PHP拓展篇——Composer实战操作指南]]></title>
    <url>%2F2019%2F03%2F02%2FPHP%E6%8B%93%E5%B1%95%E7%AF%87%E2%80%94%E2%80%94Composer%E5%AE%9E%E6%88%98%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[Composer是什么玩过Linux或者玩过编程的应该都知道，yum、apt-get、npm、bower等命令，composer其实和上面是一样的，只是composer专门给PHP用。 就像iOS中的Pods，Carthage，Android中的gradle pod = cocoapods 编译成静态链接库或者动态框架文件，会修改Xcode项目属性配置依赖关系 Carthage 去中心化(无中心库), 非侵入性：动态框架，不会修改Xcode项目属性配置依赖关系 gradle(JCenter，mavenCenter，JitPack)。Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建开源工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，抛弃了基于XML的各种繁琐配置。面向Java应用为主。 而Composer 是 PHP5.3以上 的一个依赖管理工具。它允许你声明项目所依赖的代码库，它会在你的项目中为你快速安装他们。涉及 “packages” 和 “libraries”。平时我们安装一个PHP类库，需要搜索-&gt;下载；使用composer，我们只要知道包名，直接composer insatll就可以了。 Composer 也只是一段 PHP 脚本，用官方的话说就是： 是 PHP 用来管理依赖（dependency）关系的工具。你可以在自己的项目中声明所依赖的外部工具库（libraries），Composer 会帮你安装这些依赖的库文件。 Composer用途 安装PHP包、依赖库。 通过过composer，我们可以使用大量的第三方库，而无需自己造轮子 比如 monolog $ composer require monolog/monolog laravel $ composer create-project laravel/laravel learnlaravel5 5.0.22 thinkphp5：然后在命令行下面，切换到你的web根目录下面并执行下面的命令： $ composer create-project topthink/think=5.0.* tp5 –prefer-dist 你可以在 https://packagist.org/ 找到你需要的库。甚至你可以提交自己写的优秀的库到该平台里供大家使用。 安装废话不多说，直接上代码 安装 curl -sS https://getcomposer.org/installer | php 全局 mv composer.phar /usr/local/bin/composer 之后，就可以直接使用composer install安装包了。不过通常情况下只需将composer.phar的位置加入到PATH就可以，不一定要全局安装。 镜像 composer config -g repo.packagist composer https://packagist.phpcomposer.com 常见镜像地址： https://packagist.org 国外的 http://packagist.phpcomposer.com 中国全量镜像 https://pkg.phpcomposer.com/ https://www.phpcomposer.com/ 更新 composer self-update 操作执行结束，会在当前目录下生成composer.phar文件，在Linux里，composer.phar是可执行程序。 例如，我们可以使用php composer.phar update执行更新操作。 全局安装： mv composer.phar /usr/local/bin/composer 验证composer[parallels@centos-7 html]$ composer ______ / ____/___ ____ ___ ____ ____ ________ _____ / / / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/ / /___/ /_/ / / / / / / /_/ / /_/ (__ ) __/ / \____/\____/_/ /_/ /_/ .___/\____/____/\___/_/ /_/ Composer version 1.8.4 2019-02-11 10:52:10 Usage: command [options] [arguments] Options: ... version[parallels@centos-7 html]$ composer -V Composer version 1.8.4 2019-02-11 10:52:10 使用初始化在自己想要创建项目的地方新建一个文件夹，命名为 ComposerP1，在文件夹下新建文件 composer.json： { &quot;require&quot;: { } } 命令行切换到 ComposerP1 目录下，运行： composer update 就会在该目录下生成一个vendor文件夹。以后所有的第三扩展包都会安装在这里。 安装扩展包在项目目录下创建一个composer.json文件，指明依赖，比如，你的项目依赖 monolog： { &quot;require&quot;: { &quot;monolog/monolog&quot;: &quot;1.2.*&quot; }, &quot;config&quot;: { // 解决有时候因为https造成的问题 &quot;secure-http&quot;: false } } 安装依赖安装依赖非常简单，只需在项目目录下运行： composer install 如果没有全局安装的话，则运行： php composer.phar install 更新全部的包（谨慎使用）： composer update 注意：使用composer install或者composer update命令将会更新所有的扩展包，项目中使用需谨慎！！！若只安装指定的包推荐在命令行使用一下命名进行安装。 composer require monolog/monolog 如果需要指定版本： composer require “monolog/monolog:1.2.*” 更新某个包： composer update monolog/monolog 移除某个包： composer remove monolog/monolog 如果手动更新了composer.json需要更新autoload： composer dump-autoload 命令汇总 composer list 列出所有可用的命令 composer init 初始化composer.json文件(就不劳我们自己费力创建啦)，会要求输入一些信息来描述我们当前的项目，还会要求输入依赖包 composer install 读取composer.json内容，解析依赖关系，安装依赖包到vendor目录下 composer update 更新最新的依赖关系到compsoer.lock文件，解析最新的依赖关系并且写入* composer.lock文件 composer search packagename 搜索包，packagename替换为你想查找的包名称 composer require packagename 添加对packagename的依赖，packagename可修改为你想要的包名称 composer show packagename composer self-update 更新 composer.phar文件自身 composer dump-autoload –optimize 优化一下自动加载 composer command –help 以上所有命令都可以添加 –help选项查看帮助信息]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Composer</tag>
        <tag>依赖管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tp5入门——路由入门与实战]]></title>
    <url>%2F2019%2F01%2F15%2FTp5%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E8%B7%AF%E7%94%B1%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[路由 官方文档里面是这样子定义的=&gt;路由的作用是简化URL访问地址，并根据定义的路由类型做出正确的解析。 手动解释一下：平常我们按照习惯去访问我们的ThinkPHP项目的时候，常规的url应该是这样子写的，（本地举例）http://localhost/项目名/public/index.php/模块名/控制器名/方法名 一串url输进去之后，就会感觉很绝望，（小声吐槽）=&gt;“我只是想测试一个小接口让我打这么长一串地址、地址太长记不住呀……”。这个时候我们就可以用路由去简化他的地址，并且在缩短地址的同时进行一些规则的定义。 路由的作用： 简化URL地址，方便大家记忆 有利于搜索引擎的优化，比如可以被百度的爬虫抓取到 路由的三种模式： 普通模式 :完全使用PASH_INFO来访问，比如http://www.yd.com/index.php/index/index，域名+模块+控制器 混合模式 ：可以使用路由也可以不使用 强制模式 ：必须使用路由 注意：路由只针对应用，不针对模块，如果有些模块不像使用路由，需要在配置文件中关闭路由 //关闭admin模块的路由，必须写到加载框架引导文件之后\think\App::route(false); 普通模式：完全使用PASH_INFO来访问 // 是否开启路由‘url_route_on’ =&gt; false,// 是否强制使用路由‘url_route_must’ =&gt; false, 混合模式 // 是否开启路由‘url_route_on’ =&gt; true,// 是否强制使用路由‘url_route_must’ =&gt; false, 强制模式 // 是否开启路由‘url_route_on’ =&gt; true,// 是否强制使用路由‘url_route_must’ =&gt; false, 设置路由：一下直接修改application下的route.php 单个注册在application下的route.php文件内更改 use think\Route; //引入RouteRoute::rule(‘test’,’index/index/test’); //当URL访问http://com.test.php:8888/test时，访问的是index模块下的index下的控制器下的test方法 路由形式： 静态路由：Route::rule(‘/’,’index/index/index’);Route::rule(‘test’,’index/index/test’); 带参数的路由： Route::rule(‘time/:time’,’index/User/getTime’);http://com.test.php:8888/getTime/123456 可选参数的路由： Route::rule(‘time/[:time]/[:???]’,’index/User/getTime’);http://com.test.php:8888/getTimehttp://com.test.php:8888/getTime/123456 全动态路由(不推荐)： Route::rule(‘:X/:Y’,’index/User/getXY’);http://com.test.php:8888/11/22 完全匹配：Route::rule(‘rout$’=&gt;’index/User/getRout’);不加$符号，我们字comp后面加多少路径，比如http://com.test.php:8888/comp/asd/dfds/wer/ewr，页面都能输出 我是完全匹配路由 Route::rule(‘rout’,’index/User/getRout’);加上$符号，我们在comp后面加多少路径，比如http://com.test.php:8888/comp/comp/asd/dfds/wer/ewr，页面不能输出方法的内容 额外参数：Route::rule(‘test’,’index/index/test?id=1&amp;name=icocos’); 批量注册 rule方式Route::rule([ “test”=&gt;”index/index/test”, ‘time/:time’=&gt;’index/User/getTime’ ],’’,’get’); //post,put,delete get方式Route::get([ “test”=&gt;”index/index/test”, ‘time/:time’=&gt;’index/User/getTime’ ]); //post,put,delete 配置文件注册 return[ “test”=&gt;”index/index/test”, ‘time/:time’=&gt;’index/User/getTime’]; 路由的请求方式 一般请求方式有八种，但是TP里面有四种请求方式(GET，POST，PUT，DELETE)，其中GET，POST是最常用的，如果我们不指定请求类型，默认是*，所有的请求类型 支持get Route::rule(‘rtype’,’index/User/getRType’,’get’);Route::get(‘rtype’,’index/User/getRType’); 支持postRoute::post(‘rtype’,’index/User/getRType’); 既支持get有支持post Route::rule(‘rtype’,’index/User/getRType’,’get|post’); 支持全部请求方式 Route::any(‘rtype’,’index/User/getRType’);Route::rule(‘rtype’,’index/User/getRType’,’*’); 模拟PUT，DELETE 支持put请求 Route::put(‘rtype’,’index/User/getRType’);Route::rule(‘rtype’,’index/User/getRType’,’put’); 支持put请求 Route::delete(‘rtype’,’index/User/getRType’);Route::rule(‘rtype’,’index/User/getRType’,’delete’); 变量规则 Route::rule()；的最后一个参数，是一个数组，可以指定多个参数，用正则表达式来写，用来规范传入的参数必须是什么数据类型，或者必须是那些数据等等，比如 Route::rule(‘getid/:id’,’index/User/getId’,’get’,[],[‘id’=&gt;’\d’]); //最后一个参数，表示id传参数必须是数字 路由参数 Route::rule()；的倒数第二个参数，是一个数组，可以用来指定请求的数据类型，也可以用来规定请求的URL后缀，比如 Route::rule(‘getid/:id’,’index/User/getId’,’get’,[‘method’=&gt;’get’,’ext’=&gt;’html’],[‘id’=&gt;’\d’]);//请求方式必须是get,请求的后缀必须是html,访问的url为http://www.yd.com/getid/9.html，不带html后缀就请求失败 资源路由 你的后台模块可能会有增删改查等操作，但是一个一个写太费劲，资源路由自动帮你生这些路由，你只需要在控制器内写这些方法， 设置后会自动注册7个路由规则，如下： 标识 请求类型 生成路由规则 对应操作方法（默认）index GET blog indexcreate GET blog/create createsave POST blog saveread GET blog/:id readedit GET blog/:id/edit editupdate PUT blog/:id updatedelete DELETE blog/:id delete //先创建blocknamespace app\index\controller;class Block{public function index(){echo ‘我是前台模块下的block’;}public function create(){echo ‘我是前台模块下的block的create方法’;}public function read($id){echo $id;}}//然后在route.php下写上资源路由Route::resource(‘block’,’index/Block’); //效果：//当你访问http://com.test.php:8888/block URL访问的是index方法//当你访问http://com.test.php:8888/block/15 URL访问的是read方法//当你访问http://com.test.php:8888/block/create URL访问的是create方法 快捷路由 在index模块下创建一个Fastroute控制器，里面写下如下例子，除了index，其他方法都要加上get namespace app\index\controller;class Fastroute{public function index(){echo ‘我是Fast路由的index’;}public function getAA(){echo “我是getAA”;}public function getBB(){echo “我是BB”;}public function postInfo(){} public function putInfo(){} public function deleteInfo(){}} 在route.php里面写下快捷路由 //注意：路由名字要和控制器名字一样Route::controller(‘Fastroute’,’index/Fastroute’);//然后我们想访问getAA方法，我们可以通过访问URL http://com.test.php:8888/Fastroute/AA来访问//想访问getBB()，可以通过 http://com.test.php:8888/Fastroute/BB来访问 生成URL： 有两种方式 Url::build(‘index/User/index’);url(‘index/User/index’); 查看生成方式 dump(url(‘index/User/index’));dump(Url::build(‘index/User/index’)); 带参数url(‘index/User/index/id/10’);url(‘index/User/index/abc’,[‘id’=&gt;10,’name’=&gt;’icocos’]);url(‘index/User/index/abc’, ‘id=10&amp;name=icocos’);带锚点url(‘index/User/index/abc#name’, ‘id=10&amp;name=icocos’);带域名url(‘index/User/index/abc#name@blog’, ‘id=10&amp;name=icocos’); 加入口文件Url::root(‘/index.php’); //带入口文件]]></content>
  </entry>
  <entry>
    <title><![CDATA[Tp5入门——前后台分离]]></title>
    <url>%2F2019%2F01%2F13%2FTp5%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%89%8D%E5%90%8E%E5%8F%B0%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[最开始组内讨论的过程中我发现，每个人对前后端分离的理解不一样，为了保证能在同一个频道讨论，先就什么是”前后端分离”达成一致。 大家一致认同的前后端分离的例子就是SPA(Single-page application)，所有用到的展现数据都是后端通过异步接口(AJAX/JSONP)的方式提供的，前端只管展现。从某种意义上来说，SPA确实做到了前后端分离，但这种方式存在两个问题： WEB服务中，SPA类占的比例很少。很多场景下还有同步/同步+异步混合的模式，SPA不能作为一种通用的解决方案。现阶段的SPA开发模式，接口通常是按照展现逻辑来提供的，有时候为了提高效率，后端会帮我们处理一些展现逻辑，这就意味着后端还是涉足了View层的工作，不是真正的前后端分离。 SPA式的前后端分离，是从物理层做区分（认为只要是客户端的就是前端，服务器端的就是后端），这种分法已经无法满足我们前后端分离的需求，我们认为从职责上划分才能满足目前我们的使用场景： 前端：负责View和Controller层。 后端：只负责Model层，业务处理/数据等。 前后台分离 前台index中controller的index.php输入 &lt;?phpnamespace app\index\controller; class Index{public function index(){return “前台方法：index”;} public function test() {echo “前台方法：test”;}} 创建admin后台模块(index同级)，MVC中controller新建index.php &lt;?phpnamespace app\admin\controller; class Index { public function index(){return “后台方法：index”;} public function test() {echo “后台方法：test”;}} 访问结果 前台http://com.test.php:8888/index/indexhttp://com.test.php:8888/index/index/indexhttp://com.test.php:8888/index/index/test 后台http://com.test.php:8888/admin/indexhttp://com.test.php:8888/admin/index/indexhttp://com.test.php:8888/admin/index/test public中新增admin.php入口文件，index.php同级，且内容保持一致 访问结果：上面的访问结果还是一样，只是一下访问的都是前台http://com.test.php:8888/index.phphttp://com.test.php:8888/admin.php 实现绑定public中admin.php和index.php的定义应用目录和加载框架引导文件中间 // 定义应用目录define(‘APP_PATH’, DIR . ‘/../application/‘);//TODO: ….// 加载框架引导文件require DIR . ‘/../thinkphp/start.php’; 增加绑定 // 绑定后台模块define(“BIND_MODULE”, ‘admin’);// 绑定前台模块define(“BIND_MODULE”, ‘index’); 此时使用下面URL分别访问的是前台和后台http://com.test.php:8888/index.phphttp://com.test.php:8888/admin.php 条件是需要开启隐藏入口文件功能tp5默认开启: 文档，架构中有隐藏说明(原理就是正则) 同时可以关闭路由，在配置文件最后面增加 //关闭admin模块的路由，必须写到加载框架引导文件之后\think\App::route(false);]]></content>
  </entry>
  <entry>
    <title><![CDATA[Tp5入门——加载显示UI]]></title>
    <url>%2F2019%2F01%2F10%2FTp5%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%8A%A0%E8%BD%BD%E6%98%BE%E7%A4%BAUI%2F</url>
    <content type="text"><![CDATA[在thinkPHP的MVC模式中，V：(view)视图 就是用于承载php回显数据的html文档 加载显示UI：加载显示View index/controller下新建User.php控制里面写加载方法loadview // 系统函数 return View(); // View方式 $view = new \think\View; return $view-&gt;fetch(); // 在控制器方式：需要继承系统控制器类 $this-&gt;fetch(); controller同级目录新建View目录，里面新建user文件夹，里面新建loadview.html 其中View是前台模块中MVC的View模块，View里面的user文件夹对应controller下的User.php控制器(注意大小写)View里面的user文件夹中的html名字对应User.php中的loadview方法，注意名字相同 数据输入 return “iCocos”return json_encode(array(“name”=&gt;”name”,”age”=&gt;”age”)/[“name”=&gt;”name”,”age”=&gt;”age”])return “H1“ default_return_type =&gt; ‘html’/‘json’default_ajax_return =&gt; ‘json’ 控制器初始化 必须继承控制器 只要调用控制器的任务方法都会先找初始化方法 提取控制器公告代码，后台权限把控public function _initialize() { } 前置操作定义方法之前做的事情，把一些公共的设置提取成方法，进行调用，但是必须结合系统控制器前置方法属性protected $beforeActionList=[ “abc”, // 不让index方法使用def “def”=&gt;[“except”=&gt;index], // 只让index方法使用ghi “ghi”=&gt;[“only”=&gt;index] ]; 页面跳转 thinkphp/library/think/Controller.php Loader::import(‘controller/Jump’, TRAIT_PATH, EXT); thinkphp/library/traits/controller/Jump.php 成功跳转 $this-&gt;success(&quot;成功&quot;,&apos;index/index&apos;); // 默认跳转到上一个页面 /** * 操作成功跳转的快捷方法 * @access protected * @param mixed $msg 提示信息 * @param string $url 跳转的 URL 地址 * @param mixed $data 返回的数据 * @param int $wait 跳转等待时间 * @param array $header 发送的 Header 信息 * @return void * @throws HttpResponseException */ protected function success($msg = &apos;&apos;, $url = null, $data = &apos;&apos;, $wait = 3, array $header = []) { if (is_null($url) &amp;&amp; !is_null(Request::instance()-&gt;server(&apos;HTTP_REFERER&apos;))) { $url = Request::instance()-&gt;server(&apos;HTTP_REFERER&apos;); } elseif (&apos;&apos; !== $url &amp;&amp; !strpos($url, &apos;://&apos;) &amp;&amp; 0 !== strpos($url, &apos;/&apos;)) { $url = Url::build($url); } $type = $this-&gt;getResponseType(); $result = [ &apos;code&apos; =&gt; 1, &apos;msg&apos; =&gt; $msg, &apos;data&apos; =&gt; $data, &apos;url&apos; =&gt; $url, &apos;wait&apos; =&gt; $wait, ]; if (&apos;html&apos; == strtolower($type)) { $template = Config::get(&apos;template&apos;); $view = Config::get(&apos;view_replace_str&apos;); $result = ViewTemplate::instance($template, $view) -&gt;fetch(Config::get(&apos;dispatch_success_tmpl&apos;), $result); } $response = Response::create($result, $type)-&gt;header($header); throw new HttpResponseException($response); } 失败跳转 $this-&gt;success(&quot;失败&quot;,&apos;index/index&apos;); // 默认跳转到上一个页面 /** * 操作错误跳转的快捷方法 * @access protected * @param mixed $msg 提示信息 * @param string $url 跳转的 URL 地址 * @param mixed $data 返回的数据 * @param int $wait 跳转等待时间 * @param array $header 发送的 Header 信息 * @return void * @throws HttpResponseException */ protected function error($msg = &apos;&apos;, $url = null, $data = &apos;&apos;, $wait = 3, array $header = []) { if (is_null($url)) { $url = Request::instance()-&gt;isAjax() ? &apos;&apos; : &apos;javascript:history.back(-1);&apos;; } elseif (&apos;&apos; !== $url &amp;&amp; !strpos($url, &apos;://&apos;) &amp;&amp; 0 !== strpos($url, &apos;/&apos;)) { $url = Url::build($url); } $type = $this-&gt;getResponseType(); $result = [ &apos;code&apos; =&gt; 0, &apos;msg&apos; =&gt; $msg, &apos;data&apos; =&gt; $data, &apos;url&apos; =&gt; $url, &apos;wait&apos; =&gt; $wait, ]; if (&apos;html&apos; == strtolower($type)) { $template = Config::get(&apos;template&apos;); $view = Config::get(&apos;view_replace_str&apos;); $result = ViewTemplate::instance($template, $view) -&gt;fetch(Config::get(&apos;dispatch_error_tmpl&apos;), $result); } $response = Response::create($result, $type)-&gt;header($header); throw new HttpResponseException($response); } 修改模板页面application/config.php中 &apos;dispatch_success_tmpl&apos; =&gt; THINK_PATH . &apos;tpl&apos; . DS . &apos;dispatch_jump.tpl&apos;, &apos;dispatch_error_tmpl&apos; =&gt; THINK_PATH . &apos;tpl&apos; . DS . &apos;dispatch_jump.tpl&apos;, /thinkphp/tpl/dispatch_jump.tpl {NOLAYOUT}&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; 跳转提示 *{ padding: 0; margin: 0; } body{ background: #fff; font-family: “Microsoft Yahei”,”Helvetica Neue”,Helvetica,Arial,sans-serif; color: #333; font-size: 16px; } .system-message{ padding: 24px 48px; } .system-message h1{ font-size: 100px; font-weight: normal; line-height: 120px; margin-bottom: 12px; } .system-message .jump{ padding-top: 10px; } .system-message .jump a{ color: #333; } .system-message .success,.system-message .error{ line-height: 1.8em; font-size: 36px; } .system-message .detail{ font-size: 12px; line-height: 20px; margin-top: 12px; display: none; } &lt;?php switch ($code) {?&gt; &lt;?php case 1:?&gt; :) // 状态图片 &lt;?php echo(strip_tags($msg));?&gt; &lt;?php break;?&gt; &lt;?php case 0:?&gt; // 状态图片 :( &lt;?php echo(strip_tags($msg));?&gt; &lt;?php break;?&gt; &lt;?php } ?&gt; 页面自动 跳转 等待时间： &lt;?php echo($wait);?&gt; (function(){ var wait = document.getElementById(‘wait’), href = document.getElementById(‘href’).href; var interval = setInterval(function(){ var time = –wait.innerHTML; if(time &lt;= 0) { location.href = href; clearInterval(interval); }; }, 1000); })(); * @param mixed $code 状态码 * @param mixed $msg 提示信息 * @param string $url 跳转的 URL 地址 * @param mixed $data 返回的数据 * @param int $wait 跳转等待时间 * @param array $header 发送的 Header 信息 直接在code1和0之间指定对对应的内容可以 或者指定对应的模板页面 &apos;dispatch_success_tmpl&apos; =&gt; THINK_PATH . &apos;tpl&apos; . DS . &apos;dispatch_success_jump.tpl&apos;, &apos;dispatch_error_tmpl&apos; =&gt; THINK_PATH . &apos;tpl&apos; . DS . &apos;dispatch_error_jump.tpl&apos;, /thinkphp/tpl/dispatch_success_jump.tpl/thinkphp/tpl/dispatch_error_jump.tpl 直接写dispatch_success_jump.tpl和dispatch_error_jump.tpl就可以实现自定义模板显示，具体显示根据需求或者业务进行调整 重定向 重定向(Redirect)就是通过各种方法将各种网络请求重新定个方向转到其它位置（如：网页重定向、域名的重定向、路由选择的变化也是对数据报文经由路径的一种重定向） 状态码： 301 redirect、302 redirect 我们在网站建设中，时常会遇到需要网页重定向的情况：1.网站调整（如改变网页目录结构）；2.网页被移到一个新地址；3.网页扩展名改变(如应用需要把.php改成.Html或.shtml)。这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。 我们先来了解一下用户/搜索引擎和网站一开始的交互流程。当用户或搜索引擎向一个网站服务器发出网页浏览请求时，该服务器将：1.通过域名服务器(DNS)将域名转换为网站的IP地址，然后返回给客户2.打开一个该IP套接口连接3.记下通过该套接口的一个HTTP数据流4.从WEB服务器接收一个响应请求的HTTP数据流。该数据流包含状态码，状态码的值由HTTP协议所决定。这里所说的“HTTP数据流”信息也叫“头信息(Header)”。头信息中包括了日期，服务器类型，通常还会有一条“200 OK”信息。如果一切良好，那么网络服务器就会将“200 OK”信息以及请求页面发送出去。如果网站在这时候已经建立了重定向，那么服务器就会在头信息中包含一个“302 Moved Temporarily”或“301 Moved Permanent”之类的响应信息。搜索引擎会根据服务器头信息中的内容作出决定。 /** * URL 重定向 * @access protected * @param string $url 跳转的 URL 表达式 * @param array|int $params 其它 URL 参数 * @param int $code http code * @param array $with 隐式传参 * @return void * @throws HttpResponseException */ protected function redirect($url, $params = [], $code = 302, $with = []) { if (is_integer($params)) { $code = $params; $params = []; } $response = new Redirect($url); $response-&gt;code($code)-&gt;params($params)-&gt;with($with); throw new HttpResponseException($response); } $this-&gt; redirect(‘index/index’,[‘name’=&gt;’name’, ‘id’=&gt;’99’], 301或302) 空操作 作用解决用户恶意输入，报错影响用户体验public function _empty() { $this-&gt; redirect(‘index/index’)} 空控制器 网站上线每个控制都必须写空操作，不论前台后台，都必须写一个Error.php控制器 controller下新建一个Error.php控制器 &lt;?php namespace app\index\controller; class Error{ // index重定向 public function index() { $this-&gt;redirect(&apos;index/index&apos;); } // 空操作 public function _empty() { $this-&gt; redirect(&apos;index/index&apos;) } } ?&gt; 资料控制 通过命令生成控制主目录中有一个think可执行文件 #!/usr/bin/env php&lt;?php// +———————————————————————-// | ThinkPHP [ WE CAN DO IT JUST THINK ]// +———————————————————————-// | Copyright (c) 2006-2016 http://thinkphp.cn All rights reserved.// +———————————————————————-// | Licensed ( http://www.apache.org/licenses/LICENSE-2.0 )// +———————————————————————-// | Author: yunwuxin &#x34;&#x34;&#56;&#x39;&#48;&#x31;&#x39;&#52;&#56;&#64;&#x71;&#113;&#46;&#99;&#111;&#x6d;// +———————————————————————- // 定义项目路径define(‘APP_PATH’, DIR . ‘/application/‘); // 加载框架引导文件require DIR.’/thinkphp/console.php’; 在主目录即application同级目录中操作命令行：php think Think Console version 0.1 Usage: command [options] [arguments] Options: -h, –help Display this help message -V, –version Display this console version -q, –quiet Do not output any message –ansi Force ANSI output –no-ansi Disable ANSI output -n, –no-interaction Do not ask any interactive question -v|vv|vvv, –verbose Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug Available commands: build Build Application Dirs clear Clear runtime file help Displays help for a command list Lists commands make make:controller Create a new resource controller class make:model Create a new model class migrate migrate:breakpoint Manage breakpoints migrate:create Create a new migration migrate:rollback Rollback the last or to a specific migration migrate:run Migrate the database migrate:status Show migration status optimize optimize:autoload Optimizes PSR0 and PSR4 packages to be loaded with classmaps too, good for production. optimize:config Build config and common file cache. optimize:route Build route cache. optimize:schema Build database schema cache. queue queue:listen Listen to a given queue queue:restart Restart queue worker daemons after their current job queue:subscribe Subscribe a URL to an push queue queue:work Process the next job on a queue seed seed:create Create a new database seeder seed:run Run database seeders 创建MVC： php think make:controller app\index\controller\Conterphp think make:controller app\index\view\conterphp think make:controller app\index\model\conter]]></content>
  </entry>
  <entry>
    <title><![CDATA[Tp5入门——huiadmin+MVC实战笔记]]></title>
    <url>%2F2019%2F01%2F09%2FTp5%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94huiadmin-MVC%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[MVC无人不知，可很多程序员对MVC的概念的理解似乎有误，换言之他们一直在错用MVC，尽管即使如此软件也能被写出来，然而软件内部代码的组织方式却是不科学的，这会影响到软件的可维护性、可移植性，代码的可重用性。 MVC即Model、View、Controller即模型、视图、控制器。我在和同行讨论技术，阅读别人的代码时发现，很多程序员倾向于将软件的业务逻辑放在Controller里，将数据库访问操作的代码放在Model里。 public中menu里面处理：管理员管理 模块 12345678&lt;dl id="menu-admin"&gt;&lt;dt&gt;&lt;i class="Hui-iconfont"&gt;&amp;#xe62d;&lt;/i&gt; 管理员管理&lt;i class="Hui-iconfont menu_dropdown-arrow"&gt;&amp;#xe6d5;&lt;/i&gt;&lt;/dt&gt;&lt;dd&gt;&lt;ul&gt;&lt;li&gt;&lt;a data-href="&#123;:url('admin/add')&#125;" data-title="添加用户" href="javascript:void(0)"&gt;添加用户&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/dd&gt;&lt;/dl&gt; data-href=”{:url(‘admin/add’)}”: 对应位置是admin/add,即当前view中admin里面的add.html 在view里面新建admin，里面在新建add.html,处理add.html中表单 1&lt;form class="form form-horizontal" id="form-admin-add" method="post" action="&#123;:url('admin/add')&#125;"&gt; action=”{:url(‘admin/add’)}”: 表单提交对应的是admin对应的控制器，里面的add方法 在controller里面新建Admin.php(必须大写),里面新增add方法 12345678910111213141516171819202122232425262728293031323334353637383940namespace app\admin\controller;use think\Controller;class Admin extends Controller&#123; public function add() &#123; // 是否是POST提交 if (request()-&gt;isPost()) &#123; //dump(input('post.')); $data = input('post.'); &lt;!--验证: AdminUser--&gt; $validate = validate('AdminUser'); if (!$validate-&gt;check($data)) &#123; $this-&gt;error($validate-&gt;getError()); &#125; &lt;!--加密--&gt; $data['password'] = md5($data['password'].'_#dev_icocos_php'); $data['status'] = 1; &lt;!--异常--&gt; try &#123; &lt;!--模型层数据传递：AdminUser--&gt; $id = model('AdminUser')-&gt;add($data); &#125; catch (\Exception $e) &#123; $this-&gt;error($e-&gt;getMessage()); &#125; &lt;!--状态判断--&gt; if ($id) &#123; $this-&gt;success('id='.$id.'的用户新增成功'); &#125; else &#123; $this-&gt;error('error'); &#125; &#125; else &#123; // 非POST &#125; return $this-&gt;fetch(); //显示到view &#125;&#125; 其中顶层模块新建common，里面新建两个文件夹 4.1 validate里面AdminUser.php对应全局验证，配置规则就可以 12345678910namespace app\common\validate;use think\Validate;class AdminUser extends Validate &#123; protected $rule = [ 'username' =&gt; 'require|max:20', 'password' =&gt; 'require|max:20', ];&#125; 4.2 common里面AdminUser.php对应模型数据 123456789101112131415namespace app\common\model;use think\Model;class AdminUser extends Model &#123; protected $autoWriteTimestamp = true; // 直接默认使用写入(创建)时间 public function add($data) &#123; if (!is_array($data)) &#123; exception("数据传输不合法"); &#125; &lt;!--数据库存储--&gt; $this-&gt;allowField(true)-&gt;save($data); return $this-&gt;id; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Tp5入门——脚本与配置]]></title>
    <url>%2F2019%2F01%2F06%2FTp5%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E8%84%9A%E6%9C%AC%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[ThinkPHP提供了灵活的全局配置功能，采用最有效率的PHP返回数组方式定义，支持惯例配置、公共配置、模块配置、扩展配置、场景配置、环境变量配置和动态配置。 对于有些简单的应用，你无需配置任何配置文件，而对于复杂的要求，你还可以扩展自己的独立配置文件。 系统的配置参数是通过静态变量全局存取的，存取方式简单高效。 配置功能由\think\Config类完成。 thinkphp配置类型有哪些？ 1.在thinkphp中，有6种配置。即惯例配置，应用配置、扩展配置、模块配置、场景配置、动态配置。 2.惯例配置就是系统默认的配置。 3.应用配置就是我们自己开发创建的应用单独的配置。 4.扩展配置主要是实现我们项目在开发过程中有一些扩展程序用到的配置。 5.模块配置就是我们在一个应用中，每一个模块的配置。 6.场景配置主要是实现我们在不同的开发环境中设置的配置。若我们在家里面办公，电脑环境可能不一样;公司里面办公，公司的电脑环境有不一样。 7.动态配置在我们模块中开发实现的动态配置。如我们在某一个控制器中定义数据库的配置。 脚本与配置配置类型和位置 惯例配置：通用全局配置 thinkphp5_1/thinkphp/convention.php 应用配置：App应用，后台配置 thinkphp5_1/application/config.php 拓展配置：对真个配置文件分类管理(分目录) thinkphp5_1/application/database.php thinkphp5_1/application/extra/自定义配置文件 场景配置：环境切换配置： thinkphp5_1/application/config.php // 应用模式状态 ‘app_status’ =&gt; ‘home’, application新建对应home文件，编写配置 ‘app_status’ =&gt; ‘office’, application新建对应office文件，编写配置 模块配置：模块特有，对应模块config.php thinkphp5_1/application/admin 动态配置：临时性配置，执行的时候设置 设置动态配置系统方法： config(&apos;name&apos;, &apos;PHP动态配置&apos;); 系统类: \think\Config::set(&apos;name&apos;, &apos;PHP动态配置&apos;); 读取配置系统方法： config(&apos;key&apos;) 系统类： \think\Config::get(&apos;key&apos;) 使用use： use \think\Config Config::get(&apos;key&apos;) 数组： config(&apos;key&apos;) config(&apos;key.name&apos;) 上同 扩展配置分类： config(&apos;key.name&apos;) &apos;key&apos;所有 系统相关系统类： thinkphp5_1/thinkphp/library/think 系统方法： thinkphp5_1/thinkphp/helper.php 配置顺序配置文件加载顺序：反向加载，合并同名覆盖，不同名保留 动态配置 -&gt; 模块 -&gt; 场景 -&gt; 扩展 -&gt; 应用 -&gt; 管理 环境变量配置新建： thinkphp5_1/.env // 非php，直接键值对或数组，不支持中文 name=icocos [database] type=mysql root = root 读取： think\Env::get(&apos;name&apos;) think\Env::get(&apos;database.type&apos;) // 不能直接database.type]]></content>
  </entry>
  <entry>
    <title><![CDATA[Tp5入门——数据库(MySQL)操作]]></title>
    <url>%2F2019%2F01%2F04%2FTp5%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[MySQL 是最流行的关系型数据库管理系统，在WEB应用方面 MySQL 是最好的RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。 在本教程中，会让大家快速掌握 MySQL 的基本知识，并轻松使用 MySQL 数据库。 TP-&gt;DB：查询数据public function selectDB() { // // 1. 原生更新记录 $result1 = Db::query(&apos;delete from t_php_0002 where id=38&apos;); var_dump($result1); // 2. TPS岔村构造器方法 $result2 = DB::table(&apos;t_php_0002&apos;)-&gt;where(&apos;id&apos;, 39)-&gt;delete(); var_dump($result2); // 3. 去掉表前缀:think_ $result3 = Db::name(&apos;t_php_0002&apos;)-&gt;where(&apos;id&apos;, 40)-&gt;delete(); var_dump($result3); // 4. 助手Db函数 $db = db(&apos;t_php_0002&apos;); $result4 = $db-&gt;where(&apos;id&apos;, 41)-&gt;delete(); var_dump($result4); } 删除数据public function deleteDB() { // 1. 原生更新记录 $result1 = Db::query(&apos;select * from t_php_0002 where id&lt;&gt;5&apos;); var_dump($result1); // 2. TPS岔村构造器方法 $result2 = DB::table(&apos;t_php_0002&apos;)-&gt;where(&apos;id&apos;, 16)-&gt;select(); var_dump($result2); // 3. 去掉表前缀:think_ $result3 = Db::name(&apos;t_php_0002&apos;)-&gt;where(&apos;id&apos;, 16)-&gt;select(); var_dump($result3); // 4. 助手Db函数 $db = db(&apos;t_php_0002&apos;); $result4 = $db-&gt;where(&apos;id&apos;, 16)-&gt;select(); var_dump($result4); } 更新数据public function updateDB() { // 1. 原生更新记录 $result1 = Db::execute(&apos;update t_php_0002 set name = &quot;framework&quot; where id=16&apos;); var_dump($result1); // 2. TPS岔村构造器方法 DB::table(&apos;t_php_0002&apos;)-&gt;where(&apos;id&apos;, 16)-&gt;update([&apos;name&apos;=&gt;&quot;iCocos XXX&quot;]); // 3. 去掉表前缀:think_ Db::name(&apos;t_php_0002&apos;)-&gt;where(&apos;id&apos;, 16)-&gt;update([&apos;name&apos;=&gt;&quot;iCocos YYY&quot;]); // 4. 助手Db函数 $db = db(&apos;t_php_0002&apos;); $db-&gt;where(&apos;id&apos;, 16)-&gt;update([&apos;name&apos;=&gt;&quot;iCocos MMM&quot;]); } 插入数据public function insertDB() { // 1. 原生插入记录 $result1 = Db::execute(&apos;insert into t_php_0002 (name, status) values (&quot;thinkphp002&quot;, 12)&apos;); var_dump($result1); // 2. TPS岔村构造器方法 Db::table(&apos;t_php_0002&apos;)-&gt;insert([&apos;name&apos;=&gt;&apos;PHP0002&apos;,&apos;status&apos;=&gt;10]); // 3. 去掉表前缀:think_ Db::name(&apos;t_php_0002&apos;)-&gt;insert([&apos;name&apos;=&gt;&quot;iCocos&quot;]); $db = db(&apos;t_php_0002&apos;); // 4. 直接插 $result2 = $db-&gt;insert([&apos;name&apos;=&gt;&quot;iCocos four&quot;]); var_dump($result2); // 5. 插入并获取结果 $result3 = $db-&gt;insertGetId([&apos;name&apos;=&gt;&quot;iCocos four&quot;]); var_dump($result3); // 插入多条 $data1 = [ [&apos;name&apos;=&gt;&apos;x&apos;], [&apos;name&apos;=&gt;&apos;Y&apos;], [&apos;name&apos;=&gt;&apos;Z&apos;] ]; $res = $db-&gt;insertAll($data1); var_dump($res); }]]></content>
  </entry>
  <entry>
    <title><![CDATA[Tp5入门——模块和方法调用]]></title>
    <url>%2F2019%2F01%2F02%2FTp5%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%A8%A1%E5%9D%97%E5%92%8C%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在ThinkPHP中，使用 $this 可以调用当前模块内的方法，但是很多情况下经常会在当前模块中调用其他模块的方法。这篇文章主要介绍了ThinkPHP跨模块调用操作,需要的朋友可以参考下。 模块和方法调用跨控制器调用: 当前模块public function callback_current_model() { // 调用前台User // 方式1：直接实例化-&gt;前台 $model1 = new \app\index\controller\User; echo $model1-&gt;index(); // 方法2： use \app\index\controller\User $model2 = new User; echo $model2-&gt;index(); // 方法3：系统方法 $model3 = controller(&quot;User&quot;); echo $model3-&gt;index(); } 跨控制器调用: 不同模块-&gt;后台public function callback_cothers_model() { // 调用前台User // 方式1：直接实例化 $model1 = new \app\admin\controller\Index; echo $model1-&gt;index(); // 方法2： use \app\index\controller\User $model2 = new AdminIndex; echo $model2-&gt;index(); // 方法3：系统方法 $model3 = controller(&quot;admin/Index&quot;); echo $model3-&gt;index(); } 调动当前模块当前控制器中的方法public function callback_current_method() { $this-&gt;test(); self::test(); Index::test(); action(&apos;test&apos;); } 调动当前模块其他控制器中的方法public function callback_others_method() { $model1 = new \app\index\controller\User; echo $model1-&gt;test(); echo action(&apos;User/test&apos;); } 调动其他模块其他控制器中的方法public function callback_others_model_method() { // 方式1：直接实例化 $model1 = new \app\admin\controller\Index; echo $model1-&gt;test(); echo action(&apos;admin/index/test&apos;); }]]></content>
  </entry>
  <entry>
    <title><![CDATA[Tp5入门——程序执行流程]]></title>
    <url>%2F2019%2F01%2F01%2FTp5%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[对用户的第一次URL访问 http://[ip]|[localhost]/My/index.php/Index/show/ 所执行的流程进行详细的分析，用户的URL访问首先是定位到了My项目的index.php 入口文件（注意：如果使用了URL_REWRITE，可能index.php已经被隐藏了），项目的入口文件所做的其实是实例化一个App应用实例，并且执行这个应用。 执行流程 1， 入口文件： ~/public/index.php// 定义应用目录常量 define(&apos;APP_PATH&apos;, __DIR__ . &apos;/../application/&apos;); // 加载框架引导文件 require __DIR__ . &apos;/../thinkphp/start.php&apos;; 2，加载框架引导文件：~/thinkphp/start.php// 1. 加载基础文件 require __DIR__ . &apos;/base.php&apos;; // 2. 执行应用 App::run()-&gt;send(); 3，加载基础文件定义常量，文件后缀，环境常量 加载环境变量配置文件 载入Loader类：~/thinkphp/library/think/Loader.php(自动加载类) // 注册自动加载 \think\Loader::register(); // 注册错误和异常处理机制： ~/thinkphp/library/think/Error.php \think\Error::register(); // 加载惯例配置文件:~/thinkphp/convention.php \think\Config::set(include THINK_PATH . &apos;convention&apos; . EXT); 4，加载运行应用：~/thinkphp/library/think/App.phpApp::run()-&gt;send(); run方法：public static function run(Request $request = null) 1, 加载$config = self::initCommon();// 加载命名空间: Loader::addNamespace($config[&apos;root_namespace&apos;]); // 初始化应用： config = self::init(); 加载各种配置文件 // 应用调试模式:self::$debug = Env::get(&apos;app_debug&apos;, Config::get(&apos;app_debug&apos;)); // 加载额外文件:$config[&apos;extra_file_list&apos;] // 设置系统时区: date_default_timezone_set($config[&apos;default_timezone&apos;]); // 监听 app_init： Hook::listen(&apos;app_init&apos;); 2,加载当前控制器中的init方法// 加载各种配置文件 // 加载公告文件 // 加载语言包 3, 设置时区4, 加载当前控制的路由检测5, 调用控制器中的exec方法：根据用户请求进行分发处理6, 根据不同的请求类型，加载对应文件module方法// 获取控制器名 // $controller = strip_tags($result[1] ?: $config[&apos;default_controller&apos;]); // $controller = $convert ? strtolower($controller) : $controller; // 设置当前请求的控制器、操作 // $request-&gt;controller(Loader::parseName($controller, 1))-&gt;action($actionName); 模块/控制器绑定，入口自动绑定，默认语言，系统语言包，监听 app_dispatch，URL 路由检测，记录路由和请求信息，监听 app_begin，请求缓存检查，清空类的实例化，输出数据到客户端，监听 app_end 5，相应输出// 输出数据到客户端 if ($data instanceof Response) { $response = $data; } elseif (!is_null($data)) { // 默认自动识别响应输出类型 $type = $request-&gt;isAjax() ? Config::get(&apos;default_ajax_return&apos;) : Config::get(&apos;default_return_type&apos;); $response = Response::create($data, $type); } else { $response = Response::create(); }]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHP第三十一篇——注册登录验证入门实战]]></title>
    <url>%2F2018%2F12%2F28%2FPHP%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%80%E7%AF%87%E2%80%94%E2%80%94%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[实现处理PHP+MySQLi+HTML实战，简单到不能再简单的注册登录页面效果！ PHP基础——注册登录验证入门实战连接数据库： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?php header('content-type:text/html;charset=utf-8'); ##### 建立连接: 这里使用MAMP默认提供的mysql和端口 $link = mysqli_connect('localhost', 'root', 'root', 'mysqli','8889') or die('连接数据失败&lt;\br&gt;'.mysqli__connect_errno($link).':'.mysqli__connect_error($link)); //var_dump($link); if (!$link) &#123; echo "错误连接"; echo 'ERROR'.mysqli_connect_errno().':'.mysqli_connect_error(); exit(); &#125; ##### 设置字符集 mysqli_query($link, 'SET NAMES UTF8'); ##### 打开指定数据库 $res = mysqli_select_db($link,'mysqli') or die('指定数据库不存在&lt;\br&gt;'.mysqli__errno($link).':'.mysqli__error($link));``` ### PHP操作请求```bash&lt;?phprequire_once 'connect.php';$act = $_REQUEST['act'];$username = $_POST['username'];$password = $_POST['password'];$regtime = time();// 根据不同的操作完成不同的功能switch ($act) &#123; case 'regist': $sql = "INSERT user(username,password,regtime) VALUES('&#123;$username&#125;','&#123;$password&#125;','&#123;$regtime&#125;')"; $res = mysqli_query($link, $sql); if ($res) &#123; echo "注册成功，恭喜发财, 第".mysqli_insert_id($link); echo '&lt;meta http-equiv="refresh" content="3;url=login.php"/&gt;'; &#125; else &#123; echo "注册失败，请先前往注册"; echo '&lt;meta http-equiv="refresh" content="3;url=regist.php"/&gt;'; &#125; break; case 'login': $sql = "SELECT * FROM user WHERE username='&#123;$username&#125;' AND password='&#123;$password&#125;'"; $res = mysqli_query($link, $sql); if ($res &amp;&amp; mysqli_num_rows($res)&gt;0) &#123; echo "登录成功，恭喜发财, 第".mysqli_insert_id($link); echo '&lt;meta http-equiv="refresh" content="3;url=home.php"/&gt;'; &#125; else &#123; echo "登录失败，请重新登录"; echo '&lt;meta http-equiv="refresh" content="3;url=login.php"/&gt;'; &#125; break;&#125; 注册页面与简单逻辑：12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;注册页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;注册页面&lt;/h3&gt; &lt;form action="doAction.php?act=regist" method="post"&gt; &lt;table border="1" width="80%" cellpadding="0" cellspacing="0" bgcolor="#ABCDEF"&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="username" id="username" placeholder="请输入合法用户名"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="password" id="password" placeholder="请输入密码"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2"&gt; &lt;input type="submit" value="注册"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 登录页面与简单逻辑：12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;登录页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;登录页面&lt;/h3&gt; &lt;form action="doAction.php?act=login" method="post"&gt; &lt;table border="1" width="80%" cellpadding="0" cellspacing="0" bgcolor="#ABCDEF"&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="username" id="" placeholder="请输入合法用户名"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="password" id="" placeholder="请输入密码"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2"&gt; &lt;input type="submit" value="登录"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 首页展示：12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;首页&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 实战代码以下是注册登录，验证PHP代码逻辑 index.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;梦工厂系统&lt;/title&gt;&lt;script type="text/javascript" src="js/jquery-1.9.0.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/login.js"&gt;&lt;/script&gt;&lt;link href="css/login.css" rel="stylesheet" type="text/css" /&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt; 登陆注册系统&lt;sup&gt;V2016&lt;/sup&gt; &lt;/h1&gt; &lt;div class="login" style="margin-top: 50px;"&gt; &lt;div class="header"&gt; &lt;div class="switch" id="switch"&gt; &lt;a class="switch_btn_focus" id="switch_qlogin" href="javascript:void(0);" tabindex="7"&gt;快速登录&lt;/a&gt; &lt;a class="switch_btn" id="switch_login" href="javascript:void(0);" tabindex="8"&gt;快速注册&lt;/a&gt; &lt;div class="switch_bottom" id="switch_bottom" style="position: absolute; width: 64px; left: 0px;"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="web_qr_login" id="web_qr_login" style="display: block; height: 235px;"&gt; &lt;!--登录--&gt; &lt;div class="web_login" id="web_login"&gt; &lt;div class="login-box"&gt; &lt;div class="login_form"&gt; &lt;!-- 表单操作 --&gt; &lt;form action="doAction.php?act=login" name="loginform" accept-charset="utf-8" id="login_form" class="loginForm" method="post"&gt; &lt;input type="hidden" name="did" value="0" /&gt; &lt;input type="hidden" name="to" value="log" /&gt; &lt;div class="uinArea" id="uinArea"&gt; &lt;label class="input-tips" for="u"&gt;帐号：&lt;/label&gt; &lt;div class="inputOuter" id="uArea"&gt; &lt;input type="text" id="u" name="username" class="inputstyle" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="pwdArea" id="pwdArea"&gt; &lt;label class="input-tips" for="p"&gt;密码：&lt;/label&gt; &lt;div class="inputOuter" id="pArea"&gt; &lt;input type="password" id="p" name="password" class="inputstyle" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div style="padding-left: 50px; margin-top: 20px;"&gt; &lt;input type="submit" value="登 录" style="width: 150px;" class="button_blue" /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--登录end--&gt; &lt;/div&gt; &lt;!--注册--&gt; &lt;div class="qlogin" id="qlogin" style="display: none;"&gt; &lt;div class="web_login"&gt; &lt;!-- 表单操作 --&gt; &lt;form name="form2" id="regUser" accept-charset="utf-8" action="doAction.php?act=reg" method="post"&gt; &lt;input type="hidden" name="to" value="reg" /&gt; &lt;input type="hidden" name="did" value="0" /&gt; &lt;ul class="reg_form" id="reg-ul"&gt; &lt;div id="userCue" class="cue"&gt;快速注册请注意格式&lt;/div&gt; &lt;li&gt;&lt;label for="user" class="input-tips2"&gt;用户名：&lt;/label&gt; &lt;div class="inputOuter2"&gt; &lt;input type="text" id="user" name="username" maxlength="16" class="inputstyle2" /&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt;&lt;label for="passwd" class="input-tips2"&gt;密码：&lt;/label&gt; &lt;div class="inputOuter2"&gt; &lt;input type="password" id="passwd" name="password" maxlength="16" class="inputstyle2" /&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt;&lt;label for="passwd2" class="input-tips2"&gt;确认密码：&lt;/label&gt; &lt;div class="inputOuter2"&gt; &lt;input type="password" id="passwd2" name="password2" maxlength="16" class="inputstyle2" /&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt;&lt;label for="email" class="input-tips2"&gt;邮箱：&lt;/label&gt; &lt;div class="inputOuter2"&gt; &lt;input type="email" id="email" name="email" class="inputstyle2" /&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="inputArea"&gt; &lt;input type="button" id="reg" style="margin-top: 10px; margin-left: 85px;" class="button_blue" value="同意协议并注册" /&gt; &lt;a href="#" class="zcxy" target="_blank"&gt;注册协议&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;div class="cl"&gt;&lt;/div&gt; &lt;/ul&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--注册end--&gt; &lt;/div&gt;&lt;/body&gt;&lt;/body&gt;&lt;/html&gt; login.css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239html &#123; &#125;body &#123; font-family:"Microsoft Yahei"; font-size:12px; margin:0;background: #fff url(../images/1.jpg) 50% 0 no-repeat;&#125;ul &#123; padding:0; margin:0;&#125;ul li &#123; list-style-type:none;&#125;a &#123; text-decoration:none;&#125;a:hover &#123; text-decoration:none;color:#f00;&#125;.cl&#123; clear: both;&#125;input[type="text"]:focus, input[type="password"]:focus &#123; outline:none;&#125;input::-ms-clear &#123; display:none;&#125;.login &#123; margin:0 auto; width:370px; border:2px solid #eee; border-bottom:none; position:relative;&#125;.header &#123; height:50px; border-bottom:1px solid #e2e2e2; position:relative; font-family:"Microsoft Yahei";&#125;.header .switch &#123; height:45px; position:absolute; left:60px; bottom:0; font-size:16px;&#125;.header .switch #switch_qlogin &#123; margin-right:85px;&#125;.header .switch .switch_btn &#123; color:#999; display:inline-block; height:45px; line-height:45px; outline:none; *hide-focus:expression(this.hideFocus=true);&#125;.header .switch .switch_btn_focus &#123; color:#333; display:inline-block; height:45px; line-height:45px; outline:none; *hide-focus:expression(this.hideFocus=true);&#125;.header .switch .switch_btn:hover &#123; color:#333; text-decoration:none;&#125;.header .switch .switch_btn_focus:hover &#123; text-decoration:none;&#125;#switch_bottom &#123; position:absolute; bottom:-1px;_bottom:-2px; border-bottom:2px solid #848484;&#125;.web_login &#123; width:370px; position:relative;&#125;#web_login&#123;_left:60px;*left:0;&#125;.web_login .login_form &#123; width:272px; margin:0 auto;&#125;.web_login .reg_form &#123; width:300px; margin:0 auto;&#125;.web_login .input-tips &#123; float:left; margin-top:10px; width:50px; height:42px; font-size:16px; line-height:42px; font-family:"Hiragino Sans GB", "Microsoft Yahei";&#125;.web_login .input-tips2 &#123; float:left; text-align:right; padding-right:10px; width:75px; height:30px; font-size:16px; margin-top:10px; clear:both; line-height:30px; font-family:"Hiragino Sans GB", "Microsoft Yahei";&#125;.web_login .inputOuter &#123; width:200px; height:42px; margin-top:10px; float:left; &#125;.web_login .inputOuter2 &#123; width:200px; margin-top:6px;margin-top:5px\9; float:left; &#125;.web_login .inputstyle &#123; width:200px; height:38px; padding-left:5px; line-height:30px;line-height:38px; border:1px solid #D7D7D7; background:#fff; color:#333;border-radius:2px; font-family:Verdana, Tahoma, Arial; font-size:16px; ime-mode:disabled;&#125;.web_login input.inputstyle2:focus,.web_login input.inputstyle:focus&#123;border:1px solid #198BD4;box-shadow:0 0 2px #198BD4;&#125;.web_login .inputstyle2 &#123; width:200px; height:34px; padding-left:5px; line-height:34px; border:1px solid #D7D7D7; background:#fff; color:#333;border-radius:2px; font-family:Verdana, Tahoma, Arial; font-size:16px; ime-mode:disabled;&#125;.web_login .uinArea &#123; height:55px; position:relative; z-index:10;&#125;.web_login .pwdArea &#123; height:55px; margin-bottom:10px; position:relative; z-index:3;&#125;.web_qr_login &#123; position:relative; overflow:hidden;&#125;.cue &#123; height:40px; line-height:40px; font-size:14px; border:1px #CCCCCC solid; margin-top:10px;margin-bottom:5px; text-align:center; font-family:"Hiragino Sans GB", "Microsoft Yahei";&#125;.login &#123; background-color:#ffffff;&#125;h1&#123;margin:80px auto 50px auto;text-align:center;color:#fff;margin-left:-25px;font-size:35px;font-weight: bold;text-shadow: 0px 1px 1px #555;&#125;h1 sup&#123; font-size: 18px; font-style: normal; position: absolute; margin-left: 10px;&#125;.login &#123;border:0;padding:5px 0;background: #fff;margin: 0 auto;-webkit-box-shadow: 1px 1px 2px 0 rgba(0, 0, 0, .3);box-shadow: 1px 1px 2px 0 rgba(0, 0, 0, .3);&#125;.web_login&#123;padding-bottom:20px;&#125;.jianyi&#123;color:#fff;text-align:center;margin-top:25px;color:#B3B8C4;&#125;.reg_form li &#123;height: 55px;&#125;.cue &#123;margin-top: 15px;margin-bottom: 10px;border:1px solid #eee;border-radius:3px;&#125;.web_login input.inputstyle2:focus, .web_login input.inputstyle:focus &#123;border: 1px solid #5796f;box-shadow: 0 0 0;&#125;.web_login .reg_form &#123;width: 300px;margin: 0 auto;&#125;.web_login .inputstyle2 &#123;border-radius:2px;width:210px;&#125;.web_login .input-tips2 &#123;padding-right: 5px;width: 80px;_width: 75px;_font-size:12px;&#125;.button_blue&#123; display:inline-block; float:left; height:41px;border-radius:4px; background:#2795dc;border:none;cursor:pointer; border-bottom:3px solid #0078b3;*border-bottom:none; color:#fff; font-size:16px;padding:0 10px;*width:140px; text-align:center;outline:none;font-family: "Microsoft Yahei",Arial, Helvetica, sans-serif;&#125;input.button_blue:hover&#123; background:#0081c1; border-bottom:3px solid #006698;*border-bottom:none; color:#fff; text-decoration:none;&#125;a.zcxy &#123;text-decoration: underline;line-height:58px;margin-left:15px;color: #959ca8;&#125;.web_login .login_form &#123;margin-top:30px;&#125;.web_login .uinArea &#123;height: 60px;&#125;.header .switch&#123;left:70px;&#125; login.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126$(function() &#123; $('#switch_qlogin').click( function() &#123; $('#switch_login').removeClass("switch_btn_focus").addClass( 'switch_btn'); $('#switch_qlogin').removeClass("switch_btn").addClass( 'switch_btn_focus'); $('#switch_bottom').animate(&#123; left : '0px', width : '70px' &#125;); $('#qlogin').css('display', 'none'); $('#web_qr_login').css('display', 'block'); &#125;); $('#switch_login').click( function() &#123; $('#switch_login').removeClass("switch_btn").addClass( 'switch_btn_focus'); $('#switch_qlogin').removeClass("switch_btn_focus").addClass( 'switch_btn'); $('#switch_bottom').animate(&#123; left : '154px', width : '70px' &#125;); $('#qlogin').css('display', 'block'); $('#web_qr_login').css('display', 'none'); &#125;); if (getParam("a") == '0') &#123; $('#switch_login').trigger('click'); &#125;&#125;);function logintab()&#123; scrollTo(0); $('#switch_qlogin').removeClass("switch_btn_focus").addClass('switch_btn'); $('#switch_login').removeClass("switch_btn").addClass('switch_btn_focus'); $('#switch_bottom').animate(&#123;left:'154px',width:'96px'&#125;); $('#qlogin').css('display','none'); $('#web_qr_login').css('display','block');&#125;//根据参数名获得该参数 pname等于想要的参数名 function getParam(pname) &#123; var params = location.search.substr(1); // 获取参数 平且去掉？ var ArrParam = params.split('&amp;'); if (ArrParam.length == 1) &#123; //只有一个参数的情况 return params.split('=')[1]; &#125; else &#123; //多个参数参数的情况 for (var i = 0; i &lt; ArrParam.length; i++) &#123; if (ArrParam[i].split('=')[0] == pname) &#123; return ArrParam[i].split('=')[1]; &#125; &#125; &#125; &#125; var reMethod = "GET", pwdmin = 6;$(document).ready(function() &#123; $('#user').blur(function()&#123; $.ajax(&#123; type: reMethod, url: "doAction.php?act=checkUser", data: "username=" + $("#user").val(), dataType: 'html', success: function(result) &#123; if (result==1) &#123; $('#user').focus().css(&#123; border: "1px solid red", boxShadow: "0 0 2px red" &#125;); $("#userCue").html('用户名已存在!'); return false; &#125; else &#123; $('#user').css(&#123; border: "1px solid #D7D7D7", boxShadow: "none" &#125;); &#125; &#125; &#125;); &#125;); $('#reg').click(function() &#123; if ($('#user').val() == "") &#123; $('#user').focus().css(&#123; border: "1px solid red", boxShadow: "0 0 2px red" &#125;); $('#userCue').html("&lt;font color='red'&gt;&lt;b&gt;×用户名不能为空&lt;/b&gt;&lt;/font&gt;"); return false; &#125; if ($('#user').val().length &lt; 4 || $('#user').val().length &gt; 16) &#123; $('#user').focus().css(&#123; border: "1px solid red", boxShadow: "0 0 2px red" &#125;); $('#userCue').html("&lt;font color='red'&gt;&lt;b&gt;×用户名位4-16字符&lt;/b&gt;&lt;/font&gt;"); return false; &#125; if ($('#passwd').val().length &lt; pwdmin) &#123; $('#passwd').focus(); $('#userCue').html("&lt;font color='red'&gt;&lt;b&gt;×密码不能小于" + pwdmin + "位&lt;/b&gt;&lt;/font&gt;"); return false; &#125; if ($('#passwd2').val() != $('#passwd').val()) &#123; $('#passwd2').focus(); $('#userCue').html("&lt;font color='red'&gt;&lt;b&gt;×两次密码不一致！&lt;/b&gt;&lt;/font&gt;"); return false; &#125; var reg = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(.[a-zA-Z0-9_-])+/; if (!reg.test($('#email').val())) &#123; $('#email').focus().css(&#123; border: "1px solid red", boxShadow: "0 0 2px red" &#125;); $('#userCue').html("&lt;font color='red'&gt;&lt;b&gt;×email格式不正确&lt;/b&gt;&lt;/font&gt;");return false; &#125; else &#123; $('#email').css(&#123; border: "1px solid #D7D7D7", boxShadow: "none" &#125;); &#125; $('#regUser').submit(); &#125;);&#125;); doAction.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166&lt;?php header('content-type:text/html;charset=utf-8');//基础引入require_once 'functions/mysql.func.php';require_once 'config/config.php';//邮件发送库require_once 'swiftmailer-master/lib/swift_required.php';require_once 'functions/common.func.php';//接受信息$act = $_REQUEST['act']; // 请求跳转操作$username = $_POST['username']; // 用户名$password = $_POST['password']; // 密码$link = connect3(); // 连接数据库$table = 'maizi_user';// 根据用户不同操作执行不同功能switch ($act) &#123; case 'reg': // 事务操作 // 1.关闭自动提交 mysqli_autocommit($link, FALSE); // 用户输入加产生数据 $email = $_POST['email']; $reg_time = time(); $token = md5($username.$password.$reg_time); // 生成Token $token_exptime = $reg_time+24*3600; // Token过期时间 $status = 1; // Token过期时间 $data = compact("username", "password","email","reg_time","token","token_exptime","status"); // 插入数据 $res_insert = insert($link, $data, $table); if ($res_insert) &#123; mysqli_commit($link); mysqli_autocommit($link, TRUE); echo "&lt;script&gt;alert('注册成功,立即登录');location.href='index.php'&lt;/script&gt;"; //alertMessage('注册成功,立即登录', 'index.php'); &#125; else &#123; mysqli_rollback($link); echo "&lt;script&gt;alert('注册失败,重新注册');location.href='index.php'&lt;/script&gt;"; //alertMessage('注册失败,重新注册', 'index.php'); &#125; break; // ================================== 发送邮件: 存在问题, 待调试 ================================== // 1. 初始化邮件服务器对象 $transport = Swift_SmtpTransport::newInstance('smtp.qq.com', 25); // 设置邮箱信息 $transport-&gt;setUsername(Mail_Name); $transport-&gt;setUsername(Mail_PWD); // 发送邮件对象 $mailer = Swift_Mailer::newInstance($transport); // ================= 消息对象: 发件人,收件人,设置主题和内天 ================= $message = Swift_Message::newInstance(); //发件人 $message-&gt;setFrom(array(Mail_Name)); //收件人 $message-&gt;setTo(array($email)); //主题 $message-&gt;setSubject("【梦工厂@iCocos】注册账号激活主题"); //内容 $actStr = "?act=active&amp;username=&#123;$username&#125;&amp;token=&#123;$token&#125;"; $url = "http://".$_SERVER['HTTP_HOST'].$_SERVER['PHP_SELF'].$actStr; $urlEncode = urlencode($url); $messageBody = &lt;&lt;&lt;EOF 尊敬的梦工厂用户，您好: 账号 &#123;$email&#125; ，注册并创建成功，请点击并激活, 前往主页, 详情如下： &lt;a href='&#123;$url&#125;' target='_blank'&gt;&#123;$urlEncode&#125;&lt;/a&gt; (该链接24小时内有效) 感谢您使用梦工厂，如果您在使用过程中有任何疑问，请参见下方提交工单联系我们。 谢谢！EOF; $message-&gt;setBody($messageBody, "text/html",'utf-8'); // 附件 $path = "images/maizi.png"; $message-&gt;attach(Swift_Attachment::fromPath($path, 'image/png')); // 发送操作 try &#123; $mail_res = $mailer-&gt;send($message); if ($mail_res &amp;&amp; $res_insert) &#123; mysqli_commit($link); mysqli_autocommit($link, TRUE); echo "&lt;script&gt;alert('注册成功,立即登录');location.href='index.php'&lt;/script&gt;"; &#125; else &#123; mysqli_rollback($link); echo "&lt;script&gt;alert('注册失败,重新注册');location.href='index.php'&lt;/script&gt;"; &#125; &#125; catch (Swift_ConnectionException $e) &#123; die("邮件服务器错误") . $e-&gt;getMessage(); &#125; // ================================== 发送邮件 ================================== break; case 'login': // 用户登录操作 $username = addslashes($username); $sql = "SELECT id, status FROM &#123;$table&#125; WHERE username='&#123;$username&#125;' AND password='&#123;$password&#125;'"; $user = fetchOne($link, $sql); if ($user) &#123; if ($user['status'] == 0) &#123; echo "&lt;script&gt;alert('请先激活,再登录');location.href='index.php'&lt;/script&gt;"; &#125; else &#123; echo "&lt;script&gt;alert('登录成功');location.href='index.php'&lt;/script&gt;"; &#125; &#125; else &#123; echo "&lt;script&gt;alert('用户名密码错误');location.href='index.php'&lt;/script&gt;"; &#125; break; case 'active': // 邮箱邮件外链激活操作 // http://com.mysqli.php:8888/logregmail/doAction.php // act=active&amp;username=sdsds&amp;token=ec821fcf18762a8cce7df5c47874b2f4 echo "点击邮件连接,跳转并激活成功,设置表status状态为1"; $token = $_POST['token']; // token $username = mysqli_real_escape_string($link, $username); $query = "SELECT id, token_exptime FROM &#123;$table&#125; WHERE username='&#123;$username&#125;'"; $user = fetchOne($link, $query); if ($user) &#123; // 检查是否超时 $now = time(); $token_exptime = $user['token_exptime']; if ($now&gt;$token_exptime) &#123; // 清空用户 delete($link, $table, "username='&#123;$username&#125;'"); echo "&lt;script&gt;alert('激活码无效,或者过期,请重新注册!!!');location.href='index.php'&lt;/script&gt;"; &#125; else &#123; // 激活操作:update-ststus $data=array('status'=&gt;1); $update = update($link, $data, $table, "username='&#123;$username&#125;'"); if ($update) &#123; echo "&lt;script&gt;alert('激活成功, 立即登录');location.href='index.php'&lt;/script&gt;"; &#125; else &#123; echo "&lt;script&gt;alert('激活失败,请重新激活!');location.href='index.php'&lt;/script&gt;"; &#125; &#125; &#125; else &#123; echo "&lt;script&gt;alert('激活失败,没有找到要激活的用户!!!');location.href='index.php'&lt;/script&gt;"; &#125; break; case 'checkUser': // Ajax用户注册状态检测 $username = mysqli_real_escape_string($link, $username); $query = "SELECT id FROM &#123;$table&#125; WHERE username='&#123;$username&#125;'"; $user = fetchOne($link, $query); if ($user) &#123; return 1; &#125; else &#123; return 0; &#125; break; default: die("非法操作"); break;&#125; config.php123456789101112131415161718192021&lt;?php$config=[ 'host'=&gt;'localhost', 'user'=&gt;'root', 'password'=&gt;'root', 'charset'=&gt;'utf8', 'dbName'=&gt;'maizi', 'dbPort'=&gt;'8889'];define('DB_HOST','localhost');define('DB_USER','root');define('DB_PWD','root');define('DB_CHARSET','utf8');define('DB_DBNAME','maizi');define('DB_PORT','8889');define('Mail_Name','2211523681@qq.com');define('Mail_PWD','???????'); mysql.func.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211&lt;?php/** * 连接 * @param string $host * @param string $user * @param string $password * @param string $charset * @param string $database * @return object 连接标识符 */function connect1($host,$user,$password,$charset,$database) &#123; $link = mysqli_connect ( $host, $user, $password ) or die ( '数据库连接失败&lt;br/&gt;ERROR ' . mysqli_connect_errno () . ':' . mysqli_connect_error () ); mysqli_set_charset ( $link, $charset ); mysqli_select_db ( $link, $database ) or die ( '指定数据库打开失败&lt;br/&gt;ERROR ' . mysqli_errno ( $link ) . ':' . mysqli_error ( $link ) ); return $link;&#125;/** * 连接 需要传递数组 * @param array $config * @return object */function connect2($config) &#123; $link = mysqli_connect ( $config ['host'], $config ['user'], $config ['password'] ) or die ( '数据库连接失败&lt;br/&gt;ERROR ' . mysqli_connect_errno () . ':' . mysqli_connect_error () ); mysqli_set_charset ( $link, $config ['charset'] ); mysqli_select_db ( $link, $config ['dbName'] ) or die ( '指定数据库打开失败&lt;br/&gt;ERROR ' . mysqli_errno ( $link ) . ':' . mysqli_error ( $link ) ); return $link;&#125;/** * 用常量的形式建立连接 * @return unknown */function connect3()&#123; $link = mysqli_connect ( DB_HOST, DB_USER, DB_PWD, DB_DBNAME, DB_PORT ) or die ( '数据库连接失败&lt;br/&gt;ERROR ' . mysqli_connect_errno () . ':' . mysqli_connect_error () ); mysqli_set_charset ( $link, DB_CHARSET ); mysqli_select_db ( $link, DB_DBNAME ) or die ( '指定数据库打开失败&lt;br/&gt;ERROR ' . mysqli_errno ( $link ) . ':' . mysqli_error ( $link ) ); return $link;&#125;/* array( 'username'=&gt;'king', 'password'=&gt;'king', 'age'=&gt;'12', 'regTime'=&gt;'123123123' ); INSERT user(username,password,age,regTime) VALUES('king','king','12','123123123'); *//** * 插入操作 * @param object $link * @param array $data * @param string $table * @return boolean */function insert($link,$data,$table)&#123; $keys = join ( ',', array_keys ( $data ) ); $vals = "'" . join ( "','", array_values ( $data ) ) . "'"; $query = "INSERT &#123;$table&#125;(&#123;$keys&#125;) VALUES(&#123;$vals&#125;)"; $res = mysqli_query ( $link, $query ); if ($res) &#123; return mysqli_insert_id ( $link ); &#125; else &#123; return false; &#125;&#125;/* array( 'username'=&gt;'king123', 'password'=&gt;'king123', 'age'=&gt;'32', 'regTime'=&gt;'123123123' ); UPDATE user SET username='king123',password='king123',age='32',regTime='123123123' WHERE id=1*//** * 更新操作 * @param object $link * @param array $data * @param string $table * @param string $where * @return boolean */function update($link, $data, $table, $where = null) &#123; foreach ( $data as $key =&gt; $val ) &#123; $set .= "&#123;$key&#125;='&#123;$val&#125;',"; &#125; $set = trim ( $set, ',' ); $where = $where == null ? '' : ' WHERE ' . $where; $query = "UPDATE &#123;$table&#125; SET &#123;$set&#125; &#123;$where&#125;"; $res = mysqli_query ( $link, $query ); if ($res) &#123; return mysqli_affected_rows ( $link ); &#125; else &#123; return false; &#125;&#125;//DELETE FROM user WHERE id=/** * 删除操作 * @param object $link * @param string $table * @param string $where * @return boolean */function delete($link, $table, $where = null) &#123; $where = $where ? ' WHERE ' . $where : ''; $query = "DELETE FROM &#123;$table&#125; &#123;$where&#125;"; $res = mysqli_query ( $link, $query ); if ($res) &#123; return mysqli_affected_rows ( $link ); &#125; else &#123; return false; &#125;&#125;/** * 查询指定记录 * @param object $link * @param string $query * @param string $result_type * @return array|boolean */function fetchOne($link, $query, $result_type = MYSQLI_ASSOC) &#123; $result = mysqli_query ( $link, $query ); if ($result &amp;&amp; mysqli_num_rows ( $result ) &gt; 0) &#123; $row = mysqli_fetch_array ( $result, $result_type ); return $row; &#125; else &#123; return false; &#125;&#125;/** * 查询所有记录 * @param object $link * @param string $query * @param string $result_type * @return array|boolean */function fetchAll($link, $query, $result_type = MYSQLI_ASSOC) &#123; $result = mysqli_query ( $link, $query ); if ($result &amp;&amp; mysqli_num_rows ( $result ) &gt; 0) &#123; while ( $row = mysqli_fetch_array ( $result, $result_type ) ) &#123; $rows [] = $row; &#125; return $rows; &#125; else &#123; return false; &#125;&#125;/** * 得到表中的记录数 * @param object $link * @param string $table * @return number|boolean */function getTotalRows($link, $table) &#123; $query = "SELECT COUNT(*) AS totalRows FROM &#123;$table&#125;"; $result = mysqli_query ( $link, $query ); if ($result &amp;&amp; mysqli_num_rows ( $result ) == 1) &#123; $row = mysqli_fetch_assoc ( $result ); return $row ['totalRows']; &#125; else &#123; return false; &#125;&#125;/** * 得到结果集的记录条数 * @param object $link * @param string $query * @return boolean */function getResultRows($link, $query) &#123; $result = mysqli_query ( $link, $query ); if ($result) &#123; return mysqli_num_rows ( $result ); &#125; else &#123; return false; &#125;&#125;/** * @param object $link */function getServerInfo($link) &#123; return mysqli_get_server_info ( $link );&#125;/** * @param object $link */function getClientInfo($link) &#123; return mysqli_get_client_info ( $link );&#125;/** * @param object $link */function getHostInfo($link)&#123; return mysqli_get_host_info($link);&#125;/** * @param object $link */function getProtoInfo($link) &#123; return mysqli_get_proto_info ( $link );&#125; 以上使用jquery-1.9.0.min.js实现JS基本功能交互，SwiftMailer实现用户邮箱验证，后期会根据实战抽一篇文章说关于邮箱和短信验证的实战！ 笔记总结：检测MySQLi扩展是否已经开启 phpinfo(); 检测MySQLi扩展是否已经加载，如果已经加载返回true，否则返回false var_dump(extension_loaded(‘mysqli’)); Fatal error(致命错误): Call to undefined function mysqli_connect()in G:\maizi\PHPAdvance\MySQLi\1-mysqli_connect.php on line 6 function_exists():检测某个函数是否存在 var_dump(function_exists(‘mysqli_connect’)); print_r(get_defined_functions()); mysqli_multi_query 执行多条SQL语句,每条SQL语句一定要以分号结尾，否则就会失败 如果多条SQL语句中有一条失败了，整个都会失败 结果集 mysqli_store_result():传输上一次产生的结果集 mysqli_more_results():判读是否有更多的结果集 mysqli_next_result():将结果集的指针向下移动一位 错误信息与编号 mysqli_connect_errno():连接产生的错误编号 mysqli_connect_error():连接产生的错误信息 mysqli_errno($link):得到上一步操作产生的错误编号 mysqli_error($link):得到上一步操作产生的错误信息 mysqli_querymysqli_query($link,$sql):执行SQL查询 1》只能执行一条SQL语句，SQL语句可以没有分号 2》mysqli_query()执行SELECT/SHOW/EXPLAIN/DESC/DESCRIBE这样关键字的SQL语句，执行 成功返回的是mysqli_result结果集，执行失败返回false； 执行其他SQL语句，执行成功返回true，失败返回false mysqli_affected_rowsmysqli_affected_rows($link):得到上一步操作产生的受影响的记录数 大于0的：受影响的记录数 等于0：没有记录被影响 等于-1：代表的SQL语句有问题 result_type$result_type的值为： MYSQLI_BOTH:关联+索引 MYSQLI_ASSOC:关联 MYSQLI_NUM:索引 连接不成功的情况： 1》用户名密码不正确 Warning: mysqli_connect(): (HY000/1045): Access denied for user ‘root‘@’localhost’ (using password: YES) in G:\maizi\PHPAdvance\MySQLi\2-mysqli_connect.php on line 5 bool(false) 2》MySQL服务器没有开启 ERROR 2003 (HY000): Can’t connect to MySQL server on ‘localhost’ (10061)Warning: mysqli_connect(): in G:\maizi\PHPAdvance\MySQLi\2-mysqli_connect.php on line 13 bool(false) 防止SQL注入 : ‘ or 1=1 转义特殊字符 预处理 1234567891011121314151617181920$username=addslashes($username);$username=mysqli_real_escape_string($username);$sql = "SELECT * FROM user WHERE username=? AND password=?";$sql = "SELECT id,username,password FROM user WHERE username=? AND password=?";if ($stmt=mysqli_prepare($link, $sql)) &#123; mysqli_stmt_bind_param($stmt, 'ss', $username, $password); mysqli_stmt_execute($stmt); mysqli_stmt_store_result($stmt); echo "--------"; echo '&lt;/br&gt;'.mysqli_stmt_affected_rows($stmt).'&lt;/br&gt;'; echo mysqli_stmt_num_rows($stmt).'&lt;/br&gt;'; echo "--------&lt;/br&gt;"; if (mysqli_stmt_affected_rows($stmt) == 1) &#123; mysqli_stmt_bind_result($stmt,$id,$username,$password); mysqli_stmt_reset($stmt); echo "登录成功"; echo "&lt;/br&gt;编号：".$id.'&lt;br/&gt;用户名:'.$username.'&lt;br/&gt;密码:'.$password; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHP第三十篇——数据库相关操作与分页功能封装]]></title>
    <url>%2F2018%2F12%2F28%2FPHP%E7%AC%AC%E4%B8%89%E5%8D%81%E7%AF%87%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E4%B8%8E%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[实现数据库相关操作(MySQLi)与分页功能初步实战与封装，入门学习笔记 连接与配置 123456789101112131415&lt;?php$config=[ 'host'=&gt;'localhost', 'user'=&gt;'root', 'password'=&gt;'root', 'charset'=&gt;'utf8', 'dbName'=&gt;'mysqli'];define('DB_HOST','localhost');define('DB_USER','root');define('DB_PWD','root');define('DB_CHARSET','utf8');define('DB_DBNAME','mysqli');define('DB_PORT','8889'); MySQL连接与d封装操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219&lt;?php/*** 连接* @param string $host* @param string $user* @param string $password* @param string $charset* @param string $database* @return object 连接标识符*/function connect1($host,$user,$password,$charset,$database) &#123; $link = mysqli_connect ( $host, $user, $password ) or die ( '数据库连接失败&lt;br/&gt;ERROR ' . mysqli_connect_errno () . ':' . mysqli_connect_error () ); mysqli_set_charset ( $link, $charset ); mysqli_select_db ( $link, $database ) or die ( '指定数据库打开失败&lt;br/&gt;ERROR ' . mysqli_errno ( $link ) . ':' . mysqli_error ( $link ) ); return $link;&#125;/*** 连接 需要传递数组* @param array $config* @return object*/function connect2($config) &#123; $link = mysqli_connect ( $config ['host'], $config ['user'], $config ['password'] ) or die ( '数据库连接失败&lt;br/&gt;ERROR ' . mysqli_connect_errno () . ':' . mysqli_connect_error () ); mysqli_set_charset ( $link, $config ['charset'] ); mysqli_select_db ( $link, $config ['dbName'] ) or die ( '指定数据库打开失败&lt;br/&gt;ERROR ' . mysqli_errno ( $link ) . ':' . mysqli_error ( $link ) ); return $link;&#125;/*** 用常量的形式建立连接* @return unknown*/function connect3()&#123; // define('DB_HOST','localhost'); // define('DB_USER','root'); // define('DB_PWD','root'); // define('DB_CHARSET','utf8'); // define('DB_DBNAME','mysqli'); // define('DB_POST','8889'); //mysqli_connect('localhost', 'root', 'root', 'mysqli','8889') $link = mysqli_connect ( DB_HOST, DB_USER, DB_PWD ,DB_DBNAME, DB_PORT) or die ( '数据库连接失败&lt;br/&gt;ERROR ' . mysqli_connect_errno () . ':' . mysqli_connect_error () ); mysqli_set_charset ( $link, DB_CHARSET ); mysqli_select_db ( $link, DB_DBNAME ) or die ( '指定数据库打开失败&lt;br/&gt;ERROR ' . mysqli_errno ( $link ) . ':' . mysqli_error ( $link ) ); // echo "连接成功"; return $link;&#125;/*array( 'username'=&gt;'king', 'password'=&gt;'king', 'age'=&gt;'12', 'regTime'=&gt;'123123123');INSERT user(username,password,age,regTime) VALUES('king','king','12','123123123');*//*** 插入操作* @param object $link* @param array $data* @param string $table* @return boolean*/function insert($link,$data,$table)&#123; $keys = join ( ',', array_keys ( $data ) ); $vals = "'" . join ( "','", array_values ( $data ) ) . "'"; $query = "INSERT &#123;$table&#125;(&#123;$keys&#125;) VALUES(&#123;$vals&#125;)"; $res = mysqli_query ( $link, $query ); if ($res) &#123; return mysqli_insert_id ( $link ); &#125; else &#123; return false; &#125;&#125;/*array( 'username'=&gt;'king123', 'password'=&gt;'king123', 'age'=&gt;'32', 'regTime'=&gt;'123123123');UPDATE user SET username='king123',password='king123',age='32',regTime='123123123' WHERE id=1*//*** 更新操作* @param object $link* @param array $data* @param string $table* @param string $where* @return boolean*/function update($link, $data, $table, $where = null) &#123; foreach ( $data as $key =&gt; $val ) &#123; $set .= "&#123;$key&#125;='&#123;$val&#125;',"; &#125; $set = trim ( $set, ',' ); $where = $where == null ? '' : ' WHERE ' . $where; $query = "UPDATE &#123;$table&#125; SET &#123;$set&#125; &#123;$where&#125;"; $res = mysqli_query ( $link, $query ); if ($res) &#123; return mysqli_affected_rows ( $link ); &#125; else &#123; return false; &#125;&#125;//DELETE FROM user WHERE id=/*** 删除操作* @param object $link* @param string $table* @param string $where* @return boolean*/function delete($link, $table, $where = null) &#123; $where = $where ? ' WHERE ' . $where : ''; $query = "DELETE FROM &#123;$table&#125; &#123;$where&#125;"; $res = mysqli_query ( $link, $query ); if ($res) &#123; return mysqli_affected_rows ( $link ); &#125; else &#123; return false; &#125;&#125;/*** 查询指定记录* @param object $link* @param string $query* @param string $result_type* @return array|boolean*/function fetchOne($link, $query, $result_type = MYSQLI_ASSOC) &#123; $result = mysqli_query ( $link, $query ); if ($result &amp;&amp; mysqli_num_rows ( $result ) &gt; 0) &#123; $row = mysqli_fetch_array ( $result, $result_type ); return $row; &#125; else &#123; return false; &#125;&#125;/*** 查询所有记录* @param object $link* @param string $query* @param string $result_type* @return array|boolean*/function fetchAll($link, $query, $result_type = MYSQLI_ASSOC) &#123; $result = mysqli_query ( $link, $query ); if ($result &amp;&amp; mysqli_num_rows ( $result ) &gt; 0) &#123; while ( $row = mysqli_fetch_array ( $result, $result_type ) ) &#123; $rows [] = $row; &#125; return $rows; &#125; else &#123; return false; &#125;&#125;/*** 得到表中的记录数* @param object $link* @param string $table* @return number|boolean*/function getTotalRows($link, $table) &#123; $query = "SELECT COUNT(*) AS totalRows FROM &#123;$table&#125;"; $result = mysqli_query ( $link, $query ); if ($result &amp;&amp; mysqli_num_rows ( $result ) == 1) &#123; $row = mysqli_fetch_assoc ( $result ); return $row ['totalRows']; &#125; else &#123; return false; &#125;&#125;/*** 得到结果集的记录条数* @param object $link* @param string $query* @return boolean*/function getResultRows($link, $query) &#123; $result = mysqli_query ( $link, $query ); if ($result) &#123; return mysqli_num_rows ( $result ); &#125; else &#123; return false; &#125;&#125;/*** @param object $link*/function getServerInfo($link) &#123; return mysqli_get_server_info ( $link );&#125;/*** @param object $link*/function getClientInfo($link) &#123; return mysqli_get_client_info ( $link );&#125;/*** @param object $link*/function getHostInfo($link)&#123; return mysqli_get_host_info($link);&#125;/*** @param object $link*/function getProtoInfo($link) &#123; return mysqli_get_proto_info ( $link );&#125; 分页功能的封装与实战操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;?php require_once 'mysql.func.php'; require_once 'config.php'; // 连接 $link=connect3(); // 表名 $table = 'user'; // 总条数 $totalRows = getTotalRows($link,$table); echo $totalRows; // 每页10条 $pageSize = 10; // 总页数 $totalPages = ceil($totalRows/$pageSize); echo $totalPages; // 接受当前页 $page = $_GET['page']?$_GET['page']:1; // 边界处理 if ($page&lt;1||$page==''||!is_numeric($page)) &#123; $page=1; &#125; if ($page&gt;$totalPages) &#123; $page=$totalPages; &#125; // 计算偏移量 $offset = ($page-1)*$pageSize; $query = "SELECT id,username,password,age,regtime FROM &#123;$table&#125; LIMIT &#123;$offset&#125;, &#123;$pageSize&#125;"; $users = fetchAll($link, $query); //var_dump($users); if (!$users) &#123; exit("没有用户数据"); &#125; // 形成用户列表?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;用户列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;用户列表&lt;/h2&gt; &lt;table border="1" width="80%" cellpadding="0" cellspacing="0" bgcolor="#ABCDEF"&gt; &lt;tr&gt; &lt;td&gt;编码&lt;/td&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;注册时间&lt;/td&gt; &lt;/tr&gt; &lt;?php foreach($users as $user):?&gt; &lt;tr&gt; &lt;td&gt;&lt;?php echo $user['id'];?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $user['username'];?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $user['password'];?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $user['age'];?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $user['regtime'];?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;?php endforeach;?&gt; &lt;/table&gt; &lt;p&gt; &lt;?php echo "&lt;a href=mainpage.php?page=1&gt;[首页]&lt;/a&gt;"; $prev = $page == 1 ? 1 : ($page-1); echo "&lt;a href=mainpage.php?page=".($prev)."&gt;[上一页]&lt;/a&gt;"; for ($i=1; $i&lt;=$totalPages ; $i++) &#123; // 当前页无连接 if ($page==$i) &#123; echo "[&#123;$i&#125;]"; &#125; else &#123; echo "&lt;a href='mainpage.php?page=&#123;$i&#125;'&gt;[&#123;$i&#125;]&lt;/a&gt;"; &#125; &#125; $nextv = $page == $totalPages ? $totalPages : ($page+1); echo "&lt;a href=mainpage.php?page=".($nextv)."&gt;[下一页]&lt;/a&gt;"; echo "&lt;a href=mainpage.php?page=$totalPages&gt;[尾页]&lt;/a&gt;"; ?&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHP第二十九篇——MySQLi入门与常用操作总结]]></title>
    <url>%2F2018%2F12%2F26%2FPHP%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B9%9D%E7%AF%87%E2%80%94%E2%80%94MySQLi%E5%85%A5%E9%97%A8%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[目录 1.数据库 2.SQL语言 3.MySQLi扩展简介 为什么使用MySQLi扩展 MySQLi的安装及配置 4.MySQLi操作数据库步骤 1.连接MySQL 2.设置字符集 3.打开指定数据库 4.执行SQL查询 增 删 改 查 5.释放结果集 6.关闭连接 5.MySQLi常用函数 连接相关 数据操作 预处理操作 结果集相关 事务 数据库 数据库是一某种有组织的方式存储数据或文件的集合，容器 表是一种结构化的文件(特定类型数据的结构化清单)，存储特定类型的数据 模式：描述了数据库和表的布局及特性信息，定义数据在表中如何存储，存储什么样的数据，数据如何分解，各部分信息如何命名 列：表中的一个字段 行：一条记录 主健：一列或一组(多)列，其值能唯一区分表中的每一行。即表示特定的行。习惯：不重用，不更新，不修改 任意两行都不具有相同的值 每一个行都必须具有一个主健值，且不允许为空 数据库的好处：将数据持久化到本地，可以实现结构化查询，方便管理 DB：数据库 DBMS：数据库管理系统/软件 SQL：结构化查询语言，用户和DBMS通讯 MySQL缺点: 并不总是支持其他DBMS提供的功能和特性 存储特点：将数据存储到表中，再将表存储到库中， 一个数据库中多个表，有名字且唯一。 表具有一些特性，定义数据在表中如何存储，类似‘类’。 表由列(字段)组成，类似’属性’. 表中数据按照行存储，类似‘对象’. DBMS分类 基础共享文件系统 基础客户机-服务器软件: 服务器负责所有数据的访问处理软件，客户机与用户打交道的软件。 MySQL在4中引入InnoDB引擎，增加事务处理，改进全文搜索。4.1增加函数库，子查询，集成帮助。5增加存储过程，触发器，游标，视图。 读写分离：路由和分发的DS(datasource) 一个server方法必须定位到一个唯一的数据库上 在应用中需要自己去确定或者高速路由DS,访问的真实目标DS 让路由知道有那些真实的DS和他们的名字对应 让路由根据我传入的名字去返回真实的DataSource 依赖注入容器：就是一个对象，他知道怎么样初始化并配置对象及其依赖的所有对象 SQL语言 DQL：数据库查询语言 基础查询，条件查询，排序查询，常见函数，分组函数，分组查询，连接查询，子查询，分页查询，union查询 DML：数据操作语言 插入，修改，删除 DDL：数据定义语言 库和表管理，常见数据类型，常见约束 TCL：事务控制语言 事务和事务处理 不区分大小写：建议关键字大小，自定义名字小写！分号结尾，索引与换行注释 (#)或(– )或(/ /) 相关操作 显示所有数据库 show databases; 使用(进入)指定数据库 use mysql; 显示库中所有表 show tables; show tables from phpstudy; 选择查询当前所在数据库 select databases(); 创建表： create table t_mysql (id int, name varchar(20)); 删除表： drop table t_mysql; 查看表结构： desc t_mysql; 插入数据： insert into t_mysql (id, name) values (2,”Vivian”); 查询数据库所有字段： select * from t_mysql; 更新数据库： update t_mysql set name=”MySQL” where id=4; 删除表中数据 delete from t_mysql where id=4 or name=”MySQL”; delete from t_mysql; // 删除所有 使用delete删除的数据可以找回使用drop删除的数据找不回来 查看版本： mysql&gt; select version(); MySQLi简介PHP5.4之后mysql扩展废弃，不再更新，官方推荐使用mysqli，mysqli是mysql扩展的增强版，5.4默认支持 #####mysqli功能 操作数据库 面向对象和面向过程 支持预处理 支持多语句 支持事务 MySQLi配置 略过安装，因为默认支持，如果是集成环境，也是不用安装和配置的！ 配置php_mysqli.dll扩展，在php.ini中开启 配置extension_dir=”ext所在目录” 重启服务器 MySQL相关配置 mysqli.max_persistent = -1 可以创建的持久化连接的最大数量，-1代表无限制 mysqli.allow_local_infile = On 允许Mysql的Load Data语句访问PHP角度看的本地文件。 mysqli.allow_persistent = On 开启使用mysqli_connect()函数创建持久化连接的能力 mysqli.max_links = -1 最大连接数，-1代表无限制 mysqli.default_port = 3306 默认端口号3306 mysqli.default_socket = 当连接到本地数据库服务器时如果没有指定其他socket名称，使用的默认socket名称 mysqli.default_host = 当连接到数据库服务器时， 如果没有指定其他主机地址，使用的默认服务器主机。不要在 安全模式下使用 mysqli.default_user = 当连接到数据库服务器时，如果没有指定其他用户名，使用的默认用户名。不要在 安全模式下使用。 mysqli.default_pw = 当连接到数据库服务器时，如果灭有指定其他密码，使用的默认密码。不要在 安全模式下使用。 mysqli.reconnect = Off 连接丢失时是否自动重新连接。 MySQLi检测 phpinfo #php配置 extension_loaded(‘mysqli’) #连接方法 mysqli_connect() # 直接调用 function_exists(‘mysqli_connect’) #是否存在方法 get_defined_functions() #s获取定义的方法 MySQLi操作步骤PHP打开错误提示和关闭错误提示的方法 找到php的配置文件，也就是php.ini 在文件中查找 ‘display_errors’ 查找到 display_errors = Off 或者 display_errors = On， Off为关闭错误提示，On为打开错误提示，根据需求修改即可。 也可在php文件中加入以下代码 123456//禁用错误报告error_reporting(0);//报告运行时错误error_reporting(E_ERROR | E_WARNING | E_PARSE);//报告所有错误error_reporting(E_ALL); 一、建立连接 直接连接 12345678910header('content-type:text/html;charset=utf-8');##### 建立连接: 这里使用MAMP默认提供的mysql和端口$link = mysqli_connect('localhost', 'root', 'root', 'mysqli','8889');var_dump($link);if (!$link) &#123; echo "错误连接"; echo 'ERROR'.mysqli_connect_errno().':'.mysqli_connect_error(); exit();&#125;echo "成功"; 初始化连接 12345678910111213141516171819$link=mysqli_init();if(!$link)&#123; die('MySQLi Init Failed');&#125;设置连接选项if(!mysqli_options($link,MYSQLI_INIT_COMMAND,'SET AUTOCOMMIT=0'))&#123; die('MySQLI Options Failed');&#125;//建立MySQL的连接if(!mysqli_real_connect($link,'localhost','root','root'))&#123; die('Connect Error &lt;br/&gt;'.mysqli_connect_errno().':'.mysqli_connect_error());&#125;if(mysqli_ping($link))&#123; echo 'Connect is Ok';&#125;else&#123; echo 'Error '.mysqli_error();&#125; 查看配置信息 123456789101112131415//得到和MySQL相关信息echo 'MySQL客户端版本信息：'.mysqli_get_client_info($link).'&lt;br/&gt;';echo 'MySQL客户端版本：'.mysqli_get_client_version($link).'&lt;br/&gt;';echo 'MySQL服务器的版本号：'.mysqli_get_server_info($link).'&lt;br/&gt;';echo 'MySQL服务器的版本：'.mysqli_get_server_version($link).'&lt;br/&gt;';echo 'MySQL服务器主机名和连接类型：'.mysqli_get_host_info($link).'&lt;br/&gt;';echo 'MySQL协议的版本信息：'.mysqli_get_proto_info($link).'&lt;br/&gt;';echo '当前系统的状态：'.mysqli_stat($link).'&lt;br/&gt;';echo '当前线程连接ID：'.mysqli_thread_id($link).'&lt;br/&gt;';if(mysqli_thread_safe())&#123; echo '启动安全线程';&#125;else&#123; echo '未启动安全线程';&#125; 错误类型 1》用户名密码不正确 Warning: mysqli_connect(): (HY000/1045): Access denied for user ‘root‘@’localhost’(using password: YES) in G:\maizi\PHPAdvance\MySQLi\2-mysqli_connect.php on line 5bool(false) 2》MySQL服务器没有开启 ERROR 2003 (HY000): Can’t connect to MySQL server on ‘localhost’ (10061)Warning: mysqli_connect(): in G:\maizi\PHPAdvance\MySQLi\2-mysqli_connect.php on line 13bool(false) 抑制错误： @mysqli_connect(‘localhost’, ‘root’, ‘root’, ‘mysqli’,’8889’) or die(‘数据库连接失败ERROR’.mysqli_connect_errno().’:’.mysqli_connect_error()); 12//mysqli_connect_errno():连接产生的错误编号//mysqli_connect_error():连接产生的错误信息 二、设置字符集 命令：SET NAMES GBK mysqli_set_charset($link, ‘UTF8’); mysqli_query($link, ‘SET NAMES UTF8’); print_r(mysqli_character_set_name($link)); // 默认 print_r(mysqli_get_charset($link)); // 获取 三、打开指定数据库$res = mysqli_select_db($link,&apos;mysqli&apos;); # or die(&apos;指定数据库不存在&lt;\br&gt;&apos;.mysqli__errno($link).&apos;:&apos;.mysqli__error($link)); var_dump($res); 执行SQL查询 SQL直接Query创建和插入 123456789101112131415161718执行SQL查询 mysqli_query()执行SQL查询//创建test2数据库// $sql="CREATE DATABASE IF NOT EXISTS test2 DEFAULT CHARACTER SET 'utf8'";// $sql="DROP DATABASE IF EXISTS test2";// mysqli_query($link,$sql);/*mysqli_query($link,$sql):执行SQL查询1》只能执行一条SQL语句，SQL语句可以没有分号 2》mysqli_query()执行SELECT/SHOW/EXPLAIN/DESC/DESCRIBE这样关键字的SQL语句，执行成功返回的是mysqli_result结果集，执行失败返回false；执行其他SQL语句，执行成功返回true，失败返回false */$sql=&lt;&lt;&lt;EOFINSERT user(username,password,age,regTime)VALUES('king1','king1',123,'123123');EOF;$res=mysqli_query($link,$sql);var_dump($res); SQL-Query插入和查询 123456789101112131415161718192021执行SQL查询// $sql='INSERT user(username,password,age,regTime) VALUES("maizi1","maizi1",3,"1234123")';// $sql="INSERT user1(id,username,password,age,regTime) VALUES(8,'queen','queen',14,'123123123')";$sql=&lt;&lt;&lt;EOFINSERT user(username,password,age,regTime) VALUES('maizi11','maizi11',3,'123123'),('maizi12','maizi12',3,'123123'),('maizi13','maizi13',3,'123123'),('maizi14','maizi14',3,'123123'),('maizi15','maizi15',3,'123123');EOF;$res=mysqli_query($link,$sql);if($res)&#123; // mysqli_insert_id($link)：得到上一步插入操作产生的自增长(AUTO_INCREMENT)值,如果表中没有自增长，返回0 $lastInsertId=mysqli_insert_id($link); echo '恭喜您注册成功，您是网站的第'.$lastInsertId.'位用户&lt;br/&gt;'; //mysqli_affected_rows($link):得到上一步操作产生的受影响的记录数 $affectRows=mysqli_affected_rows($link); echo 'Query Ok, '.$affectRows.' Rows Affected';&#125;else&#123; echo 'Insert Error '.mysqli_errno($link).':'.mysqli_error($link);&#125; mysqli_affected_rows 123456789101112执行SQL查询// $sql="INSERT user(username,password,age,regTime) VALUES('AA','AA',12,'123123')";// $sql="UPDATE user SET age=78 WHERE id&lt;=5";$sql="DELETE FROM user324234 WHERE id=9";$res=mysqli_query($link,$sql);echo '受影响的记录数为：'.mysqli_affected_rows($link).'&lt;br/&gt;';/* mysqli_affected_rows($link):得到上一步操作产生的受影响的记录数 大于0的：受影响的记录数 等于0：没有记录被影响 等于-1：代表的SQL语句有问题 */ mysqli_fetch 123456789101112131415161718192021222324252627282930313233343536执行SQL查询$sql="SELECT * FROM user";// $sql="SHOW DATABASES;";// $sql="DESC user";// $sql="DESCRIBE user";// $sql="EXPLAIN SELECT * FROM user WHERE id=12";$result=mysqli_query($link,$sql);//得到结果集中的记录条数echo '结果集中记录条数为：'.mysqli_num_rows($result).'&lt;br/&gt;';echo '上一步操作产生的受影响的记录条数为：'.mysqli_affected_rows($link).'&lt;br/&gt;';echo '结果集中字段数为：'.mysqli_num_fields($result).'&lt;br/&gt;';echo '获得最近一次查询所得到的列数：'.mysqli_field_count($link).'&lt;br/&gt;';echo '&lt;hr color="red"/&gt;';//取得结果集中的记录// mysqli_fetch_row($result):取得结果集中的一条记录作为索引数组返回echo '&lt;pre&gt;';$row=mysqli_fetch_row($result);print_r($row);//mysqli_fetch_assoc($result):取得结果集中的一条记录作为关联数组返回$row=mysqli_fetch_assoc($result);print_r($row);//mysqli_fetch_array($result,$result_type):取得结果集中的一条记录作为关联数组或者索引数组或者二者都有的数组来返回$row=mysqli_fetch_array($result, MYSQLI_ASSOC);/* $result_type的值为： MYSQLI_BOTH:关联+索引 MYSQLI_ASSOC:关联 MYSQLI_NUM:索引 */print_r($row);// mysqli_fetch_object($result):作为对象返回$row=mysqli_fetch_object($result);print_r($row);echo '&lt;hr color="red"/&gt;';var_dump(mysqli_fetch_assoc($result)); 查询并显示用户列表数据 mysqli_fetch 1234567891011121314151617181920212223242526272829执行SQL查询$sql="SELECT * FROM user";//5.得到所有记录$result=mysqli_query($link,$sql);//是结果集，并且结果集中有记录// if($result &amp;&amp; mysqli_num_rows($result)&gt;0)&#123;// while($row=mysqli_fetch_assoc($result))&#123;// $rows[]=$row;// &#125;// &#125;else&#123;// echo '没有记录&lt;br/&gt;';// &#125;// print_r($rows);// if($result &amp;&amp; mysqli_num_rows($result)&gt;0)&#123;// // $rows=mysqli_fetch_all($result);// $rows=mysqli_fetch_all($result,MYSQLI_BOTH);// &#125;// print_r($rows);$string=join('',array_merge(range('a','z'),range('A','Z')));for($i=1;$i&lt;=100;$i++)&#123; $username=substr(str_shuffle($string),0,5); $password=md5($username); $age=mt_rand(1,99); $regTime=time()+10*$i; $sql="INSERT user(username,password,age,regTime) VALUES('&#123;$username&#125;','&#123;$password&#125;','&#123;$age&#125;','&#123;$regTime&#125;')"; mysqli_query($link,$sql);&#125; user_list 1234567891011121314151617181920212223242526272829303132333435执行SQL查询$sql="SELECT id,username,age,regTime FROM user";//5.得到所有记录$result=mysqli_query($link,$sql);if($result &amp;&amp; mysqli_num_rows($result)&gt;0)&#123; $rows=mysqli_fetch_all($result,MYSQLI_ASSOC);&#125;?&gt;&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;用户列表&lt;/h3&gt;&lt;table border='1' cellpadding='0' cellspacing='0' bgcolor='#ABCDEF' width='80%'&gt; &lt;tr&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;注册时间&lt;/td&gt; &lt;/tr&gt; &lt;?php $i=1; foreach($rows as $user):?&gt; &lt;tr&gt; &lt;td&gt;&lt;?php echo $i++;?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $user['username'];?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $user['age'];?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo date("Y-m-d H:i:s",$user['regTime']);?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;?php endforeach;?&gt;&lt;/table&gt; &lt;/body&gt;&lt;/html&gt; mysqli_data_seek 12345678910111213141516171819202122232425262728$sql="SELECT * FROM user";$result=mysqli_query($link, $sql);echo '&lt;pre&gt;';// $row=mysqli_fetch_assoc($result);// print_r($row);// $row=mysqli_fetch_assoc($result);// print_r($row);// $row=mysqli_fetch_assoc($result);// print_r($row);// echo '&lt;hr/&gt;';// //mysqli_data_seek($result,$offset):将结果集的指针移动到指定位置// mysqli_data_seek($result, 0);// $row=mysqli_fetch_assoc($result);// print_r($row);$rows=mysqli_fetch_all($result,MYSQLI_ASSOC);print_r($rows);echo '&lt;hr color="red"/&gt;';mysqli_data_seek($result, 0);$row=mysqli_fetch_assoc($result);print_r($row);echo '&lt;hr color="pink"/&gt;';//释放结果集mysqli_free_result($result);//关闭连接mysqli_close($link);mysqli_set_charset($link,'utf8'); mysqli_field 123456789101112131415161718$sql="SELECT * FROM user";$result=mysqli_query($link, $sql);echo '结果集中字段数：'.mysqli_num_fields($result).'&lt;br/&gt;';echo mysqli_field_count($link).'&lt;br/&gt;';echo '&lt;hr/&gt;';echo '&lt;pre&gt;';// $fieldInfo=mysqli_fetch_field($result);// print_r($fieldInfo);// $fieldInfo=mysqli_fetch_field($result);// print_r($fieldInfo);// $fieldsInfo=mysqli_fetch_fields($result);// print_r($fieldsInfo);echo '当前指针所在位置：'.mysqli_field_tell($result).'&lt;br/&gt;';print_r(mysqli_fetch_field_direct($result, 0)).'&lt;br/&gt;';echo '&lt;hr/&gt;';mysqli_field_seek($result, 3);echo '当前指针所在位置：'.mysqli_field_tell($result).'&lt;br/&gt;'; mysqli_multi_query 1234567//执行多条SQL语句,每条SQL语句一定要以分号结尾，否则就会失败//如果多条SQL语句中有一条失败了，整个都会失败$sql="DELETE FROM user WHERE id=3;";$sql.="INSERT user(username,password,age,regTime) VALUES('AAAA1','AAAAA1',99,'1234123');";$sql.="UPDATE user123 SET age=5 WHERE id=1;";$res=mysqli_multi_query($link,$sql);var_dump($res); mysqli_multi_result 12345678910111213141516$sql ="SELECT id,username,age,regTime FROM user limit 5;";$sql.="SELECT VERSION() AS mysql_version;";$sql.="SELECT NOW() AS time_now;";$sql.="SELECT * FROM mysql.user;";$res=mysqli_multi_query($link, $sql);//mysqli_store_result():传输上一次产生的结果集//mysqli_more_results():判读是否有更多的结果集//mysqli_next_result():将结果集的指针向下移动一位if($res)&#123; do&#123; if($result=mysqli_store_result($link))&#123; $rows[]=mysqli_fetch_all($result,MYSQLI_ASSOC); &#125; &#125;while(mysqli_more_results($link)&amp;&amp;mysqli_next_result($link));&#125;print_r($rows); mysqli_prepare 1234567891011121314151617181920212223242526require_once 'conn.php';$sql="INSERT user(username,password,age,regTime) VALUES(?,?,?,?)";$stmt=mysqli_prepare($link, $sql);//准备要执行的SQL语句// print_r($stmt);$username='maizi123412';$password='maizi123412';$age=3;$regTime=time();@mysqli_stmt_bind_param($stmt, 'ssii',$username,$password,$age);$res=mysqli_stmt_execute($stmt);if(!$res)&#123; die ("ERROR ".mysqli_stmt_errno($stmt).':'.mysqli_stmt_error($stmt));&#125;$username='maizi1234567';$password='maizi1234567';$age=35;$regTime=time();mysqli_stmt_execute($stmt);echo '受影响的记录条数为：'.mysqli_stmt_affected_rows($stmt).'&lt;br/&gt;';echo '得到AUTO_INCREMENT的之为：'.mysqli_stmt_insert_id($stmt).'&lt;br/&gt;';mysqli_stmt_close($stmt);mysqli_close($link); mysqli_stmt_bind_result 1234567891011121314151617require_once 'conn.php';$sql="SELECT id,username,age FROM user WHERE id&lt;=?";if($stmt=mysqli_prepare($link, $sql))&#123; echo mysqli_stmt_param_count($stmt).'个参数&lt;br/&gt;'; $id=143; mysqli_stmt_bind_param($stmt, 'i',$id); mysqli_stmt_execute($stmt); mysqli_stmt_bind_result($stmt,$res_id,$res_username,$res_age);// mysqli_stmt_fetch($stmt);// printf('我的编号为：'.$res_id.'--我的名字为：'.$res_username.'--我的年龄为：'.$res_age); while(mysqli_stmt_fetch($stmt))&#123; printf('我的编号为：'.$res_id.'--我的名字为：'.$res_username.'--我的年龄为：'.$res_age); echo '&lt;hr/&gt;'; &#125; echo '&lt;hr color="red"/&gt;'; &#125; mysqli_stmt_data_seek 1234567891011121314151617require_once 'conn.php';$sql="SELECT id,username,age FROM user WHERE id&lt;=30";if($stmt=mysqli_prepare($link, $sql))&#123; mysqli_execute($stmt); mysqli_stmt_store_result($stmt); echo '受影响的记录条数为：'.mysqli_stmt_affected_rows($stmt).'&lt;br/&gt;'; echo '结果集中的记录条数为：'.mysqli_stmt_num_rows($stmt).'&lt;br/&gt;'; mysqli_stmt_bind_result($stmt,$id,$username,$age); while(mysqli_stmt_fetch($stmt))&#123; echo '编号：'.$id.'--'.'用户名：'.$username.'--年龄：'.$age."&lt;hr/&gt;"; &#125; echo '&lt;hr color="red"/&gt;'; mysqli_stmt_data_seek($stmt, 1); mysqli_stmt_bind_result($stmt,$id,$username,$age); mysqli_stmt_fetch($stmt); echo '编号：'.$id.'--'.'用户名：'.$username.'--年龄：'.$age."&lt;hr/&gt;";&#125; mysqli_commit 1234567891011121314require_once 'conn.php';//关闭自动提交mysqli_autocommit($link, FALSE);$sql="UPDATE account SET money=money-2000 WHERE username='maizi'";$res=mysqli_query($link, $sql);$sql='UPDATE account123 SET money=money+2000 WHERE username="king"';$res1=mysqli_query($link,$sql);if($res &amp;&amp; $res1)&#123; mysqli_commit($link);//提交 mysqli_autocommit($link, TRUE);&#125;else&#123; mysqli_rollback($link);//回滚&#125; reg 12345678910111213141516171819202122232425262728&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;注册页面&lt;/h3&gt;&lt;form action="doAction.php?act=reg" method='post'&gt;&lt;table border='1' width='80%' cellpadding='0' cellspacing='0' bgcolor='#ABCDEF' &gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="username" id="" placeholder='请输入合法用户名'/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type="password" name="password" id="" placeholder='密码不能为空' /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan='2'&gt; &lt;input type="submit" value="注册" /&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/form&gt; &lt;/body&gt;&lt;/html&gt; testFunction 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051header('content-type:text/html;charset=utf-8');require_once 'functions/mysql.func.php';require_once 'config/config.php';// $host='localhost';// $user='root';// $password='root';// $charset='utf8';// $database='test1';// $link=connect1($host, $user, $password, $charset, $database);// var_dump($link);// $link=connect2($config);// var_dump($link);$link=connect3();// var_dump($link);// $array=[// 'username'=&gt;'queen1',// 'password'=&gt;md5('queen1'),// 'age'=&gt;22,// 'regTime'=&gt;time()// ];$table='user';// if(insert($link, $array, $table))&#123;// echo '注册成功';// &#125;else&#123;// echo '注册失败';// &#125;// $array=['age'=&gt;'12'];// // $res=update($link, $array, $table);// $res=update($link,$array,$table,'id=2');// if($res)&#123;// echo '更新成功';// &#125;else&#123;// echo '更新失败';// &#125;// $res=delete($link, $table,'id=3');// if($res)&#123;// echo '删除成功';// &#125;else&#123;// echo '删除失败';// &#125;$query="SELECT id,username,age FROM user WHERE id=1";$row=fetchOne($link, $query);print_r($row);echo '&lt;hr/&gt;';$query="SELECT id,username,age FROM user WHERE id&gt;=1";$rows=fetchAll($link, $query);print_r($rows);echo '&lt;hr/&gt;';echo getTotalRows($link,'user1'); 释放结果集关闭连接MySQLi常见函数连接连接 mysqli_connect() 作用 打开一个到MySQL服务器的新的连接 语法 mysqli mysqli_connect ([ string $host = ini_get(“mysqli.default_host”) [, string $username = ini_get(“mysqli.default_user”) [, string $passwd = ini_get(“mysqli.default_pw”) [, string $dbname = “” [, int $port = ini_get(“mysqli.default_port”) [, string $socket = ini_get(“mysqli.default_socket”) ]]]]]] ) mysqli_real_connect() 作用 建立一个 MySQL 服务器连接 语法 bool mysqli_real_connect ( mysqli $link [, string $host [, string $username [, string $passwd [, string $dbname [, int $port [, string $socket [, int $flags ]]]]]]] ) 注意 mysqli_real_connect() 需要一个有效的对象，这个对象由 mysqli_init() 创建 可以使用 mysqli_options() 设置各种连接设置 提供 flags 参数 mysqli_init() 作用 初始化mysqli并且返回一个由mysqli_real_connect使用的资源类型。 语法 mysqli mysqli_init ( void ) mysqli_options() 作用 设置选项 语法 bool mysqli_options ( mysqli $link , int $option , mixed $value ) 注意 常用选项 mysqli_ping() 作用 ping一个服务器连接，或者如果那个连接断了尝试重连 语法 bool mysqli_ping ( mysqli $link ) 错误 mysqli_connect_errno() 作用 返回最后一次连接调用的错误代码 mysqli_connect_error() 作用 返回一个字符串描述的最后一次连接调用的错误代码 mysqli_errno() 作用 返回最近的函数调用产生的错误代码 语法 int mysqli_errno ( mysqli $link ) mysqli_error() 作用 返回字符串描述的最近一次函数调用产生的错误代码 语法 string mysqli_error ( mysqli $link ) 字符集 mysqli_character_set_name() 作用 返回数据库连接的默认字符集 mysqli_get_charset() 作用 返回对象的字符集 语法 object mysqli_get_charset ( mysqli $link ) mysqli_set_charset() 作用 设置默认的客户端字符集 语法 bool mysqli_set_charset ( mysqli $link , string $charset ) 信息相关 mysqli_get_client_info() 作用 返回字符串类型的Mysql客户端版本信息 语法 string mysqli_get_client_info ( mysqli $link )mysqli_get_client_version() 作用 将 MySQL 客户端库版本作为整数返回 语法 int mysqli_get_client_version ( mysqli $link ) mysqli_get_server_info() 作用 返回MySQL服务器的版本号 语法 string mysqli_get_server_info ( mysqli $link )mysqli_get_server_version() 作用 作为一个整数返回MySQL服务器的版本 语法 int mysqli_get_server_version ( mysqli $link ) mysqli_get_host_info() 作用 返回 MySQL 服务器主机名和连接类型。 语法 string mysqli_get_host_info ( mysqli $link ) mysqli_get_proto_info() 作用 返回使用的Mysql协议的版本信息 语法 int mysqli_get_proto_info ( mysqli $link ) mysqli_stat() 作用 获取当前系统状态 语法 string mysqli_stat ( mysqli $link ) mysqli_thread_id() 作用 返回当前连接的线程ID 语法 int mysqli_thread_id ( mysqli $link ) mysqli_thread_safe() 作用 返回是否设定了线程安全 语法 bool mysqli_thread_safe ( void ) 数据操作数据库 mysqli_select_db() 作用 为数据库查询选择默认数据库 语法 bool mysqli_select_db ( mysqli $link , string $dbname ) 数据 mysqli_query() 作用 执行SQL查询 语法 mixed mysqli_query ( mysqli $link , string $query [, int $resultmode = MYSQLI_STORE_RESULT ] ) 注意 $resultmode值 MYSQLI_USE_RESULT,检索大数据量 MYSQLI_STORE_RESULT,默认值 执行其它查询，成功返回true，失败返回false mysqli_real_query() 作用 执行一个mysql查询 语法 bool mysqli_real_query ( mysqli $link , string $query ) 注意 执行一个单条数据库查询, 其结果可以使用mysqli_store_result()或mysqli_use_result()检索或存储. 可以通过mysqli_field_count()得到结果集的数量 mysqli_multi_query() 作用 在数据库上执行一个多语句查询 mysqli_affected_rows() 作用 得到上一次MySQL操作影响的记录数 语法 int mysqli_affected_rows ( mysqli $link ) mysqli_insert_id() 作用 返回上一插入操作产生的AUTO_INCREMENT的值 语法 mixed mysqli_insert_id ( mysqli $link ) 预处理操作 mysqli_prepare() 作用 准备一个用于执行的SQL语句 语法 mysqli_stmt mysqli_prepare ( mysqli $link , string $query ) mysqli_stmt_bind_param() 作用 将一个变量作为参数绑定到prepared语句上 语法 bool mysqli_stmt_bind_param ( mysqli_stmt $stmt , string $types , mixed &amp;$var1 [, mixed &amp;$… ] ) 注意 $types的值 mysqli_stmt_bind_result() 作用 将一个变量绑定到一个prepared语句上用于结果存储 语法 bool mysqli_stmt_bind_result ( mysqli_stmt $stmt , mixed &amp;$var1 [, mixed &amp;$… ] )mysqli_stmt_execute() 作用 执行一个prepared查询 语法 bool mysqli_stmt_execute ( mysqli_stmt $stmt ) mysqli_stmt_affected_rows() 作用 返回最后一条倍执行的语句改变，删除或插入的总行数 语法 int mysqli_stmt_affected_rows ( mysqli_stmt $stmt ) mysqli_stmt_insert_id() 作用 获取前一个INSERT操作生成的ID 语法 mixed mysqli_stmt_insert_id ( mysqli_stmt $stmt ) mysqli_stmt_errno() 作用 返回最近一次语句调用的错误代码 语法 int mysqli_stmt_errno ( mysqli_stmt $stmt ) mysqli_stmt_error() 作用 返回最后一条语句错误的字符串描述 语法 string mysqli_stmt_error ( mysqli_stmt $stmt ) mysqli_stmt_num_rows() 作用 返回语句结果集中的行数 语法 int mysqli_stmt_num_rows ( mysqli_stmt $stmt ) mysqli_stmt_param_count() 作用 返回给定语句中参数数量 语法 int mysqli_stmt_param_count ( mysqli_stmt $stmt ) mysqli_stmt_data_seek() 作用 查看语句结果集中的任意行 语法 void mysqli_stmt_data_seek ( mysqli_stmt $stmt , int $offset ) mysqli_stmt_fetch() 作用 从一个prepared语句中抓取结果到指定变量中 语法 bool mysqli_stmt_fetch ( mysqli_stmt $stmt ) mysqli_stmt_free_result() 作用 释放给定语句处理存储的结果集所占内存 语法 void mysqli_stmt_free_result ( mysqli_stmt $stmt ) mysqli_stmt_num_rows() 作用 返回结果集中记录的条数 语法 int mysqli_stmt_num_rows ( mysqli_stmt $stmt ) mysqli_stmt_store_result() 作用 从一个prepared语句中传输一个结果集 语法 bool mysqli_stmt_store_result ( mysqli_stmt $stmt ) 结果集 mysqli_use_result() 作用 初始化一个结果集的取回 语法 mysqli_result mysqli_use_result ( mysqli $link ) mysqli_more_results() 作用 检查一个多语句查询是否还有其他查询结果集 语法 bool mysqli_more_results ( mysqli $link ) mysqli_next_result() 作用 从multi_query中准备下一个结果集 语法 bool mysqli_next_result ( mysqli $link ) mysqli_num_rows() 作用 获取结果集中记录条数 语法 int mysqli_num_rows ( mysqli_result $result ) mysqli_fetch_all() 作用 抓取所有的结果行并且以关联数据，数值索引数组，或者两者皆有的方式返回结果集。仅可用于 mysqlnd。 语法 mixed mysqli_fetch_all ( mysqli_result $result [, int $resulttype = MYSQLI_NUM ] ) mysqli_fetch_array() 作用 以一个关联数组，数值索引数组，或者两者皆有的方式抓取一行结果 语法 mixed mysqli_fetch_array ( mysqli_result $result [, int $resulttype = MYSQLI_BOTH ] ) mysqli_fetch_assoc() 作用 以一个关联数组方式抓取一行结果 语法 array mysqli_fetch_assoc ( mysqli_result $result ) mysqli_fetch_row() 作用 以索引数组返回结果集中的一行 语法 mixed mysqli_fetch_row ( mysqli_result $result ) mysqli_fetch_object() 作用 以一个对象的方式返回一个结果集中的当前行 语法 object mysqli_fetch_object ( mysqli_result $result [, string $class_name = “stdClass” [, array $params ]] ) mysqli_data_seek() 作用 将结果中的结果指针调整到任意行 语法 将结果中的结果指针调整到任意行 mysqli_field_count() 作用 返回最近一次查询获取到的列的数目 语法 int mysqli_field_count ( mysqli $link ) mysqli_num_fields() 作用 获取结果中字段数量 语法 int mysqli_num_fields ( mysqli_result $result ) mysqli_fetch_field() 作用 从结果集中取得下一字段（列），并作为对象返回 语法 mysqli_fetch_field(result); mysqli_fetch_fields() 作用 返回一个代表结果集字段的对象数组 语法 array mysqli_fetch_fields ( mysqli_result $result ) mysqli_field_seek() 作用 设置结果指针到特定的字段开始位置 语法 bool mysqli_field_seek ( mysqli_result $result , int $fieldnr ) mysqli_field_tell() 作用 获取当前字段在结果集指针中的开始位置 语法 int mysqli_field_tell ( mysqli_result $result ) mysqli_fetch_field_direct() 作用 抓取一个单字段的元数据 语法 object mysqli_fetch_field_direct ( mysqli_result $result , int $fieldnr ) 事务 mysqli_autocommit() 作用 打开或关闭数据库的自动提交功能 语法 bool mysqli_autocommit ( mysqli $link , bool $mode ) mysqli_commit() 作用 提交当前事务 语法 bool mysqli_commit ( mysqli $link ) mysqli_rollback() 作用 回滚当前事务 语法 bool mysqli_rollback ( mysqli $link )]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHP第二十八篇——接口设计规范]]></title>
    <url>%2F2018%2F12%2F25%2FPHP%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AB%E7%AF%87%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[任何事情都有规律可行，也有一定的规范性，但是认识或的，规范是死的，能够灵活应用就够了。比如iOS，Android，前段等等一些开发过程中都会有一些规范可寻，按照一定的规范写出来的东西能够更容易迭代与修复问题，更容易给后面的人接手…… 接口设计规范这里大概整理了一下APP开发接口的一些规范，我们可以根据实际开发，实际需求做相应的调整。 1.制定规范开发前一定要定好一个规范，比如要定好数据返回的通用参数和格式。 关于数据格式，用的比较多的有xml和json，我建议用json，因为json比xml的好处更多。 2.精简的返回数据接口数据因符合需要什么返回什么的原则，比如要查询某个用户的余额和注册时间，网页里面的做法可能是select * from user where uid=1，但是接口一定要select balance,regtime from user where uid=1。 因为接口返回数据是要有开销的，要流量的，能少返回数据就尽量少返回，这样可以大大的提高性能。 3.数据类型要严格要注意数据的类型，整数类型的数据一定要转为int， 因为app客户端开发的java、object-c语言对数据类型比较严格，类型不对会照成app闪退。 4.要写接口文档一定要写好接口文档，并按照模块写，而且还要书写规范，最好的格式是： 接口请求地址； 请求参数（包括参数名、类型、是否必填）； 测试参数举例；返回参数（参数名，并注明每个参数的含义）。 这样哪怕以后项目很大，以不会照成维护困难的问题。 5.保证代码正确性要验证保证代码正确无误，而且生成环境中要屏蔽掉错误，避免头部有额外的输出，照成返回的json等数据解析失败而导致app闪退等。 6.要优化代码的性能app要求响应迅速，这样才能给用户比较好的体验感。所以移动接口端在处理业务逻辑的时候，要避免不要执行太复杂的sql语句，或者含有大量的循环，能做成缓存的尽量做缓存，比如将首页的热点模块信息可以存到redis缓存中。 在不考虑网速的情况下，比较理想的接口响应时间应该是200毫秒以内。 7.不要随意更改旧接口app不像网页，app一旦发布，有人使用之后，接口就不要乱修改了。 以后升级也是，修改要在保证接口原有结构之上进行额外的扩展，否则会导致调用旧版接口的app出现bug。 8. 注意接口的安全安全高于一切，必须要保证接口的安全。 电话号码等敏感信息在传输的过程中一定要加密，否则可能会被别人抓包到。 拿取用户信息的接口一定要验证权限，以防止接口被恶意调用，泄密用户信息，甚至篡改信息。 处于安全考虑，应当在传值的时候加个验证字段，比如…?token=wedwdwfwf,将token值进行判断后再决定是否给予返回值，你还可以参考一下微信的借口，给用户提供了一个appid和appkey，token值需要根据这两个值去获取，并且获取到的token2小时的有效期，从很大程度上提高了安全性。 希望对你实际开发中有用！！！]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>接口设计规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第二十七篇——服务器500错误总结]]></title>
    <url>%2F2018%2F12%2F25%2FPHP%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E7%AF%87%E2%80%94%E2%80%94%E6%9C%8D%E5%8A%A1%E5%99%A8500%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[之前做客户端开发的时候，经常出现500错误，当时能做的就是告诉后台：某某api出现了500，然后没有几分钟就好了。而且一个项目下来出现最多次数的也就是500…… 500错误接触了服务器开发之后，自己在写一些简单接口的时候，也总是发现500，而且几乎所有的500都不是一样原因导致，所以就找了一些教程，并请教了有些大神，自己在接口开发中也掌握了不少相关了技巧。 如果你在学习或者开发中也遇到了，比较奇葩500错误，可以联系我，我们一起交流讨论，一并整理出来。 出现500错误的原因是很多的，一般来说，如果程序出错，那么在浏览器内会返回给用户一个友好的错误提示，统一称之为服务器500错误。 解决的方法就是您必须在http中能够正确的获得错误信息，方法为：请打开浏览器，选择工具，internet选项，高级，在高级中的浏览项目里面有一个\&quot;显示http友好错误提示\&quot;的复选框，请取消该复选框，这样您可以获得正确的错误提示。 在获得正确的错误提示之后，您就可以根据该错误提示检查您具体的出错原因了 HTTP 500错误一定是你的PHP代码有错误，PHP解释器执行不了。两个方法找错误 1) 用有语法检查提示的编辑器，比如Eclipse打开你的文件看看有没有错误提示，注意require里面的文件也要检查 2) 加error_log(&quot;error_message&quot;, 3, &quot;log.txt&quot;);在你想输出信息的地方，用这种方式找代码哪句有问题。 当我我们一定时常注意log的日志，因为大部分错误或者异常在log都能清楚，或者通过分析找到问题所在并解决 1 先看nginx error.log 指定的错误日记文件路径 找到这个日记文件看 里面信息 2 再看 php-fpm.conf 里面指定的PHP错误日记的路径 具体如下php_flag[display_errors] = off php_admin_flag[log_errors] = on php_admin_value[error_log] = /data/logs/fpm-php.log 在网上找到一段话，这是在windows上开发的时候出现的问题及解决方案，当然Mac上也差不多1、运行的用户数过多，对服务器造成的压力过大，服务器无法响应，则报HTTP500错误。减小用户数或者场景持续时间，问题得到解决。 2、该做关联的地方没有去做关联，则报HTTP500错误。进行手工或者自动关联，问题得到解决。 3、录制时请求的页面、图片等，在回放的时候服务器找不到，则报HTTP500错误，若该页面无关紧要，则可以在脚本中注释掉，问题将会得到解决。例如：有验证码的情况下，尽管测试时已经屏蔽了，但是录制的时候提交了请求，但回放的时候不存在响应。 4、参数化时的取值有问题，则报HTTP500错误。可将参数化列表中的数值，拿到实际应用系统中进行测试，可排除问题。 5、更换了应用服务器（中间件的更换，如tomcat、websphere、jboss等），还是利用原先录制的脚本去运行，则很可能报HTTP500错误。因为各种应用服务器处理的机制不一样，所录制的脚本也不一样，解决办法只有重新录制脚本。 6、Windowsxp2 与ISS组件不兼容，则有可能导致HTTP500错误。对ISS组件进行调整后问题解决。 7、系统开发程序写的有问题，则报HTTP500错误。例如有些指针问题没有处理好的，有空指针情况的存在。修改程序后问题解决。 8、如果测试中所进行的操作涉及到数据库，如插入数据操作，若大数据量的情况下导致数据库中表空间已满，或者数据库连接池较小无法满足数据的存取等，都有可能导致HTTP500错误。调整数据库、修改连接池大小，问题解决。 下面是某教程网站上在Nginx上出现的一个棘手的500错误。。原文地址：https://www.phpxy.com/article/109.html 产生原因：恢复aliyun阿里云的镜像，发现不论如何访问服务器都提示500 出现了问500错误，第一件事情要处理的是查看日志。1. 日志系统是否记录了日志 2. 发现日志系统未记录日志，所以说不好去发现问题。 3. 解决nginx未记录日志的问题，在/usr/local/nginx/conf/vhost/ uluqu.com.conf下增加error_log选项指定至目录 4. 发现nginx无法启动，错误提示 /var/log/nginx 目录未存在 5.使用mkdir 创建/var/log/nginx 目录 6. 重新启动nginx,php-fpm等，发现解决成功 7. 打开错误日志目录，发现日志已生成 8.访问 www.uluqu.com/index.php 和phpinfo.php 页面，查看日志中记录的两项错误 9. 错误提醒分别为php parse error define错误，第二个是发现 memory allowed limit 类的错误。分析原因是内存不足或者未合理管理内存造的。 10. 清理服务器内存 free -m 然后执行echo 1 &gt; /proc/sys/vm/drop_caches 11. 再次判断可能因为php.ini文件出错，解决办法：修改php.ini中的memroy_limit参数 12. 经查发现memroy_limit 这个参数写的是512而不是512M。修改参数，重启相关服务。 13. 访问地址问题解决 在运行PHP程序，通常会遇到“Fatal Error： Allowed memory size of xxxxxx bytes exhausted”的错误， 这个意味着PHP脚本使用了过多的内存，并超出了系统对其设置的允许最大内存。 解决这个问题，首先需要查看你的程序是否分配了过多的内存，在程序没有问题的情况下，你可以通过一下方法来增加PHP的内存限制（memory_limit）。 检查php的内存限制值为了查看这个值，你需要建立一个空的php文件，比如view-php-info.php。然后将一下代码贴到里面。 memory_limit应该设为多少？这个完全依赖于你的应用的要求。比如Wordpress，运行起核心代码需要32MB。Drupal 6则要求这个值最小为16MB，并推荐设置为32MB。如果你又安装不少的插件（plugins），尤其是那些要进行图像处理的模块，那么你可能需要128MB或更高的内存。 方法1： php.ini最简单或常用的方法是修改php.ini 1.首先找到对你的网站生效的php.ini文件 由于有多个地方都可以设置php的参数，找到正确的配置文件，并进行更改是首先要做的一步。对于Linux用户，你可以通过执行“php -i | grep Loaded Configuration File”来找到对应的配置文件。而Windows用户，你可以尝试修改你的php安装目录下的php.ini。 2.编辑php.ini 在php.ini中，找到“memory_limit”这一项，如果没有，你可以在文件的尾部自己增加这个参数。以下是一些设置范例memory_limit = 128M ; 可以将128M改为任何你想设置的值,保存文件 3.重启web 服务器 如果是web服务器使用Apache， 则执行：httpd restart 有些情况下，你可能不被允许私修改php.ini。比如如果你购买了虚拟主机服务，但是你的服务商确禁止你修改这个文件。那么，你可以需要考虑用其他方法来增加memory_limit的值。 方法2： .htaccess说明： 这种方法只有在php以Apache模块来执行时才生效。 在你的网站的根目录下找到“.htaccess”文件，如果没有，可以自己创建一个。然后把以下配置放入其中 php_value memory_limit 128M ; 可以将128M改为任何你想设置的值 方法3： 运行时修改php的内存设置在你的php代码中增加以下命令行即可。ini_set(&apos;memory_limit&apos;,&apos;128M&apos;); memory_limit修改失败如果你使用虚拟主机，有可能会出现memory_limit的值修改失败。这个需要联系你的服务商看怎么处理，通常他们限制了可以设置的最大值或者根本就不允许你修改。如果他们的环境真的无法满足你的要求，那么你可能要考虑换一个主机服务商。 生产环境下故障处理一例现象说明：生产环境下，storage服务器上没有安装任何服务（如apache，nginx，IIS等）现在是纯命令行执行PHP跑PHP脚本，在脚本的执行过程中发现（脚本内容含每次取5000个文件然后执行其它操作）速度奇慢，在本地测试时分分钟内搞定的事，在线上要执行2个多小时，经过排查排除掉服务器负载问题、数据库问题、服务器网络问题后，认为可能是php.ini配置文件中的资源限制所引起，于是修改了一下memory_limit将默认值128M修改为1024M后再次执行原脚本，速度得到大幅度提升，现把此参数的含义说明一下。 修改后需不需要重启？因为PHP没有守护进程一说，理论上你只要修改过以后，就会立即使用新的配置文件。 此值设置多大为好？建议根据应用需求来设置。物理服务器，如果内存够大的话建议限制内存较大一些如512M，1024M都可，如果是VPS之类的可能限制在128（默认）64M或者以下是比较合适的，特别是有web服务器的时候，一旦开启多个php的fast-cgi，估计服务器都卡的不动了。 参数语法memory_limit integer 本指令设定了一个脚本所能够申请到的最大内存字节数。 指令作用这有助于防止写得不好的脚本消耗光服务器上的可用内存。 在phpchina的论坛上，有人这样说：memory_limit是设置PHP使用内存时空间，一般设置为内存的四分之一，应该就差不多了。如512M内存设置128M,1G内存设置256M。 设置太大会影响系统速度，因为系统和数据库及其他程序同样需要内存空间，一般系统和数据库内存空间是自己分配的。 附三种修改方法可能是分词程序的问题。只要搜索的字段达到十个汉字以上，就会出现诸如以下的错误 Fatal error: Allowed memory size of 2345643 bytes exhausted 上网找了方法。有3种办法。 1.直接修改PHP.INImemory_limit = 16M ; 但是我修改了没有用。据说是要重启服务器的。但是很显然。我的 是虚拟主机。所以有独立主机的可以这样修改。 2.修改.htaccessphp_value memory_limit 16M 修改后直接出现500错误。可能是主机商限制 3.直接在程序页面上修改。ini_set(’memory_limit’, ‘16M‘);]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>500错误</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第二十六篇——APP接口是怎么来的？]]></title>
    <url>%2F2018%2F12%2F23%2FPHP%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AD%E7%AF%87%E2%80%94%E2%80%94APP%E6%8E%A5%E5%8F%A3%E6%98%AF%E6%80%8E%E4%B9%88%E6%9D%A5%E7%9A%84%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[学了差不多一个月的PHP，总想找个机会试试手，因为工作的原因每天能抽出来的时间真心少，这两天就开始在进行真正的PHP接口开发学习了，到今天为止，我终于知道我做iOS开发的时候发送请求返回的数据是这么来的…… APP接口PHP开发APP接口 APP接口开发 APP接口简介 封装通讯接口方法 核心技术 APP接口实例 接口请求流程 客户端-发送GET/POST请求-服务端-数据库/缓存-调用APP接口-客户端 APP接口简介 接口地址(url) ==== 函数名 GET或POST数据 ==== 函数的参数 这个接口输出的数据 ===== 函数的返回值 API概述 1、API 比开发 WEB 更简洁，但可能逻辑更复杂，API 只返回结果，也就是只完成数据输出，不呈现页面， 2、WEB 开发，更多的是 GET 和 POST 请求，API 还有 PUT、DELETE 请求 3、和 WEB 开发一样，首先需要一些相关的参数，这些参数，都会由客户端传过来，也许是 GET 也许是 POST，这个需要开发团队相互之间约定好，或者制定统一规范 4、有了参数，根据应用需求，完成数据处理，例如：获取用户信息、发朋友圈、发消息、一局游戏结束数据提交等等 5、数据逻辑处理完之后，返回客户端所需要用到的相关数据，例如：用户信息数组、朋友圈列表、消息状态、游戏结果数据等等，那数据是怎么返给客户端呢？常见有XML、JSON，设置相应的header并把要返回的数据直接打印出来即可 6、客户端获取到你返回的数据后，在客户端本地和用户进行交互 APP接口介绍首先要区别去面向对象中的接口 面向对象中的接口是一个抽象类，如PHP或者java中使用interface，iOS中使用的@interface，这里起到的是一个标准或者规范，适合多人开发使用。 APP中的接口：是指数据接口 APP发送HTTP请求，服务器根据请求的参数返回对应的接口数据，客户端解析数据并显示，客户端并不需要关心接口数据是这么实现的，这么返回的，只要发送请求根据返回的数据解析使用就可以！ 接口：包括接口地址，接口文件，接口数据 如何进行通讯 -&gt;需要有一个客户端APP -&gt;触发客户端APP的时候 -&gt;发送HTTP对应的地址GET/POST请求 -&gt;发送给服务端 -&gt;服务端收到接口请求之后会做相应的处理 -&gt;比如从数据库/缓存读取对应的数据 -&gt;返回给客户端 -&gt;客户端收到服务器返回的数据 -&gt;开始解析成自己想要的格式（XML、JSON） -&gt;显示到界面上 通讯格式区别JSON的定义 一种轻量级的数据交换格式，具有良好的可读和便于快速编写的特性。业内主流技术为其提供了完整的解决方案（有点类似于正则表达式 ，获得了当今大部分语言的支持），从而可以在不同平台间进行数据交换。JSON采用兼容性很高的文本格式，同时也具备类似于C语言体系的行为。 XML的定义 扩展标记语言 (Extensible Markup Language,XML) ，用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。 XML是标准通用标记语言 (SGML) 的子集，非常适合 Web 传输。XML 提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据。 XML优缺点 缺点 1. 格式统一, 符合标准 2. 容易与其他系统进行远程交互, 数据共享比较方便 缺点: 1. XML文件格式文件庞大, 格式复杂, 传输占用带宽 2. 服务器端和客户端都需要花费大量代码来解析XML, 不论服务器端和客户端代码变的异常复杂和不容易维护 3. 客户端不同浏览器之间解析XML的方式不一致, 需要重复编写很多代码 4. 服务器端和客户端解析XML花费资源和时间 JSON优缺点 那么除了XML格式, 还有没有其他格式, 有一种叫做JSON(JavaScript Object Notation) 的轻量级数据交换格式能够替代XML的工作. 优点: 1. 数据格式比较简单, 易于读写, 格式都是压缩的, 占用带宽小 2. 易于解析这种语言, 客户端JavaScript可以简单的通过eval_r()进行JSON数据的读取 3. 支持多种语言, 包括ActionScript, C, C#, ColdFusion, Java,JavaScript, Perl, PHP, Python, Ruby等语言服务器端语言, 便于服务器端的解析 4. 在PHP世界, 已经有PHP-JSON和JSON-PHP出现了, 便于PHP序列化后的程序直接调用. PHP服务器端的对象、数组等能够直接生JSON格式, 便于客户端的访问提取. 5. 因为JSON格式能够直接为服务器端代码使用, 大大简化了服务器端和客户端的代码开发量, 但是完成的任务不变, 且易于维护 缺点: 1. 没有XML格式这么推广的深入人心和使用广泛, 没有XML那么通用性 2. JSON格式目前在Web Service中推广还属于初级阶段 JSON 和 XML 优缺点的比较 1. 在可读性方面，JSON和XML的数据可读性基本相同。JSON和XML的可读性可谓不相上下，一边是建议的语法，一边是规范的标签形式，很难分出胜负。 2. 在可扩展性方面，XML天生有很好的扩展性，JSON当然也有，没有什么是XML能扩展，JSON不能的。 3. 在编码难度方面，XML有丰富的编码工具，比如Dom4j、JDom等，JSON也有json.org提供的工具，但是JSON的编码明显比XML容易许多，即使不借助工具也能写出JSON的代码，可是要写好XML就不太容易了。 4. 在解码难度方面，XML的解析得考虑子节点父节点，让人头昏眼花，而JSON的解析难度几乎为0。这一点XML输的真是没话说。 5. 在流行度方面，XML已经被业界广泛的使用，而JSON才刚刚开始，但是在Ajax这个特定的领域，未来的发展一定是XML让位于JSON。到时Ajax应该变成Ajaj(AsynchronousJavascript and JSON)了。 6. JSON和XML同样拥有丰富的解析手段。 7. JSON相对于XML来讲，数据的体积小。 8. JSON与JavaScript的交互更加方便。 9. JSON对数据的描述性比XML较差。 10. JSON的速度要远远快于XML。 protocol buffer 现在还有一种据说是比较流行，但是目前还没有PHP的API，叫做protocol buffer protocol buffer是google的一个开源项目,它是用于结构化数据串行化的灵活、高效、自动的方法，例如XML，不过它比xml更小、更快、也更简单。你可以定义自己的数据结构，然后使用代码生成器生成的代码来读写这个数据结构。你甚至可以在无需重新部署程序的情况下更新数据结构。 对于protocol buffer网上确实有不少好评，但是目前只有C++，java，python的API，希望以后有机会能试一试效果。 APP接口做的那些事获取数据：从数据库中或者缓存中获取数据，然后通过接口数据返回给客户端提交数据：通过接口提交数据给服务器。然后服务器入库处理，或者其他处理 获取数据：GET请求 界面显示数据，首页，广场，用户信息...... 提交数据：POST请求 提交反馈，注册登录，修改用户信息...... 封装通讯接口方法JSON方式封装通讯接口一. 生成JSON数据——数组方式 首先必须知道PHP生成接口数据的方法是json_encode($value),这个方法只能接口UTF-8编码数据，其他格式数据会返回null 首先我们定义一个简单的数组，然后使用json_encode方法将数组转成json数据 $arrayName = array( &apos;id&apos; =&gt; 1, &apos;name&apos; =&gt; &apos;iCocos&apos; ); echo $arrayName; echo json_encode($arrayName); 浏览器输入对应的链接地址，答应结果 Array Array{&quot;id&quot;:1,&quot;name&quot;:&quot;iCocos&quot;} 当然如果你不是UTF8编码数据，可以使用字符编码之间转换函数iconv()，将对应的编码转成自己想要的编码 iconv(&apos;原始编码&apos;,&apos;目标编码&apos;,&apos;数据变量&apos;) 二. 通讯数据的标准格式 一般来说规范一点的后台开发人员都会有一套自己的标准 code 状态吗（2XX-成功, 3XX重定向, 4XX客户端错误, 5XX服务器错误） message 提示信息 data 返回数据 id : 1 name : iCocos 如果你是做移动端的，到公司发现你们后台返回连这种标准都没有，哪怕是类似的，那么不用多说，建议还是闪人吧！ 三. 下面我们简单的实战一下 首先定义一个工具类，用来把传递进来的数据和相应的信息转换成json，然后输出 定义一个PHPResponse.php文件，并且定义一个PHPResponse类，在类里面定义一个静态方法，并且简单的实现一些逻辑处理就进行转换输出 &lt;?php /** * 相应类 */ class PHPResponse { //返回JSON数据方法 public static function jsonData($code, $message = &apos;&apos;, $data = array()) { //如果code不是数字 if (!is_numeric($code)) { # code... return &apos;&apos;; } $res = array( &apos;code&apos; =&gt; $code, &apos;message&apos; =&gt; $message, &apos;data&apos; =&gt; $data ); echo var_dump($res); //echo json_encode($res); exit(); //exit; } } 因为这里只是简单的测试，所以在index.php中引入对应的文件，然后传递数据和对应的参数进上面的方法 require_once(&apos;./PHPResponse.php&apos;); $arrRes = array( &apos;id&apos; =&gt; 1, &apos;name&apos; = &apos;iCocos&apos; ); PHPResponse::jsonData(200, &apos;成功&apos;, $arrRes); 浏览器输入对应的路径，就能看到真实的数据返回 array(3) { [&quot;code&quot;]=&gt; int(200) [&quot;message&quot;]=&gt; string(6) &quot;成功&quot; [&quot;data&quot;]=&gt; array(2) { [&quot;id&quot;]=&gt; int(1) [&quot;name&quot;]=&gt; string(6) &quot;iCocos&quot; } } 生成XML数据 组装字符串 使用系统类 DomDocument XMLWrite SimpleXML 这里使用字符串的方式，其实在学习iOS的时候就有了解过这一点： public static function xmlToEncode($data) { $xml = &quot;&lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos;?&gt;\n&quot;; $xml = &quot;&lt;root&gt;\n&quot;; $xml = &quot;&lt;code&gt;200&lt;/code&gt;\n&quot;; $xml = &quot;&lt;message&gt;返回成功&lt;/message&gt;\n&quot;; $xml = &quot;&lt;data&gt;\n&quot;; $xml = &quot;&lt;id&gt;1&lt;/id&gt;\n&quot;; $xml = &quot;&lt;name&gt;iCocos&lt;name&gt;\n&quot;; $xml = &quot;&lt;/data&gt;\n&quot;; $xml = &quot;&lt;/root&gt;\n&quot;; echo $xml; } 注意：xml节点不能使用数字 浏览器输入后测试显示就是平时我们看到的xml数据格式 &lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos;?&gt; &lt;root&gt; &lt;code&gt;200&lt;/code&gt; &lt;message&gt;返回成功&lt;/message&gt; &lt;data&gt; &lt;id&gt;1&lt;/id&gt; &lt;name&gt;iCocos&lt;name&gt; &lt;/data&gt; &lt;/root&gt; 当然可能你直接看到的是这样的，这是因为浏览器自动帮我们解析,属于来说就是Content-Type:text/html,而我们需要显示的是Content-Type:text/xml，只要右键查看源码就可以查看 200 返回成功 1 iCocos 如果想要显示的时候就自动解析成xml，只要调用对应的php方法就可以 heaer(&quot;Content-Type:text/xml&quot;); XML方式封装通讯数据方法：响应的格式和json是一样的XML方式其实现在来讲的话使用并不高，我经历了几家公司都使用的json，但是作为php开发也是必须要会。 首先定义一个工具类，用来把传递进来的数据和相应的信息转换成xml，然后输出 定义一个PHPResponse.php文件，并且定义一个PHPResponse类，在类里面定义一个静态方法，并且简单的实现一些逻辑处理就进行转换输出 /** * 按xml方式输出通信数据 * @param integer $code 状态码 * @param string $message 提示信息 * @param array $data 数据 * return string */ public static function xmlEncode($code, $message, $data = array()) { if(!is_numeric($code)) { return &apos;&apos;; } $result = array( &apos;code&apos; =&gt; $code, &apos;message&apos; =&gt; $message, &apos;data&apos; =&gt; $data, ); header(&quot;Content-Type:text/xml&quot;); $xml = &quot;&lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos;?&gt;\n&quot;; $xml .= &quot;&lt;root&gt;\n&quot;; $xml .= self::xmlToEncode($result); $xml .= &quot;&lt;/root&gt;&quot;; echo $xml; } 解析数组，返回xml数据 public static function xmlToEncode($data) { $xml = $attr = &quot;&quot;; foreach($data as $key =&gt; $value) { if(is_numeric($key)) { $attr = &quot; id=&apos;{$key}&apos;&quot;; $key = &quot;item&quot;; } $xml .= &quot;&lt;{$key}{$attr}&gt;&quot;; $xml .= is_array($value) ? self::xmlToEncode($value) : $value; //如果value是数组就循环便利执行这个方法 $xml .= &quot;&lt;/{$key}&gt;\n&quot;; } return $xml; } 调用 $arrayName = array( &apos;id&apos; =&gt; 1, &apos;name&apos; =&gt; &apos;iCocos&apos; ); PHPResponse::xmlEncode(200,’success’,$arrayName); 输入浏览器测试地址可以看到 &lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos;?&gt; &lt;root&gt; &lt;code&gt;200&lt;/code&gt; &lt;message&gt;返回成功&lt;/message&gt; &lt;data&gt; &lt;id&gt;1&lt;/id&gt; &lt;name&gt;iCocos&lt;name&gt; &lt;/data&gt; &lt;/root&gt; 这里如果实际开发坑定没有这么简单，但是复杂的地方也就是数组比较多数组，或分层 到上面位置就可以实现平时开发中最最最简单的接口数据。 综合方式封装通讯数据方法一：定义一个通用的接口文件，并且定义一个基类 &lt;?php /** * 定义API抽象类 */ abstract class Api { const JSON = &apos;Json&apos;; const XML = &apos;Xml&apos;; const ARR = &apos;Array&apos;; /** * 定义工厂方法 * param string $type 返回数据类型 */ public static function factory($type = self::JSON) { $type = isset($_GET[&apos;format&apos;]) ? $_GET[&apos;format&apos;] : $type; $resultClass = ucwords($type); require_once(&apos;./Response/&apos; . $type . &apos;.php&apos;); return new $resultClass(); } abstract function response($code, $message, $data); } 二：XML数据解析与响应方法，继承自API &lt;?php /** * @author by singwa * @date */ class Xml extends Api { public function response($code, $message = &apos;&apos;, $data = array()) { if(!is_numeric($code)) { return &apos;&apos;; } $result = array( &apos;code&apos; =&gt; $code, &apos;message&apos; =&gt; $message, &apos;data&apos; =&gt; $data ); header(&apos;Content-Type:text/xml&apos;); $xml = &quot;&lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos;?&gt;\n&quot;; $xml .= &quot;&lt;root&gt;&quot;; $xml .= self::xmlToEncode($result); $xml .= &quot;&lt;/root&gt;&quot;; echo $xml; } public static function xmlToEncode($result) { $xml = $attr = &apos;&apos;; foreach($result as $key =&gt; $value) { if(is_numeric($key)) { $attr = &quot; id=&apos;&quot; . $key . &quot;&apos;&quot;; $key = &quot;item&quot;; } $xml .= &quot;&lt;{$key}{$attr}&gt;&quot;; $xml .= is_array($value) ? self::xmlToEncode($value) : $value; $xml .= &quot;&lt;/{$key}&gt;\n&quot;; } return $xml; } } 三：JSON数据解析与响应方法，继承自API &lt;?php /** * 按xml方式输出通信数据 */ class Json extends Api { public function response($code, $message = &apos;&apos;, $data = array()) { if(!(is_numeric($code))) { return &apos;&apos;; } $result = array( &apos;code&apos; =&gt; $code, &apos;message&apos; =&gt; $message, &apos;data&apos; =&gt; $data ); echo json_encode($result); exit; } } 是不是感觉json比xml简单很多，这也是为什么很多公司都使用的是json的原因。 四：然后就是入口文件，通过入口文件调用方法，根据传入的类型解析成对应的格式，这也是前面讲到的面向对象的特性 &lt;?php class Response { const JSON = &quot;json&quot;; /** * 按综合方式输出通信数据 * @param integer $code 状态码 * @param string $message 提示信息 * @param array $data 数据 * @param string $type 数据类型 * return string */ public static function show($code, $message = &apos;&apos;, $data = array(), $type = self::JSON) { if(!is_numeric($code)) { return &apos;&apos;; } $type = isset($_GET[&apos;format&apos;]) ? $_GET[&apos;format&apos;] : self::JSON; $result = array( &apos;code&apos; =&gt; $code, &apos;message&apos; =&gt; $message, &apos;data&apos; =&gt; $data, ); if($type == &apos;json&apos;) { self::json($code, $message, $data); exit; } elseif($type == &apos;array&apos;) { var_dump($result); } elseif($type == &apos;xml&apos;) { self::xmlEncode($code, $message, $data); exit; } else { // TODO } } /** * 按json方式输出通信数据 * @param integer $code 状态码 * @param string $message 提示信息 * @param array $data 数据 * return string */ public static function json($code, $message = &apos;&apos;, $data = array()) { if(!is_numeric($code)) { return &apos;&apos;; } $result = array( &apos;code&apos; =&gt; $code, &apos;message&apos; =&gt; $message, &apos;data&apos; =&gt; $data ); echo json_encode($result); exit; } /** * 按xml方式输出通信数据 * @param integer $code 状态码 * @param string $message 提示信息 * @param array $data 数据 * return string */ public static function xmlEncode($code, $message, $data = array()) { if(!is_numeric($code)) { return &apos;&apos;; } $result = array( &apos;code&apos; =&gt; $code, &apos;message&apos; =&gt; $message, &apos;data&apos; =&gt; $data, ); header(&quot;Content-Type:text/xml&quot;); $xml = &quot;&lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos;?&gt;\n&quot;; $xml .= &quot;&lt;root&gt;\n&quot;; $xml .= self::xmlToEncode($result); $xml .= &quot;&lt;/root&gt;&quot;; echo $xml; } public static function xmlToEncode($data) { $xml = $attr = &quot;&quot;; foreach($data as $key =&gt; $value) { if(is_numeric($key)) { $attr = &quot; id=&apos;{$key}&apos;&quot;; $key = &quot;item&quot;; } $xml .= &quot;&lt;{$key}{$attr}&gt;&quot;; $xml .= is_array($value) ? self::xmlToEncode($value) : $value; $xml .= &quot;&lt;/{$key}&gt;\n&quot;; } return $xml; } } 五：最后就可以在浏览器输入对应的接口地址，传入对应的参数，就能得到想要的格式的数据 说在最后，实际项目中，我们在开发 API 时应该注意的几个点（仅供参考）1、单文件实现多接口的形式有很多种，例如：if..elseif.. 或 switch 或 很多框架里用到的统一入口通过调用类函数的形式实现 2、数据输出建议使用json，json具有很强的跨平台性，大多编程语言都支持json解析，json正在逐步取代xml，成为网络数据的通用格式 3、为了保证接口安全，一定要加入鉴权体系 4、对于线上的API，务必关闭所有错误显示，可以把错误写到日志里，PHP中，可以通过 error_reporting(0) 屏蔽所有错误这样做的目的，一方面是保护接口安全，防止输出不该打印的错误信息 另一方面是保证输出的是正确的数据格式，如json，假如不是标准的json格式，客户端在解析时就会出错，由此影响客户端的正常运转 PS：我们平时在使用手机APP时，手机会闪退，多半是这个原因，即接口调用异常 5、开发 API 和 WEB 有一定的区别，如果是 WEB 的话，如果程序写的有问题，比如有个notice 或 warning 级别的错误，在 WEB 里可能不会有什么问题，也许就只是导致 WEB 的某个部分错位或乱码。但如果是 API，就会严重调用的客户端了，如果是手机APP，那闪推啥的，是必然的，如果同样也是Web调用，也可能会出现 Server Error 了 6、一定要重点考虑稳定性和响应速度，因为我们在使用手机APP时，都不希望APP经常闪推、而且希望应用很流畅 7、不要随便使用一些 PHP 开源框架，原因概括起来有两点： 1）如6所述，客户端一般对 API 响应速度有极高要求，目前PHP领域的开源框架非常多，根据笔者的了解，目前比较流行的框架，普遍做的比较重，而且基本都是为WEB而生，因此，框架多了很多 API 用不到的东西，框架在加载和执行冗余文件时，实际是在消耗你的性能 2）如4和5所述，框架对于WEB开发，是件很幸福的事，但对于 API 而言，你实在不敢想象它会给你出什么岔子，因为很多框架并没有全面的考虑到 API 场景]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>APP接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第二十五篇——核心技术之缓存]]></title>
    <url>%2F2018%2F12%2F20%2FPHP%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E7%AF%87%E2%80%94%E2%80%94%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B9%8B%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[缓存在所有开发里面可是说是有着具足其中的作用，或者对平时开发中并不显见，但是为了考虑性能，考虑实际应用，考虑用户的顾虑，那么缓存就不得不慎重考虑，PHP中也是同样…… APP接口首先在这之前推荐一篇文章： PHP9大缓存技术 核心技术静态缓存保存在磁盘上的静态文件，用PHP生成数据放入静态文件中 一：操作缓存 生成 获取 删除 实现案例 &lt;?php class File { private $_dir; const EXT = &apos;.txt&apos;; public function __construct() { $this-&gt;_dir = dirname(__FILE__) . &apos;/files/&apos;; } public function cacheData($key, $value = &apos;&apos;, $cacheTime = 0) { $filename = $this-&gt;_dir . $key . self::EXT; if($value !== &apos;&apos;) { // 将value值写入缓存 if(is_null($value)) { return @unlink($filename); } $dir = dirname($filename); if(!is_dir($dir)) { mkdir($dir, 0777); } $cacheTime = sprintf(&apos;%011d&apos;, $cacheTime); return file_put_contents($filename,$cacheTime . json_encode($value)); } if(!is_file($filename)) { return FALSE; } $contents = file_get_contents($filename); $cacheTime = (int)substr($contents, 0 ,11); $value = substr($contents, 11); if($cacheTime !=0 &amp;&amp; ($cacheTime + filemtime($filename) &lt; time())) { unlink($filename); return FALSE; } return json_decode($value, true); } } $file = new File(); echo $file-&gt;cacheData(&apos;test1&apos;); Memcache和Redis缓存技术简单总结 1、 Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等。2、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。3、虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘4、过期策略–memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通过例如expire 设定，例如expire name 105、分布式–设定memcache集群，利用magent做一主多从;redis可以做一主多从。都可以一主一从6、存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）7、灾难恢复–memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复8、Redis支持数据的备份，即master-slave模式的数据备份。 分类总结 （1）数据结构：Memcache只支持key value存储方式，Redis支持更多的数据类型，比如Key value，hash，list，set，zset； （2）多线程：Memcache支持多线程，redis支持单线程；CPU利用方面Memcache优于redis； （3）持久化：Memcache不支持持久化，Redis支持持久化； （4）内存利用率：memcache高，redis低（采用压缩的情况下比memcache高）； （5）过期策略：memcache过期后，不删除缓存，会导致下次取数据数据的问题，Redis有专门线程，清除缓存数据； 整体性对比 1）性能对比：由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起 Memcached，还是稍有逊色。 2）内存使用效率对比：使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。 3）Redis支持服务器端的数据操作：Redis相比Memcached来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在Memcached 里，你需要将数据拿到客户端来进行类似的修改再set回去。这大大增加了网络IO的次数和数据体积。在Redis中，这些复杂的操作通常和一般的 GET/SET一样高效。所以，如果需要缓存能够支持更复杂的结构和操作，那么Redis会是不错的选择。 后面会有专门的文章介绍Memcache与Redis原理，使用与总结 设置缓存操作 获取缓存操作 删除缓存操作 分别以命令和PHP的方式]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第二十四篇——文件上传下载原理与配置]]></title>
    <url>%2F2018%2F12%2F19%2FPHP%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E7%AF%87%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[关于PHP上传和下载的原理一句话总结就是：将客户端文件上传到服务器端，再将服务器端的文件（临时文件）移动到指定目录即可。…… 文件上传下载原理与配置一、上传原理与配置1.1 原理将客户端文件上传到服务器端，再将服务器端的文件（临时文件）移动到指定目录即可。 1.2 客户端配置所需：表单页面（选择上传文件）； 具体而言：发送方式为POST，添加enctype=”multipart/form-data”属性，两者缺一不可（但是，优缺点并存，这里也限定了上传的方式和上传的文件之后的调用等方面，后面会说到） &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;doAction.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 请选择您要上传的文件： &lt;input type=&quot;file&quot; name=&quot;myFile&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt; &lt;/form&gt; &lt;?php ?&gt; &lt;/body&gt; &lt;/html&gt; 先是表单页面（请自动忽略前端问题。。。），关键就是form的属性；另外就是input 中用到了type=”file”这一点（体现到php的强大的拓展等等）。 然后是doAction &lt;?php //$_FILES:文件上传变量 //print_r($_FILES); $filename=$_FILES[&apos;myFile&apos;][&apos;name&apos;]; $type=$_FILES[&apos;myFile&apos;][&apos;type&apos;]; $tmp_name=$_FILES[&apos;myFile&apos;][&apos;tmp_name&apos;]; $size=$_FILES[&apos;myFile&apos;][&apos;size&apos;]; $error=$_FILES[&apos;myFile&apos;][&apos;error&apos;]; //将服务器上的临时文件移动到指定位置 //方法一move_upload_file($tmp_name,$destination) //move_uploaded_file($tmp_name, &quot;uploads/&quot;.$filename);//文件夹应提前建立好，不然报错 //方法二copy($src,$des) //以上两个函数都是成功返回真，否则返回false //copy($tmp_name, &quot;copies/&quot;.$filename); //注意，不能两个方法都对临时文件进行操作，临时文件似乎操作完就没了，我们试试反过来 copy($tmp_name, &quot;copies/&quot;.$filename); move_uploaded_file($tmp_name, &quot;uploads/&quot;.$filename); //能够实现，说明move那个函数基本上相当于剪切；copy就是copy，临时文件还在 //另外，错误信息也是不一样的，遇到错误可以查看或者直接报告给用户 if ($error==0) { echo &quot;上传成功！&quot;; }else{ switch ($error){ case 1: echo &quot;超过了上传文件的最大值，请上传2M以下文件&quot;; break; case 2: echo &quot;上传文件过多，请一次上传20个及以下文件！&quot;; break; case 3: echo &quot;文件并未完全上传，请再次尝试！&quot;; break; case 4: echo &quot;未选择上传文件！&quot;; break; case 5: echo &quot;上传文件为0&quot;; break; } } 先把print_r($_FILES)这个信息看一下 Array ( [myFile] =&gt; Array ( [name] =&gt; 梁博_简历.doc [type] =&gt; application/msword [tmp_name] =&gt; D:\wamp\tmp\php1D78.tmp [error] =&gt; 0 [size] =&gt; 75776 ) ) 所以得到的是个二维数组，该怎么用，都是基本的东西（其实我喜欢降维再用）； 基本是一眼就懂的东西，不罗嗦，关键有两个：tmp_name临时文件名；error报错信息（代号，后面可以利用）； 然后这里看一下doAction后面一部分，利用报错信息来反馈给用户，需要说明的是为什么报错，和报错信息是什么都； 1.3 关于报错–报错原因 基本上都是超过或者不符合服务器关于上传文件的配置，那么服务器端配置有哪些呢？ 先考虑上传我们用了什么？POST，upload 所以在php.ini中找这么几项： file_upload:On upload_tmp_dir=——临时文件保存目录； upload_max_filesize=2M max_file_uploads=20——允许一次上传的最大文件数量（注意和上面那个的区别，有没有size，别乱想） post_max_size=8M——post方式发送数据的最大值 其他相关配置 max_exectuion_time=-1——最大执行时间，避免程序不好占用服务器资源； max_input_time=60 max_input_nesting_level=64——输入嵌套深度； memory_limit=128M——最大单线程的独立内存使用量 总之都是有关资源的配置。 –错误号 以下（偷懒）引自http://blog.sina.com.cn/s/blog_3cdfaea201008utf.html UPLOAD_ERR_OK 值：0; 没有错误发生，文件上传成功。 UPLOAD_ERR_INI_SIZE 值：1; 上传的文件超过了 php.ini 中 upload_max_filesize 选项限制的值。 UPLOAD_ERR_FORM_SIZE 值：2; 上传文件的大小超过了 HTML 表单中 MAX_FILE_SIZE 选项指定的值。 UPLOAD_ERR_PARTIAL 值：3; 文件只有部分被上传。 UPLOAD_ERR_NO_FILE 值：4; 没有文件被上传。 注意：这个错误信息是第一步上传的信息，也就是上传到临时文件夹的情况，而不是move或者copy的情况。 二、上传相关限制2.1 客户端限制&lt;form action=&quot;doAction2.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;MAX_FILE_SIZE&quot; value=&quot;101321&quot; /&gt; 请选择您要上传的文件： &lt;input type=&quot;file&quot; name=&quot;myFile&quot; accept=&quot;image/jpeg,image/gif,text/html&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt; &lt;/form&gt; 这里用input的属性对上传文件的大小和类型进行了限制，但是个人感觉：一，html代码是“可见的”；二，常不起作用（没找到原因，但因为第一个我也想放弃它，知道就好。 2.2 服务器端限制 主要限制大小和类型，再有就是方式。 &lt;?php header(&apos;content-type:text/html;charset=utf-8&apos;); //接受文件，临时文件信息 $fileinfo=$_FILES[&quot;myFile&quot;];//降维操作 $filename=$fileinfo[&quot;name&quot;]; $tmp_name=$fileinfo[&quot;tmp_name&quot;]; $size=$fileinfo[&quot;size&quot;]; $error=$fileinfo[&quot;error&quot;]; $type=$fileinfo[&quot;type&quot;]; //服务器端设定限制 $maxsize=10485760;//10M,10*1024*1024 $allowExt=array(&apos;jpeg&apos;,&apos;jpg&apos;,&apos;png&apos;,&apos;tif&apos;);//允许上传的文件类型（拓展名 $ext=pathinfo($filename,PATHINFO_EXTENSION);//提取上传文件的拓展名 //目的信息 $path=&quot;uploads&quot;; if (!file_exists($path)) { //当目录不存在，就创建目录 mkdir($path,0777,true); chmod($path, 0777); } //$destination=$path.&quot;/&quot;.$filename; //得到唯一的文件名！防止因为文件名相同而产生覆盖 $uniName=md5(uniqid(microtime(true),true)).$ext;//md5加密，uniqid产生唯一id，microtime做前缀 if ($error==0) { if ($size&gt;$maxsize) { exit(&quot;上传文件过大！&quot;); } if (!in_array($ext, $allowExt)) { exit(&quot;非法文件类型&quot;); } if (!is_uploaded_file($tmp_name)) { exit(&quot;上传方式有误，请使用post方式&quot;); } if (@move_uploaded_file($tmp_name, $uniName)) {//@错误抑制符，不让用户看到警告 echo &quot;文件&quot;.$filename.&quot;上传成功!&quot;; }else{ echo &quot;文件&quot;.$filename.&quot;上传失败!&quot;; } //判断是否为真实图片（防止伪装成图片的病毒一类的 if (!getimagesize($tmp_name)) {//getimagesize真实返回数组，否则返回false exit(&quot;不是真正的图片类型&quot;); } }else{ switch ($error){ case 1: echo &quot;超过了上传文件的最大值，请上传2M以下文件&quot;; break; case 2: echo &quot;上传文件过多，请一次上传20个及以下文件！&quot;; break; case 3: echo &quot;文件并未完全上传，请再次尝试！&quot;; break; case 4: echo &quot;未选择上传文件！&quot;; break; case 7: echo &quot;没有临时文件夹&quot;; break; } } 这里，具体实现都有注释，每一步其实都可以自己试试的，很有趣。 2.3 封装函数 &lt;?php function uploadFile($fileInfo,$path,$allowExt,$maxSize){ $filename=$fileInfo[&quot;name&quot;]; $tmp_name=$fileInfo[&quot;tmp_name&quot;]; $size=$fileInfo[&quot;size&quot;]; $error=$fileInfo[&quot;error&quot;]; $type=$fileInfo[&quot;type&quot;]; //服务器端设定限制 $ext=pathinfo($filename,PATHINFO_EXTENSION); //目的信息 if (!file_exists($path)) { mkdir($path,0777,true); chmod($path, 0777); } $uniName=md5(uniqid(microtime(true),true)).&apos;.&apos;.$ext; $destination=$path.&quot;/&quot;.$uniName; if ($error==0) { if ($size&gt;$maxSize) { exit(&quot;上传文件过大！&quot;); } if (!in_array($ext, $allowExt)) { exit(&quot;非法文件类型&quot;); } if (!is_uploaded_file($tmp_name)) { exit(&quot;上传方式有误，请使用post方式&quot;); } //判断是否为真实图片（防止伪装成图片的病毒一类的 if (!getimagesize($tmp_name)) {//getimagesize真实返回数组，否则返回false exit(&quot;不是真正的图片类型&quot;); } if (@move_uploaded_file($tmp_name, $destination)) {//@错误抑制符，不让用户看到警告 echo &quot;文件&quot;.$filename.&quot;上传成功!&quot;; }else{ echo &quot;文件&quot;.$filename.&quot;上传失败!&quot;; } }else{ switch ($error){ case 1: echo &quot;超过了上传文件的最大值，请上传2M以下文件&quot;; break; case 2: echo &quot;上传文件过多，请一次上传20个及以下文件！&quot;; break; case 3: echo &quot;文件并未完全上传，请再次尝试！&quot;; break; case 4: echo &quot;未选择上传文件！&quot;; break; case 7: echo &quot;没有临时文件夹&quot;; break; } } return $destination; } 调用 &lt;?php header(&apos;content-type:text/html;charset=utf-8&apos;); $fileInfo=$_FILES[&quot;myFile&quot;]; $maxSize=10485760;//10M,10*1024*1024 $allowExt=array(&apos;jpeg&apos;,&apos;jpg&apos;,&apos;png&apos;,&apos;tif&apos;); $path=&quot;uploads&quot;; include_once &apos;upFunc.php&apos;; uploadFile($fileInfo, $path, $allowExt, $maxSize); 三、多文件的上传实现3.1 利用单文件封装&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;doAction5.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 请选择您要上传的文件：&lt;input type=&quot;file&quot; name=&quot;myFile1&quot; /&gt;&lt;br/&gt; 请选择您要上传的文件：&lt;input type=&quot;file&quot; name=&quot;myFile2&quot; /&gt;&lt;br/&gt; 请选择您要上传的文件：&lt;input type=&quot;file&quot; name=&quot;myFile3&quot; /&gt;&lt;br/&gt; 请选择您要上传的文件：&lt;input type=&quot;file&quot; name=&quot;myFile4&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; &lt;?php //print_r($_FILES); header(&apos;content-type:text/html;charset=utf-8&apos;); include_once &apos;upFunc.php&apos;; foreach ($_FILES as $fileInfo){ $file[]=uploadFile($fileInfo); } 这里的思路，从print_r($_FILES)中去找，打印出来看到是个二维数组，很简单，遍历去用就好了！ 上面那个function的定义改一下，给定一些默认值 function uploadFile($fileInfo,$path=&quot;uploads&quot;,$allowExt=array(&apos;jpeg&apos;,&apos;jpg&apos;,&apos;png&apos;,&apos;tif&apos;),$maxSize=10485760){ 这样子，简单是简单，但遇到一些问题。 正常的上传4个图片是没问题，但要是中间激活了函数中的exit，就会立即停止，导致其他图片也无法上传。 3.2 升级版封装旨在实现针对多个或单个文件上传的封装 首先这样子写个静态文件 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;doAction5.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 请选择您要上传的文件：&lt;input type=&quot;file&quot; name=&quot;myFile[]&quot; /&gt;&lt;br/&gt; 请选择您要上传的文件：&lt;input type=&quot;file&quot; name=&quot;myFile[]&quot; /&gt;&lt;br/&gt; 请选择您要上传的文件：&lt;input type=&quot;file&quot; name=&quot;myFile[]&quot; /&gt;&lt;br/&gt; 请选择您要上传的文件：&lt;input type=&quot;file&quot; name=&quot;myFile[]&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 打印一下$_FILES Array ( [myFile] =&gt; Array ( [name] =&gt; Array ( [0] =&gt; test32.png [1] =&gt; test32.png [2] =&gt; 333.png [3] =&gt; test41.png ) [type] =&gt; Array ( [0] =&gt; image/png [1] =&gt; image/png [2] =&gt; image/png [3] =&gt; image/png ) [tmp_name] =&gt; Array ( [0] =&gt; D:\wamp\tmp\php831C.tmp [1] =&gt; D:\wamp\tmp\php834C.tmp [2] =&gt; D:\wamp\tmp\php837C.tmp [3] =&gt; D:\wamp\tmp\php83BB.tmp ) [error] =&gt; Array ( [0] =&gt; 0 [1] =&gt; 0 [2] =&gt; 0 [3] =&gt; 0 ) [size] =&gt; Array ( [0] =&gt; 46174 [1] =&gt; 46174 [2] =&gt; 34196 [3] =&gt; 38514 ) ) ) 可以得到一个三维数组。 复杂是复杂了，但复杂的有规律，各项数值都在一起了，很方便我们取值！！ 所以先得到文件信息，变成单文件处理那种信息 function getFiles(){ $i=0; foreach($_FILES as $file){ if(is_string($file[&apos;name&apos;])){ //单文件判定 $files[$i]=$file; $i++; }elseif(is_array($file[&apos;name&apos;])){ foreach($file[&apos;name&apos;] as $key=&gt;$val){ //我的天，这个$key用的diao $files[$i][&apos;name&apos;]=$file[&apos;name&apos;][$key]; $files[$i][&apos;type&apos;]=$file[&apos;type&apos;][$key]; $files[$i][&apos;tmp_name&apos;]=$file[&apos;tmp_name&apos;][$key]; $files[$i][&apos;error&apos;]=$file[&apos;error&apos;][$key]; $files[$i][&apos;size&apos;]=$file[&apos;size&apos;][$key]; $i++; } } } return $files; } 然后之前的那种exit错误，就把exit改一下就好了，这里用res function uploadFile($fileInfo,$path=&apos;./uploads&apos;,$flag=true,$maxSize=1048576,$allowExt=array(&apos;jpeg&apos;,&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;)){ //$flag=true; //$allowExt=array(&apos;jpeg&apos;,&apos;jpg&apos;,&apos;gif&apos;,&apos;png&apos;); //$maxSize=1048576;//1M //判断错误号 $res=array(); if($fileInfo[&apos;error&apos;]===UPLOAD_ERR_OK){ //检测上传得到小 if($fileInfo[&apos;size&apos;]&gt;$maxSize){ $res[&apos;mes&apos;]=$fileInfo[&apos;name&apos;].&apos;上传文件过大&apos;; } $ext=getExt($fileInfo[&apos;name&apos;]); //检测上传文件的文件类型 if(!in_array($ext,$allowExt)){ $res[&apos;mes&apos;]=$fileInfo[&apos;name&apos;].&apos;非法文件类型&apos;; } //检测是否是真实的图片类型 if($flag){ if(!getimagesize($fileInfo[&apos;tmp_name&apos;])){ $res[&apos;mes&apos;]=$fileInfo[&apos;name&apos;].&apos;不是真实图片类型&apos;; } } //检测文件是否是通过HTTP POST上传上来的 if(!is_uploaded_file($fileInfo[&apos;tmp_name&apos;])){ $res[&apos;mes&apos;]=$fileInfo[&apos;name&apos;].&apos;文件不是通过HTTP POST方式上传上来的&apos;; } if($res) return $res; //$path=&apos;./uploads&apos;; if(!file_exists($path)){ mkdir($path,0777,true); chmod($path,0777); } $uniName=getUniName(); $destination=$path.&apos;/&apos;.$uniName.&apos;.&apos;.$ext; if(!move_uploaded_file($fileInfo[&apos;tmp_name&apos;],$destination)){ $res[&apos;mes&apos;]=$fileInfo[&apos;name&apos;].&apos;文件移动失败&apos;; } $res[&apos;mes&apos;]=$fileInfo[&apos;name&apos;].&apos;上传成功&apos;; $res[&apos;dest&apos;]=$destination; return $res; }else{ //匹配错误信息 switch ($fileInfo [&apos;error&apos;]) { case 1 : $res[&apos;mes&apos;] = &apos;上传文件超过了PHP配置文件中upload_max_filesize选项的值&apos;; break; case 2 : $res[&apos;mes&apos;] = &apos;超过了表单MAX_FILE_SIZE限制的大小&apos;; break; case 3 : $res[&apos;mes&apos;] = &apos;文件部分被上传&apos;; break; case 4 : $res[&apos;mes&apos;] = &apos;没有选择上传文件&apos;; break; case 6 : $res[&apos;mes&apos;] = &apos;没有找到临时目录&apos;; break; case 7 : case 8 : $res[&apos;mes&apos;] = &apos;系统错误&apos;; break; } return $res; } } 里面封装了两个小的 function getExt($filename){ return strtolower(pathinfo($filename,PATHINFO_EXTENSION)); } /** * 产生唯一字符串 * @return string */ function getUniName(){ return md5(uniqid(microtime(true),true)); } 然后静态中，用multiple属性实现多个文件的输入； &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;doAction6.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; 请选择您要上传的文件：&lt;input type=&quot;file&quot; name=&quot;myFile[]&quot; multiple=&apos;multiple&apos; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; doAction6 &lt;?php //print_r($_FILES); header(&quot;content-type:text/html;charset=utf-8&quot;); require_once &apos;upFunc2.php&apos;; require_once &apos;common.func.php&apos;; $files=getFiles(); // print_r($files); foreach($files as $fileInfo){ $res=uploadFile($fileInfo); echo $res[&apos;mes&apos;],&apos;&lt;br/&gt;&apos;; $uploadFiles[]=@$res[&apos;dest&apos;]; } $uploadFiles=array_values(array_filter($uploadFiles)); //print_r($uploadFiles); 这样子的几个文件，就实现比较强大的面向过程的上传文件的功能（学的叫一个心酸。。。）； 四、面向对象的文件上传（不是很写的动了。。。先粘过来，再说吧。。。 &lt;?php class upload{ protected $fileName; protected $maxSize; protected $allowMime; protected $allowExt; protected $uploadPath; protected $imgFlag; protected $fileInfo; protected $error; protected $ext; /** * @param string $fileName * @param string $uploadPath * @param string $imgFlag * @param number $maxSize * @param array $allowExt * @param array $allowMime */ public function __construct($fileName=&apos;myFile&apos;,$uploadPath=&apos;./uploads&apos;,$imgFlag=true,$maxSize=5242880,$allowExt=array(&apos;jpeg&apos;,&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;),$allowMime=array(&apos;image/jpeg&apos;,&apos;image/png&apos;,&apos;image/gif&apos;)){ $this-&gt;fileName=$fileName; $this-&gt;maxSize=$maxSize; $this-&gt;allowMime=$allowMime; $this-&gt;allowExt=$allowExt; $this-&gt;uploadPath=$uploadPath; $this-&gt;imgFlag=$imgFlag; $this-&gt;fileInfo=$_FILES[$this-&gt;fileName]; } /** * 检测上传文件是否出错 * @return boolean */ protected function checkError(){ if(!is_null($this-&gt;fileInfo)){ if($this-&gt;fileInfo[&apos;error&apos;]&gt;0){ switch($this-&gt;fileInfo[&apos;error&apos;]){ case 1: $this-&gt;error=&apos;超过了PHP配置文件中upload_max_filesize选项的值&apos;; break; case 2: $this-&gt;error=&apos;超过了表单中MAX_FILE_SIZE设置的值&apos;; break; case 3: $this-&gt;error=&apos;文件部分被上传&apos;; break; case 4: $this-&gt;error=&apos;没有选择上传文件&apos;; break; case 6: $this-&gt;error=&apos;没有找到临时目录&apos;; break; case 7: $this-&gt;error=&apos;文件不可写&apos;; break; case 8: $this-&gt;error=&apos;由于PHP的扩展程序中断文件上传&apos;; break; } return false; }else{ return true; } }else{ $this-&gt;error=&apos;文件上传出错&apos;; return false; } } /** * 检测上传文件的大小 * @return boolean */ protected function checkSize(){ if($this-&gt;fileInfo[&apos;size&apos;]&gt;$this-&gt;maxSize){ $this-&gt;error=&apos;上传文件过大&apos;; return false; } return true; } /** * 检测扩展名 * @return boolean */ protected function checkExt(){ $this-&gt;ext=strtolower(pathinfo($this-&gt;fileInfo[&apos;name&apos;],PATHINFO_EXTENSION)); if(!in_array($this-&gt;ext,$this-&gt;allowExt)){ $this-&gt;error=&apos;不允许的扩展名&apos;; return false; } return true; } /** * 检测文件的类型 * @return boolean */ protected function checkMime(){ if(!in_array($this-&gt;fileInfo[&apos;type&apos;],$this-&gt;allowMime)){ $this-&gt;error=&apos;不允许的文件类型&apos;; return false; } return true; } /** * 检测是否是真实图片 * @return boolean */ protected function checkTrueImg(){ if($this-&gt;imgFlag){ if(!@getimagesize($this-&gt;fileInfo[&apos;tmp_name&apos;])){ $this-&gt;error=&apos;不是真实图片&apos;; return false; } return true; } } /** * 检测是否通过HTTP POST方式上传上来的 * @return boolean */ protected function checkHTTPPost(){ if(!is_uploaded_file($this-&gt;fileInfo[&apos;tmp_name&apos;])){ $this-&gt;error=&apos;文件不是通过HTTP POST方式上传上来的&apos;; return false; } return true; } /** *显示错误 */ protected function showError(){ exit(&apos;&lt;span style=&quot;color:red&quot;&gt;&apos;.$this-&gt;error.&apos;&lt;/span&gt;&apos;); } /** * 检测目录不存在则创建 */ protected function checkUploadPath(){ if(!file_exists($this-&gt;uploadPath)){ mkdir($this-&gt;uploadPath,0777,true); } } /** * 产生唯一字符串 * @return string */ protected function getUniName(){ return md5(uniqid(microtime(true),true)); } /** * 上传文件 * @return string */ public function uploadFile(){ if($this-&gt;checkError()&amp;&amp;$this-&gt;checkSize()&amp;&amp;$this-&gt;checkExt()&amp;&amp;$this-&gt;checkMime()&amp;&amp;$this-&gt;checkTrueImg()&amp;&amp;$this-&gt;checkHTTPPost()){ $this-&gt;checkUploadPath(); $this-&gt;uniName=$this-&gt;getUniName(); $this-&gt;destination=$this-&gt;uploadPath.&apos;/&apos;.$this-&gt;uniName.&apos;.&apos;.$this-&gt;ext; if(@move_uploaded_file($this-&gt;fileInfo[&apos;tmp_name&apos;], $this-&gt;destination)){ return $this-&gt;destination; }else{ $this-&gt;error=&apos;文件移动失败&apos;; $this-&gt;showError(); } }else{ $this-&gt;showError(); } } } &lt;?php header(&apos;content-type:text/html;charset=utf-8&apos;); require_once &apos;upload.class.php&apos;; $upload=new upload(&apos;myFile1&apos;,&apos;imooc&apos;); $dest=$upload-&gt;uploadFile(); echo $dest; 五、下载对于浏览器不识别的，可以直接下载，但对于能识别的，需要多一两步 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;1.rar&quot;&gt;下载1.rar&lt;/a&gt; &lt;br /&gt; &lt;a href=&quot;1.jpg&quot;&gt;下载1.jpg&lt;/a&gt; &lt;br /&gt; &lt;a href=&quot;doDownload.php?filename=1.jpg&quot;&gt;通过程序下载1.jpg&lt;/a&gt; &lt;br /&gt; &lt;a href=&quot;doDownload.php?filename=../upload/nv.jpg&quot;&gt;下载nv.jpg&lt;/a&gt; &lt;?php ?&gt; &lt;/body&gt; &lt;/html&gt; &lt;?php $filename=$_GET[&apos;filename&apos;]; header(&apos;content-disposition:attachment;filename=&apos;.basename($filename)); header(&apos;content-length:&apos;.filesize($filename)); readfile($filename); ——————总结———————– 二维数组的降维处理； $_FILES变量 move_upload_file();copy(); tmp_name临时文件； 拓展名的提取； 真实图片的验证； 唯一文件名的生成； 函数封装以及调用； 利用单个文件函数实现多文件上传； 小功能的封装； 多文件的遍历； 面向对象的开发过程；]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>文件上传下载原理与配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第二十三篇——文件上传下载实战]]></title>
    <url>%2F2018%2F12%2F17%2FPHP%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E7%AF%87%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[既然涉及到PHP开发APP接口，文件上传和下载是在所难免的，也许有些人会考虑第三方的，比如七牛，但是学习和使用终究还是要会的，所以，所以…… 文件上传下载实战以前一直在做iOS，最近转行去搞php开发，总觉得力不从心。这几天有个需求，是关于php的文件上传和下载的。给大家分享下自己的学习资料。 1.先来个请求页面upload.html&lt;html&gt; &lt;head&gt; &lt;title&gt;Administration - upload new files&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Upload new news files&lt;/h1&gt; &lt;form enctype=&quot;multipart/form-data&quot; action=&quot;upload.php&quot; method=post&gt; &lt;input type=&quot;hidden&quot; name=&quot;MAX_FILE_SIZE&quot; value=&quot;1000000&quot;&gt; Upload this file: &lt;input name=&quot;userfile&quot; type=&quot;file&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Send File&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 2.php处理客户端请求的数据upload.html&lt;html&gt; &lt;head&gt; &lt;title&gt;Uploading...&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Uploading file...&lt;/h1&gt; &lt;?php //Check to see if an error code was generated on the upload attempt if ($_FILES[&apos;userfile&apos;][&apos;error&apos;] &gt; 0) { echo &apos;Problem: &apos;; switch ($_FILES[&apos;userfile&apos;][&apos;error&apos;]) { case 1: echo &apos;File exceeded upload_max_filesize&apos;; break; case 2: echo &apos;File exceeded max_file_size&apos;; break; case 3: echo &apos;File only partially uploaded&apos;; break; case 4: echo &apos;No file uploaded&apos;; break; case 6: echo &apos;Cannot upload file: No temp directory specified.&apos;; break; case 7: echo &apos;Upload failed: Cannot write to disk.&apos;; break; } exit; } // Does the file have the right MIME type? if ($_FILES[&apos;userfile&apos;][&apos;type&apos;] != &apos;text/plain&apos;) { echo &apos;Problem: file is not plain text&apos;; exit; } // put the file where we&apos;d like it $upfile = &apos;/uploads/&apos;.$_FILES[&apos;userfile&apos;][&apos;name&apos;]; if (is_uploaded_file($_FILES[&apos;userfile&apos;][&apos;tmp_name&apos;])) { if (!move_uploaded_file($_FILES[&apos;userfile&apos;][&apos;tmp_name&apos;], $upfile)) { echo &apos;Problem: Could not move file to destination directory&apos;; exit; } } else { echo &apos;Problem: Possible file upload attack. Filename: &apos;; echo $_FILES[&apos;userfile&apos;][&apos;name&apos;]; exit; } echo &apos;File uploaded successfully&lt;br&gt;&lt;br&gt;&apos;; // reformat the file contents $fp = fopen($upfile, &apos;r&apos;); $contents = fread ($fp, filesize ($upfile)); fclose ($fp); $contents = strip_tags($contents); $fp = fopen($upfile, &apos;w&apos;); fwrite($fp, $contents); fclose($fp); // show what was uploaded echo &apos;Preview of uploaded file contents:&lt;br&gt;&lt;hr&gt;&apos;; echo $contents; echo &apos;&lt;br&gt;&lt;hr&gt;&apos;; ?&gt; &lt;/body&gt; &lt;/html&gt; 3.php文件下载&lt;?php $filePath = &quot;template/&quot;;//此处给出你下载的文件在服务器的什么地方 $fileName = &quot;template.xls&quot;; //此处给出你下载的文件名 $file = fopen($filePath . $fileName, &quot;r&quot;); // 打开文件 //输入文件标签 Header(&quot;Content-type:application/octet-stream &quot;); Header(&quot;Accept-Ranges:bytes &quot;); Header(&quot;Accept-Length: &quot; . filesize($filePath . $fileName)); Header(&quot;Content-Disposition: attachment; filename= &quot; . $fileName); // 输出文件内容 echo fread($file, filesize($filePath . $fileName)); fclose($file); exit; ?&gt; 总的来说，上面的3个代码段只是简单介绍了php文件的上传下载，还有很多问题要解决，就例如上传大文件的时候怎么处理，批量上传、大文件下载等等问题。当然跟java一样，php也有很多框架可以解决这方面。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>文件上传下载实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第二十二篇——数据库优化的八种方式]]></title>
    <url>%2F2018%2F12%2F15%2FPHP%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E7%AF%87%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E7%9A%84%E5%85%AB%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[数据库优化的八种方式引言：关于数据库优化，网上有不少资料和方法，但是不少质量参差不齐，有些总结的不够到位，内容冗杂偶尔发现了这篇文章，总结得很经典，文章流量也很大，所以拿到自己的总结文集中，积累优质文章，提升个人能力，希望对大家今后开发中也有帮助 选取最适用的字段属性MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。 例如，在定义邮政编码这个字段时，如果将其设置为CHAR(255),显然给数据库增加了不必要的空间，甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段。 另外一个提高效率的方法是在可能的情况下，应该尽量把字段设置为NOTNULL，这样在将来执行查询的时候，数据库不用去比较NULL值。对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。 使用连接（JOIN）来代替子查询(Sub-Queries)MySQL从4.1开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。例如，我们要将客户基本信息表中没有任何订单的客户删除掉，就可以利用子查询先从销售信息表中将所有发出订单的客户ID取出来，然后将结果传递给主查询，如下所示： DELETEFROMcustomerinfo WHERECustomerIDNOTin(SELECTCustomerIDFROMsalesinfo) 使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接（JOIN）..替代。例如，假设我们要将所有没有订单记录的用户取出来，可以用下面这个查询完成： SELECT*FROMcustomerinfo WHERECustomerIDNOTin(SELECTCustomerIDFROMsalesinfo) 如果使用连接（JOIN）..来完成这个查询工作，速度将会快很多。尤其是当salesinfo表中对CustomerID建有索引的话，性能将会更好，查询如下： SELECT*FROMcustomerinfo LEFTJOINsalesinfoONcustomerinfo.CustomerID=salesinfo.CustomerID WHEREsalesinfo.CustomerIDISNULL 连接（JOIN）..之所以更有效率一些，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。 使用联合(UNION)来代替手动创建的临时表MySQL从4.0的版本开始支持union查询，它可以把需要使用临时表的两条或更多的select查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。使用union来创建查询的时候，我们只需要用UNION作为关键字把多个select语句连接起来就可以了，要注意的是所有select语句中的字段数目要想同。下面的例子就演示了一个使用UNION的查询。 SELECTName,PhoneFROMclientUNION SELECTName,BirthDateFROMauthorUNION SELECTName,SupplierFROMproduct 事务尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条SQL语句就可以完成的。更多的时候是需要用到一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来。设想一下，要把某个数据同时插入两个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，造成第二个表中的操作没有完成，这样，就会造成数据的不完整，甚至会破坏数据库中的数据。要避免这种情况，就应该使用事务，它的作用是：要么语句块中每条语句都操作成功，要么都失败。换句话说，就是可以保持数据库中数据的一致性和完整性。事物以BEGIN关键字开始，COMMIT关键字结束。在这之间的一条SQL操作失败，那么，ROLLBACK命令就可以把数据库恢复到BEGIN开始之前的状态。 BEGIN; INSERTINTOsalesinfoSETCustomerID=14;UPDATEinventorySETQuantity=11WHEREitem=&apos;book&apos;;COMMIT; 事务的另一个重要作用是当多个用户同时使用相同的数据源时，它可以利用锁定数据库的方法来为用户提供一种安全的访问方式，这样可以保证用户的操作不被其它的用户所干扰。 锁定表尽管事务是维护数据库完整性的一个非常好的方法，但却因为它的独占性，有时会影响数据库的性能，尤其是在很大的应用系统中。由于在事务执行的过程中，数据库将会被锁定，因此其它的用户请求只能暂时等待直到该事务结束。如果一个数据库系统只有少数几个用户来使用，事务造成的影响不会成为一个太大的问题；但假设有成千上万的用户同时访问一个数据库系统，例如访问一个电子商务网站，就会产生比较严重的响应延迟。 其实，有些情况下我们可以通过锁定表的方法来获得更好的性能。下面的例子就用锁定表的方法来完成前面一个例子中事务的功能。 LOCKTABLEinventoryWRITESELECTQuantityFROMinventoryWHEREItem=&apos;book&apos;; ... UPDATEinventorySETQuantity=11WHEREItem=&apos;book&apos;;UNLOCKTABLES 这里，我们用一个select语句取出初始数据，通过一些计算，用update语句将新值更新到表中。包含有WRITE关键字的LOCKTABLE语句可以保证在UNLOCKTABLES命令被执行之前，不会有其它的访问来对inventory进行插入、更新或者删除的操作。 使用外键锁定表的方法可以维护数据的完整性，但是它却不能保证数据的关联性。这个时候我们就可以使用外键。 例如，外键可以保证每一条销售记录都指向某一个存在的客户。在这里，外键可以把customerinfo表中的CustomerID映射到salesinfo表中CustomerID，任何一条没有合法CustomerID的记录都不会被更新或插入到salesinfo中。 CREATETABLEcustomerinfo( CustomerIDINTNOTNULL,PRIMARYKEY(CustomerID))TYPE=INNODB; CREATETABLEsalesinfo( SalesIDINTNOTNULL,CustomerIDINTNOTNULL, PRIMARYKEY(CustomerID,SalesID), FOREIGNKEY(CustomerID)REFERENCEScustomerinfo(CustomerID)ONDELETECASCADE)TYPE=INNODB; 注意例子中的参数“ONDELETECASCADE”。该参数保证当customerinfo表中的一条客户记录被删除的时候，salesinfo表中所有与该客户相关的记录也会被自动删除。如果要在MySQL中使用外键，一定要记住在创建表的时候将表的类型定义为事务安全表InnoDB类型。该类型不是MySQL表的默认类型。定义的方法是在CREATETABLE语句中加上TYPE=INNODB。如例中所示。 使用索引索引是提高数据库性能的常用方法，它可以令数据库服务器以比没有索引快得多的速度检索特定的行，尤其是在查询语句当中包含有MAX(),MIN()和ORDERBY这些命令的时候，性能提高更为明显。 那该对哪些字段建立索引呢？ 一般说来，索引应建立在那些将用于JOIN,WHERE判断和ORDERBY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。对于一个ENUM类型的字段来说，出现大量重复值是很有可能的情况 例如customerinfo中的“province”..字段，在这样的字段上建立索引将不会有什么帮助；相反，还有可能降低数据库的性能。我们在创建表的时候可以同时创建合适的索引，也可以使用ALTERTABLE或CREATEINDEX在以后创建索引。此外，MySQL从版本3.23.23开始支持全文索引和搜索。全文索引在MySQL中是一个FULLTEXT类型索引，但仅能用于MyISAM类型的表。对于一个大的数据库，将数据装载到一个没有FULLTEXT索引的表中，然后再使用ALTERTABLE或CREATEINDEX创建索引，将是非常快的。但如果将数据装载到一个已经有FULLTEXT索引的表中，执行过程将会非常慢。 优化的查询语句绝大多数情况下，使用索引可以提高查询的速度，但如果SQL语句使用不恰当的话，索引将无法发挥它应有的作用。 下面是应该注意的几个方面。 首先，最好是在相同类型的字段间进行比较的操作。 在MySQL3.23版之前，这甚至是一个必须的条件。例如不能将一个建有索引的INT字段和BIGINT字段进行比较；但是作为特殊的情况，在CHAR类型的字段和VARCHAR类型字段的字段大小相同的时候，可以将它们进行比较。 其次，在建有索引的字段上尽量不要使用函数进行操作。 例如，在一个DATE类型的字段上使用YEAE()函数时，将会使索引不能发挥应有的作用。所以，下面的两个查询虽然返回的结果一样，但后者要比前者快得多。 第三，在搜索字符型字段时，我们有时会使用LIKE关键字和通配符，这种做法虽然简单，但却也是以牺牲系统性能为代价的。 例如下面的查询将会比较表中的每一条记录。 SELECT*FROMbooks WHEREnamelike&quot;MySQL%&quot; 但是如果换用下面的查询，返回的结果一样，但速度就要快上很多： SELECT*FROMbooks WHEREname＞=&quot;MySQL&quot;andname＜&quot;MySQM&quot; 最后，应该注意避免在查询中让MySQL进行自动类型转换，因为转换过程也会使索引变得不起作用。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>数据库优化的八种方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第二十一篇——数据库操作]]></title>
    <url>%2F2018%2F12%2F15%2FPHP%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E7%AF%87%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[关于数据库操作，在PHP开发中可谓是重中之重，其他开发想iOS，Android如果只是做一个简单的App可以不用对数据库操作，但是PHP开发中没有数据库操作就等于一尊雕塑，PHP中数据库首选MYSql，不用问为什么，因为他们是天合之作，谁用谁知道…… 数据库操作PHP支持的数据库PHP通过安装相应的扩展来实现数据库操作，现代应用程序的设计离不开数据库的应用，当前主流的数据库有MsSQL，MySQL，Sybase，Db2，Oracle，PostgreSQL，Access等，这些数据库PHP都能够安装扩展来支持，一般情况下常说的LAMP架构指的是：Linux、Apache、Mysql、PHP，因此Mysql数据库在PHP中的应用非常广泛，我们会在本章中简单的了解Mysql的操作方法。 数据库拓展PHP中一个数据库可能有一个或者多个扩展，其中既有官方的，也有第三方提供的。像Mysql常用的扩展有原生的mysql库，也可以使用增强版的mysqli扩展，还可以使用PDO进行连接与操作。 不同的扩展提供基本相近的操作方法，不同的是可能具备一些新特性，以及操作性能可能会有所不同。 mysql扩展进行数据库连接的方法： $link = mysql_connect(&apos;mysql_host&apos;, &apos;mysql_user&apos;, &apos;mysql_password&apos;); mysqli扩展： $link = mysqli_connect(&apos;mysql_host&apos;, &apos;mysql_user&apos;, &apos;mysql_password&apos;); PDO扩展 $dsn = &apos;mysql:dbname=testdb;host=127.0.0.1&apos;; $user = &apos;dbuser&apos;; $password = &apos;dbpass&apos;; $dbh = new PDO($dsn, $user, $password); 链接数据库PHP要对数据库进行操作，首先要做的是与数据库建立连接，通常我们使用mysql_connect函数进行数据库连接，该函数需要指定数据库的地址，用户名及密码。 $host = &apos;localhost&apos;; $user = &apos;code1&apos;; $pass = &apos;&apos;; $link = mysql_connect($host, $user, $pass); PHP连接数据库的方式类似于直接在命令行下通过进行连接，类似：mysql -hlocalhost -ucode1 -p，当连接成功以后，我们需要选择一个操作的数据库，通过mysql_select_db函数来选择数据库。 mysql_select_db(&apos;code1&apos;); 通常我们会先设置一下当前连接使用的字符编码，一般的我们会使用utf8编码。 mysql_query(&quot;set names &apos;utf8&apos;&quot;); 通过上面的步骤，我们就与数据库建立了连接，可以进行数据操作了。 查询数据库在数据库建立连接以后就可以进行查询，采用mysql_query加sql语句的形式向数据库发送查询指令。 $res = mysql_query(&apos;select * from user limit 1&apos;); 对于查询类的语句会返回一个资源句柄（resource），可以通过该资源获取查询结果集中的数据。 $row = mysql_fetch_array($res); var_dump($row); 默认的，PHP使用最近的数据库连接执行查询，但如果存在多个连接的情况，则可以通过参数指令从那个连接中进行查询。 $link1 = mysql_connect(&apos;127.0.0.1&apos;, &apos;code1&apos;, &apos;&apos;); $link2 = mysql_connect(&apos;127.0.0.1&apos;, &apos;code1&apos;, &apos;&apos;, true); //开启一个新的连接 $res = mysql_query(&apos;select * from user limit 1&apos;, $link1); //从第一个连接中查询数据 插入数据库当我们了解了如何使用mysql_query进行数据查询以后，那么类似的，插入数据其实也是通过执行一个sql语句来实现，例如： $sql = &quot;insert into user(name, age, class) values(&apos;李四&apos;, 18, &apos;高三一班&apos;)&quot;; mysql_query($sql); //执行插入语句 通常数据都是存储在变量或者数组中，因此sql语句需要先进行字符串拼接得到。 $name = &apos;李四&apos;; $age = 18; $class = &apos;高三一班&apos;; $sql = &quot;insert into user(name, age, class) values(&apos;$name&apos;, &apos;$age&apos;, &apos;$class&apos;)&quot;; mysql_query($sql); //执行插入语句 在mysql中，执行插入语句以后，可以得到自增的主键id,通过PHP的mysql_insert_id函数可以获取该id。 $uid = mysql_insert_id(); 这个id的作用非常大，通常可以用来判断是否插入成功，或者作为关联ID进行其他的数据操作。 获取查询结果通过前面的章节，我们发现PHP操作数据库跟MySql客户端上操作极为相似，先进行连接，然后执行sql语句，再然后获取我们想要的结果集。 PHP有多个函数可以获取数据集中的一行数据，最常用的是mysql_fetch_array，可以通过设定参数来更改行数据的下标，默认的会包含数字索引的下标以及字段名的关联索引下标。 $sql = &quot;select * from user limit 1&quot;; $result = mysql_query($sql); $row = mysql_fetch_array($result); 可以通过设定参数MYSQL_NUM只获取数字索引数组，等同于mysql_fetch_row函数，如果设定参数为MYSQL_ASSOC则只获取关联索引数组，等同于mysql_fetch_assoc函数。 $row = mysql_fetch_row($result); $row = mysql_fetch_array($result, MYSQL_NUM); //这两个方法获取的数据是一样的 $row = mysql_fetch_assoc($result); $row = mysql_fetch_array($result, MYSQL_ASSOC); 如果要获取数据集中的所有数据，我们通过循环来遍历整个结果集。 $data = array(); while ($row = mysql_fetch_array($result)) { $data[] = $row; } 分页查询上一节中，我们了解到通过循环可以获取一个查询的所有数据，在实际应用中，我们并不希望一次性获取数据表中的所有数据，那样性能会非常的低，因此会使用翻页功能，每页仅显示10条或者20条数据。 通过mysql的limit可以很容易的实现分页，limit m,n表示从m行后取n行数据，在PHP中我们需要构造m与n来实现获取某一页的所有数据。 假定当前页为$page，每页显示$n条数据，那么m为当前页前面所有的数据，既$m = ($page-1) * $n，在知道了翻页原理以后，那么我们很容易通过构造SQL语句在PHP中实现数据翻页。 $page = 2; $n = 2; $m = ($page - 1) * $n; $sql = &quot;select * from user limit $m, $n&quot;; $result = mysql_query($sql); //循环获取当前页的数据 $data = array(); while ($row = mysql_fetch_assoc($result)) { $data[] = $row; } 在上面的例子中，我们使用了$m与$n变量来表示偏移量与每页数据条数，但我们推荐使用更有意义的变量名来表示，比如$pagesize, $start, $offset等，这样更容易理解，有助于团队协作开发。 更新与删除数据的更新与删除相对比较简单，只需要构建好相应的sql语句，然后调用mysql_query执行就能完成相应的更新与删除操作。 $sql = &quot;update user set name = &apos;曹操&apos; where id=2 limit 1&quot;; if (mysql_query($sql)) { echo &apos;更新成功&apos;; } 同样的删除可以使用类似以下的代码： $sql = &quot;delete from user where id=2 limit 1&quot;; if (mysql_query($sql)) { echo &apos;删除成功&apos;; } 对于删除与更新操作，可以通过mysql_affected_rows函数来获取更新过的数据行数，如果数据没有变化，则结果为0。 $sql = &quot;update user set name = &apos;曹操&apos; where id=2 limit 1&quot;; if (mysql_query($sql)) { echo mysql_affected_rows(); } 关闭数据库当数据库操作完成以后，可以使用mysql_close关闭数据库连接，默认的，当PHP执行完毕以后，会自动的关闭数据库连接。 mysql_close(); 虽然PHP会自动关闭数据库连接，一般情况下已经满足需求，但是在对性能要求比较高的情况下，可以在进行完数据库操作之后尽快关闭数据库连接，以节省资源，提高性能。 在存在多个数据库连接的情况下，可以设定连接资源参数来关闭指定的数据库连接。 $link = mysql_connect($host, $user, $pass); mysql_close($link); 关于数据库的操作这里只是简单的整理一下，后期或抽出专门的时间，使用专门的章节详细介绍使用与实战数据库的操作。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>数据库操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第二十篇——session和cookie]]></title>
    <url>%2F2018%2F12%2F13%2FPHP%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AF%87%E2%80%94%E2%80%94session%E5%92%8Ccookie%2F</url>
    <content type="text"><![CDATA[关于session和cookie之前做iOS开发的时候听过，也试着去了解过，但是因为项目中并没有实际应用就没有研究过了，但是PHP开发的话必须了解并熟悉他们的使用，我目前的理解就是。cookie数据保存在客户端,session数据保存在服务器端…… session和cookiecookie简介Cookie是存储在客户端浏览器中的数据，我们通过Cookie来跟踪与存储用户数据。一般情况下，Cookie通过HTTP headers从服务端返回到客户端。多数web程序都支持Cookie的操作，因为Cookie是存在于HTTP的标头之中，所以必须在其他信息输出以前进行设置，类似于header函数的使用限制。 PHP通过setcookie函数进行Cookie的设置，任何从浏览器发回的Cookie，PHP都会自动的将他存储在$_COOKIE的全局变量之中，因此我们可以通过$_COOKIE[‘key’]的形式来读取某个Cookie值。 PHP中的Cookie具有非常广泛的使用，经常用来存储用户的登录信息，购物车等，且在使用会话Session时通常使用Cookie来存储会话id来识别用户，Cookie具备有效期，当有效期结束之后，Cookie会自动的从客户端删除。同时为了进行安全控制，Cookie还可以设置域跟路径，我们会在稍后的章节中详细的讲解他们。 官方文档的介绍PHP 透明地支持 HTTP cookie。cookie 是一种在远程浏览器端储存数据并以此来跟踪和识别用户的机制。可以用 setcookie() 或 setrawcookie() 函数来设置 cookie。cookie 是 HTTP 标头的一部分，因此 setcookie() 函数必须在其它信息被输出到浏览器前调用，这和对 header() 函数的限制类似。可以使用输出缓冲函数来延迟脚本的输出，直到按需要设置好了所有的 cookie 或者其它 HTTP 标头。 如果 variables_order 中包括“C”，则任何从客户端发送的 cookie 都会被自动包括进 $_COOKIE 自动全局数组。如果希望对一个 cookie 变量设置多个值，则需在 cookie 的名称后加 [] 符号。 根据 register_globals 的设置，可以从 cookie 建立普通的 PHP 变量。但是不推荐依赖于此特性，因为出于安全原因此选项通常是关闭的。在早期的 PHP 版本中，当 track_vars 配置选项打开时（此选项自 PHP 4.0.3 后总是打开的），系统还会设定 $HTTP_COOKIE_VARS。 会话机制（Session）在 PHP 中用于保存并发访问中的一些数据。这使可以帮助创建更为人性化的程序，增加站点的吸引力。关于会话机制的更多信息，请参见会话处理函数一章。 设置cookiePHP设置Cookie最常用的方法就是使用setcookie函数，setcookie具有7个可选参数，我们常用到的为前5个： name（ Cookie名）可以通过$_COOKIE[&apos;name&apos;] 进行访问 value（Cookie的值） expire（过期时间）Unix时间戳格式，默认为0，表示浏览器关闭即失效 path（有效路径）如果路径设置为&apos;/&apos;，则整个网站都有效 domain（有效域）默认整个域名都有效，如果设置了&apos;www.imooc.com&apos;,则只在www子域中有效 使用案例 $value = &apos;test&apos;; setcookie(&quot;TestCookie&quot;, $value); setcookie(&quot;TestCookie&quot;, $value, time()+3600); //有效期一小时 setcookie(&quot;TestCookie&quot;, $value, time()+3600, &quot;/path/&quot;, &quot;imooc.com&quot;); //设置路径与域 PHP中还有一个设置Cookie的函数setrawcookie，setrawcookie跟setcookie基本一样，唯一的不同就是value值不会自动的进行urlencode，因此在需要的时候要手动的进行urlencode。 setrawcookie(&apos;cookie_name&apos;, rawurlencode($value), time()+60*60*24*365); 因为Cookie是通过HTTP标头进行设置的，所以也可以直接使用header方法进行设置。 header(&quot;Set-Cookie:cookie_name=value&quot;); cookie的删除与过期时间通过前面的章节，我们了解了设置cookie的函数，但是我们却发现php中没有删除Cookie的函数，在PHP中删除cookie也是采用setcookie函数来实现。 setcookie(&apos;test&apos;, &apos;&apos;, time()-1); 可以看到将cookie的过期时间设置到当前时间之前，则该cookie会自动失效，也就达到了删除cookie的目的。之所以这么设计是因为cookie是通过HTTP的标头来传递的，客户端根据服务端返回的Set-Cookie段来进行cookie的设置，如果删除cookie需要使用新的Del-Cookie来实现，则HTTP头就会变得复杂，实际上仅通过Set-Cookie就可以简单明了的实现Cookie的设置、更新与删除。 了解原理以后，我们也可以直接通过header来删除cookie。 header(&quot;Set-Cookie:test=1393832059; expires=&quot;.gmdate(&apos;D, d M Y H:i:s \G\M\T&apos;, time()-1)); 这里用到了gmdate，用来生成格林威治标准时间，以便排除时差的影响。 cookie的有效路径cookie中的路径用来控制设置的cookie在哪个路径下有效，默认为’/‘，在所有路径下都有，当设定了其他路径之后，则只在设定的路径以及子路径下有效，例如： setcookie(&apos;test&apos;, time(), 0, &apos;/path&apos;); 上面的设置会使test在/path以及子路径/path/abc下都有效，但是在根目录下就读取不到test的cookie值。 一般情况下，大多是使用所有路径的，只有在极少数有特殊需求的时候，会设置路径，这种情况下只在指定的路径中才会传递cookie值，可以节省数据的传输，增强安全性以及提高性能。 当我们设置了有效路径的时候，不在当前路径的时候则看不到当前cookie。 setcookie(&apos;test&apos;, &apos;1&apos;,0, &apos;/path&apos;); var_dump($_COOKIE[&apos;test&apos;]); session与cookie的异同cookie将数据存储在客户端，建立起用户与服务器之间的联系，通常可以解决很多问题，但是cookie仍然具有一些局限： cookie相对不是太安全，容易被盗用导致cookie欺骗 单个cookie的值最大只能存储4k 每次请求都要进行网络传输，占用带宽 session是将用户的会话数据存储在服务端，没有大小限制，通过一个session_id进行用户识别，PHP默认情况下session id是通过cookie来保存的，因此从某种程度上来说，seesion依赖于cookie。但这不是绝对的，session id也可以通过参数来实现，只要能将session id传递到服务端进行识别的机制都可以使用session。 &lt;?php //开始使用session session_start(); //设置一个session $_SESSION[&apos;test&apos;] = time(); //显示当前的session_id echo &quot;session_id:&quot;.session_id(); echo &quot;&lt;br&gt;&quot;; //读取session值 echo $_SESSION[&apos;test&apos;]; //销毁一个session unset($_SESSION[&apos;test&apos;]); echo &quot;&lt;br&gt;&quot;; var_dump($_SESSION); 使用session在PHP中使用session非常简单，先执行session_start方法开启session，然后通过全局变量$_SESSION进行session的读写。 session_start(); $_SESSION[&apos;test&apos;] = time(); var_dump($_SESSION); session会自动的对要设置的值进行encode与decode，因此session可以支持任意数据类型，包括数据与对象等。 session_start(); $_SESSION[&apos;ary&apos;] = array(&apos;name&apos; =&gt; &apos;jobs&apos;); $_SESSION[&apos;obj&apos;] = new stdClass(); var_dump($_SESSION); 默认情况下，session是以文件形式存储在服务器上的，因此当一个页面开启了session之后，会独占这个session文件，这样会导致当前用户的其他并发访问无法执行而等待。可以采用缓存或者数据库的形式存储来解决这个问题，这个我们会在一些高级的课程中讲到。 删除与销毁session删除某个session值可以使用PHP的unset函数，删除后就会从全局变量$_SESSION中去除，无法访问。 session_start(); $_SESSION[&apos;name&apos;] = &apos;jobs&apos;; unset($_SESSION[&apos;name&apos;]); echo $_SESSION[&apos;name&apos;]; //提示name不存在 如果要删除所有的session，可以使用session_destroy函数销毁当前session，session_destroy会删除所有数据，但是session_id仍然存在。 session_start(); $_SESSION[&apos;name&apos;] = &apos;jobs&apos;; $_SESSION[&apos;time&apos;] = time(); session_destroy(); 值得注意的是，session_destroy并不会立即的销毁全局变量$_SESSION中的值，只有当下次再访问的时候，$_SESSION才为空，因此如果需要立即销毁$_SESSION，可以使用unset函数。 session_start(); $_SESSION[&apos;name&apos;] = &apos;jobs&apos;; $_SESSION[&apos;time&apos;] = time(); unset($_SESSION); session_destroy(); var_dump($_SESSION); //此时已为空 如果需要同时销毁cookie中的session_id，通常在用户退出的时候可能会用到，则还需要显式的调用setcookie方法删除session_id的cookie值。 session实战-登录session可以用来存储多种类型的数据，因此具有很多的用途，常用来存储用户的登录信息，购物车数据，或者一些临时使用的暂存数据等。 用户在登录成功以后，通常可以将用户的信息存储在session中，一般的会单独的将一些重要的字段单独存储，然后所有的用户信息独立存储。 $_SESSION[&apos;uid&apos;] = $userinfo[&apos;uid&apos;]; $_SESSION[&apos;userinfo&apos;] = $userinfo; 一般来说，登录信息既可以存储在sessioin中，也可以存储在cookie中，他们之间的差别在于session可以方便的存取多种数据类型，而cookie只支持字符串类型，同时对于一些安全性比较高的数据，cookie需要进行格式化与加密存储，而session存储在服务端则安全性较高。 &lt;?php session_start(); //假设用户登录成功获得了以下用户数据 $userinfo = array( &apos;uid&apos; =&gt; 10000, &apos;name&apos; =&gt; &apos;spark&apos;, &apos;email&apos; =&gt; &apos;spark@imooc.com&apos;, &apos;sex&apos; =&gt; &apos;man&apos;, &apos;age&apos; =&gt; &apos;18&apos; ); header(&quot;content-type:text/html; charset=utf-8&quot;); /* 将用户信息保存到session中 */ $_SESSION[&apos;uid&apos;] = $userinfo[&apos;uid&apos;]; $_SESSION[&apos;name&apos;] = $userinfo[&apos;name&apos;]; $_SESSION[&apos;userinfo&apos;] = $userinfo; //* 将用户数据保存到cookie中的一个简单方法 */ $secureKey = &apos;imooc&apos;; //加密密钥 $str = serialize($userinfo); //将用户信息序列化 //用户信息加密前 $str = base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, md5($secureKey), $str, MCRYPT_MODE_ECB)); //用户信息加密后 //将加密后的用户数据存储到cookie中 setcookie(&apos;userinfo&apos;, $str); //当需要使用时进行解密 $str = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, md5($secureKey), base64_decode($str), MCRYPT_MODE_ECB); $uinfo = unserialize($str); echo &quot;解密后的用户信息：&lt;br&gt;&quot;; print_r($uinfo);]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>session和cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第十九篇——GET/POST方式总结]]></title>
    <url>%2F2018%2F12%2F12%2FPHP%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AF%87%E2%80%94%E2%80%94GET-POST%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[关于PHP开发中大部分使用的是GET和POST的方式，这是HTTP的请求方式，当然还有其他的方式，有机会可以了解一下…… GET/POST方式总结HTTP协议中共定义了八种方法或者叫“动作”来表明对Request-URI指定的资源的不同操作方式，具体介绍如下： OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送&apos;*&apos;的请求来测试服务器的功能性。 HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 GET：向特定的资源发出请求。 POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。 PUT：向指定资源位置上传其最新内容。 DELETE：请求服务器删除Request-URI所标识的资源。 TRACE：回显服务器收到的请求，主要用于测试或诊断。 CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 虽然HTTP的请求方式有8种，但是我们在实际应用中常用的也就是get和post，其他请求方式也都可以通过这两种方式间接的来实现。 这里主要说其中最重要的两种：GET 和 POST在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。 GET - 从指定的资源请求数据。 POST - 向指定的资源提交要被处理的数据 GET 方法 请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的： /test/demo_form.asp?name1=value1&amp;name2=value2 有关 GET 请求的其他一些注释： GET 请求可被缓存 GET 请求保留在浏览器历史记录中 GET 请求可被收藏为书签 GET 请求不应在处理敏感数据时使用 GET 请求有长度限制 GET 请求只应当用于取回数据 POST 方法请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的： POST /test/demo_form.asp HTTP/1.1 Host: w3schools.com name1=value1&amp;name2=value2 有关 POST 请求的其他一些注释： POST 请求不会被缓存 POST 请求不会保留在浏览器历史记录中 POST 不能被收藏为书签 POST 请求对数据长度没有要求 下面的表格比较了两种 HTTP 方法：GET 和 POST。 区别 GET POST 后退按钮/刷新 无害 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。 书签 可收藏为书签 不可收藏为书签 缓存 能被缓存 不能缓存 编码类型 application/x-www-form-urlencoded application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 历史 参数保留在浏览器历史中。 参数不会保存在浏览器历史中。 对数据长度的限制 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 无限制。 对数据类型的限制 只允许 ASCII 字符。 没有限制。也允许二进制数据。 安全性 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。 在发送密码或其他敏感信息时绝不要使用 GET ！ POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 可见性 数据在 URL 中对所有人都是可见的。 数据不会显示在 URL 中。 PHP之GET/POST方式总结（六种）方法1: 用file_get_contents 以get方式获取内容：123456&lt;?php$url='http://www.jb51.net/';$html = file_get_contents($url);echo $html;?&gt; 方法2: 用fopen打开url, 以get方式获取内容：12345678910&lt;?php$fp = fopen($url, ‘r');stream_get_meta_data($fp);while(!feof($fp)) &#123;$result .= fgets($fp, 1024);&#125;echo “url body: $result”;fclose($fp);?&gt; 方法3：用file_get_contents函数,以post方式获取url1234567891011121314151617181920&lt;?php$data = array (‘foo' =&gt; ‘bar');$data = http_build_query($data);$opts = array (‘http' =&gt; array (‘method' =&gt; ‘POST',‘header'=&gt; “Content-type: application/x-www-form-urlencodedrn” .“Content-Length: ” . strlen($data) . “rn”,‘content' =&gt; $data));$context = stream_context_create($opts);$html = file_get_contents(‘http://localhost/e/admin/test.html', false, $context);echo $html;?&gt; 方法4：用fsockopen函数打开url，以get方式获取完整的数据，包括header和body,fsockopen需要 PHP.ini 中 allow_url_fopen 选项开启1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpfunction get_url ($url,$cookie=false)&#123;$url = parse_url($url);$query = $url[path].”?”.$url[query];echo “Query:”.$query;$fp = fsockopen( $url[host], $url[port]?$url[port]:80 , $errno, $errstr, 30);if (!$fp) &#123;return false;&#125; else &#123;$request = “GET $query HTTP/1.1rn”;$request .= “Host: $url[host]rn”;$request .= “Connection: Closern”;if($cookie) $request.=”Cookie: $cookien”;$request.=”rn”;fwrite($fp,$request);while(!@feof($fp)) &#123;$result .= @fgets($fp, 1024);&#125;fclose($fp);return $result;&#125;&#125;//获取url的html部分，去掉headerfunction GetUrlHTML($url,$cookie=false)&#123;$rowdata = get_url($url,$cookie);if($rowdata)&#123;$body= stristr($rowdata,”rnrn”);$body=substr($body,4,strlen($body));return $body;&#125;return false;&#125;?&gt; 方法5：用fsockopen函数打开url，以POST方式获取完整的数据，包括header和body12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpfunction HTTP_Post($URL,$data,$cookie, $referrer=”")&#123;// parsing the given URL$URL_Info=parse_url($URL);// Building referrerif($referrer==”") // if not given use this script as referrer$referrer=”111″;// making string from $dataforeach($data as $key=&gt;$value)$values[]=”$key=”.urlencode($value);$data_string=implode(“&amp;”,$values);// Find out which port is needed – if not given use standard (=80)if(!isset($URL_Info["port"]))$URL_Info["port"]=80;// building POST-request:$request.=”POST “.$URL_Info["path"].” HTTP/1.1n”;$request.=”Host: “.$URL_Info["host"].”n”;$request.=”Referer: $referern”;$request.=”Content-type: application/x-www-form-urlencodedn”;$request.=”Content-length: “.strlen($data_string).”n”;$request.=”Connection: closen”;$request.=”Cookie: $cookien”;$request.=”n”;$request.=$data_string.”n”;$fp = fsockopen($URL_Info["host"],$URL_Info["port"]);fputs($fp, $request);while(!feof($fp)) &#123;$result .= fgets($fp, 1024);&#125;fclose($fp);return $result;&#125;?&gt; 方法6:使用curl库，使用curl库之前，可能需要查看一下php.ini是否已经打开了curl扩展123456789101112&lt;?php$ch = curl_init();$timeout = 5;curl_setopt ($ch, CURLOPT_URL, ‘http://www.jb51.net/');curl_setopt ($ch, CURLOPT_RETURNTRANSFER, 1);curl_setopt ($ch, CURLOPT_CONNECTTIMEOUT, $timeout);$file_contents = curl_exec($ch);curl_close($ch);echo $file_contents;?&gt;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>GET/POST方式总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第十八篇——CURL初探]]></title>
    <url>%2F2018%2F12%2F12%2FPHP%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AF%87%E2%80%94%E2%80%94CURL%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[cURL 是一个利用URL语法规定来传输文件和数据的工具，支持很多协议，如HTTP、FTP、TELNET等。最爽的是，PHP也支持 cURL 库。本文将介绍 cURL 的一些高级特性，以及在PHP中如何运用它…… CURL初探1.cURL介绍 cURL 是一个利用URL语法规定来传输文件和数据的工具，支持很多协议，如HTTP、FTP、TELNET等。最爽的是，PHP也支持 cURL 库。本文将介绍 cURL 的一些高级特性，以及在PHP中如何运用它。 2.基本结构在学习更为复杂的功能之前，先来看一下在PHP中建立cURL请求的基本步骤： （1）初始化 curl_init() （2）设置变量 curl_setopt() 。最为重要，一切玄妙均在此。有一长串cURL参数可供设置，它们能指定URL请求的各个细节。要一次性全部看完并理解可能比较困难，所以今天我们只试一下那些更常用也更有用的选项。 （3）执行并获取结果 curl_exec() （4）释放cURL句柄 curl_close() 3.cURL实现Get和Post3.1 Get方式实现 //初始化 $ch = curl_init(); //设置选项，包括URL curl_setopt($ch, CURLOPT_URL, &quot;http://www.jb51.net&quot;); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, 0); //执行并获取HTML文档内容 $output = curl_exec($ch); //释放curl句柄 curl_close($ch); //打印获得的数据 print_r($output); 3.2 Post方式实现 $url = &quot;http://localhost/web_services.php&quot;; $post_data = array (&quot;username&quot; =&gt; &quot;bob&quot;,&quot;key&quot; =&gt; &quot;12345&quot;); $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); // post数据 curl_setopt($ch, CURLOPT_POST, 1); // post的变量 curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data); $output = curl_exec($ch); curl_close($ch); //打印获得的数据 print_r($output); 以上方式获取到的数据是json格式的，使用json_decode函数解释成数组。 $output_array = json_decode($output,true); 如果使用json_decode($output)解析的话，将会得到object类型的数据。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>CURL初探</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第十七篇——分页与实现]]></title>
    <url>%2F2018%2F12%2F10%2FPHP%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AF%87%E2%80%94%E2%80%94%E5%88%86%E9%A1%B5%E4%B8%8E%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[经常在网上看到分页的出现，最近没事。看看公司的后台代码，对这个小模块进行封装。制作成一个函数。现在将自己的这个思考过程，写下来。 分页与实现逻辑准备 实现分页，我们需要获取准备以下属性和方法 属性{ 数据总条数 每一页显示的条数 计算出总页数 获取当前是第几页 显示上一页 显示下一页 显示首页 显示尾页 每一页的url 数据限制limit } 方法{ 构造函数 计算总页数 获取当前页 获取上一页 获取下一页 获取首页 获取尾页 获取当前页面url 获取上一页url 获取下一页url 获取首页url 获取尾页irl 生成limit记录 重新生成url地址 显示分页链接，显示分页情况 } 根据上面的逻辑，下一步将文字转换为代码 首先，我们先声明一个Page类，按照逻辑进行属性声明,并且进行初始化 class Page { //记录总条数 protected $total; //每页显示几条 protected $nums; //总页数 protected $totalPages; //当前页码 protected $currentPage; //上一页页码 protected $prevPage; //下一页页码 protected $nextPage; //首页页码 protected $firstPage; //尾页页码 protected $endPage; //url protected $url; //limit,传到数据库的limit protected $limit; //构造函数，初始化 public function __construct($total, $nums) { $this-&gt;total = $total; $this-&gt;nums = $nums; $this-&gt;totalPages = $this-&gt;getTotalPages(); $this-&gt;currentPage = $this-&gt;getCurrentPage(); $this-&gt;getPrevPage(); $this-&gt;getNextPage(); $this-&gt;getFirstPage(); $this-&gt;getEndPage(); $this-&gt;getUrl(); } } 接下来我们开始完善方法 计算总页数 protected funciton getTotalPages() { return ceil($this-&gt;total / $this-&gt;$nums); } 获取当前页码 protected function getCurentPage() { //判断如果存在page参数并且page大于0，返回实际值，否则返回1 if(isset($_GET[&apos;page&apos;]) &amp;&amp; intval($_GET[&apos;page&apos;]) &gt; 0) { $this-&gt;currentPage = intval($_GET[&apos;page&apos;]); } else { $this-&gt;currentPage = 1; } return $this-&gt;currentPage; } 获取上一页 protected function getPrevPage() { $this-&gt;prevPage = $this-&gt;currentPage - 1; if($this-&gt;prevPage &lt; １) { $this-&gt;prevPage = 1; } return $this-&gt;prevPage; } 获取下一页 protected function getNextPage() { $this-&gt;nextPage = $this-&gt;currentPage + 1; return $this-&gt;nextPage; } 获取首页 protected function getFirstPage() { $this-&gt;firstPage = 1; return $this-&gt;firstPage; } 获取尾页 protected function getEndPage() { $this-&gt;endPage = $this-&gt;totalPages; return $this-&gt;endPage; } 接下来开始拼接每个页码的url 获取当前页的url protected function getCurrentUrl() { return $this-&gt;url.&apos;$page=&apos;.$this-&gt;currentPage; } 获取前一页的url protected function getPrevUrl() { return $this-&gt;url.&apos;&amp;page=&apos;.$this-&gt;prevPage; } 获取下一页的url protected function getNextUrl() { return $this-&gt;url.&apos;&amp;page=&apos;.$this-&gt;nextPage; } 获取首页的url protected function getFirstUrl() { return $this-&gt;url.&apos;&amp;page=&apos;.$this-&gt;firstPage; } 获取尾页的url protected function getEndUrl() { return $this-&gt;url.&apos;&amp;page=&apos;.$this-&gt;endPage; } 生成limit记录 public function limit() { return ($this-&gt;currentPage - 1) * $this-&gt;nums.&apos;,&apos;.$this-&gt;nums; } 生成url地址 public function getUrl() { //获取当前页面的文件位置 $url = $_SERVER[&apos;REQUEST_URI&apos;]; //将url参数解析成数组 $parse = parse_url($url); //获得域名地址 $path = $parse[&apos;path&apos;]; //获取参数 $query = isset($parse[&apos;query&apos;]) ? $parse[&apos;query&apos;] : false; //如果有参数，把page这个参数先给干掉，因为我们要重新拼接 if($query) { parse_str($query,$query); //干掉page参数，保留其他参数 unset($query[&apos;page&apos;]); //http_build_query拼将参数拼接成请求 $uri = $parse[&apos;path&apos;].&apos;?&apos;.http_build_query($query); } else { $uri = rtrim($parse[&apos;path&apos;],&apos;?&apos;).&apos;?&apos;; } //智能识别https和http协议和端口号 $protocal = (isset($_SERVER[&apos;SERVER_PORT&apos;]) &amp;&amp; $_SERVER[&apos;SERVER_PORT&apos;] == 443) ? &apos;https://&apos; : &apos;http://&apos;; switch ($_SERVER[&apos;SERVER_PORT&apos;]) { case 80: case 443: $uri = $protocal.$_SERVER[&apos;SERVER_NAME&apos;].$uri; break; default: $uri = $protocal.$_SERVER[&apos;SERVER_NAME&apos;].&apos;:&apos;.$_SERVER[&apos;SERVER_PORT&apos;].$uri; break; } $this-&gt;url = $uri; } 到此所有的逻辑方面都已经处理完啦，接下来的render()函数用来显示分页的链接 public function render() { return array( [&apos;first&apos; =&gt; $this-&gt;getFirstUrl()], [&apos;prev&apos; =&gt; $this-&gt;getPrevUrl()], [&apos;current&apos; =&gt; $this-&gt;getCurrentUrl()], [&apos;next&apos; =&gt; $this-&gt;getNextUrl()], [&apos;end&apos; =&gt; $this-&gt;getEndUrl()] ); } 哦也，就这么愉快的结束啦, 使用方法如下 //new一个对象 $page = new Page(102,10); //打印出来上页/下页/首页/尾页……的url var_dump($page-&gt;render()); 后记 $url = http://www.zhyunfe.com/OOP/Page.class.php?page=1 parse_url($url):将url的文件路径和参数分开并保存到数组中 .......................................... . array (size=2) . &apos;path&apos; =&gt; string &apos;/OOP/Page.class.php&apos; (length=36) . &apos;query&apos; =&gt; string &apos;page=1&apos; (length=6) .......................................... ... $query = &quot;page=1&amp;num=2&amp;sex=男&quot; parse_str($query,$query):将带参数的字符串解析成数组 .......................................... . array . &apos;page&apos; =&gt; 1 . &apos;num&apos; =&gt; 2 . &apos;sex&apos; =&gt; &apos;男&apos; .......................................... ... $query = [&apos;num&apos;=&gt;1,&apos;sex&apos;=&gt;&apos;男&apos;] http_build_query($query):使用给出的关联（或下标）数组生成一个经过 URL-encode 的请求字符串。 ......................................... . string . &quot;num=1&amp;&amp;sex=&apos;男&apos;&quot; ......................................... ... $_SERVER[&apos;SERVER_PORT&apos;] 获取端口号 $_SERVER[&apos;SERVER_NAME&apos;] 当前运行脚本所在的服务器的主机名。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>分页与实现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第十六篇——正则表达式]]></title>
    <url>%2F2018%2F12%2F09%2FPHP%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AF%87%E2%80%94%E2%80%94%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[也许你之前听过，也许你之前用过，当然或许你之前没有听过或者没有接触过，说实话，做了这么久iOS开发，我也就用过两次，不知道是个人原因还是什么，但是其实正则表达式是几乎所有编程里面都有的，如果真的要说，估计要几个月，而且还说不完….. 字符串操作首先，如果你对正则感兴趣，我相信下面比较适合你的需求，不管是不是开始PHP开发，其他都是一样的，只是结合具体语言和语法实现想要的功能。 正则表达式30分钟入门教程 什么是正则表达式正则表达式是对字符串进行操作的一种逻辑公式，就是用一些特定的字符组合成一个规则字符串，称之为正则匹配模式。 $p = &apos;/apple/&apos;; $str = &quot;apple banna&quot;; if (preg_match($p, $str)) { echo &apos;matched&apos;; } 其中字符串’/apple/‘就是一个正则表达式，他用来匹配源字符串中是否存在apple字符串。 PHP中使用PCRE库函数进行正则匹配，比如上例中的preg_match用于执行一个正则匹配，常用来判断一类字符模式是否存在。 正则表达式基本语法PCRE库函数中，正则匹配模式使用分隔符与元字符组成，分隔符可以是非数字、非反斜线、非空格的任意字符。经常使用的分隔符是正斜线(/)、hash符号(#) 以及取反符号(~)，例如： /foo bar/ #^[^0-9]$# ~php~ 如果模式中包含分隔符，则分隔符需要使用反斜杠（\）进行转义。 /http:\/\// 如果模式中包含较多的分割字符，建议更换其他的字符作为分隔符，也可以采用preg_quote进行转义。 $p = &apos;http://&apos;; $p = &apos;/&apos;.preg_quote($p, &apos;/&apos;).&apos;/&apos;; echo $p; 分隔符后面可以使用模式修饰符，模式修饰符包括：i, m, s, x等，例如使用i修饰符可以忽略大小写匹配： $str = &quot;Http://www.imooc.com/&quot;; if (preg_match(&apos;/http/i&apos;, $str)) { echo &apos;匹配成功&apos;; } 元字符与转义正则表达式中具有特殊含义的字符称之为元字符，常用的元字符有： \ 一般用于转义字符 ^ 断言目标的开始位置(或在多行模式下是行首) $ 断言目标的结束位置(或在多行模式下是行尾) . 匹配除换行符外的任何字符(默认) [ 开始字符类定义 ] 结束字符类定义 | 开始一个可选分支 ( 子组的开始标记 ) 子组的结束标记 ? 作为量词，表示 0 次或 1 次匹配。位于量词后面用于改变量词的贪婪特性。 (查阅量词) * 量词，0 次或多次匹配 + 量词，1 次或多次匹配 { 自定义量词开始标记 } 自定义量词结束标记 使用案例 //下面的\s匹配任意的空白符，包括空格，制表符，换行符。[^\s]代表非空白符。[^\s]+表示一次或多次匹配非空白符。 $p = &apos;/^我[^\s]+(苹果|香蕉)$/&apos;; $str = &quot;我喜欢吃苹果&quot;; if (preg_match($p, $str)) { echo &apos;匹配成功&apos;; } 元字符具有两种使用场景，一种是可以在任何地方都能使用，另一种是只能在方括号内使用，在方括号内使用的有： \ 转义字符 ^ 仅在作为第一个字符(方括号内)时，表明字符类取反 - 标记字符范围 其中^在反括号外面，表示断言目标的开始位置，但在方括号内部则代表字符类取反，方括号内的减号-可以标记字符范围，例如0-9表示0到9之间的所有数字。 //下面的\w匹配字母或数字或下划线。 $p = &apos;/[\w\.\-]+@[a-z0-9\-]+\.(com|cn)/&apos;; $str = &quot;我的邮箱是Spark.eric@imooc.com&quot;; preg_match($p, $str, $match); echo $match[0]; 两种常见模式：贪婪与懒惰正则表达式中每个元字符匹配一个字符，当使用+之后将会变的贪婪，它将匹配尽可能多的字符，但使用问号?字符时，它将尽可能少的匹配字符，既是懒惰模式。 贪婪模式：在可匹配与可不匹配的时候，优先匹配 //下面的\d表示匹配数字 $p = &apos;/\d+\-\d+/&apos;; $str = &quot;我的电话是010-12345678&quot;; preg_match($p, $str, $match); echo $match[0]; //结果为：010-12345678 懒惰模式：在可匹配与可不匹配的时候，优先不匹配 $p = &apos;/\d?\-\d?/&apos;; $str = &quot;我的电话是010-12345678&quot;; preg_match($p, $str, $match); echo $match[0]; //结果为：0-1 当我们确切的知道所匹配的字符长度的时候，可以使用{}指定匹配字符数 $p = &apos;/\d{3}\-\d{8}/&apos;; $str = &quot;我的电话是010-12345678&quot;; preg_match($p, $str, $match); echo $match[0]; //结果为：010-12345678 正则匹配使用正则表达式的目的是为了实现比字符串处理函数更加灵活的处理方式，因此跟字符串处理函数一样，其主要用来判断子字符串是否存在、字符串替换、分割字符串、获取模式子串等。 PHP使用PCRE库函数来进行正则处理，通过设定好模式，然后调用相关的处理函数来取得匹配结果。 preg_match用来执行一个匹配，可以简单的用来判断模式是否匹配成功，或者取得一个匹配结果，他的返回值是匹配成功的次数0或者1，在匹配到1次以后就会停止搜索。 $subject = &quot;abcdef&quot;; $pattern = &apos;/def/&apos;; preg_match($pattern, $subject, $matches); print_r($matches); //结果为：Array ( [0] =&gt; def ) 上面的代码简单的执行了一个匹配，简单的判断def是否能匹配成功，但是正则表达式的强大的地方是进行模式匹配，因此更多的时候，会使用模式： $subject = &quot;abcdef&quot;; $pattern = &apos;/a(.*?)d/&apos;; preg_match($pattern, $subject, $matches); print_r($matches); //结果为：Array ( [0] =&gt; abcd [1] =&gt; bc ) 通过正则表达式可以匹配一个模式，得到更多的有用的数据。 查找匹配结果preg_match只能匹配一次结果，但很多时候我们需要匹配所有的结果，preg_match_all可以循环获取一个列表的匹配结果数组。 $p = &quot;|&lt;[^&gt;]+&gt;(.*?)&lt;/[^&gt;]+&gt;|i&quot;; $str = &quot;&lt;b&gt;example: &lt;/b&gt;&lt;div align=left&gt;this is a test&lt;/div&gt;&quot;; preg_match_all($p, $str, $matches); print_r($matches); 可以使用preg_match_all匹配一个表格中的数据： $p = &quot;/&lt;tr&gt;&lt;td&gt;(.*?)&lt;\/td&gt;\s*&lt;td&gt;(.*?)&lt;\/td&gt;\s*&lt;\/tr&gt;/i&quot;; $str = &quot;&lt;table&gt; &lt;tr&gt;&lt;td&gt;Eric&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;John&lt;/td&gt;&lt;td&gt;26&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt;&quot;; preg_match_all($p, $str, $matches); print_r($matches); $matches结果排序为$matches[0]保存完整模式的所有匹配, $matches[1] 保存第一个子组的所有匹配，以此类推 正则搜索与替换正则表达式的搜索与替换在某些方面具有重要用途，比如调整目标字符串的格式，改变目标字符串中匹配字符串的顺序等。 例如我们可以简单的调整字符串的日期格式： $string = &apos;April 15, 2014&apos;; $pattern = &apos;/(\w+) (\d+), (\d+)/i&apos;; $replacement = &apos;$3, ${1} $2&apos;; echo preg_replace($pattern, $replacement, $string); //结果为：2014, April 15 其中${1}与$1的写法是等效的，表示第一个匹配的字串，$2代表第二个匹配的。 通过复杂的模式，我们可以更加精确的替换目标字符串的内容。 $patterns = array (&apos;/(19|20)(\d{2})-(\d{1,2})-(\d{1,2})/&apos;, &apos;/^\s*{(\w+)}\s*=/&apos;); $replace = array (&apos;\3/\4/\1\2&apos;, &apos;$\1 =&apos;);//\3等效于$3,\4等效于$4，依次类推 echo preg_replace($patterns, $replace, &apos;{startDate} = 1999-5-27&apos;); //结果为：$startDate = 5/27/1999 //详细解释下结果：(19|20)表示取19或者20中任意一个数字，(\d{2})表示两个数字，(\d{1,2})表示1个或2个数字，(\d{1,2})表示1个或2个数字。^\s*{(\w+)\s*=}表示以任意空格开头的，并且包含在{}中的字符，并且以任意空格结尾的，最后有个=号的。 用正则替换来去掉多余的空格与字符： $str = &apos;one two&apos;; $str = preg_replace(&apos;/\s+/&apos;, &apos; &apos;, $str); echo $str; // 结果改变为&apos;one two&apos; 常见案例正则匹配常用在表单验证上，一些字段会有一定的格式要求，比如用户名一般都要求必须是字母、数字或下划线组成，邮箱、电话等也都有自己的规则，因此使用正则表达式可以很好的对这些字段进行验证。 &lt;?php $user = array( &apos;name&apos; =&gt; &apos;spark1985&apos;, &apos;email&apos; =&gt; &apos;spark@imooc.com&apos;, &apos;mobile&apos; =&gt; &apos;13312345678&apos; ); //进行一般性验证 if (empty($user)) { die(&apos;用户信息不能为空&apos;); } if (strlen($user[&apos;name&apos;]) &lt; 6) { die(&apos;用户名长度最少为6位&apos;); } //用户名必须为字母、数字与下划线 if (!preg_match(&apos;/^\w+$/i&apos;, $user[&apos;name&apos;])) { die(&apos;用户名不合法&apos;); } //验证邮箱格式是否正确 if (!preg_match(&apos;/^[\w\.]+@\w+\.\w+$/i&apos;, $user[&apos;email&apos;])) { die(&apos;邮箱不合法&apos;); } //手机号必须为11位数字，且为1开头 if (!preg_match(&apos;/^1\d{10}$/i&apos;, $user[&apos;mobile&apos;])) { die(&apos;手机号不合法&apos;); } echo &apos;用户信息验证成功&apos;;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第十五篇——异常处理]]></title>
    <url>%2F2018%2F12%2F09%2FPHP%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AF%87%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[关于异常处理和了解，我相信是任何一门语言或者做任何开发的程序员都应该知道的东西，如果你没用过可以理解，但是如果你说没有听过，那么对不起，请绕道…… 异常处理抛出一个异常从PHP5开始，PHP支持异常处理，异常处理是面向对象一个重要特性，PHP代码中的异常通过throw抛出，异常抛出之后，后面的代码将不会再被执行。 既然抛出异常会中断程序执行，那么为什么还需要使用异常处理？ 异常抛出被用于在遇到未知错误，或者不符合预先设定的条件时，通知客户程序，以便进行其他相关处理，不至于使程序直接报错中断。 当代码中使用了try catch的时候，抛出的异常会在catch中捕获，否则会直接中断。 基本语法try{ //可能出现错误或异常的代码 //catch表示捕获，Exception是php已定义好的异常类 } catch(Exception $e){ //对异常处理，方法： //1、自己处理 //2、不处理，将其再次抛出 } 处理处理程序应当包括：Try - 使用异常的函数应该位于 “try” 代码块内。如果没有触发异常，则代码将照常继续执行。但是如果异常被触发，会抛出一个异常。Throw - 这里规定如何触发异常。注意：每一个 “throw” 必须对应至少一个 “catch”，当然可以对应多个”catch”Catch - “catch” 代码块会捕获异常，并创建一个包含异常信息的对象。 //创建可抛出一个异常的函数 function checkNum($number){ if($number&gt;1){ throw new Exception(&quot;异常提示-数字必须小于等于1&quot;); } return true; } //在 &quot;try&quot; 代码块中触发异常 try{ checkNum(2); //如果异常被抛出，那么下面一行代码将不会被输出 echo &apos;如果能看到这个提示，说明你的数字小于等于1&apos;; }catch(Exception $e){ //捕获异常 echo &apos;捕获异常: &apos; .$e-&gt;getMessage(); } 上面代码将获得类似这样一个错误： 捕获异常:: 异常提示-数字必须小于等于1 例子解释： 上面的代码抛出了一个异常，并捕获了它： 创建 checkNum() 函数。它检测数字是否大于 1。如果是，则抛出一个异常。 在 &quot;try&quot; 代码块中调用 checkNum() 函数。 checkNum() 函数中的异常被抛出 &quot;catch&quot; 代码块接收到该异常，并创建一个包含异常信息的对象 ($e)。 通过从这个 exception 对象调用 $e-&gt;getMessage()，输出来自该异常的错误消息 异常类与异常处理PHP具有很多异常处理类，其中Exception是所有异常处理的基类。 Exception具有几个基本属性与方法，其中包括了： message 异常消息内容 code 异常代码 file 抛出异常的文件名 line 抛出异常在该文件的行数 其中常用的方法有： getTrace 获取异常追踪信息 getTraceAsString 获取异常追踪信息的字符串 getMessage 获取出错信息 如果必要的话，可以通过继承Exception类来建立自定义的异常处理类。 //自定义的异常类，继承了PHP的异常基类Exception class MyException extends Exception { function getInfo() { return &apos;自定义错误信息&apos;; } } try { //使用异常的函数应该位于 &quot;try&quot; 代码块内。如果没有触发异常，则代码将照常继续执行。但是如果异常被触发，会抛出一个异常。 throw new MyException(&apos;error&apos;);//这里规定如何触发异常。注意：每一个 &quot;throw&quot; 必须对应至少一个 &quot;catch&quot;，当然可以对应多个&quot;catch&quot; } catch(Exception $e) {//&quot;catch&quot; 代码块会捕获异常，并创建一个包含异常信息的对象 echo $e-&gt;getInfo();//获取自定义的异常信息 echo $e-&gt;getMessage();//获取继承自基类的getMessage信息 } 捕捉异常信息在了解了异常处理的基本原理之后，我们可以通过try catch来捕获异常，我们将执行的代码放在try代码块中，一旦其中的代码抛出异常，就能在catch中捕获。 这里我们只是通过案例来了解try catch的机制以及异常捕获的方法，在实际应用中，不会轻易的抛出异常，只有在极端情况或者非常重要的情况下，才会抛出异常，抛出异常，可以保障程序的正确性与安全，避免导致不可预知的bug。 一般的异常处理流程代码为： try { throw new Exception(&apos;wrong&apos;); } catch(Exception $ex) { echo &apos;Error:&apos;.$ex-&gt;getMessage().&apos;&lt;br&gt;&apos;; echo $ex-&gt;getTraceAsString().&apos;&lt;br&gt;&apos;; } echo &apos;异常处理后，继续执行其他代码&apos;; 获取错误发生所在位置在异常被捕获之后，我们可以通过异常处理对象获取其中的异常信息，前面我们已经了解捕获方式，以及获取基本的错误信息。 在实际应用中，我们通常会获取足够多的异常信息，然后写入到错误日志中。 通过我们需要将报错的文件名、行号、错误信息、异常追踪信息等记录到日志中，以便调试与修复问题 &lt;?php try { throw new Exception(&apos;wrong&apos;); } catch(Exception $ex) { $msg = &apos;Error:&apos;.$ex-&gt;getMessage().&quot;\n&quot;; $msg.= $ex-&gt;getTraceAsString().&quot;\n&quot;; $msg.= &apos;异常行号：&apos;.$ex-&gt;getLine().&quot;\n&quot;; $msg.= &apos;所在文件：&apos;.$ex-&gt;getFile().&quot;\n&quot;; //将异常信息记录到日志中 PHP异常处理之 file_put_contents(&apos;error.log&apos;, $msg); }]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第十四篇——图像与图像操作]]></title>
    <url>%2F2018%2F12%2F07%2FPHP%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AF%87%E2%80%94%E2%80%94%E5%9B%BE%E5%83%8F%E4%B8%8E%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[PHP关于图像处理其实还是挺重要的，只是如果你只是做API开发的话，其实根本用不到，但是做Web的话可算是一个比较重要的技术，既然看到这里我们就简单了解一下…… 图像与图像操作GD库简介GD指的是Graphic Device，PHP的GD库是用来处理图形的扩展库，通过GD库提供的一系列API，可以对图像进行处理或者直接生成新的图片。 PHP除了能进行文本处理以外，通过GD库，可以对JPG、PNG、GIF、SWF等图片进行处理。GD库常用在图片加水印，验证码生成等方面。 PHP默认已经集成了GD库，只需要在安装的时候开启就行。 header(&quot;content-type: image/png&quot;); $img=imagecreatetruecolor(100, 100); $red=imagecolorallocate($img, 0xFF, 0x00, 0x00); imagefill($img, 0, 0, $red); imagepng($img); imagedestroy($img); 绘制线条要对图形进行操作，首先要新建一个画布，通过imagecreatetruecolor函数可以创建一个真彩色的空白图片： $img = imagecreatetruecolor(100, 100); GD库中对于画笔所用的颜色，需要通过imagecolorallocate函数进行分配，通过参数设定RGB的颜色值来确定画笔的颜色： $red = imagecolorallocate($img, 0xFF, 0x00, 0x00); 然后我们通过调用绘制线段函数imageline进行线条的绘制，通过指定起点跟终点来最终得到线条。 imageline($img, 0, 0, 100, 100, $red); 线条绘制好以后，通过header与imagepng进行图像的输出。 header(&quot;content-type: image/png&quot;); imagepng($img); 最后可以调用imagedestroy释放该图片占用的内存。 imagedestroy($img); 通过上面的步骤，可以发现PHP绘制图形非常的简单，但很多时候我们不只是需要输出图片，可能我们还需要得到一个图片文件，可以通过imagepng函数指定文件名将绘制后的图像保存到文件中。 imagepng($img, &apos;img.png&apos;); 绘制文字GD库可以进行多种图形的基本操作，常用的有绘制线条，背景填充，画矩形，绘制文字等。 跟绘制线条类似，首先需要新建一个图片与初始化颜色。 $img = imagecreatetruecolor(100, 100); $red = imagecolorallocate($img, 0xFF, 0x00, 0x00); 然后使用imagestring函数来进行文字的绘制，这个函数的参数很多：imagestring ( resource $image , int $font , int $x , int $y , string $s , int $col )，可以通过$font来设置字体的大小，x,y设置文字显示的位置，$s是要绘制的文字,$col是文字的颜色。 imagestring($img, 5, 0, 0, &quot;Hello world&quot;, $red); header(&quot;content-type: image/png&quot;); imagepng($img); imagedestroy($img); 输出图形文件前面我们已经了解到，通过imagepng可以直接输出图像到浏览器，但是很多时候，我们希望将处理好的图像保存到文件，以便可以多次使用。通过指定路径参数将图像保存到文件中。 $filename = &apos;img.png&apos;; imagepng($img, $filename); 使用imagepng可以将图像保存成png格式，如果要保存成其他格式需要使用不同的函数，使用imagejpeg将图片保存成jpeg格式，imagegif将图片保存成gif格式，需要说明的是，imagejpeg会对图片进行压缩，因此还可以设置一个质量参数。 $filename = &apos;img.jpg&apos;; ​imagejpeg($img, $filename, 80); 生成图形验证码简单的验证码其实就是在图片中输出了几个字符，通过我们前面章节讲到的imagestring函数就能实现。 但是在处理上，为了使验证码更加的安全，防止其他程序自动识别，因此常常需要对验证码进行一些干扰处理，通常会采用绘制一些噪点，干扰线段，对输出的字符进行倾斜、扭曲等操作。 可以使用imagesetpixel绘制点来实现噪点干扰，但是只绘制一个点的作用不大，因此这里常常会使用循环进行随机绘制。 for($i=0;$i&lt;50;$i++) { imagesetpixel($im, rand(0, 100) , rand(0, 100) , $black); imagesetpixel($im, rand(0, 100) , rand(0, 100) , $green); } 实例 &lt;?php $img = imagecreatetruecolor(100, 40); $black = imagecolorallocate($img, 0x00, 0x00, 0x00); $green = imagecolorallocate($img, 0x00, 0xFF, 0x00); $white = imagecolorallocate($img, 0xFF, 0xFF, 0xFF); imagefill($img,0,0,$white); //生成随机的验证码 $code = &apos;&apos;; for($i = 0; $i &lt; 4; $i++) { $code .= rand(0, 9); } imagestring($img, 5, 10, 10, $code, $black); //加入噪点干扰 for($i=0;$i&lt;50;$i++) { imagesetpixel($img, rand(0, 100) , rand(0, 100) , $black); imagesetpixel($img, rand(0, 100) , rand(0, 100) , $green); } //输出验证码 header(&quot;content-type: image/png&quot;); imagepng($img); imagedestroy($img); 加水印给图片添加水印的方法一般有两种，一种是在图片上面加上一个字符串，另一种是在图片上加上一个logo或者其他的图片。 因为这里处理的是已经存在的图片，所以可以直接从已存在的图片建立画布，通过imagecreatefromjpeg可以直接从图片文件创建图像。 $im = imagecreatefromjpeg($filename); 创建图像对象以后，我们就可以通过前面的GD函数，绘制字符串到图像上。如果要加的水印是一个logo图片，那么就需要再建立一个图像对象，然后通过GD函数imagecopy将logo的图像复制到源图像中。 $logo = imagecreatefrompng($filename); imagecopy($im, $logo, 15, 15, 0, 0, $width, $height); 当将logo图片复制到原图片上以后，将加水印后的图片输出保存就完成了加水印处理。 imagejpeg($im, $filename); 使用案例 &lt;?php //这里仅仅是为了案例需要准备一些素材图片 $url = &apos;http://www.iyi8.com/uploadfile/2014/0521/20140521105216901.jpg&apos;; $content = file_get_contents($url); $filename = &apos;tmp.jpg&apos;; file_put_contents($filename, $content); $url = &apos;http://wiki.ubuntu.org.cn/images/3/3b/Qref_Edubuntu_Logo.png&apos;; file_put_contents(&apos;logo.png&apos;, file_get_contents($url)); //开始添加水印操作 $im = imagecreatefromjpeg($filename); $logo = imagecreatefrompng(&apos;logo.png&apos;); $size = getimagesize(&apos;logo.png&apos;); imagecopy($im, $logo, 15, 15, 0, 0, $size[0], $size[1]); header(&quot;content-type: image/jpeg&quot;); imagejpeg($im);]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>图像与图像操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第十三篇——文件处理]]></title>
    <url>%2F2018%2F12%2F06%2FPHP%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AF%87%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[文件处理在PHP开发中也是比较常见的，或者你使用的是缓存，但是毕竟根据需求总有用到文件的地方，所以….. 文件处理读取文件内容PHP具有丰富的文件操作函数，最简单的读取文件的函数为file_get_contents，可以将整个文件全部读取到一个字符串中。 $content = file_get_contents(&apos;./test.txt&apos;); file_get_contents也可以通过参数控制读取内容的开始点以及长度。 $content = file_get_contents(&apos;./test.txt&apos;, null, null, 100, 500); PHP也提供类似于C语言操作文件的方法，使用fopen，fgets，fread等方法，fgets可以从文件指针中读取一行，freads可以读取指定长度的字符串。 $fp = fopen(&apos;./text.txt&apos;, &apos;rb&apos;); while(!feof($fp)) { echo fgets($fp); //读取一行 } fclose($fp); $fp = fopen(&apos;./text.txt&apos;, &apos;rb&apos;); $contents = &apos;&apos;; while(!feof($fp)) { $contents .= fread($fp, 4096); //一次读取4096个字符 } fclose($fp); 使用fopen打开的文件，最好使用fclose关闭文件指针，以避免文件句柄被占用。 判断文件是否存在一般情况下在对文件进行操作的时候需要先判断文件是否存在，PHP中常用来判断文件存在的函数有两个is_file与file_exists. $filename = &apos;./test.txt&apos;; if (file_exists($filename)) { echo file_get_contents($filename); } 如果只是判断文件存在，使用file_exists就行，file_exists不仅可以判断文件是否存在，同时也可以判断目录是否存在，从函数名可以看出，is_file是确切的判断给定的路径是否是一个文件。 $filename = &apos;./test.txt&apos;; if (is_file($filename)) { echo file_get_contents($filename); } 更加精确的可以使用is_readable与is_writeable在文件是否存在的基础上，判断文件是否可读与可写。 $filename = &apos;./test.txt&apos;; if (is_writeable($filename)) { file_put_contents($filename, &apos;test&apos;); } if (is_readable($filename)) { echo file_get_contents($filename); } 获取修改时间文件有很多元属性，包括：文件的所有者、创建时间、修改时间、最后的访问时间等。 fileowner：获得文件的所有者 filectime：获取文件的创建时间 filemtime：获取文件的修改时间 fileatime：获取文件的访问时间 其中最常用的是文件的修改时间，通过文件的修改时间，可以判断文件的时效性，经常用在静态文件或者缓存数据的更新。 $mtime = filemtime($filename); echo &apos;修改时间：&apos;.date(&apos;Y-m-d H:i:s&apos;, filemtime($filename)); 使用案例 &lt;?php $filename = &apos;/data/webroot/usercode/code/resource/test.txt&apos;; echo &apos;所有者：&apos;.fileowner($filename).&apos;&lt;br&gt;&apos;; echo &apos;创建时间：&apos;.filectime($filename).&apos;&lt;br&gt;&apos;; echo &apos;修改时间：&apos;.filemtime($filename).&apos;&lt;br&gt;&apos;; echo &apos;最后访问时间：&apos;.fileatime($filename).&apos;&lt;br&gt;&apos;; //给$mtime赋值为文件的修改时间 $mtime = time(); //通过计算时间差 来判断文件内容是否有效 if (time() - $mtime &gt; 3600) { echo &apos;&lt;br&gt;缓存已过期&apos;; } else { echo file_get_contents($filename); } 获取文件大小通过filesize函数可以取得文件的大小，文件大小是以字节数表示的。 $filename = &apos;/data/webroot/usercode/resource/test.txt&apos;; $size = filesize($filename); 如果要转换文件大小的单位，可以自己定义函数来实现。 function getsize($size, $format = &apos;kb&apos;) { $p = 0; if ($format == &apos;kb&apos;) { $p = 1; } elseif ($format == &apos;mb&apos;) { $p = 2; } elseif ($format == &apos;gb&apos;) { $p = 3; } $size /= pow(1024, $p); return number_format($size, 3); } $filename = &apos;/data/webroot/usercode/code/resource/test.txt&apos;; $size = filesize($filename); $size = getsize($size, &apos;kb&apos;); //进行单位转换 echo $size.&apos;kb&apos;; 值得注意的是，没法通过简单的函数来取得目录的大小，目录的大小是该目录下所有子目录以及文件大小的总和，因此需要通过递归的方法来循环计算目录的大小。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>文件处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第十二篇——时间与日期处理]]></title>
    <url>%2F2018%2F12%2F06%2FPHP%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AF%87%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E4%B8%8E%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[关于时间与日期的处理，根据这么多年iOS开发的经验，我觉得在PHP中可以说是无处不在，只是可能如果你做的比较好的话，处理一次或者抽好了就可以通用…… 时间与日期处理首先我们需要知道PHP中关于时间的处理时间戳应该算是最好的方案，一个字：快！ 获取当前时间戳UNIX 时间戳（英文叫做：timestamp）是 PHP 中关于时间与日期的一个很重要的概念，它表示从 1970年1月1日 00:00:00 到当前时间的秒数之和。 PHP提供了内置函数 time() 来取得服务器当前时间的时间戳。那么获取当前的UNIX时间戳就很简单了。 $time = time(); echo $time;//1396193923，这个数字表示从1970年1月1日 00:00:00 到我输出这个脚本时经历了1396193923秒 获取当前日期php内置了date()函数，来取得当前的日期。 函数说明：date(时间戳的格式, 规定时间戳【默认是当前的日期和时间，可选】) 返回值：函数日期和时间 例子： //date函数，第二个参数取默认值的情况 echo date(&quot;Y-m-d&quot;);//2014-03-30 //date函数，第二个参数有值的情况 echo date(&quot;Y-m-d&quot;,&apos;1396193923&apos;);//2014-03-30,1396193923表示2014-03-30的unix时间戳 获取日期对应的时间戳UNIX 时间戳（英文叫做：timestamp）是 PHP 中关于时间与日期的一个很重要的概念，它表示从 1970年1月1日 00:00:00 到当前时间的秒数之和。 PHP提供了内置函数strtotime实现功能：获取某个日期的时间戳，或获取某个时间的时间戳。例如： echo strtotime(&apos;2014-04-29&apos;);//1398700800，这个数字表示从1970年1月1日 00:00:00 到2014年4月29号经历了1398700800秒 echo strtotime(&apos;2014-04-29 00:00:01&apos;);//1398700801，这个数字表示从1970年1月1日 00:00:00 到2014-04-29 00:00:01时经历了1398700801秒 大家发现上面的规律了吗，其实strtotime(‘2014-04-29’)相当于strtotime(‘2014-04-29 00:00:00’) 格式化日期strtotime函数预期接受一个包含美国英语日期格式的字符串并尝试将其解析为 Unix 时间戳。 函数说明：strtotime(要解析的时间字符串, 计算返回值的时间戳【默认是当前的时间，可选】) 返回值：成功则返回时间戳，否则返回 FALSE 比如 echo strtotime(&quot;now&quot;);//相当于将英文单词now直接等于现在的日期和时间，并把这个日期时间转化为unix时间戳。这个效果跟echo time();一样。 echo strtotime(&quot;+1 seconds&quot;);//相当于将现在的日期和时间加上了1秒，并把这个日期时间转化为unix时间戳。这个效果跟echo time()+1;一样。 echo strtotime(&quot;+1 day&quot;);//相当于将现在的日期和时间加上了1天。 echo strtotime(&quot;+1 week&quot;);//相当于将现在的日期和时间加上了1周。 echo strtotime(&quot;+1 week 3 days 7 hours 5 seconds&quot;);//相当于将现在的日期和时间加上了1周3天7小时5秒。 格式化格林威治时间gmdate 函数能格式化一个GMT的日期和时间，返回的是格林威治标准时（GMT）。 举个例子，我们现在所在的中国时区是东八区，领先格林威治时间8个小时，有时候也叫GMT+8，那么服务器运行以下脚本返回的时间应该是这样的：当前时间假定是2014-05-01 15:15:22 echo date(&apos;Y-m-d H:i:s&apos;, time()); //输出为：2014-05-01 15:15:22 echo gmdate(&apos;Y-m-d H:i:s&apos;, time()); //输出为：2014-05-01 07:15:22 因为格林威治时间是现在中国时区的时间减去8个小时，所以相对于现在时间要少8个小时]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>时间与日期处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第十一篇——万物皆对象]]></title>
    <url>%2F2018%2F12%2F04%2FPHP%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AF%87%E2%80%94%E2%80%94%E4%B8%87%E7%89%A9%E7%9A%86%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[所谓万物皆对象，我相信做过面向对象开发的人应该都知道这个到底，但是真正理解开发中的面向对应只有真实动手开发并且慢慢总结才能知道里面的含义，iOS可谓是纯面向对象的语言，当然还有很多其他的…. 万物皆对象类与对象通常定义一个汽车类的方法为： class Car { //定义一个Car类 $name = &apos;汽车&apos;; //属性 function getName() { //方法 return $this-&gt;name; //返回 } } 方法内部可以使用$this伪变量调用对象的属性或者方法 类是一类东西的结构描述，而对象则是一类东西的一个具体实例，例如汽车这个名词可以理解为汽车的总类，但这辆汽车则是一个具体的汽车对象。 对象通过new关键字进行实例化： $car = new Car(); //实例化一个对象 或者可以这样： $className = &apos;Car&apos;; $car = new $className(); echo $car-&gt;getName(); //调用对象的方法 类与对象看起来比较相似，但实际上有本质的区别，类是抽象的概念，对象是具体的实例。类可以使程序具有可重用性。 属性在类中定义的变量称之为属性，通常属性跟数据库中的字段有一定的关联，因此也可以称作“字段”。属性声明是由关键字 public，protected 或者 private 开头，后面跟一个普通的变量声明来组成。属性的变量可以设置初始化的默认值，默认值必须是常量。 访问控制的关键字代表的意义为： public：公开的protected：受保护的private：私有的 class Car { //定义公共属性 public $name = &apos;汽车&apos;; //定义受保护的属性 protected $corlor = &apos;白色&apos;; //定义私有属性 private $price = &apos;100000&apos;; } 默认都为public，外部可以访问。一般通过-&gt;对象操作符来访问对象的属性或者方法，对于静态属性则使用::双冒号进行访问。当在类成员方法内部调用的时候，可以使用$this伪变量调用当前对象的属性。 $car = new Car(); echo $car-&gt;name; //调用对象的属性 echo $car-&gt;color; //错误 受保护的属性不允许外部调用 echo $car-&gt;price; //错误 私有属性不允许外部调用 受保护的属性与私有属性不允许外部调用，在类的成员方法内部是可以调用的。 class Car{ private $price = &apos;1000&apos;; public function getPrice() { return $this-&gt;price; //内部访问私有属性 ​ } } 方法方法就是在类中的function，很多时候我们分不清方法与函数有什么差别，在面向过程的程序设计中function叫做函数，在面向对象中function则被称之为方法 同属性一样，类的方法也具有public，protected 以及 private 的访问控制。 访问控制的关键字代表的意义为：public：公开的protected：受保护的private：私有的 实例方法 class Car { public function getName() { return &apos;汽车&apos;; } ​} $car = new Car(); echo $car-&gt;getName(); 类方法 使用关键字static修饰的，称之为静态方法，静态方法不需要实例化对象，可以通过类名直接调用，操作符为双冒号::。 class Car { public static function getName() { return &apos;汽车&apos;; } ​} echo Car::getName(); //结果为“汽车” 构造函数和析构函数PHP5可以在类中使用__construct()定义一个构造函数，具有构造函数的类，会在每次对象创建的时候调用该函数，因此常用来在对象创建的时候进行一些初始化工作。 class Car { function __construct() { print &quot;构造函数被调用\n&quot;; //进行一些初始化工作 } } $car = new Car(); //实例化的时候 会自动调用构造函数__construct，这里会输出一个字符串 在子类中如果定义了construct则不会调用父类的construct，如果需要同时调用父类的构造函数，需要使用parent::__construct()显式的调用。 class Car { function __construct() { print &quot;父类构造函数被调用\n&quot;; } } class Truck extends Car { function __construct() { print &quot;子类构造函数被调用\n&quot;; parent::__construct(); } } $car = new Truck(); 同样，PHP5支持析构函数，使用__destruct()进行定义，析构函数指的是当某个对象的所有引用被删除，或者对象被显式的销毁时会执行的函数。 class Car { function __construct() { print &quot;构造函数被调用 \n&quot;; } function __destruct() { print &quot;析构函数被调用 \n&quot;; } } $car = new Car(); //实例化时会调用构造函数 echo &apos;使用后，准备销毁car对象 \n&apos;; unset($car); //销毁时会调用析构函数 当PHP代码执行完毕以后，会自动回收与销毁对象，因此一般情况下不需要显式的去销毁对象。 Static静态关键字静态属性与方法可以在不实例化类的情况下调用，直接使用类名::方法名的方式进行调用。静态属性不允许对象使用-&gt;操作符调用。 class Car { private static $speed = 10; public static function getSpeed() { return self::$speed; } } echo Car::getSpeed(); //调用静态方法 静态方法也可以通过变量来进行动态调用 $func = &apos;getSpeed&apos;; $className = &apos;Car&apos;; echo $className::$func(); //动态调用静态方法 静态方法中，$this伪变量不允许使用。可以使用self，parent，static在内部调用静态方法与属性。 class Car { private static $speed = 10; public static function getSpeed() { return self::$speed; } public static function speedUp() { return self::$speed+=10; } } class BigCar extends Car { public static function start() { parent::speedUp(); } } BigCar::start(); echo BigCar::getSpeed(); 访问控制被定义为公有的类成员可以在任何地方被访问。 被定义为受保护的类成员则可以被其自身以及其子类和父类访问。 被定义为私有的类成员则只能被其定义所在的类访问 类属性必须定义为公有、受保护、私有之一。为兼容PHP5以前的版本，如果采用 var 定义，则被视为公有。 class Car { $speed = 10; //错误 属性必须定义访问控制 public $name; //定义共有属性 } 类中的方法可以被定义为公有、私有或受保护。如果没有设置这些关键字，则该方法默认为公有。 class Car { ​ //默认为共有方法 function turnLeft() { } } 如果构造函数定义成了私有方法，则不允许直接实例化对象了，这时候一般通过静态方法进行实例化，在设计模式中会经常使用这样的方法来控制对象的创建，比如单例模式只允许有一个全局唯一的对象。 class Car { private function __construct() { echo &apos;object create&apos;; } private static $_object = null; public static function getInstance() { if (empty(self::$_object)) { self::$_object = new Car(); //内部方法可以调用私有方法，因此这里可以创建对象 } return self::$_object; } } //$car = new Car(); //这里不允许直接实例化对象 $car = Car::getInstance(); //通过静态方法来获得一个实例 对象继承继承是面向对象程序设计中常用的一个特性，汽车是一个比较大的类，我们也可以称之为基类，除此之外，汽车还分为卡车、轿车、东风、宝马等，因为这些子类具有很多相同的属性和方法，可以采用继承汽车类来共享这些属性与方法，实现代码的复用。 &lt;?php class Car { public $speed = 0; //汽车的起始速度是0 public function speedUp() { $this-&gt;speed += 10; return $this-&gt;speed; } } //定义继承于Car的Truck类 class Truck extends Car { public function speedUp() { parent::speedUp(); $this-&gt;speed += 50; return $this-&gt;speed; } } $car = new Truck(); $car-&gt;speedUp(); echo $car-&gt;speed; 重载PHP中的重载指的是动态的创建属性与方法，是通过魔术方法来实现的。属性的重载通过set，get，isset，unset来分别实现对不存在属性的赋值、读取、判断属性是否设置、销毁属性。 class Car { private $ary = array(); public function __set($key, $val) { $this-&gt;ary[$key] = $val; } public function __get($key) { if (isset($this-&gt;ary[$key])) { return $this-&gt;ary[$key]; } return null; } public function __isset($key) { if (isset($this-&gt;ary[$key])) { return true; } return false; } public function __unset($key) { unset($this-&gt;ary[$key]); } } $car = new Car(); $car-&gt;name = &apos;汽车&apos;; //name属性动态创建并赋值 echo $car-&gt;name; 方法的重载通过call来实现，当调用不存在的方法的时候，将会转为参数调用call方法，当调用不存在的静态方法时会使用__callStatic重载。 class Car { public $speed = 0; public function __call($name, $args) { if ($name == &apos;speedUp&apos;) { $this-&gt;speed += 10; } } } $car = new Car(); $car-&gt;speedUp(); //调用不存在的方法会使用重载 echo $car-&gt;speed; 高级特性对象比较，当同一个类的两个实例的所有属性都相等时，可以使用比较运算符==进行判断，当需要判断两个变量是否为同一个对象的引用时，可以使用全等运算符===进行判断。 class Car { } $a = new Car(); $b = new Car(); if ($a == $b) echo &apos;==&apos;; //true if ($a === $b) echo &apos;===&apos;; //false 对象复制，在一些特殊情况下，可以通过关键字clone来复制一个对象，这时__clone方法会被调用，通过这个魔术方法来设置属性的值。 class Car { public $name = &apos;car&apos;; public function __clone() { $obj = new Car(); $obj-&gt;name = $this-&gt;name; } } $a = new Car(); $a-&gt;name = &apos;new car&apos;; $b = clone $a; var_dump($b); 对象序列化，可以通过serialize方法将对象序列化为字符串，用于存储或者传递数据，然后在需要的时候通过unserialize将字符串反序列化成对象进行使用。 class Car { public $name = &apos;car&apos;; } $a = new Car(); $str = serialize($a); //对象序列化成字符串 echo $str.&apos;&lt;br&gt;&apos;; $b = unserialize($str); //反序列化为对象 var_dump($b);]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>万物皆对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第十篇——字符串操作]]></title>
    <url>%2F2018%2F12%2F03%2FPHP%E7%AC%AC%E5%8D%81%E7%AF%87%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[关于PHP中字符串操作前面的总结中也有一少部分，但是相对真实开发这还是远远不够的。结合iOS开发中对字符串操作的频率，我们其实大概就可以知道，任何开发中字符串操作是我们平时使用最频繁的！ 字符串操作字符串介绍字符串变量用于包含字符串的值。 定义方式：前面有介绍到1、单引号 $hello = &apos;hello world&apos;; 2、双引号 $hello = &quot;hello world&quot;; 3、heredoc语法结构 $hello = &lt;&lt;&lt;TAG hello world TAG; 单引号和双引号到底有啥区别？PHP允许我们在双引号串中直接包含字串变量。而单引号串中的内容总被认为是普通字符。 $str=&apos;hello&apos;; echo &quot;str is $str&quot;; //运行结果: str is hello echo &apos;str is $str&apos;; //运行结果: str is $str PHP中用英文的点号.来连接两个字符串这里就不多介绍。去除字符串首尾的空格PHP中有三个函数可以去掉字符串的空格 trim去除一个字符串两端空格。rtrim是去除一个字符串右部空格，其中的r是right的缩写。ltrim是去除一个字符串左部空格，其中的l是left的缩写。 echo trim(&quot; 空格 &quot;).&quot;&lt;br&gt;&quot;; echo rtrim(&quot; 空格 &quot;).&quot;&lt;br&gt;&quot;; echo ltrim(&quot; 空格 &quot;).&quot;&lt;br&gt;&quot;; 获取字符串的长度php中有一个神奇的函数，可以直接获取字符串的长度，这个函数就是strlen()。 $str = &apos;hello&apos;; $len = strlen($str); echo $len;//输出结果是5 如果有中文汉字，可以使用mb_strlen()函数获取字符串中中文长度。 $str = &quot;我爱你&quot;; echo mb_strlen($str,&quot;UTF8&quot;);//结果：3，此处的UTF8表示中文编码是UTF8格式，中文一般采用UTF8编码 字符串的截取英文字符串的截取函数substr()函数说明：substr(字符串变量,开始截取的位置，截取个数） $str=&apos;i love you&apos;; //截取love这几个字母 echo substr($str, 2, 4);//为什么开始位置是2呢，因为substr函数计算字符串位置是从0开始的，也就是0的位置是i,1的位置是空格，l的位置是2。从位置2开始取4个字符，就是love。 中文字符串的截取函数mb_substr()函数说明：mb_substr(字符串变量,开始截取的位置，截取个数, 网页编码） $str=&apos;我爱你，中国&apos;; //截取中国两个字 echo mb_substr($str, 4, 2, &apos;utf8&apos;);//为什么开始位置是4呢，和上一个例子一样，因为mb_substr函数计算汉字位置是从0开始的，也就是0的位置是我,1的位置是爱，4的位置是中。从位置4开始取2个汉字，就是中国。中文编码一般是utf8格式 查找字符串如果有一个字符串$str = ‘I want to study at imooc’;，怎么样找到其中的imooc在哪个位置呢？查找字符串，我们需要用到PHP的查找字符串函数strpos(); $str = &apos;I want to study at imooc&apos;; $pos = strpos($str, &apos;imooc&apos;); echo $pos;//结果显示19，表示从位置0开始，imooc在第19个位置开始出现 函数说明：strpos(要处理的字符串, 要定位的字符串, 定位的起始位置[可选]) 字符串替换替换字符串，我们需要用到PHP的替换函数str_replace() $str = &apos;I want to learn js&apos;; $replace = str_replace(&apos;js&apos;, &apos;php&apos;, $str); echo $replace;//结果显示I want to learn php 函数说明：str_replace(要查找的字符串, 要替换的字符串, 被搜索的字符串, 替换进行计数[可选]) 字符串格式化PHP的格式化字符串函数sprintf() $str = &apos;99.9&apos;; $result = sprintf(&apos;%01.2f&apos;, $str); echo $result;//结果显示99.90 函数说明：sprintf(格式, 要转化的字符串)返回：格式化好的字符串 函数注释 1、这个 % 符号是开始的意思，写在最前面表示指定格式开始了。 也就是 &quot;起始字符&quot;, 直到出现 &quot;转换字符&quot; 为止，就算格式终止。 2、跟在 % 符号后面的是 0， 是 &quot;填空字元&quot; ，表示如果位置空着就用0来填满。 3、在 0 后面的是1，这个 1 是规定整个所有的字符串占位要有1位以上(小数点也算一个占位)。 如果把 1 改成 6，则 $result的值将为 099.90 因为，在小数点后面必须是两位，99.90一共5个占位，现在需要6个占位，所以用0来填满。 4、在 %01 后面的 .2 （点2） 就很好理解了，它的意思是，小数点后的数字必须占2位。 如果这时候，$str 的值为9.234,则 $result的值将为9.23. 为什么4 不见了呢？ 因为在小数点后面，按照上面的规定，必须且仅能占2位。 可是 $str 的值中，小数点后面占了3位，所以，尾数4被去掉了，只剩下 23。 5、最后，以 f &quot;转换字符&quot; 结尾。 字符串的合并与分割php字符串合并函数implode()$arr = array(&apos;Hello&apos;, &apos;World!&apos;); $result = implode(&apos;&apos;, $arr); print_r($result);//结果显示Hello World! 函数说明：implode(分隔符[可选], 数组)返回值：把数组元素组合为一个字符串 php字符串分隔函数explode()$str = &apos;apple,banana&apos;; $result = explode(&apos;,&apos;, $str); print_r($result);//结果显示array(&apos;apple&apos;,&apos;banana&apos;) 函数说明：explode(分隔符[可选], 字符串) 返回值：函数返回由字符串组成的数组 字符串的转义php字符串转义函数addslashes() $str = &quot;what&apos;s your name?&quot;; echo addslashes($str);//输出：what\&apos;s your name? 函数说明：用于对特殊字符加上转义字符，返回一个字符串返回值：一个经过转义后的字符串]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>字符串操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第九篇——魔术方法]]></title>
    <url>%2F2018%2F12%2F01%2FPHP%E7%AC%AC%E4%B9%9D%E7%AF%87%E2%80%94%E2%80%94%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[PHP中把以两个下划线开头的方法称为魔术方法，这些方法在PHP中充当了举足轻重的作用。 魔术方法包括： construct()，类的构造函数destruct()，类的析构函数 call()，在对象中调用一个不可访问方法时调用callStatic()，用静态方式中调用一个不可访问方法时调用 get()，获得一个类的成员变量时调用 set()，设置一个类的成员变量时调用 isset()，当对不可访问属性调用isset()或empty()时调用unset()，当对不可访问属性调用unset()时被调用。 sleep()，执行serialize()时，先会调用这个函数wakeup()，执行unserialize()时，先会调用这个函数 toString()，类被当成字符串时的回应方法invoke()，调用函数的方式调用一个对象时的回应方法 set_state()，调用var_export()导出类时，此静态方法会被调用。__clone()，当对象复制完成时调用 魔术方法__get($name)–触发时机：当调用一个不访问的成员属性的时候，会自动触发，可以利用这个方法来完成对不可调用的属性进行调用，但是不能设置值 ___set($name,value)–触发时机：当给一个不可访问的成员属性赋值的时候，会自动触发这个方法，可以利用这个方法完成对不可以访问的属性进行赋值 __isset($name)—触发时机：当使用isset()函数来判断一个对象的属性的时候，如果这个属性不存在或者不能被访问的时候会触发这个魔术方法 __call($method,args)—触发时机:当调用一个不存在的成员方法或者是不可访问的成员访问的时候会被触发 __callStatic($method,args)–触发时机：当调用一个不存在的成员方法或者是不可访问的成员访问的时候会被触发 __unset()—触发时机：当要销毁一个不可访问的或者不存在的成员属性的时候会被调用 __sleep()—触发时机：当使用serialize把对象进行序列化的时候会被触发 php public function __sleep() { return array(&apos;xxx&apos;);//指定可以被序列化的属性 } __wakeup()触发时机：当使用unserialize的反序列化的时候会被自动触发 1234public function __wakeup()&#123;&#125; __toString()触发时机：在echo一个对象的时候会被触发 PHP public function __toString() { return &apos;小可爱&apos;; } __clone()对象复制可以通过 clone 关键字来完成（如果可能，这将调用对象的 __clone() 方法]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>魔术方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第八篇——函数篇]]></title>
    <url>%2F2018%2F12%2F01%2FPHP%E7%AC%AC%E5%85%AB%E7%AF%87%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E7%AF%87%2F</url>
    <content type="text"><![CDATA[PHP内置了超过1000个函数，因此函数使得PHP成为一门非常强大的语言。大多数时候我们使用系统的内置函数就可以满足需求，但是自定义函数通过将一组代码封装起来，使代码进行复用，程序结构与逻辑更加清晰。 函数篇函数定义PHP函数的定义方式：（和JS很像） 1.使用关键字“function”开始2.函数名可以是字母或下划线开头：function name()3.在大括号中编写函数体： function name() { echo &apos;Eric&apos;; } 调用直接是函数名+参数 name(); 函数参数PHP的函数可以没有参数，也可以有若干个参数，多个参数称之为参数列表，采用逗号进行分割，参数类似于一个变量，调用时用来传递数据到函数体中。通过传递参数可以使函数实现对参数的运算，得到我们想要的结果。 &lt;?php function sum($a, $b) { echo $a + $b; } //在这里调用函数计算1+2的值 sum(1, 2); 函数返回值使用return关键字可以使函数返回值，可以返回包括数组和对象的任意类型，如果省略了 return，则默认返回值为 NULL。 function add($a) { return $a+1; } $b = add(1); 注意： 返回语句会立即中止函数的运行，并且将控制权交回调用该函数的代码行 函数不能返回多个值，但可以通过返回一个数组来得到类似的效果 可变函数所谓可变函数，即通过变量的值来调用函数，因为变量的值是可变的，所以可以通过改变一个变量的值来实现调用不同的函数。经常会用在回调函数、函数列表，或者根据动态参数来调用不同的函数 变函数的调用方法为变量名加括号。 function name() { echo &apos;jobs&apos;; } $func = &apos;name&apos;; $func(); //调用可变函数 可变函数也可以用在对象的方法调用上。 class book { function getName() { return &apos;bookname&apos;; } } $func = &apos;getName&apos;; $book = new book(); $book-&gt;$func(); 内置函数内置函数指的是PHP默认支持的函数，PHP内置了很多标准的常用的处理函数，包括字符串处理、数组函数、文件处理、session与cookie处理等。 例如：通过内置函数str_replace可以实现字符串的替换 $str = &apos;i am jobs.&apos;; $str = str_replace(&apos;jobs&apos;, &apos;steven jobs&apos;, $str); echo $str; //结果为“i am steven jobs” 另外一些函数是通过其他扩展来支持的，比如mysql数据库处理函数，GD图像处理函数，邮件处理函数等，PHP默认加载了一些常用的扩展库，我们可以安装或者加载其他扩展库来增加PHP的处理函数。 函数检测当我们创建了自定义函数，并且了解了可变函数的用法，为了确保程序调用的函数是存在的，经常会先使用function_exists判断一下函数是否存在。 同样的method_exists可以用来检测类的方法是否存在。 function func() { } if (function_exists(&apos;func&apos;)){ echo &apos;exists&apos;; } 类是否定义可以使用class_exists。 class MyClass{ } // 使用前检查类是否存在 if (class_exists(&apos;MyClass&apos;)) { $myclass = new MyClass(); } PHP中有很多这类的检查方法，例如文件是否存在file_exists等。 $filename = &apos;test.txt&apos;; if (!file_exists($filename)) { echo $filename . &apos; not exists.&apos;; }]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>函数篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第七篇——数组篇]]></title>
    <url>%2F2018%2F12%2F01%2FPHP%E7%AC%AC%E4%B8%83%E7%AF%87%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E7%AF%87%2F</url>
    <content type="text"><![CDATA[什么是数组？数组就是被命名的用来存储一系列数值的地方。数组array是非常重要的数据类型。相对于其他的数据类型，它更像是一种结构，而这种结果构可以存储一系列数值。数组能够在单一变量名中存储许多值，并且能够通过引用下标号来访问某个值。 在 PHP 中，有三种数组类型： 索引数组 - 带有数字索引的数组 关联数组 - 带有指定键的数组 多维数组 - 包含一个或多个数组的数组 数组篇PHP数组定义数组就是一个键值对组成的语言结构，键类似于酒店的房间号，值类似于酒店房间里存储的东西。 其实在PHP中数组感觉更像iOS中的字典，但也有iOS中的数组相似点，只是数组通过索引，字典是通过键值对。 创建数组（空） $arr = array(); PHP有两种数组：索引数组、关联数组。索引和关联两个词都是针对数组的键而言的。 PHP索引数组–iOS中的数组先介绍下索引数组，索引数组是指数组的键是整数的数组，并且键的整数顺序是从0开始，依次类推。 创建索引数组$arrIndex = array(&quot;iCocos&quot;, &quot;iOS&quot;, &quot;苹果&quot;); 注意数组的键是从0开始的。可以使用print_r($arr);语句输出数组键及对应的值。 赋值方式第一种：用数组变量的名字后面跟一个中括号的方式赋值，当然，索引数组中，中括号内的键一定是整数。比如，$arr[0]=&apos;iCocos&apos;; 第二种：用array()创建一个空数组，使用=&gt;符号来分隔键和值，左侧表示键，右侧表示值。当然，索引数组中，键一定是整数。比如，array(&apos;0&apos;=&gt;&apos;iCocos&apos;); 第三种：用array()创建一个空数组，直接在数组里用英文的单引号&apos;或者英文的双引号&quot;赋值，数组会默认建立从0开始的整数的键。比如array(&apos;iCocos&apos;);这个数组相当于array(&apos;0&apos;=&gt;&apos;iCocos&apos;); 读取内容用数组变量的名字后跟的中括号中的键，来访问数组中的值。 $arr = array(&apos;iCocos&apos;,&apos;iOS&apos;); $arr0 = $arr[&apos;0&apos;]; print_r($arr0);//结果为iCocos 遍历数组（开发中最常用的操作）–&gt;for$arr=array(&apos;iCocos&apos;,&apos;iOS&apos;,&apos;苹果&apos;); for($i=0; $i&lt;3; $i++){ echo &apos;&lt;br&gt;数组第&apos;.$i.&apos;值是：&apos;.$arr[$i]; } 遍历数组（开发中最常用的操作）–&gt;foreach$arr=array(&apos;iCocos&apos;,&apos;iOS&apos;,&apos;苹果&apos;); foreach($arr as $k=&gt;$v){ echo &apos;&lt;br&gt;第&apos;.$k.&apos;值是：&apos;.$v; } PHP关联数组–iOS中的字典关联数组是指数组的键是字符串的数组。 创建关联数组$arr = array( &apos;apple&apos;=&gt;&quot;iCocos&quot;, &apos;banana&apos;=&gt;&quot;iOS&quot;, &apos;pineapple&apos;=&gt;&quot;苹果&quot; ); 赋值方式第一种：用数组变量的名字后面跟一个中括号的方式赋值，当然，关联数组中，中括号内的键一定是字符串。比如，$arr[&apos;apple&apos;]=&apos;iCocos&apos;; 第二种：用array()创建一个空数组，使用=&gt;符号来分隔键和值，左侧表示键，右侧表示值。当然，关联数组中，键一定是字符串。比如，array(&apos;apple&apos;=&gt;&apos;iCocos&apos;); 读取内容用数组变量的名字后跟中括号+键的方式来访问数组中的值，键使用单引号或者双引号括起来。 $arr = array(&apos;apple&apos;=&gt;&quot;iCocos&quot;,&apos;banana&apos;=&gt;&quot;iOS&quot;,&apos;pineapple&apos;=&gt;&quot;苹果&quot;); $arr0 = $arr[&apos;banana&apos;]; print_r($arr0); 遍历数组（开发中最常用的操作）–&gt;foreach$arr=array(&apos;apple&apos;=&gt;&quot;iCocos&quot;,&apos;banana&apos;=&gt;&quot;iOS&quot;,&apos;pineapple&apos;=&gt;&quot;苹果&quot;); foreach($arr as $k=&gt;$v){ echo &apos;&lt;br&gt;水果的英文键名：&apos;.$k.&apos;，对应的值是：&apos;.$v; } 常用函数array_filter(*array*,*callbackfunction*); array_intersect_uassoc(*array1*,*array2*,*array3*...,*myfunction*) array_intersect_ukey(*array1*,*array2*,*array3*...,*myfunction*) array_reduce(*array*,*myfunction*,*initial*) array_walk(*array*,*myfunction*,*userdata*...) …… 其他常用技巧总结多维数组array(array(),array()) 二维数组 数组长度$arr = array(&quot;百度&quot;,&quot;阿里&quot;,&quot;腾讯&quot;); echo count($arr); 增加删除数组的元素在数组元素的尾部增加array_push(array,value1,value2…) 函数向第一个参数的数组尾部添加一个或多个元素（入栈），然后返回新数组的长度。该函数等于多次调用 $array[] = $value。 &lt;?php $arr = array(&quot;百度&quot;,&quot;阿里&quot;,&quot;腾讯&quot;); array_push($arr,&quot;知乎&quot;,&quot;微博&quot;); echo &quot;&lt;pre&gt;&quot;; //换行显示 print_r($arr); 打印结果显示： Array ( [0] =&gt; 百度 [1] =&gt; 阿里 [2] =&gt; 腾讯 [3] =&gt; 知乎 [4] =&gt; 微博 ) 在数组元素的开始增加array_unshift(array,value1,value2,value3…) 函数用于向数组插入新元素。新数组的值将被插入到数组的开头。 &lt;?php $arr = array(&quot;百度&quot;,&quot;阿里&quot;,&quot;腾讯&quot;); array_unshift($arr,&quot;知乎&quot;,&quot;微博&quot;); echo &quot;&lt;pre&gt;&quot;; //换行显示 print_r($arr); 打印结果显示： Array ( [0] =&gt; 知乎 [1] =&gt; 微博 [2] =&gt; 百度 [3] =&gt; 阿里 [4] =&gt; 腾讯 ) 在数组元素的尾部删除array_pop(array) 函数删除数组中的最后一个元素。 &lt;?php $arr = array(&quot;百度&quot;,&quot;阿里&quot;,&quot;腾讯&quot;); array_pop($arr); echo &quot;&lt;pre&gt;&quot;; //换行显示 print_r($arr); 打印结果显示： Array ( [0] =&gt; 百度 [1] =&gt; 阿里 ) 在数组元素的开始删除array_shift(array) 函数删除数组中第一个元素 并可以返回被删除元素的值。 &lt;?php $arr = array(&quot;百度&quot;,&quot;阿里&quot;,&quot;腾讯&quot;); array_shift($arr); echo &quot;&lt;pre&gt;&quot;; //换行显示 print_r($arr); 打印结果显示： Array ( [0] =&gt; 阿里 [1] =&gt; 腾讯 ) 移除数组中重复的值array_unique(array) 函数移除数组中的重复的值，并返回结果数组。 &lt;?php $arr = array(&quot;百度&quot;,&quot;阿里&quot;,&quot;腾讯&quot;,&quot;百度&quot;,&quot;微博&quot;); $data = array_unique($arr); echo &quot;&lt;pre&gt;&quot;; print_r($data); 打印结果显示： Array ( [0] =&gt; 百度 [1] =&gt; 阿里 [2] =&gt; 腾讯 [4] =&gt; 微博 ) 数组合并、拆分、比较array_merge()函数将数组合并到一起，返回一个联合的数组。所得到的数组以第一个输入数组参数开始，按后面数组参数出现的顺序依次追加。 &lt;?php $arr1 = array(&quot;百度&quot;,&quot;阿里&quot;,&quot;腾讯&quot;); $arr2 = array(&quot;知乎&quot;,&quot;微博&quot;); $data = array_merge($arr1,$arr2); echo &quot;&lt;pre&gt;&quot;; print_r($data); 打印结果显示： Array ( [0] =&gt; 百度 [1] =&gt; 阿里 [2] =&gt; 腾讯 [3] =&gt; 知乎 [4] =&gt; 微博 ) 递归追加数组array_merge_recursive()函数与array_merge()相同，可以将两个或多个数组合并到一起，形成一个联合的数组。两者之间的区别在于，当某个输入数组中的某个键已经存在于结果数组中时该函数会采取不同的处理方法。array_merge()会覆盖前面存在的键/值对，将其替换为当前输入数组中的键/值对，而array_merge_recursive()将两个值合并在一起，形成一个新的数组并以原有的键作为数组名。其形式为： $arr= array(&apos;one&apos;=&gt;&apos;C&apos;, &apos;one&apos;=&gt;&apos;B&apos;); $arr1= array(&apos;three&apos;=&gt;&apos;1&apos;, &apos;one&apos;=&gt;&apos;2&apos;); $arr2= array_merge_recursive($arr, $arr1); echo &quot;&lt;pre&gt;&quot;; print_r($arr2); 打印结果显示： Array ( [one] =&gt; Array ( [0] =&gt; B [1] =&gt; 2 ) [three] =&gt; 1 ) 合并两个数组array_combine()函数会生成一个新数组，这个数组由一组提交的键和对应的值组成，其形式为： $arr= array(&apos;A&apos;, &apos;B&apos;); $arr1= array(&apos;1&apos;, &apos;2&apos;); $arr2= array_combine($arr, $arr1); echo &quot;&lt;pre&gt;&quot;; print_r($arr2); 打印结果显示： Array ( [A] =&gt; 1 [B] =&gt; 2 ) 求数组的交集array_intersect()函数返回一个保留了键的数组，这个数组只由第一个数组中出现的且在其他每个输入数组中都出现的值组成。其形式如下： $arr= array(&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;); $arr1= array(&apos;A&apos;, &apos;B&apos;, &apos;E&apos;); $arr2= array(&apos;A&apos;, &apos;F&apos;, &apos;D&apos;); $arr3= array_intersect($arr, $arr1, $arr2); echo &quot;&lt;pre&gt;&quot;; print_r($arr3); 打印结果显示： Array ( [0] =&gt; A ) 注意：只有在两个元素有相同的数据类型时，array_intersect()才会认为它们相等。 求关联数组的交集array_intersect_assoc()与array_intersect()基本相同，只不过它在比较中还考虑了数组的键。因此，只有在第一个数组中出现，且在所有其他输入数组中也出现的键/值对才被返回到结果数组中。其形式如下： $arr= array(&apos;a&apos;=&gt;&apos;A&apos;, &apos;b&apos;=&gt;&apos;B&apos;, &apos;c&apos;=&gt;&apos;C&apos;, &apos;d&apos;=&gt;&apos;D&apos;); $arr1= array(&apos;a&apos;=&gt;&apos;A&apos;, &apos;c&apos;=&gt;&apos;B&apos;, &apos;E&apos;); $arr2= array(&apos;a&apos;=&gt;&apos;A&apos;, &apos;b&apos;=&gt;&apos;F&apos;, &apos;d&apos;=&gt;&apos;B&apos;); $arr3= array_intersect_assoc($arr, $arr1, $arr2); echo &quot;&lt;pre&gt;&quot;; print_r($arr3); 打印结果显示： Array ( [a] =&gt; A ) 求关联数组的差集函数array_diff_assoc()与array_diff()基本相同，只是它在比较时还考虑了数组的键，因此，只在第一个数组中出现而不在其他输入数组中出现的键/值对才会被返回到结果数组中。其形式如下： $arr= array(&apos;a&apos;=&gt;&apos;A&apos;, &apos;b&apos;=&gt;&apos;B&apos;, &apos;c&apos;=&gt;&apos;C&apos;, &apos;d&apos;=&gt;&apos;D&apos;); $arr1= array(&apos;a&apos;=&gt;&apos;A&apos;, &apos;b&apos;=&gt;&apos;B&apos;, &apos;e&apos;=&gt;&apos;E&apos;); $arr3= array_diff_assoc($arr, $arr1); echo &quot;&lt;pre&gt;&quot;; print_r($arr3); 打印结果显示： Array ( [c] =&gt; C [d] =&gt; D ) 其他有用的数组函数返回一组随机的键 array_rand()函数将返回数组中的一个或多个键。其形式为： $arr= array(&apos;a&apos;=&gt;&apos;A&apos;, &apos;b&apos;=&gt;&apos;B&apos;, &apos;c&apos;=&gt;&apos;C&apos;, &apos;d&apos;=&gt;&apos;D&apos;); $arr1= array_rand($arr, 2); echo &quot;&lt;pre&gt;&quot;; print_r($arr1); 打印结果显示： Array ( [0] =&gt; c [1] =&gt; d ) //每次刷新显示的结果都不一样 对数组中的值求和array_sum()函数将数组内的所有值加在一起，返回最终的和，其形式如下： $arr= array(&apos;A&apos;, 32, 12, &apos;B&apos;); $count= array_sum($arr); echo &quot;&lt;pre&gt;&quot;; print_r($count); 打印结果显示： 44 如果数组中包含其他数据类型(例如字符串)，这些值将被忽略。 划分数组array_chunk()函数将数组分解为一个多维数组，这个多维数组由多个包含size个元素的数组所组成。其形式如下： $arr= array(&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;); $arr1= array_chunk($arr, 2); echo &quot;&lt;pre&gt;&quot;; print_r($arr1); 打印结果显示： Array ( [0] =&gt; Array ( [0] =&gt; A [1] =&gt; B ) [1] =&gt; Array ( [0] =&gt; C [1] =&gt; D ) )]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>数组篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第六篇——PHP底层机制]]></title>
    <url>%2F2018%2F11%2F25%2FPHP%E7%AC%AC%E5%85%AD%E7%AF%87%E2%80%94%E2%80%94PHP%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[最新开始打算学习新的东西，我选择了PHP，这里先说一下为什么是PHP。 1. 因为有人说PHP是世界上最好的语言 2. 因为我经历的几家大部分都是用PHP写的后台 3. 因为大学学习过java，就是因为对java不敢兴趣，所以才选择iOS 。。。。。。。 &lt;!--more--&gt; PHP底层机制先来了解与一下PHP能做什么，为什么需要学习PHP为什么要学习PHP？“我可以用JavaScript来实现程序编写。”但JavaScript的能力是有限的，JavaScript通常运行在浏览器（客户端），它可以制作网页上面的特效：鼠标滑过背景改变颜色，还有网页上常见的鼠标滑过弹出菜单。但如果要让JavaScript实现显示“访问网站的总人数”，它就无能为力了，因为它只能获得客户端的信息，而“访问网站的总人数”是存储在服务器端的。所以就需要另外一种可以在服务器端运行的编程语言，PHP语言就是其中的一种，因为它可以运行在Web服务器端。 在学习PHP之前让我们来认识一下PHP及其功能。1、运行在服务器端：学会了PHP，就可以指挥服务器给你干活，甚至是搞破坏^_^（千万不能真这么做咯），WEB网站的大部分数据都是存储在服务器端的，PHP就是用来处理这些存储在服务器的数据的（功能强大吧）。 2、跨平台：服务器可以是多种平台的服务器，比如Linux、Windows、Unix，你都可以指挥（不用怕只能指挥一种服务器啦吧）。 3、脚本语言：它是通过编写脚本，也就是一行行的计算机指令（也可以理解为特定的英文单词），来指挥服务器来工作的，因此，在编写PHP的过程其实就是与老外（服务器成老外啦）交流的过程，交流的语言就是PHP。 4、免费：免费使用（天下还真有免费的午餐）。 PHP的底层实现+运行机制PHP说简单，但是要精通也不是一件简单的事。我们除了会使用之外，还得知道它底层的工作原理。 因为有了学习iOS的时候喜欢挖底层的习惯，所以在真正学习PHP之前，我想先从PHP的底层开始研究。其实学习任何一门语言都必须学习并熟悉他的底层原理或者运行机制，不然永远是个初级或者基础的程序员。 + PHP是一种适用于web开发的动态语言。具体点说，就是一个用C语言实现包含大量组件的软件框架。更狭义点看，可以把它认为是一个强大的UI框架。 了解PHP底层实现的目的是什么？动态语言要像用好首先得了解它，内存管理、框架模型值得我们借鉴，通过扩展开发实现更多更强大的功能，优化我们程序的性能。 1. PHP的设计理念及特点多进程模型：由于PHP是多进程模型，不同请求间互不干涉，这样保证了一个请求挂掉不会对全盘服务造成影响，当然，随着时代发展，PHP也早已支持多线程模型。 弱类型语言：和C/C++、Java、C#等语言不同，PHP是一门弱类型语言。一个变量的类型并不是一开始就确定不变，运行中才会确定并可能发生隐式或显式的类型转换，这种机制的灵活性在web开发中非常方便、高效，具体会在后面PHP变量中详述。 引擎(Zend)+组件(ext)的模式降低内部耦合。 中间层(sapi)隔绝web server和PHP。 语法简单灵活，没有太多规范。缺点导致风格混杂，但再差的程序员也不会写出太离谱危害全局的程序。 2. PHP的四层体系PHP从下到上是一个4层体系： 2.1 Zend引擎：Zend整体用纯C实现，是PHP的内核部分，它将PHP代码翻译（词法、语法解析等一系列编译过程）为可执行opcode的处理并实现相应的处理方法、实现了基本的数据结构（如hashtable、oo）、内存分配及管理、提供了相应的api方法供外部调用，是一切的核心，所有的外围功能均围绕Zend实现。 2.2 Extensions：围绕着Zend引擎，extensions通过组件式的方式提供各种基础服务，我们常见的各种内置函数（如array系列）、标准库等都是通过extension来实现，用户也可以根据需要实现自己的extension以达到功能扩展、性能优化等目的（如贴吧正在使用的PHP中间层、富文本解析就是extension的典型应用）。 2.3 Sapi：Sapi全称是Server Application Programming Interface，也就是服务端应用编程接口，Sapi通过一系列钩子函数，使得PHP可以和外围交互数据，这是PHP非常优雅和成功的一个设计，通过sapi成功的将PHP本身和上层应用解耦隔离，PHP可以不再考虑如何针对不同应用进行兼容，而应用本身也可以针对自己的特点实现不同的处理方式。 2.4上层应用：这就是我们平时编写的PHP程序，通过不同的sapi方式得到各种各样的应用模式，如通过webserver实现web应用、在命令行下以脚本方式运行等等。 如果PHP是一辆车，那么车的框架就是PHP本身，Zend是车的引擎（发动机），Ext下面的各种组件就是车的轮子，Sapi可以看做是公路，车可以跑在不同类型的公路上，而一次PHP程序的执行就是汽车跑在公路上。因此，我们需要：性能优异的引擎+合适的车轮+正确的跑道。 3. Sapi如前所述，Sapi通过通过一系列的接口，使得外部应用可以和PHP交换数据并可以根据不同应用特点实现特定的处理方法，我们常见的一些sapi有： apache2handler：这是以apache作为webserver，采用mod_PHP模式运行时候的处理方式，也是现在应用最广泛的一种。 cgi：这是webserver和PHP直接的另一种交互方式，也就是大名鼎鼎的fastcgi协议，在最近今年fastcgi+PHP得到越来越多的应用，也是异步webserver所唯一支持的方式。 cli：命令行调用的应用模式 4. PHP的执行流程&amp;opcode我们先来看看PHP代码的执行所经过的流程。 PHP实现了一个典型的动态语言执行过程：拿到一段代码后，经过词法解析、语法解析等阶段后，源程序会被翻译成一个个指令(opcodes)，然后ZEND虚拟机顺次执行这些指令完成操作。PHP本身是用C实现的，因此最终调用的也都是C的函数，实际上，我们可以把PHP看做是一个C开发的软件。 4.1 PHP的执行的核心是翻译出来的一条一条指令，也即opcode。Opcode是PHP程序执行的最基本单位。一个opcode由两个参数(op1,op2)、返回值和处理函数组成。PHP程序最终被翻译为一组opcode处理函数的顺序执行。 4.2 常见的几个处理函数：ZEND_ASSIGN_SPEC_CV_CV_HANDLER : 变量分配 （$a=$b） ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER：函数调用 ZEND_CONCAT_SPEC_CV_CV_HANDLER：字符串拼接 $a.$b ZEND_ADD_SPEC_CV_CONST_HANDLER: 加法运算 $a+2 ZEND_IS_EQUAL_SPEC_CV_CONST：判断相等 $a==1 ZEND_IS_IDENTICAL_SPEC_CV_CONST：判断相等 $a===1 5. HashTable — 核心数据结构HashTable是zend的核心数据结构，在PHP里面几乎并用来实现所有常见功能，我们知道的PHP数组即是其典型应用，此外，在zend内部，如函数符号表、全局变量等也都是基于hash table来实现。 PHP的hash table具有如下特点： 支持典型的key-&gt;value查询 可以当做数组使用 添加、删除节点是O（1）复杂度 key支持混合类型：同时存在关联数组合索引数组 Value支持混合类型：array (“string”,2332) 支持线性遍历：如foreach Zend hash table实现了典型的hash表散列结构，同时通过附加一个双向链表，提供了正向、反向遍历数组的功能。 在hash table中既有key-&gt;value形式的散列结构，也有双向链表模式，使得它能够非常方便的支持快速查找和线性遍历。 5.1 散列结构：Zend的散列结构是典型的hash表模型，通过链表的方式来解决冲突。需要注意的是zend的hash table是一个自增长的数据结构，当hash表数目满了之后，其本身会动态以2倍的方式扩容并重新元素位置。初始大小均为8。另外，在进行key-&gt;value快速查找时候，zend本身还做了一些优化，通过空间换时间的方式加快速度。比如在每个元素中都会用一个变量nKeyLength标识key的长度以作快速判定。 5.2 双向链表：Zend hash table通过一个链表结构，实现了元素的线性遍历。理论上，做遍历使用单向链表就够了，之所以使用双向链表，主要目的是为了快速删除，避免遍历。Zend hash table是一种复合型的结构，作为数组使用时，即支持常见的关联数组也能够作为顺序索引数字来使用，甚至允许2者的混合。 5.3 PHP关联数组：关联数组是典型的hash_table应用。一次查询过程经过如下几步（从代码可以看出，这是一个常见的hash查询过程并增加一些快速判定加速查找。）： 来看看源码 getKeyHashValue h; index = n &amp; nTableMask; Bucket *p = arBucket[index]; while (p) { if ((p-&gt;h == h) &amp; (p-&gt;nKeyLength == nKeyLength)) { RETURN p-&gt;data; } p=p-&gt;next; } RETURN FALTURE; 5.4 PHP索引数组：索引数组就是我们常见的数组，通过下标访问。例如 $arr[0]，Zend HashTable内部进行了归一化处理，对于index类型key同样分配了hash值和nKeyLength(为0)。内部成员变量nNextFreeElement就是当前分配到的最大id，每次push后自动加一。正是这种归一化处理，PHP才能够实现关联和非关联的混合。由于push操作的特殊性，索引key在PHP数组中先后顺序并不是通过下标大小来决定，而是由push的先后决定。例如 $arr[1] = 2; $arr[2] = 3;对于double类型的key，Zend HashTable会将他当做索引key处理 6 PHP变量PHP是一门弱类型语言，本身不严格区分变量的类型。PHP在变量申明的时候不需要指定类型。PHP在程序运行期间可能进行变量类型的隐示转换。和其他强类型语言一样，程序中也可以进行显示的类型转换。PHP变量可以分为简单类型(int、string、bool)、集合类型(array resource object)和常量(const)。以上所有的变量在底层都是同一种结构 zval。 Zval是zend中另一个非常重要的数据结构，用来标识并实现PHP变量. Zval主要由三部分组成：type：指定了变量所述的类型（整数、字符串、数组等） refcount&amp;is_ref：用来实现引用计数(后面具体介绍) value：核心部分，存储了变量的实际数据 Zvalue是用来保存一个变量的实际数据。因为要存储多种类型，所以zvalue是一个union，也由此实现了弱类型。 PHP变量类型和其实际存储对应关系如下： IS_LONG -&gt; lvalue IS_DOUBLE -&gt; dvalue IS_ARRAY -&gt; ht IS_STRING -&gt; str IS_RESOURCE -&gt; lvalue 引用计数在内存回收、字符串操作等地方使用非常广泛。PHP中的变量就是引用计数的典型应用。Zval的引用计数通过成员变量is_ref和ref_count实现，通过引用计数，多个变量可以共享同一份数据。避免频繁拷贝带来的大量消耗。 在进行赋值操作时，zend将变量指向相同的zval同时ref_count++，在unset操作时，对应的ref_count-1。只有ref_count减为0时才会真正执行销毁操作。如果是引用赋值，则zend会修改is_ref为1。 PHP变量通过引用计数实现变量共享数据，那如果改变其中一个变量值呢？当试图写入一个变量时，Zend若发现该变量指向的zval被多个变量共享，则为其复制一份ref_count为1的zval，并递减原zval的refcount，这个过程称为“zval分离”。可见，只有在有写操作发生时zend才进行拷贝操作，因此也叫copy-on-write(写时拷贝) + 对于引用型变量，其要求和非引用型相反，引用赋值的变量间必须是捆绑的，修改一个变量就修改了所有捆绑变量。 + 整数、浮点数是PHP中的基础类型之一，也是一个简单型变量。对于整数和浮点数，在zvalue中直接存储对应的值。其类型分别是long和double。 - 从zvalue结构中可以看出，对于整数类型，和c等强类型语言不同，PHP是不区分int、unsigned int、long、long long等类型的，对它来说，整数只有一种类型也就是long。由此，可以看出，在PHP里面，整数的取值范围是由编译器位数来决定而不是固定不变的。 + 对于浮点数，类似整数，它也不区分float和double而是统一只有double一种类型。 - 在PHP中，如果整数范围越界了怎么办？这种情况下会自动转换为double类型，这个一定要小心，很多trick都是由此产生。 + 和整数一样，字符变量也是PHP中的基础类型和简单型变量。通过zvalue结构可以看出，在PHP中，字符串是由由指向实际数据的指针和长度结构体组成，这点和c++中的string比较类似。由于通过一个实际变量表示长度，和c不同，它的字符串可以是2进制数据（包含），同时在PHP中，求字符串长度strlen是O(1)操作。 在新增、修改、追加字符串操作时，PHP都会重新分配内存生成新的字符串。最后，出于安全考虑，PHP在生成一个字符串时末尾仍然会添加 常见的字符串拼接方式及速度比较： 假设有如下4个变量：$strA=‘123’; $strB = ‘456’; $intA=123; intB=456; 现在对如下的几种字符串拼接方式做一个比较和说明： $res = $strA.$strB和$res = “$strA$strB”这种情况下，zend会重新malloc一块内存并进行相应处理，其速度一般$strA = $strA.$strB这种是速度最快的，zend会在当前strA基础上直接relloc，避免重复拷贝$res = $intA.$intB这种速度较慢，因为需要做隐式的格式转换，实际编写程序中也应该注意尽量避免$strA = sprintf (“%s%s”,$strA.$strB);这会是最慢的一种方式，因为sprintf在PHP中并不是一个语言结构，本身对于格式识别和处理就需要耗费比较多时间，另外本身机制也是malloc。不过sprintf的方式最具可读性，实际中可以根据具体情况灵活选择。 PHP的数组通过Zend HashTable来天然实现。foreach操作如何实现？对一个数组的foreach就是通过遍历hashtable中的双向链表完成。对于索引数组，通过foreach遍历效率比for高很多，省去了key-&gt;value的查找。count操作直接调用HashTable-&gt;NumOfElements，O(1)操作。对于’123’这样的字符串，zend会转换为其整数形式。$arr[‘123’]和$arr[123]是等价的 资源类型变量是PHP中最复杂的一种变量，也是一种复合型结构。PHP的zval可以表示广泛的数据类型，但是对于自定义的数据类型却很难充分描述。由于没有有效的方式描绘这些复合结构，因此也没有办法对它们使用传统的操作符。要解决这个问题，只需要通过一个本质上任意的标识符（label）引用指针，这种方式被称为资源。 在zval中，对于resource，lval作为指针来使用，直接指向资源所在的地址。Resource可以是任意的复合结构，我们熟悉的mysqli、fsock、memcached等都是资源。 如何使用资源：注册：对于一个自定义的数据类型，要想将它作为资源。首先需要进行注册，zend会为它分配全局唯一标示。获取一个资源变量：对于资源，zend维护了一个id-&gt;实际数据的hash_tale。对于一个resource，在zval中只记录了它的id。fetch的时候通过id在hash_table中找到具体的值返回。资源销毁：资源的数据类型是多种多样的。Zend本身没有办法销毁它。因此需要用户在注册资源的时候提供销毁函数。当unset资源时，zend调用相应的函数完成析构。同时从全局资源表中删除它。 资源可以长期驻留，不只是在所有引用它的变量超出作用域之后，甚至是在一个请求结束了并且新的请求产生之后。这些资源称为持久资源，因为它们贯通SAPI的整个生命周期持续存在，除非特意销毁。很多情况下，持久化资源可以在一定程度上提高性能。比如我们常见的mysql_pconnect ,持久化资源通过pemalloc分配内存，这样在请求结束的时候不会释放。对zend来说，对两者本身并不区分。 PHP中的局部变量和全局变量是如何实现的？对于一个请求，任意时刻PHP都可以看到两个符号表(symbol_table和active_symbol_table)，其中前者用来维护全局变量。后者是一个指针，指向当前活动的变量符号表，当程序进入到某个函数中时，zend就会为它分配一个符号表x同时将active_symbol_table指向a。通过这样的方式实现全局、局部变量的区分。 获取变量值：PHP的符号表是通过hash_table实现的，对于每个变量都分配唯一标识，获取的时候根据标识从表中找到相应zval返回。 函数中使用全局变量：在函数中，我们可以通过显式申明global来使用全局变量。在active_symbol_table中创建symbol_table中同名变量的引用，如果symbol_table中没有同名变量则会先创建。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>底层机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第五篇——学习笔记整理]]></title>
    <url>%2F2018%2F11%2F24%2FPHP%E7%AC%AC%E4%BA%94%E7%AF%87%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[学习笔记，日志记录…… GET &amp;&amp; POST GET POST 不关心请求数据的来源，用超全局变量 $_REQUEST 内置函数strpos在一个字符串中搜索另外一个字符串,返回相对于开头的位置或者FALSE。 strtoupper — 将字符串转化为大写strlen — 获取字符串长度 旧的 $HTTP_*_VARS 数组从 PHP 5.4.0 开始将不再有效。 PHP » 4.1.0 版本引入了如下超全局数组变量： $_GET、$_POST、$_COOKIE、 $_SERVER、$_FILES、$_ENV、 $_REQUEST 以及 $_SESSION。 外部变量不再被默认注册为全局变量。也就是说，从 PHP » 4.2.0 版开始，php.ini 中的设置选项 register_globals 默认值变成了 off。建议用以上提到的超全局数组变量来访问这些值。但可能老的脚本、书籍以及教程都可能建立在该设置为 on 的基础上。如果该选项被设置为 on，则可以在 URL http://www.example.com/foo.php?id=42 中直接使用变量 $id。但不管被设置为 on 还是 off，$_GET[‘id’] 一直有效。 HTML混合12345678910111213&lt;?php if (strpos($_SERVER['HPPT_USER_AGENT'], 'MSIE') !== false) &#123;?&gt;&lt;h3&gt;strpos() 肯定没有返回假 (FALSE)&lt;/h3&gt;&lt;p&gt;正在使用 Internet Explorer&lt;/p&gt;&lt;?php &#125; else &#123;?&gt;&lt;h3&gt;strpos() 肯定返回假 (FALSE)&lt;/h3&gt;&lt;center&gt;&lt;b&gt;没有使用 Internet Explorer&lt;/b&gt;&lt;/center&gt;&lt;?php &#125;?&gt; 表单123456789101112131415161718html&lt;form action="index.php" method="post"&gt;&lt;p&gt;姓名: &lt;input type="text" name="name" /&gt;&lt;/p&gt;&lt;p&gt;年龄: &lt;input type="text" name="age" /&gt;&lt;/p&gt;&lt;p&gt;&lt;input type="submit" /&gt;&lt;/p&gt;&lt;/form&gt;php你好, &lt;?php // htmlspecialchars() 使得 HTML 之中的特殊字符被正确的编码，从而不会被使用者在页面注入 HTML 标签或者 Javascript 代码echo htmlspecialchars($_POST['name']);?&gt;。你&lt;?php echo (int)$_POST['age'];?&gt; 岁了。 数组12345678910$arr1 = [1,'b' =&gt;2,3];$arr2 = array('a' =&gt; 10);var_dump($arr1);$arr3 = ['a' =&gt; 1, 'b' =&gt; 2, 'c' =&gt; 3];$arr3['d'] = 4; // 增$arr3['b'] = 22; // 改unset($arr3['c']); // 删echo $arr3['d']; // 查var_dump($arr3);]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHP第四篇——入门基础总结]]></title>
    <url>%2F2018%2F11%2F23%2FPHP%E7%AC%AC%E5%9B%9B%E7%AF%87%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[接触PHP已经有一周了，说没有收获也有一点收获，说有收获却不知道收获了什么，可能只是对语法的了解吧，因为工作的原因，项目进度的原因，只能每天晚上熬夜回来学习，或者公司偶尔休息一下的时候，看两篇文章，这样进度确实蛮，不过我一定会每天抽一定的时间来学好它，就跟当初学习iOS一样。 这一周，主要是在学习和总结之前了解过的东西，比如PHP语法，常见的一些区别或者注意点，所以整理了一下，既能了解自己的学习进度，又方便以后回过头来查阅，毕竟自己的东西比网上找100片文章都有用。 并没有对这一周所有学习的东西整理，只是一小部分，或者突然想到了就记录下来的，有错误或者可以优化的地方欢迎指出，我们一起讨论，本人一直做iOS开发，对学习东西有一定的要求，PHP目前还是小白，希望不要喷我😂😉 PHP入门基础总结“”&amp;’’一般情况下两者是通用的.但双引号内部变量会解析,单引号则不解析. 所以如果内部只有纯字符串的时候,用单引号(速度快),内部有别的东西(如变量)的时候,用双号引更好点. 可以这么理解 当双引号中包含变量时，变量会与双引号中的内容连接在一起； 当单引号中包含变量时，变量会被当做字符串输出。 echo&amp;printecho可以输出多个字符串 print只能输出一个字符串，它可以表现得像一个函数 echo的效率相对比较快！ 总结： echo 命令和print命令相同，没有区别 echo 函数和print函数有区别。 echo() 无返回值，与echo命令相同 print() 有返回值，成功，返1，false,返0. printf() 和sprintf()类似，均为格式化输出，不同的是前者输出到标准输出，后者输出到变量 var_dump()&amp;print_r()var_dump():此函数显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。 print_r():显示关于一个变量的易于理解的信息。如果给出的是 string、integer 或 float，将打印变量值本身。如果给出的是 array，将会按照一定格式显示键和元素。object 与数组类似。 记住，print_r() 将把数组的指针移到最后边。 print_r和var_dump都能输出数组和对象，但print_r对布尔型的输出不太明显；var_dump输出比较详细，一般调试时用得多。 注意：PHP区分大小写，但是是一种弱类型的语言 获取消耗内存：memory_get_usage() 数据类型1.标量数据类型:BOOL型,整型，浮点型，字符串型。 注意1：BOOL值非零就是真，PHP中返回1，如果是假的话什么也不输出。 注意2：字符串中字符和字节一样。字符串型可以用三种方法定义：单引号形式、双引号形式和Heredoc结构形式:&lt;&lt;&lt;iCocos 长字符串 iCocos; 2.复合变量：array（数组）和 object（对象） 数组是一组数据的集合，他把一系列数据组成起来，形成一个可以操作的整体。数组中可以包括很多数据，例如：标量数据、数组，对象、资源以及 PHP支持的其他数据类型。 元素：数组成每一个数据成为元素；索引：每一个元素对应的唯一编码。索引只能由数字或字符串组成。 在编程语言中用到的方法有：面向对象 和 面向过程。在PHP中，用户可以自由使用这两种方法。在PHP中可以自由使用这两种方式。 3.特殊数据类型：resource（资源）和 null（空值） 资源是由专门的函数来建立和使用的，它是一种特殊的数据类型，并由程序员分配。在使用资源时，要及时的释放不需要的资源，如果忘记释放资源，系统自动启动垃圾回收机制，避免内存消耗殆尽。 控制顾名思义，表示没有为该变量设置任何值。另外，空值（null）不区分大小写，null 和 NULL 效果是一样的：没有赋值，被赋值为 null，被 unset() 函数处理过的变量 文件操作：fopen()-&gt;feof()-&gt;fgets()-&gt;fclose(); 系统常量：（1）__FILE__ :php程序文件名。它可以帮助我们获取当前文件在服务器的物理位置。 （2）__LINE__ :PHP程序文件行数。它可以告诉我们，当前代码在第几行。 （3）PHP_VERSION:当前解析器的版本号。它可以告诉我们当前PHP解析器的版本号，我们可以提前知道我们的PHP代码是否可被该PHP解析器解析。 （4）PHP_OS：执行当前PHP版本的操作系统名称。它可以告诉我们服务器所用的操作系统名称，我们可以根据该操作系统优化我们的代码。 取常量值：直接使用常量名字define(&quot;name&quot;,value),constant(&quot;name&quot;) 判断是否被定义：defined(); 错误控制@() 遍历方式1.只取值，不取下标 foreach (数组 as 值){ //执行的任务 } 2.同时取下标和值 foreach (数组 as 下标 =&gt; 值){ //执行的任务 } 好了，在写就天亮了，至于关于PHP语法其他的基础其实跟iOS中的Objective-C大同小异，不是有句话编程的相同的嘛？还是语法是相通的，这句话其实只有真正体验一次才知道其中的含义。 下面的文章我将一步步学习并整理1.数组 2.函数 3.类与对象 4.字符串操作相关 5.正则表达式 6.会话控制 7.文件系统 8.日期与实践 9.图形图像操作 10.异常处理 11.数据操作 12.JSON和XML区别，应用与总结 13.Get和POST区别，应用于总结 14.PHP结合JavaScript 15.PHP中的框架介绍与简单使用：ThinkPHP，Yii，laravel。。。 或许有遗漏，或者中间会加入其它个人觉得直接记录的东西，但是学习的路线是不变的！]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHP入门基础总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第三篇——语法概括]]></title>
    <url>%2F2018%2F11%2F22%2FPHP%E7%AC%AC%E4%B8%89%E7%AF%87%E2%80%94%E2%80%94%E8%AF%AD%E6%B3%95%E6%A6%82%E6%8B%AC%2F</url>
    <content type="text"><![CDATA[简单了解PHP底层之后，第一件事肯定是开始多研究PHP的语法，和实现的问题。 PHP语法概括##PHP 总结 PHP 代表 PHP: Hypertext Preprocessor PHP 文件可包含文本、HTML、JavaScript代码和 PHP 代码 PHP 代码在服务器上执行，结果以纯 HTML 形式返回给浏览器 PHP 文件的默认文件扩展名是 &quot;.php&quot; PHP能做什么PHP 可以生成动态页面内容 PHP 可以创建、打开、读取、写入、关闭服务器上的文件 PHP 可以收集表单数据 PHP 可以发送和接收 cookies PHP 可以添加、删除、修改您的数据库中的数据 PHP 可以限制用户访问您的网站上的一些页面 PHP 可以加密数据 安装如果您的服务器不支持 PHP，您必须： 安装 Web 服务器 安装 PHP 安装数据库，比如 MySQL 官方 PHP 网站（PHP.net）有 PHP 的安装说明： http://php.net/manual/en/install.php 集成开发环境推荐 WAMP：http://www.wampserver.com/ PHP基本语法PHP 脚本可以放在文档中的任何位置。 PHP 脚本以 &lt;?php 开始，以 ?&gt; 结束： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h1&gt;我的第一个 PHP 页面&lt;/h1&gt; &lt;?php echo &quot;Hello World!&quot;; // 这是一行注释 /* 这是 多行 注释 */ ?&gt; &lt;/body&gt; &lt;/html&gt; PHP 中的每个代码行都必须以分号结束 两种在浏览器输出文本的基础指令：echo 和 print。 PHP变量变量以 $ 符号开始，后面跟着变量的名称 PHP 没有声明变量的命令。 变量在您第一次赋值给它的时候被创建： PHP 是一门弱类型语言PHP 会根据变量的值，自动把变量转换为正确的数据类型。 在强类型的编程语言中，我们必须在使用变量前先声明（定义）变量的类型和名称。 PHP变量的作用域PHP 有四种不同的变量作用域： local global static parameter 局部和全局作用域在所有函数外部定义的变量，拥有全局作用域。除了函数外，全局变量可以被脚本中的任何部分访问，要在一个函数中访问一个全局变量，需要使用 global 关键字。 在 PHP 函数内部声明的变量是局部变量，仅能在函数内部访问： &lt;?php $x=5; // 全局变量 function myTest() { $y=10; // 局部变量 echo &quot;&lt;p&gt;测试变量在函数内部:&lt;p&gt;&quot;; echo &quot;变量 x 为: $x&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;变量 y 为: $y&quot;; } myTest(); echo &quot;&lt;p&gt;测试变量在函数外部:&lt;p&gt;&quot;; echo &quot;变量 x 为: $x&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;变量 y 为: $y&quot;; ?&gt; 在函数内调用函数外定义的全局变量，我们需要在函数中的变量前加上 global 关键字： &lt;?php $x=5; $y=10; function myTest() { global $x,$y; $y=$x+$y; } myTest(); echo $y; // 输出 15 ?&gt; PHP 将所有全局变量存储在一个名为 $GLOBALS[index] 的数组中。 index 保存变量的名称。这个数组可以在函数内部访问，也可以直接用来更新全局变量。 &lt;?php $x=5; $y=10; function myTest() { $GLOBALS[&apos;y&apos;]=$GLOBALS[&apos;x&apos;]+$GLOBALS[&apos;y&apos;]; } myTest(); echo $y; ?&gt; Static 作用域当一个函数完成时，它的所有变量通常都会被删除。然而，有时候您希望某个局部变量不要被删除,可以使用 static关键字 &lt;?php function myTest() { static $x=0; echo $x; $x++; } myTest(); myTest(); myTest(); ?&gt; 参数作用域参数是通过调用代码将值传递给函数的局部变量。 参数是在参数列表中声明的，作为函数声明的一部分： &lt;?php function myTest($x) { echo $x; } myTest(5); ?&gt; PHP echo 和 print 语句echo - 可以输出一个或多个字符串 print - 只允许输出一个字符串，返回值总为 1 提示：echo 输出的速度比 print 快， echo 没有返回值，print有返回值1。echo 和 print 都是一个语言结构，使用的时候可以不用加括号，也可以加上括号： echo 或 echo() print print()。 &lt;?php echo &quot;&lt;h2&gt;PHP is fun!&lt;/h2&gt;&quot;; echo &quot;Hello world!&lt;br&gt;&quot;; echo &quot;I&apos;m about to learn PHP!&lt;br&gt;&quot;; echo &quot;This&quot;, &quot; string&quot;, &quot; was&quot;, &quot; made&quot;, &quot; with multiple parameters.&quot;; print &quot;&lt;h2&gt;PHP is fun!&lt;/h2&gt;&quot;; print &quot;Hello world!&lt;br&gt;&quot;; print &quot;I&apos;m about to learn PHP!&quot;; ?&gt; 下面的实例演示了如何使用 echo 命令输出变量和字符串： &lt;?php $txt1=&quot;Learn PHP&quot;; $txt2=&quot;w3cschool.cc&quot;; $cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;); echo $txt1; echo &quot;&lt;br&gt;&quot;; echo &quot;Study PHP at $txt2&quot;; //php 双引号内部可包含变量 echo &quot;My car is a {$cars[0]}&quot;; //用大括号 显式的指定这是变量 $txt1=&quot;Learn PHP&quot;; $txt2=&quot;w3cschool.cc&quot;; $cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;); print $txt1; print &quot;&lt;br&gt;&quot;; print &quot;Study PHP at $txt2&quot;; print &quot;My car is a {$cars[0]}&quot;; ?&gt; PHP5数据类型String（字符串）, Integer（整型）, Float（浮点型）, Boolean（布尔型）, Array（数组）, Object（对象）, NULL（空值）。 字符串你可以将任何文本放在单引号和双引号中： &lt;?php $x = &quot;Hello world!&quot;; echo $x; echo &quot;&lt;br&gt;&quot;; $x = &apos;Hello world!&apos;; //单引号 包括字符串字面量 双引号包含的字符串 可包含变量 echo $x; ?&gt; 整型在以下实例中我们将测试不同的数字。 PHP var_dump() 函数返回变量的数据类型和值： ?php $x = 5985; var_dump($x); echo &quot;&lt;br&gt;&quot;; $x = -345; // 负数 var_dump($x); echo &quot;&lt;br&gt;&quot;; $x = 0x8C; // 十六进制数 var_dump($x); echo &quot;&lt;br&gt;&quot;; $x = 047; // 八进制数 var_dump($x); ?&gt; 浮点型&lt;?php $x = 10.365; var_dump($x); echo &quot;&lt;br&gt;&quot;; $x = 2.4e3; var_dump($x); echo &quot;&lt;br&gt;&quot;; $x = 8E-5; var_dump($x); ?&gt; 布尔型布尔型可以是 TRUE 或 FALSE。 数组数组可以在一个变量中存储多个值 &lt;?php $cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;); var_dump($cars); ?&gt; 对象在 PHP 中，对象必须声明。 首先，你必须使用class关键字声明类对象。类是可以包含属性和方法的结构。然后我们在类中定义数据类型，然后在实例化的类中使用数据类型： &lt;?php class Car { var $color; function Car($color=&quot;green&quot;) { $this-&gt;color = $color; } function what_color() { return $this-&gt;color; } } function print_vars($obj) { foreach (get_object_vars($obj) as $prop =&gt; $val) { echo &quot;\t$prop = $val\n&quot;; } } // instantiate one object $herbie = new Car(&quot;white&quot;); // show herbie properties echo &quot;\herbie: Properties\n&quot;; print_vars($herbie); ?&gt; NULL 值NULL 值表示变量没有值。NULL 是数据类型为 NULL 的值。 &lt;?php $x=&quot;Hello world!&quot;; $x=null; var_dump($x); ?&gt; 常量常量是一个简单值的标识符。该值在脚本中不能改变。 (常量名不需要加 $ 修饰符)。 注意： 常量在整个脚本中都可以使用。 设置常量，使用 define() 函数，函数语法如下： define(string constant_name, mixed value, case_sensitive = true)该函数有三个参数: constant_name：必选参数，常量名称，即标志符。value：必选参数，常量的值。case_sensitive：可选参数，指定是否大小写敏感，设定为 true 表示不敏感。 以下实例我们创建一个 区分大小写的常量, 常量值为 “Welcome to W3CSchool.cc!”： &lt;?php define(&quot;GREETING&quot;, &quot;Welcome to W3CSchool.cc!&quot;); echo GREETING; ?&gt; 字符串函数和字符串连接&lt;?php $txt1=&quot;Hello world!&quot;; $txt2=&quot;What a nice day!&quot;; echo $txt1 . &quot; &quot; . $txt2; // 字符串连接运算符 . echo strlen(&quot;Hello world!&quot;); //获取字符串长度 echo strpos(&quot;Hello world!&quot;,&quot;world&quot;); //获取子串位置 //字符串中第一个字符的位置是 0 ?&gt; 运算符&lt;?php //其他运算符略.. //逻辑运算符 ! &amp;&amp; || and or xor //数组运算符 合并: + 比较：== != === !== $x = array(&quot;a&quot; =&gt; &quot;red&quot;, &quot;b&quot; =&gt; &quot;green&quot;); $y = array(&quot;c&quot; =&gt; &quot;blue&quot;, &quot;d&quot; =&gt; &quot;yellow&quot;); $z = $x + $y; // $x 和 $y 数组合并 var_dump($z); var_dump($x == $y); var_dump($x === $y); var_dump($x != $y); var_dump($x &lt;&gt; $y); var_dump($x !== $y); ?&gt; 流程控制语句 同js&lt;?php $t=date(&quot;H&quot;); if ($t&lt;&quot;20&quot;) { echo &quot;Have a good day!&quot;; } $t=date(&quot;H&quot;); if ($t&lt;&quot;20&quot;) { echo &quot;Have a good day!&quot;; } else { echo &quot;Have a good night!&quot;; } $t=date(&quot;H&quot;); if ($t&lt;&quot;10&quot;) { echo &quot;Have a good morning!&quot;; } else if ($t&lt;&quot;20&quot;) { echo &quot;Have a good day!&quot;; } else { echo &quot;Have a good night!&quot;; } $favcolor=&quot;red&quot;; switch ($favcolor) { case &quot;red&quot;: echo &quot;Your favorite color is red!&quot;; break; case &quot;blue&quot;: echo &quot;Your favorite color is blue!&quot;; break; case &quot;green&quot;: echo &quot;Your favorite color is green!&quot;; break; default: echo &quot;Your favorite color is neither red, blue, or green!&quot;; } //循环 $i=1; while($i&lt;=5) { echo &quot;The number is &quot; . $i . &quot;&lt;br&gt;&quot;; $i++; } $i=1; do { $i++; echo &quot;The number is &quot; . $i . &quot;&lt;br&gt;&quot;; } while ($i&lt;=5); for ($i=1; $i&lt;=5; $i++) { echo &quot;The number is &quot; . $i . &quot;&lt;br&gt;&quot;; } $x=array(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;); foreach ($x as $value) { echo $value . &quot;&lt;br&gt;&quot;; } ?&gt; 数组&lt;?php $cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;); //数组定义 数值数组 echo &quot;I like &quot; . $cars[0] . &quot;, &quot; . $cars[1] . &quot; and &quot; . $cars[2] . &quot;.&quot;; //访问数组元素 //数组长度count() $cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;); echo count($cars); //count() 函数用于返回数组的长度 //遍历数值数组 $cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;); $arrlength=count($cars); for($x=0;$x&lt;$arrlength;$x++) { echo $cars[$x]; echo &quot;&lt;br&gt;&quot;; } $age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);//定义关联数组 echo &quot;Peter is &quot; . $age[&apos;Peter&apos;] . &quot; years old.&quot;; //遍历关联数组 $age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;); foreach($age as $x=&gt;$x_value) { echo &quot;Key=&quot; . $x . &quot;, Value=&quot; . $x_value; echo &quot;&lt;br&gt;&quot;; } ?&gt; 数组排序PHP - 数组排序函数 sort() - 对数组进行升序排列rsort() - 对数组进行降序排列asort() - 根据关联数组的值，对数组进行升序排列ksort() - 根据关联数组的键，对数组进行升序排列arsort() - 根据关联数组的值，对数组进行降序排列krsort() - 根据关联数组的键，对数组进行降序排列 //sort() $cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;); sort($cars); $clength=count($cars); for($x=0;$x&lt;$clength;$x++) { echo $cars[$x]; echo &quot;&lt;br&gt;&quot;; } //rsort() $cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;); rsort($cars); //asort() arsort() 关联数组排序 value $age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;); asort($age); arsort($age); //ksort() krsort() 关联数组排序 key $age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;); ksort($age); krsort($age); ?&gt; 超级全局变量PHP中预定义了几个超级全局变量（superglobals） ，这意味着它们在一个脚本的全部作用域中都可用。 $GLOBALS $_SERVER $_REQUEST $_POST $_GET $_COOKIE $_FILES $_ENV $_SESSION $GLOBAL 是一个包含了全部变量的全局组合数组。变量的名字就是数组的键。 &lt;?php $x = 75; $y = 25; function addition() { $GLOBALS[&apos;z&apos;] = $GLOBALS[&apos;x&apos;] + $GLOBALS[&apos;y&apos;]; } addition(); echo $z; ?&gt; $_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目； &lt;?php echo $_SERVER[&apos;PHP_SELF&apos;]; // /try/demo_source/demo_global_server.php echo &quot;&lt;br&gt;&quot;; echo $_SERVER[&apos;SERVER_NAME&apos;]; // w3cschool.cc echo &quot;&lt;br&gt;&quot;; echo $_SERVER[&apos;HTTP_HOST&apos;]; // www.w3cschool.cc echo &quot;&lt;br&gt;&quot;; echo $_SERVER[&apos;HTTP_REFERER&apos;]; //来由 echo &quot;&lt;br&gt;&quot;; echo $_SERVER[&apos;HTTP_USER_AGENT&apos;]; //浏览器 echo &quot;&lt;br&gt;&quot;; echo $_SERVER[&apos;SCRIPT_NAME&apos;]; // /try/demo_source/demo_global_server.php //另外$_SERVER对象还包括 SERVER_ADDR, SERVER_PROTOCOL ,REQUEST_METHOD..等属性 ?&gt; $_REQUEST 用于收集HTML表单提交的数据。 &lt;html&gt; &lt;body&gt; &lt;form method=&quot;post&quot; action=&quot;&lt;?php echo $_SERVER[&apos;PHP_SELF&apos;];?&gt;&quot;&gt; Name: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;?php $name = $_REQUEST[&apos;fname&apos;]; echo $name; ?&gt; &lt;/body&gt; &lt;/html&gt; $_POST 被广泛应用于收集表单数据，在HTML form标签的指定该属性：”method=”post” &lt;html&gt; &lt;body&gt; &lt;!--页面post给自己--&gt; &lt;form method=&quot;post&quot; action=&quot;&lt;?php echo $_SERVER[&apos;PHP_SELF&apos;];?&gt;&quot;&gt; Name: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;?php $name = $_POST[&apos;fname&apos;]; echo $name; ?&gt; &lt;/body&gt; &lt;/html&gt; $_GET 同样被广泛应用于收集表单数据，在HTML form标签的指定该属性：”method=”get”。 $_GET 也可以收集URL中发送的数据。 &lt;html&gt; &lt;body&gt; &lt;a href=&quot;test_get.php?subject=PHP&amp;web=w3cschool.cc&quot;&gt;Test $GET&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; //test_get.php &lt;html&gt; &lt;body&gt; &lt;?php echo &quot;Study &quot; . $_GET[&apos;subject&apos;] . &quot; at &quot; . $_GET[&apos;web&apos;]; ?&gt; &lt;/body&gt; &lt;/html&gt; PHP 函数PHP 的真正威力源自于它的函数。 在 PHP 中，提供了超过 1000 个内建的函数。 &lt;html&gt; &lt;body&gt; &lt;?php function writeName() { echo &quot;Kai Jim Refsnes&quot;; } echo &quot;My name is &quot;; writeName(); //函数传参 function writeName($fname,$punctuation) { echo $fname . &quot; Refsnes&quot; . $punctuation . &quot;&lt;br&gt;&quot;; } echo &quot;My name is &quot;; writeName(&quot;Kai Jim&quot;,&quot;.&quot;); echo &quot;My sister&apos;s name is &quot;; //函数返回值 function add($x,$y) { $total=$x+$y; return $total; } echo &quot;1 + 16 = &quot; . add(1,16); ?&gt; &lt;/body&gt; &lt;/html&gt; 魔术变量有八个魔术常量它们的值随着它们在代码中的位置改变而改变。 _LINE__ 文件中的当前行号。FILE 文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。DIR 文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。FUNCTION 函数名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。 简单使用 &lt;?php function test() { echo &apos;函数名为：&apos; . __FUNCTION__ ; } test(); ?&gt; CLASS 类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。 在 PHP 4 中该值总是小写字母的。类名包括其被声明的作用区域（例如 Foo\Bar）。注意自 PHP 5.4 起 CLASS 对 trait 也起作用。当用在 trait 方法中时，CLASS 是调用 trait 方法的类的名字。 &lt;?php class test { function _print() { echo &apos;类名为：&apos; . __CLASS__ . &quot;&lt;br&gt;&quot;; echo &apos;函数名为：&apos; . __FUNCTION__ ; } } $t = new test(); $t-&gt;_print(); ?&gt; TRAIT Trait 的名字（PHP 5.4.0 新加）。自 PHP 5.4.0 起，PHP 实现了代码复用的一个方法，称为 traits。 Trait 名包括其被声明的作用区域（例如 Foo\Bar）。 从基类继承的成员被插入的 SayWorld Trait 中的 MyHelloWorld 方法所覆盖。其行为 MyHelloWorld 类中定义的方法一致。优先顺序是当前类中的方法会覆盖 trait 方法，而 trait 方法又覆盖了基类中的方法。 &lt;?php class Base { public function sayHello() { echo &apos;Hello &apos;; } } trait SayWorld { public function sayHello() { parent::sayHello(); echo &apos;World!&apos;; } } class MyHelloWorld extends Base { use SayWorld; } $o = new MyHelloWorld(); $o-&gt;sayHello(); ?&gt; METHOD 类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写） &lt;?php function test() { echo &apos;函数名为：&apos; . __METHOD__ ; } test(); ?&gt; NAMESPACE 当前命名空间的名称（区分大小写）。此常量是在编译时定义的（PHP 5.3.0 新增）。 &lt;?php namespace MyProject; echo &apos;命名空间为：&quot;&apos;, __NAMESPACE__, &apos;&quot;&apos;; // 输出 &quot;MyProject&quot; ?&gt; 命名空间PHP 命名空间(namespace)是在PHP 5.3中加入的，如果你学过C#和Java，那命名空间就不算什么新事物。 不过在PHP当中还是有着相当重要的意义。 PHP 命名空间可以解决以下两类问题： 用户代码与PHP内部的类/函数/常量之间的名字冲突。 创建别名（或简短）的名称，提高源代码的可读性。 默认情况下，所有常量、类和函数名都放在全局空间下，就和PHP支持命名空间之前一样。如果一个文件中包含命名空间，它必须在其它所有代码之前声明命名空间 &lt; ?php // 定义代码在 &apos;MyProject&apos; 命名空间中 namespace MyProject; // ... 代码 ... //也可以在同一个文件中定义不同的命名空间代码 namespace MyProject1; // MyProject1 命名空间中的PHP代码 namespace MyProject2; // MyProject2 命名空间中的PHP代码 // 另一种语法 namespace MyProject3 { // MyProject3 命名空间中的PHP代码 } ?&gt; 在声明命名空间之前唯一合法的代码是用于定义源文件编码方式的 declare 语句。所有非 PHP 代码包括空白符都不能出现在命名空间的声明之前。 &lt;?php declare(encoding=&apos;UTF-8&apos;); //定义多个命名空间和不包含在命名空间中的代码 namespace MyProject { const CONNECT_OK = 1; class Connection { /* ... */ } function connect() { /* ... */ } } namespace { // 全局代码 session_start(); $a = MyProject\connect(); echo MyProject\Connection::start(); } ?&gt; 以下代码会出现语法错误： &lt;html&gt; &lt;?php namespace MyProject; // 命名空间前出现了“&lt;html&gt;” 会致命错误 - 命名空间必须是程序脚本的第一条语句 ?&gt; 子命名空间&lt;?php namespace MyProject\Sub\Level; //声明分层次的单个命名空间 //创建了常量 MyProject\Sub\Level\CONNECT_OK， //类 MyProject\Sub\Level\Connection //和函数 MyProject\Sub\Level\Connect。 const CONNECT_OK = 1; class Connection { /* ... */ } function Connect() { /* ... */ } ?&gt; 命名空间使用PHP 命名空间中的类名可以通过三种方式引用： 非限定名称，或不包含前缀的类名称，例如 $a=new foo(); 或 foo::staticmethod();。如果当前命名空间是 currentnamespace，foo 将被解析为 currentnamespace\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，则 foo 会被解析为foo。 警告：如果命名空间中的函数或常量未定义，则该非限定的函数名称或常量名称会被解析为全局函数名称或常量名称。~~无命名空间前缀的引用，默认在当前命名空间查找，然后到全局命名空间找 限定名称,或包含前缀的名称，例如 $a = new subnamespace\foo(); 或 subnamespace\foo::staticmethod();。如果当前的命名空间是 currentnamespace，则 foo 会被解析为 currentnamespace\subnamespace\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，foo 会被解析为subnamespace\foo。 ~~带相对命名空间前缀的(类似相对路径)引用，自动在开头添加调用代码所处的命名空间 完全限定名称，或包含了全局前缀操作符的名称，例如， $a = new \currentnamespace\foo(); 或 \currentnamespace\foo::staticmethod();。在这种情况下，foo 总是被解析为代码中的文字名(literal name)currentnamespace\foo。~~带绝对命名空间前缀的引用(类似绝对路径) 引用路径已明确 不用查找 file1.php &lt;?php namespace Foo\Bar\subnamespace; const FOO = 1; function foo() {} class foo { static function staticmethod() {} } ?&gt; file2.php &lt;?php namespace Foo\Bar; include &apos;file1.php&apos;; const FOO = 2; function foo() {} class foo { static function staticmethod() {} } /* 非限定名称 */ foo(); // 解析为函数 Foo\Bar\foo foo::staticmethod(); // 解析为类 Foo\Bar\foo的静态方法staticmethod。 echo FOO; // resolves to constant Foo\Bar\FOO /* 限定名称 */ subnamespace\foo(); // 解析为函数 Foo\Bar\subnamespace\foo subnamespace\foo::staticmethod(); // 解析为类 Foo\Bar\subnamespace\foo, // 以及类的方法 staticmethod echo subnamespace\FOO; // 解析为常量 Foo\Bar\subnamespace\FOO /* 完全限定名称 */ \Foo\Bar\foo(); // 解析为函数 Foo\Bar\foo \Foo\Bar\foo::staticmethod(); // 解析为类 Foo\Bar\foo, 以及类的方法 staticmethod echo \Foo\Bar\FOO; // 解析为常量 Foo\Bar\FOO ?&gt; 在命名空间内部访问全局类、函数和常量： &lt;?php namespace Foo; function strlen() {} const INI_ALL = 3; class Exception {} $a = \strlen(&apos;hi&apos;); // 调用全局函数strlen $b = \INI_ALL; // 访问全局常量 INI_ALL $c = new \Exception(&apos;error&apos;); // 实例化全局类 Exception ?&gt; 命名空间和动态语言特征PHP 命名空间的实现受到其语言自身的动态特征的影响。因此，如果要将下面的代码转换到命名空间中，动态访问元素。 //example.php &lt;?php class classname { function __construct() { echo __METHOD__,&quot;\n&quot;; } } function funcname() { echo __FUNCTION__,&quot;\n&quot;; } const constname = &quot;global&quot;; $a = &apos;classname&apos;; $obj = new $a; // prints classname::__construct $b = &apos;funcname&apos;; $b(); // prints funcname echo constant(&apos;constname&apos;), &quot;\n&quot;; // prints global ?&gt; &lt;?php namespace namespacename; class classname { function __construct() { echo __METHOD__,&quot;\n&quot;; } } function funcname() { echo __FUNCTION__,&quot;\n&quot;; } const constname = &quot;namespaced&quot;; include &apos;example1.php&apos;;//全局命名空间和某个命名空间有相同类 函数 和 常量 分别区别访问 $a = &apos;classname&apos;; $obj = new $a; // prints classname::__construct $b = &apos;funcname&apos;; $b(); // prints funcname echo constant(&apos;constname&apos;), &quot;\n&quot;; // prints global /* note that if using double quotes, &quot;\\namespacename\\classname&quot; must be used */ $a = &apos;\namespacename\classname&apos;; $obj = new $a; // prints namespacename\classname::__construct $a = &apos;namespacename\classname&apos;; $obj = new $a; // also prints namespacename\classname::__construct $b = &apos;namespacename\funcname&apos;; $b(); // prints namespacename\funcname $b = &apos;\namespacename\funcname&apos;; $b(); // also prints namespacename\funcname echo constant(&apos;\namespacename\constname&apos;), &quot;\n&quot;; // prints namespaced echo constant(&apos;namespacename\constname&apos;), &quot;\n&quot;; // also prints namespaced ?&gt; namespace关键字和NAMESPACE常量&lt;?php namespace MyProject; echo &apos;&quot;&apos;, __NAMESPACE__, &apos;&quot;&apos;; // 输出 &quot;MyProject&quot; ?&gt; &lt;?php echo &apos;&quot;&apos;, __NAMESPACE__, &apos;&quot;&apos;; // 输出 &quot;&quot; ?&gt; 使用NAMESPACE动态创建名称 &lt;?php namespace MyProject; function get($classname) { $a = __NAMESPACE__ . &apos;\\&apos; . $classname; return new $a; } ?&gt; 关键字 namespace 可用来显式访问当前命名空间或子命名空间中的元素。它等价于类中的 self 操作符。 &lt;?php namespace MyProject; use blah\blah as mine; // see &quot;Using namespaces: importing/aliasing&quot; blah\mine(); // calls function blah\blah\mine() namespace\blah\mine(); // calls function MyProject\blah\mine() namespace\func(); // calls function MyProject\func() namespace\sub\func(); // calls function MyProject\sub\func() namespace\cname::method(); // calls static method &quot;method&quot; of class MyProject\cname $a = new namespace\sub\cname(); // instantiates object of class MyProject\sub\cname $b = namespace\CONSTANT; // assigns value of constant MyProject\CONSTANT to $b ?&gt; 在PHP中，别名是通过操作符 use 来实现的. 下面是一个使用所有可能的三种导入方式的例子： 使用use操作符导入/使用别名 &lt;?php namespace foo; use My\Full\Classname as Another; // 下面的例子与 use My\Full\NSname as NSname 相同 use My\Full\NSname; // 导入一个全局类 use \ArrayObject; $obj = new namespace\Another; // 实例化 foo\Another 对象 $obj = new Another; // 实例化 My\Full\Classname 对象 NSname\subns\func(); // 调用函数 My\Full\NSname\subns\func $a = new ArrayObject(array(1)); // 实例化 ArrayObject 对象 // 如果不使用 &quot;use \ArrayObject&quot; ，则实例化一个 foo\ArrayObject 对象 ?&gt; 一行中包含多个use语句 &lt;?php use My\Full\Classname as Another, My\Full\NSname; $obj = new Another; // 实例化 My\Full\Classname 对象 NSname\subns\func(); // 调用函数 My\Full\NSname\subns\func ?&gt; &lt;p&gt;导入操作是在编译执行的，但动态的类名称、函数名称或常量名称则不是。&lt;/p&gt; &lt;ol&gt; &lt;li&gt;导入和动态名称&lt;/li&gt; &lt;/ol&gt; &lt;pre&gt; &lt;?php use My\Full\Classname as Another, My\Full\NSname; $obj = new Another; // 实例化一个 My\Full\Classname 对象 $a = &apos;Another&apos;; $obj = new $a; // 实际化一个 Another 对象 ?&gt; 导入和动态名称 &lt;?php use My\Full\Classname as Another, My\Full\NSname; $obj = new Another; // 实例化一个 My\Full\Classname 对象 $a = &apos;Another&apos;; $obj = new $a; // 实际化一个 Another 对象 ?&gt; 另外，导入操作只影响非限定名称和限定名称。完全限定名称由于是确定的，故不受导入的影响。 导入和完全限定名称 &lt;?php use My\Full\Classname as Another, My\Full\NSname; $obj = new Another; // instantiates object of class My\Full\Classname $obj = new \Another; // instantiates object of class Another $obj = new Another\thing; // instantiates object of class My\Full\Classname\thing $obj = new \Another\thing; // instantiates object of class Another\thing ?&gt; 使用命名空间：后备全局函数/常量在一个命名空间中，当 PHP 遇到一个非限定的类、函数或常量名称时，它使用不同的优先策略来解析该名称。 类名称总是解析到当前命名空间中的名称(找不到就报错咯)。因此在访问系统内部或不包含在命名空间中的类名称时，必须使用完全限定名称函数和常量来说，如果当前命名空间中不存在该函数或常量，PHP 会退而使用全局空间中的函数或常量。 &lt;?php namespace A\B\C; class Exception extends \Exception {} $a = new Exception(&apos;hi&apos;); // $a 是类 A\B\C\Exception 的一个对象 $b = new \Exception(&apos;hi&apos;); // $b 是类 Exception 的一个对象 $c = new ArrayObject; // 致命错误, 找不到 A\B\C\ArrayObject 类 ?&gt; 全局空间如果没有定义任何命名空间，所有的类与函数的定义都是在全局空间，与 PHP 引入命名空间概念前一样。在名称前加上前缀 \ 表示该名称是全局空间中的名称，即使该名称位于其它的命名空间中时也是如此。 &lt;?php namespace A\B\C; /* 这个函数是 A\B\C\fopen */ function fopen() { /* ... */ $f = \fopen(...); // 调用全局的fopen函数 return $f; } ?&gt; 命名空间的顺序 略.. PHP文件处理打开文件 $file = fopen($fname, mode) //文件的名称, 打开模式 r 只读。在文件的开头开始。 r+ 读/写。在文件的开头开始。 w 只写。打开并清空文件的内容；如果文件不存在，则创建新文件。 w+ 读/写。打开并清空文件的内容；如果文件不存在，则创建新文件。 a 追加。打开并向文件末尾进行写操作，如果文件不存在，则创建新文件。 a+ 读/追加。通过向文件末尾写内容，来保持文件内容。 x 只写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。 x+ 读/写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。 注释：如果 fopen() 函数无法打开指定文件，则返回 0 (false)。 &lt;?php //打开文件 $file = fopen(&quot;welcome.txt&quot;, &quot;r&quot;) or exit(&quot;Unable to open file!&quot;); //Output a line of the file until the end is reached //是否到达文件末尾 while(!feof($file)) { echo fgets($file). &quot;&lt;br&gt;&quot;; //逐行读取文件 //echo fgetc($file); //逐字符读取 } //关闭文件 fclose($file); ?&gt; Filesystem 函数basename() 返回路径中的文件名部分。 chgrp() 改变文件组。 chmod() 改变文件模式。 chown() 改变文件所有者。 clearstatcache() 清除文件状态缓存。 copy() 复制文件。 delete() 参见 unlink() 或 unset() dirname() 返回路径中的目录名称部分。 disk_free_space() 返回目录的可用空间。 disk_total_space() 返回一个目录的磁盘总容量。 diskfreespace() disk_free_space() 的别名。 fclose() 关闭打开的文件。 feof() 测试文件指针是否到了文件末尾。 fflush() 向打开的文件刷新缓冲输出。 fgetc() 从打开的文件中返回字符。 fgetcsv() 从打开的文件中解析一行，校验 CSV 字段。 fgets() 从打开的文件中返回一行。 fgetss() 从打开的文件中返回一行，并过滤掉 HTML 和 PHP 标签。 file() 把文件读入一个数组中。 file_exists() 检查文件或目录是否存在。 file_get_contents() 把文件读入字符串。~~获取文件内容 file_put_contents() 把字符串写入文件。~~写入文件内容 fileatime() 返回文件的上次访问时间。 filectime() 返回文件的上次修改时间。 filegroup() 返回文件的组 ID。 fileinode() 返回文件的 inode 编号。 filemtime() 返回文件内容的上次修改时间。 fileowner() 返回文件的用户 ID （所有者）。 fileperms() 返回文件的权限。 filesize() 返回文件大小。 filetype() 返回文件类型。 flock() 锁定或释放文件。 fnmatch() 根据指定的模式来匹配文件名或字符串。 fopen() 打开一个文件或 URL。 fpassthru() 从打开的文件中读数据，直到文件末尾（EOF），并向输出缓冲写结果。 fputcsv() 把行格式化为 CSV 并写入一个打开的文件中。 fputs() fwrite() 的别名。 fread() 读取打开的文件。 fscanf() 根据指定的格式对输入进行解析。 fseek() 在打开的文件中定位。 fstat() 返回关于一个打开的文件的信息。 ftell() 返回在打开文件中的当前位置。 ftruncate() 把打开文件截断到指定的长度。 fwrite() 写入打开的文件。 glob() 返回一个包含匹配指定模式的文件名/目录的数组。 is_dir() 判断文件是否是一个目录。 is_executable() 判断文件是否可执行。 is_file() 判断文件是否是常规的文件。 is_link() 判断文件是否是连接。 is_readable() 判断文件是否可读。 is_uploaded_file() 判断文件是否是通过 HTTP POST 上传的。 is_writable() 判断文件是否可写。 is_writeable() is_writable() 的别名。 lchgrp() 改变符号连接的组所有权。 lchown() 改变符号连接的用户所有权。 link() 创建一个硬连接。 linkinfo() 返回有关一个硬连接的信息。 lstat() 返回关于文件或符号连接的信息。 mkdir() 创建目录。 move_uploaded_file() 把上传的文件移动到新位置。 parse_ini_file() 解析一个配置文件。 parse_ini_string() 解析一个配置字符串。 pathinfo() 返回关于文件路径的信息。 pclose() 关闭由 popen() 打开的进程。 popen() 打开一个进程。 readfile() 读取一个文件，并写入到输出缓冲。 readlink() 返回符号连接的目标。 realpath() 返回绝对路径名。 realpath_cache_get() 返回高速缓存条目。 realpath_cache_size() 返回高速缓存大小。 rename() 重命名文件或目录。 rewind() 倒回文件指针的位置。 rmdir() 删除空的目录。 set_file_buffer() 设置已打开文件的缓冲大小。 stat() 返回关于文件的信息。 symlink() 创建符号连接。 tempnam() 创建唯一的临时文件。 tmpfile() 创建唯一的临时文件。 touch() 设置文件的访问和修改时间。 umask() 改变文件的文件权限。 unlink() 删除文件。 PHP JSONjson_encode 对变量进行 JSON 编码 json_decode 对 JSON 格式的字符串进行解码，转换为 PHP 变量 json_last_error 返回最后发生的错误 string json_encode ( $value [, $options = 0 ] ) 参数value: 要编码的值。该函数只对 UTF-8 编码的数据有效。options:由以下常量组成的二进制掩码：JSON_HEX_QUOT, JSON_HEX_TAG, JSON_HEX_AMP, JSON_HEX_APOS, JSON_NUMERIC_CHECK,JSON_PRETTY_PRINT, JSON_UNESCAPED_SLASHES, JSON_FORCE_OBJECT &lt;?php $arr = array(&apos;a&apos; =&gt; 1, &apos;b&apos; =&gt; 2, &apos;c&apos; =&gt; 3, &apos;d&apos; =&gt; 4, &apos;e&apos; =&gt; 5); echo json_encode($arr); class Emp { public $name = &quot;&quot;; public $hobbies = &quot;&quot;; public $birthdate = &quot;&quot;; } $e = new Emp(); $e-&gt;name = &quot;sachin&quot;; $e-&gt;hobbies = &quot;sports&quot;; $e-&gt;birthdate = date(&apos;m/d/Y h:i:s a&apos;, &quot;8/5/1974 12:20:03 p&quot;); $e-&gt;birthdate = date(&apos;m/d/Y h:i:s a&apos;, strtotime(&quot;8/5/1974 12:20:03&quot;)); echo json_encode($e); ?&gt; mixed json_decode ($json [,$assoc = false [, $depth = 512 [, $options = 0 ]]]) 参数json_string: 待解码的 JSON 字符串，必须是 UTF-8 编码数据 assoc: 当该参数为 TRUE 时，将返回数组，FALSE 时返回对象。 depth: 整数类型的参数，它指定递归深度 options: 二进制掩码，目前只支持 JSON_BIGINT_AS_STRING 。 &lt;?php $json = &apos;{&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:4,&quot;e&quot;:5}&apos;; var_dump(json_decode($json)); var_dump(json_decode($json, true)); ?&gt;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>语法小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第二篇——理论常识：HTTP-HTTPS]]></title>
    <url>%2F2018%2F11%2F21%2FPHP%E7%AC%AC%E4%BA%8C%E7%AF%87%E2%80%94%E2%80%94%E7%90%86%E8%AE%BA%E5%B8%B8%E8%AF%86%EF%BC%9AHTTP-HTTPS%2F</url>
    <content type="text"><![CDATA[简介 超文本传输协议（HTTP，HyperText Transfer Protocol) 是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。 HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer） 是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 HTTPS句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。 TCP/IPHTTP是一个基于TCP的协议,而TCP是一种可靠的传输层协议. TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP/IP做传输层协议将它发到网络上。 HTTPS HTTP+加密+认证+完整性保护=HTTPS 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 HTTPS协议的主要作用可以分为两种： 一种是建立一个信息安全通道，来保证数据传输的安全； 另一种就是确认网站的真实性。 HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。 SSL/TLS SSL：（Secure Socket Layer，安全套接字层） 位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。 TLS：（Transport Layer Security，传输层安全协议） 用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。 SSL是Netscape开发的专门用于保护Web通讯的，目前版本为3.0.最新版本的TLS 1.0是IETE（工程任务组）指定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本。两者差别极小，可以理解为SSL 3.1，它是写入了RFC的。 SSL的作用 （1）、认证用户和服务器，确保数据发送到正确的客户机和服务器； （2）、加密数据以防止数据中途被窃取； （3）、维护数据的完整性，确保数据在传输过程中不被改变。 而SSL证书指的是在SSL通信中验证通信双方身份的数字文件，一般分为服务器证书和客户端证书，我们通常说的SSL证书主要指服务器证书，SSL证书由受信任的数字证书颁发机构CA（如VeriSign，GlobalSign，WoSign等），在验证服务器身份后颁发，具有服务器身份验证和数据传输加密功能，分为扩展验证型(EV)SSL证书、组织验证型(OV)SSL证书、和域名验证型（DV）SSL证书。 CA证书 CA（Certificate Authority）是负责管理和签发证书的第三方权威机构，是所有行业和公众都信任的、认可的。 CA证书，就是CA颁发的证书，可用于验证网站是否可信（针对HTTPS）、验证某文件是否可信（是否被篡改）等，也可以用一个证书来证明另一个证书是真实可信，最顶级的证书称为根证书。除了根证书（自己证明自己是可靠），其它证书都要依靠上一级的证书，来证明自己。 HTTP&amp;HTTPS区别：简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。 https协议需要到ca申请证书或自制证书。 http的信息是明文传输，https则是具有安全性的ssl加密。 http是直接与TCP进行数据传输，而https是经过一层SSL（OSI表示层），用的端口也不一样，前者是80（需要国内备案），后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 HTTP&amp;HTTPS综合区别：https://blog.csdn.net/hanjianqiang2468/article/details/52605849 注意: https加密是在传输层 https报文在被包装成tcp报文的时候完成加密的过程，无论是https的header域也好，body域也罢都是会被加密的。 当使用tcpdump或者wireshark之类的tcp层工具抓包，获取是加密的内容，而如果用应用层抓包，使用Charels(Mac)、Fildder(Windows)抓包工具，那当然看到是明文的。 握手过程HTTP三次握手 HTTP（HyperText Transfer Protocol)超文本传输协议是互联网上应用最为广泛的一种网络协议。由于信息是明文传输，所以被认为是不安全的。而关于HTTP的三次握手，其实就是使用三次TCP握手确认建立一个HTTP连接。 SYN（synchronous）是TCP/IP建立连接时使用的握手信号、Sequence number（序列号）、Acknowledge number（确认号码），三个箭头指向就代表三次握手，完成三次握手，客户端与服务器开始传送数据。 第一次握手： 客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手： 服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手： 客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 建立TCP连接时会发生:三次握手(three-way handshake) firefox &gt; nginx [SYN] 在么 nginx &gt; firefox [SYN, ACK] 在 firefox &gt; nginx [ACK] 知道了 为什么断开需要四次握手:关于四次握手的详细过程这里就不过多介绍，请自行百度，这里简单说一下需要执行的步骤，和为什么连接是三次，二断开时四次 关闭TCP连接时会发生:四次挥手(four-way handshake) firefox &gt; nginx [FIN] 我要关闭连接了 nginx &gt; firefox [ACK] 知道了,等我发完包先 nginx &gt; firefox [FIN] 我也关闭连接了 firefox &gt; nginx [ACK] 好的,知道了 解释原因： TCP建立连接要进行3次握手,而断开连接要进行4次,这是由于TCP的半关闭造成的,因为TCP连接是全双工的( 即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭,这个单方向的关闭就叫半关闭. 关闭的方法是一方完成它的数据传输后,就发送一个FIN来向另一方通告将要终止这个方向的连接.当一端收到一个FIN,它必须 通知应用层TCP连接已终止了这个方向的数据传送,发送FIN通常是应用层进行关闭的结果. 另一种解释： 这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。 补充 SYN: synchronization(同步) ACK: acknowledgement(确认:告知已收到) FIN: finish(结束) HTTPS握手： HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。具体是如何进行加密，解密，验证的，且看下图，下面的称为一次握手。 1.客户端发起HTTPS请求 2.服务端的配置 采用HTTPS协议的服务器必须要有一套数字证书，可以是自己制作或者CA证书。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用CA证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。公钥给别人加密使用，私钥给自己解密使用。 3.传送证书 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等。 4.客户端解析证书 这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值，然后用证书对该随机值进行加密。 5.传送加密信息 这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 6.服务段解密信息 服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。 7.传输加密后的信息 这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。 8.客户端解密信息 客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。 注意: HTTPS中整个握手过程第三方即使监听到了数据，也束手无策。 为什么HTTPS是安全的？ 在HTTPS握手的第四步中，如果站点的证书是不受信任的，会显示出现下面确认界面，确认了网站的真实性。另外第六和八步，使用客户端私钥加密解密，保证了数据传输的安全。 补充app与后台通信完整流程 1.建立连接：前台后台建立连接。 2.发送请求：打开连接后，app向后台发送请求。 3.发送响应：后台处理完请求后，要向app发送响应消息。 后台通过关键词：路径映射，Dispatcher分发机制等方式处理app的请求 4.断开连接：以上交互完成后可以断开连接了。 浏览器执行过程 1.首先嘛，你得在浏览器里输入要网址: 2.浏览器查找域名的IP地址 3.浏览器给web服务器发送一个HTTP请求 4.facebook服务的永久重定向响应.服务器给浏览器响应一个301永久重定向响应，这样浏览器就会问“http://www.facebook.com/” 而非“http://facebook.com/”。 5.浏览器跟踪重定向地址.浏览器知道了“http://www.facebook.com/”才是要访问的正确地址，所以它会发送另一个获取请求： 6.服务器“处理”请求.服务器接收到获取请求，然后处理并返回一个响应。 7.服务器发回一个HTML响应. 8.浏览器开始显示HTML. 9.浏览器发送获取嵌入在HTML中的对象。在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。 10.浏览器发送异步（AJAX）请求。 TCP， UDP，Socket TCP :Transmission Control Protocol，传输控制协议,是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂,但也是最安全的。 UDP : User Data Protocol，用户数据报协议。传输数据之前源端和终端不建立连接，发送端直接把数据发送到网络，接收端把消息段放在队列中，应用程序每次从队列中读一个消息段。 Socket,俗称网络套接字，本身并不是协议，而是一个调用接口，是对TCP/IP协议的封装和应用,提供了一系列方法方便开发者进行网络通讯。 TCP/IP协议是使用最早的通讯协议，它是传输层协议，主要解决数据如何在网络中传输。 Socket中又分为流模式、数据报模式、原始套接字三种模式，即Socket_STREAM,Socket_DREAME,SOCL_RAW方式。 原始套接字(SOCK_RAW)：原始套接字与标准套接字（标准套接字指的是前面介绍的流套接字和数据报套接字）的区别在于: 原始套接字可以读写内核没有处理的IP数据包， 流套接字: 只能读取TCP协议的数据， 数据报套接字: 只能读取UDP协议的数据。 因此，如果要访问其他协议发送数据必须使用原始套接字。]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>HTTP-&gt;HTTPS</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP第一篇——工具集选]]></title>
    <url>%2F2018%2F11%2F20%2FPHP%E7%AC%AC%E4%B8%80%E7%AF%87%E2%80%94%E2%80%94%E5%B7%A5%E5%85%B7%E9%9B%86%E9%80%89%2F</url>
    <content type="text"><![CDATA[关于PHP环境搭建，我相信网上到处一大丢，而且都将的很不错，只是要细心按步骤来，这里就不介绍了 Windows：123http://www.cnblogs.com/pharen/archive/2012/02/06/2340628.htmlhttp://www.cnblogs.com/HD/p/4531342.html MAC：123http://www.jellythink.com/archives/783https://my.oschina.net/joanfen/blog/171109 PHP工具集选 欢迎您的到来，希望有所收获，如果您有什么疑问或者建议，欢迎一起讨论，也可以直接给我留言或者直接联系我！微信：clpaial10201119(183**7821) / QQ：2211523682github博文（如果你对iOS常用技术，基础，底层感兴趣请猛戳这里）：http://al1020119.github.io/github：https://github.com/al1020119 集成环境 XAMPP WAMP LAMP MAMP XAMPP12345678XAMPP（Apache+MySQL+PHP+PERL）是一个功能强大的建 XAMPP 软件站集成软件包。这个软件包原来的名字是 LAMPP，但是为了避免误解，最新的几个版本就改名为 XAMPP 了。它可以在Windows、Linux、Solaris、Mac OS X 等多种操作系统下安装使用。支持多语言：英文、简体中文、繁体中文、韩文、俄文、日文等。 许多人通过他们自己的经验认识到安装 Apache 服务器是件不容易的事儿。如果您想添加 MySQL、PHP 和 Perl，那就更难了。XAMPP 是一个易于安装且包含 MySQL、PHP 和 Perl 的 Apache 发行版。XAMPP 的确非常容易安装和使用：只需下载，解压缩，启动即可。 WAMP123456789101112Windows下的Apache+Mysql/MariaDB+Perl/PHP/Python，一组常用来搭建动态网站或者服务器的开源软件，本身都是各自独立的程序，但是因为常被放在一起使用，拥有了越来越高的兼容度，共同组成了一个强大的Web应用程序平台。随着开源潮流的蓬勃发展，开放源代码的LAMP已经与J2EE和.Net商业软件形成三足鼎立之势，并且该软件开发的项目在软件方面的投资成本较低，因此受到整个IT界的关注。LAMP是基于Linux，Apache，MySQL/MariaDB和PHP的开放资源网络开发平台，PHP是一种有时候用Perl或Python可代替的编程语言。这个术语来自欧洲，在那里这些程序常用来作为一种标准开发环境。名字来源于每个程序的第一个字母。每个程序在所有权里都符合开放源代码标准：Linux是开放系统；Apache是最通用的网络服务器；mySQL是带有基于网络管理附加工具的关系数据库；PHP是流行的对象脚本语言，它包含了多数其它语言的优秀特征来使得它的网络开发更加有效。开发者在Windows操作系统下使用这些Linux环境里的工具称为使用WAMP。 LAMP12345LAMP是一个缩写，它指一组通常一起使用来运行动态网站或者服务器的自由软件：Linux，操作系统；Apache，网页服务器；MySQL，数据库管理系统（或者数据库服务器）；PHP 和有时Perl 或 Python，脚本语言。 MAMP123456MAMP PRO是专业级版本的经典本地服务器环境的os x软件。MAMP这几个首字母代表苹果的OSX系统上的Macintosh、Apache、MySQL和PHP，顾名思义，你应该知道MAMP的强大功能 啦！MAMP 内含 Apache 服务器、PHP 安装套件以及MySQL安装套件。只要轻松点选就能安装架站/讨论区/论坛必备的元件。透过Web界面稍作设定，在苹果电脑上架设自己专属的网站，就是这 么简单又开心的事情和windows下的XAMPP，Linux下的LAMP一样。都是Apache+Mysql+PHP的集成环境 上面的我都在不同的环境简单的使用了一下，因为我一直使用的都是Mac，所以最后首选MAMPP Pro，具体具体为什么活着但是到底好不好用，我相信你用了就知道了！ 关于IDE： PhpStorm netbeans … PhpStorm，个人认为是最好的php开发ide，自带各种差价，ftp、svn、git、sql等都可以无缝使用netbeans:很强大不适合新手其他：zendSudio, php100。。。 PHPStorm吸引我的特点： 1234567891011121314跨平台，我在 Windows, Linux, Mac 下都可以使用它，完全一致的界面和功能，省着折腾了UI 还算好看，我用的是 Darcula 这个主题可以很方便地调试位于各种地方的 PHP 脚本，比如本地的，远程的，GAE 上的，还自带一个 RESTful 客户端，方便调试 API, 只是不大好用...可以真正地读懂源代码，进行重构，比如给函数/类改名，拆分函数或类，自动完成 PHPDoc, 标识语法错误等等的，对PHP新的标准和语法支持比较及时。虽然这一条看上去很多 IDE 都能做到，但 IDEA 做得真心更好可以直接在 IDE 里浏览数据库，浏览远程服务器上的文件，自动上传到远程服务器，IDE 内支持多种版本控制系统，总是可以在 IDE 里完成几乎所有事情。插件比较多，通过插件可以支持更多语言的开发支持前端开发，对 JS 的支持很好 数据库：1必须MYSQL：天生一对，不用问为什么！ 数据库工具：12345678910111213141516phpMyAdmin：phpMyAdmin 是一个以PHP为基础，以Web-Base方式架构在网站主机上的MySQL的数据库管理工具，让管理者可用Web接口管理MySQL数据库Navicat：Navicat是一套快速、可靠并价格相当便宜的数据库管理工具，专为简化数据库的管理及降低系统管理成本而设。它的设计符合数据库管理员、开发人员及中小企业的需要。Navicat 是以直觉化的图形用户界面而建的，让你可以以安全并且简单的方式创建、组织、访问并共用信息。现在官方就有中文版，我买的App Store内的，包含Navicat的会员（多人合作用）也才和官方价格一样。SQL Manager：SQL管理器，实现远程连接数据服务器；对数据库进行备份/恢复/日志文件清除；提取多个表的结构，并可保存；可以把表中记录直接生成“Insert、Delete、Update”等语句，便于使用；可以直接提取表中记录值；可以对多表进行备份；可以直接在此运行SQL语句。 这里我首选的是Navicat因为之前iOS使用SQLite3的时候一直也是使用的他，非常不错的一个软件。 服务器123456789Apache ：Apache HTTP Server（简称Apache）是Apache软件基金会的一个开放源码的网页服务器，可以在大多数计算机操作系统中运行，由于其多平台和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩展，将Perl/Python等解释器编译到服务器中。[2] Apache HTTP服务器是一个模块化的服务器，源于NCSAhttpd服务器，经过多次修改，成为世界使用排名第一的Web服务器软件。Nginx 可以在大多数 UnixLinux OS 上编译运行，并有 Windows 移植版。Nginx 的1.4.0稳定版已经于2013年4月24日发布，一般情况下，对于新建站点，建议使用最新稳定版作为生产版本，已有站点的升级急迫性不高。Nginx 的源代码使用 2-clause BSD-like license。 因为之前用过一段时间Apache，相对来说比较熟悉，所以还是先首选Apache吧，当然后面肯定会试试Nginx的强大之处！ 1最终我选的方案是：MAMPP（Macintosh/Apache/MySQL/PHP）+ Navicat + PHPStorm 当然或许你还有其他更好的方式也可以联系我，我们一起分享交流！ 下载完上面需要的东西，我们就可以开始码代码了……]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>工具集选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器配置——内网CentOS7/PHP/Apache/Nginx/SVN/Git/GitLab服务器实战]]></title>
    <url>%2F2018%2F11%2F18%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E5%86%85%E7%BD%91CentOS7%3APHP%3AApache%3ANginx%3ASVN%3AGit%3AGitLab%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[完整实战，验证通过，可用….. 此文章看着好长，或者逼格好高的样子。其实很简单，只是因为这些是后端开发或者公司负责项目和内部服务器搭建人员必会的！ 适合人群： PHP后端开发 小团队或部门组负责人 服务器或相关运营负责人 想要学习PHP或者转型后端开发 业务学习，纯属搞着玩 这里就不对每一个模块和内容做解释了，只用实战记录，方便后期查阅也希望能得到更多前辈的点评和指点！ 首先分享一份教程，这是慕课网实战阿里云主机(ECS)与CentOS7教程！ 阿里云主机(ECS)与CentOS7实战 提取码：389j 注：本文部分外部操作基于Mac系统 1.U盘制作Centos系统盘准备 U盘或者硬盘一个，需要大于8G iso系统:(本文基础1708) https://pan.baidu.com/s/1sC8JSuCzPk6BGbfof7vouQ 提取码: 4df8 HFSExplorer：方面Windows系统访问Mac盘(U/硬盘) UltraISO：光盘映像文件制作 具体制作安装U盘的步骤由于过于简单，这里就过多说明，不知道的请出门左转找度娘。 2.Centos安装只要U盘正确制作，关于网上教程非常多，也是非常简单的！ 这里推荐被参考的比较多的教程： https://www.osyunwei.com/archives/7829.html 有些地方需要注意的： 可以的话，最好在安装信息摘要的时候连上网，方便一些相关的更新和下载。 出入学习推荐使用桌面版，当然如果比较喜欢专业或者非入门级的那就使用最小安装，最小安装是基本上很多东西都没有，连网络和相关需求都不支持。 关于分区可以使用自动分区，或者根据教程做相应的分配，建议不要自己随意配，不然后面难免出现问题。 期间遇到了一个问题 /dev/root does not exist, could not boot 网上都说直接修改 vmlinuz initrd=initrd.imginst.stage2=hd:LABEL=CentOS\x207\x20x86_64 rd.live.check quiet 改为： vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sda4 quite 试了好几次都不行,最后发现是空格的问题，因为我格式化U盘之后直接命名为了Centos 7，导致产生了空格，而无法读取到U盘 解决方法： 到windows里面修改U盘名称（例如 ‘Centos7’） 进入U盘目录 进入 EFI/boot 修改grub.cfg文件，CENTOS\x207 全部修改为U盘名称（CENTOS7） 重启安装 正常安装并显示交互界面 总结：名称强烈不建议出现中文空格,容易出bug 安装完成之后，进入Centos命令行查看IP地址，然后在ssh连接工具上尝试连接，并且进行一些操作 CentOS7查看ip地址的方式为： ip addr 这里有一点需要知道的是，阿里云或腾讯云或者其他说明鬼云，都是提供的最新的相关Linux系统，所以一般系统安装是不需要我们来做的，除非有一些特殊的情况。 Ip地址也是直接对外提供，不需要我们去查的，所以就XXX云来说，我们做的事情就是从这里往后操作的流程。甚至有些会给你一些更完整或者更多的功能支持。 如果有需要需要额外配置其他相关功能和服务，推荐看这里： centos7 装机后的基本配置 3.Centos系统配置PHP服务器 注意：以下安装，我都是用的root权限。 一、关闭防火墙查了资料，说法是，CentOS7用的是Firewall-cmd，CentOS7之前用的是iptables防火墙；要想让外网能访问到apache主目录，就需要做以下的操作： 12345678910111213停止firewall systemctl stop firewalld.service禁止firewall开机启动 systemctl disable firewalld.service /** Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service. Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service. */查看默认防火墙的状态 firewall-cmd --state /** not running */ 或者可以这么做： 123firewall-cmd --permanent --zone=public --add-service=httpfirewall-cmd --permanent --zone=public --add-service=httpsfirewall-cmd --reload 二、安装Apache123456789101112131415安装Apache yum install httpd -y--- 一下httpd可以直接使用httpd.service --- 启动Apache systemctl start httpd停止Apache systemctl stop httpd重启Apache systemctl restart httpdApache开机自启 systemctl enable httpd /** Created symlink from /etc/systemd/system/multi-user.target.wants/httpd.service to /usr/lib/systemd/system/httpd.service. */ 在本机浏览器中前面ip addr查到的ip地址，如果看到apache默认的页面–有Testing 123…字样，便是成功安装了apache服务 三、安装php123456安装php yum install php php-devel或者yum -y install php安装Php扩展 yum install php-mysql php-gd php-imap php-ldap php-odbc php-pear php-xml php-xmlrpc重启Apache: systemctl restart httpd或者systemctl restart httpd.service 然后，你可以写一个php文件在浏览器中运行一下了; 12vi /var/www/html/info.php&lt;?php phpinfo(); ?&gt; 然后，在自己电脑浏览器输入 http://172.20.10.2/info.php运行，会出现php的一些信息,如果出现如下界面，说明已经成功了 四、安装mysql1234567891011121314安装MySQL yum install mariadb mariadb-server -y启动MariaDB systemctl start mariadb 停止MariaDB systemctl stop mariadb 重启MariaDB systemctl restart mariadb设置开机启动 systemctl enable mariadb/**Created symlink from /etc/systemd/system/multi-user.target.wants/mariadb.service to /usr/lib/systemd/system/mariadb.service.*/ 设置root帐户的密码 1mysql_secure_installation 然后会出现一串东西，可以仔细读一下，如果你懒得读，就在提示出来的时候，按Enter就好了，让你设置密码的时候，你就输入你想要的密码就行，然后继续在让你选择y/n是，Enter就好了；当一切结束的时候，你可以输入1mysql -u root 验证一下,输入密码，正常连接并可进行mysql操作 有时候由于安装命令的问题，会出现下面的报错，建议重现使用上面的操作一遍 12ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/var/run/mysqld/mysqld.sock' (2) 五、配置Mysql，设置MySQL密码1.连接MySQL1mysql -u root 2.设置密码12mysql&gt; set password for 'root'@'localhost' = password('root');mysql&gt; exit 3.远程授权连接mysql12mysql&gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION;配置生效：FLUSH PRIVILEGES; 再次连接线使用：1mysql -u root -p 然后输入上面的root密码 六、将PHP和MySQL关联起来1yum search php 选择你需要的安装： 1yum -y install php-mysql 七、安装常用的PHP模块例如，GD库，curl，mbstring,… 1.安装：1yum -y install php-gd php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-snmp php-soap curl curl-devel 2.重启apache服务1systemctl restart httpd.service 然后，再次在浏览器中运行info.php，你会看到安装的模块的信息； 至此，LAMP环境就搭建好了…… 4. nginx安装与配置 Nginx从安装到入门，基础篇 Nginx有三种安装方式 安装包编译安装(相对麻烦) yum源安装 使用docker安装 需确认80端口是否开放，如果是阿里云，得在控制台那边设置端口组开放 #确保防火墙是否开放80端口 如果没有 firewall-cmd --permanent --zone=public --add-port=80/tcp #重新加载 firewall-cmd --reload #查看列表 firewall-cmd --list-all 这里推荐直接使用yum源安装，因为比较快捷，方便 #yum安装nginx sudo yum install -y nginx #启动nginx sudo systemctl start nginx.service #设置开机自启动 sudo systemctl enable nginx.service #yum安装的nginx配置文件默认存放在 /etc/nginx/nginx.conf 查看 vi /etc/nginx/nginx.conf #卸载 yum remove nginx 如果可以你也可以直接使用安装包编译安装 # 下载源码 $ wget http://nginx.org/download/nginx-1.13.0.tar.gz # 解压源码 $ tar xvf nginx-1.13.0.tar.gz # 进入源码目录 $ cd nginx-1.13.0 # 配置、编译、安装 $ ./configure $ make $ make install 有时候回遇到，输入网址之后不是官方默认界面，可能是因为 有epel源的时候并且用yum install nginx 安装就会显示Welcome to nginx on Fedora!，因为epel源就是Fedora维护的 5.Centos配置Git服务器1、安装Git首先需要安装Git，可以使用yum源在线安装： 1yum install -y git 2、用户操作创建一个git用户，用来运行git服务 123adduser gitpasswd git/*输入git用户密码*/ 3、git初始化初始化git仓库：这里我们选择/git/icocos.git来作为我们的git仓库 123mkdir /git -pcd /gitgit init --bare icocos.git #初始化仓库 执行以上命令，会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。 4、然后，把owner改为git1chown git:git icocos.git -R 5、clone远程仓库在这里，Git服务器就已经搭得差不多了。下面我们在客户端clone一下远程仓库。 Mysql可以直接使用命令行，或者使用Tower 1234567git clone git@172.20.10.2:/git/icocos.gitCloning into 'icocos'...git@172.20.10.2's password: remote: Counting objects: 6, done.remote: Compressing objects: 100% (6/6), done.remote: Total 6 (delta 0), reused 0 (delta 0)Receiving objects: 100% (6/6), 2.63 MiB | 1.63 MiB/s, done. 输入git账户对应的密码 然后就可以根据公司或者具体项目做相应拓展和配置 Git实战记录总结配置与初始化实战流程1234567891011121314151617181920212223[root@centos /]# yum install -y git 已加载插件：fastestmirror, langpacks Loading mirror speeds from cached hostfile * base: mirror.jdcloud.com * extras: mirrors.163.com * updates: mirrors.163.com 软件包 git-1.8.3.1-20.el7.x86_64 已安装并且是最新版本 无须任何处理 [root@centos /]# adduser git [root@centos /]# passwd git 更改用户 git 的密码 。 新的 密码： 重新输入新的 密码： passwd：所有的身份验证令牌已经成功更新。 [root@centos /]# mkdir git [root@centos /]# cd git [root@centos git]# ls [root@centos git]# mkdir SwiftProject [root@centos git]# cd SwiftProject/ [root@centos SwiftProject]# ls [root@centos SwiftProject]# git init --bare SwiftProject.git #初始化仓库 初始化空的 Git 版本库于 /git/SwiftProject/SwiftProject.git/ [root@centos SwiftProject]# chown git:git SwiftProject.git -R 内外网访问和Clone1git@172.20.10.2:/git/SwiftProject/SwiftProject.git 然后就是根据需求创建项目提交或拉去代码 6.Centos配置SVN服务器1、subversion安装1[root@centos /]# yum install subversion 2、新建一个目录用于存储SVN目录1[root@centos /]mkdir /svn 3、SVN方式创建SVN项目目录1[root@centos svn]# svnadmin create /svn/SwiftProject/ 4、SVN项目目录查看内容12345678[root@centos svn]# ll SwiftProject总用量 8drwxr-xr-x. 2 root root 54 1月 12 01:09 confdrwxr-sr-x. 6 root root 233 1月 12 01:09 db-r--r--r--. 1 root root 2 1月 12 01:09 formatdrwxr-xr-x. 2 root root 231 1月 12 01:09 hooksdrwxr-xr-x. 2 root root 41 1月 12 01:09 locks-rw-r--r--. 1 root root 229 1月 12 01:09 README.txt 以下关于目录的说明： hooks目录：放置hook脚步文件的目录 locks目录：用来放置subversion的db锁文件和db_logs锁文件的目录，用来追踪存取文件库的客户端 format目录：是一个文本文件，里边只放了一个整数，表示当前文件库配置的版本号 conf目录：是这个仓库配置文件（仓库用户访问账户，权限） 5、SVN配置文件cd conf/进入conf目录（该svn版本库配置文件），一共有三个文件 authz文件是权限控制文件 passwd是帐号密码文件 svnserve.conf SVN服务配置文件 a、编辑用户文件passwd，新增两个用户：svn。 vim conf/passwd 12[users]svn = svn b、编辑权限文件authz，用户admin设置可读写权限，guest设置只读权限。 vim conf/authz 12[/]svn = rw c,进入所建立仓库的配置目录/svn/project/conf修改文件svnserve.conf vim conf/svnserve.conf 1234anon-access = none //匿名访问权限auth-access = write //认证用户权限password-db = passwd //密码配置文件路径，默认为同目录的passwd文件realm = My First Repository //认证标记而已 6、启动SVN服务器1svnserve -d -r /svn --listen-host 172.20.10.2 -d表示在后台运行，-r指定了服务器的根目录，这样在SVN客户端就可以用svn://172.20.10.2/SwiftProject来访问SVN服务器 1234svn co svn://172.20.10.2/SwiftProjectChecked out revision 0.lsSwiftProject 注意 使用以下命令可以查看正在运行的SVN进程ps -ef | grep svn使用命令 killall svnserve 来停止SVN服务器。 SVN实战记录总结配置与初始化实战流程12345678910111213141516171819202122[root@centos /]# yum install subversion 已加载插件：fastestmirror, langpacks Loading mirror speeds from cached hostfile * base: mirror.jdcloud.com * extras: mirrors.163.com * updates: mirrors.163.com 软件包 subversion-1.7.14-14.el7.x86_64 已安装并且是最新版本 无须任何处理 [root@centos /]# svnadmin create /svn/project[root@centos /]# cd /svn/SwiftProject [root@centos SwiftProject]# pwd /svn/SwiftProject [root@centos SwiftProject]# ls conf db format hooks locks README.txt [root@centos SwiftProject]# cd conf/ [root@centos conf]# ls authz passwd svnserve.conf [root@centos conf]# vi svnserve.conf [root@centos conf]# vim authz [root@centos conf]# vim passwd [root@centos conf]# cd / [root@centos /]# svnserve -d -r /svn --listen-host 172.20.10.2 内外网访问和Co1svn co svn://172.20.10.2/SwiftProject 然后就是根据需求创建项目提交或拉去代码 7.Centos配置GitLab服务器 安装依赖软件 1yum -y install policycoreutils openssh-server openssh-clients postfix 2.设置postfix开机自启，并启动，postfix支持gitlab发信功能 1systemctl enable postfix &amp;&amp; systemctl start postfix 3.下载gitlab安装包，然后安装 centos 6系统的下载地址 centos 7系统的下载地址 我的是centos7,所以我在https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7中找了个gitlab8.0.0版本,建议下载一个比较新的版本,我这里选了一个比较旧的版本仅仅是实验 123下载rpm包并安装:wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/gitlab-ce-8.0.0-ce.0.el7.x86_64.rpmrpm -i gitlab-ce-8.0.0-ce.0.el7.x86_64.rpm 4.修改gitlab配置文件指定服务器ip和自定义端口： vim /etc/gitlab/gitlab.rb 12345## Url on which GitLab will be reachable. ## For more details on configuring external_url see: ## https://gitlab.com/gitlab-org/omnibus-gitlab/blob/629def0a7a26e7c2326566f0758d4a27857b52a3/README.md#configuring-the-external-url-for-gitlab external_url 'http://172.20.10.2:8081' 最后，退出并保存 注: 这里设置的端口不能被占用，默认是8080端口，如果8080已经使用，请自定义其它端口，并在防火墙设置开放相对应得端口 5.重置并启动GitLab 12gitlab-ctl reconfiguregitlab-ctl restart 提示“ok: run:”表示启动成功 1234567ok: run: gitlab-git-http-server: (pid 3922) 1sok: run: logrotate: (pid 3929) 0sok: run: nginx: (pid 3936) 1sok: run: postgresql: (pid 3941) 0sok: run: redis: (pid 3950) 0sok: run: sidekiq: (pid 3955) 0sok: run: unicorn: (pid 3961) 1s 6.访问 GitLab页面 如果没有域名，直接输入服务器ip和指定端口进行访问,会出现如下页面并提示：You need to sign in before continuing. 初始账户: root 密码: 5iveL!fe注意，第一次登录最好修改密码 修改完成之后，就可以创建项目或者根据具体需求创建分组 7.设置gitlab发信功能，需要注意一点： 发信系统用的默认的postfix，smtp是默认开启的，两个都启用了，两个都不会工作。 我这里设置关闭smtp，开启postfix 12关闭smtp方法：vim /etc/gitlab/gitlab.rb找到#gitlab_rails['smtp_enable'] = true 改为 gitlab_rails['smtp_enable'] = false 修改后执行gitlab-ctl reconfigure另一种是关闭postfix，设置开启smtp + 相关教程请参考[官网](https://doc.gitlab.cc/omnibus/settings/smtp.html) 测试是否可以邮件通知：登录并添加一个用户，我这里使用qq邮箱添加一个用户 创建成功后，就可以去对应的邮箱查看邮件并设置密码 登录qq邮箱，可以收到邮件通知（如果收不到，请查看垃圾邮箱或者检查邮件是否被拦截并删除，如果有请添加到白名单并删除用户再重新添加用户就可以收到了，否则请检查邮件日志并做好相关设置） 到此，GitLab就基本配置完毕，如果有需要和可以结合GitLab，Jenkins，Fastlane实现CI和CD，当然这些一般的小公司不太会用到…… 错误一：报错502 gitlab报502 Whoops, GitLab is taking too much time to respond 配置启动后，访问gitlab，出现：502 ，Whoops, GitLab is taking too much time to respond. 出现这个问题，一般都是你本机的8080端口已经被其他的应用程序占用。 方法一： GitLab在使用的过程中，会开启8080端口，但是如果8080端口被其他的应用程序占用，则GitLab的该项服务不能使用，所以访问GitLab会失败。 方法二： 一般是权限问题，解决方法：chmod -R 755 /var/log/gitlab 如果还不行，请检查你的内存，安装使用GitLab需要至少4GB可用内存(RAM + Swap)! 由于操作系统和其他正在运行的应用也会使用内存, 所以安装GitLab前一定要注意当前服务器至少有4GB的可用内存. 少于4GB内存会出现各种诡异的问题, 而且在使用过程中也经常会出现500错误. 错误二：gitlab-ctl reconfigure 报错n itdb: could not obtain information about current user: Permission denied 1Error executing action `run` on resource 'execute[/opt/gitlab/embedded/bin/initdb -D /var/opt/gitlab/postgresql/data -E UTF8]' 根据报错信息大概锁定用户的权限问题,安装gitlab-ce会自动添加用户四个用户: 1234gitlab-www:x:497:498::/var/opt/gitlab/nginx:/bin/falsegit:x:496:497::/var/opt/gitlab:/bin/shgitlab-redis:x:495:496::/var/opt/gitlab/redis:/bin/nologingitlab-psql:x:494:495::/var/opt/gitlab/postgresql:/bin/sh google和百度都搜索不到解决方法,既然出错提示到权限问题，那么按照这个方向去查就不会有问题，后来查了文件/etc/passwd的权限是600,给予644权限后,成功解决报错问题 改成808112345# gitlab-ctl stop # vi /etc/gitlab/gitlab.rb (取消注释并修改端口) unicorn['port'] = 8801 # gitlab-ctl reconfigure (重新生成配置) # gitlab-ctl restart # lsof -i:8081(check whether unicorn has started properly) 8.Centos配置PHP各种拓展: Composer推荐composer官方更多教程与配置：https://www.phpcomposer.com/ 需要使用到curl，如果没有的话需要 1yum -y install curl ###安装 下载composer.phar1curl -sS https://getcomposer.org/installer | php 把composer.phar移动到环境下让其变成可执行1mv composer.phar /usr/local/bin/composer 测试composer12composer -V /** 输出：Composer version 1.0-dev (e64470c987fdd6bff03b85eed823eb4b865a4152) 2015-05-28 14:52:12 */ 实战操作1234567891011[root@centos /]# curl -sS https://getcomposer.org/installer | phpAll settings correct for using Composer Downloading...Composer (version 1.8.0) successfully installed to: //composer.pharUse it: php composer.phar[root@centos /]# mv composer.phar /usr/local/bin/composer[root@centos ~]# composer -V Do not run Composer as root/super user! See https://getcomposer.org/root for detailsComposer version 1.8.0 2018-12-03 10:31:16 推荐 实战Nginx与PHP（FastCGI）的安装、配置与优化 Nginx站点目录及文件URL访问控制]]></content>
  </entry>
  <entry>
    <title><![CDATA[服务器配置——实战验证与补充]]></title>
    <url>%2F2018%2F11%2F15%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81%E4%B8%8E%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[下面关于之前一些流程（Ngnix，Php，Go，Mysql）安装配置与使用的一些总结，和遇到的一个坑，其中也有关于服务器配置与部署，代码上传与发布相关内容，主要是为了熟悉整个流程…… 这里补充一下前面没有提到，但是实际操作会用到或者能提升效率的东西 安装ftp大家看到了，所有的文件操作在ssh中可以通过vim方法来实现，但是，你知道在windows中用惯了，还是喜欢看图形界面，所以在这里我安装了ftp可以远程来上传修改文件 软件：winscp（百度下载就好了） 安装vsftpdyum install vsftpd 启动/重启/关闭vsftpd服务器[root@localhost ftp]# /sbin/service vsftpd restart Shutting down vsftpd: [ OK ] Starting vsftpd for vsftpd: [ OK ] OK表示重启成功了. 这里现在就可以直接使用root及你的密码来查看了，当然这样的是超级用户，留给自己用的，要配置指定要文件夹的用户，我就在不在这里写了，大家继续百度下吧 安装Gitsudo apt-get update sudo apt-get install git]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Server</tag>
        <tag>服务器配置——实战验证与补充</tag>
        <tag>实战验证与补充</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器配置——Redis安装，配置，简单使用]]></title>
    <url>%2F2018%2F11%2F12%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94Redis%E5%AE%89%E8%A3%85%EF%BC%8C%E9%85%8D%E7%BD%AE%EF%BC%8C%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文是因为在做API接口开发的时候，要数据每次都需要从数据读取而写，那样太耗性能了，其实类型iOS中的Cache或者NSUserDefault，用法都和NSUserDefault类似…. Redis安装下载安装包 redis-3.2.8.tar.gz 官网地址：http://redis.io/download 解压： tar -zvxf redis-3.2.8.tar.gz 将解压后的文件夹放到 /Users/local目录下 编译测试:接下来在终端中切换到/Users/local/redis目录下,输入：sudo make test 编译安装：在终端中输入命令：sudo make install 启动Redis,输入命令redis-server redis-server 78407:C 18 Apr 21:32:31.361 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf 78407:M 18 Apr 21:32:31.362 * Increased maximum number of open files to 10032 (it was originally set to 256). _._ _.-``__ &apos;&apos;-._ _.-`` `. `_. &apos;&apos;-._ Redis 3.2.8 (00000000/0) 64 bit .-`` .-```. ```\/ _.,_ &apos;&apos;-._ ( &apos; , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|&apos;` _.-&apos;| Port: 6379 | `-._ `._ / _.-&apos; | PID: 78407 `-._ `-._ `-./ _.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | http://redis.io `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; `-._ `-.__.-&apos; _.-&apos; `-._ _.-&apos; `-.__.-&apos; 78407:M 18 Apr 21:32:31.363 # Server started, Redis version 3.2.8 78407:M 18 Apr 21:32:31.364 * DB loaded from disk: 0.001 seconds 78407:M 18 Apr 21:32:31.364 * The server is now ready to accept connections on port 6379 看到这个界面表示我们已经成功的安装Redis。 二配置1、在 /Users/local/redis目录下建立bin，etc，db三个目录2、把/Users/local/redis/src目录下的mkreleasehdr.sh，redis-benchmark， redis-cli， redis-server拷贝到bin目录3、在etc下，参考原/Users/local/redis目录下的redis.conf，新建一个redis.conf修改redis.conf，具体如下： #修改为守护模式 daemonize yes #设置进程锁文件 pidfile /Users/local/redis/redis.pid #端口 port 6379 #客户端超时时间 timeout 300 #日志级别 loglevel debug #日志文件位置 logfile /Users/local/redis/log-redis.log #设置数据库的数量，默认数据库为16，可以使用SELECT 命令在连接上指定数据库id databases 16 ##指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 #save #Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 #指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间， #可以关闭该#选项，但会导致数据库文件变的巨大 rdbcompression yes #指定本地数据库文件名 dbfilename dump.rdb #指定本地数据库路径 dir /Users/local/redis/db/ #指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能 #会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有 #的数据会在一段时间内只存在于内存中 appendonly no #指定更新日志条件，共有3个可选值： #no：表示等操作系统进行数据缓存同步到磁盘（快） #always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） #everysec：表示每秒同步一次（折衷，默认值） appendfsync everysec 其实只需要拷贝，然后修改对应的值就可以 4、保存后，启动redis：./bin/redis-server etc/redis.conf注意这里log-redis.log文件需要我自己创建 iCocosdeMacBook-Pro:redis icocos$ redis-server etc/redis.conf回车之后没有输出说明成功了 5、查看日志文件：tail -f log-redis.log| `-._`-._ _.-&apos;_.-&apos; | `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; `-._ `-.__.-&apos; _.-&apos; `-._ _.-&apos; `-.__.-&apos; 78584:M 18 Apr 21:48:02.777 # Server started, Redis version 3.2.8 78584:M 18 Apr 21:48:02.777 * The server is now ready to accept connections on port 6379 78584:M 18 Apr 21:48:02.779 - 0 clients connected (0 slaves), 957072 bytes in use 到这里，我们已经完成redis安装和配置。 三使用1、检查是否启动：redis-cli ping2、redis-cli3、ping4、redis-cli 跟上命令会将参数发送到本地redis 6379 的端口，下面来看看基本操作：使用方式 iCocosdeMacBook-Pro:redis icocos$ redis-cli 127.0.0.1:6379&gt; ping PONG 127.0.0.1:6379&gt; set key1 name OK 127.0.0.1:6379&gt; get key1 &quot;name&quot; 5、关闭命令：redis-cli shutdown上面我们演示了redis安装与配置，接下来后面的工作在真实上线之前只需要熟练redis的使用就差不多了，注意细节，并应用到实战，没错就这么简单！ 四.服务器配置上面只是基本的安装，如果要用到生产环境，得配置一些文件 1.首先把redis-cli 移动到/Users/local/bin 目录，方便执行，和JAVA_HOME 类似默认install 的时候已经有了 2.创建你存放配置文件和数据文件的目录sudomkdir /etc/redissudo mkdir /var/redis 3.复制初始化脚本到/etc/init.d 目录,建议默认只有这个端口,作开机启动$ sudocp utils/redis_init_script /etc/init.d/redis_6379 4.进入脚本,确保你的REDISPORT 是你正在使用的sudovi /etc/init.d/redis_6379 5.复制redis.conf ,和脚本保持一致sudocp redis.conf /etc/redis/6379.conf 6.创建一个存放工作数据的目录sudomkdir /var/redis/6379 同时可以对redis.conf配置其他属性 # 来源：http://www.cnblogs.com/shanyou/archive/2012/01/28/2330451.htmldaemonize：是否以后台daemon方式运行pidfile：pid文件位置port：监听的端口号timeout：请求超时时间loglevel：log信息级别logfile：log文件位置databases：开启数据库的数量save **：保存快照的频率，第一个*表示多长时间，第三个*表示执行多少次写操作。在一定时间内执行一定数量的写操作时，自动保存快照。可设置多个条件。rdbcompression：是否使用压缩dbfilename：数据快照文件名（只是文件名，不包括目录）dir：数据快照的保存目录（这个是目录）appendonly：是否开启appendonlylog，开启的话每次写操作会记一条log，这会提高数据抗风险能力，但影响效率。appendfsync：appendonlylog如何同步到磁盘（三个选项，分别是每次写都强制调用fsync、每秒启用一次fsync、不调用fsync等待系统自己同步） 7.最后将脚本设置默认启动sudoupdate-rc.d redis_6379 defaults 8.现在可以执行脚本了/etc/init.d/redis_6379start 五.MAC 版本差异一个不幸的事实是：mac 上是没有init.d 目录的，mac启动脚本是 以.plist 结尾了， 好吧，我在 ~/Library/LaunchAgents 目录下自己建立一个 redis.plist 参考：http://www.js2node.com/redis-io/install-redis-io-2-4-17-on-mac-osx-as-service $ sudovi redis.plist 然后输入以下内容 Labelio.redis.redis-serverProgramArguments/Users/local/bin/redis-server/Users/local/etc/redis.confRunAtLoad 执行命令 $ sudo launchctlload/Library/LaunchDaemons/io.redis.redis-server.plist 打开关闭： $ sudo launchctlstartio.redis.redis-server$ sudo launchctl stop io.redis.redis-server 六.brew 进行安装下面我用brew来操作，关于brew 的安装我看的：http://my.oschina.net/liygheart/blog/284668 安装好了，然后 参考：https://gist.github.com/tonypujals/9631143 $brew info redis 会有提示，然后输入 $ln -nfs /Users/local/opt/redis/*.plist ~/Library/LaunchAgents 和 $load ~/Library/LaunchAgents/homebrew.mxcl.redis.plist 网上还找到一种方式，貌似可以成功1.获取github中的redis-php扩展代码： git clone https://github.com/phpredis/phpredis.git 2.cd phpredis/ 3.phpize mac os 如果这里有 Cannot find autoconf. Please check your autoconf installation and the $PHP_AUTOCONF environment variable. Then, rerun this script.的问题，那么： 执行：brew install autoconf 4.之后执行phpize 5../configure 6.make &amp;&amp; sudo make install 输入密码就会提示成功 Password: Installing shared extensions: /usr/lib/php/extensions/no-debug-non-zts-20131226/ 7.之后在php.ini中加一句 extension=redis.so 就ok了 路径：/etc/php.ini 然后重启 apache/nginx 和 php-fpm ，输入命令：php -m |grep redis 或者通过 phpinfo() 输出php信息查看redis是否安装成功。 期间我在执行install的时候出现这样的问题装不了PHP的扩展，make install失败 RudonMacBook:igbinary-master rudon$ make install Installing shared extensions: /usr/lib/php/extensions/no-debug-non-zts-20131226/ cp: /usr/lib/php/extensions/no-debug-non-zts-20131226/#INST@12567#: Operation not permitted make: *** [install-modules] Error 1 cp: /usr/lib/php/extensions/no-debug-non-zts-20121212/#INST@17000#: Operation not permitted 原因是 原来是OSX 10.11 El Capitan（或更高）新添加了一个新的安全机制叫系统完整性保护System Integrity Protection (SIP)，所以对于目录 /System /sbin /usr 不包含(/usr/local/) 仅仅供系统使用，其它用户或者程序无法直接使用，而我们的/usr/lib/php/extensions/刚好在受保护范围内 所以解决方法就是禁掉SIP保护机制，步骤是： 重启系统 按住Command + R （重新亮屏之后就开始按，象征地按几秒再松开，出现苹果标志，ok） 菜单“实用工具” ==&gt;&gt; “终端” ==&gt;&gt; 输入csrutil disable；执行后会输出：Successfully disabled System Integrity Protection. Please restart the machine for the changes to take effect. 再次重启系统 禁止掉SIP后，就可以顺利的安装了，当然装完了以后你可以重新打开SIP，方法同上，只是命令是csrutil enable 平时使用iCocosdeMacBook-Pro:redis icocos$ cd /Users/local/redis iCocosdeMacBook-Pro:redis icocos$ redis-server 78728:C 18 Apr 22:00:25.105 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf 78728:M 18 Apr 22:00:25.107 * Increased maximum number of open files to 10032 (it was originally set to 256). _._ _.-``__ &apos;&apos;-._ _.-`` `. `_. &apos;&apos;-._ Redis 3.2.8 (00000000/0) 64 bit .-`` .-```. ```\/ _.,_ &apos;&apos;-._ ( &apos; , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|&apos;` _.-&apos;| Port: 6379 | `-._ `._ / _.-&apos; | PID: 78728 `-._ `-._ `-./ _.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | http://redis.io `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; `-._ `-.__.-&apos; _.-&apos; `-._ _.-&apos; `-.__.-&apos; 78728:M 18 Apr 22:00:25.108 # Server started, Redis version 3.2.8 78728:M 18 Apr 22:00:25.108 * DB loaded from disk: 0.000 seconds 78728:M 18 Apr 22:00:25.108 * The server is now ready to accept connections on port 6379 ^C78728:signal-handler (1492524027) Received SIGINT scheduling shutdown... 78728:M 18 Apr 22:00:27.286 # User requested shutdown... 78728:M 18 Apr 22:00:27.286 * Saving the final RDB snapshot before exiting. 78728:M 18 Apr 22:00:27.288 * DB saved on disk 78728:M 18 Apr 22:00:27.288 # Redis is now ready to exit, bye bye... iCocosdeMacBook-Pro:redis icocos$ redis-cli 127.0.0.1:6379&gt; ping PONG 127.0.0.1:6379&gt; set key1 name OK 127.0.0.1:6379&gt; get key1 &quot;name&quot; 127.0.0.1:6379&gt; PHP中使用的话&lt;?php $redis = new Redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); $redis-&gt;set(&apos;iCocos&apos;,1234); $redis-&gt;get(&apos;iCocos&apos;); 执行PHP文件，可以直接网页执行，也可以直接命令执行，方法基本上类似. Redis基本命令Redis数据类型及操作: String: 指令:{ set setnx :如果key已经存在, 返回0 setex :指定键值对的有效期, setex [key] [expire] [value] /类似于:set [key] [value] [EX expire] setrange :设置key-value值的子字符串,下标从0开始到第i位置,不包含i mset msetnx get getset getrange mget incr incrby decr decrby append strlen } Hash:是一个string类型的field-value的映射表,它的添加删除平均都是O(1)的效率 指令:{ hset hsetnx hmset hget hmget hincrby hexists hlen hdel hkeys hvals hgetall } List:是一个链表结构, 主要功能是pop,push,获取一个范围的所有值等,key理解为链表的名字list类型其实就是每一个子元素都是string类型的双向链表. 指令:{ lpush rpush linsert : linsert key [BEFORE|AFTER] [pivot] [value] 在list的特定的值的位置之前或之后添加字符串元素 lset : lset key [index] [value] 设置list中指定下标的元素值 lrem : lrem key [count] [value] 从list中删除count个和value相同的元素 count&gt;0,从头删除; count=0,全部删除; count&lt;0,从尾删除; ltrim : ltrim key [start] [stop] 保留key的值中指定范围内的数据 lpop : 从list的头部删除元素 rpop : 从list的尾部删除元素 rpoplpush : rpoplpush [source] [destination], 整个操作是原子的 从source的尾部移除元素,并添加到destination的头部,返回被移除的元素值 lindex : lindex key [index] 取list中index位置的元素 llen : 返回key对应list的长度 } Set: 指令:{} 键值指令: [ keys :返回给定pattern的所有key exists: 确认一个key是否存在 del : 删除一个key expire : 设置一个key的过期时间(秒为单位) ttl : 用于获取key的有效时长 persist : 移除给定key的过期时间 move : 把当前数据库中的key移动到其它库中 rename : 重命名key ] 服务指令: [ select :选择数据库存取, redis数据库编号从 0~15 默认16个库 dbsize :获取当前数据库的key info : 获取服务器的信息和统计,用于说明服务器的基础信息,包括版本启动时间等; config get: 获取服务器配置信息 flushdb : 删除当前选择数据库中的所有key flushall : 删除所有库中的所有key ] 主从复制基本配置: Redis主从复制中一个主服务可以有多个服务, 一个从服务可以有多个从服务; 对应配置,只需要修改redis.conf中的slaveof参数 #slaveof &lt;masterip&gt; &lt;masterport&gt; slaveof 127.0.0.1 6379 启动master #redis-server /usr/local/redis/conf/redis_6379.conf #redis-cli 启动slave(假设端口3689) #redis-server /usr/local/redis/conf/slave.conf #redis-cli -p 6389 如果master服务设置有密码,则需要配置masterauth参数 masterauth &lt;master-password&gt; 查看redis连接数 redis-cli info | grep connected 如果客户端的idle空闲时间太长,连接池维持了太多的连接,则需要把不用的连接及时释放掉; redis 127.0.0.1:6379&gt; client list redis 127.0.0.1:6379&gt; CONFIG SET timeout 30 Cluster集群配置 cluster-enabled yes 开启 每一个集群节点有一个集群配置文件;它不是手工创建的,是redis节点创建和更新的; 确保同一系统上运行的redis集群节点的配置文件名不重叠 redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件, 并且在此基础上实现了master-slave(主从)同步 pipeline 压缩请求数量 pipeline机制将多个命令汇聚到一个请求中,可以有效减少请求数量,减少网络延时。 script 压缩复杂请求 script核心思想是在redis命令里嵌入Lua脚本,来实现一些复杂操作。 cluster Redis 集群不像单机版本的 Redis 那样支持多个数据库，集群只有数据库 0，而且也不支持 SELECT 命令。 学习Redis命令请参考 http://www.redis.cn/http://www.cnblogs.com/woshimrf/p/5198361.html]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器配置——Php安装与配置]]></title>
    <url>%2F2018%2F11%2F12%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94Php%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[由于之前学过一段时间的Php，偶尔看到一个不错的东西也会尝试一下，虽然可能最终结果和意义并不大，但是此次我还是觉决定让服务器支持Php，同时也会适当的更新一些Php的内容（能力有限，都是比较基础的内容）…… 说了服务器第一步Ngnix安装与配置之后，就要开始说说关于PHP和Go的安装与配置 配置php-fpm部分要让 nginx 能够执行 php 文件，需要去安装一下 php-fpm，它直接包含在了 CentOS 资源库里，所以直接使用 yum 命令可以安装它： yum install php-fpm 完成以后，可以检查一下 php-fpm 的运行状态，使用 service 命令： service php-fpm status 返回： php-fpm is stopped（php-fpm 已停止） 启动 php-fpm 同样可以使用 service 命令： service php-fpm start 让 nginx 可以执行 php现在我们应该就可以让 nginx 去执行 php 了。不过你需要修改一下 nginx 的配置文件，之前我们在配置虚拟主机的时候，创建了一个 nginx.ninghao.net.conf 的配置文件，需要去修改下 nginx 的这个配置文件，才能去执行 php 。使用 vim 命令去编辑它： vim /etc/nginx/conf.d/nginx.ninghao.net.conf 注意你的配置文件不一定叫 nginx.ninghao.net.conf，应该是你自己命名的配置文件。打开以后，找到下面这段字样的代码： # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} 这是 nginx 默认给我们的用来执行 php 的配置，从 location 开始取消注释，会让这个配置生效，然后我们还得简单去修改一下： # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # location ~ \.php$ { # root html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } 注意 root 那里仍然是被注释掉的，还有 SCRIPT_FILENAME 后面修改了一下，把 /scripts 换成了 $document_root 。保存并退出。然后重新启动 nginx： service nginx restart 测试是否可以执行 php现在，我们已经安装了 php-fpm，并修改了 nginx 的配置文件让它可以去执行 php，下面，我们得去测试一下，可以使用 php 的 phpinfo(); 函数，方法是在你的虚拟主机根目录下面，创建一个 php 文件，命名为 phpinfo.php，然后在这个文件里输入： &lt;?php phpinfo(); ?&gt; 保存文件并退出。在浏览器里打开刚才创建的这个 php 文件。我这里应该是 http://nginx.ninghao.net/phpinfo.php。打开以后，你应该能看到像下面这样的界面，如果能，说明 nginx 已经可以执行 php 了。 配置扩展 现在，我们有了可以提供 web 服务的 nginx ，并且安装了 php-fpm ，配置了 nginx 可以让它去执行 php ，也安装了数据库管理系统。 不过在运行真正的网站的时候，我们还需要为 php 安装一些额外的扩展，比如 处理 mysql 数据库的 mysql 扩展，缓存功能的 apc 扩展，处理图像的 gd 扩展等等。安装它们同样可以使用 yum 命令。 yum install php-pecl-apc php-mysql php-gd php-mcrypt php-pear php-mbstring php-xmlrpc php-dom 上面安装了一些 php 的扩展，如果你发现在安装网站的时候提示需要安装其它的扩展，同样可以使用 yum 命令去安装。安装完成以后，需要重启一下 php-fpm ： service php-fpm restart]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Server</tag>
        <tag>服务器配置——Php安装与配置</tag>
        <tag>Php安装与配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器配置——MySql安装与配置]]></title>
    <url>%2F2018%2F11%2F12%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94MySql%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[服务器好了之后，首先我们应该从数据库入手，因为一切没有数据交互与存储的服务器和客户端都只是娱乐，这里我们选择大部分人都熟知而且与PHP成为天和之作的Mysql，当然他和Go也一样兼容…… 安装mysqlmysql 可以管理网站用到的数据库，WordPress 和 Drupal 也都支持 mysql 数据库。所以我们的 Web 运行环境里，需要安装一个 mysql 。之前我们已经添加了资源库，所以可以直接使用 yum 命令去安装 mysql ： yum install mysql-server 安装完成后，使用 service 命令启动 mysql 服务： service mysqld start 然后我们需要简单配置一下 mysql ，默认安装以后 mysql 的 root 用户是没有密码的，对于生产环境来说，这肯定是不行的. 另外还有一些安全相关的设置，可以使用下面这行命令去配置一下，它是一个向导，问你一些问题，你要给出答案，比如是否要设置 root 用户的密码， 密码是什么等等。 mysql_secure_installation 然后根据实际情况进行配置，也可以看看下面比较常用的配置方案 Enter current password for root (enter for none): 解释：输入当前 root 用户密码，默认为空，直接回车。 Set root password? [Y/n] y 解释：要设置 root 密码吗？输入 y 表示愿意。 Remove anonymous users? [Y/n] y 解释：要移除掉匿名用户吗？输入 y 表示愿意。 Disallow root login remotely? [Y/n] n 解释：不想让 root 远程登陆吗？输入 y 表示愿意。 Remove test database and access to it? [Y/n] y 解释：要去掉 test 数据库吗？输入 y 表示愿意。 Reload privilege tables now? [Y/n] y 解释：想要重新加载权限吗？输入 y 表示愿意。]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>服务器配置——MySql安装与配置</tag>
        <tag>Server</tag>
        <tag>MySql安装与配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器配置——Nginx安装与配置]]></title>
    <url>%2F2018%2F11%2F12%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94Nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[配置完阿里控制台之后，首先我们开始配置服务器，我的服务器各种配置都需要自己重新配，这里我现在Ngnix，不要问我为什么选择他，可能是之前用过Apache，对他印象不好吧…… 前面说了关于阿里云主机操作，这里打算开始一步一步搭建和配置服务器，并且开始Go语言和后台学习，并且徐后续更新，直到后面的后台实战开发 关于域名解析，实例，和安全组相关请自行参考阿里官方教程 如何连接服务器执行环境配置 我使用的是centos6.8 64位版本，如果您不是第一次接触linux那一定知道，linux不是一个可视化界面的系统，所以要摒弃windows的操作习惯，我使用的xshell这个软件链接的服务器，连接语句是 ssh root@ip地址 地址处就是写入你的ip地址，然后回车鞋面就会自动连接，弹框提示输入密码 输入服务器的密码，点击确定即链接上了 ok，下面就可以开始配置环境了，第一步我们先配置nginx nginx安装部分想在 CentOS 系统上安装 Nginx ，你得先去添加一个资源库，像这样： vim /etc/yum.repos.d/nginx.repo 使用 vim 命令去打开 /etc/yum.repos.d/nginx.repo ，如果 nginx.repo 不存在，就会去创建一个这样的文件，打开以后按一下小 i 键，进入编辑模式，然后复制粘贴下面这几行代码，完成以后按 esc 键退出，再输入 :wq （保存并退出） [nginx] name=nginx repo baseurl=http://nginx.org/packages/centos/$releasever/$basearch/ gpgcheck=0 enabled=1 完成以后，我们就可以使用 yum 命令去安装 nginx 了，像这样： yum install nginx 安装好以后测试一下 nginx 服务： service nginx status 应该会返回： nginx is stopped （nginx 已停止） 再测试一下 nginx 的配置文件： nginx -t 应该会返回： nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful … syntax is ok，… test is successful，说明配置文件没问题，同时这个结果里你可以找到 nginx 的配置文件 nginx.conf 所在的位置。 操纵 nginx 服务操纵服务，可以使用使用 service 命令，它可以启动（start），重启（restart），或停止服务（stop），比如要启动 nginx 服务： service nginx start 服务启动以后，你就可以在浏览器上使用服务器的 IP 地址，或者指向这个地址的域名访问服务器指定的目录了。你会看到类似下面的这些文字。 Welcome to nginx! If you see this page, the nginx web server is successfully installed and working. Further configuration is required. For online documentation and support please refer to nginx.org. Commercial support is available at nginx.com. Thank you for using nginx. nginx配置部分下面来看一下为 nginx 配置虚拟主机。先进入到 nginx 配置文件目录： cd /etc/nginx/conf.d 复制这个目录里的 default.conf ，复制以后的名字可以使用你的虚拟主机名字。比如创建一个 nginx.ninghao.net 的虚拟主机。复制文件可以使用 cp 命令，像这样： cp default.conf nginx.ninghao.net.conf 再去编辑一下这个复制以后的配置文件，可以使用 vim 命令： vim nginx.ninghao.net.conf 你会看到像这样的代码： server { listen 80; server_name localhost; #charset koi8-r; #access_log /var/log/nginx/log/host.access.log main; location / { root /usr/share/nginx/html; index index.html index.htm; } ... } server_name 就是主机名，也就是跟这个虚拟主机绑定在一块儿的域名，我事先把 nginx.ninghao.net 指向了服务器，这个虚拟主机就是为它准备的，所以，server_name 后面的东西就是 nginx.ninghao.net 。 紧接着 server_name 下面可以是一个root，就是这个虚拟主机的根目录，也就是网站所在的目录。比如我们要把 nginx.ninghao.net 这个网站的文件放在/home/www/nginx.ninghao.net 下面，那么这个 root 就是这个路径。 然后去掉 location / 里面的 root 这行代码。再在 index 后面加上一种索引文件名，也就是默认打开的文件，这里要加上一个 index.php ，这样访问 nginx.ninghao.net 就可以直接打开 root 目录下面的 index.php 了。稍后我们再去安装 php 。修改之后，看起来像这样： server { listen 80; server_name nginx.ninghao.net; root /home/www/nginx.ninghao.net; #charset koi8-r; #access_log /var/log/nginx/log/host.access.log main; location / { index index.php index.html index.htm; } ... } 这个配置文件先修改到这，稍后，我们再回来继续修改一下它。保存一下，按 esc ，输入 :wp（保存并退出）。现在虚拟主机应该就可以使用了。主机的域名是 nginx.ninghao.net，访问它的时候，打开的是 /home/www/nginx.ninghao.net 这个目录里面的东西，你可以在这个目录下放点东西。 重启 nginx 或者重新加载 nginx 可以让配置文件生效。 service nginx reload 现在，打开浏览器，输入你为虚拟主机设置的域名，看看是否能打开你指定的目录里的东西。]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Server</tag>
        <tag>服务器配置——Nginx安装与配置</tag>
        <tag>Nginx安装与配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器配置——阿里云主机配置与操作]]></title>
    <url>%2F2018%2F11%2F11%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%BB%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[前几年在阿里买了一个属于自己的个性域名(笔者英文)：www.icocos.cn，虽然是CN，但是这都不是重点，重点是为了更全面的接触后台，更好的学习与实战后台开发与PHP，前天又在阿里买了个主机，打算开发玩弄一番，毕竟第一次，期间可能会遇到不少坑和不对的地方，望谅解与指出一起交流，谢谢...... 阿里云（先声明我不是来给阿里大广告的，😂😂😂😂😂😂） 阿里云主机 域名：www.icocos.cn 这里关于阿里云主机和域名的购买很简单，准备钱，一路点下去就可以了,具体操作强查看阿里文档…… 备案关于备案确实是不少人蛋疼的事情，说麻烦也没有多麻烦，说不麻烦但是搞起来又不是点几下就可以的，所以也有不少人选择了不需要备案的或者国外的主机，我当时也有这种想法，但是后来放弃了，投资嘛，自己都不舍得投资还怎么学东西，怎么提升呢！ 本案分个人备案和企业备案，具体详情阿里也有教程，或者网上也有相关教程 初始化配置在链接之前可能需要做一些配置，但是有些事必须的有些可以后面备案成功之后再做，我就是第一次弄所以一直不懂，以为需要备案以后才能操作的。 添加安全组织，允许22端口访问这里其实就是进入阿里控制台的云服务ECS，找到安全组，添加安全组，配置规则就可以. 这里只要注意 端口:22/22 授权对象：0.0.0.0/0 初步的这样就可以了，我是为了方便链接访问 然后就可以链接了 连接，并操作连接的话当然首选ssh，不要问我为什么，我也不知道，大家都用它，哈哈！ 关于SSHSSH是每一台Linux电脑的标准配置。 简单说，SSH是一种网络协议，用于计算机之间的加密登录。 如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。 最基本的用法SSH主要用于远程登录。假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。 $ ssh user@host 如果本地用户名与远程用户名一致，登录时可以省略用户名。 $ ssh host SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。 $ ssh -p 2222 user@host 上面这条命令表示，ssh直接连接远程主机的2222端口。 这里我使用的是SSH shell这个工具，Windows用什么不知道，网上应该一大堆命令行步骤 输入 ssh root@ip地址 输入yes 输入密码 就可以看到显示 [root@iZwz92qgus0ln1nx5dftjd2rZ ~]# SSH工具使用也很简单，进后点击Add Server输入ip，端口是默认22，输入root用户名，输入后台配置的密码，对了这里的密码是需要在控制台配置的 一切顺利的话可以看到一个和terminal一样的终端界面，并且已经连接成功的显示 [root@iZwz92qgus0ln1nx5dftjd2rZ ~]# 然后就可以使用命令操作主机文件了。 密码登录：Mac 客户端进入.ssh 文件夹，如果没有就创建一个.ssh文件夹mkdir ~/.ssh cd ~/.ssh/ 生成rsa秘钥：这个相信大部分人都弄过，github就需要ssh-keygen -t rsa 在该文件夹下就会产生三个文件夹：id_rsa,id_rsa.pub,know_hosts。id_rsa：存储私钥，记得只能自己看哦。别人那到这个文件就完蛋蛋咯。 id_rsa.pub:存储公钥，用来通信加密使用，有了这个人家才能确定这是你。 公钥拷贝到云主机scp id_rsa.pub root@78.129.23.45:/root/.ssh/id_rsa.pub Note:云主机上没有.ssh/文件时，你要自己建立一个。终端连接后输入ls只能看到default.pass文件，ls -a发现也是没有.ssh文件夹的，所以需要输入下面命令创建.ssh文件夹 mkdir .ssh #回车没有提示就成功再次ls -a就可以看到一个蓝色的隐藏文件夹 登录到云主机进入.ssh/文件夹cd /root/.ssh/ 将客户端公钥放入云主机识别keys文件夹中cat id_rsa.pub &gt;&gt; authorized_keys 销毁公钥rm id_rsa.pub 再次输入ssh root@ip地址就可以直接连接了，当然如果你使用工具的话就不用这么麻烦。 到这里就基本上初步，而且是很简单的实现的主机的查看与操作，具体更多操作和命令请查看相关资料，后期也会有一些配置，操作与实战，请期待]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Server</tag>
        <tag>服务器配置——阿里云主机配置与操作</tag>
        <tag>阿里云主机配置与操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx lua 热更新原理与实战]]></title>
    <url>%2F2018%2F10%2F30%2Fcocos2dx-lua-%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[首先，如果有过cocos2dx lua开发经验的朋友都知道，为什么使用Lua而不是C++,最重要的原因就是因为下面这三个原因 热更新(在线更新代码和资源) 比C++简单很多,入门和实战 轻量级，最小最轻的脚本语言 今天就从Lua热更新，捣鼓一下其中的原理，并具体实战一下！ 什么是热更新？热更新也叫不停机更新，是在游戏服务器运行期间对游戏进行更新。实现不停机修正bug、修改游戏数据等操作。也可以这样讲：一辆车以时速150km跑着，突然爆胎了，然后司机告诉你，我不停车，你去把轮胎换了，小心点。 热更新的作用Lua模块热更新原理，能很好的支持代码热更新机制，是大部分选择要嵌入脚本语言的原因之一。好处很简单，脚本代码可以热更新的话，调试和线上解决问题都可以不用重启程序了，对开发效率有很大的帮助。 热更新原理Lua内部提供了一个require函数，来实现模块的加载，它做的事情主要是以下几个： 在registry[“_LOADED”]表中判断该模块是否已经加载过了，如果是则返回，避免重复加载某个模块代码。 依次调用注册的loader来加载模块,将加载过的模块赋值给registry[“_LOADED”]表。 而如果要实现Lua的代码热更新，其实也就是需要重新加载某个模块，因此就要想办法让Lua认为它之前没有加载过。查看Lua代码发现，registry[“_LOADED”]表，实际上对应的是package.loaded表，这在以下函数中有体现： (loadlib.c) 627 LUALIB_API int luaopen_package (lua_State *L) { 655 /* set field `loaded&apos; */ 656 luaL_findtable(L, LUA_REGISTRYINDEX, &quot;_LOADED&quot;, 2); 657 lua_setfield(L, -2, &quot;loaded&quot;); 因此事情就很简单了，需要提供一个require_ex函数，可以理解为require的增强版，使用这个函数可以动态更新某个模块的代码: function require_ex( _mname ) print( string.format(&quot;require_ex = %s&quot;, _mname) ) if package.loaded[_mname] then print( string.format(&quot;require_ex module[%s] reload&quot;, _mname)) end package.loaded[_mname] = nil require( _mname ) end 这个函数做的事情一目了然。首先判断是否曾经加载过这个模块，如果有则打印一条日志表示需要重新加载某个模块，然后将该模块原来在表中注册的值赋空，然后再次调用require进行模块的加载和注册。 热更新实现细节以上了解了Lua代码热更新的原理，但是还有一些细节需要提醒一下。 如何组织你的项目中的Lua代码？ 我在qnode中使用的方式是，单独使用一个叫main.lua的文件调用require_ex函数来加载需要用到的lua模块，而Lua虚拟机创建之后执行的是这个文件，这样的话，当你需要热更新项目中的Lua代码时，只需要重新执行这个main.lua就行了。 如何通知热更新代码呢？ 我在qnode中使用的信号机制，当服务器收到USR1信号时，通知所有工作进程，由工作进程来重新对main.lua进行重新加载，这样就完成了lua代码的热更新，为此我写了一个简单的脚本reload.sh，就是根据当前qnode的服务器进程ID来对其发送USR1信号量的。 一般热更新的都是函数的实现，所以需要对全局变量做一些保护。 比如当前某全局变量为100，表示某个操作已经进行了100次，它不能因为热更新重新置0，所以要对这些不能改变的全局变量做一个保护，最简单的方式就是这样: 1a = a or 0 很简单的原理，只有当前a这个变量没有初始值的时候才会赋值为0，而后面不管这个Lua文件被加载多少次，a都不会因为重新加载了Lua代码发生改变了。 热更新实战其实我们平时开发中，可以用简单易懂的方式来理解热更新 客户端向服务器发送请求，服务器告诉客户端，没更新，你是最新的啦，那就直接跳过喽 如果是告诉你有更新，那就要告诉我哪些需要更新对吧，你可能需要更新的东西，放在一个文件里，一并发送给客户端 客户端拿到这个文件，就一个一个去向服务器要，最后把要更新的内容都下载到本地了 cocos2dx-lua中有assetmanagerex的c++实现类，也有绑定到lua。 3.10之前有缺陷，问题是当有文件下载失败时会陷入死循环，导致业务链断裂。不过网上有解决办法，可简单修改源码解决。建议把高于3.10版本以后的assetmanagerex代码移植到旧的3.x版本，也可以选择新项目使用3.10以后版本。 网上有提到两种热更新的方法 1.只存在一套资源，用一个文件记录所有文件的信息（文件名，路径，大小，MD5）。游戏启动时下载这个文件与本地文件MD5进行对比，不同的和新增的下载下来，没有的删掉。（最好再做个简要信息文件，因为资源多了记录文件信息的文件会有上百KB大小） 2.第二种存在多套资源，客户端每更新一个版本都会有一个内部版本号。更新服务端会有多套压缩包，如1.0-1.5， 1.1-1.5 ，1.2-1.5 ，1.3-1.5，1.4-1.5。此方法需要保留每个版本的文件资源，依次生成每一个版本到最新版本的增量压缩包（依据是文件名和MD5） 但是结合实战第一种和优点是方便管理，从始到终只有一套资源。缺点是玩家下载时流量多一点，因为没有压缩。第二种优点是玩家下载流量小，但每次升级需要保留历史版本为升级依据，版本越多越不好管理。 具体代码实战local AutoUpdateScene = class(&quot;AutoUpdateScene&quot;, cc.load(&quot;mvc&quot;).ViewBase) local manifestPath = &quot;project.manifest&quot; local storagePath = &quot;update&quot; function AutoUpdateScene:onCreate() self._update_failed_count = 0 local layer = cc.Layer:create() local am = nil local function onEnter() local ttfConfig = {} ttfConfig.fontFilePath = &quot;fonts/arial.ttf&quot; ttfConfig.fontSize = 80 local progress = cc.Label:createWithTTF(ttfConfig, &quot;0%&quot;, cc.VERTICAL_TEXT_ALIGNMENT_CENTER) progress:setPosition(cc.p(display.center.x, display.center.y + 50)) layer:addChild(progress) am = cc.AssetsManagerEx:create(manifestPath, cc.FileUtils:getInstance():getWritablePath() .. storagePath) am:retain() if not am:getLocalManifest():isLoaded() then print(&quot;Fail to update assets, step skipped.&quot;) self:onFail(&quot;本地资源错误，请重新下载游戏。&quot;) else local function onUpdateEvent(event) local eventCode = event:getEventCode() print(&quot;====== assetsmanagerex error code:&quot;, eventCode) --[[ cc.EventAssetsManagerEx.EventCode = { ERROR_NO_LOCAL_MANIFEST = 0, ERROR_DOWNLOAD_MANIFEST = 1, ERROR_PARSE_MANIFEST = 2, NEW_VERSION_FOUND = 3, ALREADY_UP_TO_DATE = 4, UPDATE_PROGRESSION = 5, ASSET_UPDATED = 6, ERROR_UPDATING = 7, UPDATE_FINISHED = 8, UPDATE_FAILED = 9, ERROR_DECOMPRESS = 10 } ]] if eventCode == cc.EventAssetsManagerEx.EventCode.ERROR_NO_LOCAL_MANIFEST then print(&quot;No local manifest file found, skip assets update.&quot;) self:onFail(string.format(&quot;本地资源错误，请重新下载游戏。(错误码:%d)&quot;, eventCode)) elseif eventCode == cc.EventAssetsManagerEx.EventCode.UPDATE_PROGRESSION then local assetId = event:getAssetId() local percent = event:getPercent() local strInfo = &quot;&quot; if assetId == cc.AssetsManagerExStatic.VERSION_ID then strInfo = string.format(&quot;Version file: %d%%&quot;, percent) elseif assetId == cc.AssetsManagerExStatic.MANIFEST_ID then strInfo = string.format(&quot;Manifest file: %d%%&quot;, percent) else strInfo = string.format(&quot;%d%%&quot;, percent) end progress:setString(strInfo) self:setLoadingProgress(event:getPercentByFile()) elseif eventCode == cc.EventAssetsManagerEx.EventCode.ERROR_DOWNLOAD_MANIFEST or eventCode == cc.EventAssetsManagerEx.EventCode.ERROR_PARSE_MANIFEST then print(&quot;Fail to download manifest file, update skipped.&quot;) self:onFail(string.format(&quot;更新失败，请检查网络配置。(错误码:%d)&quot;, eventCode)) elseif eventCode == cc.EventAssetsManagerEx.EventCode.ALREADY_UP_TO_DATE or eventCode == cc.EventAssetsManagerEx.EventCode.UPDATE_FINISHED then print(&quot;Update finished.&quot;) self:onSuccess() elseif eventCode == cc.EventAssetsManagerEx.EventCode.ERROR_UPDATING then print(&quot;Asset &quot;, event:getAssetId(), &quot;, &quot;, event:getMessage()) -- self:onFail(string.format(&quot;更新资源失败，请检查网络后重试。(%d)&quot;, eventCode)) elseif eventCode == cc.EventAssetsManagerEx.EventCode.UPDATE_FAILED then print(&quot;Fail to download resource files.&quot;) self._update_failed_count = self._update_failed_count + 1 if self._update_failed_count &lt;= 3 then print(&quot;try again&quot;) am:downloadFailedAssets() else self:onFail(string.format(&quot;更新失败，请检查网络配置。(错误码:%d)&quot;, eventCode)) end elseif eventCode == cc.EventAssetsManagerEx.EventCode.NEW_VERSION_FOUND then print(&quot;new version found.&quot;) --am:update() elseif eventCode == cc.EventAssetsManagerEx.EventCode.ASSET_UPDATED then print(&quot;assets updated.&quot;) elseif eventCode == cc.EventAssetsManagerEx.EventCode.ERROR_DECOMPRESS then print(&quot;decompress error.&quot;) end end local listener = cc.EventListenerAssetsManagerEx:create(am, onUpdateEvent) cc.Director:getInstance():getEventDispatcher():addEventListenerWithFixedPriority(listener, 1) am:update() --am:checkUpdate() end end local function onExit() am:release() end local function onNodeEvent(event) if &quot;enter&quot; == event then onEnter() elseif &quot;exit&quot; == event then onExit() end end layer:registerScriptHandler(onNodeEvent) self:addChild(layer) end function AutoUpdateScene:onFail(msg) print(&quot;====== update fail ======&quot;, msg) -- 热更新失败处理 end function AutoUpdateScene:onSuccess() print(&quot;====== update success ======&quot;) local writablePath = cc.FileUtils:getInstance():getWritablePath() package.path = writablePath .. &quot;update/src/?.lua;./?.lua;&quot; -- 启动热更新后的场景 end return AutoUpdateScene 推荐 https://blog.csdn.net/weixin_37730482/article/details/73299286 https://blog.csdn.net/qq_32319583/article/details/53223452 https://blog.csdn.net/q277055799/article/details/8463835?utm_source=blogxgwz3**]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>事件</tag>
        <tag>cocos2dx lua 热更新原理与实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx lua 多线程之协成理解与实战]]></title>
    <url>%2F2018%2F10%2F29%2Fcocos2dx-lua-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%8D%8F%E6%88%90%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[lua是不支持多线程的，一般都是协同来调用的。但是lua却可以调用c函数。于是，我们通过lua调用C接口起一个线程，实现lua多线程的使用。子线程再调用lua中的function。就可以通过子线程获取一些数据。单纯的人儿，以为一切都是美好的。问题就出现C调用lua中的function。将数据传给lua。 lua的运行首先我们需要知道，lua是解释性语言。是在执行的时候才分配堆栈空间。通过查看lua的源码，我们可以知道，在main函数的开端，lua就创建了一个全局的L（状态机），这个状态机可以说是lua的核心所在。它保存了栈的地址。 当执行lua脚本时，lua会将全局的变量和function记录在堆中，当执行代码段是，就会将一些局部变量和参数压到栈中进行处理。这一切和c语言的解析是一样的。 我们知道C也是可以调用lua的function的，一般的操作是： 在lua中调用C函数，将需要注册的function，作为参数传给C函数 C将获取到的function和L（状态机）进行保存。 C通过向L压栈，将function和一些参数压入。通过lua_call函数进行调用。 根据上述的解释，我们可以知道。其中C和lua通过通信的是L（状态机）。压入栈之后，通过lua_call,就会进入lua的状态中。lua会处理栈中的内容。 问题所在核心问题就是C调用lua的L和lua的L是同一个L。这样就出现一个问题，当主线程的lua脚本才进行压栈操作，而子线程中也进行压栈操作，那岂不是乱了套？在一开始就不应该成功的，为什么会这样呢？通过查看代码，发现lua对进行堆操作的函数中，都加上了线程锁。当主线程进行栈操作时，子线程是不可以对栈进行操作的。 也就是说，子线程理论上是不会运行的，会卡在栈操作的函数那里。 但是为什么我们在运行的时候并没有出现这个现象呢？通过代码的查询，发现是主线程中有sleep函数，并且子线程中有阻塞，所以能够在几个线程中切换。 如果主线程的while循环中没有sleep，那么就会很快的出现问题。因此，lua从底层就是不支持多线程的。 为什么使用协同如果你搜索lua多线程，大多数都会写搜索到协同程序。 每一个协程有自己的堆栈，自己的局部变量，可以通过yield-resume实现在协程间的切换。不同之处是：Lua协程是非抢占式的多线程，必须手动在不同的协程间切换，且同一时刻只能有一个协程在运行。并且Lua中的协程无法在外部将其停止，而且有可能导致程序阻塞。 正如上诉，协同拥有自己的堆栈，那是用来避免和其他堆栈冲突的。但是两者之间想要通信，就不能通过栈了。因为栈的不同，压入的数据在另一端是无法接收到的。 但是，我们可以通过一个全局变量进行通信。比如，子线程通过协同的堆栈进行调用lua里面的function。在function中获取传入的值，将它赋值给一个全局变量。那么主线程也能够调用了。 线程与协同协同程序与线程thread差不多，也就是一条执行序列，拥有自己独立的栈、局部变量和命令指针，同时又与其他协同程序共享全局变量和其他大部分东西。可以通过yield-resume实现在协程间的切换。 从概念上讲线程与协同程序的主要区别在于，一个具有多个线程的程序可以同时运行几个线程，而协同程序却需要彼此协作的运行。也就是说多个协同程序在任意时刻只能运行一个协同程序，只有当正在运行的协同程序显式的要求挂起时，它的执行才会暂停。 总结区别： 不同之处是：Lua协程是非抢占式的多线程，必须手动在不同的协程间切换，且同一时刻只能有一个协程在运行。并且Lua中的协程无法在外部将其停止，而且有可能导致程序阻塞。 关于更多区别和介绍，可以查看这里 https://www.cnblogs.com/work115/p/5620272.html https://www.cnblogs.com/lxmhhy/p/6041001.html 协同程序coroutineLua将所有关于协同程序的函数放置在一个名为“coroutine”的table中。 1、coroutine.create创建一个thread类型的值表示新的协同程序，返回一个协同程序。 2、coroutine.status检查协同程序的状态（挂起suspended、运行running、死亡dead、正常normal）。 3、coroutine.resume启动或再次启动一个协同程序，并将其状态由挂起改为运行。 4、coroutine.yield让一个协同程序挂起。 5、coroutine.wrap同样创建一个新的协同程序，返回一个函数。 注意coroutine的三个状态：suspended（挂起，协同刚创建完成时或者yield之后）、running（运行）、dead（函数走完后的状态，这时候不能再重新resume）。 创建协同程序：create函数，接受一个函数值作为协同程序的执行内容，并返回一个协同程序。 function func( ... ) print(&quot;iCocos&quot;) -- thread: 0x79f721d4 -- [Finished in 0.0s] end local cor = coroutine.create(func) print(cor) 启动或再次启动一个协同程序：resume函数，接受一个协同程序及一个或多个参数用于值传递给协同程序。 function funcA( _cor, ... ) print(&quot;A: status_1&quot;,coroutine.status(_cor), ...) -- A: status_1 running 1 2 3 end local corA = coroutine.create(funcA) coroutine.resume(corA, corA, 1,2,3) print(&quot;A: status_2&quot;, coroutine.status(corA)) -- A: status_2 dead resume-yield数据交换Lua中协同的强大能力，还在于通过resume-yield来交换数据： （1）resume把参数传给程序（相当于函数的参数调用）； （2）数据由yield传递给resume; （3）resume的参数传递给yield； （4）协同代码结束时的返回值，也会传给resume 协同中的参数传递形势很灵活，一定要注意区分，在启动coroutine的时候，resume的参数是传给主程序的；在唤醒yield的时候，参数是传递给yield的。 挂起协同程序：yield函数，让一个协同程序挂起，并等待下次恢复它的运行。它可以接受resume函数传递进来的所有参数。 -- resume yield 参数传递 function funcB( _cor ) print(&quot;A: status_1&quot;, coroutine.status(_cor)) ptint(&quot;A: status_2&quot;, coroutine.yield()) -- 挂起 end local funcB = coroutine.create(funcB) -- wrap: wrap函数比create函数更易使用。它提供了一个对于协同程序编程实际所需的功能，即一个可以唤醒协同程序的函数。但也缺乏灵活性。无法检查wrap所创建的协同程序的状态，此外，也无法检测出运行时的错误。 coroutine.resume(funcB, funcB) -- 启动，没有yield，参数属于主函数 print(&quot;A: status_3&quot;, coroutine.status(funcB)) coroutine.resume(funcB, 1,2,3) -- 从挂起出启动，并给yield传递参数 print(&quot;A: status_4&quot;, coroutine.status(funcB)) Lua提供的是一种：”非对称的协同程序“。也就是说，Lua提供了两个函数来控制协同程序的执行，一个用于挂起执行，另一个用于恢复执行。而一些其他的语言则提供了”对称的协同程序“，其中只有一个函数用于转让协同程序之间的执行权。 管道与过滤器filter关于协同程序的示例就是”生产者–消费者“的问题。其中涉及到两个函数，一个函数不断的产生值，另一个函数不断的消费这些值。 当消费者需要一个新的值时，它唤醒生产者。生产者返回一个新值后停止运行，等待消费者的再次唤醒。这种设计称为”消费者驱动“。通过resume—yield 函数之间的值交换可以轻易的实现程序。 过滤器filter，是一种位于生产者与消费者之间的处理功能，可以进行数据转换。它既是消费者又是生产者，它唤醒生产者促使其生产新值，然后又将变换后的值传递给消费者。 --管道与过滤器filter --生产者与消费者通过过滤器进行值传递 --这种模式通过消费者驱动生产者进行产生。 --计数器函数 function getCount( x ) return function() x=x+1 return x end end --创建闭合计数器 local count = getCount(0) --发送新值 function send(x) coroutine.yield(x) end --启动一个协同程序 function receive( pro ) local status,value = coroutine.resume( pro ) return value end --生产者 function producter() while true do send( count() ) end end --过滤器，接受一个生产者 function filter( pro ) local x = 0 return function() while true do x = receive( pro ) send(x) end end end --消费者，接受一个生产者协同程序及控制条件，控制条件防止死循环 --假设有100个消费者，驱动生产者来生产 function consumer( pro,num ) local x = 0 while x &lt; num do x = receive( pro ) print( x ) end end local pro = coroutine.create( producter ) local fil = coroutine.create( filter( pro ) ) consumer( fil,100 ) print( &quot;消费者协同程序状态：&quot;,coroutine.status(pro) ) print( &quot;生产者协同程序状态：&quot;,coroutine.status(fil) ) 打印结果 1 2 3 ... -- 消费者协同程序状态： suspended -- 生产者协同程序状态： suspended 推荐 https://github.com/lichuang/Lua-Source-Internal/blob/master/doc/ch09-%E5%8D%8F%E7%A8%8B.md]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>事件</tag>
        <tag>cocos2dx lua 多线程之协成理解与实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx lua 安全之加密与解密实现]]></title>
    <url>%2F2018%2F10%2F27%2Fcocos2dx-lua-%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[非常多使用cocos2dx+lua做游戏的同学。都会想到一个问题，我的游戏一旦公布，如何才干保证的我脚本代码不被破解。不泄露代码。尽管这和开源、共享的原则不合。可是代码也是coder的劳动成果，理应得到保护。 特别是商业游戏更是如此，不希望被别人破解掉源代码而且进行改动。 今天的话题就是怎样实现lua脚本文件的加密和解密。 我在网络上查过，都没有成熟的解决方式。然后我经过考虑之后，总结出两种解决方式，供大家參考。 1、轻量级的解决方式。APK打包之前，用工具把全部的lua文件加密，详细是将lua文件读到内存，然后使用zip等压缩加密库进行压缩加密，然后将压缩加密之后的数据保存为和源文件同名的文件。 打包之后执行lua文件的时候。则先读出lua数据。然后进行解密。将解密后的流数据传给lua虚拟机。 2、重量级的解决方式，此方案是上一种方案的扩展。也是商用游戏的方案，实现一个游戏文件包，打包前将资源和脚本都使用工具打包到一个文件。能够在打包的时候加密压缩，也能够不加密压缩。 然后在执行的时候直接从包内读出对应文件的数据。然后解密解压缩。然后提供给游戏引擎使用。这也是端游普遍使用的技术，手游眼下大部分也開始使用此技术。 本文主要简要解说第一种方案，另外一种方案则有时间再写一篇博客。好了。我们開始进入正题吧。 首先是压缩lua文件。代码例如以下： int write_file_content(const char* folder) { //获得文件数据，并压缩文件 FILE* fpin = fopen(folder, &quot;wb+&quot;); if (fpin == NULL) { printf(&quot;无法读取文件: %s\n&quot;, folder); return 0; } //得到文件大小 fseek(fpin, 0, SEEK_END); unsigned int size = ftell(fpin); //读出文件内容 fseek(fpin, 0, SEEK_SET); void* con = malloc(size); int r = fread(con, size, 1, fpin); //进行加密操作 unsigned long zip_con_size = size * 2; void* zip_con = malloc(zip_con_size); if (Z_OK != compress((Bytef*)zip_con, &amp;zip_con_size, (Bytef*)con, size)) { printf(&quot;压缩 %s 时错误发生\n&quot;,folder); } printf(&quot;%s 压缩前大小：%ld 压缩后大小：%ld\n&quot;, folder, size, zip_con_size); //写文件内容 fseek(fpin, 0, SEEK_SET); int len = fwrite(zip_con, zip_con_size, 1, fpin); //释放资源 fclose(fpin); free(zip_con); free(con); return 0; } 然后是解密操作。代码例如以下： void* read_file_content(const char* folder, int&amp; bufflen) { FILE* file = fopen(folder, &quot;wb+&quot;); if (file) { { printf(&quot;无法读取文件: %s\n&quot;, folder); return 0; } //获取文件大小 fseek(file, 0, SEEK_END); unsigned int size = ftell(file); //读出文件内容 void* con = malloc(size); fseek(file, 0, SEEK_SET); int len = fread(con, size, 1, file); //解压缩操作 unsigned long zip_size = size * 4; void* zip_con = malloc(zip_size); int code = uncompress((Bytef*)zip_con, &amp;zip_size, (Bytef*)con, size); if (Z_OK != code) { printf(&quot;解压 %s 时错误发生 :%d\n&quot;, folder, code); return 0; } //释放资源 fclose(file); free(con); //zip_con由外部释放 bufflen = zip_size; return zip_con。 } 最后就把此流文件塞给lua的虚拟机就可以，即以流方式执行lua代码。 当然更高级一点的方法是直接改写lua的文件载入策略]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>事件</tag>
        <tag>cocos2dx lua 安全之加密与解密实现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx lua (伪)面向对象理解与实战应用]]></title>
    <url>%2F2018%2F10%2F24%2Fcocos2dx-lua-%E4%BC%AA-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[面向对象 把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）／泛化（generalization），通过多态（polymorphism）实现基于对象类型的动态分派（dynamic dispatch） 1.lua中的类lua中其实是没有类的，有的只是表(table)，而类之间的继承也就是将父类的表连到了一起，派生类中没有找到的属性和方法就通过元表查找父类 2.lua中类的属性classA = {width =10, height=10} classA={} classA.width=10 classA.height=10 两种方法都可以，通过点self.width统一调用 3.类方法[cpp] view plaincopy function Box:collsion() -- 默认第一个参数隐藏传递self，可以通过self.xxx 调用属性和方法 end function Box.create(self) --必须手动传递参数self,否则无法用self.xxx调用属性和方法 end 4.类与元表的用法 lua查找一个表元素时的规则，其实就是如下3个步骤: 4.1.在表中查找，如果找到，返回该元素，找不到则继续 4.2.判断该表是否有元表，如果没有元表，返回nil，有元表则继续 4.3.判断元表有没有index方法，如果index方法为nil，则返回nil；如果index方法是一个表，则重复1、2、3；如果index方法是一个函数，则返回该函数的返回值 在Lua中，函数的声明和调用可以用”:”和”.”，属性调用全部用点”.” 我们知道，对象由属性和方法组成。LUA中最基本的结构是table，所以需要用table来描述对象的属性。 lua中的function可以用来表示方法。那么LUA中的类可以通过table + function模拟出来。 至于继承，可以通过metetable模拟出来（不推荐用，只模拟最基本的对象大部分时间够用了）。 Lua中的表不仅在某种意义上是一种对象。像对象一样，表也有状态（成员变量）；也有与对象的值独立的本性，特别是拥有两个不同值的对象（table）代表两个不同的对象；一个对象在不同的时候也可以有不同的值，但他始终是一个对象；与对象类似，表的生命周期与其由什么创建、在哪创建没有关系。 1. 初步面向对象ObjectData = {balance = 0} function ObjectData.count( v ) -- body print(&quot;value is :&quot;, v) end a = ObjectData a.count(&quot;iCocos&quot;) -- value is : iCocos 2. 面向对象模拟ObjectData = {balance = 100} function ObjectData.count( self, v ) self.balance = self.balance + v print(&quot;value is :&quot;, v, self.balance) end a = ObjectData a.count(a, 99) -- 传递self -- value is : 99 199 a:count(99) -- 不传self，直接把a作为self传递进入， -- value is : 99 298 Lua中的继承先来定义一个基类，使用前面讲的setmetatable来实现基本的元表 local _M = {} function _M:new(name) return setmetatable({ name = name}, { __index = _M }) end function _M:show() print(self.name .. &quot;: show in parent:&quot;) end function _M:hello(arg) print(self.name .. &quot;: hello in parent:&quot; .. tostring(arg)) end return _M 子类的实现local parent = require(&quot;parent&quot;) local _M = {} function _M:new() local obj = parent:new(&quot;the child&quot;) local super_mt = getmetatable(obj) -- 当方法在子类中查询不到时，再去父类中去查找。 setmetatable(_M, super_mt) -- 这样设置后，可以通过self.super.method(self, ...) 调用父类的已被覆盖的方法。 obj.super = setmetatable({}, super_mt) return setmetatable(obj, { __index = _M }) end -- 覆盖父类的方法。 function _M:hello() -- 只能使用这种方法调用基类的方法。 self.super.hello(self, &quot;call from child&quot;) print(tostring(self.name) .. &quot;: hello in child&quot;) end return _M test.lua (使用) -- local parent = require(&quot;parent&quot;) local child = require(&quot;child&quot;) local c = child:new() -- 从parent继承的show方法 c:show() -- child自己的方法。 c:hello() 执行lua test.lua 后 输出： the child: show in parent: the child: hello in parent:call from child the child: hello in child 可以看到： show是继承了父类的方法。 hello是由子类覆盖了，并且在hello中调用了父类的hello方法。]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>cocos2dx lua (伪)面向对象理解与实战应用</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx lua cc & ccs & ccui区别和使用]]></title>
    <url>%2F2018%2F10%2F22%2Fcocos2dx-lua-cc-ccs-ccui%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[最近遇到一个问题，网上一些教程，或者官方的一些教程，在对应使用cc，ccs ,ccui的时候，导致我这边没有提示，开始以为是编辑器的问题，然后硬写上去之后，在调试的时候直接报错，经过多次查看Api文档发现，我使用的Api中，并没有这个方法，那么问题来了！ 我应该怎么去调用这个对应的Api呢？ 如何验证使用cocos2dx lua调用Api是正常的呢？ 遇到一个功能或者一个需求，应该如何查找对应的Api呢？ 网上有个朋友说了这么一段原话： 同一个框架里Api名字大小不统一我也就忍了（setBackGround…和setBackground…），可是同一个类名却表达两个不同的东西这个实在让我非常气愤，刚才瞎研究半天ScrollView才发现我程序里用的是ccui.ScrollView对象，而我盯着cc.ScrollView看了半天，我说怎么Api对不上号！ 其实大概的意思就是cocos2dx lua对应Api版本号的问题,因为以前cocos用cocos2d-lua写，后来带领大家往quick转，现在合并之后，又带领大家回到cocos2d-lua，所以必定会产生一些规范和版本号的区别。 尤其在2.x和3.x之间的变化比较大，或者是quick版本和整合版的多种调整。 这里主要介绍关于cc，ccs ,ccui的区别，使用和注意点，如果要了解更多2.x和3.x版本之前的问题和区别，可以参考这里： cocos2d-x v3.0 Release Notes cc &amp; ccs &amp; ccui经过可靠资料和官方提供的信息我们可以得出一个大概的结论： cc代表Cocos核心: Cocos2DConstants.lua 储存 ccs代表CocoStudio: StudioConstants.lua 储存 ccui代表CocoStudio的UI控件: GuiConstants.lua 储存 cc和ccui倒是很好理解，那么ccs这么理解呢？ 其实应该说相当于C++的命名空间，ccs是cocostudio的缩写，代表在CocoStudio的命名空间（只是类似）。 比如我们发现 之前的cc.ui.xxx是quick自己封装过的控件， 而ccs里面的对象是c++里面的原生控件 若使用cc.ui.xxx将出现在ccs里面有交互的时候无法响应touch事件的问题 必须用ccui.xxx，这个是c++里面的控件，touchEvent也是同一体系的。 并且ccui.ScrollView 对应 cocos2d::ui::ScrollView，cc.ScrollView 对应 cocos2d::extension::ScrollView 我们来看看，最简单而且最常用的Button按钮的创建：这是老版的(quick)cc.ui.UIPushButton.new({ normal = &quot;comm_btnGreenBackBack.png&quot;, pressed = &quot;comm_btnGreenBackBack_sel.png&quot; }) :onButtonClicked(function() print(&quot;start&quot;) end) :pos( display.cx / 2, display.cy ) :addTo(self) 在Quick中有三种不同的Button控件，分别是：UIPushButton (按钮控件)、UICheckBoxButton ( CheckButton 控件)和 UICheckBoxButtonGroup ( CheckButton 组控件)。 其中 UIPushButton 是最常用的按钮控件，它继承自UIButton，我们可以通过 cc.ui.UIPushButton.new(images, options) 方法来创建 UIPushButton。 参数 images 是 table 类型，它代表各个按钮状态（正常、按下、禁用）下的图片；options 为可选参数，也是 tabl e类型，包含了是否scale9缩放，偏移flipX、flipY值等设置。 onButtonClicked 方法用于监听按钮的点击事件，当点击按钮时，将调用该方法中的代码。如上例中，当我们点击按钮时，会在控制台窗口中打印“start”的字段。同 onButtonClicked 方法类似的还有： onButtonPressed(callback)：用于监听按钮的按下事件 onButtonRelease(callback)：用于监听按钮的释放事件 onButtonStateChanged(callback)：用于监听按钮的状态改变事件 新版本Button --这是一个按钮 local btn = ccui.Button:create(&quot;button/btnDog_N.png&quot;, &quot;button/btnDog_P.png&quot;, &quot;button/btnDog_D.png&quot;, 0) :pos(display.cx, 100) :addTo(self) --按钮文字 btn:setTitleText(&quot;按钮&quot;) --字体大小 btn:setTitleFontSize(25) --偏移 btn:setTitleOffset(20, 100) --字体颜色 btn:setTitleColor(cc.c3b(255, 255, 255)) --按钮的回调函数 btn:addTouchEventListener(function(sender, eventType) if (0 == eventType) then print(&quot;pressed&quot;) elseif (1 == eventType) then print(&quot;move&quot;) elseif (2== eventType) then print(&quot;up&quot;) elseif (3== eventType) then print(&quot;cancel&quot;) end end) --按钮无效 --btn:setEnabled(false) 以上就是基本按钮的创建，所以平时在开发中要注意一下API的问题，不然很多错误都不知道问题出在哪里！ 在我们平时使用控件的时候，也同样会遇到一些问题，比如 quick中的cc.ui.UIPushButton和ccui.Layout是不能共存的，在layout存在的情况下UIPushButton是不能被监听到的 如果在quick中使用ccui.Button，那么ccui.Button是不能被屏蔽的，也就是说，无论quick中怎么处理不让ccui.Button被点击都无效，只要他存在，就会被点击。 同时cc.ui.UIScrollView也存在问题，其不能被缩放，但是其父节点可以缩放。 cc.ui.UIListView也存在不能缩放的问题。 也就是说，以上API中，一旦按设计的分辨率来设计，就不能再被缩放。 Api官方文档验证为了验证这个问题我们查看官方文档发现这样的内容： Misc Api changes Use cc、ccs、ccui gl and sp as module name Now classes are bound into different modules instead of using global module. This will avoid conflicts with other codes. classes in cocos2d、cocos2d::extension、CocosDenshion and cocosbuilder were bound to cc module classes in cocos2d::ui were bound to ccui module classes in spine were bound to sp module classes in cocostudio were bound to ccs module global variables are bound to corresponding modules all funcionts and constants about openGl were bound to gl module Examples: | v2.1 | v3.0 | | CCDirector | cc.Director | | CCArmature | ccs.Armature | | kCCTextAlignmentLeft | cc.kCCTextAlignmentLeft | 最终所表达的意思其实就是 现在，类被绑定到不同的模块中，而不是使用全局模块。这将避免与其他代码发生冲突。 CCOS2D、COCOS2D:：扩展、COCOSDENSHION和COCOSUBIDER绑定到CC模块 CCOS2D:：UI绑定到CCUI模块 脊柱类与SP模块结合 COStudio中的类绑定到CCS模块 全局变量绑定到相应模块。 OpenGL的所有函数和常数都绑定到GL模块。 OpenGL和SP可以忽略 实战与代码验证最后，我们为了cc，ccs，ccui专门去寻找了一些关于Api所提供的支持和规律。 cc在Cocos2dConstants.lua中,用来存储cc 模块的常量cc = cc or {} 并且每个可调用的文件对应的最前面也有同样的定义,比如有 Action.lua Animation.lua Director.lua EventDispatcher.lua GLView.lua Hide.lua Image.lua Node.lua Scene.lua Scheduler.lua SpriteFrame.lua SpriteFrameCache.lua TextureCache.lua Timer.lua Touch.lua UserDefault.lua src/cocos/cocos2d/Cocos2d.lua src/cocos/cocos2d/Cocos2dConstants.lua src/cocos/controller/ControllerConstants.lua …… ccs在StudioConstants.lua中,用来存储ccs模块的常量ccs = ccs or {} 并且每个可调用的文件对应的最前面也有同样的定义,比如有 ActionFrame.lua ActionObject.lua Armature.lua Bone.lua ColorFrame.lua ComAttribute.lua ComController.lua Frame.lua Skin.lua TextureFrame.lua Timeline.lua VisibleFrame.lua …… ccui在GuiConstants.lua中,用来存储ccui模块的常量ccui = ccui or {} 并且每个可调用的文件对应的最前面也有同样的定义,比如有 Button.lua CheckBox.lua EditBox.lua Helper.lua ImageView.lua Layout.lua ListView.lua LoadingBar.lua PageView.lua ScrollView.lua Slider.lua Text.lua TextField.lua …… 推荐 https://blog.csdn.net/blackzhangwei/article/details/80088314?utm_source=blogxgwz0 cocos2d-x_v3.0_release_notes.md C++11 新特性]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>游戏</tag>
        <tag>cocos2dx lua cc &amp; ccs &amp; ccui区别和使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx lua 常见错误汇总与解决方案]]></title>
    <url>%2F2018%2F10%2F21%2Fcocos2dx-lua-%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E6%B1%87%E6%80%BB%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[cocos2dx lua开比较苦恼的是，没办法断点或者直接一步一步调试处理，但是幸好官方有点良心，给了一个打印的调试Log，我们可以使用它调试和查找对应的错误。 这里就记录一些，个人学习和实战中遇到的一些错误和问题的总结 not found view “ApiTest” in search paths “app.views” ApiTest不在Views里面或者名字写错了，或者没有初始化 attempt to index upvalue ‘HttpSingleton’ (a boolean value) 末尾没有返回HttpSingleton attempt to index local ‘self’ (a nil value) 参数传错了或者将逗号(.)与冒号(:)搞混了 attempt to call method ‘schedulerScriptFunc’ (a nil value) 方法写错了 attempt to call global ‘getScheduler’ (a nil value) 代码或者语法错误 syntax error during pre-compilation 严重的语法错误 invalid ‘cobj’ in function ‘lua_cocos2dx_Node_getLocalZOrder’ 这个报错是lua的变量还在，但是他底层对应的C++对象已被销毁。 InterpolationMissingOptionError: Bad value substitution: 在执行genbindings.py脚本文件时，不要在该文件的外部路径执行，需要CD到该文件目录下执行./genbindings.py TranslationUnitLoadError: Error parsing translation unit. 基本都是.ini文件没有配置正确，仔细检查一下 .ini文件里的 “headers = ”指向的路径是否正确 Xcode编译错误，header error 再此外，把.hpp和.cpp加进cocos2d_lua_bindings.xcodeproj时，target需要勾选ios。在设置 UserHeaderSearchPaths 时，注意选择该proj的Ios target进行设置 ，不要选择了mac target 选项，否则ios环境编译不过 mportError: No module named yaml 安装了yaml模块，如果还是报错找不到这个模块，这个就是是路径问题，因为我从新安装了python，然而：这里使用的python是系统默认的#!/usr/bin/python，处理好python版本和当前匹配的版本 网上说还有其他方式解决(待验证) import sys sys.path.append(‘/xxx/xxxxx/‘) 加进去也行。 attempt to perform arithmetic on local ‘x’ (a nil value) 忘了记录….. 这里专门说需要关于cocos2dx lua开发中的错误，其实cocos2dx lua中也和iOS中一样，分为两种错误：编译时错误和运行时错误 编译错误，一般是语法上存在问题，编译过不去; 运行错误，是指程序在运行过程中出现错误，只能说是程序存在一定的边界bug; 编译时错误和运行时错误编译错误，比如上面一条 error:syntax error during pre-compliation 就属于编译语法错误，这里报错其实还会有一些提示信息，如果我们可以通过提示信息，找到LuaStack，在LuaStack中有个LuaStack::luaLoadBuffer(…)，然后查看源码如下： switch (r) { case LUA_ERRSYNTAX: // 编译出错 CCLOG(&quot;[LUA ERROR] load \&quot;%s\&quot;, error: syntax error during pre-compilation.&quot;, chunkName); break; case LUA_ERRMEM: // 内存分配错误 CCLOG(&quot;[LUA ERROR] load \&quot;%s\&quot;, error: memory allocation error.&quot;, chunkName); break; case LUA_ERRRUN: // 运行错误 CCLOG(&quot;[LUA ERROR] load \&quot;%s\&quot;, error: run error.&quot;, chunkName); break; case LUA_YIELD: // 线程被挂起 CCLOG(&quot;[LUA ERROR] load \&quot;%s\&quot;, error: thread has suspended.&quot;, chunkName); break; case LUA_ERRFILE: CCLOG(&quot;[LUA ERROR] load \&quot;%s\&quot;, error: cannot open/read file.&quot;, chunkName); break; case LUA_ERRERR: // 运行错误处理函数时发生错误 CCLOG(&quot;[LUA ERROR] load \&quot;%s\&quot;, while running the error handler function.&quot;, chunkName); break; default: CCLOG(&quot;[LUA ERROR] load \&quot;%s\&quot;, error: unknown.&quot;, chunkName); } 所以，无论怎样，出现错误时，都能将错误信息返回到堆栈的最顶层 如果遇到编译错误是，可以通过如下的代码来打印错误信息：在以上{}之外的后面加const char* error = lua_tostring(L, -1); CCLOG(&quot;[LUA ERROR] error result: %s&quot;,error); lua_pop(L, 1); 运行错误而针对于运行错误，一般情况下，你可以参考如下代码(此代码在main.lua中)： -- lua提供，调用其他函数，可以捕捉到错误，第一个参数为要调用的函数， 第二个参数为捕捉到错误时所调用的函数 -- 返回的参数status为错误状态， msg为错误信息 local status, msg = xpcall(main, __G__TRACKBACK__) if not status then print(msg) end 推荐 http://www.cocoachina.com/bbs/read.php?tid=200145 https://blog.csdn.net/msdb198901/article/details/52128175]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>事件</tag>
        <tag>cocos2dx lua 常见错误汇总与解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx lua TableView(ScrollView, ListView)介绍与使用实战]]></title>
    <url>%2F2018%2F10%2F19%2Fcocos2dx-lua-TableView-ScrollView-ListView-%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[在众多移动应用中，能看到各式各样的列表/表格数据 不管是iOS中的UITableView/UICollectionView/UIScrollView,还是Android中的ListView/CircleView，都是实际项目开发中使用最平凡，也是最重要的功能。 为了用户考虑，也为了性能考虑， 我们一般都会重复利用所创建的列表项，这样就避免了界面卡顿。cocos2dx lua 3.x中有一个TabeView，效果和上面列举的那些做列表的一样，尤其与iOS中UITableView方法属性，使用方式都有很多相似的地方。 游戏开发中，虽然没有和普通应用那么多列表，但是也会有些消息列表，用户，排行榜等，所以，这篇我们就来看看如何用TableView以及解决在实际开发中的一些问题。 TableView使用直接上代码，这里我们使用cocos2dx lua提供TableView实现水平和垂直的列表，基本满足常见功能，具体细节，可以根据注释或者代码逻辑，结合实际需求进行调整和优化 local TableScene = class(&quot;TableScene&quot;) TableScene.__index = TableScene --这里是为了让layer能调用TableViewTestLayer的方法 function TableScene.extend(target) local t = tolua.getpeer(target) if not t then t = {} tolua.setpeer(target, t) end setmetatable(t, TableScene) return target end --滚动事件 function TableScene.scrollViewDidScroll(view) --print(&quot;滚动事件&quot;) end function TableScene.scrollViewDidZoom(view) print(&quot;scrollViewDidZoom&quot;) end --cell点击事件 function TableScene.tableCellTouched(table,cell) print(&quot;点击了cell：&quot; .. cell:getIdx()) end --cell的大小，注册事件就能直接影响界面，不需要主动调用 function TableScene.cellSizeForTable(table,idx) return 150,150 end --显示出可视部分的界面，出了裁剪区域的cell就会被复用 function TableScene.tableCellAtIndex(table, idx) local strValue = string.format(&quot;%d&quot;,idx) print(&quot;数据加载&quot;..strValue) local cell = table:dequeueCell() local label = nil if nil == cell then print(&quot;创建了新的cell&quot;) cell = cc.TableViewCell:new() --添加cell内容 local sprite = display.newSprite(&quot;res/apple.png&quot;) sprite:setAnchorPoint(cc.p(0,0)) sprite:setPosition(cc.p(0, 0)) cell:addChild(sprite) label = cc.Label:createWithSystemFont(strValue, &quot;Helvetica&quot;, 40) label:setPosition(cc.p(0,0)) label:setAnchorPoint(cc.p(0,0)) label:setColor(cc.c3b(255,0,0)) label:setTag(123) cell:addChild(label) else print(&quot;使用已经创建过的cell&quot;) label = cell:getChildByTag(123) if nil ~= label then label:setString(strValue) end end return cell end --设置cell个数，注册就能生效，不用主动调用 function TableScene.numberOfCellsInTableView(table) return 100 end function TableScene:init() local visiableSize = cc.Director:getInstance():getVisibleSize() local origin = cc.Director:getInstance():getVisibleOrigin() local winSize = cc.Director:getInstance():getWinSize() local isVERTICAL = false if isVERTICAL then ----------------------------------------------------------- --创建TableView local tableView = cc.TableView:create(cc.size(winSize.width - 20,150)) --设置滚动方向 水平滚动 tableView:setDirection(cc.SCROLLVIEW_DIRECTION_HORIZONTAL) tableView:setPosition(cc.p(10, winSize.height / 2)) tableView:setDelegate() self:addChild(tableView) --registerScriptHandler functions must be before the reloadData funtion --注册脚本编写器函数必须在reloadData函数之前（有道自动翻译） --cell个数 tableView:registerScriptHandler(TableScene.numberOfCellsInTableView,cc.NUMBER_OF_CELLS_IN_TABLEVIEW) --滚动事件 tableView:registerScriptHandler(TableScene.scrollViewDidScroll,cc.SCROLLVIEW_SCRIPT_SCROLL) tableView:registerScriptHandler(TableScene.scrollViewDidZoom,cc.SCROLLVIEW_SCRIPT_ZOOM) --cell点击事件 tableView:registerScriptHandler(TableScene.tableCellTouched,cc.TABLECELL_TOUCHED) --cell尺寸、大小 tableView:registerScriptHandler(TableScene.cellSizeForTable,cc.TABLECELL_SIZE_FOR_INDEX) --显示出可视部分的cell tableView:registerScriptHandler(TableScene.tableCellAtIndex,cc.TABLECELL_SIZE_AT_INDEX) --调用这个才会显示界面 tableView:reloadData() ----------------------------------------------------------- else ----------------------------------------------------------- --跟上面差不多，这里是创建一个“垂直滚动”的TableView tableView = cc.TableView:create(cc.size(200, winSize.height - 20)) tableView:setDirection(cc.SCROLLVIEW_DIRECTION_VERTICAL) tableView:setPosition(cc.p(winSize.width / 2, 10)) tableView:setDelegate() tableView:setVerticalFillOrder(cc.TABLEVIEW_FILL_TOPDOWN) self:addChild(tableView) --registerScriptHandler functions must be before the reloadData funtion --注册脚本编写器函数必须在reloadData函数之前（有道自动翻译） --cell个数 tableView:registerScriptHandler(TableScene.numberOfCellsInTableView,cc.NUMBER_OF_CELLS_IN_TABLEVIEW) --滚动事件 tableView:registerScriptHandler(TableScene.scrollViewDidScroll,cc.SCROLLVIEW_SCRIPT_SCROLL) tableView:registerScriptHandler(TableScene.scrollViewDidZoom,cc.SCROLLVIEW_SCRIPT_ZOOM) --cell点击事件 tableView:registerScriptHandler(TableScene.tableCellTouched,cc.TABLECELL_TOUCHED) --cell尺寸、大小 tableView:registerScriptHandler(TableScene.cellSizeForTable,cc.TABLECELL_SIZE_FOR_INDEX) --显示出可视部分的cell tableView:registerScriptHandler(TableScene.tableCellAtIndex,cc.TABLECELL_SIZE_AT_INDEX) --调用这个才会显示界面 tableView:reloadData() ----------------------------------------------------------- end return true end --这里是为了让layer能调用TableViewTestLayer的方法 function TableScene.create() local layer = TableScene.extend(cc.Layer:create()) if nil ~= layer then layer:init() end return layer end return TableScene 测试验证--[LUA-print] 数据加载0 --[LUA-print] 创建了新的cell --[LUA-print] 数据加载1 --[LUA-print] 创建了新的cell --[LUA-print] 数据加载2 --[LUA-print] 创建了新的cell --[LUA-print] 数据加载3 --[LUA-print] 创建了新的cell --[LUA-print] 数据加载4 --[LUA-print] 创建了新的cell --[LUA-print] 数据加载5 --[LUA-print] 创建了新的cell --[LUA-print] 数据加载6 --[LUA-print] 创建了新的cell --[LUA-print] 数据加载7 --[LUA-print] 创建了新的cell --[LUA-print] 数据加载8 --[LUA-print] 创建了新的cell --[LUA-print] 数据加载9 --[LUA-print] 使用已经创建过的cell --[LUA-print] 数据加载10 --[LUA-print] 使用已经创建过的cell --[LUA-print] 数据加载11 --[LUA-print] 使用已经创建过的cell --[LUA-print] 数据加载12 --[LUA-print] 使用已经创建过的cell --[LUA-print] 数据加载13 --[LUA-print] 使用已经创建过的cell --[LUA-print] 数据加载14 --[LUA-print] 使用已经创建过的cell --[LUA-print] 数据加载15 --[LUA-print] 使用已经创建过的cell --[LUA-print] 数据加载16 --[LUA-print] 使用已经创建过的cell --[LUA-print] 数据加载17 --[LUA-print] 使用已经创建过的cell --[LUA-print] 数据加载18 --[LUA-print] 使用已经创建过的cell --[LUA-print] 数据加载19 --[LUA-print] 使用已经创建过的cell --[LUA-print] 数据加载20 基本上重用了iOS中的UITableView机制，并且非常流畅的滑动显示一个完整的列表 注意点：reloadData()的调用和上面图层之前的关系 美中不足的是cocos创建的这个tableView也是有bug的，如果你的这个tableView有点击事件，不妨你上下滑动几下item，然后在隐藏的上下方点击，是不是仍然有点击事件呢。简单一招，添加Panel遮挡，勾上交互性轻松搞定。 cocos2dx lua中老版的listView也可以实现统一的功能，但是只能加载少量的item,多了就会很卡，所以推荐以后直接使用TableView。 其他拓展网上有其他相关的一些教程，可以省去UI的搭建 先用CocosStudio或CocosCreator制作UI界面 看这篇文章：http://blog.csdn.net/fjdmy001/article/details/52982515 然后修改config.json, 窗口的配置文件，想设置模拟器的大小就在这里设置 竖屏：”isLandscape” = false 尺寸：”width” = 540, “height” = 960 修改config.lua 游戏的配置文件 开启全局变量：CC_DISABLE_GLOBAL = false 设计尺寸：width = 1080，height = 1920，autoscale = “FIXED_HEIGHT” 使用cocos2dx的相关方法加载对应的文件，然后类似的方法去加载对应的内容(和iOS中定义tableview与cell类似) 具体可参考这里： 排行榜之ScrollView：https://blog.csdn.net/fjdmy001/article/details/52997012 排行榜之TableView：https://blog.csdn.net/fjdmy001/article/details/52998376]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>事件</tag>
        <tag>cocos2dx lua TableView(ScrollView, ListView)介绍与使用实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx lua 绑定详解与实战]]></title>
    <url>%2F2018%2F10%2F18%2Fcocos2dx-lua-%E7%BB%91%E5%AE%9A%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[我们平时在开发cocos2dx lua游戏的时候的，会遇到这样的情况： 在c++层定义了一些类，我们需要将这些类导出给Lua来使用，从而完成在c++层实现起来容易的需求，这个时候就需要将整个类作为模块导出。 而Cocos2d-x正是采用的这种思想，将Cocos中的类导出供用户使用，而不是再写一套Lua代码，用户使用Cocos导出的这套接口，在Lua脚本层写游戏代码。 为了更好的理解这部分的内容，可以先了解c++中调用Lua的机制。 推荐 手动绑定自定义类中的函数 自动绑定自定义类中的函数 前面文章中，我们说到了，Lua的本质是C，不是C++，Lua提供给C用的API也都是基于面向过程的C函数来用的，要把C++类注册进Lua形成一个一个的table环境是不太容易一下子办到的事。 为了实现我们的需求，同样也是官方的需求，在Cocos 2.x版本的时候，使用的是tolua++这个工具，但是这个工具用起来相当的麻烦，耗费体力，所以现在使用的是bindings-generator工具（官方用Python写的一个工具），这个东西底层使用的也应该是tolua++。 这里只针对iOS平台，Android和其他平台在tolua中README.mdown中有具体介绍，其他步骤基本上一样！ 在项目跟目录framework/cocos2d-x/cocos中创建mybinding文件夹，里面创建一个MyBinding.h文件(mybinding, MyBinding自定义)，输入如下测试代码 #include &quot;cocos2d.h&quot; namespace cocos2d { class MyBinding: public Ref { public: virtual bool init() { return true; } void sayBinding() { log(&quot;Hello Binding Lua&quot;); } MyBinding(); ~MyBinding(); } } 在framework/cocos2d-x/tools/tolua，新建一个配置文件，这里命名cocos2dx_binding.ini 输入下面代码：（处理标记修改处其他所有都一样） [cocos2dx_binding] # 标记修改 # the prefix to be added to the generated functions. You might or might not use this in your own # templates prefix = cocos2dx_binding # 标记修改 # create a target namespace (in javascript, this would create some code like the equiv. to `ns = ns || {}`) # all classes will be embedded in that namespace target_namespace = cc # 标记修改 # --------- ? #android_headers = -I%(androidndkdir)s/platforms/android-19/arch-arm/usr/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.7/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.7/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.8/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.8/include android_headers = -I%(androidndkdir)s/platforms/android-19/arch-arm/usr/lib -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/include # --------- ? android_flags = -D_SIZE_T_DEFINED_ #clang_headers = -I%(clangllvmdir)s/lib/clang/%(clang_version)s/include clang_headers = -I%(clangllvmdir)s/lib64/clang/5.0/include clang_flags = -nostdinc -x c++ -std=c++11 -U __SSE__ # --------- ? # -I%(cocosdir)s/jsext -I%(cocosdir)s/jsext/system -I%(cocosdir)s/jsext/alipay -I%(cocosdir)s/jsext/video -I%(cocosdir)s/jsext/webview -I%(cocosdir)s/jsext/umeng cocos_headers = -I%(cocosdir)s -I%(cocosdir)s/cocos -I%(cocosdir)s/cocos/base -I%(cocosdir)s/cocos/platform/android -I%(cocosdir)s/extensions -I%(cocosdir)s/external -I%(cocosdir)s/cocos/editor-support -I%(cocosdir)s/cocos/network -I%(cocosdir)s/cocos/ui/UIEditBox -I%(cocosdir)s/cocos/ui #cocos_headers = -I%(cocosdir)s -I%(cocosdir)s/cocos -I%(cocosdir)s/cocos/platform/android cocos_flags = -DANDROID cxxgenerator_headers = # extra arguments for clang extra_arguments = %(android_headers)s %(clang_headers)s %(cxxgenerator_headers)s %(cocos_headers)s %(android_flags)s %(clang_flags)s %(cocos_flags)s %(extra_flags)s # what headers to parse 头文件路径 headers = %(cocosdir)s/cocos/mybinding/MyBinding.h # 标记修改 # what classes to produce code for. You can use regular expressions here. When testing the regular # expression, it will be enclosed in &quot;^$&quot;, like this: &quot;^Menu*$&quot;. #包含的类，新添加文件需要修改 classes = MyBinding.* # 标记修改 #需要在js里面派生的类 #classes_need_extend = MyBinding # 标记修改 # what should we skip? in the format ClassName::[function function] # ClassName is a regular expression, but will be used like this: &quot;^ClassName$&quot; functions are also # regular expressions, they will not be surrounded by &quot;^$&quot;. If you want to skip a whole class, just # add a single &quot;*&quot; as functions. See bellow for several examples. A special class name is &quot;*&quot;, which # will apply to all class names. This is a convenience wildcard to be able to skip similar named # functions from all classes. skip = rename_functions = rename_classes = # for all class names, should we remove something when registering in the target VM? remove_prefix = # classes for which there will be no &quot;parent&quot; lookup classes_have_no_parents = # base classes which will be skipped when their sub-classes found them. base_classes_to_skip = Ref # classes that create no constructor # Set is special and we will use a hand-written constructor abstract_classes = # Determining whether to use script object(js object) to control the lifecycle of native(cpp) object or the other way around. Supported values are &apos;yes&apos; or &apos;no&apos;. script_control_cpp = no 注意检查一下三个头文件对应的路径及文件问题 android_headers clang_headers cocos_headers 说明内容：+ •[title]：要配置将被使用的工具/ tolua的/ gengindings.py脚本的称号。一般来说，标题可以是文件名。 + •prefix：要配置一个函数名的前缀，通常，我们还可以使用文件名作为前缀。 + •target_namespace：要配置在脚本层模块的名字。在这里，我们使用cc作为模块名，当你想在脚本层REF的名称，您必须将一个名为前缀，CC在名称的前面。例如，CustomClass可以参考作为cc.CustomClass。 + •headers：要配置所有需要解析的头文件和％（cocosdir）s是的Cocos2d-x的引擎的根路径。 + •classes：要配置所有绑定所需的类。在这里，它支持正则表达式。因此，我们可以设置MyCustomClass。*在这里，用于查找多个特定的用法，你可以对照到tools/tolua/cocos2dx.ini。 + •skip：要配置需要被忽略的功能。现在绑定发电机无法解析的void *类型，并委托类型，所以这些类型的需要进行手动绑定。而在这种情况下，你应该忽略所有这些类型，然后再手动将它们绑定。你可以对照到配置文件路径下的cocos/scripting/lua-bindings/auto 。 + •rename_functions：要配置的功能需要在脚本层进行重命名。由于某些原因，开发者希望更多的脚本友好的API，所以配置选项就是为了这个目的。 + •rename_classes：不在使用。 + •remove_prefix：不在使用。 + •classes_have_no_parents：要配置是过滤器所需要的父类。这个选项是很少修改。 + •abstract_classes：要配置的公共构造并不需要导出的类。 + •script_control_cpp：是的。要配置脚本层是否管理对象的生命周期。如果没有，那么C++层关心他们的生命周期。现在，它是不完善的，以控制原生对象的续航时间在脚本层。所以，你可以简单地把它设置为no 修改framework/cocos2d-x/tools/tolua里面的genbindings.py。有个cmd_args键值对的配置，增加下面代码，作为自定义绑定配置 &apos;cocos2dx_binding.ini&apos; : (&apos;cocos2dx_binding&apos;, &apos;lua_cocos2dx_binding_auto&apos;), \ 注：python注释为#，这里将cmd_args其他的元素注释掉是因为这些文件都是生成过得，没必要再生成浪费时间这行代码表示在cocos2dx_custom中找到cocos2dx_custom的模块，然后生成lua_cocos2dx_custom_auto文件 这里要确保NDK_ROOT，和PYTHON_BIN安装切配置好了,然后在framework/cocos2d-x/tools/tolua执行 ./genbindings.py 之前./genbindings.py之前，请先查看官方tolua中README文件，按照对应的流程，安装好需要的依赖，和相应的库，下面是我这边3.17最新的README * The OSX 10.1&lt;!--0 has a built-in python2.7 and if your os don&apos;t have python2.7 then use [Homebrew](http://brew.sh/) to install the python and use pip install the python dependencies. &lt;pre&gt; brew install python &lt;/pre&gt; * Install python dependices by pip. &lt;pre&gt; sudo easy_install pip sudo pip install PyYAML sudo pip install Cheetah &lt;/pre&gt; * Download NDK 64bit r10c or later from [Android Ndk](https://developer.android.com/ndk/downloads/index.html) * Run &lt;pre&gt; export NDK_ROOT=/path/to/android-ndk-10c ./genbindings.py &lt;/pre&gt;--&gt; 大概意思就是下载r10c之后版的NDK本，然后安装python(这一步一般Mac都有，但是最好安装到2.x)。 大概意思就是安装，pip， PyYAML， Cheetah ……. 执行./genbindings.py之后生成在 工程目录\frameworks\cocos2d-x\cocos\scripting\lua-bindings\auto 下便有了两个生成的文件 lua_cocos2dx_custom_auto.cpp lua_cocos2dx_custom_auto.hpp 进入到文件夹 C:\Users\user\Documents\Cocos\Link\frameworks\cocos2d-x\cocos\scripting\lua-bindings\manual 打开CCLuaStack.cpp，添加 #include &quot;lua_cocos2dx_custom_auto.hpp&quot; register_all_cocos2dx_custom(_state); 期间遇到的错误错误一Traceback (most recent call last): File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1799, in &lt;module&gt; main() File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1772, in main &apos;clang_args&apos;: (config.get(s, &apos;extra_arguments&apos;, 0, dict(userconfig.items(&apos;DEFAULT&apos;))) or &quot;&quot;).split(&quot; &quot;), File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/ConfigParser.py&quot;, line 623, in get return self._interpolate(section, option, value, d) File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/ConfigParser.py&quot;, line 691, in _interpolate self._interpolate_some(option, L, rawval, section, vars, 1) File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/ConfigParser.py&quot;, line 726, in _interpolate_some section, map, depth + 1) File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/ConfigParser.py&quot;, line 723, in _interpolate_some option, section, rest, var) InterpolationMissingOptionError: Bad value substitution: section: [cocos2dx_custom] option : extra_arguments key : clang_version rawval : /include 路径错误 #clang_headers = -I%(clangllvmdir)s/lib/clang/%(clang_version)s/include clang_headers = -I%(clangllvmdir)s/lib64/clang/5.0/include # --------- ? 错误二Traceback (most recent call last): File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1799, in &lt;module&gt; main() File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1795, in main generator.generate_code() File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1444, in generate_code self._parse_headers() File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1487, in _parse_headers raise Exception(&quot;Fatal error in parsing headers&quot;) Exception: Fatal error in parsing headers --------------------------------- Generating lua bindings fails. --------------------------------- C++语法错误 错误三Generating bindings for cocos2dx_custom... Using userconfig [(&apos;androidndkdir&apos;, &apos;/Users/iCocos/tools/android-ndk-r16b&apos;), (&apos;clangllvmdir&apos;, &apos;/Users/iCocos/tools/android-ndk-r16b/toolchains/llvm/prebuilt/darwin-x86_64&apos;), (&apos;gcc_toolchain_dir&apos;, &apos;/Users/iCocos/tools/android-ndk-r16b/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64&apos;), (&apos;cocosdir&apos;, &apos;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x&apos;), (&apos;cxxgeneratordir&apos;, &apos;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator&apos;), (&apos;extra_flags&apos;, &apos;&apos;)] .... Generating bindings for target lua .... .... Processing section cocos2dx_custom Traceback (most recent call last): File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1799, in &lt;module&gt; main() File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1795, in main generator.generate_code() File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1444, in generate_code self._parse_headers() File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/generator.py&quot;, line 1478, in _parse_headers tu = self.index.parse(header, self.clang_args) File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/clang/cindex.py&quot;, line 2602, in parse self) File &quot;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/tools/bindings-generator/clang/cindex.py&quot;, line 2714, in from_source raise TranslationUnitLoadError(&quot;Error parsing translation unit.&quot;) TranslationUnitLoadError: Error parsing translation unit. --------------------------------- Generating lua bindings fails. --------------------------------- 路径错误 #android_headers = -I%(androidndkdir)s/platforms/android-19/arch-arm/usr/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.7/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.7/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.8/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.8/include android_headers = -I%(androidndkdir)s/platforms/android-19/arch-arm/usr/lib -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.9/include 错误四==== Errors in parsing headers: 1. &lt;severity = Fatal, location = &lt;SourceLocation file &apos;/Users/iCocos/Desktop/cocos2d/Products/cocos2dx-demo/SingleLua/frameworks/cocos2d-x/cocos/platform/android/CCPlatformDefine-android.h&apos;, line 33, column 10&gt;, details = &quot;&apos;android/log.h&apos; file not found&quot;&gt; ==== ….. 提示成功--------------------------------- Generating lua bindings succeeds. --------------------------------- 拓展推荐 lua： http://www.lua.org/ lua是个脚本语言，脚本语言！！就是脚本文件加解释器。之后你就可以看效果了。可是呢，lua如果正是靠自己独立完成点事情，那就是大材小用，需要和其他东西结合起来，比如C/C++.貌似主要也就是C/C++。 tolua++： http://www.codenix.com/~tolua/#news tolua++：首先看名字“到、lua、++”，就是把其他语言（C/C++函数对象转化为lua能调用形式，++这里理解为增强版），有了这个工具，我们就可以快速的将我们现成的C/C++代码封装成Lua接口形式。 luajit： http://luajit.org/luajit.html LuaJIT：LuaJIT is a Just-In-Time Compiler (JIT) for the Lua programming language. 。。。。。。说了半天就一个lua的高效率版本。 lua for windows： http://luaforge.net/projects/luaforwindows/ lua for windows：lua在windows下的打包版本，除了最基本的lua解释器，还包括了可用于和C/C++集成开发的【动态链接库、静态链接库、头文件】、文本编辑器、常用的lua module，帮助说明文档。 致谢： https://blog.csdn.net/never_QH/article/details/45148835 http://geekgaoyang.herokuapp.com/blog/2015/02/11/cocos2d-x-tutorial-of-binding-c-plus-plus-class-to-lua-usage/ https://www.cnblogs.com/ZhYQ-Note/p/5939783.html http://www.bubuko.com/infodetail-1210197.html https://www.jianshu.com/p/9bd4d5518d53]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>事件</tag>
        <tag>cocos2dx lua 绑定详解与实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx lua 与 C/C++ 交互入门]]></title>
    <url>%2F2018%2F10%2F16%2Fcocos2dx-lua-%E4%B8%8E-C-C-%E4%BA%A4%E4%BA%92%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[目录 中间栈 1.中间件栈 C/C++访问Lua数据和函数 Lua访问C/C++数据和函数 集成Lua 集成Lua环境到C_Cpp项目中 C/C++ 调用Lua C/C++调用Lua之标准Lua读取类 C/C++调用Lua中的变量 C/C++调用Lua中的函数 C/C++调用Lua之遍历和获取Table的值 Lua 调用 C/C++ 1.Lua调用C/C++函数 深入理解编写C函数上 深入理解编写C函数下 2.Lua调用C/C++之标准C模块 待续 中间栈 lua(https://www.lua.org/)作为一种轻量级的脚本语言, 以其简单的语法结构, 方便的c++集成能力, 高效的执行效率收到广大游戏开发者的热爱, 也是cocos2d-x官方首次引入的脚本语言. 作为一种脚本语言, lua是在一个运行时环境(State)里执行的, 这个运行时环境保存了脚本运行所需的内存空间, 创建的全局变量, 加载的库文件等. 在这个运行时环境里还有一个栈空间(Stack), 其作用就是在lua和c语言进行数据传递和函数调用. lua原生实现了很多c api对栈空间进行操作, 让开发者能够方便地实现lua脚本代码与c编译代码的双向通信. 推荐：Lua中的栈概念 Lua的栈是一个线性数组，栈中的每一项元素的类型都是TValue，它是Lua表示内部数据的数据结构。栈的最大空间在luaconf.h中给出：#define LUAI_MAXSTACK 1000000。 栈包括：基指针、栈顶指针、栈大小。图中的stack-&gt;top表示栈顶指针。其实在Lua中栈的很多空间都留作它用，如call info也使用一部分的栈。 1.中间件栈 背后其实是lua和c api的互相调用, 所有c++的功能都要通过一层c函数的包装, 这点是要牢记在心的, 这也正是lua-binding的核心. cocos2d-x提供的lua-bingding工具使用libclang分析c++源码, 提取语法树, 将c++的类成员函数封装为c函数, 然后根据参数类型自动调用lua c api, 实现对栈空间的操作, 将c++的数据传递给lua. lua脚本加载编译好的c++库, 就可以自由调用c++里面的类对象和成员函数了; c++的代码则可以直接使用lua c api, 执行一段lua脚本, 并通过栈空间获取返回结果. 执行过程如下： 1）C程序读取Lua脚本 2）lualib库解析脚本，并保存解析结果。 3）通过Lua API，将解析结果中的某一个值放入栈中。 4）C程序通过Lua提供的API到栈中取得数据。 经过上面的过程C语言程序和Lua脚本就能相互传值了。开始撸代码 ——————————- 华丽的分割线 ——————————- 创建一个Lua管理类，用利用栈的原理，使用C++简单访问Lua .h文件#ifndef LuaInterface01_h #define LuaInterface01_h #include &lt;stdio.h&gt; #include &quot;lua.hpp&quot; class LuaInterface01 { public: static LuaInterface01 *shareInterface(); private: static LuaInterface01 *i; void init(); }; #endif /* LuaInterface01_hpp */ .cpp文件#include &quot;LuaInterface01.h&quot; #include &quot;cocos2d.h&quot; #include &lt;string&gt; USING_NS_CC; using namespace std; LuaInterface01 *LuaInterface01::i = NULL; LuaInterface01 *LuaInterface01::shareInterface() { if (!i) { i = new LuaInterface01; i -&gt; init(); } return i; } void LuaInterface01::init() { // 创建一个Lua状态指针 lua_State *luaState = luaL_newstate(); luaL_openlibs(luaState); string path = CCFileUtils::sharedFileUtils()-&gt;fullPathForFilename(&quot;Interface01.lua&quot;); luaL_dofile(luaState, path.c_str()); lua_pcall(luaState, 0, 0, 0); // Hello iCocos LuaInterface01! } 新建一个.lua的访问类文件，并且输入print(&quot;Hello iCocos LuaInterface01!&quot;) 控制答应结果：Hello iCocos LuaInterface01! 下面用简单的Lua与C/C++互调，验证中间件栈， 如果想了解更多或者更详细的实现Lua与C/C++，请略过本小结，滑到第三部分，或者通过目录寻找需要的内容！ C/C++访问Lua数据和函数创建一个Lua管理类，.h文件#ifndef LuaInterface02_h #define LuaInterface02_h #include &lt;stdio.h&gt; #include &quot;lua.hpp&quot; #include &quot;cocos2d.h&quot; USING_NS_CC; class LuaInterface02 { public: LuaInterface02(); ~LuaInterface02(); static LuaInterface02 *shareInterface(); void init(); void readVariable(); void loadFunstion(); private: static LuaInterface02 *i; lua_State *m_pLuaState; }; #endif /* LuaInterface02_h */ .cpp文件#include &quot;LuaInterface02.h&quot; #include &lt;string&gt; using namespace std; LuaInterface02 *LuaInterface02::i = NULL; LuaInterface02::LuaInterface02() { } LuaInterface02::~LuaInterface02() { if (m_pLuaState) { lua_close(m_pLuaState); m_pLuaState = NULL; } } LuaInterface02 *LuaInterface02::shareInterface() { if (!i) { i = new LuaInterface02; i -&gt; init(); } return i; } void LuaInterface02::init() { m_pLuaState = luaL_newstate(); luaL_openlibs(m_pLuaState); } void LuaInterface02::readVariable() { string path = CCFileUtils::sharedFileUtils()-&gt;fullPathForFilename(&quot;Interface02.lua&quot;); luaL_dofile(m_pLuaState, path.c_str()); int err_relt = lua_pcall(m_pLuaState, 0, 0, 0); CCAssert(err_relt, &quot;读取Lua文件错误&quot;); lua_getglobal(m_pLuaState, &quot;username&quot;); char *rlt = (char*)lua_tostring(m_pLuaState, -1); //lua_tonumber,lua_toboolean CCLOG(&quot;rlt is : %s&quot;, rlt); lua_pop(m_pLuaState, 1); } void LuaInterface02::loadFunstion() { string path = CCFileUtils::sharedFileUtils()-&gt;fullPathForFilename(&quot;Interface02.lua&quot;); luaL_dofile(m_pLuaState, path.c_str()); int err_relt = lua_pcall(m_pLuaState, 0, 0, -1); CCAssert(err_relt != -1, &quot;读取Lua文件错误&quot;); lua_getglobal(m_pLuaState, &quot;getResult&quot;); lua_pushnumber(m_pLuaState, 12); err_relt = lua_pcall(m_pLuaState, 1, 2, -1); // 1： 一个参数， 2：两个参数 ， -1：当出错的时候的返回值 CCAssert(err_relt != -1, &quot;访问函数报错&quot;); char *rlt = (char*)lua_tostring(m_pLuaState, -1); //lua_tonumber,lua_toboolean CCLOG(&quot;rlt is : %s&quot;, rlt); char *rlt2 = (char*)lua_tostring(m_pLuaState, -2); //lua_tonumber,lua_toboolean CCLOG(&quot;rlt2 is : %s&quot;, rlt2); } 新建一个.lua的访问类文件，并且输入username = &quot;iCocos&quot; function getResult(x) print(&quot;Enter Result&quot;) print(&quot;x:&quot;..x) return &quot;OK&quot;,&quot;Function&quot; end 控制答应结果：rlt is : iCocos Enter Result x:12 rlt is : Function rlt2 is : OK Lua访问C/C++数据和函数LuaInterface02.h中增加函数// 调用C++ static int l_show(lua_State * L) { lua_pushstring(L, &quot;String from C/C++&quot;); return 1; } 然后在init()中输入执行方法// 调用C++ lua_pushcfunction(m_pLuaState, l_show); lua_setglobal(m_pLuaState, &quot;show&quot;); 然后在.lua的访问类文件，并且输入print(show()) 控制答应结果：String from C/C++ 总结 简单点讲就是维护了一个堆栈，需要交互的数据通过入栈，出栈操作来传递数据。而具体脚本语言的实现机制，一般来说都会有一个编译模块、一个虚拟机（执行）模块、一套类型实现及数据管理模块，通常还会有一个供外部操作的接口，如lua c api，这个接口让嵌入方得以操作脚本状态（如访问变量、调用函数、管理内存），实现交互。 最后，总结一下，所有程序最终都是以机器码的形式被硬件CPU执行，从这个角度去看，不同语言的代码并没有本质区别，最终都是被编译器编译从二进制机器码，而所谓交互，就是在处理共享数据而已。 注意 Lua与C/C++或C/C++语言之前那通信过程中，实际上更多的时候是对栈顶的元素进行操作 从栈顶往下看索引是-1-2-3… 从栈底往上看索引是1，2，3… 无论从Lua调C/C++，还是C/C++调Lua，参数值都是最先被压入到栈顶的，最后结果值才会被压入到栈顶 集成Lua集成Lua环境到C/C++项目中 下载并获取到Lua源代码(src文件夹就是lua源码)https://www.lua.org/ 在lua中文件类型有三种 .c c文件 .h 头文件 .o 可执行文件 开始接入 接入Lua到C/C++的时候需要删除 lua.c luac.c MakeFile 新建一个Xcode项目，拷贝src文件夹到项目中就可以了 最后 在llex.c中trydecpoint, 修改里面decpoint=“getlocaldecpoint” decpoint=’.’ 如果不改会导致编译报错 验证 新建一个C++文件，在头文件中输入 #include &lt;stdio.h&gt; #include &quot;lua.hpp&quot; #include &quot;cocos2d.h&quot; USING_NS_CC; class TestInportLua { public: void test() { lua_State *state = luaL_newstate(); luaL_openlibs(state); luaL_dofile(state, &quot;res/test.lua&quot;); } } #endif /* TestInportLua_h */ C/C++ 调用LuaC/C++调用Lua之标准Lua读取类创建一个Lua管理类，.h文件#ifndef LuaInterface03_hpp #define LuaInterface03_hpp #include &quot;cocos2d.h&quot; #include &quot;lua.hpp&quot; #include &lt;string&gt; USING_NS_CC; using namespace std; class LuaInterface03 { public: LuaInterface03(); ~LuaInterface03(); static LuaInterface03 *shareInterface(); void readVailable(); void loadFunciton(); private: static LuaInterface03 *i; lua_State *m_pLuaState; void init(); }; #endif /* LuaInterface03_hpp */ .cpp文件#include &quot;LuaInterface03.h&quot; LuaInterface03 *LuaInterface03::i = NULL; LuaInterface03::LuaInterface03(){} LuaInterface03::~LuaInterface03(){ lua_close(m_pLuaState); m_pLuaState = NULL; } void LuaInterface03::init() { // 创建一个新的状态 m_pLuaState = luaL_newstate(); // 打开所有系统提供的库 luaL_openlibs(m_pLuaState); // 完整路径 string path = CCFileUtils::sharedFileUtils()-&gt;fullPathForFilename(&quot;LuaInterface03.lua&quot;); // 读取文件 luaL_dofile(m_pLuaState, path.c_str()); // 启动调用文件 lua_pcall(m_pLuaState, 0, 0, -1); } LuaInterface03 *LuaInterface03::shareInterface() { if (!i) { i = new LuaInterface03; i -&gt; init(); } return i; } 新建一个.lua的访问类文件，并且输入print(&quot;=======&gt; I am Lua Config&quot;) 控制答应结果：=======&gt; I am Lua Config C/C++调用Lua中的变量增加方法和对应的实现，用来获取变量void configWindowContentSize(); void LuaInterface03::configWindowContentSize() { lua_getglobal(m_pLuaState, &quot;width&quot;); // 是否能转换成number if (lua_isnumber(m_pLuaState, -1)) { int width = (int)lua_tonumber(m_pLuaState, -1); CCLOG(&quot;width: %i&quot;, width); } lua_getglobal(m_pLuaState, &quot;height&quot;); if (lua_isnumber(m_pLuaState, -1)) { int height = (int)lua_tonumber(m_pLuaState, -1); CCLOG(&quot;height: %i&quot;, height); } } Lua中增加变量width = 320 height = 640 控制答应结果：width: 320 height: 640 C/C++调用Lua中的函数增加方法和对应的实现，用来获取变量void callLuaFunctionContent(); void LuaInterface03::callLuaFunctionContent() { lua_getglobal(m_pLuaState, &quot;test1&quot;); int err_relt = lua_pcall(m_pLuaState, 0, 0, -1); CCAssert(err_relt != -1, &quot;访问函数报错&quot;); lua_getglobal(m_pLuaState, &quot;test2&quot;); lua_pushstring(m_pLuaState, &quot;test2 调用&quot;); err_relt = lua_pcall(m_pLuaState, 1, 0, -1); // 1： 一个参数， 2：两个参数 ， -1：当出错的时候的返回值 CCAssert(err_relt != -1, &quot;访问函数报错&quot;); lua_getglobal(m_pLuaState, &quot;test3&quot;); err_relt = lua_pcall(m_pLuaState, 0, 0, -1); CCAssert(err_relt != -1, &quot;访问函数报错&quot;); char* rlt = (char*)lua_tostring(m_pLuaState, -1); CCLOG(&quot;rlt is %s&quot;,rlt); lua_getglobal(m_pLuaState, &quot;test4&quot;); lua_pushnumber(m_pLuaState, 10); err_relt = lua_pcall(m_pLuaState, 1, 2, -1); // 1： 一个参数， 2：两个参数 ， -1：当出错的时候的返回值 CCAssert(err_relt != -1, &quot;访问函数报错&quot;); int rlt2 = (int)lua_tonumber(m_pLuaState, -1); CCLOG(&quot;rlt is %i&quot;,rlt2); lua_getglobal(m_pLuaState, &quot;test5&quot;); lua_pushnumber(m_pLuaState, 100); err_relt = lua_pcall(m_pLuaState, 1, 2, -1); // 1： 一个参数， 2：两个参数 ， -1：当出错的时候的返回值 CCAssert(err_relt != -1, &quot;访问函数报错&quot;); int rlt3 = (int)lua_tonumber(m_pLuaState, -1); int rlt4 = (int)lua_tonumber(m_pLuaState, -1); CCLOG(&quot;rlt is %i&quot;,rlt3); CCLOG(&quot;rlt is %i&quot;,rlt4); } Lua中增加变量function test1() print(&quot;call lua function&quot;) end function test2(var) print(&quot;call lua function&quot;, var) end function test3() return &quot;I am Lua test3&quot; end function test4(var) var = var + 10 return var end function test5(var) t = 10 var = var + 10 return t, var end 控制答应结果：call lua function call lua function test1 调用 C/C++调用Lua之遍历和获取Table的值增加方法char* getField(lua_State *L, const char* key); char* getField(lua_State *L, const char* key) { char *rlt = NULL; lua_pushstring(L, key); lua_gettable(L, -2); if (lua_isstring(L, -1)) { rlt = (char*)lua_tostring(L, -1); lua_pop(L, 1); return rlt; } return &quot;error&quot;; } 初始化方法(void LuaInterface03::init())中增加如下代码lua_getglobal(m_pLuaState, &quot;application&quot;); if (lua_isnumber(m_pLuaState, -1)) { char *width = getField(m_pLuaState, &quot;width&quot;); char *height = getField(m_pLuaState, &quot;height&quot;); CCLOG(&quot;width:%s&quot;, width); CCLOG(&quot;height:%s&quot;, height); int nWidth = atoi(width); int nHeight = atoi(height); } Lua中增加Tableapplication = { width = 320, height = 640, } Lua 调用 C/C++1.Lua调用C/C++函数创建一个Lua管理类，.h文件#ifndef LuaInterface04_hpp #define LuaInterface04_hpp #include &lt;stdio.h&gt; #include &quot;cocos2d.h&quot; #include &quot;lua.hpp&quot; #include &lt;string&gt; USING_NS_CC; using namespace std; class LuaInterface04 { public: LuaInterface04(); ~LuaInterface04(); static LuaInterface04 *shareInterface(); static int l_getMyName(lua_State * L) private: static LuaInterface04 *i; lua_State *m_pLuaState; void init(); }; #endif /* LuaInterface04_hpp */ .cpp文件#include &quot;LuaInterface04.h&quot; LuaInterface04 *LuaInterface04::i = NULL; LuaInterface04::LuaInterface04(){} LuaInterface04::LuaInterface04(){ if (m_pLuaState) { lua_close(m_pLuaState); m_pLuaState = NULL; } } // 调用C++ static int l_getMyName(lua_State * L) { lua_pushstring(L, &quot;String from C/C++&quot;); return 1; } void LuaInterface04::init() { // 创建一个新的状态 m_pLuaState = luaL_newstate(); // 打开所有系统提供的库 luaL_openlibs(m_pLuaState); // 调用C++ lua_pushcfunction(m_pLuaState, l_getMyName); lua_setglobal(m_pLuaState, &quot;getMyName&quot;); string path = CCFileUtils::sharedFileUtils()-&gt;fullPathForFilename(&quot;Interface04.lua&quot;); luaL_dofile(m_pLuaState, path.c_str()); lua_pcall(m_pLuaState, 0, 0, -1); } LuaInterface04 *LuaInterface04::shareInterface() { if (!i) { i = new LuaInterface04; i -&gt; init(); } return i; } 新建一个.lua的访问类文件，并且输入print(&quot;Begin&quot;) print(getMyName()) print(&quot;End&quot;) 控制答应结果：Begin String from C/C++ End 深入理解编写C函数上增加register_my_function方法.hstatic int l_showName(lua_State *L); static int l_showYoueName(lua_State *L); static void register_my_function(lua_State *L); .cppstatic int l_showName(lua_State *L) { const char * value1 = luaL_checkstring(L, -1); const char * value2 = luaL_checkstring(L, -2); const char * value3 = luaL_checkstring(L, -3); CCLOG(&quot;value1 is :%s&quot;, value1); CCLOG(&quot;value2 is :%s&quot;, value2); CCLOG(&quot;value3 is :%s&quot;, value3); //lua_pushstring(L, value1); return 1; } static int l_showYoueName(lua_State *L) { const char * value = luaL_checkstring(L, -1); lua_pushstring(L, value); return 1; } static void register_my_function(lua_State *L) { lua_pushcfunction(L, LuaInterface04::l_getMyName); lua_setglobal(L, &quot;getMyName&quot;); lua_pushcfunction(L, LuaInterface04::l_getMyName); lua_setglobal(L, &quot;showName&quot;); lua_pushcfunction(L, LuaInterface04::l_getMyName); lua_setglobal(L, &quot;show&quot;); } 在init中输入如下替换原始的调用方法// 调用C++ //lua_pushcfunction(m_pLuaState, l_getMyName); //lua_setglobal(m_pLuaState, &quot;getMyName&quot;); register_my_function(m_pLuaState); 新建一个.lua的访问类文件，并且输入showName(&quot;Hello iCocos&quot;) show(&quot;Hello iCocos&quot;， &quot;Hello Lua&quot;) 深入理解编写C函数下增加register_my_function方法.hstatic int lua_showreturn1(lua_State * L); static int lua_showreturn2(lua_State * L); static int lua_showreturn3(lua_State * L); static int lua_showtable(lua_State * L); static int lua_showtable2(lua_State * L); .cpp//print(lua_showreturn1()) static int lua_showreturn1(lua_State * L) { CCLOG(&quot;I am no return&quot;); return 0; } //print(lua_showreturn2()) static int lua_showreturn2(lua_State * L) { CCLOG(&quot;I am one values&quot;); lua_pushstring(L, &quot;I am one values&quot;); return 1; } //print(lua_showreturn3()) static int lua_showreturn3(lua_State * L) { CCLOG(&quot;I am two values&quot;); lua_pushstring(L, &quot;I am value one&quot;); lua_pushstring(L, &quot;I am value two&quot;); return 1; } //print(lua_showtable()) static int lua_showtable(lua_State * L) { CCLOG(&quot;I am a table&quot;); lua_newtable(L); char str[20] = {0}; for (int i = 1; i &lt;= 10; i++) { lua_pushnumber(L, i); // 压入key sprintf(str, &quot;numert is : %i&quot;, i); lua_pushstring(L, str); // 压入value lua_settable(L, -3); // 将前面的key和value保存到table中 } return 1; } //print(lua_showtable2()) static int lua_showtable2(lua_State * L) { CCLOG(&quot;I am a table2&quot;); lua_newtable(L); char str[20] = {0}; int looper = 1; while (looper &lt;= 10) { sprintf(str, &quot;key%i&quot;, looper); lua_pushstring(L, str); // 压入value looper++; lua_settable(L, -3); // 将前面的key和value保存到table中 } return 1; } 在init中输入如下替换原始的调用方法// 调用C++ //lua_pushcfunction(m_pLuaState, l_getMyName); //lua_setglobal(m_pLuaState, &quot;getMyName&quot;); lua_pushcfunction(L, LuaInterface04::lua_showreturn1); lua_setglobal(L, &quot;showreturn1&quot;); lua_pushcfunction(L, LuaInterface04::lua_showreturn2); lua_setglobal(L, &quot;showreturn2&quot;); lua_pushcfunction(L, LuaInterface04::lua_showreturn3); lua_setglobal(L, &quot;showreturn3&quot;); lua_pushcfunction(L, LuaInterface04::lua_showtable); lua_setglobal(L, &quot;getMyTable&quot;); lua_pushcfunction(L, LuaInterface04::lua_showtable2); lua_setglobal(L, &quot;getMyTable2&quot;); 新建一个.lua的访问类文件，并且输入print(showreturn1()) print(showreturn2()) print(showreturn3()) local t = getMyTable() for k, v in pairs(t) do print(k, v) end local t2 = getMyTable2() for k, v in pairs(t2) do print(k, v) end 2.Lua调用C/C++之标准C模块在lua中init.cstatic int showResult1(lua_State * L) { lua_pushstring(L, &quot;I am showResult1&quot;); return 1; } static int showResult2(lua_State * L) { const char *value = luaL_checkstring(L, -1); //string rel = strcat(&quot;iCocos&quot;, value); lua_pushstring(L, value); return 1; } static const luaL_Reg myLibs[] = { {&quot;result1&quot;, showResult1}, {&quot;result2&quot;, showResult2}, {NULL, NULL}, }; int luaopen_my_lib(lua_State * L) { //luaL_newLib(L, myLibs); luaL_register(L, &quot;my_lib&quot;, myLibs); return 1; } 在static const luaL_Reg loadedlibs[] 里面增加{&quot;my_lib&quot;, luaopen_my_lib}, 在lua中引入并调用方法--- 已入包 local my_lib = require &quot;my_lib&quot; --- 调用方法 print(my_lib.result1()) print(my_lib.result2(&quot;I am showResult2&quot;)) 待续 后续的学习和开发，会相继介绍和分析一下totua，luajit，手动和自动绑定，第三个引入(支付，分析，分析，统计)，插件引入(sqlite，json,zlib) 推荐 https://blog.csdn.net/wu554513392/article/details/60594724 https://blog.csdn.net/wyl1987527/article/details/77340896 https://www.cnblogs.com/zisou/p/cocos2dx-lua2.html]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>游戏</tag>
        <tag>cocos2dx lua 与 C/C++ 交互入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx lua —— Http请求总结与实战(封装)]]></title>
    <url>%2F2018%2F10%2F13%2Fcocos2dx-lua-%E2%80%94%E2%80%94-Http%E8%AF%B7%E6%B1%82%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AE%9E%E6%88%98-%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[今天的主题是关于cocos2dx lua实现短链接网络请求，使用Http实现基本的服务器网络数据获取，关于长链接（socket后续文件或者遇到需要的时候回特别实现与处理） 关于Http这里就不多做介绍了，不过，作为一个程序员，网络请求是开发中最多也是最重要的一环节，这里比较建议，搞懂http的整个请求流程！ 推荐：一次完整的HTTP请求过程 在有了基本的Lua知识和cocos2dx lua基本的了解和学习之后，我有了一个初步的cocos2dx lua开发常识，然后就开始在上面实现基本的界面，并根据界面操作请求和响应数据！ 入口场景在main中初始化场景中必要的UI. 创建一个背景图片和一个按钮，实现点击按钮跳转到另外一个场景，进行网络请求和数据获取 --- @class MainScene local MainScene = class(&quot;MainScene&quot;,cc.load(&quot;mvc&quot;).ViewBase) ---onEnter function MainScene:onEnter() print(&quot;onEnter&quot;) end ---createStaticButton 通用创建按钮方法 ---@param node table ---@param imageName table ---@param x table ---@param y table ---@param callBack table local function createStaticButton(node, imageName, x, y, callBack) local btn = ccui.Button:create(imageName, imageName) btn:move(x, y) btn:addClickEventListener(callBack) btn:addTo(node) end -- -----onCreate function MainScene:onCreate() -- 初始化背景 display.newSprite(&quot;HelloWorld.png&quot;) :move(display.center) :addTo(self) -- 初始化按钮 createStaticButton(self, &quot;button_start.png&quot;, display.cx, display.cy-150, function () self:getApp():enterScene(&quot;ApiRequest&quot;) end) end return MainScene 网络应用场景(ApiRequest)然后开始处理跳转之后的ApiRequest，和相关请求逻辑，这里主要是使用我们封装好的CocosRequest实现基本上的请求逻辑，然后拿到数据之后我们就可以根据实际UI和具体业务逻辑做处理 注意 测试的时候，将local url = “https://xxxx?cmd=501001&amp;uid=628941&amp;novelid=3782&quot;中的值换成自己的地址就可以 require &quot;json&quot; local CocosRequest = require &quot;app.CocosRequest&quot; --- @class ApiRequest local ApiRequest = class(&quot;ApiRequest&quot;, cc.load(&quot;mvc&quot;).ViewBase) ----local MainScene = class(&quot;MainScene&quot;, function() return display.newScene(&quot;MainScene&quot;) end) ---onEnter function ApiRequest:onEnter() print(&quot;onEnter&quot;) end -----onCreate function ApiRequest:onCreate() ----------------------- 创建自定义事件 start local function eventCustomListener1(event) local str = &quot;response: &quot;..event._usedata --labelStatusCode:setString(str) -- 如果返回的是 json 数据，这里解析 local data = json.decode(event._usedata) table.foreach(data, function(key, var) print(&quot;-----&quot;..key) table.foreach(var, function(a, b) print(a..&quot;-&quot;..b) end) end) end local listener1 = cc.EventListenerCustom:create(&quot;customEvent1&quot;,eventCustomListener1) cc.Director:getInstance():setNotificationNode(cc.Node:create()) local eventDispatcher = cc.Director:getInstance():getNotificationNode():getEventDispatcher() eventDispatcher:addEventListenerWithFixedPriority(listener1, 6) -- 将事件分配器赋值到CocosRequest.eventDispatcher -- 用来在http请求返回的回调函数中使用，因为回调函数是在异步线程中执行，必须用自定义事件更新ui线程数据 local tmpHttp = CocosRequest:getInstance() tmpHttp.eventDispatcher = eventDispatcher ----------------------- 创建自定义事件 end local tmp = CocosRequest:getInstance() local function callback(xhr) local event = cc.EventCustom:new(&quot;customEvent1&quot;) event._usedata = xhr.response eventDispatcher:dispatchEvent(event) print(&quot;post callback code = &quot;..xhr.statusText) end local type = tmp.POST local url = &quot;https://xxxx?cmd=501001&amp;uid=628941&amp;novelid=3782&quot; local dataPost = {} dataPost.data = &quot;hello&quot; dataPost.aaa = &quot;world&quot; dataPost.bbb = &quot;yang&quot; tmp:send(type, url, dataPost, callback) end return ApiRequest 网络请求封装(CocosRequest)最后才是我们的重头戏，CocosRequest是直接使用cocos2dx lua提供的XMLHttpRequest实现，其实就是做了一套逻辑，具体细节可以根据项目调整(此处已经测试通过，可直接拷贝使用) require &quot;json&quot; CocosRequest = {} CocosRequest.__index = CocosRequest CocosRequest.instance = nil CocosRequest.callback = nil CocosRequest.POST = &quot;POST&quot; CocosRequest.GET = &quot;GET&quot; function CocosRequest:new() local self = {} setmetatable(self,CocosRequest) return self end function CocosRequest:getInstance() if nil == self.instance then self.instance = self:new() end return self.instance end -- 数据转换，将请求数据由 table 型转换成 string，参数：table function CocosRequest:dataParse(data) if &quot;table&quot; ~= type(data) then print(&quot;data is not a table&quot;) return nil end local tmp = {} for key, value in pairs(data) do table.insert(tmp,key..&quot;=&quot;..value) end local newData = &quot;&quot; for i=1,#tmp do newData = newData..tostring(tmp[i]) if i&lt;#tmp then newData = newData..&quot;&amp;&amp;&quot; end end print(&quot;------- name is &quot;..newData) return newData end -- 发送数据，参数：string，string，table function CocosRequest:send(type, url, data, callback) local xhr = cc.XMLHttpRequest:new() --new 一个http request 实例 self.callback = callback --设置需要执行的函数 local newData = self:dataParse(data) if nil == newData or &quot;&quot; == newData then return end -- response回调函数 local function responseCallback() print(&quot;CocosRequest - &quot;..xhr.response) if nil ~= self.callback then self.callback(xhr) else print(&quot;callback is nil&quot;) end end -- 设置返回值类型及回调函数 xhr.responseType = cc.XMLHTTPREQUEST_RESPONSE_STRING xhr:registerScriptHandler(responseCallback) -- 请求方式判断 if self.POST == type then xhr:open(self.POST, url) xhr:registerScriptHandler(responseCallback) xhr:send(newData) elseif self.GET == type then xhr:open(self.GET, url..&quot;?&quot;..newData) xhr:send() else print(&quot;ERROR : type only can be \&quot;Post\&quot; or \&quot;GET\&quot;&quot;) end end --------------------- return CocosRequest 由于在Web中使用XMLHTTPRequest对象发出HTTP请求很普遍,Cocos2dx Lua对其进行了移植,可以在 Cocos2 d-x LumP中使用 XMLHTTPRequest对象 XMLHTTPRequest对象中几个常用的函数和属性如下 (1)open(),与服务器连接,创建新的请求 (2)send(),向服务器发送请求 (3)abort(),退出当前请求 (4)readyState属性,提供当前请求的就绪状态,其中4表示准备就绪 (5)tatus属性,提供当前HTTP请求状态码,其中200表示成功请求 (6)respomseText属性,服务器返回的请求响应 (7) onreadystatechange属性。设置回调函数,当服务器处理完请求后就会自动调用该函数。 其中open和send函数,以及onreadystatechange属性是HTTP请求的关键。open函数有以下5个参数可以使用 (1) request-type:发送请求的类型。典型的值是GET或POST,也可以发送HEAD请求 (2) url:要请求连接的URL (3) asynch:如果希望使用异步连接则为true,否则为 false。该参数是可选的,默认为 (4) username:如果需要身份验证,则可以在此指定用户名。该可选参数没有默认值 (5) password:如果需要身份验证,则可以在此指定口令。该可选参数没有默认值。 服务器响应下面是我们验证返回后的服务器数据(未做处理) [ { &quot;code&quot;:1, &quot;msg&quot;:&quot;操作成功&quot;, &quot;data&quot;:[ { &quot;novelid&quot;:&quot;3782&quot;, &quot;uid&quot;:&quot;628875&quot;, &quot;cid&quot;:&quot;5&quot;, &quot;title&quot;:&quot;零下记忆&quot;, &quot;cover&quot;:&quot;http://xxxx/img/cb/2f/f1/cb2ff155bbda8387f4b8efe917c46cd3.jpg&quot;, &quot;scover&quot;:&quot;http://xxxx/img/cb/2f/f1/cb2ff155bbda8387f4b8efe917c46cd3.jpg&quot;, &quot;shareimg&quot;:&quot;http://xxxx/img/ed/68/e6/ed68e67f77841ac76be189f0a04aa030.jpg&quot;, &quot;intro&quot;:&quot;&quot;, &quot;tags&quot;:&quot;悬疑&quot;, &quot;reason&quot;:&quot;&quot;, &quot;issingle&quot;:&quot;1&quot;, &quot;sort&quot;:&quot;0&quot;, &quot;hits&quot;:&quot;0&quot;, &quot;reads&quot;:&quot;18753&quot;, &quot;clues&quot;:20, &quot;likes&quot;:&quot;1&quot;, &quot;unlikes&quot;:&quot;0&quot;, &quot;cmts&quot;:&quot;0&quot;, &quot;favs&quot;:&quot;2&quot;, &quot;words&quot;:&quot;18420&quot;, &quot;chapters&quot;:&quot;35&quot;, &quot;pub_chapters&quot;:&quot;35&quot;, &quot;chapter_index&quot;:&quot;1&quot;, &quot;pubtime&quot;:&quot;0&quot;, &quot;updatetime&quot;:&quot;1539337440&quot;, &quot;addtime&quot;:&quot;1534222233&quot;, &quot;resversion&quot;:&quot;30&quot;, &quot;isuser&quot;:&quot;0&quot;, &quot;status&quot;:&quot;1&quot;, &quot;wstatus&quot;:&quot;1&quot;, &quot;offsale&quot;:&quot;0&quot;, &quot;chapterstatus&quot;:&quot;-1&quot;, &quot;leadrole&quot;:{ &quot;roleid&quot;:&quot;8478&quot;, &quot;rolename&quot;:&quot;炽念&quot; }, &quot;cname&quot;:&quot;推理&quot;, &quot;isnew&quot;:0, &quot;fatime&quot;:&quot;8月14日&quot;, &quot;isreading&quot;:1, &quot;iscomplete&quot;:1, &quot;isfav&quot;:0, &quot;liketype&quot;:0, &quot;shareinfo&quot;:{ &quot;type&quot;:1, &quot;title&quot;:&quot;零下记忆&quot;, &quot;intro&quot;:&quot;&quot;, &quot;img&quot;:&quot;http://xxxx/img/ed/68/e6/ed68e67f77841ac76be189f0a04aa030.jpg&quot;, &quot;url&quot;:&quot;http://xxxx/novel/startReading?novelid=3782&amp;chl=jmt&quot; }, &quot;userinfo&quot;:{ &quot;uid&quot;:&quot;628875&quot;, &quot;username&quot;:&quot;writer10&quot;, &quot;nickname&quot;:&quot;离经易道&quot;, &quot;headurl&quot;:&quot;http://xxxx/headimg/bb/d3/b6/628875_1_bbd3b631717ad615f38a6670573a375c_300x300.jpg?v=1526708983&quot;, &quot;sex&quot;:&quot;1&quot;, &quot;vtype&quot;:&quot;0&quot;, &quot;regtype&quot;:&quot;2&quot;, &quot;vname&quot;:&quot;&quot;, &quot;vicon&quot;:&quot;&quot;, &quot;isfollow&quot;:0 } } ], &quot;cmd&quot;:501001, &quot;time&quot;:1539677040 } ]]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>游戏</tag>
        <tag>cocos2dx lua —— Http请求总结与实战(封装)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS游戏——渠道越狱打包流程]]></title>
    <url>%2F2018%2F10%2F09%2FiOS%E6%B8%B8%E6%88%8F%E2%80%94%E2%80%94%E6%B8%A0%E9%81%93%E8%B6%8A%E7%8B%B1%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[关于iOS普通ipa打包这里就不说了，只要注意苹果的一些协议条款，基本上步骤都是傻瓜式的，如果不知道如何打包iOS普通ipa包，请出门左转，度娘在哪里等你！ 那么，如何将app打包成越狱包，越狱iphone在cydia源上下载安装，这样的需求在互联网游戏行业是非常普遍的，尤其是各种马甲包横行的时代！ 关于越狱相关内容，请看这里 iOS越狱解除工具 ios越狱原理详解 常见deb包打包方式1、第一种方式：自定义目录下 如desktop创建文件夹，起名test，test内新建文件夹Payload把xcode Build好的.app（Products目录中）拷到Payload目录中打开终端，cd指令 到test文件目录下，执行 zip -r “xxx.ipa” * 注意里面的空格：(zip -r “xxx.ipa”[空格]* ) ipa包就打好了，可以安装到越狱手机上试试看 注意事项：Debug或Release的Any iOS SDK都设置为正式发布证书，经测试该越狱包可正常接收推送。 2、第二种方式：在xcode中点击Product-&gt;Archive,完成后会弹出Organizer，点右边的Distribute，弹出一个向导对话框，点击“Export as Xcode Archive”，选择位置，会在那个位置生成后缀名是.xcarchive的文件右键“显示包内容”-&gt;”Products”-&gt;”applications” 然后找到那个应用程序， 将其拖到iTunes里面，在itunes的【应用程序】里找到这个文件，然后右键“在Finder 中显示”，便可找到ipa文件了…. ipa包就打好了，可以安装到越狱手机上试试看 最近发现了一种更好的方式致谢： 胖梁的技术笔记 1.修改编译选项重新打包在工程的Build Settings -&gt; Code Signing -&gt; Code Signing Identity选项, 将 Debug 和 Release 下的 Any iOS SDK都设置为 Don’t Code Sign然后在重新Archive 2.准备目录创建一个目录用来打包,如tmp,tmp下建DEBIAN和Applications两个目录, DEBIAN下建一个文本文件control tmp目录结构如下: -DEBIAN ---control -Applications control文件就是打包时的配置文件,它也会作为deb包的配置被打包到包中, 文件例子: Package: com.sharedream.game Name: 游戏测试 Version: 0.1-1 Description: 游戏测试游戏,开发中... Section: 游戏 Depends: firmware (&gt;= 4.3) Priority: optional Architecture: iphoneos-arm Author: liangwei &lt;http://weibo.com/iamliangwei&gt; Homepage: http://weibo.com/iamliangwei Icon: file:///Applications/game.app/Icon.png Maintainer: liangwei &lt;http://weibo.com/iamliangwei&gt; 然后将xcode打包出来的.app文件整个拷贝到Applications目录下, 结构如下: -DEBIAN ---control -Applications ---game.app 3.打包退出至tmp的上层目录 dpkg-deb -b tmp game.deb 看到如下几行就是打包完成了 warning, `com.sull.sample/DEBIAN/control&apos; contains user-defined field `Name&apos; warning, `com.sull.sample/DEBIAN/control&apos; contains user-defined field `Author&apos; warning, `com.sull.sample/DEBIAN/control&apos; contains user-defined field `Sponsor&apos; dpkg-deb: ignoring 3 warnings about the control file(s) 拷贝到cydia源中, 重新扫描包生成Packages列表文件, 并压缩成Packages.bz2就可以啦 dpkg-scanpackages -m debs &gt;Packages bzip2 -zkf Packages contains ununderstood data member data.tar.xz” 的安装错误 是因为自从1.17.0版本的dpkg-deb开始, 默认使用xz格式来压缩data.tar文件但是,cydia在ios提供的dpkg是1.14版本, 还没有支持xz这种压缩格式所以我们需要设置”-Zgzip”参数给dpkg-deb 进行打包, 类似命令: dpkg-deb -Zgzip -b tmp game.deb 关于iOS普通包打包可以参考这里： https://blog.csdn.net/zhanghow/article/details/60603461?utm_source=blogxgwz8]]></content>
      <categories>
        <category>Games</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>iOS游戏——渠道越狱打包流程</tag>
        <tag>越狱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx lua注册事件详解]]></title>
    <url>%2F2018%2F10%2F05%2Fcocos2dx-lua%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[最近在学习cocos2dx lua的时候，遇到了一些关于事件注册的逻辑！ 结合用户实际操作和游戏的真实需求，关于事件在游戏中还是使用非常多的，所以特此记录一下 事件(网络) 事件是可以被控件识别的操作。如按下确定按钮，选择某个单选按钮或者复选框。每一种控件有自己可以识别的事件，如窗体的加载、单击、双击等事件，编辑框（文本框）的文本改变事件，等等。 事件是用户对窗口上各种组件的操作。 事件有系统事件和用户事件。 1.系统事件由系统激发，如时间间隔24小时，银行储蓄的存款日期增加一天。 2.用户事件由用户激发，如用户点击按钮，在文本框中显示特定的文本。事件驱动控件执行某项功能。 触发事件的对象称为事件发送者；接收事件的对象称为事件接受者； 注: 这里只针对用户事件！ cocos2dx中事件的类型 registerScriptTouchHandler 注册触屏事件 registerScriptTapHandler 注册点击事件 registerScriptHandler 注册基本事件 包括 触屏 层的进入 退出 事件 registerScriptKeypadHandler 注册键盘事件 registerScriptAccelerateHandler 注册加速事件 在3.x之前事件的注册可以直接使用这些方式来注册， 事件监听器主要有： 触摸事件 : EventListenerTouchOneByOne、EventListenerTouchAllAtOnce 鼠标响应事件 : EventListenerMouse 键盘响应事件 : EventListenerKeyboard 加速计事件 : EventListenerAcceleration 自定义事件 : EventListenerCustom 物理碰撞事件 : EventListenerPhysicsContact 游戏手柄事件 : EventListenerController 而在3.x中由于加入了C++11的特性，而对事件的分发机制通过事件分发器EventDispatcher 来进行统一的管理。 官方说明：触摸事件，键盘事件，加速器事件和自定义事件等所有事件都由 EventDispatcher 分发。 TouchDispatcher, KeypadDispatcher, KeyboardDispatcher, AccelerometerDispatcher 已经被移除。 【事件分发器】事件分发器EventDispatcher，用于统一管理事件监听器的所有事件的分发。 EventDispatcher 的特性主要有: 事件的分发基于渲染顺序 所有的事件都由 EventDispatcher 分发 可以使用 EventDispatcher 来分发自定义事件 可以注册一个 lambda 表达式作为回调函数 1、_eventDispatcher_eventDispatcher是Node的属性，通过Director::getInstance()-&gt;getEventDispatcher() 获得。 _eventDispatcher的工作由三部分组成： （1）事件分发器 ：EventDispatcher。 （2）事件类型 ：EventTouch, EventKeyboard 等。 （3）事件监听器 ：EventListenerTouch, EventListenerKeyboard 等。 监听器实现了各种触发后的逻辑，在适当时候由事件分发器分发事件类型，然后调用相应类型的监听器。 2、添加/删除监听器 添加监听器： addEventListenerWithSceneGraphPriority ， addEventListenerWithFixedPriority 。 删除监听器： removeEventListener ， removeAllEventListeners 。 3、主要函数包含监听器的添加、删除、暂停、恢复，优先级的设置，手动分发事件等。 class EventDispatcher : public Ref { /** * 添加监听器 * - addEventListenerWithSceneGraphPriority * - addEventListenerWithFixedPriority * - addCustomEventListener */ //使用 场景图的优先级 为指定事件添加一个监听. //listener : 指定要监听的事件. //node : 这个节点的绘制顺序是基于监听优先级. //优先级 : 0 void addEventListenerWithSceneGraphPriority(EventListener* listener, Node* node); //使用 一定的优先级 为指定事件添加一个监听. //listener : 指定要监听的事件. //fixedPriority : 这个监听器的固定优先级. //优先级 : fixedPriority。(但是不能为0，因为他是场景图的基本优先级) void addEventListenerWithFixedPriority(EventListener* listener, int fixedPriority); //用户自定义监听器 EventListenerCustom* addCustomEventListener(const std::string &amp;eventName, const std::function&lt;void(EventCustom*)&gt;&amp; callback); /** * 删除监听器 * - removeEventListener * - removeEventListenersForType * - removeEventListenersForTarget * - removeCustomEventListeners * - removeAllEventListeners */ //删除指定监听器 void removeEventListener(EventListener* listener); //删除某类型对应的所有监听器 //EventListener::Type:: // 单点触摸 : TOUCH_ONE_BY_ONE // 多点触摸 : TOUCH_ALL_AT_ONCE // 键盘 : KEYBOARD // 鼠标 : MOUSE // 加速计 : ACCELERATION // 自定义 : CUSTOM void removeEventListenersForType(EventListener::Type listenerType); //删除绑定在节点target上的所有监听器 void removeEventListenersForTarget(Node* target, bool recursive = false); //删除名字为customEventName的所有自定义监听器 void removeCustomEventListeners(const std::string&amp; customEventName); //移除所有监听器 void removeAllEventListeners(); /** * 暂停、恢复在节点target上的所有监听器 * - pauseEventListenersForTarget * - resumeEventListenersForTarget */ void pauseEventListenersForTarget(Node* target, bool recursive = false); void resumeEventListenersForTarget(Node* target, bool recursive = false); /** * 其他 * - setPriority * - setEnabled * - dispatchEvent * - dispatchCustomEvent */ //设置某监听器的优先级 void setPriority(EventListener* listener, int fixedPriority); //启用事件分发器 void setEnabled(bool isEnabled); bool isEnabled() const; //手动派发自定义事件 void dispatchEvent(Event* event); //给名字为eventName的自定义监听器, 绑定用户数据 void dispatchCustomEvent(const std::string &amp;eventName, void *optionalUserData = nullptr); } 4、关于事件监听器的优先权通过 addEventListenerWithSceneGraphPriority 添加的监听器，优先权为0。通过 addEventListenerWithFixedPriority 添加的监听器，可以自定义优先权，但不能为0。 优先级越低，越先响应事件。 如果优先级相同，则上层的（z轴）先接收触摸事件。 5、使用步骤 （1）获取事件分发器： dispatcher = Director::getInstance()-&gt;getEventDispatcher(); （2）创建监听器： auto listener = EventListenerTouchOneByOne::create(); （3）绑定响应事件函数： listener-&gt;onTouchBegan = CC_CALLBACK_2(callback, this); （4）将监听器添加到事件分发器dispatcher中： dispatcher-&gt;addEventListenerWithSceneGraphPriority(Listener, this); （5）编写回调响应函数： bool callback(Touch touch, Event event) { … } 实战案例先来看看项目用用到的一些简单时间的操作， 两种方式创建使用 触摸事件根据用户手机在屏幕触摸的位置，对场景或者场景中的精灵，控件的做一些处理，这种类型偏向于触摸屏的设备。 local function onTouchBegan(touch, event) local location = touch:getLocation() local visiableSize = cc.Director:getInstance():getVisibleSize() local origin = cc.Director:getInstance():getVisibleOrigin() local finalX = location.x - (origin.x + visiableSize.width/2) local finalY = location.y - (origin.y + visiableSize.height/2) finalX, finalY 根据实际屏幕计算触摸点 end local listener = cc.EventListenerTouchOneByOne:create() listener:registerScriptHandler(onTouchBegan, cc.Handler.EVENT_TOUCH_BEGAN) local eventDiapatcher = self:getEventDispatcher() eventDiapatcher:addEventListenerWithSceneGraphPriority(listener, self) 键盘事件这里是coco2dx 定义的一套键盘字节码，每一个键盘上的键都对应一个数字，我们可以根据用户按键对精灵和界面做控制，这种偏向于桌面版的游戏！ 方法一-- 键盘监听器 local listener = cc.EventListenerKeyboard:create() listener:registerScriptHandler(function(keyCode, event) if self.tank ~= nil then -- w if keyCode == 146 then self.tank:MoveBegin(&quot;up&quot;) -- s elseif keyCode == 142 then self.tank:MoveBegin(&quot;down&quot;) -- a elseif keyCode == 124 then self.tank:MoveBegin(&quot;left&quot;) -- d elseif keyCode == 127 then self.tank:MoveBegin(&quot;right&quot;) end end end, cc.Handler.EVENT_KEYBOARD_PRESSED) --- cc.Handler.EVENT_KEYBOARD_RELEASED) local eventDiapatcher = self:getEventDispatcher() eventDiapatcher:addEventListenerWithSceneGraphPriority(listener, self) 方法二local function keyboardPressed(keyCode, event) -- up if keyCode == 28 then self:MoveCursor(0, 1) -- down elseif keyCode == 29 then self:MoveCursor(0, -1) -- left elseif keyCode == 26 then self:MoveCursor(-1, 0) -- right elseif keyCode == 27 then self:MoveCursor(1, 0) -- page up elseif keyCode == 38 then self:SwitchCursor(-1) -- page down elseif keyCode == 44 then self:SwitchCursor(1) -- enter elseif keyCode == 38 then self:Place() -- delete elseif keyCode == 44 then self:Delete() -- F3 elseif keyCode == 49 then self:Load() -- F4 elseif keyCode == 50 then self:Save() end print(&quot;key board ???????? keyCode&quot;, keyCode) end -- 键盘监听器 local listener = cc.EventListenerKeyboard:create() listener:registerScriptHandler(keyboardPressed, cc.Handler.EVENT_KEYBOARD_PRESSED) local eventDiapatcher = self:getEventDispatcher() eventDiapatcher:addEventListenerWithSceneGraphPriority(listener, self) 这里主要说一下codeKey，codeKey是cocos2dx定义的一套键盘的代码，每个平台几乎是通用的 【触摸事件】1、单点触摸：EventListenerTouchOneByOne单点触摸监听器相关： static EventListenerTouchOneByOne* create(); std::function&lt;bool(Touch*, Event*)&gt; onTouchBegan; //只有这个返回值为 bool std::function&lt;void(Touch*, Event*)&gt; onTouchMoved; std::function&lt;void(Touch*, Event*)&gt; onTouchEnded; std::function&lt;void(Touch*, Event*)&gt; onTouchCancelled; 使用举例： //获取事件分发器 auto dispatcher = Director::getInstance()-&gt;getEventDispatcher(); //创建单点触摸监听器 EventListenerTouchOneByOne auto touchListener = EventListenerTouchOneByOne::create(); //单点触摸响应事件绑定 touchListener-&gt;onTouchBegan = CC_CALLBACK_2(HelloWorld::onTouchBegan, this); touchListener-&gt;onTouchMoved = CC_CALLBACK_2(HelloWorld::onTouchMoved, this); touchListener-&gt;onTouchEnded = CC_CALLBACK_2(HelloWorld::onTouchEnded, this); touchListener-&gt;onTouchCancelled = CC_CALLBACK_2(HelloWorld::onTouchCancelled, this); //在事件分发器中，添加触摸监听器，事件响应委托给 this 处理 dispatcher-&gt;addEventListenerWithSceneGraphPriority(touchListener, this); //单点触摸事件响应函数 bool onTouchBegan(Touch *touch, Event *unused_event) { CCLOG(&quot;began&quot;); return true; } void onTouchMoved(Touch *touch, Event *unused_event) { CCLOG(&quot;moved&quot;); } void onTouchEnded(Touch *touch, Event *unused_event) { CCLOG(&quot;ended&quot;); } void onTouchCancelled(Touch *touch, Event *unused_event) { CCLOG(&quot;cancelled&quot;); } 2、多点触摸：EventListenerTouchAllAtOnce多点触摸监听器相关： static EventListenerTouchAllAtOnce* create(); std::function&lt;void(const std::vector&lt;Touch*&gt;&amp;, Event*)&gt; onTouchesBegan; std::function&lt;void(const std::vector&lt;Touch*&gt;&amp;, Event*)&gt; onTouchesMoved; std::function&lt;void(const std::vector&lt;Touch*&gt;&amp;, Event*)&gt; onTouchesEnded; std::function&lt;void(const std::vector&lt;Touch*&gt;&amp;, Event*)&gt; onTouchesCancelled; 使用举例： //获取事件分发器 auto dispatcher = Director::getInstance()-&gt;getEventDispatcher(); //创建多点触摸监听器 EventListenerTouchAllAtOnce auto touchesListener = EventListenerTouchAllAtOnce::create(); //多点触摸响应事件绑定 touchesListener-&gt;onTouchesBegan = CC_CALLBACK_2(HelloWorld::onTouchesBegan, this); touchesListener-&gt;onTouchesMoved = CC_CALLBACK_2(HelloWorld::onTouchesMoved, this); touchesListener-&gt;onTouchesEnded = CC_CALLBACK_2(HelloWorld::onTouchesEnded, this); touchesListener-&gt;onTouchesCancelled = CC_CALLBACK_2(HelloWorld::onTouchesCancelled, this); //在事件分发器中，添加触摸监听器，事件响应委托给 this 处理 dispatcher-&gt;addEventListenerWithSceneGraphPriority(touchesListener, this); //多点触摸事件响应函数 void onTouchesBegan(const std::vector&lt;Touch*&gt;&amp; touches, Event *unused_event) { CCLOG(&quot;began&quot;); } void onTouchesMoved(const std::vector&lt;Touch*&gt;&amp; touches, Event *unused_event) { CCLOG(&quot;moved&quot;); } void onTouchesEnded(const std::vector&lt;Touch*&gt;&amp; touches, Event *unused_event) { CCLOG(&quot;ended&quot;); } void onTouchesCancelled(const std::vector&lt;Touch*&gt;&amp;touches, Event *unused_event) { CCLOG(&quot;cancelled&quot;); } 【鼠标事件】EventListenerMouse，主要用于监听鼠标的点击、松开、移动、滚轮的事件。 鼠标事件监听器相关： static EventListenerMouse* create(); std::function&lt;void(Event* event)&gt; onMouseDown; //按下鼠标, 单击鼠标 std::function&lt;void(Event* event)&gt; onMouseUp; //松开鼠标, 按下的状态下松开 std::function&lt;void(Event* event)&gt; onMouseMove; //移动鼠标, 在屏幕中移动 std::function&lt;void(Event* event)&gt; onMouseScroll;//滚动鼠标, 滚动鼠标的滚轮 使用举例： //获取事件分发器 auto dispatcher = Director::getInstance()-&gt;getEventDispatcher(); //创建鼠标事件监听器 EventListenerMouse EventListenerMouse* mouseListenter = EventListenerMouse::create(); //鼠标事件响应函数 mouseListenter-&gt;onMouseDown = CC_CALLBACK_1(HelloWorld::onMouseDown, this); mouseListenter-&gt;onMouseUp = CC_CALLBACK_1(HelloWorld::onMouseUp, this); mouseListenter-&gt;onMouseMove = CC_CALLBACK_1(HelloWorld::onMouseMove, this); mouseListenter-&gt;onMouseScroll = CC_CALLBACK_1(HelloWorld::onMouseScroll, this); //添加鼠标事件监听器，事件响应处理委托给this dispatcher-&gt;addEventListenerWithSceneGraphPriority(mouseListenter, this); //事件响应函数 void onMouseDown(Event* event) { CCLOG(&quot;Down&quot;); } void onMouseUp(Event* event) { CCLOG(&quot;UP&quot;); } void onMouseMove(Event* event) { CCLOG(&quot;MOVE&quot;); } void onMouseScroll(Event* event) { CCLOG(&quot;Scroll&quot;); } 【键盘事件】EventListenerKeyboard，主要用于监听键盘某个键的按下、松开的事件。 键盘事件监听器相关： static EventListenerKeyboard* create(); std::function&lt;void(EventKeyboard::KeyCode, Event*)&gt; onKeyPressed; //按下某键 std::function&lt;void(EventKeyboard::KeyCode, Event*)&gt; onKeyReleased; //松开某键 //键盘按键枚举类型 EventKeyboard::KeyCode //KeyCode的值对应的不是键盘的键值、也不是ASCII码，只是纯粹的枚举类型 //如: // EventKeyboard::KeyCode::KEY_A // EventKeyboard::KeyCode::KEY_1 // EventKeyboard::KeyCode::KEY_F1 // EventKeyboard::KeyCode::KEY_SPACE // EventKeyboard::KeyCode::KEY_ALT // EventKeyboard::KeyCode::KEY_SHIFT 使用举例： // //获取事件分发器 auto dispatcher = Director::getInstance()-&gt;getEventDispatcher(); //创建键盘按键事件监听器 EventListenerKeyboard* keyboardListener = EventListenerKeyboard::create(); //绑定事件响应函数 keyboardListener-&gt;onKeyPressed = CC_CALLBACK_2(HelloWorld::onKeyPressed, this); keyboardListener-&gt;onKeyReleased = CC_CALLBACK_2(HelloWorld::onKeyReleased, this); //添加监听器 dispatcher-&gt;addEventListenerWithSceneGraphPriority(keyboardListener, this); //事件响应函数 void onKeyPressed(EventKeyboard::KeyCode keyCode, Event* event) { if (EventKeyboard::KeyCode::KEY_J == keyCode) { CCLOG(&quot;Pressed: J&quot;); } } void onKeyReleased(EventKeyboard::KeyCode keyCode, Event* event) { if (EventKeyboard::KeyCode::KEY_SPACE == keyCode) { CCLOG(&quot;Released: SPACE&quot;); } } 【加速计事件】EventListenerAcceleration，主要用于监听移动设备的所受重力方向感应事件。 重力感应来自移动设备的加速计，通常支持 (X, Y, Z) 三个方向的加速度感应，所以又称为三向加速计。在实际应用中，可以根据3个方向的力度大小来计算手机倾斜的角度或方向。 1、加速计信息类Acceleration该类中每个方向的加速度，大小都为一个重力加速度大小。 //加速计信息 class Acceleration { double x; double y; double z; }; 2、开启加速计感应在使用加速计事件监听器之前，需要先启用此硬件设备： Device::setAccelerometerEnabled(true); 3、加速计监听器相关static EventListenerAcceleration* create(const std::function&lt;void(Acceleration*, Event*)&gt;&amp; callback); std::function&lt;void(Acceleration*, Event*)&gt; onAccelerationEvent; 4、使用举例//标签: 显示加速计信息 label = Label::createWithTTF(&quot;no used&quot;, &quot;Marker Felt.ttf&quot;, 12); label-&gt;setPosition(visibleSize / 2); this-&gt;addChild(label); //小球: 可视化加速计 ball = Sprite::create(&quot;ball.png&quot;); ball-&gt;setPosition(visibleSize / 2); this-&gt;addChild(ball); //获取事件分发器 auto dispatcher = Director::getInstance()-&gt;getEventDispatcher(); //需要开启移动设备的加速计 Device::setAccelerometerEnabled(true); //创建加速计事件监听器 auto accelerationListener = EventListenerAcceleration::create(CC_CALLBACK_2(HelloWorld::onAccelerationEvent, this)); //添加加速计监听器 dispatcher-&gt;addEventListenerWithSceneGraphPriority(accelerationListener, this); //事件响应函数 void HelloWorld::onAccelerationEvent(Acceleration* acceleration, Event* event) { char s[100]; sprintf(s, &quot;X: %f; Y: %f; Z:%f; &quot;, acceleration-&gt;x, acceleration-&gt;y, acceleration-&gt;z); label-&gt;setString(s); //改变小球ball的位置 float x = ball-&gt;getPositionX() + acceleration-&gt;x * 10; float y = ball-&gt;getPositionY() + acceleration-&gt;y * 10; Vec2 pos = Vec2(x, y); pos.clamp(ball-&gt;getContentSize() / 2, Vec2(288, 512) - ball-&gt;getContentSize() / 2); ball-&gt;setPosition(pos); //设置位置 } 【自定义事件】以上是系统自带的事件类型，事件由系统内部自动触发，如 触摸屏幕，键盘响应等。 EventListenerCustom 自定义事件，它不是由系统自动触发，而是人为的干涉。 它的出现，使得2.x中的 观察者模式 NotificationCenter（订阅发布消息） 被无情的遗弃了。 在 3.x 中，使用EventListenerCustom来实现消息的订阅与发布。 学习它之前，最好了解一下 NotificationCenter 这个类的用法。 NotificationCenter 的用法参见：http://shahdza.blog.51cto.com/2410787/1611575 1、创建自定义监听器该监听器，就相当于是订阅消息。即与NotificationCenter的 addObserver 类似。 //eventName : 监听器名字，即消息的名称 //callback : 监听器函数，即消息的回调函数 static EventListenerCustom* create(const std::string&amp; eventName, const std::function&lt;void(EventCustom*)&gt;&amp; callback); 2、分发自定义事件自定义的事件监听器，需要通过手动的方式，将事件分发出去。 通过 EventCustom(string eventName); 来设置需要发布消息的数据信息，eventName为消息名称。 其中EventCustom可以通过setUserData来绑定想要传递的消息数据。 通过 dispatcher-&gt;dispatchEvent(&amp;event); 来手动将事件分发出去。即发布消息。 这与NotificationCenter的 postNotification 类似。 EventCustom event(&quot;custom_event&quot;); event-&gt;setUserData((void*)123); // 绑定消息传递的数据，可以为任意类型void。 dispatcher-&gt;dispatchEvent(&amp;event); // 发布名称为&quot;custom_event&quot;的消息。 3、使用举例//获取事件分发器 auto dispatcher = Director::getInstance()-&gt;getEventDispatcher(); //创建自定义事件监听器 //监听器名字 : &quot;custom_event&quot; //事件响应函数: HelloWorld::onCustomEvent auto customListener = EventListenerCustom::create(&quot;custom_event&quot;, CC_CALLBACK_1(HelloWorld::onCustomEvent, this)); //添加自定义事件监听器，优先权为1 dispatcher-&gt;addEventListenerWithFixedPriority(customListener, 1); //手动分发监听器的事件，通过dispatchEvent发布名称为custom_event的消息。 EventCustom event = EventCustom(&quot;custom_event&quot;); event-&gt;setUserData((void*)123); // 绑定消息传递的数据，可以为任意类型void。 dispatcher-&gt;dispatchEvent(&amp;event); //消息事件回调函数 void HelloWorld::onCustomEvent(EventCustom* event) { // 获取消息传递的数据 int* data = (int*)event-&gt;getUserData() CCLOG(&quot;onCustomEvent data = %d&quot;, data); } 4、说明 每个自定义的事件监听器，都有一个监听器名字eventName。即为订阅的消息名称。 需要通过 dispatcher-&gt;dispatchEvent(&amp;event); 来手动将事件分发出去。即为发布消息。 可以通过 dispatcher-&gt;dispatchCustomEvent(,); 来给自定义事件监听器绑定一个用户数据。]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>事件</tag>
        <tag>cocos2dx lua注册事件详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx lua 闭包(匿名函数)入门实战]]></title>
    <url>%2F2018%2F09%2F28%2Fcocos2dx-lua-%E9%97%AD%E5%8C%85-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0-%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[本文首先通过具体的例子讲解了Lua中闭包的概念，然后总结了闭包的应用场合，最后探讨了Lua中闭包的实现原理。 闭包的概念 在Lua中，闭包（closure）是由一个函数和该函数会访问到的非局部变量（或者是upvalue）组成的，其中非局部变量（non-local variable）是指不是在局部作用范围内定义的一个变量，但同时又不是一个全局变量，主要应用在嵌套函数和匿名函数里，因此若一个闭包没有会访问的非局部变量，那么它就是通常说的函数。也就是说，在Lua中，函数是闭包一种特殊情况。 不知道c++的lambda和lua的闭包是谁先谁后，不过就我来说，是先学了c++，最近才接触到现代lua。因此把一切向c++看齐，会不自觉地把一切和c++做对比。 就闭包来说，不就是c++的lambda嘛！ 前面所说的upvalue，也就是一开始按引用捕获，在变量退出生命期时，拷贝到Functor的成员变量里来，变成了按值捕获。这算是解释性语言特有的灵活性吧，变量可以在运行时按解释器的便利来移动位置，而不必像苦哈哈的编译性语言，一旦决定好位置，就无法移动了。 在Lua的C API中，所有关于Lua中的函数的核心API都是以closure来命名的，也可视为这一观点的延续。在Lua中，函数是一种第一类型值（First-Class Value），它们具有特定的词法域（Lexical Scoping）。 Lua使用结构体upvalue来实现闭包。外面的局部变量可以直接通过upvalue进行访问。 upvalue最开始的时候指向栈中的一个变量，此时这个变量还在它的生存周期内。 当变量离开作用域（译者注：就是函数返回后，变量的生存周期结束时），这个变量就从栈转移到了upvalue中。 虽然这个变量存储在upvalue中，但是访问这个变量还是间接通过upvalue中的一个指针进行的（译者注：和在栈中时候的访问方式一样）。 因此，变量位置的转移对任何试图读写这个变量的代码都是透明的。 有别于这个变量在一个函数内部时候的行为，函数声明、访问这个变量，就是直接对栈的操作。 看下具体例子： function f1(n) --函数参数n也是局部变量 local function f2() print(n) --引用外部函数的局部变量 end return f2 end g1 = f1(2015) g1() -- 打印出2015 g2 = f1(2016) g2() -- 打印出2016 这里的n就是upvalue。upvalue实际指的是变量而不是值，这些变量可以在内部函数之间共享，即upvalue提供一种闭包之间共享数据的方法， 再看个例子： function Create(n) local function foo1() print(n) end local function foo2() n = n + 10 end return foo1,foo2 end f1,f2 = Create(2015) f1() -- 打印2015 f2() f1() -- 打印2025 f2() f1() -- 打印2035 上面的例子中，闭包f1和f2共享同一个upvalue了，这是因为当Lua发现两个闭包的upvalue指向的是当前堆栈上的相同变量时，会聪明地只生成一个拷贝，然后让这两个闭包共享该拷贝，这样任一个闭包对该upvalue进行修改都会被另一个探知。 为什么会这样，我们看下面的解释： 通过为每个变量最多创建一个upvalue并按需要重复利用这个upvalue，保证了未决状态（未超过生命周期）的局部变量（pending vars）能够在闭包之间正确地共享。 为了保证这种唯一性，Lua维护这一条链表，该链表中每个节点对应一个打开的upvalue（opend upvalue）结构，打开的upvalue是指当前正指向栈局部变量的upvalue，如上图的未决状态的局部变量链表（the pending vars list）。 当Lua创建一个新的闭包时，Lua会遍历当前函数所有的外部的局部变量，对于每一个外部的局部变量，若在上面的链表中能找到该变量，则重复使用该打开的upvalue，否则，Lua会创建一个新的打开的upvalue，并把它插入链表中。 当局部变量离开作用域时（即超过变量生命周期），这个打开的upvalue就会变成关闭的upvalue（closed upvalue），并把它从链表中删除，一旦某个关闭的upvalue不再被任何闭包所引用，那么它的存储空间就会被回收。 最后看下闭包的应用。 闭包最常用的一个应用就是实现迭代器。所谓迭代器就是一种可以遍历一种集合中所谓元素的机制。每个迭代器都需要在每次成功调用之间保持一些状态，这样才能知道它所在的位置及如何进到下一个位置。闭包刚好适合这种场景。比如下面的代码： function values(t) local i = 0 return function () i = i + 1 return t[i] end end t = {10, 20, 30} iter = values(t) while true do local element = iter() if element == nil then break end print(element) end 总结下lua闭包，关键点是upvalue，然后注意下如何申明一个背包，函数（A）里面返回的是函数（B），B引用了A的局部变量。]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>事件</tag>
        <tag>ocos2dx lua 闭包(匿名函数)入门实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2d-x lua —— 元表metatable]]></title>
    <url>%2F2018%2F09%2F22%2Fcocos2d-x-lua-%E2%80%94%E2%80%94-%E5%85%83%E8%A1%A8metatable%2F</url>
    <content type="text"><![CDATA[Lua表关于Lua表的介绍，这里有一段出自网络的介绍： Lua的表本质其实是个类似HashMap的东西，其元素是很多的Key-Value对.如果尝试访问了一个表中并不存在的元素时，就会触发Lua的一套查找机制，也是凭借这个机制，才能够实现“面向对象”的。 那么有时候我们可能会遇到这样的一段代码： myTable = {} print(myTable.A) --这里试图打印myTable并不存在的成员A 执行结果：nil 输出为nil的原因很简单，myTable中并没有A这个成员，这符合我们平时对HashMap的认知。但对于Lua表，如果myTable有元表，情况就不同了。 Lua元表 元表像是一个备用查找表，说白了假设表A的元表是B，那么如果在A中找不到的东西就会尝试在B中去找。 在Lua中，metatable是被译作元表，Lua 中的每个值都可以用一个 metatable。这个 metatable 就是一个原始的 Lua table ，它用来定义原始值在特定操作下的行为。 一个 metatable 可以控制一个对象做数学运算操作、比较操作、连接操作、取长度操作、取下标操作时的行为，metatable 中还可以定义一个函数，让 userdata 作垃圾收集时调用它。对于这些操作，Lua 都将其关联上一个被称作事件的指定健。 当 Lua 需要对一个值发起这些操作中的一个时，它会去检查值中 metatable 中是否有对应事件。如果有的话，键名对应的值（元方法）将控制 Lua 怎样做这个操作。 #####metatable通过其包含的函数来给所挂接的table定义一些特殊的操作，包括: __add: 定义所挂接table的加法操作 __mul: 定义乘法操作 __div: 定义除法操作 __sub: 定义减法操作 __unm: 定义负操作, 即: -table的含义 __tostring: 定义当table作为tostring()函式之参数被呼叫时的行为(例如: print(table)时将呼叫tostring(table)作为输出结果) __concat: 定义连接操作(“..”运算符) __index: 定义当table中不存在的key值被试图获取时的行为 __newindex: 定义在table中产生新key值时的行为 这里主要说一下_index__index：如果A的元表是B，那么如果访问了一个A中不存在的成员，就会访问查找B中有没有这个成员。这个过程大体是这样，但却不完全是这样，实际上，即使将A的元表设置为B，而且B中也确实有这个成员，返回结果仍然会是nil，原因就是B的index元方法没有赋值。按照我的理解，index方法是用来确定一个表在被作为元表时的查找方法 father = { house=1 } son = { car=1 } setmetatable(son, father) --把son的metatable设置为father print(son.house) 输出的结果是nil，但如果把代码改为 father = { house=1 } father.__index = father -- 把father的__index方法指向自己 son = { car=1 } setmetatable(son, father) print(son.house) 输出的结果为1，符合预期。 在上述例子中，访问son.house时，son中没有house这个成员，但Lua接着发现son有元表father，于是此时father被当做元表来查找，此时，Lua并不是直接在father中找名为house的成员，而是调用father的index方法，如果index方法为nil，则返回nil，如果是一个表（上例中father的index方法等于自己，就是这种情况），那么就到index方法所指的这个表中查找名为house的成员，于是，最终找到了house成员。 注：index方法除了可以是一个表，还可以是一个函数，如果是一个函数，index方法被调用时将返回该函数的返回值。 相信到这里，应该已经很好理解了。 总结一句就是：index是:当我们访问一个表中的元素不存在时，则会触发去寻找index元方法，如果不存在，则返回nil，如果存在，则返回结果。补充 _newindex：当给你的表中不存在的值进行赋值时，lua解释器则会寻找__newindex元方法，发现存在该方法，则执行该方法进行赋值，注意，是使用rawset来进行赋值，至于原因，后面会讲到。 rawget是为了绕过index而出现的，直接点，就是让index方法的重写无效。 Lua查找一个表元素时的规则（出自网络） 1.在表中查找，如果找到，返回该元素，找不到则继续 2.判断该表是否有元表，如果没有元表，返回nil，有元表则继续 3.判断元表有没有index方法，如果index方法为nil，则返回nil；如果index方法是一个表，则重复1、2、3；如果index方法是一个函数，则返回该函数的返回值 参考链接：https://blog.csdn.net/wangbin_jxust/article/details/12108189]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2d-x lua —— 元表metatable</tag>
        <tag>cocos2dx</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx lua 语法糖之冒号(:)与点号(.)区别与使用]]></title>
    <url>%2F2018%2F09%2F16%2Fcocos2dx-lua-%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B9%8B%E5%86%92%E5%8F%B7-%E4%B8%8E%E7%82%B9%E5%8F%B7-%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[相信接触Lua或者做过cocos2dx lua的朋友，都遇到过这样的迷惑，关于Lua中冒号(:)与点号(.)语法糖，有时候会混乱，或者说一开始不太能适应和理解这里的区别和使用。 今天，就主要围绕着两个点，实际对比一下，并结合案例进行实战，并进行一些相关的拓展！ 先来看看下面这段代码： ObjectData = {} function ObjectData.count1( self ) print(&quot;ObjectData.count1&quot;, self) end function ObjectData:count2() print(&quot;ObjectData:count2&quot;, self) end a = ObjectData a.count1() -- nil a:count1() a.count1(a) a:count1(a) a.count2() -- nil a:count2() a.count2(a) a:count2(a) 我们通过打印，得到下面的结果，是不是有点蒙圈了！ -- ObjectData.count1 nil -- ObjectData.count1 table: 0x7c06d880 -- ObjectData.count1 table: 0x7c06d880 -- ObjectData.count1 table: 0x7c06d880 -- ObjectData:count2 nil -- ObjectData:count2 table: 0x7c06d880 -- ObjectData:count2 table: 0x7c06d880 -- ObjectData:count2 table: 0x7c06d880 有了上面的实例，我就可以通过简单的区分来实际应用和对比一下。 方法的点号定义和点号调用。money = {count = 888} function money.getCount(money ,somecount) money.count = money.count - somecount end money.getCount(money ,666) print(money.count) 冒号定义和冒号调用。money = {count = 888} function money:getCount(somecount) self.count = self.count - somecount end money:getCount(666) print(money.count) 以上的打印结果都是666。 可以看出，冒号定义和冒号调用其实跟上面的效果一样，只是把第一个隐藏参数省略了，而该参数self指向调用者自身当然了，我们也可以点号定义冒号调用，或者冒号定义点号调用 money = {count = 888} function money.getCount(self ,somecount) self.count = self.count - somecount end money:getCount(666) print(money.count) 冒号只是起了省略第一个参数self的作用，该self指向调用者本身，并没有其他特殊的地方。 也有网友提出：用lua进行面向对象的编程,声明方法和调用方法统一用冒号,对于属性的调用全部用点号 由此总结就是： 定义的时候冒号默认接收self参数 调用的时候冒号默认传递调用者自己为参数 而句号要显示传递或接收self参数 冒号会提供一个内置table供function之间通信。 一个点用来定义和取得一个变量，这个变量可能是个函数 两个点用来定义和调用一个函数，两个点会自动传入“调用者”这个table自身 如果是使用Cocos2d-x lua来开发的话，大部分情况下都是使用冒号的。 原因很简单，因为大部分情况下我们都要使用到self参数，就像C++的this关键字一样。 推荐： https://blog.csdn.net/stormbjm/article/details/38532413 https://www.cnblogs.com/youxilua/archive/2011/07/28/2119059.html]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>游戏</tag>
        <tag>cocos2dx lua 语法糖之冒号(:)与点号(.)区别与使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx lua 常见命令行(编译&调试&运行&打包)]]></title>
    <url>%2F2018%2F09%2F15%2Fcocos2dx-lua-%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E8%A1%8C-%E7%BC%96%E8%AF%91-%E8%B0%83%E8%AF%95-%E8%BF%90%E8%A1%8C-%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[cocos 命令 Cocos2d-x 带有一个命令行工具：cocos 这是一个跨平台的工具，你可以用它创建项目、运行项目、发布项目。命令行工具适用于所有 Cocos2d-x 支持的平台，包括：iOS、Android、Mac、Linux、Windows、Web。不用 IDE，只用命令行，你就能完成所有的工作！ 本文选自cocos2dx官方文档，只做记录！ 项目创建使用 cocos new 命令创建新项目，命令格式如下： cocos new &lt;game name&gt; -p &lt;package identifier&gt; -l &lt;language&gt; -d &lt;location&gt; 示例： cocos new MyGame -p com.MyCompany.MyGame -l cpp -d ~/MyCompany cocos new MyGame -p com.MyCompany.MyGame -l lua -d ~/MyCompany cocos new MyGame -p com.MyCompany.MyGame -l js -d ~/MyCompany 使用命令 cocos new –help 可以查看到更多关于项目创建的帮助信息。 项目编译我们都知道，程序从源码到二进制程序，有一个编译环节。我们来看下 Cocos2d-x 是如何编译项目的，命令格式如下： cocos compile -s &lt;path to your project&gt; -p &lt;platform&gt; -m &lt;mode&gt; -o &lt;output directory&gt; 示例： cocos compile -s ~/MyCompany/MyGame -p ios -m release -o ~/MyCompany/MyGame/bin cocos compile -s ~/MyCompany/MyGame -p android -m release -o ~/MyCompany/MyGame/bin cocos compile -s c:\MyCompany\MyGame -p win32 -m release -o c:\MyCompany\MyGame\bin 这里的参数有点多，让我们来一个一个说，-p 是编译的平台，-m 是模式：debug 或者 release。如果没指定模式，默认 debug。此外 -s 和 -o 参数是可选的，如果操作命令的当前路径就是工程的路径，那这两个参数都可以省掉。比如已经在 ~/MyCompany/MyGame 目录，那编译命令可以简化为： cocos compile . -p ios -m release 你也可以增加一个可选的参数 -q，这样执行静默操作，控制台的输出信息会比较少。示例： cocos compile -q -s ~/MyCompany/MyGame -p ios -m release -o ~/MyCompany/MyGame/bin 由于命令行工具支持很多平台，因此还有一些特定平台的参数，使用它们可以进行更多的控制，比如指定 SDK 版本，确定签名信息，添加一些 Lua 相关或专用于 Web 的选项。 使用命令 cocos compile –help 可以查看更多关于项目编译的帮助信息。 Android 项目编译注意事项 命令行工具是很灵活的，对于编译 Android 项目允许开发者使用特定版本的 API。比如你的系统上安装了 Android-22，你想使用它来编译，就在命令行的最后增加参数 –ap android-api-version。示例： cocos compile -p android –ap android-22 你可以在项目的配置中，查看到目标 API 是什么版本。 项目运行创建完项目后，你可以直接从命令行执行运行命令。cocos 会启动你指定平台的程序。命令行格式如下： cocos run -s &lt;path to your project&gt; -p &lt;platform&gt; 示例: cocos run -s ~/MyCompany/MyGame -p ios cocos run -s ~/MyCompany/MyGame -p android cocos run -s c:\MyCompany\MyGame -p win32 当然，你也可以指定程序以 debug 还是 release 方式运行，默认的方式是 debug。示例： cocos run -s ~/MyCompany/MyGame -p ios -m release 就好像 cocos compile 命令那样，如果你已经在项目目录了，-s 和 -o 参数就不是必须的，这对 cocos run 命令也一样。就以上面的为例，如果已经在工程目录，命令可以简化成： cocos run . -p ios -m release 在运行 Web 程序时，还有可选的参数，允许你指定浏览器，例如指定 Google Chrome： cocos run -s ~/MyCompany/MyGame -p web -b /Applications/Google\ Chrome.app cocos run -s ~/MyCompany/MyGame -p web -b C:\Program Files\Google\Chrome\Application\chrome.exe cocos run -s ~/MyCompany/MyGame -p web -b /usr/local/bin/chrome 你还可以指定 IP 地址和端口，更多关于项目运行的使用帮助，请运行 cocos run –help 命令。 项目发布cocos 通过提供一系列项目发布的命令实现了简单的发布机制。这些命令，就像上面介绍的命令一样，通过一些参数指定需要的操作。命令格式如下： cocos deploy -s &lt;path to your project&gt; -p &lt;platform&gt; -m &lt;mode&gt; 示例： cocos deploy -s ~/MyCompany/MyGame -p ios -m release cocos deploy -s ~/MyCompany/MyGame -p android -m release cocos deploy -s c:\MyCompany\MyGame -p win32 -m release 你可以增加参数 -q，执行静默操作，这样控制台的输出信息会比较少。示例： cocos deploy -q -s ~/MyCompany/MyGame -p ios -m release 运行 cocos deploy –help，可以查看更多关于项目发布的帮助信息。]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>事件</tag>
        <tag>cocos2dx lua 常见命令行(编译&amp;调试&amp;运行&amp;打包)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2dx——项目启动流程与跨平台原理]]></title>
    <url>%2F2018%2F09%2F14%2Fcocos2dx%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[最近大部分空余时间都在开始学习cocos2d游戏开发相关技术，作为一个游戏行业菜鸟级别的选手，我觉得基础很重要，所以我决定从cocos2dx启动流程和快平台原理开始！ 注:这里只针对Lua做相关介绍，为什么是Lua，有过cocos2dx经验的朋友应该都知道Lua小，快，简单，而且比较大众化，而C++就不多多说了，大部分程序员都有畏惧心理，当然也有一些C++比较好，或者有独特爱好和专研朋友！ 关于其他平台基本上的流程和原理其实是一样的，可以直接参考！ 什么是Lua 百科: Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。 Lua由标准C编写而成，几乎在所有操作系统和平台上都可以编译，运行。Lua并没有提供强大的库，这是由它的定位决定的。所以Lua不适合作为开发独立应用程序的语言。 Lua 有一个同时进行的JIT项目，提供在特定平台上的即时编译功能。 很多应用程序、游戏使用LUA作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。这其中包括魔兽世界、博德之门、愤怒的小鸟、QQ三国、VOCALOID3、太阳神三国杀、游戏王ygocore等。 Cocos2d-lua，其实只是Cocos2d引擎添加了Lua绑定的版本。Cocos2d这里就不解释了，懒得拷贝，只是关于cocos创建和使用的时候需要注意的是 cocos new TestProj -d Desktop/ -l lua，这里的引擎其实是同一套，只是创建工程时提供了不同语言的桥接层 使用C++语言和Cocos2d-x引擎进行开发时，我们写的代码是直接调用引擎的API的，因为引擎也是用C++语言编写，不需要进行语言转换 使用Lua语言和Cocos2d-x引擎进行开发时，我们写的代码通过LuaEngine执行，而LuaEngine封装了Cocos2d-x引擎的API，所以就相当于使用Lua脚本在调用Cocos2d-x的API了 各个平台的入口iOS#import &lt;UIKit/UIKit.h&gt; int main(int argc, char *argv[]) { NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init]; int retVal = UIApplicationMain(argc, argv, nil, @&quot;AppController&quot;); [pool release]; return retVal; } Mac OS#import &lt;Cocoa/Cocoa.h&gt; int main(int argc, char *argv[]) { return NSApplicationMain(argc, (const char **)argv); } Linuxint main(int argc,char *argv) { AppDelegate app; return Application::getInstance()-&gt;run(); } Androidvoid cocos_android_app_init(JNIENV* env) { appDelegate.reset(new AppDelegate()); //新版本 : AppDelegate *pAppDelegate = new AppDelegate(); } Android启动流程概述 配置文件Manifest AppActivity onCreate super.onCreate onLoadNativeLibraries System.loadLibrary(libName); 触发cocos_android_app_init（在main.cpp）中 再由库执行调用对应的Lua代码 …… 由于笔者一直着力于iOS平台，所以这里以iOS为例，其他平台可参考：1. main函数入口iOSApp中打开程序，加载完动态库，和一些必备的初始化和准备(rebase, bind,SetUp)之后,会回到main函数开始执行真正的程序代码 int main(int argc, char *argv[]) { @autoreleasepool { return UIApplicationMain(argc, argv, nil, @&quot;AppController&quot;); } } Main函数里面会调用UIApplicationMain， UIApplicationMain会一路走完这些流程 + 根据principalClassName传递的类名创建UIApplication对象 + 创建UIApplication代理对象，给UIApplication对象设置代理 + 开启主运行时间循环，处理事件，保持程序一直运行 + 加载info.plist，判断下是否指定了main，如果指定了，就会去加载 我们可以看到这里设置的代理是AppController，然后看看AppController 2. 代理对象AppControllerAppController里面有个 didFinishLaunchingWithOptions，这个是程序加载完毕的监听方法 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { cocos2d::Application *app = cocos2d::Application::getInstance(); // Initialize the GLView attributes app-&gt;initGLContextAttrs(); cocos2d::GLViewImpl::convertAttrs(); // Override point for customization after application launch. // Add the view controller&apos;s view to the window and display. window = [[UIWindow alloc] initWithFrame: [[UIScreen mainScreen] bounds]]; // Use RootViewController to manage CCEAGLView _viewController = [[RootViewController alloc]init]; _viewController.wantsFullScreenLayout = YES; // Set RootViewController to window if ( [[UIDevice currentDevice].systemVersion floatValue] &lt; 6.0) { // warning: addSubView doesn&apos;t work on iOS6 [window addSubview: _viewController.view]; } else { // use this method on ios6 [window setRootViewController:_viewController]; } [window makeKeyAndVisible]; [[UIApplication sharedApplication] setStatusBarHidden:true]; // IMPORTANT: Setting the GLView should be done after creating the RootViewController cocos2d::GLView *glview = cocos2d::GLViewImpl::createWithEAGLView((__bridge void *)_viewController.view); cocos2d::Director::getInstance()-&gt;setOpenGLView(glview); //run the cocos2d-x game scene app-&gt;run(); return YES; } 前面分别：获取Director，GLView设置GLView，最后执行run 3. run cocos2d delegate我们看看run方法里面，这里的run方法很关键， int Application::run() { if (applicationDidFinishLaunching()) { [[CCDirectorCaller sharedDirectorCaller] startMainLoop]; } return 0; } 有个applicationDidFinishLaunching，其实这里cocos2d默认的代理，在class中 4. cocos2d配置，lua加载这里在coco2d的代理中，可以看到一堆的初始化配置和加载，然后就开始获取并执行脚本lua(通过lua脚本显示并处理Scene逻辑) bool AppDelegate::applicationDidFinishLaunching() { // set default FPS Director::getInstance()-&gt;setAnimationInterval(1.0 / 60.0f); // register lua module auto engine = LuaEngine::getInstance(); ScriptEngineManager::getInstance()-&gt;setScriptEngine(engine); lua_State* L = engine-&gt;getLuaStack()-&gt;getLuaState(); lua_module_register(L); register_all_packages(); LuaStack* stack = engine-&gt;getLuaStack(); stack-&gt;setXXTEAKeyAndSign(&quot;2dxLua&quot;, strlen(&quot;2dxLua&quot;), &quot;XXTEA&quot;, strlen(&quot;XXTEA&quot;)); //register custom function //LuaStack* stack = engine-&gt;getLuaStack(); //register_custom_function(stack-&gt;getLuaState()); #if CC_64BITS FileUtils::getInstance()-&gt;addSearchPath(&quot;src/64bit&quot;); #endif FileUtils::getInstance()-&gt;addSearchPath(&quot;src&quot;); FileUtils::getInstance()-&gt;addSearchPath(&quot;res&quot;); if (engine-&gt;executeScriptFile(&quot;main.lua&quot;)) { return false; } return true; } 原生集成补充如果你是直接在原生嵌入而不是夸平台会看到这里其实是创建并返回Scene bool AppDelegate::applicationDidFinishLaunching() { // initialize director auto director = Director::getInstance(); auto glview = director-&gt;getOpenGLView(); if(!glview) { glview = GLViewImpl::create(&quot;Fiction_Single&quot;); director-&gt;setOpenGLView(glview); } // turn on display FPS // director-&gt;setDisplayStats(true); // set FPS. the default value is 1.0/60 if you don&apos;t call this director-&gt;setAnimationInterval(1.0f / 60); register_all_packages(); //SpriteFrameCache::getInstance()-&gt;removeSpriteFrames(); //SpriteFrameCache::getInstance()-&gt;removeUnusedSpriteFrames(); // create a scene. it&apos;s an autorelease object // 初始化与运行主场景 auto scene = GameMainLayer::MainScene(); // 初始化与运行主场景 director-&gt;runWithScene(scene); return true; } 游戏逻辑就可以从这个Scene中的init函数开始，添加UI层，添加事件监听器，添加游戏层等等…如果我们有一些统计、资源管理器等，也可以在AppDelegate的applicationDidFinishLaunching函数中来进行。 5. Lua脚本初始化在这之前，我们先先看看，项目的配置文件config.json { &quot;init_cfg&quot;:{ &quot;isLandscape&quot;: true, &quot;isWindowTop&quot;: false, &quot;name&quot;: &quot;MyDemo&quot;, &quot;width&quot;: 960, &quot;height&quot;: 640, &quot;entry&quot;: &quot;src/main.lua&quot;, &quot;consolePort&quot;: 6050, &quot;uploadPort&quot;: 6060 }, &quot;simulator_screen_size&quot;: [ { &quot;title&quot;: &quot;iPhone 3Gs (480x320)&quot;, &quot;width&quot;: 480, &quot;height&quot;: 320 }, ...... ] } 可以看到”entry”: “src/main.lua”,也就是说入口文件是main.lua，由此可以得知，即使我们不从iOS的启动流程来看，整个启动也会从这里开始，进入。 再来看”main.lua”，这个时候我们就开始开发查看main.lua文件从MyApp开始，初始化，然后执行run运行程序 cc.FileUtils:getInstance():setPopupNotify(false) require &quot;config&quot; require &quot;cocos.init&quot; local function main() require(&quot;app.MyApp&quot;):create():run() end local status, msg = xpcall(main, __G__TRACKBACK__) if not status then print(msg) end 这里很重要的一个方法是run(),run()方法是设置启动View，执行main函数，main函数里加载MyApp创建并运行，进而打开MyApp.lua： 6. MyApp.lua我们看到MyApp仅仅是继承自AppBase，onCreate函数只是初始化了下随机数种子，也就意味着更多的操作在AppBase中，我们打开分析： local AppBase = class(&quot;AppBase&quot;) function AppBase:ctor(configs) self.configs_ = { viewsRoot = &quot;app.views&quot;, modelsRoot = &quot;app.models&quot;, defaultSceneName = &quot;TitleScene&quot;, } for k, v in pairs(configs or {}) do self.configs_[k] = v end if type(self.configs_.viewsRoot) ~= &quot;table&quot; then self.configs_.viewsRoot = {self.configs_.viewsRoot} end if type(self.configs_.modelsRoot) ~= &quot;table&quot; then self.configs_.modelsRoot = {self.configs_.modelsRoot} end if DEBUG &gt; 1 then dump(self.configs_, &quot;AppBase configs&quot;) end if CC_SHOW_FPS then cc.Director:getInstance():setDisplayStats(true) end -- event self:onCreate() end function AppBase:run(initSceneName) initSceneName = initSceneName or self.configs_.defaultSceneName self:enterScene(initSceneName) end function AppBase:enterScene(sceneName, transition, time, more) local view = self:createView(sceneName) view:showWithScene(transition, time, more) return view end function AppBase:createView(name) for _, root in ipairs(self.configs_.viewsRoot) do local packageName = string.format(&quot;%s.%s&quot;, root, name) local status, view = xpcall(function() return require(packageName) end, function(msg) if not string.find(msg, string.format(&quot;&apos;%s&apos; not found:&quot;, packageName)) then print(&quot;load view error: &quot;, msg) end end) local t = type(view) if status and (t == &quot;table&quot; or t == &quot;userdata&quot;) then return view:create(self, name) end end error(string.format(&quot;AppBase:createView() - not found view \&quot;%s\&quot; in search paths \&quot;%s\&quot;&quot;, name, table.concat(self.configs_.viewsRoot, &quot;,&quot;)), 0) end function AppBase:onCreate() end return AppBase 在前面的分析中知道main.lua是执行的是App的run函数，作为基类的AppBase，当然也要被调用run函数，因此直接看run函数：主要是创建并进入场景initSceneName，如果run的参数没有指定开始的场景则使用默认场景defaultSceneName，默认场景在构造函数的时候被初始化为MainScene，也就是说场景默认将从MainScene开始。 7. 指定Scene如果想指定启动，而不是使用默认的Scene，那么项目启动后会直接进入该场景，这点有个好处是如果要调试设计某场景可以直接从这个场景进入，不必从其他场景进入了。 local function main() require(&quot;app.MyApp&quot;):create():run(&quot;StartScene&quot;) end 默认不设置会选择MainScene，如果仔细再AppBase里面会看到这样一行代码 function AppBase:ctor(configs) self.configs_ = { viewsRoot = &quot;app.views&quot;, modelsRoot = &quot;app.models&quot;, defaultSceneName = &quot;MainScene&quot;, } ..... 那么项目启动后会直接进入StartScene场景，而不再是默认的MainScene场景。 8. 根据脚本指定Scene，上面说了，如果没有设置就会试着用默认的Scene，run里面的逻辑就是去真正指定Scene， -- 创建完对象之后，就到了这一步 function AppBase:run(initSceneName) initSceneName = initSceneName or self.configs_.defaultSceneName self:enterScene(initSceneName) -- 如果没有指定第一个Scene，则第一个Scene为MainScene end -- 生成并进入第一个Scene function AppBase:enterScene(sceneName, transition, time, more) local view = self:createView(sceneName) -- 前去生成View view:showWithScene(transition, time, more) -- 因为MainScene继承自ViewBase类，这里就吊用ViewBase的方法了 return view end 建议仔细读一下AppBase，ViewBase！ 9. 自定义Scene(StartScene)这个时候就会首先从StartScene开始， local StartScene = class(&quot;StartScene&quot;, cc.load(&quot;mvc&quot;).ViewBase) function StartScene:onCreate() display.newSprite(&quot;HelloWorld.png&quot;) :move(display.center) :addTo(self) cc.Label:createWithSystemFont(&quot;cocos2dx Run StartScene&quot;, &quot;Arial&quot;, 60) :move(display.cx, display.cy + 200) :addTo(self) end return StartScene 然后后面步骤就是从StartScene开始，写脚本代码，处理UI，网络和逻辑等，到这里就基本上完成cocos2dx Lua启动流程，其他C++,JS原理和流程其实都差不多, 只是执行的方法或者代码不一样而已 总结其实关于coocs2dx之前的版本我不了解，就我目前了解到的，其实就是由通用程序入口到跨平台程序入口 基本的流程如下 初始化Director 新建GLView，然后进行一些设置 新建Scene 使用Director运行这个场景 bool AppDelegate::applicationDidFinishLaunching()//程序入口 -&gt; 跨平台程序入口 { auto director = Director::getInstance(); auto glview = director-&gt;getOpenGLView(); if(!glview) { glview = GLViewImpl::create(&quot;my test&quot;); director-&gt;setOpenGLView(glview); } //初始化、资源适配、屏幕适配、运行第一个场景... glview-&gt;setDesignResolutionSize(); auto scene = Hellow::scene(); director-&gt;runWithScene(scene); return scene; } 通过上面我们其实可以知道，cocos2d_lua_bindings库提供了Lua对Cocos2d引擎的绑定，相当于通过注册Module的方式对Cocos2d引擎提供的（相关的）API进行了一次封装（把常用的功能封装成一个函数newScene）。 相对于Cocos2d-x C++工程来说，Cocos2d-x生成的Lua语言工程提供了对Cocos2d引擎的Lua语言封装。将Cocos2d引擎API绑定到对应的Lua语言函数，在调用到这些函数时，会执行对应的Cocos2d引擎API, 其实最终还是调用的C++代码和对应的引擎代码。 跨平台原理 AppDelegate 作为跨平台程序入口，在这之上做了另一层的封装，封装了不同平台的不同实现。比如我们通常认为一个程序是由 main 函数开始运行，那我们就去找寻，我们看到了在 proj.linux 目录下存在 main.cpp 文件。 在main.cpp 中 CCApplication::sharedApplication()–&gt;run(); 这一句看起，这一句标志着， cocos2d-x 程序正式开始运行. 定位到 sharedApplication() 方法的实现，在CCAplication类中我们可以看到从 sharedApplication() 方法，在调用 run() 方法，在这之前，我们需要调用到它的构造函数，否则不能运行，这就是为什么在 CCApplication::sharedApplication()–&gt;run(); 之前，我们首先有语句 AppDelegate app; 创建 AppDelegate 变量的原因是 AppDelegate 是 CCApplication 的子类，在创建子类对象的时候，调用其构造函数的同时，父类构造函数也会执行，然后就将 AppDelegate 的对象赋给了 CCApplication 的静态变量，而在 AppDelegate 之中我们实现了 applicationDidFinishLaunching方法，所以在 CCApplication 中 run 方法的开始处调用的就是 AppDelegate 之中的实现。 我们在此方法中我们初始化了一些变量，创建了第一个 CCScene 场景等，之后的控制权，便全权交给了CCDirector::sharedDirector()–&gt;mainLoop(); 方法了。 在cocos2d-x的文件夹下，有一个platform文件夹，里面存放了跨平台的封装接口。 当前目录下有CCApplicationProtocol.h头文件，子目录有win32,Android,IOS三个文件夹，里面分别存放跨平台需要的函数，其中包括CCApplication。 而AppDelegate 类则是继承自CCApplication。CCApplication又继承自CCApplicationProtocol。 在CCApplicationProtocol中定义了applicationDidFinishLaunching虚方法,由CCApplication 继承， AppDelegate 实现的。以此实现了跨平台。 为了充分发挥硬件性能，手机游戏通常使用Native App开发模式，这就造成开发商要为iOS 和Android平台用户开发不同的应用，无论是产品迭代还是运行维护都非常麻烦。 Cocos2d-x在iOS，Android等移动平台之上，封装了一层C++接口，从而屏蔽了平台的差异性，通过平台宏来控制使用哪个平台的代码，向开发者提供C++接口调用。这些接口主要包括UI、事件和网络，封装UI主要是使用OpenGL ES的接口来写UI，封装事件和网络，均是使用C++接口对原生接口进行一层封装。 其实对应cocos2dx跨平台在说，我们这么理解就可以了 Lua底层是通过C编写实现的 Android通过JNI技术调用C iOS也是完全兼容C语言 我们打开对应的工程可以看到 Java项目中，有些关于Lua的文件， luajava.jar是Java代码封装包， libluajava-1.1.so在底层封装了.C 文件，实现了lua相关底层功能。 但是在iOS项目中，我们发现 iOS允许开发者使用C语言文件和objective-c文件混合编程。但是，如果你在Objective-C的代码中调用C文件中的函数，你不能直接将.c文件import到你的OC文件中，这样是不起作用的。你需要先创建一个.h 头文件 里面包含你的函数申明，同时将这个.h 头文件import到.c文件中，.c文件负责实现要调用的函数。最后将你新创建的.h头文件import到OC文件中，这样你就可以在OC的文件中调用C的方法了 具体更多启动相关细节，可以参考这里 https://www.jianshu.com/p/781d835c88c9 http://www.cocos2d-x.org/docs/cocos2d-x/zh/about/learn.html]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>游戏</tag>
        <tag>cocos2dx——项目启动流程与跨平台原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——请求依赖多种解决方案]]></title>
    <url>%2F2018%2F08%2F23%2FiOS%E2%80%94%E2%80%94%E8%AF%B7%E6%B1%82%E4%BE%9D%E8%B5%96%E5%A4%9A%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[iOS开发中如何解决网络请求的依赖关系(同时应用于业务层) 比如：一个(或多个)接口的请求需要依赖于另一个(或多个)网络请求的结果？ 目录 操作依赖 – NSOperation 逻辑判断 – if/else 线程同步 – 组队列 线程同步 – 阻塞任务 线程同步 – 信号量机制 操作依赖 – NSOperationNSOperation 操作依赖和优先级（不适用，异步网络请求并不是立刻返回，无法保证回调时再开启下一个网络请求） 1234567891011121314151617181920// Do any additional setup after loading the view, typically from a nib.//创建队列NSOperationQueue *queue=[[NSOperationQueue alloc] init];//创建操作NSBlockOperation *operation1=[NSBlockOperation blockOperationWithBlock:^()&#123; NSLog(@"执行第1次操作，线程：%@",[NSThread currentThread]);&#125;];NSBlockOperation *operation2=[NSBlockOperation blockOperationWithBlock:^()&#123; NSLog(@"执行第2次操作，线程：%@",[NSThread currentThread]);&#125;];NSBlockOperation *operation3=[NSBlockOperation blockOperationWithBlock:^()&#123; NSLog(@"执行第3次操作，线程：%@",[NSThread currentThread]);&#125;];//添加依赖[operation1 addDependency:operation2];[operation2 addDependency:operation3];//将操作添加到队列中去[queue addOperation:operation1];[queue addOperation:operation2];[queue addOperation:operation3]; 逻辑判断 – if/else上一个网络请求的响应回调后，下一网络请求的才开始执行 1234567891011121314NSString *urlString = @"http://www.icocos.cn"; AFHTTPSessionManager *manger =[AFHTTPSessionManager manager]; [manger GET:urlString parameters:nil progress:^(NSProgress * _Nonnull downloadProgress) &#123; &#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; NSLog(@"成功"); ///////////////////////////////////////////// // TODO： 执行下一个请求 /////////////////////////////////////////////&#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; NSLog(@"%@",error);&#125;]; 但是这样会存在一个概率性的问题，就会有可能根本拿不到结果，或者由于网络慢和用户操作之间的关系导致不可预料的问题。 线程同步 – 组队列（dispatch_group）dispatch_group是GCD(Grand Central Dispatch)中的一组方法，他有一个组的概念，可以把相关的任务归并到一个组内来执行，通过监听组内所有任务的执行情况来做相应处理。 1.dispatch_group_async 将代码块dispatch_block_t block放入队列dispatch_queue_t queue中执行；并和调度组dispatch_group_t group相互关联；如果提交到dispatch_queue_t queue中的block全都执行完毕会调用dispatch_group_notify并且dispatch_group_wait会停止等待； 2.dispatch_group_enter(group)、dispatch_group_leave(group) 和内存管理的引用计数类似，我们可以认为group也持有一个整形变量(只是假设)，当调用enter时计数加1，调用leave时计数减1，当计数为0时会调用dispatch_group_notify并且dispatch_group_wait会停止等待； 3.dispatch_group_notify 当关联到dispatch_group_t上的dispatch_group_async任务执行完毕或者是关联在上面的dispatch_group_enter、dispatch_group_leave成对出现了。参数中的dispatch_block_t block会被提交到dispatch_queue_t queue中执行。 4.dispatch_group_wait 和dispatch_group_notify功能类似(多了一个dispatch_time_t参数可以设置超时时间)，在group上任务完成前，dispatch_group_wait会阻塞当前线程(所以不能放在主线程调用)一直等待；当group上任务完成，或者等待时间超过设置的超时时间会结束等待； 5……….. 1234567891011121314151617181920212223bashdispatch_queue_t dispatchQueue = dispatch_queue_create(&quot;icocos.queue.next&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_queue_t globalQueue = dispatch_get_global_queue(0, 0); dispatch_group_t dispatchGroup = dispatch_group_create(); dispatch_group_async(dispatchGroup, dispatchQueue, ^()&#123; dispatch_async(globalQueue, ^&#123; sleep(5); NSLog(@&quot;请求任务一完成&quot;); &#125;); &#125;); dispatch_group_async(dispatchGroup, dispatchQueue, ^()&#123; dispatch_async(globalQueue, ^&#123; sleep(8); NSLog(@&quot;请求任务二完成&quot;); &#125;); &#125;); dispatch_group_notify(dispatchGroup, dispatch_get_main_queue(), ^()&#123; NSLog(@&quot;notify：请求任务都完成了&quot;); &#125;);&#125; 线程同步 –阻塞任务（dispatch_barrier）：一个dispatch barrier 允许在一个并发队列中创建一个同步点。当在并发队列中遇到一个barrier, 他会延迟执行barrier的block,等待所有在barrier之前提交的blocks执行结束。 这时，barrier block自己开始执行。 之后， 队列继续正常的执行操作。 调用这个函数总是在barrier block被提交之后立即返回，不会等到block被执行。当barrier block到并发队列的最前端，他不会立即执行。相反，队列会等到所有当前正在执行的blocks结束执行。到这时，barrier才开始自己执行。所有在barrier block之后提交的blocks会等到barrier block结束之后才执行。 dispatch_barrier_async函数的作用 1.实现高效率的数据库访问和文件访问 2.避免数据竞争 1234567891011121314151617181920/* 创建并发队列 */dispatch_queue_t concurrentQueue = dispatch_queue_create("test.concurrent.queue", DISPATCH_QUEUE_CONCURRENT);/* 添加两个并发操作A和B，即A和B会并发执行 */dispatch_async(concurrentQueue, ^()&#123; NSLog(@"请求OperationA");&#125;);dispatch_async(concurrentQueue, ^()&#123; NSLog(@"请求OperationB");&#125;);/* 添加barrier障碍操作，会等待前面的并发操作结束，并暂时阻塞后面的并发操作直到其完成 */dispatch_barrier_async(concurrentQueue, ^()&#123; NSLog(@"请求OperationBarrier!");&#125;);/* 继续添加并发操作C和D，要等待barrier障碍操作结束才能开始 */dispatch_async(concurrentQueue, ^()&#123; NSLog(@"请求OperationC");&#125;);dispatch_async(concurrentQueue, ^()&#123; NSLog(@"请求OperationD");&#125;); 线程同步 – 信号量机制（dispatch_semaphore）： 信号量： 就是一种可用来控制访问资源的数量的标识，设定了一个信号量，在线程访问之前，加上信号量的处理，则可告知系统按照我们指定的信号量数量来执行多个线程。 其实，这有点类似锁机制了，只不过信号量都是系统帮助我们处理了，我们只需要在执行线程之前，设定一个信号量值，并且在使用时，加上信号量处理方法就行了。 信号量主要有3个函数创建信号量，参数：信号量的初值，如果小于0则会返回NULL dispatch_semaphore_create（信号量值） //等待降低信号量 dispatch_semaphore_wait（信号量，等待时间） //提高信号量 dispatch_semaphore_signal(信号量) 注意，正常的使用顺序是先降低然后再提高，这两个函数通常成对使用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758- (void)getToken&#123; //以上请求的设置忽略 NSURLSessionDataTask *task = [mySession dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; if (data) &#123; NSLog(@"get Token"); //拿到token，传给request请求做参数 [self request:token]; &#125;else&#123; NSLog(@"token error:%@",error.description); &#125; &#125;]; [task resume];&#125;- (void)request:(NSString *)params&#123; //请求的设置忽略 NSURLSessionDataTask *task = [mySession dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; if (data) &#123; NSLog(@"request success"); &#125;else&#123; NSLog(@"request error:%@----",error.description); &#125; &#125;]; [task resume];&#125;// 指定调用- (IBAction)buttonPress:(UIButton *)sender&#123; //创建一个并行队列 dispatch_queue_t queque = dispatch_queue_create("GoyakodCreated", DISPATCH_QUEUE_CONCURRENT); //异步执行 dispatch_async(queque, ^&#123; dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); [self getToken:semaphore]; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); [self request]; &#125;); NSLog(@"main thread");&#125;- (void)getToken:(dispatch_semaphore_t)semaphore&#123; //以上请求的设置忽略 NSURLSessionDataTask *task = [mySession dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; if (data) &#123; NSLog(@"get Token"); //成功拿到token，发送信号量: dispatch_semaphore_signal(semaphore); &#125;else&#123; NSLog(@"token error:%@",error.description); &#125; &#125;]; [task resume];&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS——请求依赖多种解决方案</tag>
        <tag>网络层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS(OC+cocos2dx)游戏APP磁盘空间爆增(文稿与数据)]]></title>
    <url>%2F2018%2F08%2F16%2FiOS-OC-cocos2dx-%E6%B8%B8%E6%88%8FAPP%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E7%88%86%E5%A2%9E-%E6%96%87%E7%A8%BF%E4%B8%8E%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[这段时间在开发公司的新产品二次元游戏(零下记忆)，由于接触coco2dx不久，很多东西还在摸索，也没少加班，所以都没有时间整理和发文了。 但是最近(从周一开始),发现了一个特别其他的Bug，App磁盘数据报增，幸好我手机是64G的，不然估计会爆炸！ 先来张爆图！ 这个产品是在Objective-C原生架构的基础上接入cocos2dx(C++)，所以导致部分文件或者类需要使用MRC模式。 我曾尝试过 使用模拟器针对不同时段操作，计算沙盒文件大小。 借助部门同事的越狱机导包寻找导致爆增的具体文件。 多次删除App，关闭可能存在问题原因的代码。 借助内存泄漏框架自动记录，内存变化与位置。 借助Xcode自带Instrument定点查找具体位置和代码。 通过Stack Overflow查询更多可能导致的原因。 经过一次次排查，和一个个问题的处理，最终通过多次杀进程，和运行测试，终于处理完成，不过还有待优化！ 下面是具体原因和流程。清理缓存：清理cocos2dx缓存：123456789CCAnimationCache::purgeSharedAnimationCache();CCSpriteFrameCache::purgeSharedSpriteFrameCache();CCTextureCache::purgeSharedTextureCache(); CCSpriteFrameCache::sharedSpriteFrameCache()-&gt;removeUnusedSpriteFrames();CCTextureCache::sharedTextureCache()-&gt;removeUnusedTextures();CCTextureCache::sharedTextureCache()-&gt;removeAllTextures();Director::getInstance()-&gt;getTextureCache()-&gt;removeAllTextures(); 清理运行磁盘，内存或者缓存123456789101112131415161718192021222324252627282930313233343536+ (void)clearAllCache &#123; [[SDImageCache sharedImageCache] clearMemory]; [[SDImageCache sharedImageCache] clearDiskOnCompletion:nil]; // 拿到cachePath路径的下一级目录的子文件夹 // contentsOfDirectoryAtPath:error:递归 // subpathsAtPath:不递归 NSArray *subpathArray = [fileManager contentsOfDirectoryAtPath:cachePath error:nil]; // 如果数组为空，说明没有缓存或者用户已经清理过，此时直接return if (subpathArray.count == 0) &#123;#ifdef DEBUG NSLog(@"cachePath缓存清理完成");#else #endif &#125; NSError *error = nil; NSString *filePath = nil; BOOL flag = NO; for (NSString *subpath in subpathArray) &#123; filePath = [cachePath stringByAppendingPathComponent:subpath]; if ([fileManager fileExistsAtPath:cachePath]) &#123; // 删除子文件夹 BOOL isRemoveSuccessed = [fileManager removeItemAtPath:filePath error:&amp;error]; if (isRemoveSuccessed) &#123; // 删除成功 flag = YES; &#125; &#125; &#125; if (NO == flag) &#123;#ifdef DEBUG NSLog(@"已经清理了所有可以访问的文件,不可访问的文件无法删除"); // 调试阶段才打印#else #endif &#125;&#125; 记忆中此处大概处理了1-3G 内存管理通过Stack Overflow和相应代码调试最后发现： 原来是把sprite和控件都retain了，需要手动release，才能释放图片。 所以我得找到对应的cocos2dx项目代码，对创建和操作的对象进行release操作，这里比较蛋疼，得一个个找！ 处理中遇到个问题： removeTexture执行release后，不管有没有被gl释放掉，都从列表里删除。 但是如果load进来的node被addChild到场景中，应该是不需要retain的，addChild会自动retain，这里不清楚，cocos2dx引擎设计者在load里加retain是为了什么， 这里所导致的问题，几乎是使用过程中内存暴涨 环境与配置(主要原因):通过多次测试发现沙盒文件中的temp中有一堆文件stack-logs.xxxxx.index 同时控制台也打印了一大堆看不懂也搜不到的内容 结合以上几点才初步猜测可能是因为配置环境的问题，查阅资料后发现这与Xcode设置有关,具体配置原因我也不记得了，印象中是当时配置接入cocos2dx的时候，遇到了一些问题，点过了一次，但是现在想想好像当时的操作并没有什么卵用！ Edit Scheme中Diagnostics有个logging分类，下面有个Malloc Stack选项，将勾选取消。 处理完后立刻验证了一下,重装App,多次执行杀进程和实际测试用，在tmp下并没有产生那个文件stack-logs.xxxxx.index,磁盘占用也处于稳定状态,再打开手机设置查看存储空间，也很正常。 以上文稿与数据的15.7中有13M多属于App下载的资源文件。 That’s all for today.]]></content>
      <categories>
        <category>iOS游戏</category>
      </categories>
      <tags>
        <tag>iOS(OC+cocos2dx)游戏APP磁盘空间爆增(文稿与数据)</tag>
        <tag>iOS游戏</tag>
        <tag>磁盘管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏引擎——cocos2dx入门]]></title>
    <url>%2F2018%2F08%2F09%2F%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94cocos2dx%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[简介 Cocos2d-x是一个开源的移动2D游戏框架，MIT许可证下发布的。这是一个C++ Cocos2d-iPhone项目的版本。Cocos2d-X发展的重点是围绕Cocos2d跨平台，Cocos2d-x提供的框架。手机游戏，可以写在C++或者Lua中，使用API是Cocos2d-iPhone完全兼容。Cocos2d-x项目可以很容易地建立和运行在iOS，Android，黑莓Blackberry等操作系统中。Cocos2d-x还支持Windows、Mac和Linux等桌面操作系统，因此，开发者编写的源代码很容易在桌面操作系统中编辑和调试。 cocos2dx 与 UNITY3D 一、区别: 1、COCOS2D开源,有文档支持,论坛资料庞杂博大；UNITY3D闭源,有强大的文档支持,论坛资料一样的庞杂博大。 2、COCOS2D免费；UNITY3D收费。 3、COCOS2D的跨平台,需要大量重写代码；UNITY3D的跨平台,程序员只需要选选按钮就淡定许多的搞定了。 二、拓展: 1、不同: COCOS2D拥有令人发指的可定制性；UNITY3D有一个专门为订制而写的类库。 2、相同: UNITY3D和 COCOS2D-X都是跨平台的游戏开发引擎。 特性 现代化的 C++ API 立足于 C++ 同时支持 JavaScript/Lua 作为开发语言 可以跨平台部署, 支持 iOS、Android、Windows、macOS 和 Linux 可以在 PC 端完成游戏的测试，最终发布到移动端 完善的游戏功能支持，包含精灵、动作、动画、粒子特效、场景转换、事件、文件 IO、数据持久化、骨骼动画、3D 家族成员 cocos2d是一个基于MIT协议的开源框架，用于构建游戏、应用程序和其他图形界面交互应用。可以让你在创建自己的多平台游戏时节省很多的时间。 Cocos2d-html5 ： Cocos2d-HTML5 是基于 HTML5 规范集的 Cocos2d引擎分支，具有跨平台的能力和强大的性能，是 Cocos2d 系列引擎随着互联网技术演进而产生的一个分支，该分支基于 HTML5 规范集，目标是可对游戏进行跨平台部署，Cocos2d-HTML5 采用 MIT 开源协议，设计上保持Cocos2d家族的传统架构，并可联合 Cocos2d-x JavaScript-binding 接口，最大程度地实现游戏代码在不同平台上的复用。 JSB ： Cocos2d-x JavaScript-binding 是使用 SpiderMonkey 引擎实现 C++ 接口到 JavaSciprt 的绑定方案，它可以使用 Js 快速开发游戏，以更简单的语法实现功能，并且能与 Cocos2D-HTML5 相互兼容，使同一套代码，运行两个平台，这是相比使用 Lua 实现的一个明显优势。 Cocos Studio ： Cocos Studio 是一套基于 Cocos2d-x 引擎的工具集，包括 UI编辑器，动画编辑器，场景编辑器和数据编辑器。 UI 编辑器和动画编辑器主要面向美术，而场景编辑器和数据编辑器则面向游戏策划，这四个工具合在一起构成了一套完整的游戏开发体系，帮助开发者进一步降低开发难度，提高开发效率，减少开发成本。 Cocos2d也拥有几个主要版本，包括Cocos2d-iPhone、Cocos2d-X，以及被社区普遍看好的Cocos2d-HTML5和JavaScript bindings for Cocos2d-X。 关于lua，c++，JS允许开发人员使用 C++、Javascript 及 Lua 三种语言来进行游戏开发。 支持所有常见平台，包括 iOS、Android、Windows、macOS、Linux。 运行效率： Lua 的性能在各种测试里都比 JavaScript 快不少。而移动设备上存在不支持 JIT 的情况（未越狱的 iOS 设备），Lua 对比 JavaScript 的性能优势就更明显。 安全性： 现在 cocos2d-x 使用 LuaJIT 来执行 Lua，所以可以把 Lua 代码编译为字节码再打包到游戏里。由于 LuaJIT 的字节码是高度优化过的，所以目前还没有反编译工具。而 JS 虽然也可以用字节码，但从目前的情况看还达不到 LuaJIT 的安全性。 与 C/C++ 的交互： Lua 原本就是作为嵌入式语言来设计的，所以天然和 C/C++ 很容易交互。JS 这方面是个劣势。 与 Java/Objective-C 的交互： 不管是 quick-cocos2d-x 里提供的 luaoc/luaj 模块，还是 wax, luajava 这些开源项目，都让我们可以绕过 C/C++ 层实现 Lua 和 Java/Objc 的交互。这个优势在游戏发行阶段，集成各种第三方 SDK 时绝对会节约巨量时间！！！ 游戏是非常消耗资源的每时每刻都要大量的计算， 假如有个方法 让 C语言来实现 并且把它完成的时间定义为 1个单位 的时间 那么同样的数据结构的方法在其他语言中 java 需要 8个单位 lua需要30个单位 python需要200个单位 php需要462个单位 javascript需要621个单位 所以在需要大量计算的环节，代码的结构时间复杂度比较高的 情况下用 C++（肯没直接用C快，但一定比java快）来写， 现在的CPU计算能力都还是蛮高的，所以没必要完全用C++ ，用一些其他的语言开发速度可以大大加快。 个人总结 项目不需要热更新的时候用c++ lua，c++都可以用的时候c++更熟悉的用c++ c++效率比lua高 lua项目的底层框架还是要c++搭比较好 c++老司机转其他语言比较轻松。 最终使用那种方式还是需要结合个人，语言，需求，性能综合考虑 当然，cocos2d-x 目前明显是在主推 JS 的解决方案，因为 JS 可以跨越移动设备、桌面的界限，实现一套程序跑任意平台。不过我个人认为以当前 HTML5 的发展情况，对于要强调体验的游戏来说，HTML5 还要一些时间。 网友评价：前面提到 JS 更容易面向对象，我想可能是因为大家对 Lua 还不够了解造成的错觉。实际上，Lua 和 JS 实现面向对象的机制几乎是一样的。JS 基于 prototype，Lua 基于 metatable，在我看来仅仅是名字不同而已。 从目前的市场情况来说，Lua 明显是更理性的选择：成熟、安全性高、众多大作采用。 推荐 官方文档：http://www.cocos2d-x.org/docs/cocos2d-x/zh/about/learn.html OC/Swift - C++交互与混编:http://edu.51cto.com/center/course/lesson/index?id=57316 入门实战-飞机大战游戏：http://www.maiziedu.com/course/662-9914/]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>游戏</tag>
        <tag>游戏引擎——cocos2dx入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏开发——各大游戏引擎介绍和对比]]></title>
    <url>%2F2018%2F07%2F07%2F%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%90%84%E5%A4%A7%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[游戏引擎是指一些已编写好的可编辑电脑游戏系统或者一些交互式实时图像应用程序的核心组件。这些系统为游戏设计者提供各种编写游戏所需的各种工具，其目的在于让游戏设计者能容易和快速地做出游戏程式而不用由零开始。大部分都支持多种操作平台，如Linux、Mac OS X、微软Windows。游戏引擎包含以下系统：渲染引擎（即“渲染器”，含二维图像引擎和三维图像引擎）、物理引擎、碰撞检测系统、音效、脚本引擎、电脑动画、人工智能、网络引擎以及场景管理。 cocos2d Cocos 2d是一个基于MIT协议的开源框架，用于构建游戏、应用程序和其他图形界面交互应用。可以让你在创建自己的多平台游戏时节省很多的时间。 Cocos2D拥有几个主要版本，包括Cocos2D-iPhone、Cocos2d-x，以及被社区普遍看好的Cocos2D-HTML5和javaScript bindings for Cocos2D-X，拥有非常优秀的编辑器。很多策划认为Cocos 2D对于新入行的开发者来说不仅具备大量功能，而且非常容易上手。虽然该引擎比较复杂，但值得一提的是其功能和灵活性。 优点：强大而且灵活;理论上来讲，你可以为自己的游戏加入所有的iOS功能;提供成熟的框架和多种工具;开源、免费，社区支持强大。 缺点：和同类引擎相比比较复杂;学习门槛相对较高;特别适合Mac或者iOS平台，不过并不是跨平台引擎。 unityUnity 3D是一个用于创建诸如三维视频游戏、建筑可视化、实时三维动画等类型互动内容的综合型创作工具，由Unity Technologies开发，是一个全面整合的专业游戏引擎。 对游戏开发者们来说，Unity 3D是一个真正可以负担得起的引擎，具有其他引擎难以匹敌的用户量。更重要的是，你只需要付费一次，而且，不管你的游戏如何成功，都不用担心Unity会分走你的收入。这对于很多开发商来说当然是非常具有吸引力的，尤其是初创公司和新入行的开发者们。 优点：业内最 具竞争力的授 权条款;易于使用，且兼容所有游戏平台;开发者社区支持强大;学习门槛非常低;开发商使用率最 高。 缺点：工具数量有限，所以开发商必须给自己创作工具;做复杂和多样化的效果比较耗时。 虚幻虚幻引擎的设计目的非常明确，每个方面都具有较高的易用性，尤其侧重于数据生成和程序编写的方面，这样，美工只需要程序员的很少量的协助，就能尽可能多地开发游戏的数据资源，并且这个过程是在完全可视化环境中完成的，实际操作非常便利。 数年以来，虚幻引擎一直是做高端EA游戏最 受欢迎的引擎。《战争机器》、《蝙蝠侠：阿卡汉姆疯人院》(Batman:ArkhamAsylum)、《质量效应》以及其他很多著名作品都是出自该引擎之手。 优点：开发商使用率较高，开发商社区强烈支持，有视频教程和大量资源。拥有最 佳的引擎支持，随时更新其他引擎平台的功能，增加新的工具，且管理相对容易，工具简单易用。很多系统都兼容，如：iOS、Android、Linux、Mac、Windows等和大多数游戏主机。 缺点：授 权条款只适合大作，商业授 权价格为99美元，在游戏收入超过5万美元之后，必须支付25%的分成。也有一些开发者抱怨有些工具不好用，学习门槛较高。 layaboxLayabox 有两个框架； LayaFlash是面向Flash AS3程序员的，可以用AS3语言直接开发H5产品，也可以把AS3源码的项目发布成H5项目。主要用于开发大游戏。 另一个框架是LayaAir支持三种语言开发（AS3、TypeScript、JavaScript）这是全新的开发框架，与Flash没关系了，是一个超牛的全新H5引擎，支持重度、中度、轻度的游戏开发，支持应用、网站的开发。 libgdxLibgdx 是一个跨平台可视化游戏开发框架。它支持Windows, Linux, Mac OS X, Android, Blackberry, iOS, HTML5 平台。 Libgdx 可以让你写一次代码不需要修改就可以部署到多个平台。你在电脑环境中可以很快的编译， 通过编译HTML5而不是等待运行在设备上。你可以使用所有Java提供的工具。因为他是运行在JVM, 你也可以随意使用其他好的非Java语言(Kotlin, Scala, Clojure等) 必要时, libgdx 可以不用Java编写， 使用native代码调用以达到最好的性能。所有的函数都有Java的API, 所以你不必要担心所有平台的跨平台native代码调用。很多地方的libgdx运行平台问题已经被发现， 所以你不需要处理他们。 Libgdx使用一个框架而不是一个引擎， 它不是所有的问题都可以解决。反而， 我们给你一个强大的抽象概念， 让你选择怎样写游戏跟应用。 love2dLove2D是一个开源的， 跨平台的2D游戏引擎。使用纯Lua脚本来进行游戏开发。目前支持的平台有Windows，Mac OS，Linux。另外在社区里，还有Love2D-android版本，而且也有进军IOS的计划。 这个游戏引擎在国内听说或者是使用的人可能不是很多，但是在国外还是有很大一部分的使用人群的。 白鹭ergtEgret是TypeScript语言开发游戏用的。是围住神经猫这个游戏把引擎推火了，也一直致力于小游戏的开发。目前在小游戏的研发市场上品牌作的不错。 更多对比：https://blog.csdn.net/enweitech/article/details/72820183 区别与对比：Cocos 2D &amp; unity https://www.cnblogs.com/clj2005/articles/3558914.html http://www.benmutou.com/archives/2388 百科推荐著名引擎 著名的MMOG专用商业引擎有： EA DICE的寒霜引擎、寒霜2引擎、寒霜3引擎。（战地系列游戏作品就是采用此引擎） BigWorld公司的BigWorld引擎。 Emergent公司的Gamebryo引擎。 EPIC公司的虚幻引擎、虚幻2引擎、虚幻3引擎、虚幻4引擎。 Crytek公司的Cry Engine 1引擎、Cry Engine 2引擎和Cry Engine 3引擎。（孤岛危机系列、战争前线等） Garage Games公司的Torque 3D引擎。 Hero公司的Hero Engine引擎。 北京目标软件公司的OverMax引擎。 Quantumas引擎(国人开发) Valve公司的Source Engine（起源引擎） Infinity Ward工作室的IW 引擎。（其中有IW 2.0、IW 3.0、IW 4.0、IW 5.0版本，著名的使命召唤系列游戏作品就是采用此引擎，中文译名无尽引擎） 幻影游戏引擎（国产，支持PC、IOS、Android的3D和2D游戏开发，也可以支持Web2D），支持程序语言：C++、Lua、VB、C#、易语言、Objective C、javascript。 搜狐畅游公司的黑火引擎 完美世界公司的Athena引擎 Unity Technologies开发的Unity3D引擎 日本SiliconStudio公司的Orochi 4(Mizuchi图形引擎)(square-enix公司Gunslinger Stratos系列使用的引擎) [3] 日本Square enix公司的Luminous(夜光引擎)（最终幻想15使用的引擎） [4] 克罗地亚Croteam公司的Serious引擎（代表游戏为《英雄萨姆》、《英雄萨姆：第二次遭遇》），Serious II引擎（代表游戏为《英雄萨姆2》） 世界知名游戏引擎排名]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>游戏开发——各大游戏引擎介绍和对比</tag>
        <tag>游戏引擎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识游戏——cocos2dx初探]]></title>
    <url>%2F2018%2F06%2F15%2F%E5%88%9D%E8%AF%86%E6%B8%B8%E6%88%8F%E2%80%94%E2%80%94cocos2dx%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[前端时间一直在忙项目，也提到了关于是一个AVG游戏项目，近期由于最新需求，需要开发iOS 游戏，之前做了这么久一直没有感觉到真正游戏或者游戏开发的存在，这一次，好像真的要步入游戏开发了。 所以整理了一下。 具体概念和基本使用就不做介绍了，因为那些都太枯燥了，这里先说说整个环境搭建（以Mac为例），然后根据实际开发整理一些有意义的东西 先来看看官方http://docs.cocos.com/cocos2d-x/manual/zh/ 搭建开发环境 - iOS工具准备Cocos2d-x v3.17，下载后解压，下载参见：Cocos官网页面:http://www.cocos.com/download Xcode 9 下载后安装，下载参见：Apple官网页面;https://developer.apple.com/download/more/或者前往App Store下载 配置步骤： 打开 cocos2d-x-3.17/build/cocos2d_tests.xcodeproj 在 Xcode 顶部工具栏选择 cpp-tests iOS，iPhone 7 Plus，点击运行，项目将自动编译运行，效果如图： 如何调试(Debug) 点击代码行左侧的空白，设置断点 运行 cpp-tests 操作 App 触发断点，IDE 将卡在断点处，视图会自动变化，左侧导航栏可以查看运行堆栈，底部窗口可以查看变量的值： 这里严格来说，其实不算是环境搭建，而是下载引擎，运行官方demo而已，那么下面我们开始简单的搭建一个实际项目，并后续从零开始做一个真正的游戏 实际开发配置步骤：登录Cocos2d-x 的官网 http://www.cocos2d-x.org 点击download 下载最新的版本 点击超链接，将会下载得到一个Cocos2d-x-3.17.zip 压缩包 将下载的压缩包进行解压，打开得到的文件夹，其结构目录如下 build :多平台下的架构文件存放的目录 cocos 框架核心目录 里面存放了Cocos2d-x的核心代码。 docs：文档目录 可以使用该目录下的doxygen.config 文件创建离线文档 extensions:扩展目录 存放了一些官方的扩展 包括更多图形用户界面的控制功能 网络访问 CocosBuilder 等 external：存放扩展需要用到的物理引擎 包括box2d和chipmunk licenses: cocos2d依赖很多开源项目，所有的授权许可文件都在这个目录 plugin:plugin-x 项目目录，plugin -x 是一个可以快速接入第三方idk的框架 templates：该目录包括在不同集成环境及不同平台中创建Cocos2d-x 新项目的模板 test：测试项目 这是我们最开始用到的文件 在 cpp-tests 项目中包含所有类的用法 lua 和js 样本也在这个目录 tools： 需要用到的工具 Cocos2d-console 目录中包含了创建Cocos2d-x项目的脚本 可以针对不同的平台进行开发环境的搭建 同时 还包括将c++绑定至lua 及JavaScript 的脚本文件 Cocos2d-x的安装和配置Cocos2d-x 从2.1.4 版 之后已经不再支持使用模板来生成项目 而是使用官方提供的python 直接创建项目 也就是说Cocos2d-x 不能安装到Xcode上面，不能使用Xcode的Cocos2d-x模板一步一步的生成项目，只能使用Xcode来打开已经创建好的项目 创建项目的步骤如下： 打开终端 进入Cocos2d-x3.14 目录执行./setup.py 运行该文件用来 配置系统的一些环境变量 打开终端 执行Cocos new HelloCpp -p org.cocos2dx -l cpp -d codes 如果一切正常 则项目创建成功 关闭终端 再次进入Cocos2d-3.14目录这时候 会发现新建的codes目录 进入该目录发现新建的HelloCpp项目 进入proj.ios_mac 双击HelloCPP.xcodeproj 文件 使用快捷键（command+run）运行程序 就可以在iOS模拟器上看到经典的hello world 画面]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>cocos2dx</tag>
        <tag>游戏</tag>
        <tag>初识游戏——cocos2dx初探</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——开发者中心更新手机号码]]></title>
    <url>%2F2018%2F04%2F26%2FiOS%E2%80%94%E2%80%94%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%AD%E5%BF%83%E6%9B%B4%E6%96%B0%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81%2F</url>
    <content type="text"><![CDATA[The Apple Developer 开发者中心更新手机号码 Program License Agreement has been updated……. The Apple Developer 开发者中心更新手机号码 Program License Agreement has been updated. 从而导致：1. 无法提交新APP 2. 无法编辑证书 从而造成无法继续做任何App更新，与证书相关的操作。 于是开始联系苹果技术客服（400 670 1855），但是在天朝开发者的数量你懂的，于是，不管三七二十几，拨通了放一边不管，因为我打过不下5次客服，排队时间从来没有少于半个小时了。 …… 等了近两个小时候，既然通了，叙事描述了一番，让我根据他们的说明提交对应的信息和问题的描述，然后让我们等2-3个工作日，当时我就闹过了，但是也没有办法，谁让人家是爸爸呢！ 于是在等待苹果消息的时候，不定时的进入后台刷新查看状态，同事在寻求各种大神和好友的帮助。 最后在一个群里看到了一个比较直接的解决方案，当然也比较变态，这一切都都应该是苹果的锅。具体方案是这样的：1、在修改手机号的页面，将COUNTRY / REGION一栏的国家从中国改成香港（Hong Kong） 2、修改地区会提示你修改付款信息（随便瞎填一下就行了，修改后记得点保存） 3、和原来的步骤一样，在REACHABLE AT（改手机号旁）处，点击Add More..添加手机号（如果之前添加了，建议删除重新添加） 这个时候，就可以去登录开发者中心了，如果前面几步操作无误，就不会再提示让修改手机号了，然后点击同意协议就行了！ 最后别忘了把地区改回中国！ 网上有小伙伴给出了具体原因： 因为中国的iCloud数据转到中国,更新后数据在中国保存,开发中心获取不到导致的。 当然，还有一些小伙伴也有其他的方案，由于我们已经搞定了，所以就没有尝试，如果感兴趣可以试试！ 期间如果具体遇到了问题，我相信作为一个合格的开发的，难不到你，哈哈！ 好了，今天，我们就到这里 拜了个拜……]]></content>
      <categories>
        <category>Apple</category>
      </categories>
      <tags>
        <tag>iOS——开发者中心更新手机号码</tag>
        <tag>Apple</tag>
        <tag>开发者中心更新手机号码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——Xcode默认路径(Fastlane打包)]]></title>
    <url>%2F2018%2F04%2F24%2FiOS%E2%80%94%E2%80%94Xcode%E9%BB%98%E8%AE%A4%E8%B7%AF%E5%BE%84-Fastlane%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[最近在使用fastlane的时候，发现踩了不少坑，但是大部分由于时间的原因没能即使记录下来….. 最近在使用fastlane的时候，发现踩了不少坑，但是大部分由于时间的原因没能即使记录下来 这次简单的记录了一下前两天遇到的一个坑 事情是这样的，由于公司的一个测试机不知道被谁脑残似的点点了升级，于是系统直接到11.3，从而导致我的Xcode版本不支持对应真机的调试， 于是想着网上找对应的真机包，发现并没有找到，可能是我搜索能力不行，如果你有最新的，多多分享哦。 然后我就开始升级Xcode，但是发现升级Xcode又要升级系统，麻蛋。 于是就有了下面的一路升级系统升级Xcode 9.3编译一下，发现报错，报错的位置是WCDB，于是在官方群里问了一下，发现是WCDB的一个大坑，于是github有人提出了两种方式 在 Xcode 9.3 来 Swift 4.0.3 的方法，该方法可以临时解决 WCDB 的问题。 1. 下载并安装 Swift 4.0.3 的 toolchain: https://swift.org/builds/swift-4.0.3-release/xcode/swift-4.0.3-RELEASE/swift-4.0.3-RELEASE-osx.pkg 2. 在 Xcode 中选择 Preferences -&gt; Components -&gt; Toolchains，选择 Swift 4.0.3 Release 3. Clean 并重编你的 Xcode 工程 综合考虑之后，我暂时选择放弃的那台11.3的真机调试功能，只能通过扫描安装 于是又有了下面的一路 下载并安装Xcode 9.2编译项目….. 就在下班的时候，准备打包，没过几分钟就发现，变态的fastlane报错了（这是要闹哪一出，我都打算打完包直接闪人的） 具体错误如下：+-----------------------+---------+--------+ | Used plugins | +-----------------------+---------+--------+ | Plugin | Version | Action | +-----------------------+---------+--------+ | fastlane-plugin-pgyer | 0.2.1 | pgyer | +-----------------------+---------+--------+ [14:34:34]: ---------------------------------------- [14:34:34]: --- Step: Verifying fastlane version --- [14:34:34]: ---------------------------------------- [14:34:34]: Your fastlane version 2.89.0 matches the minimum requirement of 2.89.0 ✅ [14:34:34]: ------------------------------ [14:34:34]: --- Step: default_platform --- [14:34:34]: ------------------------------ [14:34:34]: Driving the lane &apos;ios development_build&apos; 🚀 [14:34:34]: 开始打development ipa [14:34:34]: ------------------------------ [14:34:34]: --- Step: get_build_number --- [14:34:34]: ------------------------------ 。。。。。。 [14:34:34]: fastlane finished with errors Looking for related GitHub issues on fastlane/fastlane... /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane_core/lib/fastlane_core/ui/interface.rb:145:in `shell_error!&apos;: [!] Exit status of command &apos;cd /Users/icocos/Desktop/\积\木\塔\科\技/\源\码/Fiction_iOS &amp;&amp; agvtool what-version -terse&apos; was 1 instead of 0. (FastlaneCore::Interface::FastlaneShellError) xcode-select: error: tool &apos;agvtool&apos; requires Xcode, but active developer directory &apos;/Library/Developer/CommandLineTools&apos; is a command line tools instance from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane_core/lib/fastlane_core/ui/ui.rb:17:in `method_missing&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/helper/sh_helper.rb:80:in `sh_control_output&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/helper/sh_helper.rb:12:in `sh&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/actions/get_build_number.rb:28:in `run&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/runner.rb:257:in `block (2 levels) in execute_action&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/actions/actions_helper.rb:50:in `execute_action&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/runner.rb:236:in `block in execute_action&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/runner.rb:231:in `chdir&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/runner.rb:231:in `execute_action&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/runner.rb:157:in `trigger_action_by_name&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/fast_file.rb:148:in `method_missing&apos; from Fastfile:10:in `updateProjectBuildNumber&apos; from Fastfile:45:in `block (2 levels) in parsing_binding&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/lane.rb:33:in `call&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/runner.rb:49:in `block in execute&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/runner.rb:45:in `chdir&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/runner.rb:45:in `execute&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/lane_manager.rb:57:in `cruise_lane&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/command_line_handler.rb:36:in `handle&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/commands_generator.rb:108:in `block (2 levels) in run&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1@global/gems/commander-fastlane-4.4.6/lib/commander/command.rb:178:in `call&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1@global/gems/commander-fastlane-4.4.6/lib/commander/command.rb:153:in `run&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1@global/gems/commander-fastlane-4.4.6/lib/commander/runner.rb:476:in `run_active_command&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane_core/lib/fastlane_core/ui/fastlane_runner.rb:75:in `run!&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1@global/gems/commander-fastlane-4.4.6/lib/commander/delegates.rb:15:in `run!&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/commands_generator.rb:333:in `run&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/commands_generator.rb:42:in `start&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/fastlane/lib/fastlane/cli_tools_distributor.rb:107:in `take_off&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/gems/fastlane-2.89.0/bin/fastlane:20:in `&lt;top (required)&gt;&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/bin/fastlane:23:in `load&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/bin/fastlane:23:in `&lt;main&gt;&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/bin/ruby_executable_hooks:15:in `eval&apos; from /Users/icocos/.rvm/gems/ruby-2.4.1/bin/ruby_executable_hooks:15:in `&lt;main&gt;&apos; xcode-select: error: tool &apos;agvtool&apos; requires Xcode, but active developer directory &apos;/Library/Developer/CommandLineTools&apos; is a command line tools instance xcode-select: error: tool &apos;xcodebuild&apos; requires Xcode, but active developer directory &apos;/Library/Deve 我尝试着杀进程，重启电脑，升级fastlane，然而并没有什么卵用 于是网上到处寻找答案：按照stack中的方案一，卸载fastlane重新安装，捣鼓了一会打算重新打包的时候，还是这个错，我就很奇怪了， 然后，我整理了一下思路 Xcode9.2直接升级到9.3，升级和运行fasrlane，再次安装9.2，于是有了两个Xcode，当时我就蒙圈了 就根据具体问题网上找到了一个重置默认Xcode的方式： sudo xcode-select --switch /Applications/Xcode\ 9.2.app/Contents/Developer 以上错误是因为安装了 xcode , 但并不是系统默认的位置, 所以可以使用以下命令把 xcode 的路径修改为你安装的位置即可 switch后面部分就是安装的 xcode 的自定义路径. 再次运行fastlane，发现成功了，当时我真想扇自己两耳光. 这问题貌似并没有撒难度，只是当时急着上线，有点脑残了，耗费了我将近4个小时，然后悄悄的回家了， 到家已是2点多……]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS——Xcode默认路径(Fastlane打包)</tag>
        <tag>Xcode默认路径（Fastlane打包的尴尬）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——3-rf一把无形的双刃剑]]></title>
    <url>%2F2018%2F04%2F20%2FiOS%E2%80%94%E2%80%943-rf%E4%B8%80%E6%8A%8A%E6%97%A0%E5%BD%A2%E7%9A%84%E5%8F%8C%E5%88%83%E5%89%91%2F</url>
    <content type="text"><![CDATA[今天我就遇到一个奇葩的问题，上一次编译并打包成功和这一次报错之间就一个上厕所的时间….. 大部分情况下，在项目报错的时候 很多人会选择clean再次编译 退出xcode重新编译 清楚drivedata重新编译 重启电脑重新编译 今天我就遇到一个奇葩的问题，上一次编译并打包成功和这一次报错之间就一个上厕所的时间。 具体错误ld: file too small (length=0) file &apos;/Users/icocos/Library/Developer/Xcode/DerivedData/Fiction_iOS-ccljhnehuyrphfbjlldfaqmstvub/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/RxSwift.build/Objects-normal/arm64/Just.o&apos; for architecture arm64 clang: error: linker command failed with exit code 1 (use -v to see invocation) 以上错误来自RXSwift。 查看git仓库，但是一句代码也没改，连一个空格都没有动 于是我就按照上面的走了一遍，发现并没有什么卵用,于是我在想:最后在一个群里有位大佬给了一个方案： rm -rf $HOME/Library/Developer/Xcode/DerivedData/* rm -rf $HOME/Library/Caches/com.apple.dt.Xcode/* rm -rf &quot;$(getconf DARWIN_USER_CACHE_DIR)/org.llvm.clang/ModuleCache&quot; 既然真的成功了。我们暂且把它叫做3rf。 关于rf这里有一个圈内的笑话：]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS——3-rf一把无形的双刃剑</tag>
        <tag>iOS</tag>
        <tag>3-rf一把无形的双刃剑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——奇葩需求QQ号与QQ群添加与跳转]]></title>
    <url>%2F2018%2F04%2F18%2FiOS%E2%80%94%E2%80%94%E5%A5%87%E8%91%A9%E9%9C%80%E6%B1%82QQ%E5%8F%B7%E4%B8%8EQQ%E7%BE%A4%E6%B7%BB%E5%8A%A0%E4%B8%8E%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[最近在做一个新的二次元游戏App，说真的第一次做游戏一开始有点压力，但是后面了解到用到的技术其实跟游戏没有太多关系，就巴拉巴拉的开始写了，但是由于只有一个人，项目赶着上线，再加上之前需求的不明确和中途的调整，导致期间也浪费了不少时间，最近在实现最后一个功能的时候遇到了点问题，一开始是我想的太复杂了，后面群里一问，网上一了解，发现：MMP，这么简单，说多了都是尿，于是记录了这一切…….. 前言 本文的起因： 新项目，一个人纯swift开发，有个小功能第一次遇到，就是在用户中心有一行显示（群号+点击加群）文案，点击这一行拉起QQ App，如果QQ APP所登录的QQ已经加入了QQ号就直接到群聊页面，如果没有就跳到加群页面，可以点击申请加群。 注意： 这里其实是打开QQ后，使用QQ来去打开了一个网页。下面上代码： 一下是朋友提供的OC代码- (NSURL*)getQQQunUrl { NSString *qq_number = @&quot;??&quot; NSString* urlStr = [NSString stringWithFormat:@&quot;mqqapi://card/show_pslcard?src_type=internal&amp;version=1&amp;uin=%@&amp;key=%@&amp;card_type=group&amp;source=external&quot;, qq_number, @&quot;44a6e01f2dab126f87ecd2ec7b7e66ae259b30535fd0c2c25776271e8c0ac08f&quot;]; return [NSURL URLWithString:urlStr]; } 调用方式：NSURL* url = [self getQQqunUrl]; if ([[UIApplication sharedApplication] canOpenURL:url]) { [[UIApplication sharedApplication] openURL:url]; } 这是我最终Swift的实现方式func getQQQunUrl() -&gt; String { let qq_number = &quot;??&quot; let url_str = &quot;mqqapi://card/show_pslcard?src_type=internal&amp;version=1&amp;uin=\(qq_number)&amp;key=44a6e01f2dab126f87ecd2ec7b7e66ae259b30535fd0c2c25776271e8c0ac08f&amp;card_type=group&amp;source=external&quot; return url_str } 调用方式：let urlString = self.getQQQunUrl() if let url = URL(string: urlString) { //根据iOS系统版本，分别处理 if #available(iOS 10, *) { UIApplication.shared.open(url, options: [:], completionHandler: { (success) in }) } else { UIApplication.shared.openURL(url) } } 只要替换以上QQ好就可以，看着代码是不是很简单，算了不说了，我都想静一静…… 来看看效果图： 加群之前的效果 加群之后的效果 QQ号调整最近又有一个新的需求，由于需求比较相似，于是我直接在这里追加了。 需要处理QQ号的跳转，点击直接打开QQ调用网页版加号或者聊天页面 其实功能并没有任何难度在，其实寻找对应的链接，替换内部信息就可以。 一下只提供OC和Swift的关键代码： OC的实现方式//qqNumber就是你要打开的QQ号码， 也就是你的客服号码。 NSString *qqNumber=@&quot;QQ号&quot;; if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;mqq://&quot;]]) { UIWebView *webView = [[UIWebView alloc] initWithFrame:CGRectZero]; NSURL * url=[NSURL URLWithString:[NSString stringWithFormat:@&quot;mqq://im/chat?chat_type=wpa&amp;uin=%@&amp;version=1&amp;src_type=web&quot;,qqNumber]]; NSURLRequest *request = [NSURLRequest requestWithURL:url]; webView.delegate = self; [webView loadRequest:request]; [self.view addSubview:webView]; } Swift的实现方式// 打开Url class func openOuterUrl(_ url: String) { if let url = URL(string: url) { //根据iOS系统版本，分别处理 if UIApplication.shared.canOpenURL(url) { //根据iOS系统版本，分别处理 if #available(iOS 10, *) { UIApplication.shared.open(url, options: [:], completionHandler: { (success) in }) } else { UIApplication.shared.openURL(url) } } } } class func getQQUrl() -&gt; String { let url_str = &quot;mqq://im/chat?chat_type=wpa&amp;uin=\(self.getQQ())&amp;version=1&amp;src_type=web&quot; return url_str } 参考链接iOS调用QQ客户端,发起临时会话IOS APP中打开指定qq聊天界面]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS——奇葩需求QQ号与QQ群添加与跳转</tag>
        <tag>QQ号与QQ群添加与调整功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——重整iOS技术（Fastlane完整打包流程）]]></title>
    <url>%2F2018%2F03%2F09%2FiOS%E2%80%94%E2%80%94%E9%87%8D%E6%95%B4iOS%E6%8A%80%E6%9C%AF%EF%BC%88Fastlane%E5%AE%8C%E6%95%B4%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[自从去年中旬电脑被我整挂了之后，大部分插件和脚本配置都失效了，重新安装也试了好几次，最近上班要上线了，不得不重新整理和配置一下，还好没有遇到什么坑…… 前言 项目即将进入阶段，每次都要点击那么多，频繁的打包脑子都要晕了，习惯了之前一行命令就搞定的我，只能花一个晚上加班整回之前的Fastlane。 本文采用的方案是：Fastlane + 蒲公英 + ……。 关于具体发布状态可以在这里（app-store, package, ad-hoc, enterprise, development）改，当然后面会结合App store发布最近本文内容，同时支持jenkins或者其他持续集成系统. Fastlane安装Fastlane是一套使用Ruby写的自动化工具集，用于iOS和Android的自动化打包、发布等工作，可以节省大量的时间。 安装过程如下： 1.检查Ruby版本，需要2.0及以上版本。在终端输入以下命令确认：ruby -v 需要注意的是需要将gem的source改为https://gems.ruby-china.org/。如何检查?在终端输入以下命令: gem sources 结果应为： *** CURRENT SOURCES *** https://gems.ruby-china.org/ 2.检查Xcode命令行工具是否安装。在终端输入以下命令：xcode-select --install 如果没有安装会进行安装。如果已经安装了则会提示： xcode-select: error: command line tools are already installed, use &quot;Software Update&quot; to install updates 3.安装Fastlanesudo gem install fastlane --verbose 如果出现以下错误： ERROR: While executing gem ... (Errno::EPERM) Operation not permitted - /usr/bin/rougify 则输入以下命令： sudo gem install -n /usr/local/bin fastlane 4.检查Fastlane是否正确安装。输入以下命令：fastlane --version 可以看到Fastlane版本信息，我的是2.85.0。 蒲公英的Fastlane插件安装打开终端，进入你的项目工程的根目录，输入以下命令： fastlane add_plugin pgyer 出现 Plugin &apos;fastlane-plugin-pgyer&apos; was added to &apos;./fastlane/Pluginfile&apos; It looks like fastlane plugins are not yet set up for this project. fastlane will create a new Gemfile at path &apos;Gemfile&apos; This change is necessary for fastlane plugins to work Should fastlane modify the Gemfile at path &apos;Gemfile&apos; for you? (y/n) 输入y按回车，出现 Installing plugin dependencies... Successfully installed plugins 便是安装成功了。 Fastlane配置1.打开终端，进入你的项目工程的根目录，输入以下命令：fastlane init 中间会让你输入苹果开发者账号的账号和密码，之后会在你项目工程的目录下生成一个fastlane文件夹，里面有Fastlane的配置文件，一个是Appfile文件，一个是Fastfile文件(如果要上传AppStore的话还有Deliverfile文件)。Appfile保存苹果开发者的相关信息、项目的相关信息等。Fastfile是运行脚本。 2.编辑Fastfile文件有时候一天需要打好几个包，为了区分，我们这里实现一个递增build号的功能。 (1)修改项目工程配置 修改Build Settings中的Versioning配置，Current Project Version随便填一个，Versioning System选择Apple Generic。 修改Info.plist File路径 (2)定义一个递增build号的函数，添加到Fastfile中def updateProjectBuildNumber currentTime = Time.new.strftime(&quot;%Y%m%d&quot;) build = get_build_number() if build.include?&quot;#{currentTime}.&quot; # =&gt; 为当天版本 计算迭代版本号 lastStr = build[build.length-2..build.length-1] lastNum = lastStr.to_i lastNum = lastNum + 1 lastStr = lastNum.to_s if lastNum &lt; 10 lastStr = lastStr.insert(0,&quot;0&quot;) end build = &quot;#{currentTime}.#{lastStr}&quot; else # =&gt; 非当天版本 build 号重置 build = &quot;#{currentTime}.01&quot; end puts(&quot;*************| 更新build #{build} |*************&quot;) # =&gt; 更改项目 build 号 increment_build_number( build_number: &quot;#{build}&quot; ) end 实现自动打包的完整Fastfile如下：可以直接拷贝修改# 定义fastlane版本号 ---- 修改 fastlane_version &quot;2.85.0&quot; # 定义打包平台 default_platform :ios def updateProjectBuildNumber currentTime = Time.new.strftime(&quot;%Y%m%d&quot;) build = get_build_number() if build.include?&quot;#{currentTime}.&quot; # =&gt; 为当天版本 计算迭代版本号 lastStr = build[build.length-2..build.length-1] lastNum = lastStr.to_i lastNum = lastNum + 1 lastStr = lastNum.to_s if lastNum &lt; 10 lastStr = lastStr.insert(0,&quot;0&quot;) end build = &quot;#{currentTime}.#{lastStr}&quot; else # =&gt; 非当天版本 build 号重置 build = &quot;#{currentTime}.01&quot; end puts(&quot;*************| 更新build #{build} |*************&quot;) # =&gt; 更改项目 build 号 increment_build_number( build_number: &quot;#{build}&quot; ) end #指定项目的scheme名称 ---- 修改 scheme=&quot;Fiction_iOS&quot; #蒲公英api_key和user_key ---- 修改 api_key=&quot;264c007c340157969a5e4da77637e60f&quot; user_key=&quot;3fdffa475f545097333473b980765ce1&quot; # 任务脚本 platform :ios do lane :development_build do|options| branch = options[:branch] puts &quot;开始打development ipa&quot; updateProjectBuildNumber #更改项目build号 # 开始打包 gym( #输出的ipa名称 output_name:&quot;#{scheme}_#{get_build_number()}&quot;, # 是否清空以前的编译信息 true：是 clean:true, # 指定打包方式，Release 或者 Debug configuration:&quot;Release&quot;, # 指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, development export_method:&quot;development&quot;, # 指定输出文件夹 output_directory:&quot;./fastlane/build&quot;, ) puts &quot;开始上传蒲公英&quot; # 开始上传蒲公英 pgyer(api_key: &quot;#{api_key}&quot;, user_key: &quot;#{user_key}&quot;) end end 注意：蒲公英的 api_key 和 user_key，开发者在自己账号下的 账号设置-API信息 中可以找到。打其它类型的包的方法与development类似，可自定义一个新的lane实现。 打包发布 在终端输入 fastlane development_build 便会进行自动打包并上传蒲公英了。 下面以执行流程 下面以执行结果 再来三张：入口，选项与结果]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS——重整iOS技术（Fastlane完整打包流程）</tag>
        <tag>重整iOS技术（Fastlane完整打包流程）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS游戏——关于马甲包与审核]]></title>
    <url>%2F2018%2F01%2F26%2FiOS%E6%B8%B8%E6%88%8F%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8E%E9%A9%AC%E7%94%B2%E5%8C%85%E4%B8%8E%E5%AE%A1%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[最近因为工作的原因，博客与公众号停了近一个月，网站也没有及时更新，实在抱歉！当初也不知道哪里来的冲动，脑子一热就离开了多年的城市@广州，去了一个鸟都不拉屎的地方@东莞（有点夸张了，老铁！）。本以为是一个新的开始，本以为可以进入一个新的台阶，没料想，半年之久就遍体鳞伤的回到的这个梦想最开始的地方，其中的心酸就不便多说了，当然也让我学到了不少东西，认识了不少朋友和牛人……今天我们来聊的话题是：甲包与审核…… 引言：离开东莞之后，来到广州的一家新公司（创业公司），开始从事小说类游戏开发，说来也惭愧，以前不怎么玩游戏，最多偶尔玩一下近期比较火的游戏，也没有从事过任何游戏开发的工作，有几次有朋友看到我的英文名@iCocos都会问我，你之前事做游戏开发吗？当时我也只能无奈的解释一下： iCocos的含义是 i+ Coco + s = 苹果 + Cocoa Touch + s 取这个名字的原因是，一直以来都是从事iOS开发，而且对这一块比较喜欢，也很喜欢苹果的产品！ 接触iOS行业也有近四年多，第一次有幸进入游戏这个行业，以前很多同行（非游戏行业）朋友，包括我，一听到游戏行业和游戏开发就觉得很可怕。工资高，加班多——这是是很多人对游戏的行业的最初认识。 背景 项目启动不久，就接到公司内部关于游戏马甲包的整个对接与提审任务，后续也会一直负责这个任务，因为之前是由总部的一个多年Android开发并且有过一些iOS开发经验的同事负责，后面我进来之后iOS这一块也就有我对接处理了，当然其实有很多，我处理的只是其中一两个！ 因为之前上架过不少次，当时还是挺有自信的，但是经过了解和沟通之后发现其实并不是相信中的那么简单。 我还专门花时间在网上，群里，各大论坛和学习网站寻找相关的资料，希望能有一点帮忙！ 其中提到最多的就是关于审核的问题，而且这边同事也说了关于马甲包的审核，通过与否基本上靠运气，而且概率非常低！ 关于马甲包那么说了这么多，什么是马甲包呢？ 马甲APP指的是为了让认识你的人猜不到,在常用的用户名外再注册的其他名字的APP。 马甲APP与真实APP的区别是什么?相同的地方是什么? 应用名称不一样。 关键词不一样。 应用图标。不一样。 应用截图。可以一样,也可以不一样,不做要求。 开屏图片。最好不一样。 其余的,比如主APP的一些品牌因素,最好去掉。因为马甲是要用来做坏事的,当然不能让人察觉咯。 以上出自网络：关于为什么要做马甲APP? 马甲APP怎么做? 马甲APP需要事项? 可以查看下面网络来源说明: 什么是马甲APP？怎么用马甲APP导流 对接事项一直以来我们做的APP一般都是这几种情况： 从零开始发一个完整的项目，然后提审上线。 接手一个已经开发到一部分或者已经上线的迭代项目，然后提审上线。 接手一个审核被拒，根据苹果给出的条款修改内容，然后提审上线 有一些外包或者项目和公司比较特殊的情况 但是正因为是马甲包，所以比较例外，例外在哪里呢？ 我拿不到源码，改不了App内部的任何界面与效果 我只要修改提审内容信息，然后向渠道回到进度 审核几率非常低，而且经常要切换Apple账户处理 …… 操作流程所以在处理之前我这边其实大概根据之前的上线经验整理了一下具体的对接事项和具体步骤： 使用（或新）apple账号 apple developer生成并下载证书（开发与发布） apple developer创建一个Bundle ID apple developer添加设备ID apple developer创建并下载描述文件（开发与发布） itnues connect 创建一个对应ID的app 将证书导入到电脑钥匙串，右健对应证书到处P12 修改IAP支付信息（这种一般都是根据ID，不然会很麻烦） 提交或者修改App Icon，宣传图，应用名称,关键词,应用图标,文件等App和公司信息 将证书，描述文件，P12（+密码）和ID对应版本号ipa提供商 让他们根据重新出包，并提供新的ipa包 确认测试通过，并确认提审信息后，重新上传ipa 提交审核（使用手动发布模式）…… 跟渠道那边及时反馈进度 审核没通过则重新以上步骤（不用换账号还好，换账号是最虐心的！！！） 审核通过则先完成以下两个步骤再点击：发布： 1、通知CP切换到正式区服 2、通知我这边让后端把支付方式切换到第三方支付 最后注意一点： 有时候可能会涉及到SDK的处理，这个就要母包提前就准备好，并且根据实际需求替换对应的参数就可以由于这里已经涉及到SDK开发与集成的基础，已经不属于马甲包的范围 提审信息以下是我提供的数据证书与App提审信息证书与ipa信息 App提审信息 其实整个流程差不多就这么写，这里就不每一步网上都有对应的教程，而且很简单（傻瓜式），当然在整个过程也有可能遇到不少问题，这个就要根据个人经验和学习能力临时应变处理了，所以我就不一一介绍了。 补充：Android流程与注意事项以下是Android同事整理的流程与步骤，可能比较简洁，但是实际并没有这么简单，毕竟Android不像苹果那么多限制，仅供参考，具体流程还是要根据实际执行 反编译 母包 并且 集成了渠道sdk的demo 打开两者 反编译之后的目录进行资源替换 lib里面的so文件 smali源码 res的图片、value里面的资源 manifest的activity、权限等等，包名后面添加对应渠道的名字 注意：(除了3011,其他的渠道包还要修改appId、clientKey、clientId) 在eclipse新建一个同包名的项目， 拷贝修改后母包的res覆盖进去， 修改冲突ids(游戏母包也要修改)， 编译得到apk， 再反编译这个apk， 拿到包名对应下面的R$xxxx.smail覆盖到母包里面 后面就是提交apk或者发包的内容了 最后 那么说了这么多，好像里面学不到什么东西，我为什么还要写这篇文章呢？ 其实一开始不太想写，也确实没有太多有用的东西，但是我觉得写了还是会有一些用的！ 太久没有写博客和公众号了，有点手痒（哈哈！！！） 个人习惯，几乎接触第一次的领域，项目，技术都会简单记录一下 方便后面打算或者会负责此类任务的人，了解整个流程，也欢迎交流学习 最后一点其实也是最重要的，拒审多次，需求有经验的前辈，指点迷津！]]></content>
      <categories>
        <category>Games</category>
      </categories>
      <tags>
        <tag>iOS游戏——关于马甲包与审核</tag>
        <tag>Games</tag>
        <tag>关于马甲包与审核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回顾与展望：梦想之路！]]></title>
    <url>%2F2017%2F12%2F31%2F%E5%9B%9E%E9%A1%BE%E4%B8%8E%E5%B1%95%E6%9C%9B%EF%BC%9A%E6%A2%A6%E6%83%B3%E4%B9%8B%E8%B7%AF%EF%BC%81%2F</url>
    <content type="text"><![CDATA[又是一次跨年之夜，又是一次年终总结。过去就一直有写总结回顾自己的成长，和往年一样，今年依旧是一个人坐在电脑旁，回顾着这一年中所经历与发生的一切！2017发生了很多事情，我也从中学到了很多，我开始更加地了解自己。…… 又是一次跨年之夜，又是一次年终总结。 过去就一直有写总结回顾自己的成长，和往年一样， 今年依旧是一个人坐在电脑旁，回顾着这一年中所经历与发生的一切！ 2017发生了很多事情，我也从中学到了很多，我开始更加地了解自己。 今年让我成长最大的就是： 发现了自己不足，不管是技术，还是人际关系。 脱离单身狗部队！ 实现了第一个小目标！ 下面我将从这一年来的各个方面总结一番，可能有点多，但是很有意义。 2017 @Swift2017@Swift——中国开发者大会（第二站） 会议时间：2017年5月13日-5月14日， 地址：深圳凯宾斯基酒店， 人数：400人 嘉宾：18人，其中8位国外，8位国内。 第一天所有外国嘉宾的演讲时间，第二天是国内大牛的演讲时间！ 记得第一站是去年在北京举行，当时项目太赶，就没有去，今年有幸能参加此次大会，并且收获真心不少。因此这里稍微整理了一下这两天最大的感触，和所学到的东西！ 2017 @Swift 中国开发者大会英语能力 交友 技术 英语为什么这里我把英语能力放在最前面，肯定是有原因的。 开会第一天所有都是老外，所有人都直接用英语讲，几乎听不太懂，所以导致很多东西根本没有听到重点与细节 会后交流，与提问，人家都能听懂，甚至都能提出自己的问题与观点，甚至还能通嘉宾进行更多更加升入的交流与讨论，而我却只能翻译或者发呆 技术的学习，几乎所有的最好，最新的技术资料都是从英文开始的，当你开始看中文翻译资料或者开始研究的时候，人家已经换了一种技术 后期的规划问题，出国旅游，出国发展（有点长远，当然也不是没有可能的），或者有机会接触外国朋友。 总结：针对程序员，哪怕只有一点基础的，技术这种东西都可以慢慢学，或者在实际项目中提高，如果你英文不好很多事情真的很难进行下去，除非你没有什么长远的目标或者没有自己个人的规划。 交友经过这次会议之后，看到了很多牛人，也认识了不少牛人之后才知道自己的渺小，才知道自己原来离期望中太远太远。 最有名的Swift框架RXSwift的作者 Google工程师 腾讯，美团，礼物说，阿里等一些非常厉害的架构师，同时也是技术迷 不少技术书籍的作者，其中有一位是我非常喜欢的巧哥@唐巧 不同公司的技术主管，开发人员，初入门的程序员 两天的会议中认识到了不少来自去全国各地参会者，也结下了不少好友！ 总结：永远不要觉得自己多牛逼，当你真的看到牛人之后你就会发现，其实自己真的很low，哪怕你做过再多项目，写过再多代码，不思考，不提升依然是个菜鸟。 技术主题就是Swift：iOS，后台肯定是重心 Swift实现AI，智能，机器学习，树莓派的结合，后期的转行。 实现属于自己的东西，小的方向比如小框架，静态或者动态库，大的话其中有人自己写了一个Swift转H5的编译器 App性能的提升，多线程，锁，MVVM, 自动化（测试，脚本） 包括开发，集成，测试，发布，维护需要有一套完成的规范与流程。 总之，程序员是一个需要时刻保持学习的职业，不学你就将被淘汰，不管学习技术，管理，社交，英语或者学习别人成功或失败的经验 未来的路还很长，希望一路上的坎坷能让我足够强大。 脱离单身狗部落今年终于不再被称之为单身狗了，对象是我高中同学，也是大学在处的女友， 因为毕业之后，发生了一些事情，也商量了一下，彼此奋斗。 于是一分开就是几年，再次相处之时，已经不再是年轻的的那种冲动， 更多的是成家立业，还有共同努力的梦想！ 于是，见了家长，并且预计两年左右成事……. 梦想之旅东莞梦想之路6月份的时候，一次偶然的计划接触到了一一五（广东一一五科技股份有限公司），并通过某些方式去了解更多关于此公司！ 开始是通过百度，知乎，微信或者QQ群，还有部分已经离职的朋友那里了解，一一五福利非常不错，而且挺大的，适合稳定发展！ 后面以一种尝试的形态投了一份简历，没想到既然真约我面试，而且面试了两轮以后，既然过了， 当时也确实想了很久，才最终决定离开这个梦想最开始的地方，去到了那个荒凉之地（个人半年来的体验） 其实，我原本可以留在广州，在一一五广州分部上班的，但是我也不记得当时是什么样的心态。 要说福利其实并没有说比广州要好多少，现在想想，又让我想起了那句话：to young to sinple 广州最好的两个基友一起吃饭的时候，说得最多的就是，让他不要去东莞，或者再多了解一下，但是并没有听进去什么！ 其实关于去东莞，去一一五，并没有什么后悔可言，即使没有长待，但是这半年我真的学到了很多东西。 不管在技术，学习能力，还是对一些大公司或者进大公司的看法，都有了一些重新的认识！ 同时结交了几个不错的朋友，并且结识了几位厉害的牛人！ 而且这几个月里面，通过各种努力，与计划，实现了我一直以来的第一个不算小的小目标！ 买了人生的第一辆爱车，虽然期间也发生了很多事情。 但是总算，不愧奋斗了这么多年！ 重回梦想之地从一一五离职之后，两天不到就收拾东西，回到了我一开始的梦想之地：广州！ 很多人都有问两个问题！ 为什么要离开一一五？那公司不是还不错吗？ 为什么不去深圳，却要来（去）广州？ 首先第一个问题，我就不方便详细回答了，也不想做过多的说明与评价，想了解更多关于115，可以百度或者私聊！ 那么至于我为什么要去广州？这里其实综合考虑了很久，可能个人看法或者对不同城市的体验不同！ 个人对广州确实怀有几分留恋，不管是因为他是我一开始的梦想之地，还是这几年来在广州所经历和所发生的一切， 我都觉得广州比较适合我，或者适合我未来的日子，适合我去实现自己的梦想！ 于是，我来广州后休息了几天，然后找了几天工作之后，拿到了一份理想的offer，可能只是短短的几个小时的聊天和了解。 但是我想说，既然选择了，我就相信这个公司，这个产品，这个团队。 我坚信，我，我们，我们的团队一定可以把这件事情做好，甚至以此去实现自己的梦想！ 未来的展望为了更加美好的2018 坚定一个最最基本的目标，而不是多大多宏伟，因为我觉得路需要一步一步走，太快了，你总会跌遍体鳞伤！ 说说我接下来的规划（我只谈短期3-5年）： 学习英语，不管是自学还是报班这都是现阶段挺重要的任务,同时也会长期的坚持下去。 深入Swift学习并进行项目实战优化，同时去了解Swift实现后台开发。 对PHP实战后台开发进一步的提升，完善个人网站个人博客，公众号。 iOS深挖：深入解析Max OS X &amp; iOS操作系统， 逆向工程 挖掘iOS音视频技术，并进行实战之旅！ 学习Python，了解机器学习等技术 学习RN基础，并进行实战开发与总结。 解决个人终身大事！ 梦想的城市，新的公司，新的项目，新的学习目标，新的梦想之旅！ 岁月不居，时节如流 我们共同走过的这一轮365天 或振奋人心，或略显伤感，或温暖如初 都是难忘的经历、记忆的珍藏……]]></content>
      <categories>
        <category>iCocos</category>
      </categories>
      <tags>
        <tag>iCocos</tag>
        <tag>回顾与展望：梦想之路！</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——Swift 4.0 适配实战总结（Xcode9）]]></title>
    <url>%2F2017%2F11%2F27%2FiOS%E2%80%94%E2%80%94Swift-4-0-%E9%80%82%E9%85%8D%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93%EF%BC%88Xcode9%EF%BC%89%2F</url>
    <content type="text"><![CDATA[iOS的小伙伴有没有觉得今年特别与众不同，是因为iPhone X出来了吗？是的，但是不仅仅是因为iPhone X的面世。 还有 Xcode 9无线调试，Swift 4升级适配，iPhone X适配，前面介绍了iPhone X适配总结，这里整理一下Swift 4.0升级与适配处理….. 前言ios开发中，适配越来越多了： Xcode适配 Swift升级适配 iPhone适配 其中Xcode没有太多东西可说，最重要的是iPhone适配，尤其是最新的iPhone X的适配。 iPhone X的适配之前有整理过一篇文章根据实际进行总结iPhone X适配实战总结， 这里主要介绍一下最新版Swift 4适配，并简单的说一下关于Xcode9特性与适配的问题 关于Swift新特性可以参考这里：http://www.jianshu.com/p/f35514ae9c1a Xcode 9 中同时集成了 Swift 3.2 和 Swift 4。 Swift 3.2 完全兼容 Swift 3.1，并会在过时的语法或函数上报告警告。 Swift 3.2 具有 Swift 4 的一些写法，但是性能不如 Swift 4。 Swift 3.2 和 Swift 4 可以混合编译，可以指定一部分模块用 Swift 3.2 编译，一部分用 Swift 4 编译。 迁移到 Swift 4 后能获得 Swift 4 所有的新特性，并且性能比 Swift 3.2 好。 当 Xcode 正式版发布后，现有的 Swift 代码可以直接升级到 Swift 3.2 而不用做任何改动，也可以后续再迁移到 Swift 4。或者直接迁移到 Swift 4 也可以，Swift 4 相比 Swift 3 的 API 变化还是不大的，很多第三方库都可以直接用 Swift 4 编译。Swift 1 到 2 和 Swift 2 到 3 的迁移的痛苦在 3 到 4 的迁移上已经大大改善了。 适配关于Swift 4适配中OC与Swift混编的坑比较多 查看当前版本 当前环境 Mac OS 10.12.6 XCode 9.1 当前Swift版本 3.2 一键升级这一特性非常6，印象中是swift2的时候出来的，具体时间也忘了。 然后勾选需要转换的 target （pod 引用不用勾选），Next 然后选择转换选项，Next 这两个选项是关于 swift 的 @objc 推断特性的，如果使用了 swift4.0 显式的 @objc 属性，能减少整体代码的大小。此时我们选 Minimize Inference（recommend） Minimize Inference（recommend） 根据静态推断，仅在需要的地方添加@objc属性。使用此选项后，需要按照Completing a Swift 4 minimize inference migration来完成转换。 Match Swift 3 Behavior 在编译器隐式推断的任何地方向代码添加一个@objc属性。这个选项不会改变你的二进制文件的大小，因为被Swift 3隐式推断在所有的地方都添加了显式的@objc属性。 修改错误+细节 完成上面之后，不会发现当前版本确实编程的Swift 4，但是好像跑步起来，到处报错。 对，毕竟是工具，不可能那么人性化，有些地方还是需要人工进行专门的适配 问题一：编译不通过如果项目中之前有class和extension，有些也给OC调用。在OC的代码中，我们通过#import “ModuleName-Swift.h”导入了Swift文件。如果是Swift3.2，一切都能正常工作，但是在Swift4.0上，编译通不过了。 如果你看了Swift 4特性的话应该知道 swift4.0 最大的特性之一就是 @objc 修饰符的变化了，它主要处理 OC 和 swift 混编时一些方法的调用以及属性获取问题，swift4.0 将在 swift3.x 中一些隐式类型推断的特性去除以后，需要我们来手动管理 @objc 修饰符。 具体解决方案： 一：在OC中调用一个Swift4.0类的方法（包括实例方法、static方法、class方法），你需要： 在该Swift4.0类前加上修饰符@objc 该Swift4.0类必须继承NSObject(否则，无法在前面加上修饰符@objc。当然，这里指的是普通类，@objc也是可以修饰UI开头的一系列UIKit框架下的UI类，只是修饰了这些类，不会产生什么影响) 在需要调用的方法前加上修饰符@objc 二：在OC中调用一个Swift4.0扩展的属性（包括实例属性、static属性、class属性）、方法（包括实例方法、static方法、class法），你有如下两种选择方式： 在该Swift4.0扩展前加上修饰符@objc(这样的话，该扩展下的所有的属性、方法，都可被OC调用)。 在需要的属性、方法前直接加上@objc修饰，也可达到目的。 注意一点：swift3 使用 #selector 指定的方法，只有当方法权限为 private 时需要加 @objc 修饰符，swift4.0 都要加 @objc 修饰符swift4.0 不再允许重载 extension 中的方法(包括instance、static、class方法) 问题二：运行时找不到属性如果你有一个Swift类继承自UIViewController，OC中调用或者操作这个类[viewController valueForKey:@”userName”]这一KVC方法去获取这个自定义UIViewController中的iconURL这一属性的属性值。 这种方式，编译时是无法检查出问题的。但是在运行时，问题就来了，找不到这个属性。因为这个属性没有暴露给OC来进行调用。 解决方案： 仅需要在自定义的UIViewController类中给需要暴露给OC调用的属性前加上@objc修饰符便可。如此一来，在OC代码中就能访问到这个属性。 (注意：这里可不像上面提到的extension一样，在这个已定义的UIViewController类前面加上@objc修饰符没有任何意义)。 编译警告 swift 中编译的警告 “#selector” 参数指定的实例方法必须使用 @objc 修饰，因为swift4中弃用了 @objc属性推断。 Objective-C 编译时警告 在 OC 中调用的 swift 方法，在 swift 中需要追加 @objc 修饰，swift4 废弃了该类型推断。 关于编译时也是直接增加@objc即可运行时警告运行时警告会打印在控制台： ***Swift runtime: ClassName.swift:lineInFile:columnInLine: entrypoint -[ClassName methodName] generated by implicit @objc inference is deprecated and will be removed in Swift 4; add explicit @objc to the declaration to emit the Objective-C entrypoint in Swift 4 and suppress this message 同样：想要修复运行时警告，需要添加 @objc 修饰符到对应的方法或者符号。 运行时警告的常见原因: 在 OC 中使用 SEL 在 swift 中使用了 perform methods 在 OC 中使用了 performSelector methods 使用了 @IBOutlet 或者 @IBAction NSAttributedStringKeyswift3.x public init(string str: String, attributes attrs: [AnyHashable : Any]? = nil) swift4.0 public init(string str: String, attributes attrs: [NSAttributedStringKey : Any]? = nil) String废弃charactersswift 3 var count = string.characters.count error &apos;characters&apos; is deprecated: Please use String or Substring directly swift 4 count = string.count 废弃addingPercentEscapesswift 3 var url = @&quot;http://www.example.com?username=姓名&quot; url = url.addingPercentEscapes(using: String.Encoding.utf8)! error &apos;addingPercentEscapes(using:)&apos; is unavailable: Use addingPercentEncoding(withAllowedCharacters:) instead, which always uses the recommended UTF-8 encoding, and which encodes for a specific URL component or subcomponent since each URL component or subcomponent has different rules for what characters are valid. swift 4 uri = uri.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlQueryAllowed)! 废弃substring(to:)swift 3 let index = tagText.index(tagText.startIndex, offsetBy: MPMultipleStyleListItemTagMaxLength) // 警告：&apos;substring(to:)&apos; is deprecated: Please use String slicing subscript with a &apos;partial range upto&apos; operator. let b = tagText.substring(to: index) Swift 4 let a = tagText.prefix(upTo: index) //a 的类型是 Substring，不是 String pod 引用添加以下内容到 Podfile。 post_install do |installer| installer.pods_project.targets.each do |target| if [&apos;WTCarouselFlowLayout&apos;, &apos;XSLRevenue&apos;, &apos;OHHTTPStubs/Swift&apos;].include? target.name target.build_configurations.each do |config| config.build_settings[&apos;SWIFT_VERSION&apos;] = &apos;3.2&apos; end end end end 系统方法UITableViewDelegate 协议方法名变更，没有错误提示： // swift3.x func tableView(_ tableView: UITableView, heightForRowAtIndexPath indexPath: IndexPath) -&gt; CGFloat // swift4.0 func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat Xcode 9关于Xcode 9适配其实并没有太多可说的地方，具体可参考苹果官方Session,但是我相信有一点是很多开发都非常喜欢的特性：无线调试 好处： 不用经常买线，不用担心接口或者插口坏了 不用担心忘记带线，无法调试 不用每次都插着才能调试（嘿，测试的MM，我给你装个最新的包，你接好了） … 要求 必须是Xcode9-beta以上 iPhone系统需iOS11以上 操作 在Xcode9-beta菜单的Window选项中选择Devices and Simulators 通过连接线让你的Mac识别到你的iPhone 在Devices and Simulators面板的左侧Connected菜单中选择连接的设备 在顶部的Devices和Simulators选项中选择Devices(这里其实默认就是选择了Devices)， 勾选Connect via network选项。 关于Xcode无线调试可参考下面地址 WWDC17惊喜——Xcode9无线调试https://icocos.github.io/2017/06/13/WWDC17%E6%83%8A%E5%96%9C%E2%80%94%E2%80%94Xcode9%E6%97%A0%E7%BA%BF%E8%B0%83%E8%AF%95/ 总结Swift3.2到Swift4.0的改变(只是我项目中遇到的)： Swift4.0中对于扩展的属性(包括实例属性、static属性、class属性)，都只能使用get方法，不可使用set方法 Swift4.0中不再允许复写扩展中的方法(包括实例方法、static方法、class方法) 编译期与运行时警告处理，添加 @objc 修饰符到对应的方法或者符号。 swift3使用#selector指定的方法，只有当方法权限为private时需要加@objc修饰符，现在全都要加@objc修饰符 字体方面的一些重命名 NSFontAttributeName重命名为NSAttributedStringKey.font、 NSForegroundColorAttributeName重命名为NSAttributedStringKey.foregroundColor、 NSStrikethroughStyleAttributeName重命名为NSAttributedStringKey.strikethroughStyle、 size(withAttributes:)方法重命名为size(withAttributes:)) … 官方参考资料 《Swift Language Programming (Swift 4.0)》 WWDC 2017 Session 402 《What’s New in Swift》 WWDC 2017 Session 212 《What’s New in Foundation》 WWDC 2017 Session 102 《Platforms State of the Union》]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS——Swift 4.0 适配实战总结（Xcode9）</tag>
        <tag>Swift 4.0 适配实战总结（Xcode9）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native搭建与初始化项目]]></title>
    <url>%2F2017%2F11%2F21%2FReact-Nativec%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[一年以前就听说React Native很火，很多移动端同学也都开始学习了，由于工作和各方面的原因，我一直与之无缘，最近有朋友说面试了几个公司，其中有两家公司要求会React Native，当时我也很奇怪，我咋地就一次没遇到过呢？而且公司对这方面都没有过要求，也没有这方面的开发，即使如此，但是还是激起了我去学习研究一下React Native的欲望，打算从零开始搞一个简单的App，总结并分析里面的一些实现，技术细节，还有关联技术…… 关于React Native是什么，有什么用，为什么会这么火这里就不多介绍了，相信你在网上随便一搜文章一大把。 这里主要介绍怎么从零开始入门React Native，并开发一个简单可用的App 准备工作 Mac OS X Xcode 8 HomeBrew:/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; Node.js: brew install nvm nvm install version/ nvm install stable nvm not found - export NVM_DIR=~/.nvm source $(brew –prefix nvm)/nvm.sh watchmain :监视文件修改、触发操作brew install watchman flow:语法检测器brew install flow React Nativenpm install -g react-native-cli 具体安装和下载步骤这里就不多说了，那属于准备工作，本文主要实战开发 安装结果 从源码一步一步解析它的实现原理 http://www.jianshu.com/p/5cc61ec04b39 创建项目执行下面开始创建项目 react-native init Hello 时间比较长，耐心等待 遇到的问题：中间可能会出现一些问题，其中提供一个出现最多的解决方案（这个问题我也遇到了，试了好几次都没有成功，每一次都好几个小时，以为是我的网络问题） 每次执行完react-native init Hello，就会出现下面的效果，然后一直卡在不动 在Stack Overflow找到了一个解决方案，目前问题已经解决了 vim ~/.npmrc registry = https://registry.npm.taobao.org 一开始只有：registry=http://registry.cnpmjs.org 根据实际结果应该是天朝网络的问题（你懂的…） 安装完成后命令行结果 执行以下： react-native run-ios / react-native run-android 这里主要以iOS为例 执行完之后你会看到进行一些加载和依赖的检测 然后会弹出一个新的窗口进行，扫描和加载准备工作， 最后会直接启动模拟器并提示 BUILD SUCCESS iOS执行结果： 没错，就是这么丑…… 关于Android配置相对iOS麻烦一点，具体过程可以参考下面Android Studio 这里安装的时候选择自定义，且勾选： SDK 安装下面部分想要下载的SDK，其中SDK Tools中有一个需要选的：Android SDk Build-Tools 23.0.1（这个必须选，另外可以增加其他的） 配置环境HOME 添加环境变量 其他插件工具和之前一样 权限问题期间如果遇到权限问题，可以直接修改文件夹或者文件对应权限 项目目录结果 后面会针对项目目录进行介绍与分析，并开始界面初始化，数据，逻辑相关处理，去完成第一个简单可用的React Native App]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native搭建与初始化项目</tag>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——遇到的最奇葩的Bug]]></title>
    <url>%2F2017%2F11%2F20%2FiOS%E2%80%94%E2%80%94%E9%81%87%E5%88%B0%E7%9A%84%E6%9C%80%E5%A5%87%E8%91%A9%E7%9A%84Bug%2F</url>
    <content type="text"><![CDATA[我司有两个App，一个115，一个是115组织，每个人分别负责不同的模块，最近除了适配iPhone X，还处理一些遗留的问题（Bug），并跟进一些开发的需求。但是最近，前几天测试很强硬的跟我反馈的了一个Bug，说这个问题一定要想办法处理掉…………。 先来看看看具体的问题 这是具体出现这个奇葩Bug的现象（已打开图层）， 由于App实际效果现场暂时无法出现，所以抱歉，只能给出当时截图的图层调试效果 事情是这样的:我司有两个App，一个115，一个是115组织，每个人分别负责不同的模块，最近除了适配iPhone X，还处理一些遗留的问题（Bug），并跟进一些开发的需求。但是最近，前几天测试很强硬的跟我反馈的了一个Bug，说这个问题一定要想办法处理掉…… 测试反馈的具体问题： 底部TabBar条中多出一个Item。 115组织有（非常小概率）这样的现象，但是115没有出现过。 无法复现，但是出现之后就无法消失 ，只能结束进程。 根据上面测试人员反馈的问题，之前有专门负责模块的人有尝试处理过此问题，后面老大和大家也一起查找和分析过此问题，但是并没有实际验证并解决此问题…… 解决过程… 由于最近在开始适配iPhone X，公司仅有的一部测试机没有在我们总部现场，还在北京的分部，所以在我们进行适配后，测试人员无法验证问题，于是只能借用这边的Mac设置使用模拟器进行测试验证…… 就在某一天中午，iPhone X现在测试人员在群里说了一句： 这个Bug又出现了，并符上了截图。 而且此Bug在过去的一段时间里，测试人员也有反馈过，只是概率非常低，当我们再次进行验证调试的时候，且始终无法再现了，最终都以失败告终…… 这次终于有现场了，什么也不说，我停下了手上的所有工作，做到现场设备前开始调试，希望能解决这个一直以来存在的问题…… 由于之前在上一家公司遇到过一次这样的问题，但是当时的解决方案是： 没有使用之前的TabBar，并且部分代码都重写整理了，才处理次问题，但实际上并没有从根本解决这个Bug，后面由于项目太赶，也就没有管那么多了。但是这次可能不一样，就目前公司项目之庞大，肯定是没办法重写了，只能想办法找出具体问题，毕竟别人家的项目正常（或者我们另一个项目正常），这就是Bug，是Bug就要像办法解。 下面是我整个解决问题的过程 一：乱点一顿开始调试模式以后，我回到实际效果界面，随便点了几下界面（当时测试说了一句：一来就破坏现场，我……）,发现以下问题： 本来只有四个Item的（有文字和图片），但是现在貌似有五组文字，其中一组文字偏移了不少 重复的那组文字，在第一个Item对应标题的坐下角 重复的问题和对应的区域无法点击，或者点击相应的就是第一个Item的效果 重复的为文字是刚好是App上一个版本的第一个Item文字对应的标题文案， 出现之后，无论怎么操作都无法消失（即使退到了后台），只能杀掉进程 二：图层分析然后我们开启了图层调试模式，并仔细分析了一下，下面是具体效果 由此我们得出了一下结论 TabBar有五个Item， 异常的那个在图层的位置属于第三个 异常的那个在宽高貌似和其他四个相反（躺着的） 异常的那个原始X和Y值都是0 异常的那个只有问题没有图片 得到这些信息之后，我保留了一份效果并记录下来的这个信息 三：代码找到我找到的TabBarController，发现没有自定义的Tabar，使用的系统的tabBar，经过查找也没有发现有对应TabBarController和TabBar的分类，最终到唯一设置TabBarController对应控制器和相关标题文案，图的代码 //事务 self.oneVC = [[OneViewController alloc] init]; self.oneVC.title = NSLocalizedString(@&quot;事务&quot;, nil); self.oneVC.tabBarItem = [[UITabBarItem alloc] initWithTitle:NSLocalizedString(@&quot;事务+&quot;, nil) image:... selectedImage:...]; //提醒 self.twoVC = [[LifeMainViewController alloc] init]; self.twoVC.tabBarItem = [[UITabBarItem alloc] initWithTitle:NSLocalizedString(@&quot;提醒&quot;,nil) image:... selectedImage:...]; //我聊 self.three = [[ChatMainViewController alloc] init]; self.three.title = NSLocalizedString(@&quot;消息&quot;, nil); self.three.tabBarItem = [[UITabBarItem alloc] initWithTitle:NSLocalizedString(@&quot;我聊&quot;,nil) image:... selectedImage:...]; //组织 self.fourVC = [[UIStoryboard storyboardWithName:@&quot;Groups&quot; bundle:nil] instantiateViewControllerWithIdentifier:@&quot;COMainOfficeViewController&quot;]; self.fourVC.tabBarItem = [[UITabBarItem alloc] initWithTitle:NSLocalizedString(@&quot;组织&quot;,nil) image:... selectedImage:...]; self.viewControllers = @[[[UINavigationController alloc] initWithRootViewController:self.oneVC], //115 [[UINavigationController alloc] initWithRootViewController:self.twoVC], //提醒 [[UINavigationController alloc] initWithRootViewController:self.threeVC], //我聊 [[UINavigationController alloc] initWithRootViewController:self.fourVC]]; //组织 以上是所有TabBarController设置TabBar,Item，对应控制，标题，图片的代码（由于关系代码隐私，部分代码做了特殊处理）。 这段我仔细看了不下三遍，看来看去还是看不出任何问题,但是又感觉和我们之前使用的方式有撒不同的地方，差了一下另一个项目的对应代码，好像没有什么区别，只是那边自定义了一个TabBar. 四：根据错位文案全局查找由于上面错位Item的标题文案并不是我们设置的那四个Item的文案，只是同样是个Item，只有标题，没有图片而且是躺着的Item。 于是我全局搜索：“115组织”，发现马上有一百多个地方，当时我就懵逼了，也懒得吐槽。。。。。。。 直接查看这一百多个含有“115组织”文案的地方，并且根据类名从可能性高到底看，看完之后我们眼睛都在打转，也没有发现什么可用信息，只是熟悉了一遍代码…… 五：网上寻找答案于是我开始在进苹果官方论坛并查找相关的苹果文档资料，然后github，stackoverflow，百度，微博，贴吧，论坛，知乎等地方都搜了一遍相关资料，开始并没有找到什么根本问题，并且在几个比较值得发布的技术群里提出的请教….. 最后在stackoverflow中发现了一个问题： how to change uiviewcontroller title independent of tabbar item title 仔细看了一下下面的回答，虽然不是问题和答案不是和我们的这个问题相关，但是我们从这里找到了灵感。 从上面的实际效果和结论我们知道 多了一个Item 只有标题没有问题 位置在初始位置（0，0） 再回到上面的代码，我们发现只有第一个（事务）和第三个（我聊）使用的VC.title //事务 self.oneVC = [[OneViewController alloc] init]; self.oneVC.title = NSLocalizedString(@&quot;事务&quot;, nil); self.oneVC.tabBarItem = [[UITabBarItem alloc] initWithTitle:NSLocalizedString(@&quot;事务+&quot;, nil) image:... selectedImage:...]; //我聊 self.three = [[ChatMainViewController alloc] init]; self.three.title = NSLocalizedString(@&quot;消息&quot;, nil); self.three.tabBarItem = [[UITabBarItem alloc] initWithTitle:NSLocalizedString(@&quot;我聊&quot;,nil) image:... selectedImage:...]; 在要说区别就是组织使用的是StoryBard加载的控制器。 于是我开始猜想，难道真的在这里，但是为撒只有第一个有Bug，第三个没有Bug呢？ 六：群聊问答就在沉思和与同事讨论的时候，我之前在群里提过的问题，有人几个回答了，但是一开始都是让我直接搜索错位Bug显示对应的标题文案，仔细查看对应代码，检查tabBar控制器，Item标题等信息代码等等….. 后面有一个大牛说了一句话： 这是一个历史悠久的Bug，从iOS 5就开始有了，tabBarController对应子控制器标题最好不要这么设置，会有问题。 附上截图 顿时我好想又想到了stackoverflow的那个问题，并想起来项目中设置TabBarController对应控制器和相关标题文案，图的代码。好像终于找到了解决方案，但是是真的吗？我也不知道，因为前面提到了，无法复现了（这Bug非常变态，你想它出了，死都不出来，但是不知不觉可能又出来了，而那个时候是不是又不是调试模式）。 七：解决方案？ 最后我决定换掉上面设置TabBarController对应控制器和相关标题文案，图片的代码，并且和部门同事，测试人员一起想办法专门测了一下这个问题，但是最终一次都没有出现过，于是我就跟测试人员说：你先测试或者回忆一下之前出现的方案，尽量多测试一下，不管这个问题是不是真的解决了，跟其他同事也说一下，留意一下这个问题,然后就闪人了…… 回到座位后，我沉思了几秒，再回想了一下整个过程，并且带讽刺的微笑，问自己： 这个问题真的解决了吗？我也不知道.......]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>开发文档</tag>
        <tag>iOS——遇到的最奇葩的Bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——免密登录，我以为有多难？]]></title>
    <url>%2F2017%2F11%2F18%2FiOS%E2%80%94%E2%80%94%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%EF%BC%8C%E6%88%91%E4%BB%A5%E4%B8%BA%E6%9C%89%E5%A4%9A%E9%9A%BE%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[以前总是在群里或者网上听说什么：单点登录，免密登录，因为没有听过，所以感觉很高大上的样子，最近一次免密登录的开发需求，差点给自己打脸了……… 前言： 最近公司要开发一个免密登录的需求，以前好像听过，感觉没撒用处，就没有去管了。 因此不得不研究一下，原本以为会和某些第三方一样，各种配置，导入，各种坑，却没想到……哎！ 背景现在很多人在使用一个App的时候，遇到这样的一些问题： 经常需要输入账号密码，手动或者自动退出 如果账号或者密码一次输错又要重新输入，甚至各种验证。 有时候密码不太记得了，就要狠麻烦的修改或者找回 如果涉及到太多安全信息在里面，输入的时候可能会特别小心。 …. 有了上面这些问题之后，自然也有很多公司或者技术人员考虑了很多技术或者涉及上的解决方案。其中免密登录被公认为是一种不错的选择，即使也有一些缺陷…… 什么是：免密登录免 密登录的意思 : 就 是 免 密认证，是利用了电信运营商独有的移动网络安全认证，实现手机号码认证登录、手机号码 就 是账号，无需设置密码，由运营商移动网络认证。 天翼基于各行业的合作，天翼账号为合作方提供一套智能认证解决方案，”免密认证“和”运营商能力“： “免密认证”，依托电信运营商的移动数据网络，采用“通信网关取号”及SIM卡识别等技术，准确识别用户手机号码。依托运营商计费网络更“快，准，安全”。 “运营商能力”，基于天翼手机用户的二次卡校验，实名校验，用户信用等多种基于运营商的特色功能。 移动统一认证是中国移动推出的手机号码认证功能，应用集成后可通过数据网络、短信网关获取本机号码（覆盖移动、电信、联通手机号），实现手机用户免输账号密码一键注册/登录。 同时，应用可获取更多用户授权的号码信息，调用更多的用户身份认证功能。如：本机号码校验、号码状态查询、二次卡查询、实名认证、防刷单、互联互通等服务。 由于天翼帐号免密登录在移动号码上的成功率不高，有些公司会考虑接入移动帐号免密登录来改善或者进行双重介入与验证判断（我们就是这做的）。 具体需求 当前手机无SIM卡/网络情况差，调用免密登录接口失败时，走短信登录流程； 有SIM卡且网络比较稳定，判断该手机号类型， 如果是移动卡，调用移动免密登录的接口，走移动帐号免密登录流程， 其他类型则调用移动免密登录的接口，走现有的天翼帐号登录流程。 当有双卡双待时，本机号码为启用了移动网络数据的那个。 核心代码 开发与操作流程1. 运营商类型判断定义枚举 typedef NS_ENUM(NSInteger, SSOperatorsType) { // Apple NetworkStatus Compatible Names. // 参考 https://en.wikipedia.org/wiki/Mobile_country_code Other = 0, // 中国移动 Mobile = 1, // 中国联通 Unicom = 2, // 中国联通 Telecom = 3, // 中国电信 Tietong = 4 // 中国铁通 }; 2. 库导入#import &lt;CoreTelephony/CTCarrier.h&gt; #import &lt;CoreTelephony/CTTelephonyNetworkInfo.h&gt; 3. 类型获取/** 获取运营商类型 @return 对应的运营商类型（枚举） */ + (SSOperatorsType)getOperatorsType{ CTTelephonyNetworkInfo *telephonyInfo = [[CTTelephonyNetworkInfo alloc] init]; CTCarrier *carrier = [telephonyInfo subscriberCellularProvider]; NSString *currentCountryCode = [carrier mobileCountryCode]; NSString *mobileNetWorkCode = [carrier mobileNetworkCode]; if (![currentCountryCode isEqualToString:@&quot;460&quot;]) { return Other; } // 参考 https://en.wikipedia.org/wiki/Mobile_country_code if ([mobileNetWorkCode isEqualToString:@&quot;00&quot;] || [mobileNetWorkCode isEqualToString:@&quot;02&quot;] || [mobileNetWorkCode isEqualToString:@&quot;07&quot;]) { // 中国移动 return Mobile; } if ([mobileNetWorkCode isEqualToString:@&quot;01&quot;] || [mobileNetWorkCode isEqualToString:@&quot;06&quot;] || [mobileNetWorkCode isEqualToString:@&quot;09&quot;]) { // 中国联通 return Unicom; } if ([mobileNetWorkCode isEqualToString:@&quot;03&quot;] || [mobileNetWorkCode isEqualToString:@&quot;05&quot;] || [mobileNetWorkCode isEqualToString:@&quot;11&quot;]) { // 中国电信 return Telecom; } if ([mobileNetWorkCode isEqualToString:@&quot;20&quot;]) { // 中国铁通 return Tietong; } return Other; } 4. 移动判断/** 移动运营商类型判断 @return 布尔值（是否是移动运营商类型） */ - (BOOL)checkOperatorsTypeChinaMobile { return [NetWorkState getOperatorsType] == Mobile; } 具体实现代码（抽取封装之后的）//免密登录 //1.本机手机号未注册过115帐号，则免密登录后自动注册、登录、绑定本机手机号。 //2.本机手机号已注册过115帐号，则直接登录该帐号。 //3.客户端判断当前启用移动网络数据的号码是否属于移动， //属于则走移动免密登录流程， //不属于则走现有的天翼免密流程 if ([[NetWorkState shareNetWork] checkOperatorsTypeChinaMobile]) { ///移动接口接入地址 http://dev.10086.cn/wiki/?p5_01_03#p2-2 [UMCOpenLogin loginExplicitly:self complete:^(id sender) { if ([sender[@&quot;resultcode&quot;] isEqual:@&quot;000&quot;] &amp;&amp; sender[@&quot;uniqueid&quot;] &amp;&amp; sender[@&quot;accesstoken&quot;]) { [MBProgressHUD showLoading:NSLocalizedString(@&quot;正在登录...&quot;,nil)]; [COLoginService noCodeLoginWithToken:sender[@&quot;accesstoken&quot;] uniqueId:sender[@&quot;uniqueid&quot;] block:^(id _Nonnull model, NSError * _Nonnull error) { [MBProgressHUD hide]; }]; } else if(![sender[@&quot;resultcode&quot;] isEqual:@&quot;102121&quot;]) { [self smsVerifyCodeLogin]; } }]; } else { ///天翼接口接入地址 http://id.189.cn/api?initialSrc=/html/api_detail_447.html [EAccount login:@&quot;&quot; loginWay:@&quot;zm|dm&quot; accountType:@&quot;&quot; loginList:@[] hasat:NO hideTop:NO baseApp:YES basicLoginTxt:@&quot;短信登录&quot; controller:self success:^(NSDictionary * _Nonnull resultDic) { if (resultDic[@&quot;accessToken&quot;]) { [MBProgressHUD showLoading:NSLocalizedString(@&quot;正在登录...&quot;,nil)]; [COLoginService noCodeLoginWithToken:resultDic[@&quot;accessToken&quot;] uniqueId:nil block:^(id _Nonnull model, NSError * _Nonnull error) { [MBProgressHUD hide]; }]; } } failure:^(NSError * _Nonnull error) { NSLog(@&quot;error%@&quot;, error); if (error.code == -8994014) { [self smsVerifyCodeLogin]; } else { [MBProgressHUD showError:error]; } }]; } 免密登录后的流程 获取用户信息 通过获取用户信息接口，在用户登录后可以获取用户昵称、手机号码、头像等信息，需要对接获取用户信息接口. 刷新accessToken accessToken是调用账号登录的调用凭证，accessToken有效期为1个月 在有效期内避免accessToken过期后，可以在用户打开应用时使用刷新accessToken接口进行刷新. 相关API：登录相关接口这里只介绍一下登录相关，其他Api可自行查阅API文档和源代码 天翼API：/** 打开登录页面 @param showThirdLogin 第三方登录的配置，有qq，微博，微信三个，要哪个登录方式，就传对应的拼音，如@&quot;qq&quot; 或者@&quot;qq|weixin&quot; 或者@&quot;qq|weixin|weibo&quot; @param loginWay 登录方式，zm、dm、zm|dm、dm|zm等4种方式，zm代表账号密码登录，dm，代表短信验证码登录，zm|dm代表两种都有，并且优先账号密码登录, dm|zm代表两种都有，优先短信登录 @param accountType 账号类型，有mobile,email两种，两种都要的话，传@&quot;mobile|email&quot;，否则传@&quot;mobile&quot; 或者@&quot;email&quot; @param loginList 已经登录上的账号的accessToken组成的数组，不需要多账号功能的，可以传一个空的数组 @param hasat 登录页面的登录账号是否默认加上@189.cn，yes表示有后缀，no表示没有后缀 @param hideTop 是否隐藏头部导航栏 @param baseApp 自定义账号入口方式 @param basicLoginTxt 自定义账号入口方式的自定义文本 （6到8个字符） @param controller 可以为nil，如果是nil，SDK会新建一/Users/thy/TY/EAccountSDK_WIFI/EAccountSDK/EAccountSDK/EAccount.h个window来加载登录页面，如果不是空，SDK会使用controller来preszent登录页面。 @param success 登录成功的回调 @param failure 登录失败的回调 */ + (void)login:(NSString *)showThirdLogin loginWay:(NSString *)loginWay accountType:(NSString *)accountType // loginList:(NSArray *)loginList hasat:(BOOL)hasat hideTop:(BOOL)hideTop baseApp:(BOOL)baseApp basicLoginTxt:(NSString *)basicLoginTxt controller:(nullable UIViewController *)controller success:(successHandler)success failure:(failureHandler)failure; 移动API：/** 显式登录 */ + (void)loginExplicitly:(UIViewController *)vc complete:(void (^)(id sender))complete; 总结 免密登录主要体现在安全性上，手机丢了，那么就麻烦大了， 而且现在的黑科技太发达了，短信截获、伪装基站、伪装商家服务号、复制SIM 卡…… 用手机号登录、用短信验证码的方式真的安全吗？！]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS——免密登录，我以为有多难？</tag>
        <tag>免密登录，我以为有多难？</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——iPhone X适配实战总结]]></title>
    <url>%2F2017%2F11%2F18%2FiOS%E2%80%94%E2%80%94iPhone-X%E9%80%82%E9%85%8D%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近公司项目需要开始适配iPhone X了，之前在网上看到过很多讲解iPhone X适配的文章，也刷过几篇文章看了一遍，但是看完之后实在受不了各种假帖。甚至讲的都是一些理论和差异上的东西，真正讲解实际开发中适配iPhone的并没有多少，有些看完正片文章之后都不知道怎么开始。于是自己去根据官方提供的资料和指南写一篇只针对iPhone X适配的贴子…… 前言： 本文从实际开发着手iPhone X适配，关于相关理论与常识内容不会过多解释。 本文会分析iPhone X适配的几个不同方向和相关的处理方案 本文会分析并总结适配和测试过程中遇到的Bug，最终给出实际的适配方案或者代码 本文会尽量多的从实际项目与实际适配步骤会代码进行介绍 官方资料HIG-Human Interface Guideline官方Session 首先我们要明确一点：iPhone X适配的宗旨：我们要做的是让那些不能被遮挡的内容和控件在安全区域范围内显示,一.iPhone X的规则| | | iPhone X是真正的3x标准，印象中7p是2.88x iPhone X宽度和4.7的6，7，8一致（375），高度多出145pt（+20%） iPhone X的比例是9：19.5，而4.7的6，7，8比例是9：16， iPhone X（375812-&gt;11252436-&gt;5.8英寸）Super Retina 状态栏20-&gt;44(留海H=30，W=209,耳朵W=83)，底脚0-&gt;34 实际上可有效利用的高度为：145 – 24 (Status Bar) – 34 (Home Indicator) = 87pt 键盘高度由 216pt 增长为 291pt，设计文字区域时要小心 Home Indicator，Tab Bar 高度由 49pt 增长为 83pt 横屏时Home Indicator的高度为21pt，需要格外注意 | | | iPhone X竖屏时占满整个屏幕的控制器的view的safeAreaInsets是（44，0，34，0），横屏是（0，44，21，44），inset后的区域正好是safeAreaLayoutGuide区域 如果你的 UI「顶部」有 Navigation Bar 或其它类似的UI控件，那么一般来说，在设计稿将 Navigation Bar 的背景色往上延伸 44pt，「垫在 Status Bar 后方」作为背景色即可如果你的 UI「底部」有 Tab Bar、Toolbar 或其它类似的UI控件，在设计稿时将背景色往下延伸 34pt，「垫在 Home Indicator 后方」作为背景色即可。 二： iOS11相关 如果只是设置了titleView，没有设置barbutton，把titleview的宽度设置为屏幕宽度，则titleview距离屏幕的边距，iOS11之前，在iPhone6p上是20p，在iPhone6p之前是16p；iOS11之后，在iPhone6p上是12p，在iPhone6p之前是8p。 如果只是设置了barbutton，没有设置titleview，则在iOS11里，barButton距离屏幕的边距是20p和16p；在iOS11之前，barButton距离屏幕的边距也是20p和16p。 如果同时设置了titleView和barButton，则在iOS11之前，titleview和barbutton之间的间距是6p，在iOS11上titleview和barbutton之间无间距 estimatedRowHeight是一个预估高度，iOS11之前是为0，在iOS11下，这个值默认为44。 iOS11以前,我们布局时, 视图的 top 和 bottom 一般参照的是 Top Layout Guide 和 Bottom Layout Guide iOS11为UIViewController和UIView增加了两个新的属性safeAreaInsets和safeAreaLayoutGuide, 通过这两个属性我们可以获得安全区域的范围 safeAreaInsets 适用于手动计算. safeAreaLayoutGuide 适用于自动布局. 三. iPhone环境判断 通过分辨率判断：#define kDevice_Is_iPhoneX ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(1125, 2436), [[UIScreen mainScreen] currentMode].size) : NO) 通过设备名称判断：@&quot;iPhone10,1&quot; : @&quot;iPhone 8&quot;, @&quot;iPhone10,4&quot; : @&quot;iPhone 8&quot;, @&quot;iPhone10,2&quot; : @&quot;iPhone 8 Plus&quot;, @&quot;iPhone10,5&quot; : @&quot;iPhone 8 Plus&quot;, @&quot;iPhone10,3&quot; : @&quot;iPhone X&quot;, @&quot;iPhone10,6&quot; : @&quot;iPhone X&quot;, 判断状态栏的高度（如果状态栏没有隐藏，且竖屏的情况） 判断屏幕的高度或者宽度（横屏的时候） 根据是否可执行或者获取对应API的值（safeAreaInseret） 根据系统框架 常用宏定义#define IS_IPHONE_X_HEIGHT ([[UIScreen mainScreen] bounds].size.height &gt;= 812.0f ? 812.0f : 667.0f) #define ScaleWidth(width) width/ 375.0*KSCREEN_WIDTH #define ScaleHeigth(height) height/IS_IPHONE_X_HEIGHT*KSCREEN_HEIGHT #define WKSW(width) width/375.0*KSCREEN_WIDTH #define WKSH(height) height/IS_IPHONE_X_HEIGHT*KSCREEN_HEIGHT #define SafeAreaTopHeight (kWJScreenHeight == 812.0 ? 88 : 64) #define VIEWSAFEAREAINSETS(view) ({UIEdgeInsets i; if(@available(iOS 11.0, *)) {i = view.safeAreaInsets;} else {i = UIEdgeInsetsZero;} i;}) VIEWSAFEAREAINSETS(view).left VIEWSAFEAREAINSETS(self.view).right 四.启动页的适配启动页的启动方式 LaunchScreen(这里直接设置图片就可以) LaunchImage 使用对应的设计图片：1125 * 2436 如果使用的是Assets中的LaunchImage, 在增加了iPhone X尺寸的图片配置.准备一张尺寸:1125 * 2436的启动图片, 移动到LaunchImage的Finder目录中, 并在LaunchImage中的Contents.json文件中增加 (注意Json格式): { &quot;extent&quot; : &quot;full-screen&quot;, &quot;idiom&quot; : &quot;iphone&quot;, &quot;subtype&quot; : &quot;2436h&quot;, &quot;filename&quot; : &quot;图片名.png&quot;, &quot;minimum-system-version&quot; : &quot;11.0&quot;, &quot;orientation&quot; : &quot;portrait&quot;, &quot;scale&quot; : &quot;3x&quot; } 五.刷新框架的适配iOS11这里拿最有名的刷新框架,如果使用的类似的刷新框架并且隐藏导航那么你或许会遇到：刷新控件和留海重合且被挡住 具体原因：iOS 11上面废除了automaticallyAdjustsScrollViewInsets，使用contentInsetAdjustmentBehavior代替 适配具体代码： if (@available(iOS 11.0, *)) { self.home_collectionView.contentInsetAdjustmentBehavior = UIApplicationBackgroundFetchIntervalNever; } else { self.automaticallyAdjustsScrollViewInsets = false; // Fallback on earlier versions } 宏定义：/// 第一个参数是当下的控制器适配iOS11 一下的，第二个参数表示scrollview或子类 #define AdjustsScrollViewInsetNever(controller,view) if(@available(iOS 11.0, *)) { view.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever; } else if([controller isKindOfClass:[UIViewController class]]) { controller.automaticallyAdjustsScrollViewInsets = false; } 六：导航栏在iOS11导航栏多了一个LargeTitleView，专门显示大字标题用的，整个导航栏的高度达到了96p，这不包括状态栏的高度，也就是说，整个app顶部高度达到了116p，其中statusbar=20，title=44，largetitle=52，不过默认是64p； 当然，iPhoneX的高度会更高点，如果不显示大字标题，顶部的高度也达到了88，statusbar=44，title=44，如果显示大字标题，则高度变成了140，statusbar=44，title=44，largetitle=52，也就是说，iPhoneX的刘海高度为24p， 七：导航栏按钮间距变化(UIBarButtonItem) (iPhoneX &amp; iOS 11)iOS11以后，导航栏的层级发生了变化，也无法时使导航栏左右按钮边距为0了 iOS11之前导航栏的title是添加在UINavigationItemView上面，而navigationBarButton则直接添加在UINavigationBar上面，如果设置了titleView，则titleView也是直接添加在UINavigationBar上面。iOS11之后，大概因为largeTitle的原因，视图层级发生了变化，如果没有给titleView赋值，则titleView会直接添加在_UINavigationBarContentView上面，如果赋值了titleView，则会把titleView添加在_UITAMICAdaptorView上，而navigationBarButton被加在了_UIButtonBarStackView上，然后他们都被加在了_UINavigationBarContentView上 所以如果你的项目是自定义的navigationBar，那么在iOS11上运行就可能出现布局错乱的bug，解决办法是重写UINavigationBar的layoutSubviews方法，调整布局，上代码： - (void)layoutSubviews { [super layoutSubviews]; //注意导航栏及状态栏高度适配 self.frame = CGRectMake(0, 0, CGRectGetWidth(self.frame), naviBarHeight); for (UIView *view in self.subviews) { if([NSStringFromClass([view class]) containsString:@&quot;Background&quot;]) { view.frame = self.bounds; } else if ([NSStringFromClass([view class]) containsString:@&quot;ContentView&quot;]) { CGRect frame = view.frame; frame.origin.y = statusBarHeight; frame.size.height = self.bounds.size.height - frame.origin.y; view.frame = frame; } } } 看了简书App适配iOS11发现titleView支持autolayout，这要求titleView必须是能够自撑开的或实现了- intrinsicContentSize方法 - (CGSize)intrinsicContentSize { return UILayoutFittingExpandedSize; } 导航栏新增了一种大标题样式，默认设置是不开启，所以不需要修改。 titleView支持autolayout，这要求titleView必须是能够自撑开的或实现了- intrinsicContentSize， App需要实现导航栏左右按钮边距为0 八：继承自UIScrollView的视图偏移问题在iOS11设备上运行出现最多问题应该就是tableview莫名奇妙的偏移20pt或者64pt了。。原因是iOS11弃用了automaticallyAdjustsScrollViewInsets属性（前面有提到），取而代之的是UIScrollView新增了contentInsetAdjustmentBehavior属性，这一切的罪魁祸首都是新引入的safeArea， 原因分析 原因是iOS 11中Controller的automaticallyAdjustsScrollViewInsets属性被废弃了，所以当tableView超出安全区域时系统自动调整了SafeAreaInsets值，进而影响adjustedContentInset值，在iOS 11中决定tableView的内容与边缘距离的是adjustedContentInset属性，而不是contentInset。adjustedContentInset的计算方式见本文第二部分内容。因为系统对adjustedContentInset值进行了调整，所以导致tableView的内容到边缘的距离发生了变化，导致tableView下移了20pt（statusbar高度）或64pt（navigationbar高度）。 如果你的APP中使用的是自定义的navigationbar，隐藏掉系统的navigationbar，并且tableView的frame为(0,0,SCREEN_WIDTH, SCREEN_HEIGHT)开始，那么系统会自动调整SafeAreaInsets值为(20,0,0,0)，如果使用了系统的navigationbar，那么SafeAreaInsets值为(64,0,0,0)，如果也使用了系统的tabbar，那么SafeAreaInsets值为(64,0,49,0) if (@available(iOS 11.0, *)) { self.tableView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever; } else { self.automaticallyAdjustsScrollViewInsets = NO; } 这个问题的解决方法有哪些？ 重新设置tableView的contentInset值，来抵消掉SafeAreaInset值，因为内容下移偏移量 = contentInset + SafeAreaInset； 如果之前自己设置了contentInset值为(64,0,0,0),现在系统又设置了SafeAreaInsets值为(64,0,0,0)，那么tableView内容下移了64pt，这种情况下，可以设置contentInset值为(0,0,0,0)，也就是遵从系统的设置了。 设置tableView的contentInsetAdjustmentBehavior属性 如果不需要系统为你设置边缘距离，可以做以下设置： //如果iOS的系统是11.0，会有这样一个宏定义“#define __IPHONE_11_0 110000”；如果系统版本低于11.0则没有这个宏定义 #ifdef __IPHONE_11_0 if ([tableView respondsToSelector:@selector(setContentInsetAdjustmentBehavior:)]) { tableView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever; } #endif contentInsetAdjustmentBehavior属性也是用来取代automaticallyAdjustsScrollViewInsets属性的，推荐使用这种方式。 通过设置iOS 11新增的属性addtionalSafeAreaInset； iOS 11之前，大家是通过将Controller的automaticallyAdjustsScrollViewInsets属性设置为NO，来禁止系统对tableView调整contentInsets的。如果还是想从Controller级别解决问题，那么可以通过设置Controller的additionalSafeAreaInsets属性，如果SafeAreaInset值为(20,0,0,0)，那么设置additionalSafeAreaInsets属性值为(-20,0,0,0)，则SafeAreaInsets不会对adjustedContentInset值产生影响，tableView内容不会显示异常。 这里需要注意的是addtionalSafeAreaInset是Controller的属性，要知道SafeAreaInset的值是由哪个Controller引起的，可能是由自己的Controller调整的，可能是navigationController调整的。是由哪个Controller调整的，则设置哪个Controller的addtionalSafeAreaInset值来抵消掉SafeAreaInset值。 九：UITableView，cell，header，footer高度异常,tableView顶部有留白在iOS 11中默认启用Self-Sizing，，Headers, footers, and cells都默认开启了Self-Sizing，所有estimated 高度默认值从iOS11之前的 0 改变为UITableViewAutomaticDimension要解决此类异常的话，可通过以下代码解决 _tableView.estimatedRowHeight = 0; _tableView.estimatedSectionHeaderHeight = 0; _tableView.estimatedSectionFooterHeight = 0; 这个配合estimatedRowHeight、estimatedSectionFooterHeight、estimatedSectionHeaderHeight使用，可以预估高度。之前，设置header或者footer高度为0时，需要设置height=0.1，才会起作用，如果直接设置为0，则会使用默认高度。iOS11由于自动使用预估高度，所以，忽略了设置的高度，使原来的高度增大了。只要把这几个属性设置为0就可以解决 在iOS11里面有时候在tableView的头部和尾部留白，因为苹果给滚动试图加进去了self-sizeing，开始计算逐步计算contentSize，默认如果不去实现viewForHeaderInSection就不会调用heightForHeaderInSection,尾部试图一样。func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -&gt; UIView? { } func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -&gt; CGFloat { return 0.001 } 如果你不想实现viewForHeaderInSection也不想留白，那么只需要使用上面的三段代码把self-sizeing自动估高关闭即可 如果你使用了Masonry，某些界面需要适配需要适配safeArea，可以试试下面这段代码 if (@available(iOS 11.0, *)) { make.edges.equalTo()(self.view.safeAreaInsets) } else { make.edges.equalTo()(self.view) } 十：适配iOS 11 列表的册数删除在iOS8之后，苹果官方增加了UITableVIew的右滑操作接口，即新增了一个代理方法(tableView: editActionsForRowAtIndexPath:)和一个类(UITableViewRowAction)，代理方法返回的是一个数组，我们可以在这个代理方法中定义所需要的操作按钮(删除、置顶等)，这些按钮的类就是UITableViewRowAction。 这个类只能定义按钮的显示文字、背景色、和按钮事件。并且返回数组的第一个元素在UITableViewCell的最右侧显示，最后一个元素在最左侧显示。从iOS 11开始有了一些改变，首先是可以给这些按钮添加图片了，然后是如果实现了以下两个iOS 11新增的代理方法，将会取代(tableView: editActionsForRowAtIndexPath:)代理方法： 注意：看的有的文章如果在iOS11上面调用老的删除，会崩溃， - (nullable UISwipeActionsConfiguration *)tableView:(UITableView *)tableView leadingSwipeActionsConfigurationForRowAtIndexPath:(NSIndexPath *)indexPath func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? { let action = UIContextualAction(style: .destructive, title: &quot;Delete&quot;) { (action, view, handler) in handler(true) } let configuration = UISwipeActionsConfiguration(actions: [action]) return configuration } func tableView(_ tableView: UITableView, leadingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? { let action = UIContextualAction(style: .normal, title: &quot;Mark&quot;) { (action, view, handler) in handler(true) } action.backgroundColor = UIColor.init(red: 254/255.0, green: 175/255.0, blue: 254/255.0, alpha: 1); let configuration = UISwipeActionsConfiguration(actions: [action]) return configuration } 十一：到底用viewSafeAreaInsetsDidChange还是viewWillLayoutSubviews先来看看下面一段代码，相信做过iPhone X适配的同学应该都不陌生， var safeArea: CGFloat = 0 if #available(iOS 11.0, *) { safeArea += self.view.safeAreaInsets.bottom || UIApplication.shared.keyWindow.rootViewController.view.safeAreaInsets.bottom } coding ... constant || originY || frame || height 有时候，我们会发现这样的一段适配的代码，如果根据苹果的特性，和我们所了解情况，我们一般都会把他放到viewSafeAreaInsetsDidChange，但是，并没有什么卵用，但是根据UI刷新的特性，我试着把他放在viewWillLayoutSubviews，却又正常了，很多人对此很是不解。 首先我们要知道： viewSafeAreaInsetsDidChange调用时机很早，在viewWillAppear后 viewSafeAreaInsetsDidChange后面会调用两次viewDidLayoutSubviews，所以我们应该把改变高度或布局的代码都写在viewDidLayoutSubviews里，这样就不会有多余的动画效果了 注意: viewDidLayoutSubviews可能会由别的操作频繁触发，所以如果调整safeArea布局的代码比较耗时，可以考虑加上一个状态标记，只在didChange后执行一次布局调整 - (void)viewDidLayoutSubviews { [super viewDidLayoutSubviews]; UIEdgeInsets safeAreaInsets = sgm_safeAreaInset(self.view); CGFloat height = 44.0; // 导航栏原本的高度，通常是44.0 height += safeAreaInsets.top &gt; 0 ? safeAreaInsets.top : 20.0; // 20.0是statusbar的高度，这里假设statusbar不消失 if (_navigationbar &amp;&amp; _navigationbar.height != height) { _navigationbar.height = height; } } 十二：纯代码的宽高比适配/// 高度系数 812.0 是iPhoneX的高度尺寸，667.0表示是iPhone 8 的高度，如果你觉的它会变化，那我也很无奈 #define kWJHeightCoefficient (kWJScreenHeight == 812.0 ? 667.0/667.0 : kWJScreenHeight/667.0) | | | 十三：纯代码适配iPhone X脚底首先需要知道一点的是，底部脚底高度是34（tabBar之下所拓张的区域）适配规则： 列表页面不去适配，底部有按钮的界面要适配 viewSafeAreaInsetsDidChange方法里面打印NSLog(@”%@”,NSStringFromUIEdgeInsets(self.view.safeAreaInsets)); 注意： 1.介绍viewSafeAreaInsetsDidChange方法系统调用或者你设置控制器的additionalSafeAreaInsets安全区域边界2.顺序viewSafeAreaInsetsDidChange调用顺序实在viewWillAppear之后，在viewWillLayoutSubvies之前调用 /// 底部宏，吃一见长一智吧，别写数字了 #define SafeAreaBottomHeight (kWJScreenHeight == 812.0 ? 34 : 0) 十四：xib和SB适配安全区域：整个屏幕–导航栏–状态栏–tabbar（自己设定的安全区域除外 xib的适配齐刘海和圆角，如果你们项目要求适配iOS 9一下的，就该一个一个好好拖，如果你们不要求适配iOS 9一下的，只需要给view打开安全区域。 十五：App Store评论跳转问题在iOS11 之后，会跳的Today里面说无法连接到App Store 先来看看我们之前的写法 NSString *appstoreUrlString = [NSString stringWithFormat: @&quot;itms-apps://itunes.apple.com/WebObjects/MZStore.woa/wa/viewContentsUserReviews?type=Purple+Software&amp;id=%@&quot;,AppStoreAppId ]; NSURL * url = [NSURL URLWithString:appstoreUrlString]; if ([[UIApplication sharedApplication] canOpenURL:url]){ [[UIApplication sharedApplication]openURL:url]; }else{ WKLog(@&quot;can not open&quot;); } 到iOS 11后，那样已经没有效果了，要改成: NSString *appstoreUrlString = [NSString stringWithFormat:@&quot;itms-apps://itunes.apple.com/cn/app/idXXXXXX?mt=8&amp;action=write-review&quot;, AppStoreAppId ]; NSURL * url = [NSURL URLWithString:appstoreUrlString]; if ([[UIApplication sharedApplication] canOpenURL:url]){ [[UIApplication sharedApplication]openURL:url]; }else{ WKLog(@&quot;can not open&quot;); } 十六：导航栏设置透明问题本来导航栏设置为不透明，如今却变成了透明(磨砂)模式，要知道导航栏透明与不透明的区别除了视觉差异外还有对屏幕左上角坐标点（0,0）的基准是不一样的。 当导航栏设置为透明模式时—&gt;基准点为手机屏幕最左上角，也就是说如果你在（0,0）点放一个有色label时，你就会发现导航栏是挡住了你的方块的，因为是半透明，你能隐约间看到有色块如果你需要设置导航栏透明度，切记把 self.navigationController.navigationBar.translucent = NO; 写到ViewWillAppear里！ 十七：twitter今天刚发现的一个坑，那就是iOS11设置里并没有集成twitter等第三方应用了 一些系统的关于这些APP的API也申明被废弃了，并推荐使用官网SDK iOS 11 no longer supports using Twitter through the built-in social framework. ]Instead,you can use Twitter Kit 3 to Tweet, log in users, and use the Twitter API. 所以APP里集成twitter分享同学要注意了，一定要检查下twitter分享功能。其它APP分享如Facebook，微博分享功能等应该是完好的。 十八：AppIcon在iOS11上发现了一个奇怪的现象，APP在启动时图标会出现黑边， 原因是iOS11修改了App启动动画，如果你的App图标有圆角那么就会变成这个鸟样了…所有图标都换成直角就好了 十九：相册访问权限iOS11上系统默认打开了用户相册的访问权限，但是当你保存图片时APP就会crash， 原因是需要在info.plist再申明一个NSPhotoLibraryAddUsageDescription的key，同时为了兼容iOS11以前的机型，保留以前NSPhotoLibraryUsageDescription的key 总结：1. 属性总结： self.additionalSafeAreaInsets self.view.safeAreaInsets self.additionalSafeAreaInsets 改变safeAreaInsets的值 self.viewSafeAreaInsetsDidChange() self.view.safeAreaInsetsDidChange()- (void)viewSafeAreaInsetsDidChange在UIViewController中第一次调用的时间是在- (void)viewWillAppear:(BOOL)animated调用之后, 在- (void)viewWillLayoutSubviews调用之前. 当你的viewController改变了它的safeAreaInsets值时，有两种方式获取到回调 self.viewSafeAreaInsetsDidChange()self.view.safeAreaInsetsDidChange() self.view.safeAreaLayoutGuide self.view.safeAreaLayoutGuide UIView的一个只读属性，作为参照物，让view可以相对某个view的safeAreaLayoutGuide做布局，从而保证view能正常、安全地显示（相对的那个view不一定要是父view） 把safeAreaLayoutGuide看成是一个“view”，这个“view”系统自动帮我们调整它的bounds，让它不会被各种奇奇怪怪的东西挡住，包括iPhone X的刘海区域和底部的一道杠区域，可以认为在这个“view”上一定能完整显示所有内容,safeAreaInsets来调整自己的bounds的 self.view.insetsLayoutMarginsFromSafeArea 如果你不想让safeAreaInsets影响你的视图布局，则可以将insetsLayoutMarginsFromSafeArea设置为NO，所有的视图布局将会忽略safeAreaInsets这个属性了。 要注意的是，insetsLayoutMarginsFromSafeArea仅用于AutoLayout，即使该属性为NO，视图的safeAreaInsets还是一样有值，而且安全区域变更方法safeAreaInsetsDidChange一样被调用。 contentInsetAdjustmentBehavior 在iOS11 中, UIViewController的automaticallyAdjustsScrollViewInsets属性已经不再使用,我们需要使用UIScrollView的 contentInsetAdjustmentBehavior 属性来替代它. UIScrollViewContentInsetAdjustmentBehavior 是一个枚举类型,值有以下几种: automatic 和scrollableAxes一样,scrollView会自动计算和适应顶部和底部的内边距并且在scrollView 不可滚动时,也会设置内边距.scrollableAxes 自动计算内边距.never不计算内边距always 根据safeAreaInsets 计算内边距 2. Safe Area 与 Layout Margins一般在做 UI 设计，背景色或较不重要的內容可完整地延伸至屏幕边缘；主要的内容呈现区域 (例如 Table View) 会往内缩 (indent) 一层，称为「Safe Area」；而通常文字或是按钮等更加关键的物件，考虑到美观及操作性，會再内缩一层，称之为「Layout Margins 竖屏时的 Safe Area 可延伸至屏幕左右两侧，上部留 44pt 給 Status Bar；Layout Margins 通常左右再内缩 16pt。 横屏时的 Safe Area 左右两侧皆内缩 44pt；Layout Margins 通常左右再内缩 16pt。 Home IndicatorHome Indicator 为 iPhone X 屏幕下方的一个操控區域，外观是一条粗线 (手把)，由屏幕底部往上滑动可返回主界面 (Home Screen)，或进入多任务管理界面 (App Switcher)。 注意：该“粗线”不可自定义外观，系统会自动判断背景颜色，深色背景时显示浅色 Bar，浅色背景时则显示深色 Bar。 3. Edge Protection如果你的 UI 带有由屏幕底部往上滑动 (Swipe) 的手势，可能会与系统的手势冲突，这时可告诉开发者该 UI界面需要启用「Edge Protection」。启用时，Home Indicator 将会变得较为透明，并下降位置 (但还在)，让全屏体验更为完整。当使用者第一次由下往上滑动时，此手势将保留给你的 App 使用，而不会触发 Home Indicator；当使用者在这时进行第二次滑动，才会触发。 注意：此选项将造成使用者不便，因此当真的有需要时再考虑启用 4. Auto-HideUI 中若是有影片播放等需要降低干扰的情况，需要完全隐藏 Home Indicator，可启用「Auto-Hide」选项，启用时，若是使用者数秒内沒有操纵行为，Home Indicator 将自动隐藏，直到使用者触碰界面才会再度出现。 注意：此选项将造成使用者困惑，因此當真的有需要时再考虑启用。 推荐： 你可能需要为你的 APP 适配 iOS 11 iOS 11 适配集锦 iOS 11新特性与适配 iOS 11更新的内容(开发) APP适配iOS11 WWDC:Updating Your App for iOS 11 PDF版：Updating Your App For iOS 11 iPhoneX人机交互指南(开发&amp;设计师) 官方iPhoneX人机交互指南 中文版iPhoneX人际交互指南 强烈推荐UI 設計師需要知道的 iPhone X 細節]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS——iPhone X适配实战总结</tag>
        <tag>iPhone X适配实战总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——App跳转到系统设置]]></title>
    <url>%2F2017%2F11%2F16%2FiOS%E2%80%94%E2%80%94App%E8%B7%B3%E8%BD%AC%E5%88%B0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[这里就不扯太多没用的理论，也不做什么总结与分析，只是整理备用，方便查询：关于App跳转到系统设置…… 前言： 先上一段代码，懂的自然会懂….. #define iOS10 ([[UIDevice currentDevice].systemVersion doubleValue] &gt;= 10.0) NSString * urlString = @&quot;App-Prefs:root=FACETIME&quot;; if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:urlString]]) { if (iOS10) { [[UIApplication sharedApplication] openURL:[NSURL URLWithString:urlString] options:@{} completionHandler:nil]; } else { [[UIApplication sharedApplication] openURL:[NSURL URLWithString:urlString]]; } } 说明： APP的跳转通过： [[UIApplication sharedApplication] openURL:url]这种方法来实现的。 而APP之间传递数据 的 接收是在AppDelegate里： (BOOL)application:(UIApplication )application openURL:(NSURL )url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation { }方法里。 印象中iOS 10之前所有prefs中的P都是小写，而iOS 10之后Prefs中的P变成了大写 系统内置跳转 跳转 写法 运营商 App-Prefs:root=Carrier 通用-还原 App-Prefs:root=Reset Siri App-Prefs:root=SIRI 隐私 App-Prefs:root=Privacy 音乐 App-Prefs:root=MUSIC 音乐-均衡器 App-Prefs:root=MUSIC&amp;path=com.apple.Music:EQ 蜂窝网络：Prefs:root=MOBILE_DATA_SETTINGS_ID — Prefs:root=General&amp;path=Network/ Wi-Fi：Prefs:root=WIFI 定位服务：Prefs:root=LOCATION_SERVICES 个人热点：Prefs:root=INTERNET_TETHERING 关于本机：Prefs:root=General&amp;path=About 辅助功能：Prefs:root=General&amp;path=ACCESSIBILITY 飞行模式：Prefs:root=AIRPLANE_MODE 锁定：Prefs:root=General&amp;path=AUTOLOCK 亮度：Prefs:root=Brightness 蓝牙：Prefs:root=Bluetooth 时间设置：Prefs:root=General&amp;path=DATE_AND_TIME FaceTime：Prefs:root=FACETIME 设置：Prefs:root=General 设置 Prefs:root=SETTING 定位服务 Prefs:root=LOCATION_SERVICES 键盘设置：Prefs:root=General&amp;path=Keyboard iCloud：Prefs:root=CASTLE iCloud备份：Prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUP 语言：Prefs:root=General&amp;path=INTERNATIONAL 定位：Prefs:root=LOCATION_SERVICES 音乐：Prefs:root=MUSIC Music Equalizer — Prefs:root=MUSIC&amp;path=EQ Music Volume Limit — Prefs:root=MUSIC&amp;path=VolumeLimit Network — Prefs:root=General&amp;path=Network Nike + iPod — Prefs:root=NIKE_PLUS_IPOD Notes — Prefs:root=NOTES Notification — Prefs:root=NOTIFICATIONS_ID Phone — Prefs:root=Phone Photos — Prefs:root=Photos Profile — Prefs:root=General&amp;path=ManagedConfigurationList Reset — Prefs:root=General&amp;path=Reset Safari — Prefs:root=Safari Siri — Prefs:root=General&amp;path=Assistant Sounds — Prefs:root=Sounds Software Update — Prefs:root=General&amp;path=SOFTWARE_UPDATE_LINK Store — Prefs:root=STORE Twitter — Prefs:root=TWITTER Usage — Prefs:root=General&amp;path=USAGE Wallpaper — Prefs:root=Wallpaper 其他服务与APP跳转 电话 mobilephone:// 备忘录 mobilenotes:// 墨客 com.moke.moke-1:// 名片全能王 camcard:// 扫描全能王 camscanner:// TuneIn Radio tunein:// 或 tuneinpro:// OfficeSuite mobisystemsofficesuite:// WPS Office KingsoftOfficeApp:// Line line:// 1Password onepassword:// Clear(著名的Todo应用) clearapp:// Chrome谷歌浏览器 googlechrome:// Calendars 5 calendars:// GoodReader 4 com.goodreader.sendtogr:// PDF Expert 5 pdfexpert5presence:// Documents 5 rdocs:// nPlayer nplayer-http:// GPlayer gplayer:// AVPlayer HD AVPlayerHD:// AVPlayer AVPlayer:// Ace Player aceplayer:// 12306订票助手 trainassist:// 金山词霸 com.kingsoft.powerword.6:// 节奏大师 tencentrm:// 赶集生活 **:// 凤凰新闻 comIfeng3GifengNews:// 高铁管家 gtgj:// 飞信 fetion:// 豆瓣FM doubanradio:// 大智慧 dzhiphone:// 布卡漫画 buka:// 爱奇艺PPS ppstream:// 哔哩哔哩动画 bilibili:// 56视频 com.56Video:// 365日历 rili365:// 58同城 wbmain:// 遇见 iaround:// 陌陌 momochat:// 有道词典 yddict:// 优酷 youku:// 掌阅iReader iReader:// 艺龙旅行 elongIPhone:// 迅雷+迅雷云播 thunder:// 熊猫公交 wb1405365637:// 携程无线 CtripWireless:// 无线苏州 SuZhouTV:// 唯品会 vipshop:// 微视 weishiiosscheme:// 微拍 wpweipai:// 旺信 wangxin:// 网易公开课 ntesopen:// 网易将军令 netease-mkey:// 万年历 youloft.419805549:// 土豆视频 tudou:// 同花顺 amihexin:// 天涯社区 tianya:// 天气通Pro sinaweatherpro:// 天气通 sinaweather:// 墨迹天气 rm434209233MojiWeather:// 淘宝旅行 taobaotravel:// 人人 renrenios:// 蜻蜓FM qtfmp:// 浦发银行 wx1cb534bb13ba3dbd:// 招商银行 cmbmobilebank:// 建设银行 wx2654d9155d70a468:// 工商银行 com.icbc.iphoneclient:// 酷我音乐 com.kuwo.kwmusic.kwmusicForKwsing:// 酷狗音乐 kugouURL:// 今日头条 snssdk141:// 京东 openApp.jdMobile:// QQ mqq:// 微信 wechat:// 或 weixin:// QQ音乐 qqmusic:// QQ斗地主 tencent382:// QQ浏览器 mttbrowser:// QQ安全中心 qmtoken:// QQ国际版 mqqiapi:// 腾讯新闻 qqnews:// 腾讯微云 weiyun:// 腾讯地图 sosomap:// 腾讯企业邮箱 qqbizmailDistribute2:// 腾讯手机管家 mqqsecure:// 腾讯视频 tenvideo:// 或 tenvideo2:// 或 tenvideo3:// 腾讯微博 TencentWeibo:// 天天星连萌 tencent100689806:// 天天爱消除 tencent100689805:// 天天酷跑 tencent100692648:// 天天飞车 tencent100695850:// PPTV pptv:// 爱奇艺视频 qiyi-iphone:// 暴风影音 com.baofeng.play:// 保卫萝卜2 wb2217954495:// 保卫萝卜 wb1308702128:// 百度音乐 baidumusic:// 百度视频 baiduvideoiphone:// 或 bdviphapp:// 百度糯米 bainuo:// 百度魔图 photowonder:// 百度魔拍 wondercamera:// 百度地图 baidumap:// 百度导航 bdNavi:// 百度 baiduboxapp:// 或 BaiduSSO:// 搜狗输入法 com.sogou.sogouinput:// 搜狐视频 sohuvideo-iphone:// 或 sohuvideo:// 搜狐新闻 sohunews:// 随手记 FDMoney:// 天天动听 ttpod:// 挖财记账 wacai:// 威锋网 com.weiphone.forum:// 新浪微博 weibo:// 或 sinaweibo:// 网易邮箱 neteasemail:// 高德导航 Autonavi:// 百度输入法 BaiduIMShop:// 百度贴吧 com.baidu.tieba:// 淘宝 taobao:// 天猫 tmall:// 支付宝 alipay:// 旺旺卖家版 wangwangseller:// 百度云 baiduyun:// 网易新闻 newsapp:// UC浏览器 ucbrowser:// E-Mail MESSAGE://]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS——App跳转到系统设置</tag>
        <tag>App跳转到系统设置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode Server完整教程]]></title>
    <url>%2F2017%2F11%2F11%2FXcode-Server%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[由于公司项目的需要，以及同事和测试人员的反馈，我们的打包服务器挂了，貌似之前经常挂（因为我桌旁的就是装有打包服务器的垃圾桶，在领用Mac之前，我都是用那个开发的）。其实之前我也一直想找个机会搞一下Xcode Server，记得还专门写过一篇总结，但是由于工作的原因，也由于帐号的原因就没去搞了，这一次刚好有这个机会，于是我专门放下手上所有的活，打算把这个东西弄好来……… 如果你对CI和CD已经足够了解，仅仅想知道怎么搞好Xcode Server，那么你可以直接从准备开始… 背景：之前项目使用的是Jenkins，但是由于Jenkins的各种问题，配置，后面被换到了Xcode Server（当然除了他们我还可以选择Fantlane）。自从老大走了以后Xcode Server经常挂，导致测试人员不发打包测试，从而影响整体进度。而且这一次好像是彻底挂了，根本都进不去了….. 常识：这里简单介绍一下Xcode Server和常用的持续交付与继承工具（CI&amp;CD）。 xcodebuild - 由Apple开发，主要用于Xcode的构建和测试，有时可能难以想起，但可配置程度很高。 fastlane - 实际上并不是一个工具，而是一组可用于构建、测试、上传至iTunes Connect、供应配置文件管理、屏幕截图创建、dsym上传/下载至主要崩溃报告平台的一系列工具。 xctool和其他 - “其他”是指诸如nomad tools等工具，这些工具或者被弃用，或者逐渐缺少支持，或者即将被废弃。尽管Facebook在使用某种工具，但并不意味着这个工具依然可以得到妥善的维护。 服务器方面主要的选择包括： TravisCI/CircleCI - 托管式服务器，可免费用于开源项目，可随处访问，极为强大。相比Jenkins可配置的选项较少，仅支持与Github集成。用于私有代码库的价格高昂。 Xcode Server - 能与Xcode高度集成，实际上也是唯一可用于Xcode的服务器，由Apple开发，最有可能只需要少量配置即可投入使用。 Jenkins - CI服务器领域曾经的王者，有大量插件可用，可与各种其他产品集成，需要一定的配置和维护，但是非常强大。 需求一般项目到了一定程度，或者公司和成员到了一定规模都会考虑自动化，当然也包括那些喜欢导致或者懒惰想一键打包发布的程序员。因此结合公司，项目或者个人的情况我们可以将整个过程进行拆分。 构建并签署我们的所有不同特性的应用； 将我们的应用商店首选项上传至iTunes Connect； 将IPA、dSYM，以及变更日志上传至HockeyApp； 针对发布和开发分支持续不断地运行单元测试和UI测试； 构建每次合并请求（MR）并汇报测试结果； 进行持续不断地构建和签署，以确保没有引入新的问题。 由于时间的原因，也由于目前需求的原因，我们目前只需要进行打包发布相关操作，至于，分析，测试… 看完上面之后，相信你知道我接下来要说的是什么， 准备OS X工具下载 下载 OS X Server（付费开发者免费使用） 下载 Xcode 这里就不多废话了，直接到苹果商店搜索就可以 帐号与代码仓库地址 开发者帐号（相关证书与描述文件） git源代码仓库地址 装备完了上面所需要的东西之后我们就可以开始配置和使用OS X Server了 配置Xcode打开OS X Server，根据提示点击一步一步操作即可 1 选择服务器主机：一般选自身，也可以指定IP 2 选择Xcode服务，开启服务（右上角） 老版配置页面 这里需要注意，之前的配置方案是直接有 权限和版本号：自己考虑，我这里默认设置不改了； 开发团队：使用自己的apple ID添加； 开发设备：需要用设备连接服务器后才能搜索到，初次连接，可能还需要在Status选项里面点击【Add to Teams】（比如设备不是你上面apple ID 的就需要） 查看Bot：会打开网页（Bot管理页面，默认127.0.01）,可以直接静态分析测试打包等，当然需要后面配置成功才能使用。 新版配置页面 最新版本不知道为什么没有了对应的信息，根据提示信息应该的Xcode兼容性问题（因为：点击选择Xcode，选择指定Xcode之后提示是说版本不兼容） 此时界面只有一个选择Xcode的按钮，点击进去就会直接进入到Server &amp; Bots 你会看到下面的界面 这里也可以直接在Xcode Preferences中打开， 解锁后点击OFF&amp;ON进行开启服务，然后会提示Select Integration User（选择集成用户） 这里我们一般都会新建一个用户，而不是直接使用服务器账户，然后填写对应的信息（帐号密码），这里要记住后面会有用 点击创建之后就会执行一系列操作，对Xcode进行配置 具体执行操作有 Saveing version information Enableing developer model Configuring SSL certificates Starting Redis initializing database Starting API Server Starting Apache Starting control daemon Starting Builder Upgrading Xcode Server Data Saveing version information 完成后你会看到，一个提示新用户登录的提示，为了更好的进行测试和验证，我们都会先登录用户 直接登录就可以，并且一步一步确认进入到子账户，子账户会提示： 这里先不用管，切回到服务器账户就可以，这个时候，你就可以看到刚刚创建的账户已经出现了，并且处于登录状态，我们可以点击直接切换到对应账户，或者选择和重新创建多个账户，控制超时时间。 登录账户在Xcode Preferences中选择Account，点击右下角添加账户，分别登录Apple ID，GitHub，Xcode Server Apple ID：对应开发者帐号，要和本地证书与描述文件对应 GitHub 注意:Source Control 需要打开才能使用！具体下面的各种自动自己考虑勾选； Xcode Server（如果使用Xcode 9.1最新版本，这一步已经不需要了，也就是说Xcode 9.1已经自带了Bots功能） 注意：Accounts 添加 Servers，一般默认自己主机，也可以选择指定IP地址，按服务器配置时对应选择；需要填写用户名，密码，自己搞定； 完成帐号登录以后，可以适当下载更新一下证书文件 配置Xcode Server（如果使用Xcode 9.1最新版本，这一步已经不需要了，也就是说Xcode 9.1已经自带了Bots功能）再次打开Xcode Server，进入Xcode服务页面，点击打开Xcode，会直接打开Xcode Preferences中的Server &amp; Bots并开启对应账户，这里和前面操作一样，如果没有就根据提示直接确定或者输入对应的账号信息就可以（如果没有登录帐号的话） 创建Bots 注意：自己的项目必须是个git文件夹，比如github上clone下来的项目，或者是本地服务器git来的，总之需要git文件夹；（官方文档使用Xcode的Source Control 方式搞定，具体可以看官方指南。我直接用了第三方软件SourceTree管理的） 这里由于我们是直接使用GitLab的，所以我直接从GitLab克隆了一分项目源码到本地文件夹。 打开Xcode，保证项目编译正常的情况下创建Bots（这里可以直接点击Products-&gt;Create Bots） 1 Bot命名与服务器选择，基本默认不改；2 选择项目内容，后面的master，可选其他分支，比如develop；3 Bot 操作配置Scheme：默认项目本身Actions：1分析；2单元测试（测试项目没开单元测试所有没的选）；3打包；Cleaning：可以选择，因为是自己的电脑做服务器的，所以选择了一周清理一次；Configuation：项目配置；4 环境变量？没用过，sorry；5 添加脚本，比如完成后发送个邮件通知；6 create！注意 需要一次验证 git 的用户名和密码！不是之前设置的用户名与密码。7 成功；各种信息以及完成的打包等；通过IP地址也可以实时整合并下载； 当你看到一个类型这样的界面，说明已经配置并且创建Bots完成，具体是否正确，需要进行打包验证或者根据日志进行查找具体问题 注意： 如果在使用Xcode Server对应的分析，测试功能，还需要额外进行一些配置，由于时间的问题，这里我们暂时只使用打包功能。 打包配置需要选择InHouse 打包验证输入网址或者点击Xcode Perferences中的Account，点击Xcode Server对应的地址链接，进入网址（这里是icocos.local对应ip是10.0.6.7），这里可以在当前服务器进行操作，也可以在配置Xcode的时候创建的那个帐号进行操作，同意可以在内网的其他端系统或者浏览器进行操作 然后就会有一打包的进度…… 错误总结错误问题一： 问题原因： 因为没有登录对应的Git帐号或者没有打包对应项目的workspace 错误问题二： 问题原因： 同样是因为没有登录对应的Git帐号 错误问题三： 问题原因： 同样是因为没有登录对应的Git帐号 错误问题四： 问题原因： 这里是由于创建Bots进行配置的时候，只需要打包功能就行了，那些什么分析,测试不需要,还有打包配置要选InHouse，不然打不了的 错误问题五： 问题原因： 由于升级了Xcode 9.1，和对应的Xcode Server不兼容，这里需要输入xcsd密码（也不知道是sm鬼），根据2017@swift大会的朋友经验： 备份/Library/Developer/XcodeServer，然后删除XcodeServer文件夹内容，重新前面的步骤就正常了。 错误问题六： 问题原因： 这其实不是sm错误 ，只是一个安全警告，解决方案：点击显示详细信息-&gt;继续访问网址，就可以了 错误问题七： 问题原因： 此问题困扰了很久，由于加入了GZIP库，但是…. 错误问题八： 问题原因： 此问题困扰了很久，由于加入了GZIP库，但是…. 其他问题 这些问题目前没有找到好的解决方案，根据提示查找发现，证书，前面都没有问题…… 总结一最后根据最新经验总结，最新版本Xcode 9.1配置其实非常简单了 配置Xcode Perferences中Server &amp; Bots 创建并登录帐号 Xcode Perferences登录git，app，server帐号 Clone远程Git源代码，并打开保证正常编译 Create Bots并配置 重启相关服务，Server，Bots，Xcode，开始打包 注意： 关于代码提交，不管使用Xcode还是其他方式，是没有关系的，Xcode服务指向的是master或者其他分支的服务器资源；关于打包，项目配置里就做好证书等配置文件的选择；内测的ipa包，可以结合蒲公英等平台作分发也是很方便的；考虑是不是可以搞个脚本上传。 打包过程中 通过 Xcode 中的 Integrate 查看进度我们不难发现，其实整个过程和我们手动打包的过程是一样的 打包完成 但是这样可能享受不到OS X Server那样多而且好用的服务，不过如果只是需要简单的进行打包，配合测试进行验证，简单的发布引用还是可以满足的…….. 推荐想了解更过关于Xcode Server配置与使用的，可以参考与学习下面的文章，笔者也是从下面的文章中一点一点学习的，并结合了朋友指点进行实战。 3个官方文档： 官方配置教程 苹果开发指南 OS X Server 帮助 简书教程： OS X Server 之 Xcode服务 手动打包流程 iOS App打包上架超详细流程]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Xcode Server完整教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——__attribute__使用与总结]]></title>
    <url>%2F2017%2F11%2F08%2FiOS%E2%80%94%E2%80%94-attribute-%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[关于attribute，其实iOS开发中无处不在，只是我们平时都只是开发，因为苹果已经帮我们处理好了这一切，或许你在曾在哪里看到过并且了解过，或者你曾在写过组件和框架相关，否则你应该只会知道大概的意思，而且只是小部分，今天我们就来分析一下一些常用attribute的含义，具体文章参考网络资料…… __attribute__使用与总结attribute是GNU C特色之一,在iOS用的比较广泛.系统中有许多地方使用到. attribute可以设置函数属性（Function Attribute ）、变量属性（Variable Attribute ）和类型属性（Type Attribute)等. 函数属性(Function Attribute) noreturn noinline always_inline pure const nothrow sentinel format format_arg no_instrument_function section constructor destructor used unused deprecated weak malloc alias warn_unused_result nonnull 类型属性(Type Attributes) aligned packed transparent_union, unused, deprecated may_alias 变量属性(Variable Attribute) aligned packed Clang特有的 availability overloadable 书写格式书写格式：attribute后面会紧跟一对原括弧，括弧里面是相应的attribute参数 attribute(xxx) 常见的系统用法format官方例子:NSLog #define NS_FORMAT_FUNCTION(F,A) __attribute__((format(__NSString__, F, A))) format属性可以给被声明的函数加上类似printf或者scanf的特征，它可以使编译器检查函数声明和函数实际调用参数之间的格式化字符串是否匹配。该功能十分有用，尤其是处理一些很难发现的bug。对于format参数的使用如下 format (archetype, string-index, first-to-check) 第一参数需要传递“archetype”指定是哪种风格,这里是 NSString；“string-index”指定传入函数的第几个参数是格式化字符串；“first-to-check”指定第一个可变参数所在的索引. noreturn官方例子: abort() 和 exit() 该属性通知编译器函数从不返回值。当遇到类似函数还未运行到return语句就需要退出来的情况，该属性可以避免出现错误信息。 availability官方例子: - (CGSize)sizeWithFont:(UIFont *)font NS_DEPRECATED_IOS(2_0, 7_0, &quot;Use -sizeWithAttributes:&quot;) __TVOS_PROHIBITED; 来看一下 后边的宏 #define NS_DEPRECATED_IOS(_iosIntro, _iosDep, ...) CF_DEPRECATED_IOS(_iosIntro, _iosDep, __VA_ARGS__) define CF_DEPRECATED_IOS(_iosIntro, _iosDep, ...) __attribute__((availability(ios,introduced=_iosIntro,deprecated=_iosDep,message=&quot;&quot; __VA_ARGS__))) //宏展开以后如下 __attribute__((availability(ios,introduced=2_0,deprecated=7_0,message=&quot;&quot;__VA_ARGS__))); //ios即是iOS平台 //introduced 从哪个版本开始使用 //deprecated 从哪个版本开始弃用 //message 警告的消息 availability属性是一个以逗号为分隔的参数列表，以平台的名称开始，包含一些放在附加信息里的一些里程碑式的声明。 introduced：第一次出现的版本。 deprecated：声明要废弃的版本，意味着用户要迁移为其他API obsoleted： 声明移除的版本，意味着完全移除，再也不能使用它 unavailable：在这些平台不可用 message：一些关于废弃和移除的额外信息，clang发出警告的时候会提供这些信息，对用户使用替代的API非常有用。 这个属性支持的平台：ios，macosx。 简单例子: //如果经常用,建议定义成类似系统的宏 - (void)oldMethod:(NSString *)string __attribute__((availability(ios,introduced=2_0,deprecated=7_0,message=&quot;用 -newMethod: 这个方法替代 &quot;))){ NSLog(@&quot;我是旧方法,不要调我&quot;); } - (void)newMethod:(NSString *)string{ NSLog(@&quot;我是新方法&quot;); } 如果调用了,会有警告 unavailable告诉编译器该方法不可用，如果强行调用编译器会提示错误。比如某个类在构造的时候不想直接通过init来初始化，只能通过特定的初始化方法()比如单例，就可以将init方法标记为unavailable; //系统的宏,可以直接拿来用 #define UNAVAILABLE_ATTRIBUTE __attribute__((unavailable)) #define NS_UNAVAILABLE UNAVAILABLE_ATTRIBUTE @interface Person : NSObject @property(nonatomic,copy) NSString *name; @property(nonatomic,assign) NSUInteger age; - (instancetype)init NS_UNAVAILABLE; - (instancetype)initWithName:(NSString *)name age:(NSUInteger)age; @end 实际上unavailable后面可以跟参数,显示一些信息 //系统的 #define NS_AUTOMATED_REFCOUNT_UNAVAILABLE __attribute__((unavailable(&quot;not available in automatic reference counting mode&quot;))) objc_root_class表示这个类是一个根类(基类),比如NSObject,NSProxy. //摘自系统 //NSProxy NS_ROOT_CLASS @interface NSProxy &lt;NSObject&gt; { Class isa; } //NSObject __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0) OBJC_ROOT_CLASS OBJC_EXPORT @interface NSObject &lt;NSObject&gt; { Class isa OBJC_ISA_AVAILABILITY; } NSObject@property (nonatomic,strong) __attribute__((NSObject)) CFDictionaryRef myDictionary; CFDictionaryRef属于CoreFoundation框架的,也就是非OC对象,加上attribute((NSObject))后,myDictionary的内存管理会被当做OC对象来对待. objc_designated_initializer用来修饰类的designated initializer初始化方法，如果修饰的方法里没有调用super类的 designated initializer，编译器会发出警告。可以简写成NS_DESIGNATED_INITIALIZER visibility语法: attribute((visibility(“visibility_type”)))其中，visibility_type 是下列值之一： default 假定的符号可见性可通过其他选项进行更改。缺省可见性将覆盖此类更改。缺省可见性与外部链接对应。 hidden 该符号不存放在动态符号表中，因此，其他可执行文件或共享库都无法直接引用它。使用函数指针可进行间接引用。 internal 除非由 特定于处理器的应用二进制接口 (psABI) 指定，否则，内部可见性意味着不允许从另一模块调用该函数。 protected 该符号存放在动态符号表中，但定义模块内的引用将与局部符号绑定。也就是说，另一模块无法覆盖该符号。 除指定 default 可见性外，此属性都可与在这些情况下具有外部链接的声明结合使用。您可在 C 和 C++ 中使用此属性。在 C++ 中，还可将它应用于类型、成员函数和命名空间声明。 系统用法: // UIKIT_EXTERN extern #ifdef __cplusplus #define UIKIT_EXTERN extern &quot;C&quot; __attribute__((visibility (&quot;default&quot;))) #else #define UIKIT_EXTERN extern __attribute__((visibility (&quot;default&quot;))) #endif nonnull编译器对函数参数进行NULL的检查,参数类型必须是指针类型(包括对象) //使用 - (int)addNum1:(int *)num1 num2:(int *)num2 __attribute__((nonnull (1,2))){//1,2表示第一个和第二个参数不能为空 return *num1 + *num2; } - (NSString *)getHost:(NSURL *)url __attribute__((nonnull (1))){//第一个参数不能为空 return url.host; } 常见用法aligned__attribute((aligned (n)))，让所作用的结构成员对齐在n字节自然边界上。如果结构中有成员的长度大于n，则按照最大成员的长度来对齐.例如: 不加修饰的情况 typedef struct { char member1; int member2; short member3; }Family; //输出字节: NSLog(@&quot;Family size is %zd&quot;,sizeof(Family)); 输出结果 2016-07-25 10:28:45.380 Study[917:436064] Family size is 12 修改字节对齐为1 typedef struct { char member1; int member2; short member3; }__attribute__ ((aligned (1))) Family; //输出字节: NSLog(@&quot;Family size is %zd&quot;,sizeof(Family)); 输出结果 2016-07-25 10:28:05.315 Study[914:435764] Family size is 12 和上面的结果一致,因为 设定的字节对齐为1.而结构体中成员的最大字节数是int 4个字节,1 &lt; 4,按照4字节对齐,和系统默认一致. 修改字节对齐为8 typedef struct { char member1; int member2; short member3; }__attribute__ ((aligned (8))) Family; //输出字节: NSLog(@&quot;Family size is %zd&quot;,sizeof(Family)); //输出结果为: 2016-07-25 10:28:05.315 Study[914:435764] Family size is 16 这里 8 &gt; 4,按照8字节对齐,结果为16,不知道字节对齐的可以看我的这篇文章http://www.jianshu.com/p/f69652c7df99 可是想了半天,也不知道这玩意有什么用,设定值小于系统默认的,和没设定一样,设定大了,又浪费空间,效率也没提高,感觉学习学习就好. packed让指定的结构结构体按照一字节对齐,测试: //不加packed修饰 typedef struct { char version; int16_t sid; int32_t len; int64_t time; } Header; //计算长度 NSLog(@&quot;size is %zd&quot;,sizeof(Header)); 输出结果 2016-07-22 11:53:47.728 Study[14378:5523450] size is 16 可以看出,默认系统是按照4字节对齐 //加packed修饰 typedef struct { char version; int16_t sid; int32_t len; int64_t time; }__attribute__ ((packed)) Header; //计算长度NSLog(@”size is %zd”,sizeof(Header)); 输出结果 2016-07-22 11:57:46.970 Study[14382:5524502] size is 15 用packed修饰后,变为1字节对齐,这个常用于与协议有关的网络传输中. noinline &amp; always_inline内联函数:内联函数从源代码层看，有函数的结构，而在编译后，却不具备函数的性质。内联函数不是在调用时发生控制转移，而是在编译时将函数体嵌入在每一个调用处。编译时，类似宏替换，使用函数体替换调用处的函数名。一般在代码中用inline修饰，但是能否形成内联函数，需要看编译器对该函数定义的具体处理 noinline 不内联 always_inline 总是内联 这两个都是用在函数上 内联的本质是用代码块直接替换掉函数调用处,好处是:快代码的执行，减少系统开销.适用场景: 这个函数更小 这个函数不被经常调用 使用例子: //函数声明 void test(int a) __attribute__((always_inline)); #### warn_unused_result 当函数或者方法的返回值很重要时,要求调用者必须检查或者使用返回值,否则编译器会发出警告提示 - (BOOL)availiable __attribute__((warn_unused_result)) { return 10; } objc_subclassing_restricted因为某些原因,我们不希望这个类被继承,也就是 “最终”的类,用法如下: __attribute__((objc_subclassing_restricted)) @interface ViewController : UIViewController @end 如果继承了这个类,编译器会报错 objc_requires_super这个属性要求子类在重写父类的方法时,必须要重载父类方法,也就是调用super方法,否则警告.示例如下: @interface ViewController : UIViewController - (void)jump __attribute__((objc_requires_super)); @end - (void)jump{ NSLog(@&quot;父类必须先执行&quot;); } @interface SGViewController : ViewController @end @implementation SGViewController - (void)jump{ NSLog(@&quot;子类才能再执行&quot;); } @end objc_boxable实现类似于NSNumber 的快速打包能力@(…),一般对于struct,union我们只能通过NSValue将其打包. objc_boxable 可以帮助我们实现快速打包,示例如下: //自定义结构体 typedef struct __attribute__((objc_boxable)){ CGFloat x,y,width,height; }SGRect; SGRect rect = {0,0,100,200}; //这里直接打包成NSValue NSValue *value = @(rect); //这里我直接用系统的方法打印 NSLog(@&quot;%@&quot;,NSStringFromCGRect(value.CGRectValue)); 输出结果 2016-07-21 21:28:43.538 Study[14118:5408921] {{0, 0}, {100, 200}} 这样SGRect就具备快速打包功能了. constructor / destructor意思是: 构造器和析构器;constructor修饰的函数会在main函数之前执行,destructor修饰的函数会在程序exit前调用. 示例如下: int main(int argc, char * argv[]) { @autoreleasepool { NSLog(@&quot;main&quot;); return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); } } __attribute__((constructor)) void before(){ NSLog(@&quot;before main&quot;); } __attribute__((destructor)) void after(){ NSLog(@&quot;after main&quot;); } //在viewController中调用exit - (void)viewDidLoad { [super viewDidLoad]; exit(0); } 输出结果 2016-07-21 21:49:17.446 Study[14162:5415982] before main 2016-07-21 21:49:17.447 Study[14162:5415982] main 2016-07-21 21:49:17.534 Study[14162:5415982] after main 注意点: 程序退出的时候才会调用after函数,经测试,手动退出程序会执行上面两个函数不管写在哪个类里,哪个文件中效果都一样如果存在多个修饰的函数,那么都会执行,顺序不定实际上如果存在多个修饰过的函数,可以它们的调整优先级 代码如下: int main(int argc, char * argv[]) { @autoreleasepool { NSLog(@&quot;main&quot;); return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); } } __attribute__((constructor(101))) void before1(){ NSLog(@&quot;before main - 1&quot;); } __attribute__((constructor(102))) void before2(){ NSLog(@&quot;before main - 2&quot;); } __attribute__((destructor(201))) void after1(){ NSLog(@&quot;after main - 1&quot;); } __attribute__((destructor(202))) void after2(){ NSLog(@&quot;after main - 2&quot;); } 输出结果 2016-07-21 21:59:35.622 Study[14171:5418393] before main - 1 2016-07-21 21:59:35.624 Study[14171:5418393] before main - 2 2016-07-21 21:59:35.624 Study[14171:5418393] main 2016-07-21 21:59:35.704 Study[14171:5418393] after main - 2 2016-07-21 21:59:35.704 Study[14171:5418393] after main - 1 注意点: 括号内的值表示优先级,[0,100]这个返回时系统保留的,自己千万别调用.根据输出结果可以看出,main函数之前的,数值越小,越先调用;main函数之后的数值越大,越先调用.当函数声明和函数实现分开写时, 格式如下: static void before() __attribute__((constructor)); static void before() { printf(&quot;before\n&quot;); } 讨论:+load,constructor,main的执行顺序,代码如下: + (void)load{ NSLog(@&quot;load&quot;); } __attribute__((constructor)) void before(){ NSLog(@&quot;before main&quot;); } 输出结果 2016-07-21 22:13:58.591 Study[14185:5421811] load 2016-07-21 22:13:58.592 Study[14185:5421811] before main 2016-07-21 22:13:58.592 Study[14185:5421811] main 可以看出执行顺序为: load-&gt;constructor-&gt;main 为什么呢? 因为 dyld（动态链接器，程序的最初起点）在加载 image（可以理解成 Mach-O 文件）时会先通知 objc runtime 去加载其中所有的类，每加载一个类时，它的 +load 随之调用，全部加载完成后，dyld 才会调用这个 image 中所有的 constructor 方法,然后才调用main函数. enable_if用来检查参数是否合法,只能用来修饰函数: void printAge(int age) __attribute__((enable_if(age &gt; 0 &amp;&amp; age &lt; 120, &quot;你丫太监?&quot;))) { NSLog(@&quot;%d&quot;,age); } 表示只能输入的参数只能是 0 ~ 120左右,否则编译报错 cleanup声明到一个变量上，当这个变量作用域结束时，调用指定的一个函数.如果不知道什么是作用域,请先学习一下.例子: //这里传递的参数是变量的地址 void intCleanup(int *num){ NSLog(@&quot;cleanup------%d&quot;,*num); } - (void)test{ int a __attribute__((cleanup(intCleanup))) = 10; } 输出结果 2016-07-22 09:59:09.139 Study[14293:5495713] cleanup------10 注意点: 指定的函数传递的参数是变量的地址作用域的结束包括:大括号结束、return、goto、break、exception等情况当作用域内有多个cleanup的变量时,遵守 先入后出 的栈式结构. 示例代码: void intCleanup(int *num){ NSLog(@&quot;cleanup------%d&quot;,*num); } void stringCleanup(NSString **str){ NSLog(@&quot;cleanup------%@&quot;,*str); } void rectCleanup(CGRect *rect){ CGRect temp = *rect; NSString *str = NSStringFromCGRect(temp); NSLog(@&quot;cleanup------%@&quot;,str); } int a __attribute__((cleanup(intCleanup))) = 10; { NSString *string __attribute__((cleanup(stringCleanup))) = @&quot;string&quot;; CGRect rect __attribute__((cleanup(rectCleanup))) = {0,0,1,1}; } 输出结果 2016-07-22 10:09:36.621 Study[14308:5498861] cleanup------{{0, 0}, {1, 1}} 2016-07-22 10:09:36.622 Study[14308:5498861] cleanup------string 2016-07-22 10:09:36.622 Study[14308:5498861] cleanup------10 讨论:如果修饰了某个对象,那么cleanup和dealloc,谁先执行?测试代码如下: void objectCleanup(NSObject **obj){ NSLog(@&quot;cleanup------%@&quot;,*obj); } - (void)viewDidLoad { [super viewDidLoad]; ViewController *vc __attribute__((cleanup(objectCleanup))) = [[ViewController alloc] init]; } - (void)dealloc{ NSLog(@&quot;dealloc&quot;); } 输出结果 2016-07-22 10:23:08.839 Study[14319:5502769] cleanup------&lt;ViewController: 0x13fe881e0&gt; 2016-07-22 10:23:08.840 Study[14319:5502769] dealloc 可以明显看出,cleanup先于对象的dealloc执行. 在block中的用法:在block中使用,先看例子: //指向block的指针,觉得不好理解可以用typeof void blockCleanUp(void(^*block)()){ (*block)(); } void (^block)(void) __attribute__((cleanup(blockCleanUp))) = ^{ NSLog(@&quot;finish block&quot;); }; 这个好处就是,不用等到block最后才写某些代码,我们可以把它放在block的任意位置,防止忘记. overloadable用于c语言函数,可以定义若干个函数名相同，但参数不同的方法，调用时编译器会自动根据参数选择函数原型： __attribute__((overloadable)) void print(NSString *string){ NSLog(@&quot;%@&quot;,string); } __attribute__((overloadable)) void print(int num){ NSLog(@&quot;%d&quot;,num); } 输出结果 //调用 print(10); print(@&quot;哈哈&quot;); objc_runtime_name看到runtime是不是就感觉高大上,没错这个也跟运行时有关.作用是将将类或协议的名字在编译时指定成另一个.示例如下: __attribute__((objc_runtime_name(&quot;NSObject&quot;))) @interface SGObject :NSObject @end 输出结果 //调用 NSLog(@&quot;%@&quot;,[SGObject class]); //输出 2016-07-22 11:18:00.934 Study[14355:5516261] NSObject]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS——__attribute__使用与总结</tag>
        <tag>attribute__使用与总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——App启动优化分析与总结]]></title>
    <url>%2F2017%2F11%2F03%2FiOS%E2%80%94%E2%80%94App%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[随着人们对App性能与实用要求越来越高，也随着大量iOS开发中的涌入，现如今已经不再是几年前会做简单App，然后开始开发，能写出一个可用功能的产品就可以了，于是，很多公司和开发者也开始关注和实战启动优化，因为App除了桌面Log，启动是也是夺得用户喜好最首要的条件，如果一个App每次启动都要几十秒甚至几分钟，你觉得你还会继续使用吗…… 如果你对iOS开发中App的整个启动过程干兴趣，那么可以先看我之前分享的一个主题iOS——App整个启动过程分析 当然关于启动优化，上面只是简单的提了一下，本文结合那篇文章进行详细分析 启动优化准备APP启动时间： t(App总启动时间) = t1(main()之前的加载时间) + t2(main()之后的加载时间)。 t1 = 系统dylib(动态链接库)和自身App可执行文件的加载； t2 = main方法执行之后到AppDelegate类中的didFinishLaunchingWithOptions方法执行结束前这段时间，主要是构建第一个界面，并完成渲染展示。 前面我们分析了，Main之前和之后的加载过程这里我们先简单介绍一下，之前没有详细说明的一些其中关联的技术： App开始启动后，系统首先加载可执行文件（自身App的所有.o文件的集合），然后加载动态链接库dyld，dyld是一个专门用来加载动态链接库的库。执行从dyld开始，dyld从可执行文件的依赖开始, 递归加载所有的依赖动态链接库。 其实无论对于系统的动态链接库还是对于App本身的可执行文件而言，他们都算是image（镜像），而每个App都是以image(镜像)为单位进行加载的 什么是image 1.executable可执行文件 比如.o文件。 2.dylib 动态链接库 framework就是动态链接库和相应资源包含在一起的一个文件夹结构。 3.bundle 资源文件 只能用dlopen加载，不推荐使用这种方式加载。 注意：除了我们App本身的可行性文件，系统中所有的framework比如UIKit、Foundation等都是以动态链接库的方式集成进App中的。 不同进程之间共用系统dylib的_TEXT区，但是各自维护对应的_DATA区。 所有动态链接库和我们App中的静态库.a和所有类文件编译后的.o文件最终都是由dyld(the dynamic link editor)，Apple的动态链接器来加载到内存中。每个image都是由一个叫做ImageLoader的类来负责加载（一一对应） 是ImageLoader image 表示一个二进制文件(可执行文件或 so 文件)，里面是被编译过的符号、代码等， ImageLoader 作用是将这些文件加载进内存，且每一个文件对应一个ImageLoader实例来负责加载。 ImageLoader加载步骤分两步走： 在程序运行时它先将动态链接的 image 递归加载 (也就是上面测试栈中一串的递归调用的时刻)。 再从可执行文件 image 递归加载所有符号。 真正的启动优化：Main之前：检测方式：Apple提供了一种测量方法，在 Xcode 中 Edit scheme -&gt; Run -&gt; Auguments 将环境变量DYLD_PRINT_STATISTICS 设为1 pre-main阶段 1.1. 加载应用的可执行文件 1.2. 加载动态链接库加载器dyld（dynamic loader） 1.3. dyld递归加载应用所有依赖的dylib（dynamic library 动态链接库） 动态链接库的加载步骤具体分为5步： load dylibs image 读取库镜像文件 Rebase image Bind image Objc setup initializers load dylibs image在每个动态库的加载过程中， dyld需要： 分析所依赖的动态库 找到动态库的mach-o文件 打开文件 验证文件 在系统核心注册文件签名 对动态库的每一个segment调用mmap() 通常的，一个App需要加载100到400个dylibs， 但是其中的系统库被优化，可以很快的加载。 ######&gt; 针对这一步骤的优化有： 减少非系统库的依赖 尽量不使用内嵌（embedded）的dylib，加载内嵌dylib性能开销较大 合并已有的dylib和使用静态库（static archives），减少dylib的使用个数 使用静态资源，比如把代码加入主程序 懒加载dylib，但是要注意dlopen()可能造成一些问题，且实际上懒加载做的工作会更多 rebase/bind由于ASLR(address space layout randomization)的存在，可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不固定，所以需要这2步来修复镜像中的资源指针，来指向正确的地址。 rebase修复的是指向当前镜像内部的资源指针； 而bind指向的是镜像外部的资源指针。rebase步骤先进行，需要把镜像读入内存，并以page为单位进行加密验证，保证不会被篡改，所以这一步的瓶颈在IO。bind在其后进行，由于要查询符号表，来指向跨镜像的资源，加上在rebase阶段，镜像已被读入和加密验证，所以这一步的瓶颈在于CPU计算。 通过命令行可以查看相关的资源指针: xcrun dyldinfo -rebase -bind -lazy_bind myApp.App/myApp 优化该阶段的关键在于减少__DATA segment中的指针数量。 ######&gt; 我们可以优化的点有： 减少ObjC类（class）、方法（selector）、分类（category）的数量 减少C++虚函数数量（创建虚函数表有开销） 转而使用swift stuct（其实本质上就是为了减少符号的数量） Objc setup这一步主要工作是: 注册Objc类 (class registration) 把category的定义插入方法列表 (category registration) 保证每一个selector唯一 (selctor uniquing) 由于之前2步骤的优化，这一步实际上没有什么可做的。 initializers以上三步属于静态调整(fix-up)，都是在修改__DATA segment中的内容，而这里则开始动态调整，开始在堆和堆栈中写入内容。 在这里的工作有： Objc的+load()函数 C++的构造函数属性函数 形如attribute((constructor)) void DoSomeInitializationWork() 非基本类型的C++静态全局变量的创建(通常是类或结构体)(non-trivial initializer) 比如一个全局静态结构体的构建，如果在构造函数中有繁重的工作，那么会拖慢启动速度 Objc的load函数和C++的静态构造函数采用由底向上的方式执行，来保证每个执行的方法，都可以找到所依赖的动态库。 +load方法断点的调用堆栈和顺序： dyld 开始将程序二进制文件初始化 交由 ImageLoader 读取 image，其中包含了我们的类、方法等各种符号 由于 runtime 向 dyld 绑定了回调，当 image 加载到内存后，dyld 会通知 runtime 进行处理 runtime 接手后调用 mapimages 做解析和处理，接下来 loadimages 中调用 callloadmethods 方法，遍历所有加载进来的 Class，按继承层级依次调用 Class 的 +load 方法和其 Category 的 +load 方法 ######&gt; 我们可以做的优化有： 少在类的+load方法里做事情，尽量把这些事情推迟到+initiailize 减少构造器函数个数，在构造器函数里少做些事情 减少C++静态全局变量的个数 至此，可执行文件中和动态库所有的符号(Class，Protocol，Selector，IMP，…)都已经按格式成功加载到内存中，被 runtime 所管理，再这之后，runtime 的那些方法(动态添加 Class、swizzle 等等才能生效)。 到这里整个过程： 整个事件由 dyld 主导，完成运行环境的初始化后，配合 ImageLoader 将二进制文件按格式加载到内存， 动态链接依赖库，并由 runtime 负责加载成 objc 定义的结构，所有初始化工作结束后，dyld 调用真正的 main 函数。 总结优化点： 减少不必要的framework，因为动态链接比较耗时 check framework应当设为optional和required，如果该framework在当前App支持的所有iOS系统版本都存在，那么就设为required，否则就设为optional，因为optional会有些额外的检查 合并或者删减一些OC类，关于清理项目中没用到的类，使用工具AppCode代码检查功能，查到当前项目中没有用到的类如下： 删减一些无用的静态变量 删减没有被调用到或者已经废弃的方法 将不必须在+load方法中做的事情延迟到+initialize中 尽量不要用C++虚函数(创建虚函数表有开销) Main之后：检测方式：测量main()函数开始执行到didFinishLaunchingWithOptions执行结束的耗时，自己插入代码到工程。 main()阶段 2.1. dyld调用main() 2.2. 调用UIApplicationMain() 2.3. 调用applicationWillFinishLaunching 2.4. 调用didFinishLaunchingWithOptions 在main()被调用之后，App的主要工作就是初始化必要的服务，显示首页内容等。而我们的优化也是围绕如何能够快速展现首页来开展。App通常在AppDelegate类中的didFinishLaunchingWithOptions方法中创建首页需要展示的view，然后在当前runloop的末尾，主动调用CA::Transaction::commit完成视图的渲染。 而视图的渲染主要涉及三个阶段： 准备阶段 这里主要是图片的解码 布局阶段 首页所有UIView的- (void)layoutSubViews()运行 绘制阶段 首页所有UIView的- (void)drawRect:(CGRect)rect运行 再加上启动之后必要服务的启动、必要数据的创建和读取，这些就是我们可以尝试优化的地方 因此，对于main()函数调用之前我们可以优化的点有： 不使用xib，直接视用代码加载首页视图 NSUserDefaults实际上是在Library文件夹下会生产一个plist文件，如果文件太大的话一次能读取到内存中可能很耗时，这个影响需要评估，如果耗时很大的话需要拆分(需考虑老版本覆盖安装兼容问题) 每次用NSLog方式打印会隐式的创建一个Calendar，因此需要删减启动时各业务方打的log，或者仅仅针对内测版输出log 梳理应用启动时发送的所有网络请求，是否可以统一在异步线程请求 梳理各个二方/三方库，找到可以延迟加载的库，做延迟加载处理，比如放到首页控制器的viewDidAppear方法里。 梳理业务逻辑，把可以延迟执行的逻辑，做延迟执行处理。比如检查新版本、注册推送通知等逻辑。 避免复杂/多余的计算。 避免在首页控制器的viewDidLoad和viewWillAppear做太多事情，这2个方法执行完，首页控制器才能显示，部分可以延迟创建的视图应做延迟创建/懒加载处理。 采用性能更好的API。 首页控制器用纯代码方式来构建。 总结：具体优化点 纯代码方式而不是storyboard加载首页UI。 对didFinishLaunching里的函数考虑能否挖掘可以延迟加载或者懒加载，需要与各个业务方pm和rd共同check 对于一些已经下线的业务，删减冗余代码。 对于一些与UI展示无关的业务，如微博认证过期检查、图片最大缓存空间设置等做延迟加载 对实现了+load()方法的类进行分析，尽量将load里的代码延后调用。 上面统计数据显示展示feed的导航控制器页面(NewsListViewController)比较耗时，对于viewDidLoad以及viewWillAppear方法中尽量去尝试少做，晚做，不做 到这里之后其实已经差不多了，相信你应该有哪么写成就与收获。 除了这些，我们还可以喂项目做一些缓存优化 ccache 等缓存方案 优化 Xcode 配置 加钱堆硬件 以上优化方案出发点都是基础优化编译耗时来解决的。 哪有没有一个办法可以做到不编译就执行修改后的代码呢？ 答案肯定是：有的 基于 Objective-C 的动态特性，是完全可以做到这一点的，这也是各种热修复框架的支撑原理之一。那么如果需要做到不编译就执行修改后的代码，我们可以这样做： 获取本地修改后代码 -&gt; 转 JavaScript 或 Lua -&gt; 模拟器执行修改后的脚本。 获取本地修改代码 这里也有许多方法，可以手动复制，也可以自动获取。这里我是选择利用 Xcode Editor Extension 来获取到你选中的修改代码的。 Objective-C 转 JavaScript 由于整个流程我是基于 JSPatch 来开发的，所以是需要转为 JS 的脚本。这里我是写了个 node.js 的脚本来实现，转换算法是利用 https://github.com/bang590/JSPatchConvertor 中的开源代码。 模拟器执行修改后的脚本 由于已经有 JSPatch 完整的框架做支撑，这里只需要利用其中的方法 -[JPEngine evaluateScriptWithPath:] 去执行修改后的脚本即可。 当然这种有一定的缺陷，不管是针对苹果审核，还是学习成本，或者是其他意向不到的问题 使用之前还是慎重考虑，可以适当的使用作为部分模块的优化，或者作为学习。 至于后续的步骤就是，写好代码，逻辑，界面，优化…… 性能优化推荐：iOS应用性能调优的25个建议和技巧]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS——App启动优化分析与总结</tag>
        <tag>App启动优化分析与总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——防止反编译总结]]></title>
    <url>%2F2017%2F10%2F26%2FiOS%E2%80%94%E2%80%94%E9%98%B2%E6%AD%A2%E5%8F%8D%E7%BC%96%E8%AF%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[iOS开发中有一个方向叫，你想工程开发，曾经也试着话时间去研究过相关的技术，熟悉使用那些相关的工具，但是毕竟没有专门实战过项目，也就只能简单的入门一下。而随着iOS开发年限的增长，和所了解到的东西，发现有不少公司或者朋友都在关注安全这一块，虽然Apple已经把安全做得很到位了，但是还是有这一块的问题存在，所以我根据个人的能力并结合网上的相关资料，简单的整理了一下，不管是作为了解，还是项目实战，或者为了面试，我都希望能有所帮助…… 已经app store上线的程序，苹果采取DRM进行保护，这样直接使用反汇编工具IDA是提示文件加密的，但现在DRM不堪一击。 先来说说iOS开发中有那些安全风险 iOS应用安全1、内购破解： 插件法（仅越狱）、iTools工具替换文件法（常见为存档破解）、八门神器修改 2、网络安全风险： 截获网络请求，破解通信协议并模拟客户端登录，伪造用户行为，对用户数据造成危害 ​3、应用程序函数PATCH破解：​&gt; 利用FLEX 补丁软件通过派遣返回值来对应用进行patch破解 4、源代码安全风险： 通过使用ida等反汇编工具对ipa进行逆向汇编代码，导致核心代码逻辑泄漏与被修改，影响应用安全 面对这些iOS应用存在的风险，iOS应用如何防止被反编译，防止反编译防砸壳我们要分析一个 app，最开始一般是砸壳 $ DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /path/to/XXX.app/XXX 然后将解密之后的二进制文件扔给类似 hopper 这样的反编译器处理。 注意：直接将没有砸壳的二进制文件扔个 hopper 反编译出来的内容是无法阅读的（被苹果加密了） 对于这一步的防范，有两种方式。 限制二进制文件头内的段通过在 Xcode 里面工程配置 build setting 选项中将 -Wl,-sectcreate,RESTRICT,restrict,/dev/null 添加到 “Other Linker Flags” setuid 和 setgid （Apple 不接受调用这两个函数的 app，因为它可以通过查看符号表来判断您的二进制运行文件是否包含这两个函数） 检测tweak（越狱设备）我们会使用 TheOS 创建 tweak 类型的工程。然后针对我们要分析的类，使用提供的 logify.pl 命令生成的 mk 文件来打印该类所有方法的入参和出参。这对分析 app 的运行方式有很大的帮助。当然，我们也可以自己创建某个类的 mk，来 hook 某个函数，让它以我们想要的方式运行， 对于这一步的防范可以在工程的 main 函数里面加入一层判断，首先读取 /Library/MobileSubstrate/DynamicLibraries 下所有的 plist 文件的内容，查看是否某个 plist 含有你的 app 的 bundle id，是的话，可以判定有人想利用 tweak 攻击你的 app，这时候你可以采取比如说将 app 给 crash 掉，或者限制某些功能等方式来应对 就是 MobileSubstrate 在 app 加载到内存的时候会先去检查 /Library/MobileSubstrate/DynamicLibraries 下面是否有需要加载的 tweak，有的话就加载，怎么判断有没有？就是根据 plist 里面的 bundle ID 判断的。 防 http 抓包 就是将 NSURLSessionConfiguration 的 connection​Proxy​Dictionary 设置成空的字典，因为这个属性就是用来控制会话的可用代理的。 但是由于 OC 方法很容易被 hook，避免抓包是不可能的，所以，个人认为最好的方式是对请求参数进行加密（最好是非对称加密，比如 RSA） 加密硬编码的明文字符串 你的 app 被人抓包了，某些数据请求接口也被人发现了，那么很简单，逆向人员可以直接拷贝特征比较明显的字符串到 hopper 中搜索，通过查看该字符串被引用的地方，可以很快的找到相应的逻辑代码。 对于这一步的防范需要做的就是对硬编码的明文进行加密或混淆。 有个开源代码可以用，UAObfuscatedString，但是这个开源混淆代码写出来的字符串是相当长的（也就是麻烦），同时不支持加密,还有一个不错的MixPlainText（可以在编译期间加密所有代码中的明文字符串，在 app 运行的时候解密字符串） 使用 Swift 开发 class-dump 工具目前就不支持含有 Swift 的二进制文件。 TheOS 也是最近才开始支持 Swift，但是还没有加到主分支上（可以参见 Features）。所以目前来看，至少 Swift 可能比纯 OC 的工程要安全一点点 使用静态内连 C 函数由于 OC 语言的动态性，导致 OC 的代码是最容易被破解分析的。在安全性上，更推荐使用 C 语言写成的函数。但是 C 语言的函数也是可以被 hook 的，主要有3种方式： 使用 Facebook 开源的 fishhook 使用 MobileSubstrate 提供的 hook C 语言函数的方法 void MSHookFunction(void function, void replacement, void** p_original); 使用 mach_override，关于 mach_override 和 fishhook 的区别请看 mach_override 和 fishhook 区别 由于上面这三种方式可以 hook C 函数。要想不被 hook 解决方法是使用静态内联函数，这样的话需要被 hook 的函数没有统一的入口，逆向人员想要破解只能去理解该函数的逻辑。 使用 block严格来说使用 block 并不能很大程度提高安全性，因为逆向人员只要找到使用该 block 的方法，一般来说在其附近就会有 block 内代码的逻辑。 其实使用 block 的安全性是比直接使用 oc 方法是要高的。尤其是含有嵌套的 block 或者是作为参数传递的 block，处理起来就更加复杂了。所以，如果能将内敛 C 函数，嵌套 block ， block 类型参数组合起来的话，安全性应该是会有一定提升。 代码混淆（或者加密）方法体，方法名高级混淆 对应用程序的方法名和方法体进行混淆，保证源码被逆向后无法解析代码 程序结构混排加密 对应用程序逻辑结构进行打乱混排，保证源码可读性降到最低 本地数据加密 对NSUserDefaults，sqlite存储文件数据加密，保护帐号和关键信息 URL编码加密i 对程序中出现的URL进行编码加密，防止URL被静态分析 网络传输数据加密 对客户端传输数据提供加密方案，有效防止通过网络接口的拦截获取数据 代码混淆的方式有几种 添加无用又不影响逻辑的代码片段，迷糊逆向人员 对关键的类、方法，命名成与真实意图无关的名称 对于第二种，目前有一些自动化工具,个人认为最好的一个加密混淆工具是 ios-class-guard，不过目前这个项目已经停止维护了。但是这种方式的混淆我觉得才是最终极的方案。 念大婶在博客中介绍了两种方法，用于保护代码逻辑，对抗逆向分析 代码混淆 通过宏定义，混淆objective-c消息(函数)，用于对抗class-dump。 敏感逻辑用C实现 通过static关键字和函数指针的方式，将关键逻辑隐藏，可以对抗class-dump和Cycript攻击。 其实只有成功的应用才会被反编译资源。。。如果应用知名度不够高或者没什么用户量的话，无需浪费时间避免反编译，而是花时间、精力和金钱来迭代版本和推广App！ ######相关链接推荐 iOS程序 防止动态调试和代码注入 对 iOS app 进行安全加固 iOS 安全 之 方法混淆 iOS 对源代码进行混淆 iOS代码混淆]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS——防止反编译总结</tag>
        <tag>防止反编译总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——最新高级面试题整理（阿里篇）]]></title>
    <url>%2F2017%2F10%2F25%2FiOS%E2%80%94%E2%80%94%E6%9C%80%E6%96%B0%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E9%98%BF%E9%87%8C%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近有朋友和同事在找工作，也问了一些相关的iOS技术问题，虽然今时不如往日，但是面试与面试之前的准备还是要做足的，即使我不用面试，但是我还是经常关注着一块的内容，就当回顾技术点和广度学习。最近有个朋友发了一串面试题给我，说是阿里的，听起来好高大上的样子，于是开始看了一下题目，看完后，顿时不知所措…… 具体问题 1.dSYM你是如何分析的？ 2.多线程有哪几种？你更倾向于哪一种？ 3.单例弊端？ 4.如何把异步线程转换成同步任务进行单元测试？ 5.介绍下App启动的完成过程？ 6.比如App启动过慢，你可能想到的因素有哪些？ 7.0x8badf00d表示是什么？ 8.怎么防止反编译？ 9.说说你遇到到的技术难点？ 10.说说你了解的第三方原理或底层知识？ 11.介绍下内存的几大区域？ 12.你是如何组件化解耦的？ 13.runtime如何通过selector找到对应的IMP地址 14.runloop内部实现逻辑？ 15.你理解的多线程？ 16.GCD执行原理？ 17.怎么防止别人动态在你程序生成代码 18.YYAsyncLayer如何异步绘制？ 19.优化你是从哪几方面着手？ 看完之后我相信你知道我为什么，顿时不知所措。 其实很多东西我们都知道，或者能说出一二，又或者用过，研究过，但是仔细回想一下，发现大部分问题的大部分答案或者内容都已经忘得差不多了 于是网上寻找并结合自己实际理解整理了一下 这是知乎上的部分答案: 阿里面试题 如果你想寻找各大互联网公司的面试题，请戳这里 各大互联网公司的面试题 1.dSYM你是如何分析的？Xcode编译项目后，我们会看到一个同名的 dSYM 文件，dSYM 是保存 16 进制函数地址映射信息的中转文件——称为符号表文件 http://www.cnblogs.com/quansir/p/5539682.htmlhttp://blog.csdn.net/openglnewbee/article/details/38824139 2.多线程有哪几种？你更倾向于哪一种？http://www.cocoachina.com/ios/20150731/12819.html 3.单例弊端？由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。 单例类的职责过重，在一定程度上违背了“单一职责原则”。 因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。 现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的共享对象长时间不被利用， 系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致共享的单例对象状态的丢失。 4.如何把异步线程转换成同步任务进行单元测试？http://www.cnblogs.com/goodboy-heyang/p/5277910.html 5.介绍下App启动的完成过程？https://icocos.github.io/2017/06/28/iOS%E2%80%94%E2%80%94App%E6%95%B4%E4%B8%AA%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/ 6.比如App启动过慢，你可能想到的因素有哪些？https://www.zhihu.com/question/19823199http://blog.csdn.net/Tencent_Bugly/article/details/77363817?locationNum=1&amp;fps=1 7.0x8badf00d表示是什么？异常代码 0x8badf00d 指示应用程序已终止的 iOS 因为看门狗超时发生。 应用程序时间太长，启动、 终止，或对系统事件作出响应。 一个常见的原因做在主线程上的同步联网。无论操作是线程 0 上： 需要搬到后台线程，或处理方式不同，所以，它不会阻止在主线程。 http://www.cnblogs.com/smileEvday/p/Crash1.htmlhttps://developer.apple.com/library/content/technotes/tn2151/_index.html#//apple_ref/doc/uid/DTS40008184-CH1-APPINFO 8.怎么防止反编译？http://blog.sina.com.cn/s/blog_134451adb0102wduz.htmlhttp://blog.sina.com.cn/s/blog_12f70aa790102vfd9.html 9.说说你遇到到的技术难点？http://blog.csdn.net/johnny_nass_hu/article/details/50854143http://www.cnblogs.com/ywr-zf/p/5917772.html 10.说说你了解的第三方原理或底层知识？https://github.com/Draveness/analyze 11.介绍下内存的几大区域？http://www.jianshu.com/p/5054c6932bdbhttps://www.baidu.com/link?url=CilnOv5mL3MVF50415d0SjkFgRpq_iNaZ44_Jiu1_1AQIi_qFqLMzvaRzqVoIUyI&amp;wd=&amp;eqid=f8f0a387000453cb0000000659f066f9http://www.cnblogs.com/chenjiangxiaoyu/p/7723154.html 12.你是如何组件化解耦的？http://blog.csdn.net/GGGHub/article/details/52713642https://www.2cto.com/kf/201611/552444.html 13.runtime如何通过selector找到对应的IMP地址http://blog.csdn.net/dp948080952/article/details/52437451 14.runloop内部实现逻辑？http://www.jianshu.com/p/1154df5d866fhttp://www.cocoachina.com/ios/20150601/11970.html 15.你理解的多线程？http://www.jianshu.com/p/5e96759a941b 16.GCD执行原理？http://www.jianshu.com/p/5840523fb3eahttp://www.cocoachina.com/bbs/read.php?tid-459704.html 17.怎么防止别人动态在你程序生成代码http://ruixiazun.blog.163.com/blog/static/9068791820141173588694/ 18.YYAsyncLayer如何异步绘制？http://ios.jobbole.com/86878/http://www.cnblogs.com/sunshine-anycall/p/7674021.html?utm_source=tuicool&amp;utm_medium=referral 19.优化你是从哪几方面着手？https://zhidao.baidu.com/question/181762176405714684.htmlhttps://www.2cto.com/kf/201505/401059.htmlhttps://zhidao.baidu.com/question/563610078113818364.htmlhttp://cache.baiducontent.com/c?m=9d78d513d9981cee4fede5697b17c0171e43f0132ba4a4027ea4843995732c40506793ac56510775d6d27d1716df4f4b9cf12173471451b18cb98e5ddccb85585e9f573e671df65662d60edfbd5154c037e75efeae69f0ccf525e2a9c5d2af4322b944737e94b7cb040f4e8c29b2033090bb840d501a07ba9a683eac053673d83440c116a4bf2f2c1a8aa7db5b4e942dd3611397ad&amp;p=8e6ac64ad4d000fa08e2977e085c8e&amp;newp=8f7f8f15d9c041aa0db8cf2d0214c1231610db2151d4da136b82c825d7331b001c3bbfb42324150ed2c77f6507ad485cebf232773c0127a3dda5c91d9fb4c57479dd726f&amp;user=baidu&amp;fm=sc&amp;query=iOS+%D3%C5%BB%AF%C4%E3%CA%C7%B4%D3%C4%C4%BC%B8%B7%BD%C3%E6%D7%C5%CA%D6%3F&amp;qid=82c11955000459a8&amp;p1=2 由于时间的原因，暂时先整理到这里，只是网上寻找了一些相关而且还不错的链接， 后期会专门抽时间整理这些问题 望谅解……]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS——最新高级面试题整理（阿里篇）</tag>
        <tag>最新高级面试题整理（阿里篇）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——CocoaPods私有化组件]]></title>
    <url>%2F2017%2F10%2F25%2FiOS%E2%80%94%E2%80%94CocoaPods%E7%A7%81%E6%9C%89%E5%8C%96%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[相信你能看到这里，就一定用过cocoapods，cocoapods是什么呢？怎么用？算了吧，都是本文的范围，这里只介绍怎么将自己的项目组件进行私有化，其实严格来说不算什么私有化，只是，想自己写好的框架放到github或者其他平台上让他支持cocoapods管理。这类文章网上已经随处可见，但是由于打算开始写自己的框架，就记录了一下….. 首推荐 用CocoaPods做iOS程序的依赖管理 深入理解 CocoaPods CocoaPods 都做了什么? 如果你还不知道sm是CocoaPods，或者想对CocoaPods了解更深入一点的，可以先看看上面的推荐 1. 在github创建仓库完成，然后将仓库检出到本地注意创建事项： LICENSE(许可证)文件不可缺少，否则检测spec文件时，会有警告（选择MIT就OK） 不要使用中文，最好和库名字直接对应 其实也可以在其他平台，不一定是github 2. 将写好开源框架/库的Demo或者Example放到Git仓库下，还要将要开源的文件夹也放入到git仓库中（该文件夹在后面会被用到） 3. 项目发布到github后，我们在工程根目录中初始化一个Podspec文件：创建自己项目的Podspec描述文件: pod spec create iCocos 4. 编辑修改iCocos.podspec对应信息 可以直接参照我的内容进行修改 具体内容不介绍 s.name：名称，pod search 搜索的关键词,注意这里一定要和.podspec的名称一样,否则报错 s.version：版本号 s.ios.deployment_target:支持的pod最低版本 s.summary: 简介 s.homepage:项目主页地址 s.license:许可证 s.author:作者 s.social_media_url:社交网址,这里我写的微博默认是Twitter,如果你写Twitter的话,你的podspec发布成功后会@你 s.source:项目的地址 s.source = { :git =&gt; “https://github.com/al1020119/iCocos.git&quot;, :commit =&gt; “68defea” } s.source = { :git =&gt; “https://github.com/al1020119/iCocos.git&quot;, :tag =&gt; 1.0.0 } s.source = { :git =&gt; “https://github.com/al1020119/iCocos.git&quot;, :tag =&gt; s.version } commit =&gt; “68defea” 表示将这个Pod版本与Git仓库中某个commit绑定 tag =&gt; 1.0.0 表示将这个Pod版本与Git仓库中某个版本的comit绑定 tag =&gt; s.version 表示将这个Pod版本与Git仓库中相同版本的comit绑定 s.source_files:需要包含的源文件 s.resources: 资源文件 s.requires_arc: 是否支持ARC s.dependency：依赖库，不能依赖未发布的库，如 s.dependency = ‘AFNetworking’ s.dependency：依赖库，如有多个可以这样写。我这里是托管在github上,所以这里将地址copy过来就行了。 source_files: 核心代码的文件地址。 这里是经常出错的地方！—如果使用的是这种方式来显示核心代码地址而不是下面的模块化的话， 需要将代码文件必须以仓库名命名（也就意味着最多只有两个文件.h和.m文件了，可以有一个.h文件，把它作为头文件就行），这种方式检验podspec文件有点严格，否则就会报错。 source_files:写法及含义建议大家写第一种或者第二种 &quot;YJSettingTableView/* &quot;&quot;YJSettingTableView/YJSettingTableView/*.{h,m}&quot; &quot;YJSettingTableView/**/*.h&quot; “*” 表示匹配所有文件 “*.{h,m}” 表示匹配所有以.h和.m结尾的文件 “**” 表示匹配所有子目录 5. 设置tag号，提交修改（注：只要spec文件被修改，就必须重新执行如下命令）因为cocoapods是依赖tag版本的,所以必须打tag,以后再次更新只需要把你的项目打一个tag然后修改.podspec文件中的版本接着提交到cocoapods官方就可以了,提交命令请看下面 git commit -m “Release 1.0.0” (先提交当前修改) git tag “v1.0.0” (添加tag) //为git打tag, 第一次需要在前面加一个v git push –tags (推送tag到远程) git push origin master (推送到远程到代码仓库) 或许可能有些没有加入的（执行 git add . 就可以） 6. 提交之前先验证.podspec文件是否合法 pod spec lint iCocos.podspec –verbose pod spec lint iCocos.podspec –allow-warnings (忽略警告) 我这边在验证的时候出现了下面错误 LiudeMacBook:iCocos a115$ pod spec lint iCocos.podspec –verbose -&gt; iCocos (1.0.0) - ERROR | license: Sample license type. - ERROR | description: The description is empty. - ERROR | [iOS] unknown: Encountered an unknown error (The `iCocos` pod failed to validate due to 2 errors. [!] The validator for Swift projects uses Swift 3.0 by default, if you are using a different version of swift you can use a `.swift-version` file to set the version for your Pod. For example to use Swift 2.3, run: `echo &quot;2.3&quot; &gt; .swift-version`: - ERROR | license: Sample license type. - ERROR | description: The description is empty. ) during validation. Analyzed 1 podspec. [!] The spec did not pass validation, due to 3 errors. [!] The validator for Swift projects uses Swift 3.0 by default, if you are using a different version of swift you can use a `.swift-version` file to set the version for your Pod. For example to use Swift 2.3, run: `echo &quot;2.3&quot; &gt; .swift-version`. 根据上面提示了三个错误（due to 3 errors），其实是两个，1，3是一个 1. description is empty这里原始description是这样的 `s.description = &lt;&lt;-DESC` `DESC` 需要改成一段属于自己的描述，其他信息类型修改 关于swift-version 这里直接执行echo &quot;2.3&quot; &gt; .swift-version就正常的 但是据需验证又出现如下错误： LiudeMacBook:iCocos a115$ pod spec lint iCocos.podspec -&gt; iCocos (1.0.0) - ERROR | [iOS] unknown: Encountered an unknown error ([!] /usr/bin/git clone https://github.com/al1020119/iCocos.git /var/folders/4z/d12mnyfx7c37vg91t8h0941h0000gp/T/d20171025-8857-1oau87 --template= --single-branch --depth 1 --branch 1.0.0 Cloning into &apos;/var/folders/4z/d12mnyfx7c37vg91t8h0941h0000gp/T/d20171025-8857-1oau87&apos;... warning: Could not find remote branch 1.0.0 to clone. fatal: Remote branch 1.0.0 not found in upstream origin ) during validation. Analyzed 1 podspec. [!] The spec did not pass validation, due to 1 error. 这里其实不是错误，是没有更新处理，前面说了： （注：只要spec文件被修改，就必须重新执行如下命令） git commit -m &quot;Release 1.0.0&quot; (先提交当前修改) git tag 1.0.0 (添加tag) git push --tags (推送tag到远程) git push origin master (推送到远程到代码仓库) 或许可能有些没有加入的（执行 git add . 就可以） 7. 然后再次验证就会成功 LiudeMacBook:iCocos a115$ pod spec lint iCocos.podspec –verbose -&gt; iCocos (1.0.0) Analyzed 1 podspec. iCocos.podspec passed validation. 或许你还可能遇到下面的错误，不过不要慌，直接按照下面操作就可以 先删除tag // 删除本地tag git tag -d 1.0.0 // 删除远程tag git push origin -d tag 1.0.0 修改spec文件（必须修改相应的version和source）重新执行–&gt;设置tag号，提交修改的步骤 8. trunk推送podspec文件podspec文件验证成功，通过trunk推送podspec文件 pod trunk push iCocos.podspec 如果你是第一次，并且没有帐号你会看到下面一段 LiudeMacBook:iCocos a115$ pod trunk push iCocos.podspec [!] You need to register a session first. Usage: $ pod trunk push [PATH] Publish the podspec at `PATH` to make it available to all users of the ‘master’ spec-repo. If `PATH` is not provided, defaults to the current directory. Before pushing the podspec to cocoapods.org, this will perform a local lint of the podspec, including a build of the library. However, it remains *your* responsibility to ensure that the published podspec will actually work for your users. Thus it is recommended that you *first* try to use the podspec to integrate the library into your demo and/or real application. If this is the first time you publish a spec for this pod, you will automatically be registered as the ‘owner’ of this pod. (Note that ‘owner’ in this case implies a person that is allowed to publish new versions and add other ‘owners’, not necessarily the library author.) Options: --allow-warnings Allows push even if there are lint warnings --use-libraries Linter uses static libraries to install the spec --swift-version=VERSION The SWIFT_VERSION that should be used to lint the spec. This takes precedence over a .swift-version file. --skip-import-validation Lint skips validating that the pod can be imported --skip-tests Lint skips building and running tests during validation --silent Show nothing --verbose Show more debugging information --no-ansi Show output without ANSI codes --help Show help banner of specified command 根据上面的提示是告诉你：需要你用邮箱注册一个trunk 9. 我们直接使用终端注册pod trunk register al10201119@163.com &quot;iCocos&quot; --description=&quot;iCocos&quot; 之后会有一封带有验证链接的邮件发送到你输入的邮箱，点击验证后就可以回来终端继续提交操作了。 已经注册过的不需要注册,怎么看自己有没有注册 pod trunk me 10. 发布代码到cocoapodspod trunk push iCocos.podspec --verbose pod trunk push iCocos.podspec --allow-warnings 发布时会验证 Pod 的有效性，如果你在手动验证 Pod 时使用了 –use-libraries 或 –allow-warnings 等修饰符，那么发布的时候也应该使用相同的字段修饰，否则出现相同的报错。 pod trunk push iCocos.podspec –verbose 一段很长的描述，然后你会看到下面的成功提示 11. 如果提交到cocoapods还有可能遇到下面错误：Updating spec repo &apos;master&apos; warning: inexact rename detection was skipped due to too many files. warning: you may want yo set your diff.renameLimit variable to at least 3080 an retry the command ... [!] There was an error pushing a new version to trunk: execution expired 这里有解决方案：http://www.sw33tcode.com/?p=31 git config merge.renameLimit 999999 git config --unset merge.renameLimit 12. 然后开始去搜索我的库了但是发现既然没有，各种排查，最后发现由于延时的问题，不过如果还是不出现的，网上找到了相应的方案： 删除~/Library/Caches/CocoaPods目录下的search_index.json文件 pod setup成功后会生成~/Library/Caches/CocoaPods/search_index.json文件。 终端输入rm ~/Library/Caches/CocoaPods/search_index.json 删除成功后再执行pod search 稍等片刻，然后pod search就会出现你所要搜的类库了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS——CocoaPods私有化组件</tag>
        <tag>CocoaPods私有化组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——Objective-C与Swift优缺点对比]]></title>
    <url>%2F2017%2F09%2F19%2FiOS%E2%80%94%E2%80%94Objective-C%E4%B8%8ESwift%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[最近有个朋友（同事）在找工作，一起讨论关于面试过程中的面试题，有不少关于Objective-C的技术问题，尤其是关于一些技术的底层实现，当然这个在之前的文章中有整理，其中有一个问题就是关于Objective-C和Swift区别，与优缺点的对比，由于我刚使用Swift实战开发并不久，过去三年多都都是搞Objective-C，所以对Swift和Objective-C优缺点还真没有多少简介，虽然网上也有不少相关的资料和回答，但是想想这个问题以后再很多打算或者还没有开始使用Swift的公司会被经常问到，所以就花了点时间整理一下………. 简介Swift，苹果于2014年WWDC（苹果开发者大会）发布的新开发语言（已开源），可与Objective-C*共同运行于Mac OS和iOS平台，用于搭建基于苹果平台的应用程序。 动态性Swift 是一种强类型语言。类型静态，也就是说 Swift 的默认类型是非常安全的。 Swift 当中存在有这两个修饰符@objc和@dynamic，此外我们同样还可以访问NSObject。 @objc将您的 Swift API 暴露给 Objective-C 运行时，但是它仍然不能保证编译器会尝试对其进行优化。 如果您真的想使用动态功能的话，就需要使用@dynamic。一旦您使用了@dynamic修饰符之后，就不需要添加@objc了，因为它已经隐含在其中。 Swift比Objective-C有什么优势？ Swift容易阅读，语法和文件结构简易化。 Swift更易于维护，文件分离后结构更清晰。 Swift更加安全，它是类型安全的语言。 Swift代码更少，简洁的语法，可以省去大量冗余代码 Swift速度更快，运算性能更高。 Swift目前存在的缺点 版本不稳定，之前升级Swift3大动刀，苦了好多人，swift4目前还未知 使用人数比例偏低，目前还是OC的天下 社区的开源项目偏少，毕竟OC独大好多年，很多优秀的类库都不支持Swift，不过这种状况正在改变，现在有好多优秀的Swift的开源类库了 公司使用的比例不高，很多公司以稳为主，还是在使用OC开发，很少一些在进行混合开发，更少一些是纯Swift开发。 偶尔开发中遇到的一些问题，很难查找到相关资料，这是一个弊端。 纯Swift的运行时和OC有本质区别，一些OC中运行时的强大功能，在纯Swift中变无效了。 对于不支持Swift的一些第三方类库，如果非得使用，只能混合编程，利用桥接文件实现。 整体总结 String： Swift中String操作已经甩OC三百万条街 泛型： Swift泛用性还是不够强，如果项目不止涉及常用的http啊xmpp啊之类的协议，而是要做一些SIP啊FFMPEG啊之类的干活，那明显是OC成熟得多 Discriminated Union swift里的enum. 是静态语言独有的特性. 安全： 由于swift的strong static type system，编译器可帮你检查出更多问题，而不是在运行时突然boom，还有一个很牛逼的安全特性就是OptionalType。 快速： 静态相对来说语言本身速度更快，swift编译期就能生成vtable，确定具体要调用的方法，比起oc的动态派发自然是更快，当然处理到与oc之间桥接部分，可能不一定比oc快 细节使用区别 在 Swift 中没有了 main.m，@UIApplicationMain 是程序入口 swift不分.h和.m文件 ，一个类只有.swift一个文件，所以整体的文件数量比起OC有一定减少。 swift句尾不需要分号 ，除非你想在一行中写三行代码就加分号隔开。 在 Swift 中，一个类就是用一对 { } 括起的，没有 @implementation 和 @end swift数据类型都会自动判断 ， 只区分变量var 和常量let 强制类型转换格式不同 OC强转：(int)a Swift强转：Int(a) 关于BOOL类型更加严格 ，Swift不再是OC的非0就是真，而是true才是真false才是假 swift的 循环语句中必须加{}就算只有一行代码也必须要加 swift的switch语句后面可以跟各种数据类型了 ，如Int、字符串都行，并且里面不用写break（OC好像不能字符串） swift if后的括号可以省略: if a&gt;b {}，而OC里 if后面必须写括号。 swift打印 用print(&quot;&quot;) 打印变量时可以 print(&quot;\(value)&quot;)，不用像OC那样记很多%@，d%等。 Swift3的【Any】可以代表任何类型的值，无论是类、枚举、结构体还是任何其他Swift类型，这个对应OC中的【id】类型。 在 OC 中 alloc / init 对应( ) 在 OC 中 alloc / initWithXXX 对应 (XXX: ) 在 OC 中的类函数调用，在 Swift 中，直接使用 . 在 Swift 中，绝大多数可以省略 self.，建议一般不写，可以提高对语境的理解（闭包时会体会到） 在 OC 中的 枚举类型使用 UIButtonTypeContactAdd，而 Swift 中分开了，操作热键：回车-&gt; 向右 -&gt;. Swift 中，枚举类型的前缀可以省略，如：.ContactAdd，但是：很多时候没有智能提示 监听方法，直接使用字符串引起 循环引用问题Objective-C中循环引用也是遇到比较多的，一不小心就会导致循环引用，甚至导致内存问题 Swift [weak self] self是可选项，如果self已经被释放，则为nil [unowned self] self不是可选项，如果self已经被释放，则出现野指针访问 Objective-C __weak typeof(self) weakSelf; 如果self已经被释放，则为nil __unsafe_unretained typeof(self) weakSelf; 如果self已经被释放，则出现野指针访问 参考：推荐几个Objective-C的框架 FBRetainCycleDetector PLeakSniffer MLeaksFinder]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS——Objective-C与Swift优缺点对比</tag>
        <tag>Objective-C与Swift优缺点对比</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发——SVG图展示方案]]></title>
    <url>%2F2017%2F09%2F14%2FiOS%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94SVG%E5%9B%BE%E5%B1%95%E7%A4%BA%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[最近，接到了一个需求，关于iOS中加载SVG图片的实现，就我了解苹果是没有提供这种API直接加载SVG图片的，但是发现网上有各种资料和相关库的实现，于是为了实现这个需求专门了解了一下，虽然最后没有用到牛逼的技术，或者没有话太多时间在SVG的解析上，但是这一路也折腾的挺累的，于是就有了这篇文章 SVG简介首先我们来看看上面是SVG svg 可缩放的矢量图形 SVG 可伸缩矢量图形 (Scalable Vector Graphics) SVG 文件是纯粹的 XML SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失 简单的说就是svg格式的图不会随着图片的缩放出现模糊、svg图实际是xml格式的，可以通过代码获取各种element 参考资料：http://www.ibm.com/developerworks/cn/web/wa-scalable/ SVG相关库由于在ios中源生的api没有提供相关的操作，但是可喜的是有第三方库提供了操作：SVGKit 使用SVGKit库显示svg图： 1、使用SVGKit库显示svg图 2、实现svg图的缩放操作 3、点击svg图的某个部分，获取svg图的某个部分 SVGKit的地址：https://github.com/SVGKit/SVGKit代码中集成SVGKit参考：http://stackoverflow.com/questions/3520977/build-fat-static-library-device-simulator-using-xcode-and-sdk-4/3647187#3647187 SVGKit是一个非常强大的，可以快速渲染SVG文件的框架，由Matt Rajca开发。你可以直接把SVG文件加载至app中，并且SVG中的每个图形会变成一个CAShapeLayer，可以方便地进行缩放和动画你的图形。SVGKit包含iOS和Mac示例，不过不支持渐变。可以从github上查看使用说明、示例以及下载相关的类。如果你想渲染app中的矢量图形，SVGKit是个不错的解决办法。 SVG图片加载加载网络文件目前来说，苹果相册并不支持SVG的存储，但是由于公司考虑到用户可能在PC端上传对应的SVG文件到服务器，当在客户端操作相册或者需要上传SVG图片的时候，就需要将用户上传到服务器的SVG获取并显示到界面，以供用户上传SVG的初衷。 一路来其实考虑了各种方案，但是由于目前还没有找到特别符合项目，特别好，而且是Swift版的库，就选择的使用WebView来直接加载SVG 上代码 if (isSVG) { self.webView = [[WebView alloc] initWithConfiguration:nil]; self.webView.frame = CGRectMake(index * CGRectGetWidth(visibleBounds), 0, CGRectGetWidth(visibleBounds), CGRectGetHeight(visibleBounds)); self.webView.autoresizingMask = UIViewAutoresizingFlexibleHeight | UIViewAutoresizingFlexibleWidth; self.webView.contentMode = UIViewContentModeRedraw; self.webView.opaque = YES; self.webView.allowsBackForwardNavigationGestures = NO; // 解决本地文件svg模拟器能正常打开，真机无法打开白屏问题 if ([originURL isFileURL]) { SEL sel = NSSelectorFromString(@&quot;loadFileURL:allowingReadAccessToURL:&quot;); if ([self.webView respondsToSelector:sel]) { NSString* directory = [originURL.absoluteString stringByDeletingLastPathComponent]; SEL myMethod = @selector(loadFileURL:allowingReadAccessToURL:); // 返回一个方法 如果那个方法找不到则返回nil NSMethodSignature *signature = [[WKWebView class] instanceMethodSignatureForSelector:myMethod]; NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature]; [invocation setSelector:myMethod]; NSURL *loadFileURL = originURL; NSURL *allowingReadAccessToURL = [NSURL URLWithString:directory]; //注意：1、这里设置参数的Index 需要从2开始，因为前两个被selector和target占用。下面这样写也没有任何 [invocation setArgument:&amp;loadFileURL atIndex:2]; [invocation setArgument:&amp;allowingReadAccessToURL atIndex:3]; invocation.target = self.webView; [invocation invoke]; } else { // load the passed in URL [self.webView loadRequest:[NSURLRequest requestWithURL:originURL]]; } } else { [self.webView loadRequest:[NSURLRequest requestWithURL:originURL]]; } [view addSubview:self.webView]; self.photoCurrentModel = ((UDPhotoModel *)obj); if (index == 0) { self.webView.tag = 10000; } else { self.webView.tag = 0; } // 长安弹出手势 UILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(handleLongPressWebImage:)]; longPress.minimumPressDuration = 1; longPress.delegate = self; [self.webView addGestureRecognizer:longPress]; // 单击手势 UITapGestureRecognizer *tapWeb = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(handleTapWebImage:)]; tapWeb.delegate = self; [self.webView addGestureRecognizer:tapWeb]; // 轻扫手势 UIPanGestureRecognizer *panWebImageBack = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(panWebImageBackAction:)]; panWebImageBack.delegate = self; [self.webView addGestureRecognizer:panWebImageBack]; } 交互操作的实现由于根据项目的需求，我们需要对SVG图片进行一个操作，但是本身使用WebView加载的SVG，因此只能使用手势的方式，增加对他的交互 /** * 要想让点击手势起作用需要实现 * 如果第一个手势是点击第二个是长按就返回NO 不支持同时响应长按和点击手势 */ - (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer { if ([otherGestureRecognizer isKindOfClass:[UILongPressGestureRecognizer class]] &amp;&amp; [gestureRecognizer isKindOfClass:[UITapGestureRecognizer class]]) { return NO; } else { return YES; } } - (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation{ // 不执行前段界面弹出列表的JS代码 [self.webView evaluateJavaScript:@&quot;document.documentElement.style.webkitTouchCallout=&apos;none&apos;;&quot; completionHandler:nil]; } -(void)panWebImageBackAction:(UIPanGestureRecognizer *)gest{ if (gest.state == UIGestureRecognizerStateChanged) { [self commitTranslation:[gest translationInView:gest.view] tagIndex:gest.view.tag]; } } /** * 判断手势方向 * * @param translation translation description */ - (void)commitTranslation:(CGPoint)translation tagIndex:(NSInteger)tagIndex { CGFloat absX = fabs(translation.x); CGFloat absY = fabs(translation.y); // 设置滑动有效距离 if (UIUserInterfaceIdiomIsPad()) { if (MAX(absX, absY) &lt; 300) return; } else { if (MAX(absX, absY) &lt; 150) return; } if (absX &gt; absY ) { if (translation.x&lt;0) { //向左滑动 }else{ //向右滑动 } } else if (absY &gt; absX) { if (translation.y&lt;0) { //向上滑动 }else{ //向下滑动 } } } // 单击 - (void)handleTapWebImage:(UITapGestureRecognizer *)sender { } // 长按 - (void)handleLongPressWebImage:(UILongPressGestureRecognizer *)sender{ } 加载本地文件加载本地SVG的时候，其实和加载本地的html，pdf等式一样的，打开之后完全是一个网页 具体如下： NSString *svgName = @&quot;svg名称&quot;; NSString *svgPath = [[NSBundle mainBundle] pathForResource:svgName ofType:nil]; NSData *svgData = [NSData dataWithContentsOfFile:svgPath]; NSString *reasourcePath = [[NSBundle mainBundle] resourcePath]; NSURL *baseUrl = [[NSURL alloc] initFileURLWithPath:reasourcePath isDirectory:true]; UIWebView *webView = [[UIWebView alloc] init]; webView.frame = CGRectMake(0, 0, width, height); [webView loadData:svgData MIMEType:@&quot;image/svg+xml&quot; textEncodingName:@&quot;UTF-8&quot; baseURL:baseUrl]; 总结：如果想要交互并且放大缩小，难度就大了，然后我就百度了下，发现了个好东西SVGKit 由于项目的原因，暂时只能考虑使用WebView来实现了，后期有机会专门研究一下SVG的加载过程或者将它替换成使用库的方式当然，我也希望苹果能够增加对SVG的支持，哈哈！ 误操作考虑到WebView默认的特性是，所有内容会直接放在左上角，如果你没有对她进行一些适应的话于是我想到了，之前用WebView加载HTML的方式，去执行JS代码将它居中，以控制内部内容居中 [webView evaluateJavaScript:@&quot;Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight)&quot; completionHandler:^(id _Nullable result, NSError * _Nullable error) { if (!error) { } }]; 不执行前段界面弹出列表的JS代码 [webView evaluateJavaScript:@&quot;document.documentElement.style.webkitTouchCallout=&apos;none&apos;;&quot; completionHandler:nil]; // 执行JS，是WebView内容剧中，边距自适应：这里无效，具体原因不明， // 预览同张svg图片两端预览效果不一致(https://yun.115.com/5/T339573.html#) [webView evaluateJavaScript:@&quot;document.getElementsByTagName(&apos;body&apos;)[0].style.verticalAlign = &apos;middle&apos;;&quot; completionHandler:nil]; [webView evaluateJavaScript:@&quot;document.getElementsByTagName(&apos;body&apos;)[0].style.textAlign = &apos;center&apos;;&quot; completionHandler:nil]; [webView evaluateJavaScript:@&quot;document.getElementById(&apos;mapid&apos;).style.margin = &apos;auto&apos;;&quot; completionHandler:nil]; 但是发现并没有什么卵用，试了好久才发现自己，傻逼了，SVG是XML格式的，并不能像HTML一样，使用JS去执行对应的DOC操作于是，就停下了。 直到现在暂时还没有找到对应的方案，由于Android能够控制SVG居中适应，导致我这边有一个区配合Android的Bug如果您知道怎么处理或者有什么好的方案，欢迎联系我，或者有什么好的建议和简介，我们可以一起交交流与学习。 参考http://www.cocoachina.com/ios/20161115/18087.html https://segmentfault.com/a/1190000002580541]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>iOS开发——SVG图展示方案</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift——简单服务端开发实战]]></title>
    <url>%2F2017%2F09%2F12%2FSwift%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[相比不少iOS开发者在平时业余时间，都学习或者瞎搞过非iOS开发相关的技术，比如PHP，H5，Python，Kotlin，Go等，但是不管是为了打发时间，还是作为业余学习爱好，或者是广度拓展知识量，抑或者为了装逼，但是对我来说目前吃饭的家伙依然还是iOS，虽然iOS依然学的很水，就在5月份的时候去深圳参加过一次2017@Swift开发者大会，除了感触自己英语很差之外，还有一个记忆深刻的话题就是关于使用Swift开发服务端应用，当时确实有不少人在学习和研究相关技术，由于工作的原因也就没有去捣鼓，当然也可能是因为Swift开发服务端并不是那么稳定，完善，最近不知道为撒，突然想花点时间尝试一下，不管结果怎样或者是不是外面传的那么牛逼，我就当尝鲜吧……哈哈！ 前言 这里就不介绍什么Swift相关的知识了，如果不了解或者不够熟悉Swift的请查看相关文档 目前而言关于Swift开发服务端应用的库比较好的有两个：Vapor和Perfect当然也还有其他关于类似的，具体可以参考这里的对比：服务端写Swift体验 (Perfect框架) 因为我所在的一个2017@Swift开发者大会群中，其中有一位是Perfect作者之一，而且经常有听到关于Perfect的讨论，我也前往官网和github看了一下，文档非常详细，star也有12k，所以我决定从Perfect开始尝试。当然Vapor据说也不错，有机会也可以研究一下，然后对比，选择一个适合自己的来做点小东西。 Vapor参考：服务端 Swift - Vapor 篇 介绍摘自官网:Perfect是一组完整、强大的工具箱、软件框架体系和Web应用服务器，可以在Linux、iOS和macOS (OS X)上使用。 该软件体系为Swift工程师量身定制了一整套用于开发轻量、易维护、规模可扩展的Web应用及其它REST服务的解决方案， 这样Swift工程师就可以实现同时在服务器和客户端上采用同一种语言开发软件项目。 由于建立在一个高性能异步网络引擎基础上，Perfect还能够在FastCGI上运行，支持安全套接字加密（SSL）。 该软件体系还包含很多其它互联网服务器所需要的特点，包括WebSockets和iOS消息推送，而且很快会有更多强大的功能支持。 其实总结一句就是： Perfect是一套可以用来开发服务端应用的Swift库。 第一步：装备阶段开发环境 开发设备：MacBook Pro Xcode9.6、Swift3.1 homebrew 终端命令,以下是安装命令 /usr/bin/ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 环境配置swift –versioniCocos:blog icocos$ swift --version Apple Swift version 3.1 (swiftlang-802.0.53 clang-802.0.42) Target: x86_64-apple-macosx10.9 注意：最新版本的Swift 3.0。如果低于3.0版本则Perfect是无法成功编译。 软件Perfect依赖于若干软件接口库，比如OpenSSL、libssl-dev和uuid-dev brew install openssl libssl-dev uuid-dev 编译项目Clonegit clone https://github.com/PerfectlySoft/PerfectTemplate.git Swift编译命令cd PerfectTemplate swift build 命令行启动Swift Server.build/debug/PerfectTemplate 编译后可以启动一个本地的服务器，监听您计算机的8181端口： iCocos:PerfectTemplate icocos$ .build/debug/PerfectTemplate [INFO] Starting HTTP server localhost on 0.0.0.0:8181 服务器现在已经运行并等待连接。从浏览器打开http://localhost:8181/ 可以看到“Hello, world!”信息。 是不是感觉很熟悉，这不是和学习PHP的时候一样的吗？ XcodeSwift软件包管理器（SPM）能够创建一个Xcode项目，并且能够运行PerfectTemplate模板服务器，还能为您的项目提供完全的源代码编辑和调试。在您的终端命令行内输入： swift package generate-xcodeproj 然后打开产生的文件“PerfectTemplate.xcodeproj”，确定选择了可执行的目标文件，并选择在“我的Mac”运行。现在您可以运行并调试服务器了。 iCocos:PerfectTemplate icocos$ swift package generate-xcodeproj generated: ./PerfectTemplate.xcodeproj 运行项目打开Clone下来的项目文件PerfectTemplate中的.xcodeproj文件，选择带命令行图片（不能选错）的目标运行一行代码都不用写，就会发现Xcode命令行打印了一段： [INFO] Starting HTTP server localhost on 0.0.0.0:8181 到这里第一步基本上已经完成，下面基本上就可以开始撸代码了。 第二步：初步调整调整接口返回数据找到main.swift文件，handler方法中有这么一段： // An example request handler. // This &apos;handler&apos; function can be referenced directly in the configuration below. func handler(data: [String:Any]) throws -&gt; RequestHandler { return { request, response in // Respond with a simple message. response.setHeader(.contentType, value: &quot;text/html&quot;) response.appendBody(string: &quot;&lt;html&gt;&lt;title&gt;Hello, world!&lt;/title&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot;) // Ensure that response.completed() is called when your processing is done. response.completed() } } 直接将Hello, world!替换为想要的内容，再在浏览器输入 0.0.0.0:8181刚刚所修改的内容就会直接显示出来。 慢慢的，我发现和之前学习PHP所设计的步骤和操作越来越像 添加软件包打开PerfectTemplate项目中的Package.swift，在package前面添加需要的软件包，并替换package中dependencies获取方式 //软件包管理 import PackageDescription let versions = Version(0,0,0)..&lt;Version(10,0,0) let urls = [ &quot;https://github.com/PerfectlySoft/Perfect-HTTPServer.git&quot;, //HTTP服务 &quot;https://github.com/PerfectlySoft/Perfect-MySQL.git&quot;, //MySQL服务 &quot;https://github.com/PerfectlySoft/Perfect-Mustache.git&quot; //Mustache ] let package = Package( name: &quot;PerfectDemoProject&quot;, targets: [], dependencies: urls.map { .Package(url: $0, versions: versions) } ) 第三步：搭建HTTP服务器关于HTTP服务器配置官方（HTTP 服务器）其实已经给出了一个比较完成的介绍，但是由于篇幅过长这里就整理了一下： 1.编辑main.swift import PerfectLib import PerfectHTTP import PerfectHTTPServer //HTTP服务 let networkServer = NetworkServerManager(root: &quot;webroot&quot;, port: 8888) networkServer.startServer() 2.创建并编辑NetworkServerManager.swift import PerfectLib import PerfectHTTP import PerfectHTTPServer open class NetworkServerManager { fileprivate var server: HTTPServer internal init(root: String, port: UInt16) { server = HTTPServer.init() //创建HTTPServer服务器 var routes = Routes.init(baseUri: &quot;/api&quot;) //创建路由器 configure(routes: &amp;routes) //注册路由 server.addRoutes(routes) //路由添加进服务 server.serverPort = port //端口 server.documentRoot = root //根目录 server.setResponseFilters([(Filter404(), .high)]) //404过滤 } //MARK: 开启服务 open func startServer() { do { print(&quot;启动HTTP服务器&quot;) try server.start() } catch PerfectError.networkError(let err, let msg) { print(&quot;网络出现错误：\(err) \(msg)&quot;) } catch { print(&quot;网络未知错误&quot;) } } //MARK: 注册路由 fileprivate func configure(routes: inout Routes) { // 添加接口,请求方式,路径 routes.add(method: .get, uri: &quot;/&quot;) { (request, response) in response.setHeader( .contentType, value: &quot;text/html&quot;) //响应头 let jsonDic = [&quot;hello&quot;: &quot;world&quot;] let jsonString = self.baseResponseBodyJSONData(status: 200, message: &quot;成功&quot;, data: jsonDic) response.setBody(string: jsonString) //响应体 response.completed() //响应 } } //MARK: 通用响应格式 func baseResponseBodyJSONData(status: Int, message: String, data: Any!) -&gt; String { var result = Dictionary&lt;String, Any&gt;() result.updateValue(status, forKey: &quot;status&quot;) result.updateValue(message, forKey: &quot;message&quot;) if (data != nil) { result.updateValue(data, forKey: &quot;data&quot;) }else{ result.updateValue(&quot;&quot;, forKey: &quot;data&quot;) } guard let jsonString = try? result.jsonEncodedString() else { return &quot;&quot; } return jsonString } //MARK: 404过滤 struct Filter404: HTTPResponseFilter { func filterBody(response: HTTPResponse, callback: (HTTPResponseFilterResult) -&gt; ()) { callback(.continue) } func filterHeaders(response: HTTPResponse, callback: (HTTPResponseFilterResult) -&gt; ()) { if case .notFound = response.status { response.setBody(string: &quot;404 文件\(response.request.path)不存在。&quot;) response.setHeader(.contentLength, value: &quot;\(response.bodyBytes.count)&quot;) callback(.done) } else { callback(.continue) } } } } 3.运行项目 可以看到底部打印 启动HTTP服务 [INFO] Starting HTTP server localhost on 0.0.0.0:8181 4.重新刷新浏览器链接会发现 { &quot;status&quot;:200 &quot;date&quot;: { &quot;hello&quot;: &quot;world&quot; } &quot;message&quot;: &quot;成功&quot; } 这里我们平时开发中返回的标准格式，具体含义这里就不介绍了 遇到的问题（报错）及解决方案：1.swift build：SSLRead() return error -9806报错 brew remove git brew remove curl brew install openssl brew install --with-openssl curl brew install --with-brewed-curl --with-brewed-openssl git swift build Swift开发服务端应用完整资料： Swift 服务端开发 Perfect、Vapor资料]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层分析</tag>
        <tag>Swift——简单服务端开发实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发——系统API使用问题汇总（+解决方案）]]></title>
    <url>%2F2017%2F08%2F08%2FiOS%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9FAPI%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[平时实际开发中遇到最多的问题是什么？Bug？技术实现？技术难点？接口使用？方法优化？界面调整？ 其实最后总结来说终究是关于Api的问题，因为不管怎么样最后总会转成苹果对应的Api或者底层与处理。那么我们在使用苹果系统API的时候会遇到一些什么问题呢？也许你会说查文档，但是如果文档也没有提到相关的解决方案呢？那就懵逼了…… 1. 解决添加tap手势后点击cell无响应实现UIGestureRecognizerDelegate协议下面的方法1func gestureRecognizer(gestureRecognizer: UIGestureRecognizer, shouldReceiveTouch touch: UITouch) -&gt; Bool &#123; if NSStringFromClass(touch.view!.classForCoder) == &quot;UITableViewCellContentView&quot;&#123; return false &#125; return true &#125; 2.cell分割线不留空格12cell.preservesSuperviewLayoutMargins = falsecell.layoutMargins = UIEdgeInsetsZero 3.UISlider无法拖动进度条的问题解决在我听播放详情页的时候UISlider刚开始播放的时候距离左边20像素的位置之前的是不能拖动的，因为iOS在左边预留了20像素的手势返回处理。 当UISlider起始位置贴近屏幕边框的时候，UISilder不能拖动的原因是因为手势返回的原因，需要关闭手势返回就可以了。123- (BOOL)navigationControllerShouldDragback:(UINavigationController *)navigationController &#123;return false;&#125; 4.view被导航条给覆盖了，并没有从导航条的下面开始布局解决方法：（1）、设置edgesForExtendedLayout1self.edgesForExtendedLayout = UIRectEdgeNone; //view不需要拓展到整个屏幕 （2）、设置导航条的透明度1self.navigationController.navigationBar.translucent = NO; 5.我听设置当音频被占用的时候（如电话进来）系统会自动暂停当前使用的音频，如果想要系统使用完毕后恢复自己的音频使用 需要 播放自己的音频前设置：1[[AVAudioSession sharedInstance] setActive:NO withOptions:AVAudioSessionSetActiveOptionNotifyOthersOnDeactivation error:nil]; 然后设置系统音频中断恢复的通知1[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleInterruption:) name:AVAudioSessionInterruptionNotification object:[AVAudioSession sharedInstance]]; 中断发生时,应用程序的AVAudioSession会发送通知AVAudioSessionInterruptionNotification,注册通知代码如下:12在接收到通知的userInfo中,会包含一个AVAudioSessionInterruptionTypeKey,用来标识中断开始和中断结束.当中断类型为AVAudioSessionInterruptionTypeKeyEnded时,userInfo中还会包含一个AVAudioSessionInterruptionOptions来表明音频会话是否已经重新激活以及是否可以再次播放 6.跟xib一起走过的坑如果在xib中有一个控件, 已经明确设置尺寸了,输出的frame也是对的, 但是显示出来的效果不一样(比如尺寸变大了), 如果是这种情况一般就是autoresizingMask自动伸缩属性在搞鬼! 解决办法如下:1234//xib的awakeFromNib方法中设置UIViewAutoresizingNone进行清空- (void)awakeFromNib &#123;self.autoresizingMask = UIViewAutoresizingNone;&#125; 或者在layoutSubView中重新设置contentView的frame 7.一生部分对于系统视频音频API的使用较多，这里把我记得的坑公示，防止以后大家踩坑。 1.系统初始化AVCaptureSession的时候不能直接调用startSession的方法，需要先调用stopSession方法停止当前session，然后再调用startSession方法。否则会出现卡死主线程的问题。 （这里如果不手动显示调用stopSession，那么系统会利用主线程去停止session，而停止session是一个耗时操作，就会卡死主线程，出现页面卡死的现 2.因为之前一生拍摄需要拍照和视频录制相互切换，但是他们用的同一个session，只是视频的session中多了音频输入设备，如果直接使用session会造成录制的视频没有声音的问题（原因：因为session初始化的时候里面的视频设备音频设备还是使用的原来的session的。从拍照到录像的时候session中是没有音频设备的，所以需要重新加入音频设备， 注意(重点): 不能直接只加一个音频设备，需要把session中之前的输入输出设备全部移除掉，然后再重新加入新的输入输出音频视频设备，否则session不会生效。）1234567891011121314151617181920212223242526272829session.beginConfiguration()//移除输入if let input = self.getAVCaptureDeviceInput() &#123; let viewLayer = self.captureImage.layer viewLayer.masksToBounds = true let bounds = self.view.bounds self.captureVideoPreviewLayer?.frame = bounds for input in session.inputs &#123; if let input = input as? AVCaptureDeviceInput &#123; session.removeInput(input) &#125;&#125;if session.canAddInput(input) &#123; session.addInput(input)&#125; //移除输出self.stillImageOutput = AVCaptureStillImageOutput()let outputSettings = [AVVideoCodecKey : AVVideoCodecJPEG]self.stillImageOutput?.outputSettings = outputSettingsfor output in session.outputs &#123; if let output = output as? AVCaptureOutput &#123; session.removeOutput(output) &#125;&#125;if session.canAddOutput(stillImageOutput) &#123; session.addOutput(self.stillImageOutput)&#125;session.commitConfiguration() 3.视频拍摄设备方向和播放视频的设备方向是不一致的。所以需要在预览视频和上传后播放视频做视频的方向旋转处理。前置头像头和后置摄像头的处理方向是不一样的。 具体代码如下1234567891011121314151617if FrontCamera &#123; if self.videoFirstOrientation == .landscapeRight&#123; self.playerLayer?.setAffineTransform(CGAffineTransform(rotationAngle: CGFloat(Double.pi*0.5))) &#125;else if self.videoFirstOrientation == . landscapeLeft&#123; self.playerLayer?.setAffineTransform(CGAffineTransform(rotationAngle: CGFloat(Double.pi*1.5))) &#125; else if self.videoFirstOrientation == .portraitUpsideDown&#123; self.playerLayer?.setAffineTransform(CGAffineTransform(rotationAngle: CGFloat(Double.pi ))) &#125;&#125; else &#123; if self.videoFirstOrientation == .landscapeLeft &#123; self.playerLayer?.setAffineTransform(CGAffineTransform(rotationAngle: CGFloat(Double.pi * 1.5))) &#125; else if self.videoFirstOrientation == .landscapeRight &#123; self.playerLayer?.setAffineTransform(CGAffineTransform(rotationAngle: CGFloat(Double.pi / 2))) &#125; else if self.videoFirstOrientation == .portraitUpsideDown &#123; self.playerLayer?.setAffineTransform(CGAffineTransform(rotationAngle: 0)) &#125;&#125; 4.如果后期需要做滤镜或者实时视频滤镜，在DWVideoRecoder 中的123- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection &#123;&#125; 这个方法是拿到当前视频输入设备捕捉的每一帧画面，然后进行对每一帧画面进行处理。这个方法中拿到当前帧的画面然后进行滤镜渲染显示 5.获取沙盒中的视频路径要用 url.path. 不能直接转换为String，否则拿到的地址是不对的。1try? FileManager.default.removeItem(atPath: url.path) 6.视频的压缩主要取决于码率和关键帧率。 123456789101112131415161718192021self.assetWriterVideoInput = (&#123; AVAssetWriterInput *writerInput = [[AVAssetWriterInput alloc] initWithMediaType:AVMediaTypeVideo outputSettings:(&#123; // 录制参数。 根据调节参数实现压缩 @&#123; AVVideoCodecKey : AVVideoCodecH264,//编码方式 AVVideoScalingModeKey : AVVideoScalingModeResizeAspectFill, AVVideoWidthKey : @(960),//视频的宽高 AVVideoHeightKey : @(540), // 压缩参数 ，10 表示清晰度。 AVVideoCompressionPropertiesKey : (&#123; @&#123; AVVideoAverageBitRateKey : @(640 * 320 * 10),//压缩码率 AVVideoMaxKeyFrameIntervalKey : @(10),//清晰度 AVVideoProfileLevelKey : AVVideoProfileLevelH264HighAutoLevel//清晰度等级，枚举类型 &#125;; &#125;) &#125;; &#125;)] &#125;);// yes指明输入应针对实时进行优化writerInput.expectsMediaDataInRealTime = YES; 7.目前没有做多音频视频合成的需求，如果有需求，可以在TakeViedeoController.swift中的mergeAndExportVideos方法中代码就是对多段音频视频合成处理的代码。 录制视频关键流程梳理 1.初始化session，在session中设置音频视频的输入输出设备。在DWVideoRecoder中setupSessionInputs 和 setupSessionOutputs中 2.初始化摄像头，开启session，显示当前摄像头捕捉画面，为了防止按钮在白光下面显示不清晰，在view上加了一层蒙版。 3.开始录制调用DWRecorder中的startRecordWithSwift，然后往沙盒中写入视频数据。 4.结束录制后停止session，显示录制的最后一帧图像。调用session的stopSession方法，并且将.mov的文件转换为mp4格式视频保存到沙盒，然后删除之前的mov文件 5.重新录制视频只需要把页面按钮状态重置，停止session重新开始session。在TakeVideoViewController中直接调用重录方法cancelAction即可重录。 6.播放视频。从沙盒中获取之前录制的mp4文件路径放到当前的player中。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS开发——系统API使用问题汇总（+解决方案）</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS（Swift）开发——App开发文档]]></title>
    <url>%2F2017%2F08%2F02%2FiOS%EF%BC%88Swift%EF%BC%89%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[你有没有遇到过，突然老板或者老大跟你说，你根据项目或者根据功能写一份开发文档，当时很开心的答应了，后来想想，既然懵了。开发文档是什么鬼？写了这么多年代码都没写过什么开发文档，最多也就只是产品的需求文档，说明文档，代码的注释与规范文档，或者说过苹果的开发文档，因为之前刚好写过一次很简单的，最近公司又开始要写上面开发文档了，而且发现确实很多同学都不会，我在想，我是不是该做点什么……。 前言App开发过程中的文档分为很多种，比如最常见的就是官方的开发文档，这种比较倾向代码和接口，但是你可能还见过或者听过其他文档。 比如，这里根据个人理解整理了几个。 开发文档 需求(原型)文档 需求(说明)文档 技术方案文档 Bug修复文档 注释文档 代码与UI规范文档 性能优化文档 是不是有点晕了，哪有这么多鬼，其实按照之前的习惯，我都是一份开发文档就够了，基本上包含上面的东西，只是看你怎么细分。 开发文档概述实际开发中如果真的遇到要写上面开发文档可以从下面几个角度写。 一. 开发环境及工具 二. 项目或功能（需求）描述（最好有流程图或者UML）- 需求文档 三. 编写目的（用户特征和水平） 四. 项目或功能背景 五. 模块与关系 六. 类或术语说明 七. 参考资料（网络或公司内部资料，UI，原型，说明文档） 八. 项目进度预估 九. 难点预估（条件与限制） 十. 功能与所计划采用的技术 - 技术方案文档 十一. 用户界面与交互 十二. 软件（代码）接口 - 注释文档 十三. 通信（网络）接口 - 接口文档 十四. 问题与修复说明 - Bug修复文档 十五. 性能分析与优化 当然也不是说这些全部要写，可以根据项目或者功能适当编写。 下面大概一个个的说明一些每一个步骤是什么意思，需要怎么写，这里主要以iOS开发中App开发文档为规范，并使用苹果最新的语言Swift作为唯一语言。 一. 开发环境及工具 Mac OX 10 iPhone或者iPad 5+ 2+ 必须真机 iOS 8+ Xcode 8+ 其他工具：Tower，cornerstone 主要指明开发在工具，开发平台，开发版本的支持。描述软件的运行环境，包括硬件平台、硬件要求、操作系统和版本，以及其他的软 件或与其共存的应用程序等。 二. 项目或功能（需求）描述（最好有流程图或者UML）- 需求文档 顶层数据流图； 用例UseCase图； 系统流程图； 层次方框图。 主要根据产品给出的需求结合原型进行描述，并适当给出相应的图。 三. 编写目的（用户特征和水平） 描述最终用户应具有的受教育水平、工作经验及技术专长。 次软件或者功能编写的目的，对项目，对用户，对公司有什么好处。 四. 项目或功能背景 标识待开发软件产品的名称、代码； 列出本项目的任务提出者、项目负责人、系统分析员、系统设计员、程序设计员、程序员、资料员以及与本项目开展工作直接有关的人员和用户； 说明该软件产品与其他有关软件产品的相互关系。 此项目或功能编写之前市面上的情况，公司和用户的情况 五. 模块与关系 项目或功能对应模块在位置，入口，和其他模块的关系 六. 类或术语说明 项目或功能对应类的说明，和开发中使用到的一些相关的术语的说明 七. 参考资料（网络或公司内部资料，UI，原型，说明文档） 列举编写软件需求规格说明时所参考的资料，包括项目经核准的计划任务书、合同、引用的标准和规范、项目开发计划、需求规格说明、使用实例文档，以及相关产品的软件需求规格说明。 在这里应该给出详细的信息，包括标题、作者、版本号、发表日期、出版单位或资料来源。 网络资料，尤其是苹果的，也可以群里或者博客，文章等。公司内部的UI，原型，说明，网络接口资料 八. 项目进度预估 预计从上面开始到指定的时间节点完成任务或者完成对应的部分 九. 难点预估（条件与限制） 其中考虑到或者可能会遇到什么技术或者实现难点 十. 功能与所计划采用的技术 - 技术方案文档 将要采用的图形用户界面标准或产品系列的风格； 屏幕布局； 菜单布局； 输入输出格式； 错误信息显示格式； 建议采用RAD开发工具， 比如Visio，构造用户界面。 根据项目或者功能需求，在代码层面所使用的技术或者实现方案，或者比如说ios中布局方式的使用。 十一. 用户界面与交互 根据用户界面和入口说明交互与使用步骤并 十二. 软件（代码）接口 - 注释文档 每一个方法和属性对应的注释，一般是私有的话使用private但是也要注释，公开的都会使用标准的注释说明，苹果有自带的快捷键（command+option+/），之前有个插件叫VVDocument 十三. 通信（网络）接口 - 接口文档 网络请求对应的说明包括对应的参数，字段和返回值，也可以是数据模型层对应的模型属性和方法的说明 十四. 问题与修复说明 - Bug修复文档 开发或者测试的过程中出现了什么比较重要的bug，不要什么bug都写上，然后说明解决的方案 十五. 性能分析与优化 时间特性 响应时间； 更新处理时间； 数据转换与传输时间； 运行时间等。 适应性 在操作方式、运行环境、与其他软件的接口以及开发计划等发生变化时，软件的适应能力。 到此完成之后，根据实际需求和个人能力，个人理解分析项目或者功能那些地方需要进行优化一下，打算怎么去优化他。 后期会继续完善(根据项目或功能整理一套完整的开发文档)……. 注：这里是按照功能，并不是按照整个项目分，如果要写整个项目的开发文档也可以再根据功能细分。]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>iOS（Swift）开发——App开发文档</tag>
        <tag>开发文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift开发——实用技巧Literal]]></title>
    <url>%2F2017%2F07%2F31%2FSwift%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7Literal%2F</url>
    <content type="text"><![CDATA[由于之前一直在写OC项目，最近开始真正实用Swift开发与迭代项目，前段时间偶尔看到项目中一段莫名奇妙的代码，就是关于颜色和图片的设置，顿时激起了我的兴趣，即使我从Swift 1.0 到 2.0 再到 3.0 也没有看到过这样的写法，可能是我孤陋寡闻了，于是随便弄了一下，发现还真有趣…… 首先我们来看看本文的主要字眼：Literal Literal：照字面的， 原义的的意思. 个人理解：所见即所得其实理解的这里的含义应该就差不多能猜到我今天要说什么了。 通过官方资料Add a color, file, or image literal我们可以知道：Literal是Xcode8 的新特性，而且不支持 OC，只至少目前只能在Swift中使用。 Color LiteralColor Literal在Swift中我们写颜色都是这样的： let iCocosColor = UIColor(red: 10/255.0, green: 10/255.0, blue: 10/255.0, alpha: 1) 但是如果不 command + R 运行项目的话，我们就不知道这颜色到底长什么样。 那么有了接下Color Literal 之后，就简单多了。直接输入color提示下面的Color Literal，回车就可以，会看到一个默认的白色框， 点击白色框就可以选择任何你想要的颜色了。 同时也可以点击other进行其他多样化颜色的选取。如果把那句代码拷贝出来，其实是这样的： let iCocosColor = #colorLiteral(red: 1, green: 0.04969102033, blue: 0, alpha: 1) Image LiteralImage Literal而图片的定义或者设置我们一般会这么做。 let iCocosImage = UIImage(named: &quot;iCocos&quot;) 同样如果我们不command + R运行项目的话，也没办法知道是否正确，而且如果我把 name 写错，图片就不会显示了。 那么有了接下Image Literal 之后，就简单多了。直接输入iamge提示下面的Image Literal，回车就可以，会看到一个默认的图标， 点击图标就可以选择任何你想要的图片了。 如果把那句代码拷贝出来，其实是这样的： let iCocosImage = #imageLiteral(resourceName: &quot;circleItemMore&quot;) 到这里基本上就结束了，相信你会爱上这个特性。 是不是很牛逼，我当时没有查资料和文档的情况下，硬是没有看懂。]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Swift开发——实用技巧Literal</tag>
        <tag>实用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift篇——ARC中循环引用问题]]></title>
    <url>%2F2017%2F07%2F22%2FSwift%E7%AF%87%E2%80%94%E2%80%94ARC%E4%B8%AD%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[如果你有过实际iOS开发经验，尤其是OC时代的，那么你一定遇到过这样的一个问题，那就是循环应用，于是就有了各种文文章，各种解决方式实现这样的问题，但是这种情况到了Swift里面依然没有办法避免的，只是Swift里面似乎考虑到了OC中欠缺的地方，同时也为了我们能更好的处理这样的问题，给出了对应的方案…… 一、几个用到的关键概念弱引用(weak)：不会增加自动引用计数，必须为可选类型变量，因为弱引用在引用计数为0的时候，会自动赋为nil。在swfit中，可以赋值为nil的为可选类型 无主引用(unonwed)：不会增加自动引用计数，必须为非可选类型。在ARC销毁内存后，不会被赋为nil，所以在访问无主引用的时候，要确保其引用正确，不然会引起内存崩溃。 隐式解析可选类型：在初始的时候可以为nil，但是第一次赋值以后便会一直有值。语法是在变量后面加上感叹号(例如var name:String!)。使用该类型只需要正常调用，不需要像可选类型那样做判断。 二、类实例之间的循环引用1、实例A可选包含实例B的引用，实例B可选包含实例A的引用-用弱引用来解决公寓不一定有住户，住户也不一定在公寓里 class Person { let name: String init(name: String) { self.name = name } var apartment: Apartment? deinit { println(&quot;\(name) is being deinitialized&quot;) } } class Apartment { let number: Int init(number: Int) { self.number = number } weak var tenant: Person? deinit { println(&quot;Apartment #\(number) is being deinitialized&quot;) } } var john: Person? var number73: Apartment? john = Person(name: &quot;John Appleseed&quot;) number73 = Apartment(number: 73) john!.apartment = number73 number73!.tenant = john 2、实例A可选包含实例B，实例B一定包含实例A-用无主引用解决用户可能没有信用卡，但是信用卡一定会有用户。由于信用卡一定有用户，所以不是可选类型，不能用弱引用，swift中提供的无主引用是简单便捷的解决方案。 class Customer { let name: String var card: CreditCard? init(name: String) { self.name = name } deinit { println(&quot;\(name) is being deinitialized&quot;) } } class CreditCard { let number: Int unowned let customer: Customer init(number: Int, customer: Customer) { self.number = number self.customer = customer } deinit { println(&quot;Card #\(number) is being deinitialized&quot;) } } var john: Customer? john = Customer(name: &quot;John Appleseed&quot;) john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!) 3、A一定包含B，B一定包含A - 用隐式解析+无主引用解决国家一定包含首都，首都也一定在一个国家里 class Country { let name: String let capitalCity: City! init(name: String, capitalName: String) { self.name = name self.capitalCity = City(name: capitalName, country: self) } } class City { let name: String unowned let country: Country init(name: String, country: Country) { self.name = name self.country = country } }]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Swift篇——ARC中循环引用问题</tag>
        <tag>ARC中循环引用问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift篇——可选类型总结]]></title>
    <url>%2F2017%2F07%2F18%2FSwift%E7%AF%87%E2%80%94%E2%80%94%E5%8F%AF%E9%80%89%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在Swift中，可选类型其根源是一个枚举型，里面有None和Some两种类型。其实所谓的nil就是Optional.None, 非nil就是Optional.Some, 然后会通过Some(T)包装（wrap）原始值，这也是为什么在使用Optional的时候要拆包（从enum里取出来原始值）的原因, 也是PlayGround会把Optional值显示为类似{Some “hello world”}的原因，…… 首先我们先看下Objective-C与Swift语言对于可选nil的不同理解: Objective-C中的nil:表示缺少一个合法的对象，是指向不存在对象的指针，对结构体、枚举等类型不起作用(会返回NSNotFound) Swift中的nil:表示任意类型的值缺失，是一个确定的值，要么是该类型的一个值要么什么都没有(即为nil) 一、申明可选常量或变量let status: Int? = 1 // 申明可选Int类型的常量,初始值为1 var defaultAddress: String? = &quot;江苏南京&quot; // 申明可选String类型的变量,初始值为&quot;江苏南京&quot; var student: Person? // 申明可选Person(自定义的类)的变量，初始值为nil 注意：Int?与Int不相同，Int?表示可选的Int类型，可以赋值为nil，而Int不可以赋值为nil 二、使用”!”强制解析获取可选类型的值(不建议直接使用)var defaultAddress: String? = &quot;江苏南京&quot; if defaultAddress != nil { // !=或==可以用来判断是否为nil print(&quot;您的地址是\(defaultAddress!)&quot;) // 使用!强制解析 } else { print(&quot;对不起，您不存在地址信息&quot;) } var student: Person? print(&quot;学生为\(student!)&quot;) // XCode会提示运行错误，因为student初始值为nil，强制解析不行 三、使用可选绑定获取可选类型的值(建议的用法)var defaultAddress: String? = &quot;江苏南京&quot; if let address = defaultAddress { // 如果defaultAddress有值或类型转换成功，则将值赋值给address直接使用 print(&quot;您的地址是\(address)&quot;) // 使用address代替defaultAddress，且不需要加!强制解析 } else { print(&quot;对不起，您不存在地址信息&quot;) } 四、隐式解析可选类型(用于申明时肯定有初始值，但后面可能为nil)var mobileNumber: Int64! = 13912345678 // 第一次申明有初始值 print(&quot;您的电话号码是\(mobileNumber)&quot;) // 不需要使用!强制解析 // 打印内容:**您的电话号码是****Optional(13912345678)** // 还是不建议直接强制解析，因为实际项目中可能中间已经对该值做了改变，若为nil则会运行错误导致APP崩溃 if let number = mobileNumber { // 建议的做法 print(&quot;您的电话号码是\(number)&quot;) // 打印内容:**您的电话号码是****13912345678** } else { print(&quot;您没有记录电话号码&quot;) } 五、空合运算符(用于判断变量或常量是否为nil)// 空合运算符：a ?? b 判断a是否为nil，若a不为nil对a解封，否则返回b的值 var status: Int? // 申明可选Int类型的变量status，初始值为nil status ?? 0 // 因为status为nil，则返回0 // ?? 即为以下if else的缩写 func testOption() -&gt; Int { let status: Int? = 1 if status == nil { return 0 } else { return status! } } 六、函数/方法返回类型为可选类型A:返回值为可选类型的值(如Int?、String?、(Int, String)?、[Int]?、[Int: String]?等) func returnPossibleValue(value: Bool) -&gt; String? { // 返回类型为可选String类型 if value { return &quot;返回类型是可选类型值&quot; // 如果为真，返回Int类型的值1 } else { return nil // 如果为假，返回nil } } let possibleValue = returnPossibleValue(value: true) // 要用可选绑定判断再使用，因为possibleValue为String？可选类型 if let value = possibleValue { print(value) } else { print(&quot;none value&quot;) } B:返回值为可选类型的类(如URL?、自定义Person?等) class SomeClass { var someValue: Int init?(someValue: Int) { // 可失败构造器 if someValue == 1 { return nil } self.someValue = someValue } } func returnPossibleClass(value: Bool) -&gt; SomeClass? { // 返回的类实例可能为nil if value { return SomeClass(someValue: 1) // 返回的为nil } else { return SomeClass(someValue: 2) // 返回的SomeClass?实例，不为nil } } C:返回值为可选类型的闭包(如(()-&gt; (void))? ) func returnOptionalFunc(value: Bool) -&gt; (() -&gt; (Void))? { // 返回类型为可选类型的闭包 if value { return { () in print(&quot;返回类型是可选类型闭包&quot;) } } else { return nil } } let possibleFunc = returnOptionalFunc(value: true) // 要用可选绑定判断再使用，因为possibleFunc 为可选类型的闭包，类型为() -&gt; (Void) if let aFunc = possibleFunc { print(aFunc()) // 注意增加()调用闭包，因为没有参数则是空括号 } else { print(&quot;none func&quot;) } 七、可选类型在类或结构体中的运用A:可选类型在类中的运用 class PossibleClass { var someValue: Int var possibleValue: String? // 可选存储属性，默认值为nil init(someValue: Int) { // 构造方法中可以不对possibleValue属性初始化 self.someValue = someValue } } let someClass = PossibleClass(someValue: 4) // 实例化对象时不需要对possibleValue初始化，someClass实例中：someValue为4，possibleValue为nil 注意：类中所有属性都需要有默认值。属性可以在申明时赋予初始值，也可以在构造方法中赋予初始值；子类继承父类时，必须先给自身属性先初始化后再继承父类构造方法初始化。一般的，出于安全的因素，子类的属性都赋予初始值或直接定义为可选类型。 B:可选类型在结构体中的运用 struct PossibleStruct { var someValue: Int var possibleValue: String? // 可选存储属性，默认值为nil // 结构体中可以自定义一个init构造器对属性初始化，也可以不自定义 } let someStruct = PossibleStruct(someValue: 4, possibleValue: nil) 调用默认的逐一构造器 说明：从上图可看出实例化,PossibleStruct会调用默认逐一构造器，其中possibleValue可传String类型的值或nil 八、可选类型在构造器中的运用 概念：可失败构造器是 一个类、结构体或枚举类型的对象，在构造过程中有可能失败；这里所指的“失败”是指，如给构造器传入无效的参数值，或缺少某种所需的外部资源，又或是不满足某种必要的条件等。 A:结构体的可失败构造器 struct PossibleStructInit { let someValue: String init?(someValue: String) { // 可失败构造器 if someValue.isEmpty { return nil } // 如果实例化为空串，则返回nil(即实例化失败) self.someValue = someValue } } let oneStruct = PossibleStructInit(someValue: &quot;abc&quot;) // abc不是空串，oneStruct为PossibleStructInit？可选类型 if let one = oneStruct { // 使用if let可选绑定判断 print(one.someValue) } else { print(&quot;none value&quot;) } // 结果打印 abc let twoStruct = PossibleStructInit(someValue: &quot;&quot;) // 传参为空串 if let two = twoStruct { print(two.someValue) } else { print(&quot;none value&quot;) } // 结果打印 none value B:枚举的可失败构造器 enum PossibleEnmuInit { case East, West, South, North // 不带原始值，带原始值也可以使用可失败构造器 init?(director: Character) { switch director { case &quot;E&quot;: self = .East case &quot;W&quot;: self = .West case &quot;S&quot;: self = .South case &quot;N&quot;: self = .North default: return nil // 如果实例化时不是E/W/S/N字符，则返回nil(即实例化失败) } } } let oneEnmu = PossibleEnmuInit(director: &quot;E&quot;) // 传值E，返回PossibleEnmuInit?可选类型 if let one = oneEnmu { // 使用可选绑定判断 print(one) } else { print(&quot;none value&quot;) } // 结果打印 East let twoEnmu = PossibleEnmuInit(director: &quot;A&quot;) // 传值A，返回PossibleEnmuInit?可选类型 if let two = twoEnmu { // 使用可选绑定判断 print(two) } else { print(&quot;none value&quot;) } // 结果打印 none value C:类的可失败构造器 class Product { let name: String init?(name: String) { if name.isEmpty { return nil } self.name = name } } class CartItem: Product { let quantity: Int init?(name: String, quantity: Int) { if quantity &lt; 1 { return nil } // 实例化时如果quantity小于1，则立即终止构造过程 self.quantity = quantity super.init(name: name) // 如果name为空串，则立即终止构造过程 } } if let twoSocks = CartItem(name: &quot;sock&quot;, quantity: 2) { print(&quot;Item: \(twoSocks.name), quantity: \(twoSocks.quantity)&quot;) } // 打印 &quot;Item: sock, quantity: 2” if let zeroShirts = CartItem(name: &quot;shirt&quot;, quantity: 0) { print(&quot;Item: \(zeroShirts.name), quantity: \(zeroShirts.quantity)&quot;) } else { print(&quot;Unable to initialize zero shirts&quot;) } // 打印 &quot;Unable to initialize zero shirts” 九、可选类型在可选链中的运用概念：可选链为一种可以在当前值可能为nil的可选值上请求和调用属性、方法及下标的方法。如果可选值有值，那么调用就会成功；如果可选值是nil，那么调用将返回nil。多个调用可以连接在一起形成一个调用链，如果其中任何一个节点为nil，整个调用链都会失败，即返回nil。 class Person { var name: String var room: Room? // 不是每个人都买房，定义为可选类型 init(name: String) { self.name = name } } class Room { var roomAddr: String var roomArea: Int init(roomAddr: String, roomArea: Int) { self.roomAddr = roomAddr self.roomArea = roomArea } } let xiaoming = Person(name: &quot;xiaoming&quot;) // 此时xiaoming实例中属性：name为&quot;xiaoming&quot;,room为nil if let address = xiaoming.room?.roomAddr, let area = xiaoming.room?.roomArea { // 使用?可选链式调用，如果含有值则返回该值(不需要手动强制解析),如果没有值则返回nil print(&quot;\(xiaoming.name)的房子地址在:\(address), 面积:\(area)&quot;) } else { print(&quot;\(xiaoming.name)没有房子&quot;) } // 打印：xiaoming没有房子 xiaoming.room = Room(roomAddr: &quot;南京雨花台区&quot;, roomArea: 95) // 定义xiaoming实例的room属性 // 再次调用以上可选绑定，打印 xiaoming的房子地址在:南京雨花台区, 面积:95 十、可选类型在错误处理中的运用概念：错误处理即为响应错误一级从错误中恢复的过程 A:一般的错误处理写法（一般使用于需要对不同的返回结果较为清晰的捕捉并做相应的处理） // 操作错误处理枚举 enum OperationError: Error { case ErrorOne case ErrorTwo(String) // 带关联值的枚举属性 case ErrorOthers } // 错误处理抛出 func throwDriver(num: Int) throws { if num == 1 { throw OperationError.ErrorOne } else if num == 2 { throw OperationError.ErrorTwo(&quot;数据类型错误&quot;) } else { throw OperationError.ErrorOthers } } do { print(&quot;使用do-catch捕获错误&quot;) try throwDriver(num: 2) // 使用try尝试请求 print(&quot;未捕获到错误&quot;) } catch OperationError.ErrorOne { // catch去捕捉是否又throw出来的错误 print(&quot;捕捉到错误：ErrorOne&quot;) } catch OperationError.ErrorTwo(let message) { // 可以使用let 获取枚举关联值 print(&quot;捕捉到错误：ErrorTwo&quot; + message) } catch OperationError.ErrorOthers { print(&quot;捕捉到错误：ErrorOthers&quot;) } // 打印结果如下： // 使用do-catch捕获错误 // 捕捉到错误：ErrorTwo数据类型错误 B:错误处理(try!)（不建议使用，可能会导致App崩溃） let photo = try! loadImage(atPath: &quot;./Resources/John Appleseed.jpg&quot;) // 上述语句中在执行loadImage方法时如果执行失败，使用try!来禁用错误传递，会有运行错误导致App崩溃 C:错误处理(try?)（一般使用于不需要对错误进行过多的处理） func someThrowingFunction() throws -&gt; Int { // ... } let x = try? someThrowingFunction() // x可能正常返回一个Int类型的值也有可能抛出一个错误异常，使用时对x用if let可选绑定判断 十一、可选类型在类型转换中的运用类型转换在向上转型时一般不会出现失败，例如从子类向父类转型，直接用as即可类型转换在向下转型时可能会出现失败，例如从父类向子类转型，要使用as?转型，使用时需要可选绑定后再用 使用as?类型转换值得注意的是：从Any转成Int为向下转型，Swift从安全因素考虑，会直接返回nil，所以在日常项目中若遇到从父类向子类转型时，一定要使用可选绑定，如以下代码： class SuperClass { // 这是一个父类 } class SubClass: SuperClass { // 这是一个子类 } let superClass = SuperClass() if let someClass = superClass as? SubClass { // 如果转换成功，则用someClass使用即可 } else { // 转换失败 } 其他、调用公共库时注意API的返回值 返回值类型 var score: [String: Int] = [&quot;语文&quot;: 87, &quot;数学&quot;: 99, &quot;英语&quot;: 61] let removedValue = score.removeValue(forKey: &quot;物理&quot;) // 返回nil 注意：从以上代码中可看出，removeValue方法会返回被删除key对应的Value值，发现不存在key为“物理”，即返回nil(removedValue常量值)]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Swift篇——可选类型总结</tag>
        <tag>可选类型总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift——类&结构体&枚举总结]]></title>
    <url>%2F2017%2F07%2F15%2FSwift%E2%80%94%E2%80%94%E7%B1%BB-%E7%BB%93%E6%9E%84%E4%BD%93-%E6%9E%9A%E4%B8%BE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[OC中也有类，结构体，枚举。但是 到了Swift中，我发现实际的应该却远远超过OC，而且强大之处之后我们真正用了才知道，那么他们之间到底有什么区别呢？ 即枚举类型、结构类型（包括基本类型，基本类型实际都是结构类型的特例）、类。 类型区别 类是引用类型 引用类型(reference types，通常是类)被复制的时候其实复制的是一份引用，两份引用指向同一个对象。所以在修改一个实例的数据时副本的数据也被修改了(s1、s2)。 枚举，结构体是值类型 值类型(value types)的每一个实例都有一份属于自己的数据，在复制时修改一个实例的数据并不影响副本的数据(p1、p2)。值类型和引用类型是这三兄弟最本质的区别。 mutating值类型的属性不能在实例方法中被修改，但是有时候你确实想修改过，这时候 你可以使用变异方法 。关键字 mutating 总结枚举、结构体、类的共同点：定义属性和方法； 下标语法访问值； 初始化器； 支持扩展增加功能； 可以遵循协议； 类特有的功能：继承； 允许类型转换； 析构方法释放资源； 引用计数； 我该如何选择关于在新建一个类型时如何选择到底是使用值类型还是引用类型的问题其实在理解了两者之间的区别后是非常简单的，在这苹果官方已经做出了非常明确的指示（以下内容引自苹果官方文档）： 当你使用Cocoa框架的时候，很多API都要通过NSObject的子类使用，所以这时候必须要用到引用类型class。在其他情况下，有下面几个准则： 1.什么时候该用值类型：要用==运算符来比较实例的数据时 你希望那个实例的拷贝能保持独立的状态时 数据会被多个线程使用时 2.什么时候该用引用类型（class）：要用==运算符来比较实例身份的时候 你希望有创建一个共享的、可变对象的时候]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Swift——类&amp;结构体&amp;枚举总结</tag>
        <tag>类&amp;结构体&amp;枚举总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC&&Swift——方法调用技巧]]></title>
    <url>%2F2017%2F07%2F13%2FOC-Swift%E2%80%94%E2%80%94%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[在现在这个iOS行业，如果你还只会OC的话，可能你是一个老手，而且是一个不喜欢学习的老手，如果你只会Swift的话，那么那么可能很多底层的东西没有办法去挖掘，尤其是一个篇全局和理论的东西，所以如果你是一个iOS程序员，那么OC和Swift是必会的，只是看你比较偏向于那一块。很多项目中都能看到两者的身影，这个时候你就不得不学习怎么去混编或者交互…….. 1、OC调用Swift实例方法例如在ViewController.m类里调用Swift的logMe实例方法，就可以这么写： SwiftDemo* demo = [[SwiftDemo alloc] init]; [demo logMe]; 2、OC调用Swift静态方法首先先在SwiftDemo.swift文件中声明一个静态方法： public static func swiftStaticFunc(log: NSString) { print(log); } 然后回到ViewController.m类里调用该方法（记得编译一下才可以）同样、调用方式和OC之间的调用类似： [SwiftDemo swiftStaticFunc:@&quot;oc call swift static func&quot;]; 3、Swift调用OC实例方法在SwiftDemo.swift类里调用ViewController.m类里的logYou方法，swift调用代码如下： let vc = ViewController() vc.logYou() 声明一个变量vc，也就是ViewController的实例对象。然后用vc对象调用实例方法logYou。。 4、Swift调用OC静态方法首先先在ViewController.h中声明一个OC的静态方法： + (void) ocStaticFunc:(NSString*)log; 然后在.m文件中简单些一下实现： + (void)ocStaticFunc:(NSString *)log { NSLog(@&quot;%@&quot;, log); } 回到SwiftDemo.swift文件中，用swift调用OC的静态方法。 ViewController.ocStaticFunc(&quot;swift call oc static fun&quot;) 5、Swift调用OC多参方法首先先在ViewController.h中声明一个OC的多参方法： - (void) logMe:(NSString*)logMe logYou:(NSString*)logYou; 在.m文件中进行一下实现： - (void)logMe:(NSString *)logMe logYou:(NSString *)logYou { NSLog(@&quot;%@--%@&quot;, logMe, logYou); } 在SwiftDemo.swift文件中调用方法如下： vc.logMe(&quot;log me&quot;, logYou: &quot;log you&quot;) 方法从第一个参数开始都要写在括号里]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>OC&amp;&amp;Swift——方法调用技巧</tag>
        <tag>方法调用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift——不为人知的淫技]]></title>
    <url>%2F2017%2F07%2F08%2FSwift%E2%80%94%E2%80%94%E4%B8%8D%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84%E6%B7%AB%E6%8A%80%2F</url>
    <content type="text"><![CDATA[过去总是遇到一些看不太懂的代码，或者是一些开源的源码，或者是看到别人写代码，看起来好有逼格，有些因为好奇也就网上搜了一下，发现既然有这么一系列的东西我们虽然有用到，或者有看到，但是根本没有去了解他是什么？有什么用？或者苹果为什么要给个这样的特性？ @dynamicdynamic 可以让类里面的函数使用消息机制派发. 使用 dynamic, 必须导入 Foundation 框架, 里面包括了 NSObject 和 Objective-C 的运行时. dynamic 可以让声明在 extension 里面的函数能够被 override. dynamic 可以用在所有 NSObject 的子类和 Swift 的原声类. @objc使用 @objc 的典型例子就是给 selector 一个命名空间 @objc(abc_methodName), 让这个函数可以被 Objective-C 的运行时调用. @nonobjc 会改变派发的方式, 可以用来禁止消息机制派发这个函数, 不让这个函数注册到 Objective-C 的运行时里. 总结@objc 和 @nonobjc 显式地声明了一个函数是否能被 Objective-C 的运行时捕获到. @objc是用来将Swift的API导出给Objective-C和Objective-C runtime使用的，如果你的类继承自Objective-c的类（如NSObject）将会自动被编译器插入@objc标识。 加了@objc标识的方法、属性无法保证都会被运行时调用，因为Swift会做静态优化。要想完全被动态调用，必须使用dynamic修饰。使用dynamic修饰将会隐式的加上@objc标识。 @inline这个特性为编译器提供了内联提示。可以理解为告诉编译器可以使用直接派发. @asmname该属性给出了函数、方法或属性实现的符号名称。如果已经知道对应的函数参数及其类型，那么就可以直接调用Swift的内部标准库函数，甚至不用头文件，也可以方便地调用C语言编写的函数：@asmname(“function”) func f() @semantics这又是另一个谜。参数看起来像是array.mutate_unknown或array.init这样的字符串数组。想必这是要告诉编译器（或静态分析器）函数是如何工作的。 @unsafe_no_objc_tagged_pointer上面这个仍然是个谜，但据猜测，它是在告诉Swift与objective-C联系的时候不要使用tagged pointer。 对象在内存中是对齐的，它们的地址总是指针大小的整数倍，通常为16的倍数。对象指针是一个64位的整数，而为了对齐，一些位将永远是零。 Tagged Pointer利用了这一现状，它使对象指针中非零位有了特殊的含义。在苹果的64位Objective-C实现中，若对象指针的最低有效位为1(即奇数)，则该指针为Tagged Pointer。这种指针不通过解引用isa来获取其所属类，而是通过接下来三位的一个类表的索引。该索引是用来查找所属类是采用Tagged Pointer的哪个类。剩下的60位则留给类来使用。 @availability这个特性可以用来标识某些函数只在某些平台或版本上可用。第一个参数是平台，可以用星号（＊）代表一切可用，还可以是iOS或OS X。因为如果需要针对不同的平台，就要指定多个@availability属性。 @available放在函数（方法），类或者协议前面。 @available(iOS 9, *) func myMethod() { // do something } #available用在条件语句代码块中，判断不同的平台下，做不同的逻辑处理， if #available(iOS 8, *) { // iOS 8 及其以上系统运行 } 总结 网上有这么一段话：@available是编译期间判断的，而#available是运行时行为。 @transparent该特性会导致编译器在管道（pipeline）中更早地将函数内联。它用于“像+(Int, Int)这样非常原始的函数”，而“不应该用于独立函数”。甚至在没有优化设置的调试模式下，@transparent特性函数就会被内联，所以在调用“1+1”这样的函数时候并不会特别慢，另外这个特性与@inline（__always）非常类似。 @warn_unused_result在Swift 2.x的时候，带返回的方法我们如果在调用的时候后面使用到返回的参数，编译器不会有任何的警告，想要编译器给出警告的话需要自己在方法前面添加属性 @warn_unused_result , 如 @warn_unused_result func doSomething() -&gt; Bool { return true } 这个关键字的含义：如果某个函数使用了这个关键字，那么函数在被调用的时候，要检查或者使用返回值，某则编译器会进行警告。使用场合：在把一些功能封装起来（或者SDK的编写）时候，如果对返回值的使用比较重要，那么使用这个关键字提醒编译器要检查返回值是否被利用。 这时候调用这个方法没有使用返回参数的情况下编译器就会给出警告： Result of call to ‘doSomething()’ is unused @discardableResult Swift 3.0 的时候@warn_unused_result已经不需要了，默认情况下编译器就是会去检查返回参数是否有被使用，没有的话就会给出警告。如果你不想要这个警告，可以自己手动加上 @discardableResult ，如： @discardableResult func doSomething() -&gt; Bool { return true } 这样一来一切又恢复正常了。 @warn_unqualified_accessextension SortedArray { /// 返回集合里的最小值 /// /// - Complexity: O(1). @warn_unqualified_access public func min() -&gt; Element? { return first } /// 返回集合里的最大值 /// /// - Complexity: O(1). @warn_unqualified_access public func max() -&gt; Element? { return last } } 当你在类型的内部实现中调用这些函数，却没有显式地写明 self. 的前缀时，@warn_unqualified_access 会告诉编译器抛出一个警告。这样可以帮助你避免混淆了这些函数与全局函数 min(::) 和 max(::) 。 @convention@convention 特性是在 Swift 2.0 中引入的，用于修饰函数类型，它指出了函数调用的约定。用在以下几个地方： 修饰 Swift 中的函数类型，调用 C 的函数时候，可以传入修饰过 @convention(c) 的函数类型，匹配 C 函数参数中的函数指针。修饰 Swift 中的函数类型，调用 Objective-C 的方法时候，可以传入修饰过 @convention(block) 的函数类型，匹配 Objective-C 方法参数中的 block 参数。 拓展__attribute__((constructor)) //确保此函数在 在main函数被调用之前调用__attribute__((destructor)) // 确保此函数在 在main函数被调用之后调__attribute__((cleanup())) 用于修饰一个变量，在它的作用域结束时可以自动执行一个指定的方法后期如果有遇到或者发现其他更多相关的我也会随时更新，如果你有遇到不错的也可以联系我，我们一起交流讨论…….]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Swift——不为人知的淫技</tag>
        <tag>不为人知的淫技</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift——动态&静态分析与实战]]></title>
    <url>%2F2017%2F07%2F04%2FSwift%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[我们知道在OC里面有一个非常牛逼的特性，那就是动态性，也就是说很多东西都被推到了运行时，包括我们所理解的消息机制和转发机制。但是据我了解OC貌似是没有动态类型的，因为他是一门静态类型的语言，他对多就是支持一些和OC动态的交互，但是Swift在通过某些手段还是可以实现对消息的动态转发的…… Swift是一门静态类型的语言，不支持类似OC中的消息机制和转发机制以及其他一些动态的特性，但是你可以通过某些手段实现这一点。 新的Swift编译器更智能，能够识别对象和方法的调用关系以及层级关系，减少对象调用方法的查找时间；同时在内存管理上也有所提高。大部分的方法调用，尤其是重复的方法调用，并没有必要次次都从头开始进行查找，消息分发、转发。Swift一定程度上减少了这种重复的劳动。 Swift是OO（面向对象）的语言，所以少不了方法和属性的重载等特性，程序只能在运行时来确定具体的方法或属性来间接调用或间接访问，这就叫做动态派发。从性能上考虑，对于动态派发的方法，会有常量时间的运行时开销。 函数的派发方式： 程序判断使用哪种途径去调用一个函数的机制. 直接派发(Direct Dispatch) 函数表派发(Table Dispatch) 消息机制派发(Message Dispatch) 大多数语言都会支持一到两种, Java 默认使用函数表派发, 但你可以通过 final 修饰符修改成直接派发. C++ 默认使用直接派发, 但可以通过加上 virtual 修饰符来改成函数表派发. Objective-C 则总是使用消息机制派发, 但允许开发者使用 C 直接派发来获取性能的提高. 直接派发 (Direct Dispatch)直接派发是最快的, 不止是因为需要调用的指令集会更少, 并且编译器还能够有很大的优化空间, 例如函数内联等, 但这不在这篇博客的讨论范围. 直接派发也有人称为静态调用.因为缺乏动态性所以没办法支持继承. 函数表派发 (Table Dispatch )函数表派发是编译型语言实现动态行为最常见的实现方式. 函数表使用了一个数组来存储类声明的每一个函数的指针. 大部分语言把这个称为 “virtual table”(虚函数表), Swift 里称为 “witness table”. 每一个类都会维护一个函数表, 里面记录着类所有的函数, 如果父类函数被 override 的话, 表里面只会保存被 override 之后的函数. 一个子类新添加的函数, 都会被插入到这个数组的最后. 运行时会根据这一个表去决定实际要被调用的函数. 这种派发方式比起直接派发还是慢一点. 从字节码角度来看, 多了两次读和一次跳转,另一个慢的原因在于编译器可能会由于函数内执行的任务导致无法优化 这种基于数组的实现, 缺陷在于函数表无法拓展. 子类会在虚数函数表的最后插入新的函数, 没有位置可以让 extension 安全地插入函数. 消息机制派发 (Message Dispatch )消息机制是调用函数最动态的方式. 也是 Cocoa 的基石, 这样的机制催生了 KVO, UIAppearence 和 CoreData 等功能. 这种运作方式的关键在于开发者可以在运行时改变函数的行为. 不止可以通过 swizzling 来改变, 甚至可以用 isa-swizzling 修改对象的继承关系, 可以在面向对象的基础上实现自定义派发. Swift中的派发方式开发中遇到比较多的坑 Class中的mainMethod 会使用函数表派发, extension中的extensionMethod 则会使用直接派发. 总结起来有这么几点: 值类型总是会使用直接派发, 简单易懂 而协议和类的 extension 都会使用直接派发 NSObject 的 extension 会使用消息机制进行派发 NSObject 声明作用域里的函数都会使用函数表进行派发. 协议里声明的, 并且带有默认实现的函数会使用函数表进行派发 当然上面说到的也不知道必然的，比较OC这么多年的历史，而且动态特性在某些方面还是有着实际的好处，所以苹果也考虑到了这一点，使用某些手段我们可以指定派发方式 指定派发方式 (Specifying Dispatch Behavior)final final 允许类里面的函数使用直接派发. 这个修饰符会让函数失去动态性. 任何函数都可以使用这个修饰符, 就算是 extension 里本来就是直接派发的函数. 这也会让 Objective-C 的运行时获取不到这个函数, 不会生成相应的 selector. dynamic dynamic 可以让类里面的函数使用消息机制派发. 使用 dynamic, 必须导入 Foundation 框架, 里面包括了 NSObject 和 Objective-C 的运行时. dynamic 可以让声明在 extension 里面的函数能够被 override. dynamic 可以用在所有 NSObject 的子类和 Swift 的原声类. @objc &amp; @nonobjc @objc 和 @nonobjc 显式地声明了一个函数是否能被 Objective-C 的运行时捕获到. 使用 @objc 的典型例子就是给 selector 一个命名空间 @objc(abc_methodName), 让这个函数可以被 Objective-C 的运行时调用. @nonobjc 会改变派发的方式, 可以用来禁止消息机制派发这个函数, 不让这个函数注册到 Objective-C 的运行时里. final @objc 可以在标记为 final 的同时, 也使用 @objc 来让函数可以使用消息机制派发. 这么做的结果就是, 调用函数的时候会使用直接派发, 但也会在 Objective-C 的运行时里注册响应的 selector. 函数可以响应 perform(selector:) 以及别的 Objective-C 特性, 但在直接调用时又可以有直接派发的性能. @inline Swift 也支持 @inline, 告诉编译器可以使用直接派发. 有趣的是, dynamic @inline(__always) func dynamicOrDirect() {} 也可以通过编译! 但这也只是告诉了编译器而已, 实际上这个函数还是会使用消息机制派发. 这样的写法看起来像是一个未定义的行为, 应该避免这么做. 在使用Swift重写之前项目中AppDelegate的时候遇到了一个这样的问题（本文也是由这个问题的产生牵引我学习Swift动态相关内容的） Argument of ‘#selector’ refers to a method that is not exposed to Objective-C (Objective-C 无法获取 #selector 指定的函数). 你如果记得 Swift 会把这个函数优化为直接派发的话, 就能理解这件事情了. 这里修复的方式很简单: 加上@objc 或者 dynamic 就可以保证 Objective-C 的运行时可以获取到函数了. 这种类型的错误也会发生在UIAppearance 上, 依赖于 proxy 和 NSInvocation 的代码. 性能上的提升那么在实际项目中我们应该如何使用Swift结合动态和静态方式提高项目的性能呢？在Swift中，动态调用是通过在一个方法表中找到方法然后执行间接的调用（类似于C++的虚函数表），对于这种先查找再调用的过程，其效率是要低于方法的直接调用，而且间接调用会阻止许多编译器优化，这将加重间接调用的开销。接下来将列举一些技巧来禁用动态派发的行为，以达到提升性能的目的。 当属性、方法、或类不需要被重载时，可在其声明的地方加上final关键字在属性，方法或类声明时加上final关键字，表示其不能被重载，这将允许编译器安全的移除动态派发。如下代码所示，point和velocity将直接从对象的存储属性中加载，updatePoint()方法将被直接调用；另外，update()依然会通过动态派发的方式来调用，这样，ParticleModel的子类就可以重载update()来自定义实现。 class ParticleModel { final var point = ( x: 0.0, y: 0.0 ) final var velocity = 100.0 final func updatePoint(newPoint: (Double, Double), newVelocity: Double) { point = newPoint velocity = newVelocity } func update(newP: (Double, Double), newV: Double) { updatePoint(newP, newVelocity: newV) } } 除了上面所示，在属性和方法声明前加final关键字，还可以直接在类上加final，表示该类将不能作为父类被子类化，隐含的表明该类的所有的方法和属性都是final的。 final class ParticleModel { var point = ( x: 0.0, y: 0.0 ) var velocity = 100.0 // ... } 在属性、方法、或类声明前加private关键字，将限制其只能在同一个文件中被引用在声明前加private关键字，将限制其只能在当前文件中被引用，这将允许编译器在当前文件中找到所有潜在的重载声明，编译器会对这些private关键字的方法或属性进行优化，移除间接的方法调用以及属性访问。 假设在当前文件中没有类重载ParticleModel，那么编译器将移除所有带有private声明的动态派发调用。 class ParticleModel { private var point = ( x: 0.0, y: 0.0 ) private var velocity = 100.0 private func updatePoint(newPoint: (Double, Double), newVelocity: Double) { point = newPoint velocity = newVelocity } func update(newP: (Double, Double), newV: Double) { updatePoint(newP, newVelocity: newV) } } 如上代码所示，point和velocity将直接访问，updatePoint()方法也将直接被调用，而update()方法由于没有加private关键字，依然是只能间接调用。同样，private可以加在类的声明前，等同于类的所有方法和属性都将加上private关键字。 private class ParticleModel { var point = ( x: 0.0, y: 0.0 ) var velocity = 100.0 // ... } 在使用internal的声明中通过使用Whole Module Optimization来隐式的推断出final默认的情况下，Xcode将单独编译源文件，这会限制编译器优化的程度，Xcode 7后，增加了Whole Module Optimization选项，它能允许编译器在同一个模块（Module）中分析所有的源文件来进行优化，可以在Xcode的Building Settings中开启该选项，如下图所示。 在开启Whole Module Optimization选项，且声明为internal(默认级别)的情况下，模块的所有文件将同时被编译，这将允许编译器对整个模块一起分析，并对没有被重载且声明为internal级别的类、方法或属性添加final关键字。如下代码所示，我们修改一下ParticleModel类，添加public关键字： public class ParticleModel { var point = ( x: 0.0, y: 0.0 ) var velocity = 100.0 func updatePoint(newPoint: (Double, Double), newVelocity: Double) { point = newPoint velocity = newVelocity } public func update(newP: (Double, Double), newV: Double) { updatePoint(newP, newVelocity: newV) } } var p = ParticleModel() for i in stride(from: 0.0, through: times, by: 1.0) { p.update((i * sin(i), i), newV:i*1000) } 如上代码，当开启Whole Module Optimization选项的情况下，编译器能在属性point,velotity，以及updatePoint()方法上推断出final，既相当于在point、velocity、updatePoint()声明前加上final关键字，而update()方法由于是public级别，所以无法推断出final关键字，其仍将是间接调用。 总结： 使用静态派发的话结构体是个不错的选择, 而使用消息机制派发的话则可以考虑 NSObject 当你继承 NSObject 的时候, 这是一个你想要完全使用动态消息机制的表现. 当使用private或final关键字，或者开启Whole Module Optimization，声明internal级别的没有被重载的方法，将直接调用，在编译时确定。 运行时决定的动态派发的情形包括： 继承自NSObject或者方法有@objc前缀。 使用Swift的方法表的方式，除去上述情况下，将采用这种方式。]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Swift——动态&amp;静态分析与实战</tag>
        <tag>动态&amp;静态分析与实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift——访问控制关键字说明]]></title>
    <url>%2F2017%2F07%2F01%2FSwift%E2%80%94%E2%80%94%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[有的时候我们从访问控制可以看出代码的质量以及考虑的是否细致，在OC，Java时代我就接触过很多访问控制，但是Swift中又有什么不一样的地方呢？ 首先我们来看OC中的访问控制符 属性访问权限 protected 该类和所有的子类中的方法可以直接访问这样的变量，这是默认的。 private 该类中的方法可以访问这样的变量，子类不可以 可以将变量放在.m中 public 除了自己和子类中的方法外，也可以被其他类或者其他模块中的方法所访问。开放性最大。 package 框架集中 方法访问权限 只有public、private public .h文件 private .m中 其实这里并不默认，因为只有有那么一点基础都应该知道什么意思，但是当我们写Swift的时候，却发现很多地方不一样了。 swift中访问控制一共有5个关键字 open:可以在任何地方访问、继承和重写 public:可以在任何地方被访问，在其他module中不能被继承和重写(一会在详细介绍一下什么是module内和module外) internal:默认访问级别，在整个模块内都可以被访问 fileprivate:其修饰的属性可以再同一个文件被访问、继承和重写，同一个文件指同一个swift文件，一个文件中可以有多个类 private:其修饰的属性和方法只能在本类被访问和使用，不包括扩展类 上面部分是Swift新增的特性。 关键字详解1.private 和 fileprivate这两个访问关键字都是防止文件外访问，但是还是有一些差别的。 在原有的swift中的 private其实并不是真正的私有，如果一个变量定义为private，在同一个文件中的其他类依然是可以访问到的。 在swift 3中，新增加了一个 fileprivate来显式的表明，这个元素的访问权限为文件内私有。过去的private对应现在的fileprivate。现在的private则是真正的私有，离开了这个类或者结构体的作用域外面就无法访问。 2.internalinternal是Swift默认访问级别,所以其实是可以可不写 internal访问级别所修饰的属性或方法在源代码所在的整个模块都可以访问。 如果是框架或者库代码，则在整个框架内部都可以访问，框架由外部代码所引用时，则不可以访问。 如果是App代码，也是在整个App代码，也是在整个App内部可以访问。 3.public1.使用public修饰的类,属性或方法,可以被任何类访问, 2.但在其他的module中不可以被override和继承,而在本module可以; 注意：module内和module外的区别 ： module内是指不需要使用import引用文件，就可以创建对象，表示module内，而module外是指需要使用import文件才能创建对象才能使用 4.open1.可以被任何人使用 2.也可以被override和继承,这是和public的区别]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Swift——访问控制关键字说明</tag>
        <tag>访问控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——App整个启动过程分析]]></title>
    <url>%2F2017%2F06%2F28%2FiOS%E2%80%94%E2%80%94App%E6%95%B4%E4%B8%AA%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[你想知道App是怎么显示到我们眼前的吗？你想知道点击Run之后发生了什么吗？你想知道在Main函数之前都还有那些你不知道操作吗？你想知道在Objective-C和Swift混编的时候这么处理AppDelegate吗？你想知道UIApplication都干了撒吗？你想知道怎么优化App启动过程吗？你想知道…..你撒都想知道，那还等什么？ 前言 本文的起因： 前段时间在研究App启动相关内容，还有启动优化相关的东西，网上寻找了一下相关的资料并试着在整理，也自己试着去验证了其中的一些步骤。 公司项目是Objective-C版本的，大部分相关类都已经使用Swift重写了，后期新增的功能都使用的Swift混合开发。但是由于项目庞大又复杂，没有时间也没有精力去完全使用Swift重写。 因为从Swift一出来我就在学习，但是并没有在实际项目中应用到Swift，从1.0到2.0，再到3.0都有了解和学习相关的语法。但是近四年来一直都在使用OC和学习各种技术，以致于Swift其实该忘的也忘得差不多了。网上有句话：Swift从入门到入门。相信你既然都能看到这里，肯定明白其中的原因。所以我又开始重写学了一遍Swift，这一次是Swift3.1开始学，其实Swift4已经出来了，但是和3.1并没有太大的变化。 因为公司每个星期都有一个技术分享，所以我觉得去试一次，希望能把我知道的东西通过口述的方式分享出来。（不过分享的结果很差，毕竟是第一次，所以导致最后连我自己都不知道自己在说什么），同时这也是我在公司内部做的第一次技术分享的主题。 这一次，我希望能彻底从OC转到Swift进行实际开发。 资料地址： iOS——App整个启动过程分析。如果你觉得有用希望能给个star，或者有什么疑问欢迎issuse也欢迎联系我，谢谢！首先申明，本文大部分会以理论和实际分析，不会涉及的太多的代码实战，也不会涉及到太多相关术语的解释，当然部分会给出链接地址，但是力求从下面几个问题并结合实际App的启动过程，让你了解代码之前所干的事情和处理实际开发中遇到的相关问题…. 点击Run之后发生了什么,以致App能够显示在我们的眼前？ Main函数之前苹果还为我们的App做了哪些操作？ OC项目中怎么使用Swift重写AppDelagate？ UIApplication&amp;UIApplicationMain背后做了什么？ 如何优化App启动过程？…… 本文篇幅会比较长，但是如果你能完全掌握里面的内容和应用，足以让你有一个质的提升，当然这是在你不了解上面我提到的情况下。 好了，废话说太多没有什么意思……开干！ 2016 WWDC（苹果提供的启动优化方案） https://developer.apple.com/videos/play/wwdc2016/406/ 优化 App 的启动时间（各个阶段优化与处理） http://ios.jobbole.com/90331/ iOS 程序 main 函数之前发生了什么 http://blog.sunnyxx.com/2014/08/30/objc-pre-main/ 点击 Run 之后发生了什么？（Build类似） http://www.jianshu.com/p/d5cf01424e92 Xcode编译性能优化（各个阶段优化实战与对比） http://blog.csdn.net/qq_25131687/article/details/52194034]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS——App整个启动过程分析</tag>
        <tag>App整个启动过程分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带你简单理解block和__block的实现？]]></title>
    <url>%2F2017%2F06%2F25%2F%E5%B8%A6%E4%BD%A0%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3block%E5%92%8C-block%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[其实类似block和__block的实现网上随便一搜就能找到无数篇，有些分析的确实非常不错，但是或许有些人刚好就没有那个耐心去看完，有些人就算最后看完也没有理解，甚至还是没能理解其中的核心,所以这里我就根据个人的理解和网上资料的整理，简单的总结一下…… block1.Block其实是闭包 2.Block是基于C语言的拓展 3.Block是基于指针和函数指针实现的， 4.同时他也是一种匿名函数，而且你会发现他和函数其实有很多相似的地方 5.通过打印我们可以知道他其实是一种的结构体 block的实现Block是被设为_NSConcreteStackBlock，在栈上生成。当我们把Block作为全局变量使用时，对应生成的Block将被设为_NSConcreteGlobalBlock Block属性这里还有一点关于block类型的ARC属性。上文也说明了，ARC会自动帮strong类型且捕获外部变量的block进行copy，所以在定义block类型的属性时也可以使用strong，不一定使用copy。也就是以下代码： /** 假如有栈block赋给以下两个属性 **/ // 这里因为ARC，当栈block中会捕获外部变量时，这个block会被copy进堆中 // 如果没有捕获外部变量，这个block会变为全局类型 // 不管怎么样，它都脱离了栈生命周期的约束 @property (strong, nonatomic) Block *strongBlock; // 这里都会被copy进堆中 @property (copy, nonatomic) Block *copyBlock; __blockBlock不允许修改外部变量的值，这里所说的外部变量的值，指的是栈中指针的内存地址。__block 所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。 总结就是：__block对象在block中是可以被修改、重新赋值的。 __block的实现__block其实是堆栈的拷贝， 首先block修饰的变量会变成block_bref_val_0的结构体，它包含实例变量本身__forwarding(用于访问局部变量val)。 block拷贝到堆上的时候： _val_0也会拷贝到堆上，局部变量销毁，block任然能对堆上的局部变量操作 __forwarding替换为堆上的__block变量的地址 栈上的_val_0结构体中的__forwarding指针也会指向堆上的结构体 main函数或者blcok释放的时候，只是释放了栈上的东西，所有对局部变量的操作都已经移到了对上。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层分析</tag>
        <tag>带你简单理解block和__block的实现？</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带你简单理解weak和__weak的实现？]]></title>
    <url>%2F2017%2F06%2F24%2F%E5%B8%A6%E4%BD%A0%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3weak%E5%92%8C-weak%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[其实类似weak和__weak的实现网上随便一搜就能找到无数篇，有些分析的确实非常不错，但是或许有些人刚好就没有那个耐心去看完，有些人就算最后看完也没有理解，甚至还是没能理解其中的核心,所以这里我就根据个人的理解和网上资料的整理，简单的总结一下…… weak字面含义就是弱引用,Objective-C中默认都是强引用的（strong） weak的实现Runtime维护了一个weak表，用于存储指向某个对象的所有weak指针。weak表其实是一个hash（哈希）表，Key是所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象的地址）数组。 weak 的实现原理可以概括一下三步：1、初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。 2、添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。 3、释放时，调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。 __weak__weak修饰符的对象，作用等同于定义为weak的property。他并不会导致循环引用问题（通过苹果文档我们可以得出这样的结论），当原对象没有任何强引用的时候，弱引用指针也会被设置为nil。 __weak的实现简单来说，系统有一个全局的 CFMutableDictionary 实例，来保存每个对象的 weak 指针列表，因为每个对象可能有多个 weak 指针，所以这个实例的值是 CFMutableSet（Array） 类型。 剩下我们要做的，就是在引用计数变成 0 的时候，去这个全局的字典里面，找到所有的 weak 指针，将其值设置成 nil。如何做到这一点呢？Friday QA 上介绍了一种类似 KVO 实现的方式。当对象存在 weak 指针时，我们可以将这个实例指向一个新创建的子类，然后修改这个子类的 release 方法，在 release 方法中，去从全局的 CFMutableDictionary 字典中找到所有的 weak 对象，并且设置成 nil。我摘抄了 Friday QA 上的实现的核心代码，如下： Class subclass = objc_allocateClassPair(class, newNameC, 0); Method release = class_getInstanceMethod(class, @selector(release)); Method dealloc = class_getInstanceMethod(class, @selector(dealloc)); class_addMethod(subclass, @selector(release), (IMP)CustomSubclassRelease, method_getTypeEncoding(release)); class_addMethod(subclass, @selector(dealloc), (IMP)CustomSubclassDealloc, method_getTypeEncoding(dealloc)); objc_registerClassPair(subclass); 总结一句就是：一个通俗的解释就是，在Objective-C的运行时环境中，维护了一种weak表，这张哈希表用对象的首地址作为键，将由若干个weak修饰的指针自身的地址组成的数组作为值。当一个Objective-C对象被释放后，通过这个对象的起始地址来找到所有指向它的weak指针，并将它们指向nil。 __weak的作用在Objective-C中，用__weak修饰的指针，会在所指向的那个Objective-C对象被释放后，自动指向nil。 使用__weak来修饰指针，相比于__unsafe_unretained，可以帮助程序员减小访问野指针的风险，方便了程序员对内存的管理。 block和weak的区别前面提到了block，也大概说了一下其简单实现，所以这里总结一下block和__weak修饰符的区别： 1.__block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型。 2.__weak只能在ARC模式下使用，也只能修饰对象（NSString），不能修饰基本数据类型（int）。 3.__block对象可以在block中被重新赋值，__weak不可以。 4.__block对象在ARC下可能会导致循环引用，非ARC下会避免循环引用，__weak只在ARC下使用，可以避免循环引用。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层分析</tag>
        <tag>带你简单理解weak和__weak的实现？</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分类能添加属性吗？成员变量呢？为什么？]]></title>
    <url>%2F2017%2F06%2F20%2F%E5%88%86%E7%B1%BB%E8%83%BD%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E5%90%97%EF%BC%9F%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%91%A2%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[在iOS开发中，如果你要在不改变原来的类内容的基础上，为类增加一些方法，那么苹果提供了一个很好机制，那就是分类，当然我们平时可能比较多的是直接给他添加方法，并且我们清楚一点的是，我们还能给一个分类添加属性（使用关联对象），但是并不能添加成员变量，可是为什么刚好成员变量就不能连接呢…… 分类概念： Category 分类是OC特有的语言，依赖于类。 分类的作用： 在不改变原来的类内容的基础上，为类增加一些方法。 分类增加属性和方法属性方法 这里其实就不用做过多介绍了，只需要知道分类增加方法其实就和一个类增加一个方法一样。 属性 至于分类增加属性，只要使用到的就是Objective-C里面比较底层的一个技术Runtime，Runtime里面有个里面有个关联对象的概念，具体请查看官方或者相关资料，很简单。 成员变量NO，NO，NO，分类是不能增加属性的，一定没办法，如果你有可以来找我，哈哈…. 为什么不能增加成员变量呢？首先我们不能混淆了成员变量和属性的概念.Property是Property，Ivar是Ivar。 分类里面不能添加Ivar是因为分类本身并不是一个真正的类（Objective-C中真正的类是有一个isa存在的），但是分类并没有自己的ISA . 类最开始生成了很多基本属性，比如IvarList，MethodList，分类只会将自己的method attach到主类，并不会影响到主类的IvarList。 这就是为什么分类里面不能增加成员变量的原因” 类和分类的初始化1.当程序启动时，就会加载项目中所有的类和分类，而且加载后会调用每个类和分类的+load方法，只会调用一次； 2.当第一次使用某个类时，就会调用当前类的+initialize方法； 3.先加载父类，再加载子类（先调用父类的+load方法，再调用子类的+load方法，最后调用分类的+load方法），先初始化父类，再初始化子类（先调用父类的+initialize方法，再调用子类的+initialize方法）。 4.注意：在初始化的时候，如果在分类中重写了+initialize方法，则会覆盖掉父类的。 5.重写+initialize方法可以监听类的使用情况。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层分析</tag>
        <tag>分类能添加属性吗？成员变量呢？为什么？</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么调用nil的任何方法都不会崩溃？]]></title>
    <url>%2F2017%2F06%2F18%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B0%83%E7%94%A8nil%E7%9A%84%E4%BB%BB%E4%BD%95%E6%96%B9%E6%B3%95%E9%83%BD%E4%B8%8D%E4%BC%9A%E5%B4%A9%E6%BA%83%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[我们知道，在Objective-C消息和转发机制的背后有这样一个说法：调用没有实现或者不存在的方法，会导致App崩溃，但是如果你比较细心或者专门研究过消息和转发机制那么你应该听过这样的结论：Objective-C中调用nil的任何方法都不会崩溃，但是，为什么就不会崩溃呢？这里就简单分析一下具体的原因和底层的实现方式…… 访问了一个已经被释放的对象我们知道在不使用 ARC 的时候，内存要自己管理，这时重复或过早释放都有可能导致 Crash。 NSObject * aObj = [[NSObject alloc] init]; [aObj release]; NSLog(@&quot;%@&quot;, aObj); 原因aObj 这个对象已经被释放，但是指针没有置空，这时访问这个指针指向的内存就会 Crash。 解决办法使用前要判断非空，释放后要置空。正确的释放应该是: [aObj release]; aObj = nil; 由于ObjC的特性，调用 nil 指针的任何方法相当于无作用，所以即使有人在使用这个指针时没有判断至少还不会挂掉。 那么这里就有一个问题？为什么调用nil的任何方法都不会崩溃呢？ 首先在Objective-C里，nil对象被设计来跟NULL空指针关联的。他们的区别就是nil是一个对象，而NULL只是一个值。而且我们对于nil调用方法，不会产生crash或者抛出异常。这个技术被framework通过多种不同的方式使用。 最主要的就是我们现在在调用方法之前根本无须去检查这个对象是否是nil。假如我们调了nil对象的一个有返回值的方法，那么我们会得到一个nil返回值。 我们先来看看这断代码： - (void) dealloc { self.caption = nil; self.photographer = nil; [super dealloc]; } 具体原因 之所以可以这么做是因为我们给把nil对象设给了一个成员变量，setter就会retain nil对象(当然了这个时候nil对象啥事情也不会做)然后release旧的对象。这个方式来释放对象其实更好，因为这样做的话，成员变量连指向随机数据的机会都没有，而通过别的方式，出现指向随机数据的情形机会不可避免。 注意到我们调用的self.VAR这样的语法，这表示我们正在用setter，而且不会引起任何内存问题。假如我们直接去设值的话，就会有内存溢出： // incorrect. causes a memory leak. // use self.caption to Go through setter caption = nil; 这里进入提到了崩溃，那么就大概整理一下开发中常见的崩溃问题和类型，方便提前预防和部分相关处理一、访问了一个已经被释放的对象：nil，autorelease 二、访问数组类对象越界或插入了空对象：分类或者runtime替换 三、访问了不存在的方法：判断是否有，runtime修改 四、字节对齐：使用 memcpy 来作内存拷贝，而不是直接对指针赋值 五、堆栈溢出（过多的递归会导致栈溢出，过多的 alloc 变量会导致堆溢出。） 六、多线程并发操作：加锁 ，原子，Operation Objects, GCD, Idle-time notifications, Asynchronous functions, Timers, Separate processes。 七、Repeating NSTimer：写了个宏用来释放Timer]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>为什么调用nil的任何方法都不会崩溃？</tag>
        <tag>底层分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XCode9——还有那些你不知道的新特性？]]></title>
    <url>%2F2017%2F06%2F15%2FXCode9%E2%80%94%E2%80%94%E8%BF%98%E6%9C%89%E9%82%A3%E4%BA%9B%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[苹果在每一年的WWDC都有很多惊喜，同时也有让人赞不绝口的新东西，今年同样不例外，除了新品，新系统，新Swift之外，其中一个很重要也是所有开发中必须关注的就是XCode的新特性，那么今年XCode又推出了那些新特性呢？ Xcode是用于为Apple TV，Apple Watch，iPad，iPhone和Mac创建应用程序的完整开发人员工具集。Xcode开发环境采用tvOS SDK，watchOS SDK，iOS SDK和macOS SDK的形式捆绑Instruments分析工具，Simulator和OS框架 Xcode 9.0需要运行MacOS Sierra 10.12.4或更高版本的Mac。 前言苹果在What is New Xcode中详细介绍了Xcode 9中的新特性，其中开篇就有这样一段话 Xcode 9 includes overall quality improvements as well as extensive new features.+ All new editor: Fast, structure-based editor that lets you intelligently highlight and navigate your code. Includes great Markdown support. + Refactoring: Refactoring built right into the editing experience and works across Swift, Objective-C, Interface Builder, and many other file types. + Super-fast search: The Find navigator returns results instantly. + Debugging: Wirelessly debug iOS and tvOS devices over the network, new debuggers for Metal, and more features throughout Xcode. + Source Control: All new source control navigator and integrated support for GitHub accounts for quickly browsing repositories and pushing your repositories to the cloud. + Xcode Server built-in: Continuous integration bots can be run on any Mac with Xcode 9, no need to install macOS Server. + New Playground templates: Includes iOS templates designed to run well in both Xcode and Swift Playgrounds in iPad. + New Build System: An opt-in preview of Xcode&apos;s new build system provides improved reliability and performance. 如果你对英语不熟悉的话，可能看完上面只有有点懵逼，那么我们来看看具体的中文意思，或者很多东西就能很清楚了！ Xcode 9包括整体质量改进以及广泛的新功能。+ 全新编辑: 快速，基于结构的编辑器，可让您智能地突出显示和浏览代码。包括伟大的Markdown支持。 + 重构: 重构内置于编辑体验之中，并可跨Swift，Objective-C，Interface Builder和许多其他文件类型。 + 超快速搜索: “查找”导航器会立即返回结果。 + 调试: 通过网络无线调试ios和tvOS设备，Metal的新调试器以及Xcode中的更多功能。 + 源控制: 所有新的源代码管理导航器和集成的支持GitHub帐户可以快速浏览资源库并将您的存储库推向云端。 + Xcode服务器内置: 连续集成机器人可以在任何具有Xcode 9的Mac上运行，无需安装macOS Server。 + 新游乐场模板: 包括iOS模板，旨在在iPad中的Xcode和swift Playground中运行良好。 + 新建系统: Xcode新的构建系统的选择性预览提供了更高的可靠性和性能。 所以通过上面的这段话，我们可以得知苹果在XCode还是推出了很多不错的东西，值得前线开发中第一时间研究并学习相关内容，所以我们来具体总结一下，XCode 9到底有那些新特性….. 源代码编辑器。代码编辑器的滚动It scrolls at a constantly smooth rate, no matter the files size. 在Xcode中，你会发现不管文件有多大，滚动都会很平滑，老版本的Xcode会时不时的卡顿。 代码样式give you greater control over line spacing, multiple font styles, and even the type of cursor. 在Preference中增加了对行间距和光标样式的修改。 同时还增加了对资产目录使用命名颜色的支持。 增加了对新边距和基线视图约束的支持。 添加了对自动布局安全区域指南的支持。 增加了对全屏WatchOS应用程序的支持。 Command + 点击行为command-click gesture makes it easy to visualize and select sections of code based on structure. 按住Command点击方法，类，变量的时候，交互方式比之前更加清晰。 Issue提示框Issues have been redesigned to flow nicely with your code with Fix-its are grouped together so you can commit multiple changes in a single click. 错误和警告的提示框在界面上做了重新设计，解决了之前的很多细节上的问题。 MarkDown支持In Markdown files, headings, bold and italic text, links, and other formatting are instantly rendered in the editor as you type. The Jump Bar even understands Markdown structure so you can quickly navigate your README.md and documentation files. 加入了对MarkDown格式的支持。 重构和代码转换添加了一个在Swift中编写的新构建系统的预览。 新的Xcode提供了新的重构和代码转换引擎。当你Command + Click时，Xcode会根据上下文提供对应的重构方式和代码转换，转换引擎是开源的，以后应该会有更多来自其他开发者贡献的代码转换特性。 提供更高的可靠性。 捕获许多项目配置问题。 提高整体构建系统性能。 注意，构建系统性能不包括构建系统使用的编译器，链接器和其他工具。 目前可选，并将成为未来版本的Xcode的默认值。 具体操作：要选择项目或工作区的新构建系统，请选择“文件”&gt;“项目设置”或“文件”&gt;“工作区设置”，然后选择“构建系统”类型的“新建构建系统（预览）”。 对Git的支持Git的管理界面直接以navigator的方式集成到Xcode中，可以方便的对自己的Git Repos进行管理。 之前虽然支持Git，但是并不友好，而且使用起来总让人感觉不够爽，最终很多人选择使用第三方的管理工具，比如SoureTree，tower等。 远程调试想要支持远程调试，你的手机必须升级到iOS11。升级后，连接手机，进入Devices and Simulators。 选中Connect via network，再拔掉数据线就可以了。注意一定要在一个局域网中。 具体可以看我这篇文章：WWDC17惊喜——Xcode9无线调试 同时增加了网络调试相关的内容通过WiFi或有线网络调试iOS和tvOS设备。通过Bonjour连接或输入IP地址。需要插入iOS设备才能启用网络调试。 模拟器支持多个模拟器同时开启，方便自动化测试。 适用于iOS和watchOS模拟器的新Chrome包括硬件控件，并允许轻松拖动和调整模拟设备的大小。 Swift4Swift 4和Swift 3，Swift 4和Swift 3目标的一个编译器可以在同一个项目中编译。 改进的迁移者体验，仅支持将选定目标迁移到Swift 4。 主线程检查检测未在主线程上进行的AppKit，UIKit和WebKit方法调用。在调试期间自动启用，并且可以在方案编辑器的“诊断”选项卡中禁用。主线程检查器与Swift和c语言一起使用。 VR支持查看VR提交和左眼/右眼提交的表面。 添加了纹理检查，用于检查渲染目标中各个像素的值，如颜色，alpha，深度等。 添加检查输出顶点属性到缓冲区编辑器。 添加数据提示支持金属对象，如纹理，缓冲区和采样器。 还有一些大家不曾注意的细节自定义新的文件头。 更新了项目中plist文件文本宏的定义方式。同时为项目中的用户,项目或特定用户定义文本宏。 更新了索引引擎，包括在编译文件时编制索引的能力。 设备窗口被分成用于设备和模拟器的单独窗格，对命名颜色支持。 添加了广泛的应用程序图标。为App图标集添加了更大的iOS营销。同时添加了保留图像矢量数据以选择动态类型缩放的选项。增加了HEIF图像的支持。 最后如果你想了解更多关于XCode9相关特性和信息可以点击这里 What is New Xcode xcode9 新功能]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>WWDC</tag>
        <tag>iOS</tag>
        <tag>XCode9——还有那些你不知道的新特性？</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WWDC17惊喜——Xcode9无线调试]]></title>
    <url>%2F2017%2F06%2F13%2FWWDC17%E6%83%8A%E5%96%9C%E2%80%94%E2%80%94Xcode9%E6%97%A0%E7%BA%BF%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[苹果第28届年度全球开发者大会（WWDC 2017）在6月5日至6月9日（北京时间6月6日凌晨1点）在圣何塞的 McEnery 会议中心举行，到目前为止，我一直在寻找WWDC17中值得开发者庆祝与欢呼的福利…… 其实，苹果几乎在每年WWDC，都会给开发者带来不同的惊喜，从1983年到至今…. WWDC 1983：Lisa开始 WWDC 1998：Mac OS X WWDC 2008：iPhone 3G WWDC 2010：iPhone 4 WWDC 2013：iOS 7 扁平化风 WWDC 2014：Swift问世，以及Swift一路过来的大改版 WWDC 2015：One More Thing WWDC 2016：Siri、iMessage 等软件在多平台的打通 当然还远远不止这些，上面这些都只是在现场产生了欢呼的产品,并且对开发者和用户来说都是非常值得一试的福利，甚至包括其中每一小场中带来的新特性，新功能….. 所以2017年苹果在第28届年度全球开发者大会同样带来了不少的惊喜，比如 macOS High Sierra 苹果音箱HomePod发布 ... 这一届WWDC之后，我第一时间去寻找苹果的各个方面的新特性和新功能，其中发现了一项，值得我放下当下所有任务去研究一下的，那就是：Xcode 9 Beta版的无线调试模式。 如果你曾经是一个iOS开发者或者是学习iOS开发，那么你会发现几个问题。 当我们，每次修改一个东西（方法，一行代码，一个约束，一个资源）都要运行并且拿起手机，运行并测试，当然这个不是重点，重点是你的手机必须使用数据线连接电脑，如果没有链接，那么你撒野干不了，所这个时候可能遇到这样的一些问题。 1.如果你的线坏了，或者解除不良那么又蛋疼了。 2.如果你手机刚刚因为某些原因拔了，那么你又必须重新插上，并且等待链接才能运行测试。 3.如果你有还几个测试机，那么你需要好几条数据线，或者你需要每个分别切换插拔。 4.如果公司某个同事需要一个最新版（比如测试，产品，老板），那么你必须拿到手机插上线，然后Run一下（如果被你发现隐私了怎么办）。 ..... 当然这里面或者你还会遇到一些其他比较特殊的情况，但是这一点苹果怎么会想不到呢？所以WWDC17之后，苹果专门解决了这个问题。那就是我上面提到的，Xcode 9 Beta版的无线调试模式。 那么什么是：无线调试模式呢？ 其实就是你不需要使用数据线链接手机，就可以直接运行一个App到你的手机！ 但是在开始使用的时候，我发现其实还有有一个弊端的，就是第一次始终还是需要链接的，不然没有办法找到你的手机，或者说没有办法配对！ 好了，下面我就通过实际演示来玩转一下这个无线调试模式。 首先请准备好环境。 设备环境：Mac OSX 10.12.5、iOS11、Xcode9 这是WWDC2017的新功能，所以 Mac必须在Mac OSX 10.12.4以上（iOS 9 Beta根本安装不了），这里我是直接升级的，所以直接到了Mac OSX 10.12.5 iOS必须要在iOS11以上 XCode必须在iOS 9 Beta及版以上 配对与测试1. 打开手机，插上数据线，并且能保证手机正常链接电脑和Xcode（如果第一次会有信任的提示） 一般如果链接成功，Mac会自动弹出iTnues，并且显示对应的手机设备。 2. 这个时候，我打开Xcode9 Beta版（如果没有下载请前往Apple developer下载） 这里我Mac中有两个Xcode，那个带BETA标识的就是Xcode9 Beta版，打开之后就可以正式连接配置了！ 打开Xcode导航菜单，然后点击：Windows-&gt;Device and Simulators。找到你已经连接上的设备，把Connect via network选项打勾。 这里iPad和iPhone的连接方式是一样的，没有任何差异！ 3. 点击并选中Connect via network之后，Xcode将会转一会圈圈，耐心等待一会就可以成功了。如果成功你会看到这些标志，没有就代表没有成功，重新再试一次。 此时可以拔掉数据线，但是我们可以看到左侧的设备连接列表上手机仍显示在上面。 4. 同时我们，打开XCode主界面并，点击设备选择的位置，可以看到，已经链接上的设备。 注意，这时候我的数据线已经是没有查上手机的，是不是很神奇！ 然后我就就可以和之前使用数据线链接手机一样直接运行APP，他就会帮我们安装到手机上并且自动启动显示。。 防掉线处理这里我开始以为第一次运行需要链接安装的，验证了一下，发现其实第一次都不需要连接安装，只是第一次验证和配对需要链接数据线…. 但是，是不是到上面就完了呢？其实不然，当我调试了一段时间之后再打开Device and Simulators的时候发现这样的情况！ 有没有发现iPad已经DisConnected了，说明iPad其实已经是自动断开了！ 这个时候我就需要另外做一些配置工作。 1. 回到我们刚刚的设备列表中，选中手机右键，在出来的选项卡中选择一个Connect via IP Address项。 2. 然后输入手机的局域网ip地址。 3. 完成之后，不出意外的话，上面那个问题就解决了。 以后只要之前链接过的手机，并且配置，配对，验证成功的，项目运行之后都可以直接运行起来，并进行测试，不需要再用上面数据线啦，是不是很爽…… 注意点？这里有一点需要注意的 Mac和测试设备（iPhone，iPad，...）必须在同一个局域网下,这个其实应该接不上的都满足的。]]></content>
      <categories>
        <category>WWDC</category>
      </categories>
      <tags>
        <tag>WWDC</tag>
        <tag>WWDC17惊喜——Xcode9无线调试</tag>
        <tag>WWDC17惊喜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个偶然的面试机会——我既然懵了]]></title>
    <url>%2F2017%2F06%2F11%2F%E4%B8%80%E4%B8%AA%E5%81%B6%E7%84%B6%E7%9A%84%E9%9D%A2%E8%AF%95%E6%9C%BA%E4%BC%9A%E2%80%94%E2%80%94%E6%88%91%E6%97%A2%E7%84%B6%E6%87%B5%E4%BA%86%2F</url>
    <content type="text"><![CDATA[刚刚辞职没有几天，其实我并没有打算这么早就去找工作的，就是因为有事情要处理所以才辞职，然后准备在家休息几天的时候，既然突然收到一个电话说叫我去面试的，当时已经是委婉的拒绝了的，但是对方好像很礼貌，而且说看了我的博客网站和工作，很希望能去面试一下，或者了解一下，于是我就了解了一下他们公司的情况，最后通过各方面考虑答应了会准时赴约……. 两天之后我就准时去面试了，并且中间发生了一些挺有意义的事情。 第一面的时候，遇到了一个自称为是我粉丝的人，当然我好像比他还要激动😂😂😂 第三面既然发现老板是老乡，只是很早就来广州发展了，于是我们用方言聊了起来。 其中第一面和第二面的时候大部分都是技术型的问题这里根据自己的记忆，做了一下相关的整理。 部分答案会后期再做整理和分享 第一面：在一个小房间等了几分钟之后，来了两位面试官，面带微笑的跟我握了手，并且其中一位说了一句：你就是iCocos。当时我就懵逼了，结果他告诉我，看了我们的博客网站，github，也一直在关注，曾经还给我评论了，发了邮件请教过问题，当时场面有点尴尬，因为我根本想不起来什么了，然后就这样过了，，，，，，， 第一面主要问了下面这些问题： 说说Swift函数式编程和面向协议编程 TCP，UDP，HTTP，Socket之前的一些区别和理解 你都用Runtime做过撒 KOV和KVC的理解还有底层实现？ 100万个中去出其中最大的100个，你会怎么做？说说为什么这么做？ MVVM结合RAC在实际项目中给你带来了什么方便之处。 如何做数据埋点 说说Objective-C中的消息和转发机制 iOS开发中事件处理是怎么实现的，什么是响应链？…… 第二面：面完第一面之后，又在里面等了大概十分钟，来了一个身材很丰满的大哥，说是公司的技术总监，于是我们就聊了起来。 首先聊的是项目，一开始就教我打开项目演示，并且告诉他那些事我做的，亮点和难点在哪里？ 做过或者了解过音视频编解码吗？说说你所知道的。 CI和CD是怎么什么做的，中间遇到了什么问题？你是这么处理这些问题的？ 这么保证我们开发的项目，数据，源码，请求等更加安全？ 为什么HTTP链接是三次握手，关闭需要四次？ 自动自动释池是什么？ 属性与成员变量的区别？ 什么是RunLoop？ 什么是Blcok，使用的时候需要注意什么？还有__block的实现是什么？ 说说多线程，并说说你使用最多的方式，为什么？……… 一二面总结到这里，两轮面试大概就完了，当然上面大概是我所能想起来的一些，其中还有一些随便聊到的，具体问题也不记得了，但是大概能起一下关键字什么的？ 比如： 轮询 Swift FMDB安全 WWDC2017新东西 SwiftJSON Mansory 签名机制 几个常用第三方的理解和实现 第二面：两轮技术面试完了之后，接来下是最后一轮，第三轮，是和老板聊，和老板聊的时候，感觉就不一样了，老板看了我的简历说，我们既然是老乡，然后就直接用起来老家话，聊了一伙，虽然是老乡，但是毕竟人家是老板，我是来面试的，也不能太嚣张，所以一路下来我还是很礼貌变现很正常的回答他的问题，并且最后走的时候还留了他的微信和电话…… 就这样整个面试就结束了，讲真的，这场面试还是有很多东西值得学习的，不管是前面两轮技术上的知识，即使很多我都快忘了。还是后面跟老板聊到的一下生活，理想上的问题，我都有在思考...... 面试已经过去两天了，暂时还没有收到什么消息，虽然我并没有太多期望，我也知道前面技术面试表现并不是很好，不管是因为我知识面不够还有理解的不够深入，我觉得这一次还是值得了，因为至少我知道了自己还有很多方面是不足的！ 之后大概整理一下，上面一些相关的技术问题和部分问题的答案，由于个人能力有限，如果有不对或者误解的地方，还有见谅并指出，谢谢！消息消息机制：忽略-nil-IMP-缓存-方法（重复父-根）-存或者转发-函数指针-实现 转发机制：动态（动态添加），标准（别的对象执行），快速（其他形式执行），发送消息获取签名，非空就转发，否则奔溃退出 事件响应：view-VC/父视图-window-application-丢弃 传递：事件添加到application队列-取出传递给窗口-寻找最适合View（主窗口是否接受-触摸点是否在自己身上-重复子控件）-没有就自己处理调用touches KOV&amp;KVCKVO基于KVC，KVC基于Runtime KVC：字符串非访问器，类型混合指针：方法名-环境变量-结合isa找接口-找实现。检测ket对应的set方法-同名_key成员属性-同名属性_key-undefine. KVO：创建派生类-重写setter方法（isa假的,指向的是派生类），willchange，didchange监听内部path Blockblock（闭包）：C语言的拓展，基于指针和函数指针，一种匿名函数的结构体； 堆栈的拷贝，__block修饰的变量会变成__block_bref_val_0的结构体，它包含实例变量本身__forwarding(用于访问局部变量val)。 block拷贝到堆上的时候： _val_0也会拷贝到堆上，局部变量销毁，block任然能对堆上的局部变量操作 __forwarding替换为堆上的__block变量的地址 栈上的_val_0结构体中的__forwarding指针也会指向堆上的结构体 main函数或者blcok释放的时候，只是释放了栈上的东西，所有对局部变量的操作都已经移到了对上。 Copyblock：MRC传下来的，MRC中block在栈去，copy将其放到堆区，ARC中不写也可以的，编译器对block进行了copy操作 NSString:对应可变类型，防止被修改。 不可变使用strong，防止判断影响性能。不可变的数据类型线程更安全。 GCD基于XNU，在libdispatch库，queue管理block操作，source：处理事件， 基于C语言（NSO基于GCD），只支持FIFO（NSO可调整和设置并发数），依赖复杂（NSO简单且支持KVO），速度快。任务添加到队列，NST使用NSObject的分类实现通讯 RunLoop运行循环（不断处理事件），至少一个时间源，事件接受与分发机制，一步执行不能并行执行，保证程序执行的线程不被终止，有事情做的时候，根据具体事件类型通知应用做出响应，没有就会进入休眠，省电，再次发生会唤醒处理事件（通过Observer监听，并释放自动释放池）。 input：传递异步时间，通讯与传输 timer：传递同步事件 销毁发生在线程结束的时候，很少主动创建，而是把事件添加到runloop。每次RonLoop完成一个缓存都会检测retainCount是否为0 成员变量和属性属性=成员变量+get+set，编译器自动合成，@dy告诉编译器我们自己实现，没有实现编译的时候没有问题，运行的时候就会报错，说找不到对应的方法。 成员变量地址可根据实例的内存地址偏移寻址，属性读写需要函数调用（访问器），相对更慢，C++成员变量更合适（不支持copy等） 多线程情况保证数据一致，同步执行的时候使用成员变量，同步的时候set，get会降低效率，锁影响 成员变量可以直接管理内存，属性进行了多层封装，还能复写，容易出错 默认用属性生成不必要的set，get方法，体积变大 自动释放池（存储指针变量）&amp;AutorreleasePoolautorrelease把对象放入到自动释放池（延迟释放），自动释放池释放的时候，内部的对象引用计数-1， AutorreleasePool：接受对象向他发送的release消息，记录该对象的release消息，自动释放池销毁的时候，想池中记录的对象发送release消息 释放时机：autorrelease的}执行完后，实际是autorrelease对象在当前Runloop（Push，Pop）迭代结束的时候释放 AutorreleasePoolPage（Push，Pop）一个个page组成，4096字节大小，每个AutorreleasePoolPage双向链表链接形成一个自动释放池。 三次和四次服务端接受到客户端的请求信号报文后，可以直接发送信号和应答报文。关闭的是，服务端收到信号报文的时候，很可能不会立即关闭，只能先回一个应答报文，告诉客户端我收到了你的报文，只有等服务端所有报文发送我哪里才会发送关闭的信号报文，所以不能一起发送 总结长轮询：服务端的程序加入到一个死循环，在循环中检测数据的变动 desc：NSLog底层调用，Array答应打印元素，NSObject打印类名和指针 区块链：一串使用密码学方法相关联产生的数据块（包含比特币网络交易信息，验证有效和产生下一个快） KVC：因为使用字符串所以比较慢，无法检测错误 Swift：隐含一个Main函数，会设置并调用全局的C_ARGC C_ARGV，调用由top level code构成的top_level_code（）函数 FMDB安全：创建一个GCD线程队列，读取时调用inDatabase方法，在block锁定数据库，实际对应整个数据库加锁 数组和字典：每个对象或者成为key/value时，对象计数器+1（retain），当字典或者数组销毁的时候，里面所有的元素或者key/value都会被release一次（-1）， Xcode9无线调试，APFS，ARKit， “”，string：常量 format：堆 HTTPS=HTTPS+TLS（运行在TCP之上），TLS有独立的握手，链接，验证机制，任何一个数据包篡改，都失败，当我们使用HTTP协议来解释TLS曾携带的内容就是HTTPS maker加入到blcok，遍历block中约束数组install YYText：Label，Text，CoreT，图文，MacD，表情，编辑，竖 SwiftJSON不要一直判断是否存在，是否是我们想要的class，内部自动对optional拆包 SD在单例情况下，缓存使用url，磁盘使用md5 Alamofire不是类，只是命名空间，通过参数调用Manager具体方法，几乎所有操作都是通过Manager控制 RAC（singal流），RXS（Observable），监听管道sequence（状态之间的依赖，MVC中Controller中的复杂和臃肿，统一消息处理机制） iJK（VideoToolBox，OpenGL ES，AudioQueue），视频（软硬编码），音频（软编码），从解码钱的数据缓冲区中取出一帧数据进行解码，完成后放入相应的解码后的数据缓冲区 load父先子，类先分， cache缓存指针和vtable，加速方法调用，bits存类的方法属性协议等信息 extra_rc存额外的自动引用计数，实际计数在此基础+1，使用isa的extra_rc和SideTable存引用计数 空指针：赋值为nil，僵尸对象：对中已经被释放的对象count=0，野指针：指针没有初始化，只想的空间被释放，OC中没有空指针异常 泄露：提前赋nil，没有配对或者清空，栈区释放了，堆去没有释放 溢出：容量超过限制 类的结构isa最前面，父类的实例变量在子类的实例变量之前 define：编译器，替换，无内存，不检测类型 __block在MRC和ARC中都可以使用，可以是对象和基本类型，__weak只能在ARC中使用，只能是对象。__block可以在block在block中重新复制，但是__weak不行。 签名机制：通过摘要算法得到摘要，用私钥对摘要加密得到密文，密文+原文本+私钥对应的公钥一起发布 Get：1024k UDP：64kb AFN：60s SD:一周 线程：64个]]></content>
      <categories>
        <category>Meeting</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>一个偶然的面试机会——我既然懵了</tag>
        <tag>Meeting</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WWDC17——都有那些值得你去了解的？]]></title>
    <url>%2F2017%2F06%2F06%2FWWDC17%E2%80%94%E2%80%94%E9%83%BD%E6%9C%89%E9%82%A3%E4%BA%9B%E5%80%BC%E5%BE%97%E4%BD%A0%E5%8E%BB%E4%BA%86%E8%A7%A3%E7%9A%84%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[苹果第28届年度全球开发者大会（WWDC 2017）在6月5日至6月9日（北京时间6月6日凌晨1点）在圣何塞的 McEnery 会议中心举行…… 苹果WWDC2017Apple Watch 1. 系统watchOS迭代到了第四代，加入了更智能的语音助手Siri表盘。用语音即可操控整块手表，交互进一步升级。 2. 更多迪士尼的经典人物加入表盘内显示，同时还可以根据用户的动作产生互动。比如你甩下手表，那个动画人物就飞出表盘外了。 3. 更智能能的运动App，可以对你的训练提出建议，还可以同时监视用户两项运动数据。对于喜欢健身的朋友来说比较实用。 4. 增加与健身器材的互动。比如手机靠近跑步机，就能读取到跑步机里的数据，当然这对跑步机也有要求。目前苹果已经和部分知名健身器材厂家展开了合作，在相关器材了加入了对Apple Watch的支持。 5. 增加与“音乐”应用的互动，开始运用时音乐会自动播放，还能根据不同的运动切换到不同的音乐。 mac OS 1. 新系统macOS High Sierra登场。命名上毫无创意，在现有的macOS Sierra中间加了个“High”单词。主持人居然还说是在行走高山时触发灵感才想到的…… 2. 浏览器Safari加入了自动屏蔽. 智能防跟踪功能，尽可能地保护你的个人隐私。在此之前主持人惯例商业管理吹一波，表现目前Safari是地表最强. 最快的浏览器。 3. 照片功能加入了新的UI，更方便归类和查找，同时增强了照片编辑功能，但显然不可能达到专业的图片处理软件水平。 4. metal功能升级到metal2，整体调用速度提升十倍，变得更加智能，进行外部显示连接，可以帮助开发者创作VR。所有支持Sierra系统的设备都可以支持High Sierra。 iMac 1. 显示器略有提升，处理器升级到英特尔第七代KabyLake处理器；显卡方面，27英寸版的iMac采用了AMD Radeon 570/580显卡。 2. 21.5 英寸配备Retina 4K显示屏的iMac降价，13英寸的MacBook Pro也降价了。 3. iMac Pro发布！主持人表示这是目前最强大的MAC电脑，把工作站级的性能带到MAC。它配备英特尔8核心XEON处理器，最高选配18核心XEON处理器;搭载AMD Radeon Vega系列显卡，拥有16GB显存，可以实现22Teraflops运算。存储方面，iMac Pro提供了128GB ECC内存. 4TB最高3GB/秒传输率SSD。iMac Pro还可以连接2个5K显示器。 4. 同样配置的工作站大约要7000美刀起，而IMAC PRO只需要4999美刀，并于今年12月开始发货。 iOS 1. iOS11正式发布，主持人说是“大版本更新”。短信功能imessage重新设计app贴纸，可以与其他iOS设备同步。 2. 到年底，美国将有50%以上的商店将支持Apple pay，并且Apple pay现在支持个人转账了!这方面我国的“微信”和“支付宝”早已走在了苹果的前面。 3. Siri通过深度学习变得更加智能，支持英文转中文. 法语. 德语. 意大利语. 西班牙语的翻译功能，支持ios设备的同步。 4. 通知界面改进，支持3d touch展开，也就是说你在锁屏界面时，可以通过不同按压力度打开对应的通知界面，不再单纯依靠上下左右滑动来交互。 5. 相册功能增加。动态图片支持反向播放，直接在相册里编辑还能实现长曝光功能。比如拍摄一组瀑布的动态照片，通过图片编辑就能变成一张长曝光摄像手法的图，无需在事先打开其他特效相机。 6. 地图加入更多的信息，还有支持店铺搜索，就像商场里每一层的店铺导购图那样。不过目前只支持机场的店铺搜索，而且都是美国的机场。 7. 用地图导航时，还支持免打扰功能(黑屏)，这时手机不会受到任何消息，这时别人发短信给你，系统会自动回复我在开车的信息，确保安全。 8. App store重新设计，加入“today(今天)“标签，里面有众多分类。以“游戏”分类为例，有新的应用详情页展示，查看内购项目信息;还可以查看编辑推荐的游戏和攻略。“Home”工具提供全自动控制家中电器的方式，新增音响类型。顺便一提iOS11上的“音乐”应用支持SNS功能，像QQ音乐那种，可以看到你好友最近听什么歌，喜欢听什么类型的歌。 9. “Home”工具提供全自动控制家中电器的方式，新增音响类型。顺便一提iOS11上的“音乐”应用支持SNS功能，像QQ音乐那种，可以看到你好友最近听什么歌，喜欢听什么类型的歌。 10. iOS11特别为中国用户做了优化，比如在锁屏界面上就可以扫描二维码，还支持上海话识别等。 iPad相关 1. 全新iPad Pro发布，第一款10.5英寸iPad Pro，重量更轻，只有前代的一半。 2. iPad Pro的屏幕进一步升级，拥有更广的色域和更高的亮度，支持120Hz刷新率。坦白说高刷新率除了打游戏外，基本没什么luan用，还会增加功耗。 苹果WWDC2017小结：中国式的系统升级 3. 性能方面采用A10X六核处理器，性能提升30%，图像性能提升40%。前置700万+后置1200万摄像头，可以使用USB C接口充电器。价格方面649美刀起售，今天能够预定，下周发货。iPad Pro今年秋季也会升级到IOS11。 4. iOS 11在iPad上加入MAC上的DOCK功能;截屏功能现在支持编辑;点击Apple Pencil上按钮点击后直接进入“笔记”应用，支持摄像头文档扫描。 苹果HomePod相关 1. 苹果音箱HomePod发布，支持各种音效. 声场混合调节，和Apple Music配合还能满足音乐发烧友要求。 2. 通过HomePod内置的6个麦克风可以唤醒Siri功能。默认下，在家里只要喊一声“Hey Siri”就可以HomePod自动播放音乐。 3. HomePod的价格为349美刀，拥有白色和黑色版，今年12月在美国. 英国. 澳大利亚上市。 4. 主持人表示，如果在家里觉得一个HomePod的音效满足不了你，那就买两个。]]></content>
      <categories>
        <category>WWDC</category>
      </categories>
      <tags>
        <tag>WWDC17——都有那些值得你去了解的？</tag>
        <tag>WWDC</tag>
        <tag>2017</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift3——Swift3中的Runtime]]></title>
    <url>%2F2017%2F05%2F25%2FSwift3%E2%80%94%E2%80%94Swift3%E4%B8%AD%E7%9A%84Runtime%2F</url>
    <content type="text"><![CDATA[记得学习OC的时候直到第二年才开始接触到Runtime，之前一直都是基础，UI，项目的简单开发，当我真正接触Runtime的时候，有种相见恨晚的感觉，之后再项目中也有经常使用到相关技术，当然15年开始Runtime在面试中也变得非常重要了…… Swift3 Runtime纯Swift类没有动态性，但在方法、属性前添加dynamic修饰可以获得动态性。 Runtime是一套比较底层的纯C语言的API,属于C语言库, 包含了很多底层的C语言API。在我们平时编写的iOS代码中, 最终都是转成了runtime的C语言代码。 所谓运行时，也就是在编译时是不存在的，只是在运行过程中才去确定对象的类型、方法等。利用Runtime机制可以在程序运行时动态修改类、对象中的所有属性、方法等。 还记得我们在网络请求数据处理时，调用了-setValuesForKeysWithDictionary:方法来设置模型的值。这里什么原理呢？为什么能这么做？其实就是通过Runtime机制来完成的，内部会遍历模型类的所有属性名，然后设置与key对应的属性名的值。 我们在使用运行时的地方，都需要包含头文件：#import &lt;objc/runtime.h&gt;。如果是Swift就不需要包含头文件，就可以直接使用了。 Swift中如何使用runtimeSwift代码中已经没有了Objective-C的运行时消息机制, 在代码编译时即确定了其实际调用的方法. 所以纯粹的Swift类和对象没有办法使用runtime, 更不存在method swizzling. 为了兼容Objective-C, 凡是继承NSObject的类都会保留其动态性, 依然遵循Objective-C的运行时消息机制, 因此可以通过runtime获取其属性和方法, 实现method swizzling. 获取对象所有属性名利用运行时获取对象的所有属性名是可以的，但是变量名获取就得用另外的方法了。我们可以通过class_copyPropertyList方法获取所有的属性名称。 对于Swift版，使用C语言的指针就不容易了，因为Swift希望尽可能减少C语言的指针的直接使用，因此在Swift中已经提供了相应的结构体封装了C语言的指针。但是看起来好复杂，使用起来好麻烦。看看Swift版的获取类的属性名称如何做： class Person: NSObject { var name: String = &quot;&quot; var hasBMW = false override init() { super.init() } func allProperties() -&gt;[String] { // 这个类型可以使用CUnsignedInt,对应Swift中的UInt32 var count: UInt32 = 0 let properties = class_copyPropertyList(Person.self, &amp;count) var propertyNames: [String] = [] // Swift中类型是严格检查的，必须转换成同一类型 for var i = 0; i &lt; Int(count); ++i { // UnsafeMutablePointer&lt;objc_property_t&gt;是 // 可变指针，因此properties就是类似数组一样，可以 // 通过下标获取 let property = properties[i] let name = property_getName(property) // 这里还得转换成字符串 let strName = String.fromCString(name); propertyNames.append(strName!); } // 不要忘记释放内存，否则C语言的指针很容易成野指针的 free(properties) return propertyNames; } } 测试一下是否获取正确： let p = Person() p.name = &quot;Lili&quot; // 打印结果：[&quot;name&quot;, &quot;hasBMW&quot;]，说明成功 p.allProperties() 获取对象的所有属性名和属性值对于获取对象的所有属性名，在上面的-allProperties方法已经可以拿到了，但是并没有处理获取属性值，下面的方法就是可以获取属性名和属性值，将属性名作为key，属性值作为value func allPropertyNamesAndValues() -&gt;[String: AnyObject] { var count: UInt32 = 0 let properties = class_copyPropertyList(Person.self, &amp;count) var resultDict: [String: AnyObject] = [:] for var i = 0; i &lt; Int(count); ++i { let property = properties[i] // 取得属性名 let name = property_getName(property) if let propertyName = String.fromCString(name) { // 取得属性值 if let propertyValue = self.valueForKey(propertyName) { resultDict[propertyName] = propertyValue } } } return resultDict } 测试一下： let dict = p.allPropertyNamesAndValues() for (propertyName, propertyValue) in dict.enumerate() { print(&quot;propertyName: (propertyName), propertyValue: (propertyValue)&quot;) } 打印结果与上面的一样，由于array属性的值为nil，因此不会处理。 propertyName: 0, propertyValue: (“name”, Lili) 获取对象的所有方法名通过class_copyMethodList方法就可以获取所有的方法。 func allMethods() { var count: UInt32 = 0 let methods = class_copyMethodList(Person.self, &amp;count) for var i = 0; i &lt; Int(count); ++i { let method = methods[i] let sel = method_getName(method) let methodName = sel_getName(sel) let argument = method_getNumberOfArguments(method) print(&quot;name: (methodName), arguemtns: (argument)&quot;) } } 测试一下调用： p.allMethods() 获取对象的成员变量名称要获取对象的成员变量，可以通过class_copyIvarList方法来获取，通过ivar_getName来获取成员变量的名称。对于属性，会自动生成一个成员变量。 Swift的成员变量名与属性名是一样的，不会生成下划线的成员变量名，这一点与Oc是有区别的。 func allMemberVariables() -&gt;[String] { var count:UInt32 = 0 let ivars = class_copyIvarList(Person.self, &amp;count) var result: [String] = [] for var i = 0; i &lt; Int(count); ++i { let ivar = ivars[i] let name = ivar_getName(ivar) if let varName = String.fromCString(name) { result.append(varName) } } return result } 测试一下： let array = p.allMemberVariables() for varName in array { print(varName) } 打印结果，说明Swift的属性不会自动加下划线，属性名就是变量名： name array 运行时发消息iOS中，可以在运行时发送消息，让接收消息者执行对应的动作。可以使用objc_msgSend方法，发送消息。 很抱歉，似乎在Swift中已经没有这种写法了。如果有，请告诉我。 Category扩展”属性”iOS的category是不能扩展存储属性的，但是我们可以通过运行时关联来扩展“属性”。 Swift版的要想扩展闭包，就比OC版的要复杂得多了。这里只是例子，写了一个简单的存储属性扩展。 let s_HYBFullnameKey = &quot;s_HYBFullnameKey&quot; extension Person { var fullName: String? { get { return objc_getAssociatedObject(self, s_HYBFullnameKey) as? String } set { objc_setAssociatedObject(self, s_HYBFullnameKey, newValue, .OBJC_ASSOCIATION_COPY_NONATOMIC) } } } Objective-C Category 可以随意重写本类的方法, Swift的Extension虽然易用, 但仍然没有Category那样方便的重写方法. Swizzle还是可以在Extension替换掉本类的任意方法. (Swift修改CocoaPods管理的第三库福音) 目前Swift3对于这个并不友好. Swift调用方法的时候是直接访问内存, 而不是在运行时查找地址, 意味着普通的方法, 你需要在方法前加dynamic修饰字, 告诉编译器跳过优化而是转发. 否则你是拦截不到方法.(注:viewDidLoad等方法不用加daynamic也可以截取到方法) class Swizzler { dynamic func originalFunction() -&gt; String { return &quot;Original function&quot; } dynamic func swizzledFunction() -&gt; String { return &quot;Swizzled function&quot; } } let swizzler = Swizzler() print(swizzler.originalFunction()) // prints: &quot;Original function&quot; let classToModify = Swizzler.self let originalMethod = class_getInstanceMethod(classToModify, #selector(Swizzler.originalFunction)) let swizzledMethod = class_getInstanceMethod(classToModify, #selector(Swizzler.swizzledFunction)) method_exchangeImplementations(originalMethod, swizzledMethod) print(swizzler.originalFunction()) // prints: &quot;Swizzled function&quot; 在开发中，我们比较常用的是使用关联属性的方式来扩展我们的“属性”，以便在开发中简单代码。我们在开发中使用关联属性扩展所有响应事件、将代理转换成block版等。比如，我们可以将所有继承于UIControl的控件，都拥有block版的点击响应，那么我们就可以给UIControl扩展一个TouchUp、TouchDown、TouchOut的block等。 对于动态获取属性的名称、属性值使用较多的地方一般是在使用第三方库中，比如MJExtension等。这些三方库都是通过这种方式将Model转换成字典，或者将字典转换成Model。 这里, 要注意Swift的代码与Objective-C代码的语法区别.同时, 对于一般OC代码的method swizzling, 在load方法中执行即可. 而Swift没有load, 所以要在initialize中执行. 使用方式: btn.cs_accpetEventInterval = 1.0 Swift中的@objc和dynamic关键字继承自NSObject的类都遵循runtime, 那么纯粹的Swift类呢? 在属性和方法之前加上@objc关键字, 则一般情况下可以在runtime中使用了. 但有一些情况下, Swift会做静态优化而无法使用runtime. 要想完全使得属性和方法被动态调用, 必须使用dynamic关键字. 而dynamic关键字会隐式地加上@objc来修饰. 获取Swift类的runtime信息的方法, 要加上Swift模块名: id cls = objc_getClass(&quot;DemoSwift.MySwiftClass&quot;)]]></content>
      <categories>
        <category>Swift3</category>
      </categories>
      <tags>
        <tag>Swift3</tag>
        <tag>Swift3——Swift3中的Runtime</tag>
        <tag>Swift3中的Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift3——Swift内存管理]]></title>
    <url>%2F2017%2F05%2F23%2FSwift3%E2%80%94%E2%80%94Swift%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[记得学习OC的前期时候内存管理一直是个过不去的坑，虽然我是从ARC开始学起的，但是不管面试，实际开发中特殊问题，还是一些开源的项目大部分还是使用的MRC，导师还是遇到不少的困难，那么Swift重内存管理又是怎样的呢…… 作为一种现代化高级编程语言，Swift为您的应用程序中的分配、释放等内存管理需求提供强有力的支持。它使用的是一种称为自动化引用计数（ARC）的技术。通过本文的学习，你将通过以下内容进一步提升你的Swift开发中的ARC编程水平： 1.分配（从堆栈或堆中分配内存） 2.初始化（init代码运行） 3.使用（使用对象） 4.析构（deinit代码运行） 5.释放（内存又回到了堆栈或堆） 虽然没有直接的钩子技术埋伏到内存分配和内存回收中，但是您可以在init和deinit方法中 使用print语句作为代理手段来监控上述过程。注意，尽管上面过程4和5中的释放和析构两个方法常常交替使用，但实际上它们是在一个对象的生命周期中的两个不同的阶段。 引用计数是当不再需要对象时被释放的机制。这里的问题是：“你何时可以肯定未来不会需要这个对象？”通过保持一个使用次数的统计计数，即“引用计数”即可实现这一管理目的。引用计数存储于每一个对象实例内部。 上面的计数能够确定，有多少“东西”引用了对象。当一个对象的引用计数降为零时，也就是说对象的客户端不再存在；于是，对象被析构和解除内存分配 ARC与GC很多人分不清ARC（Automatic Reference Counting，自动引用计数）跟GC（Garbage Collection，垃圾收集）的区别。其实“引用计数法”也算是一种GC策略，只不过我们现在提到GC的时候一般是指基于“标记－整理”策略的垃圾收集器，譬如主流的JVM（Java虚拟机）几乎都是采用“标记－整理”＋“分代收集”的策略来进行自动内存管理的。标记算法一般是从全局对象图的“根”出发进行可达性分析，对象的生死会被批量地标记出来，之后再在某个时间批量地释放死对象。显然，这是一种“全局＋延时”的管理策略。 而与之相对的，引用计数是一种“局部＋即时”的内存管理策略。它不需要全局的对象信息，一般每个被管理的对象都会跟一个引用计数器关联，这个计数器保存着当前对象被引用的次数，一旦创建一个新的引用指向该对象，引用计数就加1，每当指向该对象的某个引用失效引用计数就减1，直到引用计数为0，就立即释放该对象。使用引用计数法管理内存的语言也不止OC和Swift，还有诸如CPython之类的GC也是基于引用计数的。 早年OC是采用MRC（手动引用计数）的，当然其实现在也有人还在用，它跟ARC的主要区别在于它需要手动管理引用计数器，而ARC是自动管理的。所以其实MRC也不能让你直接释放对象的，只是控制引用罢了。 ARC的功能在每一次一个新的类实例被创建时ARC分配一块内存以存储信息 init() 关于实例类型和其值的信息存储在存储器中 当类实例不再需要它自动由 deinit() 释放，用于进一步类实例的存储和检索的存储空间 ARC保存在磁道当前参照类实例的属性，常量和变量，使得 deinit() 仅适用于那些不使用的实例。 ARC维护“强引用”这些类实例属性，常量和变量来限制释放当当前的类实例正在使用。 Swift中内存管理包括哪些呢？1、内存管理，weak和unowned 2、@autoreleasepool 3、C 指针内存管理 1、内存管理，weak和unowned1.Swift中的unowned等效于OC中的unsafe_unretained，而Swift中的weak就是OC中的weak。如果能够确定在访问时不会已被释放，就尽量使用unowned；如果存在被释放的可能，那就选择用weak。 2.被标记为weak的变量一定需要是Optional值。 3.闭包和循环引用 lazy var printName: () —&gt; () = { [weak self] in if let strongSelf = self { print(“The name is \(strongSelf.name)”) } } //self持有闭包，闭包又持有self，循环引用。为了解决这种闭包内的循环引用，我们需要在闭包开始的时候添加一个标注，来表示这个闭包内的某些要素应该以何种特定的方式来使用，比如像这里的[weak self]。 这种在闭包参数的位置进行标注的语法结构是将要标注的内容放在原来参数的前面，并使用括号括起来。如果有多个需要标注的元素的话，在同一个中括号内用逗号隔开。 { [unowned self, weak someObject] (number: Int) —&gt; Bool in //…… return true } 2、@autoreleasepoolSwift中的自动释放池的创建语法： autoreleasepool { let data = NSData.dataWithContentsOfFile(path, options: nil, error: nil) //dataWithContentsOfFile返回的autorelease对象。在Swift中更提倡的是用初始化方法而不是用像上面那样的类方法来生成对象，而且从Swift 1.1开始，因为加入了可以返回nil的初始化方法，像上面例子中那样的工厂方法都已经从API中删除了。 } let data = NSData(contentsOfFile: path) //使用初始化方法的话，我们就不需要面临自动释放的问题了，每次在超过作用域后，自动内存管理都将为我们处理好内存相关的事情。 3、C 指针内存管理在Swift中C指针的内存需要自己手动管理。 class Employee { ① var no : Int var name : String var job : String var salary : Double init(no : Int, name: String, job : String, salary : Double) { ② self.no = no self.name = name self.job = job self.salary = salary println(&quot;员工\(name) 已经构造成功。&quot;) ③ } deinit { ④ println(&quot;员工\(name) 已经析构成功。&quot;) ⑤ } } var ref1: Employee? ⑥ var ref2: Employee? ⑦ var ref3: Employee? ⑧ ref1 = Employee(no: 7698, name: &quot;Blake&quot;, job :&quot;Salesman&quot;, salary : 1600) ⑨ ref2 = ref1 ⑩ ref3 = ref1 ⑪ ref1 = nil ⑫ ref2 = nil ⑬ ref3 = nil ⑭ 代码解释上述代码第①行声明了Employee类，第②行代码是定义构造器，在构造器中初始化存储属性，并且在代码第③行输出构造成功信息。第④行代码是定义析构器，并在代码第⑤行输出析构成功信息。 代码第⑥~⑧行是声明3个Employee类型变量，这个时候还没有创建Employee对象分配内存空间。代码第⑨行是真正创建Employee对象分配内存空间，并把对象的引用分配给ref1变量，ref1与对象建立“强引用”关系，“强引用”关系能够保证对象在内存中不被释放，这时候它的引用计数是1。第⑩行代码ref2 = ref1是将对象的引用分配给ref2，ref2也与对象建立“强引用”关系，这时候它的引用计数是2。第⑪行代码ref3 = ref1是将对象的引用分配给ref3，ref3也与对象建立“强引用”关系，这时候它的引用计数是3。 然后在代码第⑫行通过ref1 = nil语句断开ref1对Employee对象的引用，这时候它的引用计数是2。以此类推，ref2 = nil时它的引用计数是1，ref3 = nil时它的引用计数是0，当引用计数为0的时候Employee对象被释放。 我们可以测试一下看看效果，如果设置断点单步调试，会发现代码运行完第⑨行后控制台输出： 员工Blake 已经构造成功。 析构器输出的内容直到运行完第⑭行代码才输出： 员工Blake 已经析构成功。 这说明只有在引用计数为0的情况下才调用析构器，释放对象。 在 Swift 中，对引用描述的关键字有三个：strong，weak 和 unowned，所有的引用没有特殊说明都是 strong 强引用类型。在 ARC 中，只有指向一个实例的所有 strong 强引用都断开了，这个实例才会被销毁。 循环强引用（Strong Reference Cycles）但是，在某些情况下，一个类实例的强引用数永远不能变为 0，例如两个类实例互相持有对方的强引用，因而每个类实例都让对方一直存在，这就是所谓的强引用循环（Strong Reference Cycles）。 什么时候使用 weak？当两个实例是 optional 关联在一起时，确保其中的一个使用 weak 弱引用，就像上面所说的那个例子一样。 unowned 无主引用在某些情况下，声明的变量总是有值得时候，我们需要使用 unowned 无主引用。 什么时候使用 unowned 无主引用？两个实例 A 和 B，如果实例 A 必须在实例 B 存在的前提下才能存在，那么实例 A 必须用 unowned 无主引用指向实例 B。也就是说，有强制依赖性的那个实例必须对另一个实例持有无主引用。 例如上面那个例子所说，银行客户可能没有信用卡，但是每张信用卡总是绑定着一个银行客户，所以信用卡这个类就需要用 unowned 无主引用。 无主引用以及隐市解析可选属性 还有一种情况，两个属性都必须有值，并且初始化完成之后永远不会为 nil。在这种情况下，需要一个类使用 unowned 无主引用，另一个类使用隐式解析可选属性。闭包引起的循环强引用 在 Swift 中，闭包和函数都属于引用类型。并且闭包还有一个特性：可以在其定义的上下文中捕获常量或者变量。所以，在一个类中，闭包被赋值给了一个属性，而这个闭包又使用了这个类的实例的时候，就会引起循环强引用。 Swift 提供了一种方法来解决这个问题：闭包捕获列表（closure capture list）。在定义闭包的同时定义捕获列表作为闭包的一部分，捕获列表定义了闭包体内捕获一个或者多个引用类型的规则。跟解决两个类实例之间的循环强引用一样，声明每个捕获的引用为弱引用或者无主引用。 捕获列表中的每一项都由一对元素组成，一个元素是 weak 或者 unowned 关键字，另一个元素是类实例的引用（例如最常见得是 self），这些在方括号内用逗号隔开。 何时使用 weak，何时使用 unowned在闭包和捕获的实例总是相互引用并且总是同时销毁的时候，将闭包内的捕获定义为 unowned 无主引用。 在被捕获的实例可能变成 nil 的情况下，使用 weak 弱引用。如果被捕获的引用绝对不会变成 nil，应该使用 unowned 无主引用，而不是 weak 弱引用。Garbage Collection（GC，垃圾回收） 其实 ARC 应该也算 GC 的一种，不过我们一谈到 GC，大多都会想到 Java 中的垃圾回收机制，相比较 GC，ARC 简单得许多。以后有机会可以讨论一下 Java 中的内存管理。 另外，需要注意的一点是，这里所讲的都是针对于引用类型，结构体和枚举在 Swift 中属于值类型，不在 ARC 的考虑范围之内。 Swift内存管理机制总结swift同样使用自动计数（ARC）会制动释放内存。swift有3种引用方式： 在实例的生命周期中，如果某些时候引用没有值，那么弱引用可以阻止强引用环。如果整个生命周期内引用都有值，那么相应的用无主引用， 强引用 会增加实例的引用计数。 弱引用 弱引用不会增加实例的引用计数，因此不会阻止ARC销毁被引用的实例。这种特性使得引用不会变成强引用环。声明属性或者变量的时候，关键字weak表明引用为弱引用 无主引用 和弱引用相似，无主引用也不强持有实例。但是和弱引用不同的是，无主引用默认始终有值。 最后贴上一段使用的demo import UIKit class Person: NSObject { var name: String? var age: Int? // block 可能的循环引用 var block: ((Void)-&gt;Void)? = nil override init() { super.init() // weak 只能修改变量 ，其值在运行期间会被修改 // 闭包造成的循环引用([unowned self, weak delegate = self.delegate] 无主引用解决这个问题) // 遇见代理的时候我们还需要weak来修饰。注意内存泄漏 weak var weakself = self; self.block = { [unowned self] in weakself?.name = &quot;修改&quot;; } self.block!() } deinit { // 动态绑定， 因为第51行(p3)创建出来的对象没有name, self.name强制拆包会崩溃 if let name = self.name { print(name + &quot;被解放了&quot;); } } } class ViewController: UIViewController { var name: String? override func viewDidLoad() { super.viewDidLoad() // 引用计数 var p = Person() // 0 －&gt; 1 p.name = &quot;小王&quot; var p1 = p // 1 -&gt; 2 var p2 = p // 2 -&gt; 3 // 因为类型不匹配，无法赋值nil. 只能修改指针的指向让p释放 let p3 = Person() p1 = p3 // 3 -&gt; 2 p2 = p3 // 2 -&gt; 1 p = p3 } // 两个类相互引用 // var stu = student() // var tea = teachet() // tea.student = stu // student.tea = tea override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. } /* 对于闭包内的引用，何时使用弱引用，何时使用无主引用呢？ 如果在一个值的生命周期中可能没有值，我们就使用weak，weak可选 ,weak必须被申明为变量，在运行时可能被修改 如果一只值在生命周期一只有值，我们使用无主引用 , 无主是非可选类型 ，非可选类型不能赋值为nil */ }]]></content>
      <categories>
        <category>Swift3</category>
      </categories>
      <tags>
        <tag>Swift3</tag>
        <tag>Swift3——Swift内存管理</tag>
        <tag>Swift内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift3——Swift从入门到入门]]></title>
    <url>%2F2017%2F05%2F20%2FSwift3%E2%80%94%E2%80%94Swift%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[自从14年Swift出来之后，苹果就一直保持对它的快速更新与迭代，也正是因为这样，导致我们几乎是每年学习一门语言，从1.0到2.0，再从2.0到3.0…… 至于Swift1，Swift2的东西，这里就说这没撒说的了，有很多即使还是一样的知识点，但是用到3里面还是不是你当初所了解的哪有，所以…… 之前 Apple 在 WWDC 上已将 Swift 3 整合进了 Xcode 8 beta 中，而本月苹果发布了 Swift 3 的正式版。这也是自 2015 年底Apple开源Swift之后，首个发布的主要版本（Swift 3.0），该版本实现了 Swift 演变过程中所讨论并通过的90多个提议。这里我对 Swift 3 的新特性、新变化进行一个总结。 原文:Swift - Swift 3 新特性汇总（不同于以往版本的新变化） 语法列表： 学习笔记： 由于Swift是开源的，所以关于这门语言所有的更新内容可以从GitHub上找到详细的解释。 Swift 3改变可以分为四个大的部分1. 移除在Swift 2.2中弃用的方法 2. Swift 3 的新特性 3. 一些语法的修改 4. 语言更加安全，优雅（正确的废话） 特性http://www.jianshu.com/p/ca8e05150068http://www.tuicool.com/articles/NVJryi6 一、彻底移除在 Swift 2.2 就已经弃用的特性这些特性在我们使用 Xcode 7.3 的时候就已经有告警提示，在 Swift 3 中已将其彻底移出。 1，弃用 ++ 与 – 操作符过去我们可以使用 ++ 与 – 操作符来实现自增自减，现已废弃。 var i = 0 i++ ++i i-- --i 可以使用复合加法运算（+=）与减法运算（-=），或者使用普通的加法运算（+）与减法运算（-）实现同样的功能。 //使用复合加法运算（+=）与减法运算（-=） var i = 0 i += 1 i -= 1 //使用普通的加法运算（+）与减法运算（-） i = i + 1 i = i - 1 2，废除C语言风格的for循环我们过去可能习惯下面风格的 for 循环，现在也已废弃。 for var i=1; i&lt;100; i++ { print(&quot;\(i)&quot;) } 现在可以使用 for-in 循环，或者使用 for-each 加闭包的写法实现同样的功能。 //for-in循环 for i in 1...10 { print(i) } //for-each循环 (1...10).forEach { print($0) } 3，移除函数参数的 var 标记在 Swift 函数中，参数默认是常量。过去可以在参数前加关键字 var 将其定义为变量，这样函数内部就可以对该参数进行修改（外部的参数任然不会被修改）。 var age = 22 add(age) func add(var age:Int) { age += 1 } 现在这种做法已经被废弃，Swift 3 不再允许开发者这样来将参数标记为变量了。 4，所有函数参数都必须带上标签过去如果一个函数有多个参数，调用的时候第一个参数无需带标签，而从第二个参数开始，必须要带标签。 let number = additive(8, b: 12) func additive(a:Int, b:Int) -&gt; Int{ return a + b } 现在为了确保函数参数标签的一致性，所有参数都必须带上标签。 let number = additive(a: 8, b: 12) func additive(a:Int, b:Int) -&gt; Int{ return a + b } 这个变化可能会造成我们的项目代码要进行较大的改动，毕竟涉及的地方很多。所以苹果又给出了一种不用给第一个参数带标签的解决方案。即在第一个参数前面加上一个下划线。（不过这个只是方便我们代码从 Swift2 迁移到 Swift3 的一个折中方案，可以的话还是建议将所有的参数都带上标签。） let number = additive(8, b: 12) func additive(_ a:Int, b:Int) -&gt; Int{ return a + b } 5，函数声明和函数调用都需要括号来包括参数我们可以使用函数类型作为参数 ，对于一个参数是函数、返回值也是函数的函数。原来我们可能会这么写： func g(a: Int -&gt; Int) -&gt; Int-&gt;Int { ... } 当这样非常难以阅读，很难看出参数在哪里结束，返回值又从哪里开始。在 Swift 3 中变成这么定义这个函数： func g(a:(Int) -&gt; Int) -&gt; (Int) -&gt; Int { ... } 6，Selector 不再允许使用 String假设我们给按钮添加一个点击事件响应，点击后执行 tapped 函数。以前可以这么写： button.addTarget(responder, action: &quot;tapped&quot;, forControlEvents: .TouchUpInside) 但由于按钮的 selector 写的是字符串。如果字符串拼写错了，那程序会在运行时因找不到相关方法而崩溃。所以 Swift 3 将这种写法废除，改成 #selecor()。这样就将允许编译器提前检查方法名的拼写问题，而不用再等到运行时才发现问题。 button.addTarget(self, action:#selector(tapped), for:.touchUpInside) 二、Swift 3 的新特性1，内联序列函数sequenceSwift 3 新增了两个全局函数：sequence(first: next:) 和 sequence(state: next:)。使用它们可以返回一个无限序列。下面是一个简单的使用样例，更详细的介绍可以关注我后续的文章。 // 从某一个树节点一直向上遍历到根节点 for node in sequence(first: leaf, next: { $0.parent }) { // node is leaf, then leaf.parent, then leaf.parent.parent, etc. } // 遍历出所有的2的n次方数（不考虑溢出） for value in sequence(first: 1, next: { $0 * 2 }) { // value is 1, then 2, then 4, then 8, etc. } 2， key-path不再只能使用String这个是用在键值编码（KVC）与键值观察（KVO）上的，具体 KVC、KVO 相关内容可以参考我原来写的这篇文章：Swift - 反射（Reflection）的介绍与使用样例（附KVC介绍）我们还是可以继续使用 String 类型的 key-Path： //用户类 class User: NSObject{ var name:String = &quot;&quot; //姓名 var age:Int = 0 //年龄 } //创建一个User实例对象 let user1 = User() user1.name = &quot;hangge&quot; user1.age = 100 //使用KVC取值 let name = user1.value(forKey: &quot;name&quot;) print(name) //使用KVC赋值 user1.setValue(&quot;hangge.com&quot;, forKey: &quot;name&quot;) 但建议使用新增的 #keyPath() 写法，这样可以避免我们因为拼写错误而引发问题。 //使用KVC取值 let name = user1.value(forKeyPath: #keyPath(User.name)) print(name) //使用KVC赋值 user1.setValue(&quot;hangge.com&quot;, forKeyPath: #keyPath(User.name)) 3，Foundation 去掉 NS 前缀比如过去我们使用 Foundation 相关类来对文件中的 JSON 数据进行解析，这么写： let file = NSBundle.mainBundle().pathForResource(&quot;tutorials&quot;, ofType: &quot;json&quot;) let url = NSURL(fileURLWithPath: file!) let data = NSData(contentsOfURL: url) let json = try! NSJSONSerialization.JSONObjectWithData(data!, options: []) print(json) 在 Swift 3 中，将移除 NS 前缀，就变成了： let file = Bundle.main.path(forResource: &quot;tutorials&quot;, ofType: &quot;json&quot;) let url = URL(fileURLWithPath: file!) let data = try! Data(contentsOf: url) let json = try! JSONSerialization.jsonObject(with: data) print(json) 4，除了M_PI 还有 .pi在过去，我们使用 M_PI 常量来表示 π。所以根据半径求周长代码如下： let r = 3.0 let circumference = 2 * M_PI * r 在 Swift 3 中，π 提供了 Float，Double 与 CGFloat 三种形式（Float.pi、Double.pi、CGFloat.pi），所以求周长还可以这么写： let r = 3.0 let circumference = 2 * Double.pi * r //我们还可以将前缀省略，让其通过类型自动推断 let r = 3.0 let circumference = 2 * .pi * r 5，简化GCD的写法关于 GCD，我原来写过一篇相关文章：Swift - 多线程实现方式（3） - Grand Central Dispatch（GCD）过去写法采用 C 语言的风格，初学者可能会不大适应。比如创建一个简单的异步线程： let queue = dispatch_queue_create(&quot;Swift 2.2&quot;, nil) dispatch_async(queue) { print(&quot;Swift 2.2 queue&quot;) } Swift 3 取消了这种冗余的写法，而采用了更为面向对象的方式： let queue = DispatchQueue(label: &quot;Swift 3&quot;) queue.async { print(&quot;Swift 3 queue&quot;) } 6，Core Graphics的写法也更加面向对象化Core Graphics 是一个相当强大的绘图框架，但是和 GCD 一样，它原来的 API 也是 C 语言风格的。比如我们要创建一个 view，其内部背景使用 Core Graphics 进行绘制（红色边框，蓝色背景）。过去我们这么写： class View: UIView { override func drawRect(rect: CGRect) { let context = UIGraphicsGetCurrentContext() let blue = UIColor.blueColor().CGColor CGContextSetFillColorWithColor(context, blue) let red = UIColor.redColor().CGColor CGContextSetStrokeColorWithColor(context, red) CGContextSetLineWidth(context, 10) CGContextAddRect(context, frame) CGContextDrawPath(context, .FillStroke) } } let frame = CGRect(x: 0, y: 0, width: 100, height: 50) let aView = View(frame: frame) 在 Swift 3 中改进了写法，只要对当前画布上下文解包，之后的所有绘制操作就都基于解包对象。 class View: UIView { override func draw(_ rect: CGRect) { guard let context = UIGraphicsGetCurrentContext() else { return } let blue = UIColor.blue.cgColor context.setFillColor(blue) let red = UIColor.red.cgColor context.setStrokeColor(red) context.setLineWidth(10) context.addRect(frame) context.drawPath(using: .fillStroke) } } let frame = CGRect(x: 0, y: 0, width: 100, height: 50) let aView = View(frame: frame) 7，新增的访问控制关键字：fileprivate、open在 Swift 3 中在原有的 3 个访问控制关键字 private、public、internal 外。又添加了2个新关键字 fileprivate、open。它们可以看成是对原来 private 和 public 的进一步细分。具体使用方法和介绍可以关注我的后续文章。 三、一些语法的修改:Swift 3 的新特性1，数组排序：sort()与sorted()过去数组排序的两个方法：sortInPlace() 和 sort()，现在分别改名成 sort() 和 sorted()sort() 是直接对目标数组进行排序。sorted() 是返回一个排序后的数组，原数组不变。 var array1 = [1, 5, 3, 2, 4] array1.sort() print(array1) //[1, 2, 3, 4, 5] var array2 = [1, 5, 3, 2, 4] let sortedArray = array2.sorted() print(array2) //[1, 5, 3, 2, 4] print(sortedArray) //[1, 2, 3, 4, 5] 2，reversed()与enumerated()过去 reverse() 方法实现数组反转，enumerate() 方法实现遍历。现这两个方法都加上 ed 后缀（reversed、enumerated） for i in (1...10).reversed() { print(i) } let array = [1, 5, 3, 2, 4] for (index, value) in array.enumerated() { print(&quot;\(index + 1) \(value)&quot;) } 3，CGRect、CGPoint、CGSize过去的 CGRectMake、CGPointMake、CGSizeMake 已废弃。现改用 CGRect、CGPoint、CGSize 代替。 //Swift 2 let frame = CGRectMake(0, 0, 20, 20) let point = CGPointMake(0, 0) let size = CGSizeMake(20, 20) //Swift 3 let frame = CGRect(x: 0, y: 0, width: 20, height: 20) let point = CGPoint(x: 0, y: 0) let size = CGSize(width: 20, height: 20) 4，移除了API中多余的单词XCPlaygroundPage.currentPage 改为 PlaygroundPage.current button.setTitle(forState) 改为 button.setTitle(for) button.addTarget(action, forControlEvents) 改为 button.addTarget(action, for) arr.minElement() 改为 arr.min() arr.maxElement() 改为 arr.max() attributedString.appendAttributedString(anotherString) 改为 attributedString.append(anotherString) names.insert(&quot;Jane&quot;, atIndex: 0) 改为 names.insert(&quot;Jane&quot;, at: 0) NSBundle.mainBundle() 改为 Bundle.main UIDevice.currentDevice() 改为 UIDevice.current NSData(contentsOfURL) 改为 Data(contentsOf) NSJSONSerialization.JSONObjectWithData() 改为 JSONSerialization.jsonObject(with) UIColor.blueColor() 改为 UIColor.blue 5，枚举成员变成小写字母开头Swift 3 将枚举成员当做属性来看，所以现在使用小写字母开头而不是以前的大写字母。 .system //过去是：.System .touchUpInside //过去是：.TouchUpInside .fillStroke //过去是：.FillStroke .cgColor //过去是：.CGColor 6，@discardableResult在 Swift 3 中，如果一个方法有返回值。而调用的时候没有接收该方法的返回值，Xcode 会报出警告，告诉你这可能会存在潜在问题。 原文:Swift - Swift 3 新特性汇总（不同于以往版本的新变化） 除了可以通过接收返回值消除警告。还可以通过给方法声明 @discardableResult 来达到消除目的。 import UIKit class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() printMessage(message: &quot;Hello Swift 3!&quot;) } @discardableResult func printMessage(message: String) -&gt; String { let outputMessage = &quot;Output : \(message)&quot; return outputMessage } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } } 迁移的坑 官方资料]]></content>
      <categories>
        <category>Swift3</category>
      </categories>
      <tags>
        <tag>Swift3——Swift从入门到入门</tag>
        <tag>Swift3</tag>
        <tag>Swift从入门到入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin——和Swift像得一塌糊涂]]></title>
    <url>%2F2017%2F05%2F18%2Fkotlin%E2%80%94%E2%80%94%E5%92%8CSwift%E5%83%8F%E5%BE%97%E4%B8%80%E5%A1%8C%E7%B3%8A%E6%B6%82%2F</url>
    <content type="text"><![CDATA[今天大概看了一下网上关于Google I/O的详细内容，当然主要还是关于kotlin，随便找打之前的的小demo，突然又想到上周深圳的Swift大会，顿时感觉以后Swift和kotlin与占有很大一部分市场，就寻找了一份关于kotlin和Swift代码的异同之处，也好方便kotlin和Swift程序员区分与学习….. | | | 下面是一些关于Swift和Kotlin语法和细节上的区别，出自网络！ Hello WorldSwiftprint(&quot;Hello, world!&quot;) kotlinprintln(&quot;Hello, world!&quot;) Variables And ConstantsSwiftvar myVariable = 42 myVariable = 50 let myConstant = 42 kotlinvar myVariable = 42 myVariable = 50 val myConstant = 42 Explicit TypesSwiftlet explicitDouble: Double = 70 kotlinval explicitDouble: Double = 70.0 Type CoercionSwiftlet label = &quot;The width is &quot; let width = 94 let widthLabel = label + String(width) kotlinval label = &quot;The width is &quot; val width = 94 val widthLabel = label + width String InterpolationSwiftlet apples = 3 let oranges = 5 let fruitSummary = &quot;I have \(apples + oranges) &quot; + &quot;pieces of fruit.&quot; kotlinval apples = 3 val oranges = 5 val fruitSummary = &quot;I have ${apples + oranges} &quot; + &quot;pieces of fruit.&quot; Range OperatorSwiftlet names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;] let count = names.count for i in 0..&lt;count { print(&quot;Person \(i + 1) is called \(names[i])&quot;) } // Person 1 is called Anna // Person 2 is called Alex // Person 3 is called Brian // Person 4 is called Jack kotlinval names = arrayOf(&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;) val count = names.count() for (i in 0..count - 1) { println(&quot;Person ${i + 1} is called ${names[i]}&quot;) } // Person 1 is called Anna // Person 2 is called Alex // Person 3 is called Brian // Person 4 is called Jack Inclusive Range OperatorSwiftfor index in 1...5 { print(&quot;\(index) times 5 is \(index * 5)&quot;) } // 1 times 5 is 5 // 2 times 5 is 10 // 3 times 5 is 15 // 4 times 5 is 20 // 5 times 5 is 25 kotlinfor (index in 1..5) { println(&quot;$index times 5 is ${index * 5}&quot;) } // 1 times 5 is 5 // 2 times 5 is 10 // 3 times 5 is 15 // 4 times 5 is 20 // 5 times 5 is 25 ArraysSwiftvar shoppingList = [&quot;catfish&quot;, &quot;water&quot;, &quot;tulips&quot;, &quot;blue paint&quot;] shoppingList[1] = &quot;bottle of water&quot; ### kotlin val shoppingList = arrayOf(&quot;catfish&quot;, &quot;water&quot;, &quot;tulips&quot;, &quot;blue paint&quot;) shoppingList[1] = &quot;bottle of water&quot; MapsSwiftvar occupations = [ &quot;Malcolm&quot;: &quot;Captain&quot;, &quot;Kaylee&quot;: &quot;Mechanic&quot;, ] occupations[&quot;Jayne&quot;] = &quot;Public Relations&quot; kotlinval occupations = mutableMapOf( &quot;Malcolm&quot; to &quot;Captain&quot;, &quot;Kaylee&quot; to &quot;Mechanic&quot; ) occupations[&quot;Jayne&quot;] = &quot;Public Relations&quot; Empty CollectionsSwiftlet emptyArray = [String]() let emptyDictionary = [String: Float]() kotlinval emptyArray = arrayOf&lt;String&gt;() val emptyMap = mapOf&lt;String, Float&gt;() FunctionsSwiftfunc greet(_ name: String,_ day: String) -&gt; String { return &quot;Hello \(name), today is \(day).&quot; } greet(&quot;Bob&quot;, &quot;Tuesday&quot;) kotlinfun greet(name: String, day: String): String { return &quot;Hello $name, today is $day.&quot; } greet(&quot;Bob&quot;, &quot;Tuesday&quot;) Tuple ReturnSwiftfunc getGasPrices() -&gt; (Double, Double, Double) { return (3.59, 3.69, 3.79) } kotlindata class GasPrices(val a: Double, val b: Double, val c: Double) fun getGasPrices() = GasPrices(3.59, 3.69, 3.79) Variable Number Of ArgumentsSwiftfunc sumOf(_ numbers: Int...) -&gt; Int { var sum = 0 for number in numbers { sum += number } return sum } sumOf(42, 597, 12) kotlinfun sumOf(vararg numbers: Int): Int { var sum = 0 for (number in numbers) { sum += number } return sum } sumOf(42, 597, 12) // sumOf() can also be written in a shorter way: fun sumOf(vararg numbers: Int) = numbers.sum() Function TypeSwiftfunc makeIncrementer() -&gt; (Int -&gt; Int) { func addOne(number: Int) -&gt; Int { return 1 + number } return addOne } let increment = makeIncrementer() increment(7) kotlinfun makeIncrementer(): (Int) -&gt; Int { val addOne = fun(number: Int): Int { return 1 + number } return addOne } val increment = makeIncrementer() increment(7) // makeIncrementer can also be written in a shorter way: fun makeIncrementer() = fun(number: Int) = 1 + number MapSwiftlet numbers = [20, 19, 7, 12] numbers.map { 3 * $0 } kotlinval numbers = listOf(20, 19, 7, 12) numbers.map { 3 * it } Sort Swiftvar mutableArray = [1, 5, 3, 12, 2] mutableArray.sort() kotlinlistOf(1, 5, 3, 12, 2).sorted() Named ArgumentsSwiftfunc area(width: Int, height: Int) -&gt; Int { return width * height } area(width: 2, height: 3) kotlinfun area(width: Int, height: Int) = width * height area(width = 2, height = 3) // This is also possible with named arguments area(2, height = 2) area(height = 3, width = 2) DeclarationSwiftclass Shape { var numberOfSides = 0 func simpleDescription() -&gt; String { return &quot;A shape with \(numberOfSides) sides.&quot; } } kotlinclass Shape { var numberOfSides = 0 fun simpleDescription() = &quot;A shape with $numberOfSides sides.&quot; } UsageSwiftvar shape = Shape() shape.numberOfSides = 7 var shapeDescription = shape.simpleDescription() kotlinvar shape = Shape() shape.numberOfSides = 7 var shapeDescription = shape.simpleDescription() SubclassSwiftclass NamedShape { var numberOfSides: Int = 0 let name: String init(name: String) { self.name = name } func simpleDescription() -&gt; String { return &quot;A shape with \(numberOfSides) sides.&quot; } } class Square: NamedShape { var sideLength: Double init(sideLength: Double, name: String) { self.sideLength = sideLength super.init(name: name) self.numberOfSides = 4 } func area() -&gt; Double { return sideLength * sideLength } override func simpleDescription() -&gt; String { return &quot;A square with sides of length &quot; + sideLength + &quot;.&quot; } } let test = Square(sideLength: 5.2, name: &quot;square&quot;) test.area() test.simpleDescription() kotlinopen class NamedShape(val name: String) { var numberOfSides = 0 open fun simpleDescription() = &quot;A shape with $numberOfSides sides.&quot; } class Square(var sideLength: BigDecimal, name: String) : NamedShape(name) { init { numberOfSides = 4 } fun area() = sideLength.pow(2) override fun simpleDescription() = &quot;A square with sides of length $sideLength.&quot; } val test = Square(BigDecimal(&quot;5.2&quot;), &quot;square&quot;) test.area() test.simpleDescription() Checking TypeSwiftvar movieCount = 0 var songCount = 0 for item in library { if item is Movie { movieCount += 1 } else if item is Song { songCount += 1 } } kotlinvar movieCount = 0 var songCount = 0 for (item in library) { if (item is Movie) { ++movieCount } else if (item is Song) { ++songCount } } Pattern MatchingSwiftlet nb = 42 switch nb { case 0...7, 8, 9: print(&quot;single digit&quot;) case 10: print(&quot;double digits&quot;) case 11...99: print(&quot;double digits&quot;) case 100...999: print(&quot;triple digits&quot;) default: print(&quot;four or more digits&quot;) } kotlinval nb = 42 when (nb) { in 0..7, 8, 9 -&gt; println(&quot;single digit&quot;) 10 -&gt; println(&quot;double digits&quot;) in 11..99 -&gt; println(&quot;double digits&quot;) in 100..999 -&gt; println(&quot;triple digits&quot;) else -&gt; println(&quot;four or more digits&quot;) } DowncastingSwiftfor current in someObjects { if let movie = current as? Movie { print(&quot;Movie: &apos;\(movie.name)&apos;, &quot; + &quot;dir. \(movie.director)&quot;) } } kotlinfor (current in someObjects) { if (current is Movie) { println(&quot;Movie: &apos;${current.name}&apos;, &quot; + &quot;dir. ${current.director}&quot;) } } ProtocolSwiftprotocol Nameable { func name() -&gt; String } func f&lt;T: Nameable&gt;(x: T) { print(&quot;Name is &quot; + x.name()) } kotlininterface Nameable { fun name(): String } fun f&lt;T: Nameable&gt;(x: T) { println(&quot;Name is &quot; + x.name()) } Extensions### Swiftextension Double { var km: Double { return self * 1_000.0 } var m: Double { return self } var cm: Double { return self / 100.0 } var mm: Double { return self / 1_000.0 } var ft: Double { return self / 3.28084 } } let oneInch = 25.4.mm print(&quot;One inch is \(oneInch) meters&quot;) // prints &quot;One inch is 0.0254 meters&quot; let threeFeet = 3.ft print(&quot;Three feet is \(threeFeet) meters&quot;) // prints &quot;Three feet is 0.914399970739201 meters&quot; kotlinval Double.km: Double get() = this * 1000 val Double.m: Double get() = this val Double.cm: Double get() = this / 100 val Double.mm: Double get() = this / 1000 val Double.ft: Double get() = this / 3.28084 val oneInch = 25.4.mm println(&quot;One inch is $oneInch meters&quot;) // prints &quot;One inch is 0.0254 meters&quot; val threeFeet = 3.0.ft println(&quot;Three feet is $threeFeet meters&quot;) // prints &quot;Three feet is 0.914399970739201 meters&quot;]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>kotlin</tag>
        <tag>kotlin——和Swift像得一塌糊涂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin——要火了❤️，你还在等什么？]]></title>
    <url>%2F2017%2F05%2F18%2Fkotlin%E2%80%94%E2%80%94%E8%A6%81%E7%81%AB%E4%BA%86%E2%9D%A4%EF%B8%8F%EF%BC%8C%E4%BD%A0%E8%BF%98%E5%9C%A8%E7%AD%89%E4%BB%80%E4%B9%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[其实在去年我就开发在了解Kotlin，只是由于项目的原因，还有一些人根本不知道他的存在，然后推荐给了不少人，都被否决了！ 百度发音：kotlin——科特林 前言： 今早睡一醒来打开手机一看，发现朋友圈被刷屏了！ 其实在去年我就开发在了解Kotlin，只是由于项目的原因，还有一些人根本不知道他的存在，然后推荐给了不少人，都被否决了！ kotlin要火了，昨晚的Google I/O大会，Google宣布正式其实kotlin。 这个小时对几乎所有Android的猿类来说，应该是最震惊的，为什么呢？ 因为你又有一门新的语言可以学习了，就像Swift对iOS程序员的意义意义！ 当然这个消息不仅对Android程序员比较震惊，对几乎所有做iOS开发的程序也是一个值得关注的消息？为什么呢？ 那你的问问Swift为什么和他长得这么像！ 先来看看昨晚Google I/O 2017有哪些亮点？TPU（用于深度学习的处理器） Google Lens （新API，摄像头直接支持图像识别） Google Assistan新功能 Google Home新功能 Google Photos新功能 Android支持分屏 Android支持Kotlin开发 Tango（AR）进展 Daydream（VR）进展 Google工作搜索 想了解更多请看官方发布视频与相关总结！ 有人用一句话总结AI已经无处不在了 这里是主要阐述kotlin的，上面两点中“Android支持Kotlin开发”也是我非常关注和值得开心的一件！ 所以，Let`s Go首先有任何想了解kotlin的，建议最好先看官方教程：http://kotlinlang.org/ Kotlin是什么Kotlin 是一个基于 JVM 的新的编程语言，由 JetBrains 开发。 Kotlin可以编译成Java字节码，也可以编译成JavaScript，方便在没有JVM的设备上运行。 JetBrains，作为目前广受欢迎的Java IDE IntelliJ 的提供商，在 Apache 许可下已经开源其Kotlin 编程语言。 众所周知Android程序是运行在Java虚拟机之上的，因此从技术上来说，可以运行在JVM之上的一切都可用于开发Android应用。现在已经有很多可以生成JVM能够执行的字节码的语言，其中一些语言开始崭露头角并逐步流行起来。现存的计算机编程语言有好几千种，JVM上的语言也有十几种(比如NBJL/Clojure/Groovy/Scala/Fantom)，所以大可不必为没听说过的编程语言感到惊奇,我也就听过Groovy/Scala/Kotlin，scala比较和C语言接近，而Groovy和java很相似你肯定对gradle不陌生吧，但是Kotlin就是其中的佼佼者。 近日召开的 Google IO 2017 ， Google 将 Kotlin 列为 Android 官方开发语言了，Android Studio 3.0 也默认集成了 Kotlin plugin kotlin的历史历史2011 年 7 月，JetBrains 推出 Kotlin 项目，这是一个面向 JVM 的新语言，它已被开发一年之久。JetBrains 负责人Dmitry Jemerov 说，大多数语言没有他们正在寻找的特性，Scala 除外，他指出了 Scala 的编译时间慢这一明显缺陷。Kotlin 的既定目标之一是像 Java 一样快速编译。 2012 年 2 月，JetBrains 以 Apache 2 许可证开源此项目，Jetbrains 希望这个新语言能够推动 IntelliJ IDEA 的销售。 Kotlin v1.0 于 2016 年 2 月 15 日发布。这被认为是第一个官方稳定版本，并且 JetBrains 已准备从该版本开始的长期向后兼容性。 在 Google I/O 2017 中，Google 宣布在 Android 上为 Kotlin 提供支持。 Kotlin设计的目的创建一种兼容Java的语言 让它比Java更安全，能够静态检测常见的陷阱。如：引用空指针 让它比Java更简洁，通过支持variable type inference，higher-order functions (closures)，extension functions，mixins and first-class delegation等实现。 让它比最成熟的竞争对手Scala语言更加简单 java的缺陷：对象可以赋值null造成NPE 受检异常(checked exception) 属性getter，setter太烦 接口不能有实现（java8 fixed） 缺乏Lambda(java8 fixed) 方法Overloading对可读性和动态调用造成伤害。 语言层缺乏模块化支持 并发支持很糟糕 原始类型不是对象&gt; Kotlin优势：创建一种兼容Java的语言 让它比Java更安全，能够静态检测常见的陷阱。如：引用空指针 让 它比Java更简洁，通过支持variable type inference，higher-order functions (closures)，extension functions，mixins and first-class delegation等实现。 语言特性轻量级： 这一点对于Android来说非常重要。项目所需要的库应该尽可能的小。Android对于方法数量有严格的限制，Kotlin只额外增加了大约6000个方法。 互操作： Kotlin可与Java语言无缝通信。这意味着我们可以在Kotlin代码中使用任何已有的Java库；因此，即便这门语言还很年轻，但却已经可以使用成百上千的库了。除此之外，Kotlin代码还可以为Java代码所用，这意味着我们可以使用这两种语言来构建软件。你可以使用Kotlin开发新特性，同时使用Java实现代码基的其他部分。 强类型： 我们很少需要在代码中指定类型，因为编译器可以在绝大多数情况下推断出变量或是函数返回值的类型。这样就能获得两个好处：简洁与安全。 Null安全： Java最大的一个问题就是null。如果没有对变量或是参数进行null判断，那么程序当中就有可能抛出大量的NullPointerException，然而在编码时这些又是难以检测到的。Kotlin使用了显式的null，这会强制我们在必要时进行null检查。 适用平台只要能用Java的地方就能用Kotlin， Kotlin支持所有主要的开发工具以及服务，比如： * IntelliJ IDEA、Android Studio和Eclipse； * Maven、Gradle和Ant； * spring Boot（Kotlin 支持今天正式发布！）； * GitHub，Slack，甚至Minecraft。 分类整理一下 Kotlin VS Java语法简单不啰嗦Kotlin的一个主要优点是它的简洁。 你用更少的代码获得更多的功能。 ① Kotlin 支持类型推断，没有 Java 那样的啰嗦。 ② 用 var 表示变量，val 表示常量更加的简洁 ③ 方法也很简单，连 function 都缩写成了 fun ④ 类的继承和实现很简单，使用:即可 ⑤ Kotlin 每个句子都不需要加分号 (;) 避免空指针异常在许多编程语言中最大的痛苦 - 空指针异常。 但是使用Kotlin，这个问题得到了很好的解决 ① 在类型上的处理，即在类型后面加上?，即表示这个变量或参数以及返回值可以为 null，否则不允许为变量参数赋值为 null 或者返回 null ② 对于一个可能是 null 的变量或者参数，在调用对象方法或者属性之前，需要加上?，否则编译无法通过。 支持方法拓展Kotlin有一个聪明的解决方案 - 扩展功能 ，帮助你摆脱所有的util类一劳永逸。扩展函数几乎是一个通常的Kotlin函数。 但是当你声明它，你需要指定的实例将具有扩展功能的类。 注意：Kotlin 的方法扩展并不是真正修改了对应的类文件，而是在编译器和 IDE 方面做得处理。使我们看起来像是扩展了方法。 高阶函数， 函数式编程支持所谓的高阶函数就是：可以接受函数作为参数，也可以返回函数作为结果。 Kotlin 支持了 Streams API 和方法引用，这样函数式编程更加方便。比如下面的代码就是我们结合 Jsoup，来抓取某个 proxy 网站的数据，代码更加简单，实现起来也快速。 关于性能Kotlin 的执行效率和 Java 代码的执行效率理论上一致的。有时候 Kotlin 可能会显得高一些。比如 Kotlin 提供了方法的 inline 设置，可以设置某些高频方法进行 inline 操作，减少了运行时的进栈出栈和保存状态的开销。 与Java互操作Kotlin 在设计时就考虑了 Java 互操作性。可以从 Kotlin 中自然地调用现存的 Java 代码，并且在 Java 代码中也可以 很顺利地调用 Kotlin 代码。 总结Kotlin的特性有很多，总的来说， Kotlin这门语言简化了Java , 完全是从一个是实用派的角度，而不是学院派的角度。 相比于JRuby , Jython这些一移植到JVM上的语言， Kotlin 和Java 和互操作感觉更加自然。 每个语言的流行都需要一个引爆点，就像Ruby on Rails 引爆了Ruby 一样， Android 也许就是之前不那么流行的Kotlin的引爆点。 这里有一篇不错的入门实战教程，非常简单：http://www.jianshu.com/p/cf1f96c56150 Kotlin这里就不说了，太乏味了，最后一句话总结一下kotlin Android届的Swift（请深刻理解其中的含义） 各位Android的同仁们，是时候了，不管是为了喜好还是为了以后的规划，你都应该停下手上的活，抽出一切空余时间进攻kotlin，相信我，不学你会后悔的，哈哈！当然有机会我也会去了解，接触一些kotlin开发的知识，哪怕我不会转到哪上面去，这就是我们所谓的广度优先！ 如果想简单入门kotlin语法和一些特点可以看这里：http://www.jianshu.com/p/1ea733ea197d 学习资源： 1.kotlin官方中文翻译文档网址 2.Kotlin官网 3.kotlin中文官网 4.kotlin的gitbook网址 在线学习 Kotlin官方文档]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
        <tag>kotlin——要火了❤️，你还在等什么？</tag>
        <tag>Google I/O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017@Swift——后感]]></title>
    <url>%2F2017%2F05%2F15%2F2017-Swift%E2%80%94%E2%80%94%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[2017@Swift——中国开发者大会（第二站） 会议时间：2017年5月13日-5月14日， 地址：深圳凯宾斯基酒店， 人数：400人 嘉宾：18人，其中8位国外，8位国内。 第一天所有外国嘉宾的演讲时间，第二天是国内大牛的演讲时间！ 记得第一站是去年在北京举行，当时项目太赶，就没有去，今年有幸能参加此次大会，并且收获真心不少。因此这里稍微整理了一下这两天最大的感触，和所学到的东西！ 当然关于技术的分享，后期会有专门的文章与结合简单的实战整理一并分享出来，敬请期待……. 更多信息请点2017@Swift——中国开发者大会,同时后面也会抽空整理一下会议中讲到的内容，底层，细节与实现，敬请期待！ 2017@Swift——后感 这种收获真不是一两句话或者一两篇文章就能说清楚的，如果你有事吗疑问或者想了解先关内容也可以直接关注我，联系我！ 第二届 @Swift 中国开发者大会 英语能力 交友 技术 英语为什么这里我把英语能力放在最前面，肯定是有原因的。 1. 开会第一天所有都是老外，所有人都直接用英语讲，几乎听不太懂，所以导致很多东西根本没有听到重点与细节 2. 会后交流，与提问，人家都能听懂，甚至都能提出自己的问题与观点，甚至还能通嘉宾进行更多更加升入的交流与讨论，而我却只能翻译或者发呆 3. 技术的学习，几乎所有的最好，最新的技术资料都是从英文开始的，当你开始看中文翻译资料或者开始研究的时候，人家已经换了一种技术 4. 后期的规划问题，出国旅游，出国发展（有点长远，当然也不是没有可能的），或者有机会接触外国朋友。 总结：针对程序员，哪怕只有一点基础的，技术这种东西都可以慢慢学，或者在实际项目中提高，如果你英文不好很多事情真的很难进行下去，除非你没有什么长远的目标或者没有自己个人的规划。 交友经过这次会议之后，看到了很多牛人，也认识了不少牛人之后才知道自己的渺小，才知道自己原来离期望中太远太远。 1. 最有名的Swift框架RXSwift的作者 2. Google工程师 3. 腾讯，美团，礼物说，阿里等一些非常厉害的架构师，同时也是技术迷 4. 不少技术书籍的作者，其中有一位是我非常喜欢的巧哥@唐巧 5. 不同公司的技术主管，开发人员，初入门的程序员 6. 两天的会议中认识到了不少来自去全国各地参会者，也结下了不少好友！ 总结：永远不要觉得自己多牛逼，当你真的看到牛人之后你就会发现，其实自己真的很low，哪怕你做过再多项目，写过再多代码，不思考，不提升依然是个菜鸟。 技术1. 主题就是Swift：iOS，后台肯定是重心 2. Swift实现AI，智能，机器学习，树莓派的结合，后期的转行。 3. 实现属于自己的东西，小的方向比如小框架，静态或者动态库，大的话其中有人自己写了一个Swift转H5的编译器 4. App性能的提升，多线程，锁，MVVM, 自动化（测试，脚本） 5. 包括开发，集成，测试，发布，维护需要有一套完成的规范与流程。 总之，程序员是一个需要时刻保持学习的职业，不学你就将被淘汰，不管学习技术，管理，社交，英语或者学习别人成功或失败的经验 未来的路还很长，希望一路上的坎坷能让我足够强大。 说说我接下来的规划（我只谈短期1-2年）： 1. 学习英语，不管是自学还是报班这都是现阶段最最最重要的任务,同时也会长期的坚持下去。 2. 着手Swift进行项目实战，对PHP实战后台开发进一步的提升，同时去了解Swift实现后台开发 3. iOS深挖：深入解析Max OS X &amp; iOS操作系统 4. 学习Python，了解机器学习等技术]]></content>
      <categories>
        <category>2017@Swift</category>
      </categories>
      <tags>
        <tag>2017@Swift——后感</tag>
        <tag>Swift</tag>
        <tag>大会后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017@Swift——中国开发者大会（第二天）]]></title>
    <url>%2F2017%2F05%2F15%2F2017-Swift%E2%80%94%E2%80%94%E4%B8%AD%E5%9B%BD%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%A4%A9%EF%BC%89%2F</url>
    <content type="text"><![CDATA[首先介绍一下会议信息 会议时间：2017年5月13日-5月14日， 地址：深圳凯宾斯基酒店， 人数：400人 嘉宾：18人，其中8位国外，8位国内。 第一天所有外国嘉宾的演讲时间，第二天是国内大牛的演讲时间！ 更多信息请点2017@Swift——中国开发者大会,同时后面也会抽空整理一下会议中讲到的内容，底层，细节与实现，敬请期待！ ============================================================================= 唐巧（小猿搜题产品技术负责人）Richards 和 Deltablue 是衡量语言运算速度的两个主流的评测代码。Swift 在这两个评测中，显示出远超 Objective-C 的性能。特别是 Richards 评测，Swift 比 Objective-C 快了 4 倍。那么，为什么 Swift 这么快呢？本次分享，我将从编译器优化，内存分配优化，引用计数优化，方法调用优化，面向协议编程的实现细节等方面来介绍 Swift 在性能上所做的努力。如果可能，我们也会一起看看编译器处理后的源码，加深我们对于这些优化的理解。 小猿搜题产品技术负责人，资深 iOS 开发者，曾开发过网易邮箱、网易微博、有道云笔记、猿题库、小猿搜题。喜欢写作和分享，维护着中国关注者最多的iOS领域的微信公众号「iOS开发by唐巧」，产出了超过 100 篇原创的 iOS 技术文章，出版了一本 iOS 进阶读物《iOS开发进阶》。 Swift 为什么这么快1. 第二天中，唯一一个使用英文演讲的国内大牛，挑战自我。 2. 从不同方便说明为什么swift比OC好：引用数，struct的内存布局，性能优化，编译器、内存、消息转发机制、引用数和protocol。 ============================================================================= 戴铭（滴滴出行技术专家） github.com/ming1016 结合实例介绍如何用 LLVM IR 中间语言和编译前端的语法解析来设计一门简洁易用支持多平台的 DSL 语言，从而提高开发效率。介绍如何使用 Swift 开发一个类似 Clang 并且支持插件的简版编译前端，从而优化代码，提高工程质量。此外还会简单介绍一些有趣的实践。 微博@戴铭。滴滴出行技术专家，技术上主要负责滴滴出行 iOS 相关的开发工作。时常会将对新技术的深入研究和工作的经验总结发在微博上。对 ReactiveCocoa，RxSwift，软件架构，性能优化和算法有着浓厚的兴趣。最近正在研究iOS编译相关底层技术，用来解决工程优化问题，到时会将成果分享出来。 学习 iOS 编译原理能做哪些有意思的事情1. 这哥们可谓是有着一双被编程耽误了的画手，不但主题，技术吸引人，所画出来的作品更是让人回味。 2. 先讲了一个关于flexbox布局的web代码，自己使用swift写了一个解析器。 3. 结合上面的实现个性化的讲解了一下编译器前后端，及编译的整个过程 ============================================================================= 柯灵杰（腾讯公司iOS开发）图片组件可以说是app开发中使用最多的组件之一，它既简单也不简单，如何设计和开发一个具有高扩展性，高性能的图片组件呢？本次分享将会从架构设计到性能优化等多方面，全面解析一个优秀图片组件的设计和开发原理，以及在性能优化和架构设计方面的一些经验和探索。 柯灵杰（lingtonke），腾讯公司 iOS 开发。腾讯学院认证讲师，主要讲授课程《设计模式》。曾参加过 QQ、QZone、微云、企鹅 MV、闪咖等的开发。他主导开发的图片组件，在腾讯内被多个项目使用，获得公司内多项优秀组件奖，目前已着手对业内开源。同时他还是数项技术发明专利的发明人，曾参加过程序员 LiveShow《有码的开发哥无码的直播》。目前是腾讯 QZone 团队 iOS 开发。 打造易扩展的高性能图片组件1. 如何设计高性能易拓展的图片组件，一步一步的优化。 2. 综合分析的不同框架，不同实现方案，不同技术的优缺点。 3. 当时我会中问到是否开源，回答是会，并且预计年底会开源。 ============================================================================= 王文槿（UC资深开发工程师）来自 UC 浏览器的 iPhone 组，参与了 UC 浏览器，UC 头条和夸克浏览器相关产品的开发，工作中主要使用 OC 和 Weex 。不过业余是不折不扣的 Swift 爱好者，自诩 Swift 的函数式编程的布道师。曾经先后通过文章&amp;演讲的形式分享了 Swift 异步串行/并行编程以及函数式的设计模式等话题。 一个轻量级 FRP 框架的诞生记1. 之前UC面试过一次，可惜挂了 2. 主要结合实际以一个很简单的Demo演示了MVVM，并且很清晰的解答了众多为止疑惑的参会者。 ============================================================================= 赵恩生（美团点评高级工程师）随着业务拆分和组件化的完成，美团 iOS 客户端在集成和交付的道路上越发艰难。在业务代码下放后，如何能保证客户端的安全稳定；面对千万用户，如何能快速优雅地组建并交付一个完整的客户端，这一切的一切都值得思考和深究。 希望通过本次分享，和各位一起探讨如何玩转大业务体量下的众多组件、如何搭建整个客户端的发布流程。 美团点评高级工程师，曾维护美团 iOS 客户端，现负责 iOS 发布流程相关工作，专业打杂，通过对复杂业务下组件发布集成的踩坑总结，对 CI CD 有一定的认识和理解。闲暇时喜欢捣鼓乱七八糟的东西，自学习得包括疏通下水道，手机贴膜，设备维修在内的一些奇怪技能。 组件 + 组建 = 美团 iOS 客户端1. 美团开发，集成，打包，测试，发布整个流程的工作与注意点。 2. 组件式的开发方式，规范性的流程与测试形成一个闭环 3. 校验，避错，后期的修复的考虑及解决方案 4. CI的基本流程介绍 ============================================================================= 傅若愚（ThoughtWorks 高级咨询师）是的，你一定听说过 Metal，或者你还写过一些 Metal 的 Shader。不过，说实话，喝了两杯啤酒之后，面对 Xcode，我们能做点儿更有趣的东西么？要不要来试试？ 来自 ThoughtWorks，刚睡醒的移动开发者，喝高了的 Tech Lead，SwiftyJSON 的作者（但这家伙已经弃坑……Oh，别担心，其他人还在维护）。业余喜读书，文史哲无所禁忌，爱美食与啤酒（最近爱上了 American Pale Ale），今年大概 17 岁的样子。 一些跟 Metal 有关系，肯定有趣但多半没用的东西1. 主要是机器学习，高逼格式的讲解了神经网络 2. 输入图片，视频染色然后渲染并输出对应的效果。 3. 主要是一些基础的概念，理论知识。 ============================================================================= 尹航（Google 工程师）深度学习总是让人联想到成吨的数据、笨重的服务器。但在移动端，我们能不能利用深度学习做一点有趣的事情呢？本次分享，让我们看看如何在iOS上运行起工业级的深度学习框架TensorFlow吧。 一个技能树歪掉的开发者。iOS 首个游戏辅助“叉叉助手”作者，也曾经编写《Cocos2d-x高级开发教程》，目前兴趣有移动安全和机器学习，Google 工程师，从事 Gmail 语义理解相关开发。 TensorFlow+iOS=❤️: 造一个颜文字输入法1. 机器学习，实战了一个emoji表情的输出。 2. 介绍了TensorFlow，介绍了他的一些特性与简单的应用 ============================================================================= 唐晓轩（礼物说联合创始人）Live Coding 礼物说联合创始人，全栈打杂工程师，公众号糖炒小虾，热衷于折腾各种黑技术。 当 Swift 遇上树莓派1. swift和树莓派之间的交互。 2. Swift+ARM，展示了一个watch跑的超级玛丽。 3. 展示数个小Demo，演示怎么与实际相结合，并提到为了对小米设备的实际应用 ============================================================================= 第二天尾声…到此整个会议已经全部结束，这一天在技术，底层，架构等方面收获就完全不一样了，同时后期会有文章介绍相关内容！ 随后，大家都纷纷离开准备回家或者会工作的城市！]]></content>
      <categories>
        <category>2017@Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>大会</tag>
        <tag>2017@Swift——中国开发者大会（第二天）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017@Swift——中国开发者大会（第一天）]]></title>
    <url>%2F2017%2F05%2F15%2F2017-Swift%E2%80%94%E2%80%94%E4%B8%AD%E5%9B%BD%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A%EF%BC%88%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%89%2F</url>
    <content type="text"><![CDATA[首先介绍一下会议信息 会议时间：2017年5月13日-5月14日， 地址：深圳凯宾斯基酒店， 人数：400人 嘉宾：18人，其中8位国外，8位国内。 第一天所有外国嘉宾的演讲时间，第二天是国内大牛的演讲时间！ 更多信息请点2017@Swift——中国开发者大会,同时后面也会抽空整理一下会议中讲到的内容，底层，细节与实现，敬请期待！ ================================================================================================================================= Tuomas Artman（Uber 移动架构和框架组负责人）Uber 使用 Swift 重写了 app，在这个分享中，Tuomas 会介绍如何在上百人的团队中使用 Swift 进行开发，并介绍 Uber 重写过程中遇到的各种问题和解决方法。Tuomas 是 Uber 移动架构和框架组的负责人。在来湾区之前，他创立了一家芬兰知名的数字资讯公司，还在上海的一家公司工作过一年，开发游戏和多用户技术平台。 Swift with hundreds of engineers1. 使用swift重构Uber的过程中good，bad，ugly。 2. 对架构重新设计了，并且将他成为router-&gt;interaction-&gt;builder简称RIBs。适用于Android和iOS双平台。 3. 重构后Uber的崩溃率降到了0.01%，这确实是一个非常理想的数据。 4. binary size关于Uber包的大小。 5. 关于如何缩短Uber的编译时间 6. 最后聊了一下unit test。 ================================================================================================================================= Sam Davies（RayWenderlich CTO）从基础的 NSOperation 一直到 Grand Central Dispatch，彻底讲明白 iOS 并发。此外还会涉及一些高级内容，比如 dispatch group 和线程安全。 Concurrency on iOS1. 异步并发。 2. 提出了开发中经常遇到的一些问题和解决方案 3. 提到了反转优先级 ================================================================================================================================= Igor Jerkovic（前 Facebook 资深开发者）Igor 在 Facebook 的视频团队工作了五年，非常熟悉国外大公司的那一套理论。他会在这次分享中介绍如何提高开发效率和代码质量。 我很喜欢编程，也喜欢学习新东西，尝试不同的方法。2011-2013 年我在 Facebook 实习，负责开发 iOS 项目。2014 年我正式加入 Facebook，一直在视频团队工作到 2016年。现在我在 Bellabeat 工作，这是一家和健康相关的创业公司，在旧金山、深圳和萨格勒布都有办公室。 iOS development efficiency at Facebook1. Facebook的开发流程，包括各种开发中的规范 2. 介绍了很多实用的工具Buck... ================================================================================================================================= Sommer Panage（Chorus Fitness 核心 iOS）在这个分享中，我会介绍无障碍和 VoiceOver。首先说明为什么无障碍支持很重要，然后通过一个权威的 iOS 应用了解你可以实现哪些无障碍功能。接着我会介绍 iOS 无障碍 API 以及如何对接 VoiceOver。最后，我会补充一些有趣的无障碍知识，除了支持 VoiceOver，我们还能做得更好。 Sommer Panage 目前是 Chorus Fitness 的核心 iOS 开发。在这之前，她做了两年 iOS freelancer，与此同时她还成为了一名马戏表演者和教练。更早的时候，她在 Twitter 和 Apple 的无障碍团队工作。Sommer 对心理学和计算机科学两个领域都有涉猎。在编写代码之余，她还会做绳索训练、高空秋千、倒立、跑步和抱石。你可以在 Twitter 上关注她，@sommer。 From Zero to Hero: Making your iOS App Accessible to VoiceOver and Beyond1. 主要是无障碍应用开发 2. 讲了iOS中的accessibility programing，并演示了对失明者的交互与使用。 3. 通过code演示了一些使用方式 ================================================================================================================================= Krunoslav Zaher（RxSwift 框架作者）我会介绍开发 Rx 的初衷、我对 Rx 的看法、Rx 的特点以及 Rx 和传统编程方式的区别。我还会介绍 Rx 的性能、不同设计模式的实现方式以及如何关联 Rx 和状态机。 在行业内摸爬滚打了 16 年。做过很多东西，增强现实引擎、BPM 系统、手机应用、机器人……最近在研究函数式编程和链式编程。白天我会帮准妈妈们听婴儿的心跳，晚上我会哄自己的宝贝女儿睡觉。 Thinking in Rx way1. 主要是对rx的用法介绍。 2. 提到了他写RX的初衷 ================================================================================================================================= Marius Rackwitz（CocoaPods、Realm 核心开发者）Marius 从大学毕业开始就从事移动端和 web 应用开发。最近他开始专注移动端开发，尤其是 iOS 和 Objective-C，以及后起之秀 Swift。当然，作为 CocoaPods 核心成员，他也没有抛弃 Ruby。加入 Realm 之后，他在社区中更加活跃，参与了很多大会。 JavaScript for Swift Developer1. 这哥们整个演讲的过程中很是激情，但是却让在场大部分参会者归为叛徒的了（哈哈，开个玩笑）。 2. JavaScript for Swift Developer主要是两者之间的不同。 ================================================================================================================================= Kyle Jessup（Perfect 框架作者，CTO）Perfect 作者，Lasso 编程语言（被苹果的子公司 Claris 收购）的服务端核心开发者。Kyle 自学能力很强，对 Swift、Java 和 C++ 都有深入了解。 小时候，Kyle 的父亲——一名曾在美国海军潜艇上服役的核工程师——送给他一台雅达利 800 个人电脑。从那时起，他就对技术产生兴趣，一直延续到现在。 Kyle 在德克萨斯的达拉斯出生，2015 年搬到加拿大，加入 PerfectlySoft 团队。 Swift作为后端开发相关1. 演示并分享了Swift实现后端开发的利弊 2. 介绍了了Perfect ================================================================================================================================= Saul Mora（流利说 iOS 工程师，MagicalRecord 作者）从上古时代开始接触 iOS，熟悉手动内存管理、编译器宏、pthread 和 头文件。Saul Mora 为了表达对编程前辈的尊重，在 Swift 中使用带可选变量的 Nib 编写 UI。掌握了 Objective C 之后，Saul 开始环游世界，进行历练。为了应对前方的算法挑战，Saul 积极拥抱 Swift。最近，Saul 生活在现代中国的核心城市——上海。他在流利说寺修行，开发这款优秀的 app，帮助中国用户学习英语。 Building Confidence: Testing iOS applications1. 以一个很滑稽很有乔布斯风格的开场吸引住了在场的参会者 2. 分析并深入讲解了测试的重要性和原则 ============================================================================= 第一天尾声…第一天的会议也就这样结束了，整个会议中大家谈论最多的问题就是关于英语的能力，这个后面会有相关的文章详细说明！]]></content>
      <categories>
        <category>2017@Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>2017@Swift——中国开发者大会（第一天）</tag>
        <tag>大会</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——自动打包上传]]></title>
    <url>%2F2017%2F04%2F21%2FiOS%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[为了不去每次都做这些繁琐的操作，我们只能做一个懒得程序狗，也就是将整个过程进行脚本化…… 之前写过一篇关于自动打包上传代码的教程，最近又开始需要上线APP，发现新版的Mac对之前的教程不支持了，就换了一种方式，这次试用fir. http://al1020119.github.io/blog/2016/12/26/ios-daobao/ 工作中一般两种情况，1.打包Ad-Hoc给测试人员，或者内部人员测试 2.打包product发布到App Store 所以，为了不去每次都做这些繁琐的操作，我们只能做一个懒得程序狗，也就是将整个过程进行脚本化 大概的步骤是写个bash脚本，执行自动打包iOS版本，到指定的目录 （有条件的公司，可以自己搭个小服务器，这样谁都可以随时随地的打包） 将打包好的文件上传到fir.im (当然上传到自己公司的服务器或者任何地方都行，只是fir.im我一直用，觉得比较方便) 开发一个内部使用的类似APPStore，上面放着自己公司的所有APP,每次有更新的时候，测试童鞋直接通过这个自己下载新APP就可以了 主要命令编译workspacexcodebuild -workspace workspacename -scheme schemename -configuration [-configuration configurationname] clean build SYMROOT=(SYMROOT) 编译projectxcodebuild -target targetname -configuration [-configuration configurationname] clean build SYMROOT=(SYMROOT) 查看配置信息xcodebuild -list xcrun打包ipaxcrun -sdk iphoneos PackageApplication -v projectName.app -o ipaName.ipa 其他在终端输入：xcodebuild –help 或 –h查看具体的选项 显示xcodebuildversion：xcodebuild –version 显示当前系统安装的sdk：xcodebuild –showsdks 显示当前目录下project Information：xcodebuild –list xcodebuild&amp;xcrunxcodebuild-&gt;Build xcrun-&gt;Api 终端查看对应版本iCocosdeiMac:115科技 iCocos$ xcrun --version xcrun version 31. iCocosdeiMac:115科技 iCocos$ xcodebuild -version Xcode 8.2.1 Build version 8C1002 xcodebuild 是苹果提供的打包项目或者工程的命令需要在包含 name.xcodeproj 的目录下执行 xcodebuild 命令，且如果该目录下有多个 projects，那么需要使用 -project 指定需要 build 的项目。 在不指定 build 的 target 的时候，默认情况下会 build project 下的第一个 target 当 build workspace 时，需要同时指定 -workspace 和 -scheme 参数，scheme 参数控制了哪些 targets 会被 build 以及以怎样的方式 build。 有一些诸如 -list, -showBuildSettings, -showsdks 的参数可以查看项目或者工程的信息，不会对 build action 造成任何影响，放心使用。 使用xcodebuild和xcrun打包签名我这里就使用公司项目作为测试，方便查找问题和后续打包上传 1. 终端输入xcodebuild -project T 115科技.xcodeproj -target 115科技 -configuration Release xcodebuild -project T 曹理鹏(iCocos)-梦工厂.xcodeproj -target 曹理鹏(iCocos)-梦工厂 -configuration Debug 这是骚等所有走完之后就能看到对应的信息，表示build成功Signing Identity: &quot;iPhone Developer: xxx(59xxxxxx)&quot; Provisioning Profile: &quot;iOS Team Provisioning Profile: *&quot; 且在该目录下会多出一个 build 目录，该目录下有 Release-iphoneos 和 曹理鹏(iCocos)-梦工厂.build 文件，根据我们 build -configuration 配置的参数不同，Release-iphoneos 的文件名会不同。在 Release-iphoneos 文件夹下，有我们需要的曹理鹏(iCocos)-梦工厂.app文件，但是要安装到真机上，我们需要将该文件导出为ipa文件，这里使用 xcrun 命令。 xcrun -sdk iphoneos -v PackageApplication ./build/Release-iphoneos/曹理鹏(iCocos)-梦工厂.app -o ~/Desktop/曹理鹏(iCocos)-梦工厂.ipa 这个时候桌面上就会出现一个曹理鹏(iCocos)-梦工厂.ipa文件，这就是我们平时Archive之后的问题，也正是我们所需要的ipa包 但是xcodebuild期间我出现了一个这样的错误ld: library not found for -lAFNetworking clang: error: linker command failed with exit code 1 (use -v to see invocation) ** BUILD FAILED ** The following build commands failed: Ld build/曹理鹏(iCocos)-梦工厂.build/Release-iphoneos/曹理鹏(iCocos)-梦工厂.build/Objects-normal/armv7/曹理鹏(iCocos)-梦工厂 normal armv7 Ld build/曹理鹏(iCocos)-梦工厂.build/Release-iphoneos/曹理鹏(iCocos)-梦工厂.build/Objects-normal/arm64/曹理鹏(iCocos)-梦工厂 normal arm64 (2 failures) 貌似是linker command failed with exit code 1经典错误，但是然并卵，于是看了一下pingpong从零开始写个自动打包IPA脚本中的build方式，也有类似的问题。多谢pingpong帮我解决了这个问题。iCocosdeiMac ios (develop) $ xcodebuild 2016-05-02 13:05:04.623 xcodebuild[1015:16272] [MT] PluginLoading: Required plug-in compatibility UUID ACA8656B-FEA8-4B6D-8E4A-93F4C95C362C for plug-in at path &apos;~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/XcodeColors.xcplugin&apos; not present in DVTPlugInCompatibilityUUIDs 2016-05-02 13:05:04.625 xcodebuild[1015:16272] [MT] PluginLoading: Required plug-in compatibility UUID ACA8656B-FEA8-4B6D-8E4A-93F4C95C362C for plug-in at path &apos;~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/OMColorSense.xcplugin&apos; not present in DVTPlugInCompatibilityUUIDs === BUILD TARGET xxx OF PROJECT xxx WITH THE DEFAULT CONFIGURATION (Release) === Check dependencies Write auxiliary files write-file /Users/iCocos/Documents/code/xxx/ios/build/xxx.build/Release-iphoneos/xxx.build/xxx.hmap write-file /Users/iCocos/Documents/code/xxx/ios/build/xxx.build/Release-iphoneos/xxx.build/xxx-own-target-headers.hmap write-file /Users/iCocos/Documents/code/xxx/ios/build/xxx.build/Release-iphoneos/xxx.build/Script-492B764475E022A63FB67F55.sh 解决方案是：执行xcodebuild需要指定你所需要对应的workspace和schemexcodebuild -workspace /Users/iCocos/Desktop/MBA/最新Git源代码/曹理鹏(iCocos)-梦工厂/曹理鹏(iCocos)-梦工厂.xcworkspace -scheme 曹理鹏(iCocos)-梦工厂 执行前，先查看下-list,这个可以知道xcodebuild命令下对应的参数需要填写的内容iCocosdeiMac ios (develop) $ xcodebuild -list 2016-05-02 15:24:26.656 xcodebuild[16535:154176] [MT] PluginLoading: Required plug-in compatibility UUID ACA8656B-FEA8-4B6D-8E4A-93F4C95C362C for plug-in at path &apos;~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/XcodeColors.xcplugin&apos; not present in DVTPlugInCompatibilityUUIDs 2016-05-02 15:24:26.661 xcodebuild[16535:154176] [MT] PluginLoading: Required plug-in compatibility UUID ACA8656B-FEA8-4B6D-8E4A-93F4C95C362C for plug-in at path &apos;~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/OMColorSense.xcplugin&apos; not present in DVTPlugInCompatibilityUUIDs Information about project &quot;xxx&quot;: Targets: xxx xxxTests Build Configurations: Debug Release If no build configuration is specified and -scheme is not passed then &quot;Release&quot; is used. Schemes: xxx 然后，成功了,如下：Entitlements: { &quot;application-identifier&quot; = &quot;L64TE3S9T9.com.曹理鹏(iCocos)-梦工厂.shaoshang&quot;; &quot;aps-environment&quot; = development; &quot;com.apple.developer.pass-type-identifiers&quot; = ( &quot;L64TE3S9T9.*&quot; ); &quot;com.apple.developer.team-identifier&quot; = L64TE3S9T9; &quot;get-task-allow&quot; = 1; } builtin-productPackagingUtility -entitlements -format xml -o /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Intermediates/曹理鹏(iCocos)-梦工厂.build/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.build/曹理鹏(iCocos)-梦工厂.app.xcent CodeSign /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Products/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.app cd /Users/iCocos/Desktop/MBA/最新Git源代码/曹理鹏(iCocos)-梦工厂 export CODESIGN_ALLOCATE=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/codesign_allocate export PATH=&quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/Users/iCocos/.rvm/gems/ruby-2.3.0/bin:/Users/iCocos/.rvm/gems/ruby-2.3.0@global/bin:/Users/iCocos/.rvm/rubies/ruby-2.3.0/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/iCocos/.rvm/bin:/usr/local/mysql/bin/mysql&quot; Signing Identity: &quot;iPhone Developer: Songbai He (73N6HPPJDP)&quot; Provisioning Profile: &quot;iOS Team Provisioning Profile: com.曹理鹏(iCocos)-梦工厂.shaoshang&quot; (34c1d23b-ade5-4d0f-9329-7b16009b30c2) /usr/bin/codesign --force --sign F8BAED0C84DB84AAA84769FED9FEAA9E80825C29 --entitlements /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Intermediates/曹理鹏(iCocos)-梦工厂.build/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.build/曹理鹏(iCocos)-梦工厂.app.xcent --timestamp=none /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Products/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.app Validate /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Products/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.app cd /Users/iCocos/Desktop/MBA/最新Git源代码/曹理鹏(iCocos)-梦工厂 export PATH=&quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/Users/iCocos/.rvm/gems/ruby-2.3.0/bin:/Users/iCocos/.rvm/gems/ruby-2.3.0@global/bin:/Users/iCocos/.rvm/rubies/ruby-2.3.0/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/iCocos/.rvm/bin:/usr/local/mysql/bin/mysql&quot; export PRODUCT_TYPE=com.apple.product-type.application builtin-validationUtility /Users/iCocos/Library/Developer/Xcode/DerivedData/曹理鹏(iCocos)-梦工厂-aqiwhxodbfeztuebgnzgbgicurgl/Build/Products/Debug-iphoneos/曹理鹏(iCocos)-梦工厂.app ** BUILD SUCCEEDED ** 下面就是验证你全栈的时候到了，其实也没有那么难，就是一点脚本而已先git 指令，pull到最新的分支# git update git checkout $BRANCHNAME if [ $? -ne 0 ]; then exit 1 fi git pull #pod update --verbose --no-repo-update if [ $? -ne 0 ]; then exit 1 fi 成功之后你同意会看到提示信息logout Saving session... ...copying shared history... ...saving history...truncating history files... ...completed. Deleting expired sessions...118 completed. xcodebuild进行编译xcodebuild \ -workspace $SORCEPATH/曹理鹏(iCocos)-梦工厂.xcworkspace \ -scheme $SCHEMENAMEPLQ \ -configuration Debug \ CODE_SIGN_IDENTITY=&quot;iPhone Developer: Songbai He(73N6HPPJDP)” \ PROVISIONING_PROFILE=&quot;com.曹理鹏(iCocos)-梦工厂.shaoshang&quot; \ clean \ build \ -derivedDataPath $IPAPATH/$BRANCHNAME/$DATE 测试与发布只需要更改对应的参数即可-configuration Debug -configuration Release 用xcrun打包成ipa包xcrun -sdk iphoneos PackageApplication \ -v $IPAPATH/Build/Products/Debug-iphoneos/$SCHEMENAME.app \ -o $IPAPATH/$IPANAME 生成ipa包，上传到fir.im一：1.注册fir.拿到tokenfir.im官网：https://fir.im 注册号账号，点击右上角个人信息，进入API token 拿到token，并保存 二：安装fir-clifir-cli 使用 Ruby 构建, 无需编译, 只要安装相应 gem 即可. $ ruby -v # &gt; 1.9.3 $ gem install fir-cli 三：Mac新版之后可能由于源的问题导致无法安装（由于10.11引入了 rootless, 无法直接安装 fir-cli）一般都是这么安装的：使用 Homebrew 及 RVM 安装 Ruby, 再安装 fir-cli Install Homebrew: $ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; Install RVM: $ \curl -sSL https://get.rvm.io | bash -s stable --ruby Install fir-cli: $ gem install fir-cli 四：在终端登录并查看信息 $ fir login 按照提示输入token,然后 iCocosdeiMac:曹理鹏(iCocos)-梦工厂 iCocos$ fir login Please enter your fir.im API Token: 849ad212b94683b4c3087248d422d124 I, [2017-04-18T13:58:01.184043 #14531] INFO -- : Login succeed, previous user&apos;s email: al10201119@163.com I, [2017-04-18T13:58:01.185131 #14531] INFO -- : Login succeed, current user&apos;s email: al10201119@163.com I, [2017-04-18T13:58:01.185223 #14531] INFO -- : $fir me 登录成功,就会显示用户信息 I, [2017-04-18T13:58:21.876164 #14545] INFO – : Login succeed, current user’s email: al10201119@163.com I, [2017-04-18T13:58:21.876246 #14545] INFO – : Login succeed, current user’s name: al10201119 I, [2017-04-18T13:58:21.876261 #14545] INFO – : 使用fir指令，上传我们的ipa包 fir login -T c525718a775b954882xxxxxxxx # fir.im token fir publish $IPAPATH/Develop/xxx.ipa 最后你会看到 恭喜！！！上传fir.im成功！ 也可以直接使用执行脚本#author iCocos #注意：脚本目录和xxxx.xcodeproj要在同一个目录，如果放到其他目录，请自行修改脚本。 #工程名字(Target名字) Project_Name=&quot;Target名字，系统默认和工程名字一样&quot; #配置环境，Release或者Debug Configuration=&quot;Release&quot; #AdHoc版本的Bundle ID AdHocBundleID=&quot;com.xxx&quot; #AppStore版本的Bundle ID AppStoreBundleID=&quot;com.xxx&quot; #enterprise的Bundle ID EnterpriseBundleID=&quot;com.xxx&quot; # ADHOC #证书名#描述文件 ADHOCCODE_SIGN_IDENTITY=&quot;iPhone Distribution: xxxx&quot; ADHOCPROVISIONING_PROFILE_NAME=&quot;xxxx-xxxx-xxxx-xxxx&quot; #AppStore证书名#描述文件 APPSTORECODE_SIGN_IDENTITY=&quot;iPhone Distribution: xxxx&quot; APPSTOREROVISIONING_PROFILE_NAME=&quot;xxxx-xxxx-xxxx-xxxx&quot; #企业(enterprise)证书名#描述文件 ENTERPRISECODE_SIGN_IDENTITY=&quot;iPhone Distribution: xxxxx&quot; ENTERPRISEROVISIONING_PROFILE_NAME=&quot;xxxx-xxxx-xxxx-xxxx&quot; #加载各个版本的plist文件 ADHOCExportOptionsPlist=./ADHOCExportOptionsPlist.plist AppStoreExportOptionsPlist=./AppStoreExportOptionsPlist.plist EnterpriseExportOptionsPlist=./EnterpriseExportOptionsPlist.plist ADHOCExportOptionsPlist=${ADHOCExportOptionsPlist} AppStoreExportOptionsPlist=${AppStoreExportOptionsPlist} EnterpriseExportOptionsPlist=${EnterpriseExportOptionsPlist} echo &quot;~~~~~~~~~~~~选择打包方式(输入序号)~~~~~~~~~~~~~~~&quot; echo &quot; 1 appstore&quot; echo &quot; 2 adhoc&quot; echo &quot; 3 enterprise&quot; # 读取用户输入并存到变量里 read parameter sleep 0.5 method=&quot;$parameter&quot; # 判读用户是否有输入 if [ -n &quot;$method&quot; ] then #clean下 xcodebuild clean -xcodeproj ./$Project_Name/$Project_Name.xcodeproj -configuration $Configuration -alltargets if [ &quot;$method&quot; = &quot;1&quot; ] then #appstore脚本 xcodebuild -project $Project_Name.xcodeproj -scheme $Project_Name -configuration $Configuration -archivePath build/$Project_Name-appstore.xcarchive clean archive build CODE_SIGN_IDENTITY=&quot;${APPSTORECODE_SIGN_IDENTITY}&quot; PROVISIONING_PROFILE=&quot;${APPSTOREROVISIONING_PROFILE_NAME}&quot; PRODUCT_BUNDLE_IDENTIFIER=&quot;${AppStoreBundleID}&quot; xcodebuild -exportArchive -archivePath build/$Project_Name-appstore.xcarchive -exportOptionsPlist $AppStoreExportOptionsPlist -exportPath ~/Desktop/$Project_Name-appstore.ipa elif [ &quot;$method&quot; = &quot;2&quot; ] then #adhoc脚本 xcodebuild -project $Project_Name.xcodeproj -scheme $Project_Name -configuration $Configuration -archivePath build/$Project_Name-adhoc.xcarchive clean archive build CODE_SIGN_IDENTITY=&quot;${ADHOCCODE_SIGN_IDENTITY}&quot; PROVISIONING_PROFILE=&quot;${ADHOCPROVISIONING_PROFILE_NAME}&quot; PRODUCT_BUNDLE_IDENTIFIER=&quot;${AdHocBundleID}&quot; xcodebuild -exportArchive -archivePath build/$Project_Name-adhoc.xcarchive -exportOptionsPlist $ADHOCExportOptionsPlist -exportPath ~/Desktop/$Project_Name-adhoc.ipa elif [ &quot;$method&quot; = &quot;3&quot; ] then #企业打包脚本 xcodebuild -project $Project_Name.xcodeproj -scheme $Project_Name -configuration $Configuration -archivePath build/$Project_Name-enterprise.xcarchive clean archive build CODE_SIGN_IDENTITY=&quot;${ENTERPRISECODE_SIGN_IDENTITY}&quot; PROVISIONING_PROFILE=&quot;${ENTERPRISEROVISIONING_PROFILE_NAME}&quot; PRODUCT_BUNDLE_IDENTIFIER=&quot;${EnterpriseBundleID}&quot; xcodebuild -exportArchive -archivePath build/$Project_Name-enterprise.xcarchive -exportOptionsPlist $EnterpriseExportOptionsPlist -exportPath ~/Desktop/$Project_Name-enterprise.ipa else echo &quot;参数无效....&quot; exit 1 fi fi 这里还有一个大神使用PHP干了一票，虽然还在学习PHP中，但是有机会也要试一下 这里目前只是实现了Ad-Hoc打包上传，关于App Store其实也就是更改参数，和对应的地址，后续会退出相应的文章界面具体实战……]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS——自动打包上传</tag>
        <tag>自动打包上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——ipv6(客户端)]]></title>
    <url>%2F2017%2F04%2F20%2FiOS%E2%80%94%E2%80%94ipv6-%E5%AE%A2%E6%88%B7%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[此篇文章的起源是由最近一次APP被拒引起的，就在上周，我们App因为ipv6的问题被拒了，当时我就纳闷了，前一次都没有被拒，这一次只改功能，逻辑，界面并没有涉及第三方或者网络相关集成，于是不得不整理一番…… 如果你想了解服务器对ipv6支持，请查看上一节：iOS——ipv6(客户端) 引言总的来说有三个方面需要进行检查和修改： 1、项目里面涉及和网络有关的网络请求是否支持ipv6。 2、项目里面涉及和网络有关的sdk是否支持ipv6。 3、项目的服务器是否支持ipv6。 IPv6的简介IPv4 和 IPv6的区别就是 IP 地址前者是 .（dot）分割，后者是以 :（冒号）分割的（更多详细信息自行搜索）。 PS：在使用 IPv6 的热点时候，记得手机开飞行模式哦，保证手机只在 Wi-Fi 下上网，以免手机在连接不到网络时候，会默认跳转到使用 蜂窝移动网络（即2G、3G、4G流量） 上网。 IPV6，是对IPV4地址空间的扩充。目前当我们用iOS设备连接上Wifi、4G、3G等网络时，设备被分配的地址均是IPV4地址，但是随着运营商和企业逐渐部署IPV6 DNS64/NAT64网络之后，设备被分配的地址会变成IPV6的地址，而这些网络就是所谓的IPV6-Only网络，并且仍然可以通过此网络去获取IPV4地址提供的内容。客户端向服务器端请求域名解析，首先通过DNS64 Server查询IPv6的地址，如果查询不到，再向DNS Server查询IPv4地址，通过DNS64 Server合成一个IPV6的地址，最终将一个IPV6的地址返回给客户端。 本地如何搭建IPv6环境测试你的APPhttp://jingyan.baidu.com/article/e75057f2f33cffebc91a89a3.html ipv6介绍与实现一、IPV6-Only支持是啥？首先IPV6，是对IPV4地址空间的扩充。目前当我们用iOS设备连接上Wifi、4G、3G等网络时，设备被分配的地址均是IPV4地址，但是随着运营商和企业逐渐部署IPV6 DNS64/NAT64网络之后，设备被分配的地址会变成IPV6的地址，而这些网络就是所谓的IPV6-Only网络，并且仍然可以通过此网络去获取IPV4地址提供的内容。客户端向服务器端请求域名解析，首先通过DNS64 Server查询IPv6的地址，如果查询不到，再向DNS Server查询IPv4地址，通过DNS64 Server合成一个IPV6的地址，最终将一个IPV6的地址返回给客户端。如图所示： 二、Apple如何审核支持IPV6-Only？首先第一点：这里说的支持IPV6-Only网络，其实就是说让应用在 IPv6 DNS64/NAT64 网络环境下仍然能够正常运行。但是考虑到我们目前的实际网络环境仍然是IPV4网络，所以应用需要能够同时保证IPV4和IPV6环境下的可用性。从这点来说，苹果不会去扫描IPV4的专有API来拒绝审核通过，因为IPV4的API和IPV6的API调用都会同时存在于代码中。 其次第二点：Apple官方声明iOS9开始向IPV6支持过渡，在iOS9.2+支持IPV4地址合成IPV6地址。其提供的Reachability库在iOS8系统下，当从IPV4切换到IPV6网络，或者从IPV6网络切换到IPV4，是无法监控到网络状态的变化。也有一些开发者针对这些Bug询问Apple的审核部门，给予的答复是只需要在苹果最新的系统上保证IPV6的兼容性即可。 最后第三点：只要应用的主流程支持IPV6，通过苹果审核即可。对于不支持IPV6的模块，考虑到我们现实IPV6网络的部署还需要一段时间，短时间内不会影响我们用户的使用。但随着4G网络IPV6的部署，这部分模块还是需要逐渐安排人力进行支持。 三、应用如何支持IPV6-Only？对于如何支持IPV6-Only，官方给出了如下几点标准：（这里就不对其进行解释了，大家看上面的参考链接即可） Use High-Level Networking Frameworks; Don’t Use IP Address Literals; Check Source Code for IPv6 DNS64/NAT64 Incompatibilities;4. Use System APIs to Synthesize IPv6 Addresses;3.1 NSURLConnection是否支持IPV6？ 官方的这句话让我们疑惑顿生： using high-level networking APIs such as NSURLSession and the CFNetwork frameworks and you connect by name, you should not need to change anything for your app to work with IPv6 addresses 只说了NSURLSession和CFNetwork的API不需要改变，但是并没有提及到NSURLConnection。 从上文的参考资料中，我们看到NSURLSession、NSURLConnection同属于Cocoa的url loading system，可以猜测出NSURLConnection在ios9上是支持IPV6的。 应用里面的API网络请求，大家一般都会选择AFNetworking进行请求发送，由于历史原因，应用的代码基本上都深度引用了AFHTTPRequestOperation类，所以目前API网络请求均需要通过NSURLConnection发送出去，所以必须确认NSURLConnection是否支持IPV6. 经过测试，NSURLConnection在最新的iOS9系统上是支持IPV6的。 3.2 Cocoa的URL Loading System从iOS哪个版本开始支持IPV6？目前我们的应用最低版本还需要支持iOS7，虽然苹果只要求最新版本支持IPV6－Only，但是出于对用户负责的态度，我们仍然需要搞清楚在低版本上URL Loading System的API是否支持IPV6.（to fix me, make some experiments）待续～～～ 3.3 Reachability是否需要修改支持IPV6？我们可以查到应用中大量使用了Reachability进行网络状态判断，但是在里面却使用了IPV4的专用API。 在Pods:Reachability中 AF_INET Files:Reachability.m struct sockaddr_in Files:Reachability.h , Reachability.m 那Reachability应该如何支持IPV6呢？ （1）目前Github的开源库Reachability的最新版本是3.2，苹果也出了一个Support IPV6 的Reachability的官方样例，我们比较了一下源码，跟Github上的Reachability没有什么差异。（2）我们通常都是通过一个0.0.0.0 (ZeroAddress)去开启网络状态监控，经过我们测试，在iOS9以上的系统上IPV4和IPV6网络环境均能够正常使用；但是在iOS8上IPV4和IPV6相互切换的时候无法监控到网络状态的变化，可能是因为苹果在iOS8上还并没有对IPV6进行相关支持相关。（但是这仍然满足苹果要求在最新系统版本上支持IPV6的网络）。 （3）当大家都在要求Reachability添加对于IPV6的支持，其实苹果在iOS9以上对Zero Address进行了特别处理，官方发言是这样的： reachabilityForInternetConnection: This monitors the address 0.0.0.0,which reachability treats as a special token that causes it to actuallymonitor the general routing status of the device, both IPv4 and IPv6. + (instancetype)reachabilityForInternetConnection { struct sockaddr_in zeroAddress; bzero(&amp;zeroAddress, sizeof(zeroAddress)); zeroAddress.sin_len = sizeof(zeroAddress); zeroAddress.sin_family = AF_INET; return [self reachabilityWithAddress: (const struct sockaddr *) &amp;zeroAddress]; } 综上所述，Reachability不需要做任何修改，在iOS9上就可以支持IPV6和IPV4，但是在iOS9以下会存在bug，但是苹果审核并不关心。 四、底层的socket API如何同时支持IPV4和IPV6？由于在应用中使用了网络诊断的组件，大量使用了底层的 socket API，所以对于IPV6支持，这块是个重头戏。如果你的应用中使用了长连接，其必然会使用底层socket API，这一块也是需要支持IPV6的。 对于Socket如何同时支持IPV4和IPV6，可以参考谷歌的开源库CocoaAsyncSocket. 下面我针对我们的开源 网络诊断组件, 说一下是如何同时支持IPV4和IPV6的。开源地址：https://github.com/Lede-Inc/LDNetDiagnoService_IOS.git 这个网络诊断组件的主要功能如下： 本地网络环境的监测（本机IP＋本地网关＋本地DNS＋域名解析）； 通过TCP Connect监测到域名的连通性； 通过Ping 监测到目标主机的连通耗时； 通过traceRoute监测设备到目标主机中间每一个路由器节点的ICMP耗时； 4.1 IP地址从二进制到符号的转化之前我们都是通过inet_ntoa()进行二进制到符号，这个API只能转化IPV4地址。而inet_ntop()能够兼容转化IPV4和IPV6地址。 写了一个公用的in6_addr的转化方法如下： //for IPV6 +(NSString *)formatIPV6Address:(struct in6_addr)ipv6Addr{ NSString *address = nil; char dstStr[INET6_ADDRSTRLEN]; char srcStr[INET6_ADDRSTRLEN]; memcpy(srcStr, &amp;ipv6Addr, sizeof(struct in6_addr)); if(inet_ntop(AF_INET6, srcStr, dstStr, INET6_ADDRSTRLEN) != NULL){ address = [NSString stringWithUTF8String:dstStr]; } return address; } //for IPV4 +(NSString *)formatIPV4Address:(struct in_addr)ipv4Addr{ NSString *address = nil; char dstStr[INET_ADDRSTRLEN]; char srcStr[INET_ADDRSTRLEN]; memcpy(srcStr, &amp;ipv4Addr, sizeof(struct in_addr)); if(inet_ntop(AF_INET, srcStr, dstStr, INET_ADDRSTRLEN) != NULL){ address = [NSString stringWithUTF8String:dstStr]; } return address; } 4.2 本机IP获取支持IPV6 相当于我们在终端中输入ifconfig命令获取字符串，然后对ifconfig结果字符串进行解析，获取其中en0（Wifi）、pdp_ip0（移动网络）的ip地址。 注意： （1）在模拟器和真机上都会出现以FE80开头的IPV6单播地址影响我们判断，所以在这里进行特殊的处理（当第一次遇到不是单播地址的IP地址即为本机IP地址）。（2）在IPV6环境下，真机测试的时候，第一个出现的是一个IPV4地址，所以在IPV4条件下第一次遇到单播地址不退出。 + (NSString *)deviceIPAdress { while (temp_addr != NULL) { NSLog(@&quot;ifa_name===%@&quot;,[NSString stringWithUTF8String:temp_addr-&gt;ifa_name]); // Check if interface is en0 which is the wifi connection on the iPhone if ([[NSString stringWithUTF8String:temp_addr-&gt;ifa_name] isEqualToString:@&quot;en0&quot;] || [[NSString stringWithUTF8String:temp_addr-&gt;ifa_name] isEqualToString:@&quot;pdp_ip0&quot;]) { //如果是IPV4地址，直接转化 if (temp_addr-&gt;ifa_addr-&gt;sa_family == AF_INET){ // Get NSString from C String address = [self formatIPV4Address:((struct sockaddr_in *)temp_addr-&gt;ifa_addr)-&gt;sin_addr]; } //如果是IPV6地址 else if (temp_addr-&gt;ifa_addr-&gt;sa_family == AF_INET6){ address = [self formatIPV6Address:((struct sockaddr_in6 *)temp_addr-&gt;ifa_addr)-&gt;sin6_addr]; if (address &amp;&amp; ![address isEqualToString:@&quot;&quot;] &amp;&amp; ![address.uppercaseString hasPrefix:@&quot;FE80&quot;]) break; } } temp_addr = temp_addr-&gt;ifa_next; } } } 4.3 设备网关地址获取获取支持IPV6其实是在IPV4获取网关地址的源码的基础上进行了修改，初开把AF_INET－&gt;AF_INET6, sockaddr -&gt; sockaddr_in6之外，还需要注意如下修改，就是拷贝的地址字节数。去掉了ROUNDUP的处理。 （解析出来的地址老是少了4个字节，结果是偏移量搞错了，纠结了半天），具体参考源码库。 /* net.route.0.inet.flags.gateway */ int mib[] = {CTL_NET, PF_ROUTE, 0, AF_INET6, NET_RT_FLAGS, RTF_GATEWAY}; if (sysctl(mib, sizeof(mib) / sizeof(int), buf, &amp;l, 0, 0) &lt; 0) { address = @&quot;192.168.0.1&quot;; } .... //for IPV4 for (i = 0; i &lt; RTAX_MAX; i++) { if (rt-&gt;rtm_addrs &amp; (1 &lt;&lt; i)) { sa_tab[i] = sa; sa = (struct sockaddr *)((char *)sa + ROUNDUP(sa-&gt;sa_len)); } else { sa_tab[i] = NULL; } } //for IPV6 for (i = 0; i &lt; RTAX_MAX; i++) { if (rt-&gt;rtm_addrs &amp; (1 &lt;&lt; i)) { sa_tab[i] = sa; sa = (struct sockaddr_in6 *)((char *)sa + sa-&gt;sin6_len); } else { sa_tab[i] = NULL; } } 4.4 设备DNS地址获取支持IPV6IPV4时只需要通过res_ninit进行初始化就可以获取，但是在IPV6环境下需要通过res_getservers()接口才能获取。 +(NSArray *)outPutDNSServers{ res_state res = malloc(sizeof(struct __res_state)); int result = res_ninit(res); NSMutableArray *servers = [[NSMutableArray alloc] init]; if (result == 0) { union res_9_sockaddr_union *addr_union = malloc(res-&gt;nscount * sizeof(union res_9_sockaddr_union)); res_getservers(res, addr_union, res-&gt;nscount); for (int i = 0; i &lt; res-&gt;nscount; i++) { if (addr_union[i].sin.sin_family == AF_INET) { char ip[INET_ADDRSTRLEN]; inet_ntop(AF_INET, &amp;(addr_union[i].sin.sin_addr), ip, INET_ADDRSTRLEN); NSString *dnsIP = [NSString stringWithUTF8String:ip]; [servers addObject:dnsIP]; NSLog(@&quot;IPv4 DNS IP: %@&quot;, dnsIP); } else if (addr_union[i].sin6.sin6_family == AF_INET6) { char ip[INET6_ADDRSTRLEN]; inet_ntop(AF_INET6, &amp;(addr_union[i].sin6.sin6_addr), ip, INET6_ADDRSTRLEN); NSString *dnsIP = [NSString stringWithUTF8String:ip]; [servers addObject:dnsIP]; NSLog(@&quot;IPv6 DNS IP: %@&quot;, dnsIP); } else { NSLog(@&quot;Undefined family.&quot;); } } } res_nclose(res); free(res); return [NSArray arrayWithArray:servers]; } 4.4 域名DNS地址获取支持IPV6在IPV4网络下我们通过gethostname获取，而在IPV6环境下，通过新的gethostbyname2函数获取。 //ipv4 phot = gethostbyname(hostN); //ipv6 phot = gethostbyname2(hostN, AF_INET6); 4.5 ping方案支持IPV6Apple的官方提供了最新的支持IPV6的ping方案，参考地址如下：https://developer.apple.com/library/mac/samplecode/SimplePing/Introduction/Intro.html只是需要注意的是： （1）返回的packet去掉了IPHeader部分，IPV6的header部分也不返回TTL（Time to Live）字段； （2）IPV6的ICMP报文不进行checkSum的处理； 4.6 traceRoute方案支持IPV6其实是通过创建socket套接字模拟ICMP报文的发送，以计算耗时；两个关键的地方需要注意： （1）IPV6中去掉IP_TTL字段，改用跳数IPV6_UNICAST_HOPS来表示； （2）sendto方法可以兼容支持IPV4和IPV6，但是需要最后一个参数，制定目标IP地址的大小；因为前一个参数只是指明了IP地址的开始地址。千万不要用统一的sizeof(struct sockaddr), 因为sockaddr_in 和 sockaddr都是16个字节，两者可以通用，但是sockaddr_in6的数据结构是28个字节，如果不显式指定，sendto方法就会一直返回－1，erroNo报22 Invalid argument的错误。 关键代码如下：（完整代码参考开源组件） //构造通用的IP地址结构stuck sockaddr NSString *ipAddr0 = [serverDNSs objectAtIndex:0]; //设置server主机的套接口地址 NSData *addrData = nil; BOOL isIPV6 = NO; if ([ipAddr0 rangeOfString:@&quot;:&quot;].location == NSNotFound) { isIPV6 = NO; struct sockaddr_in nativeAddr4; memset(&amp;nativeAddr4, 0, sizeof(nativeAddr4)); nativeAddr4.sin_len = sizeof(nativeAddr4); nativeAddr4.sin_family = AF_INET; nativeAddr4.sin_port = htons(udpPort); inet_pton(AF_INET, ipAddr0.UTF8String, &amp;nativeAddr4.sin_addr.s_addr); addrData = [NSData dataWithBytes:&amp;nativeAddr4 length:sizeof(nativeAddr4)]; } else { isIPV6 = YES; struct sockaddr_in6 nativeAddr6; memset(&amp;nativeAddr6, 0, sizeof(nativeAddr6)); nativeAddr6.sin6_len = sizeof(nativeAddr6); nativeAddr6.sin6_family = AF_INET6; nativeAddr6.sin6_port = htons(udpPort); inet_pton(AF_INET6, ipAddr0.UTF8String, &amp;nativeAddr6.sin6_addr); addrData = [NSData dataWithBytes:&amp;nativeAddr6 length:sizeof(nativeAddr6)]; } struct sockaddr *destination; destination = (struct sockaddr *)[addrData bytes]; //创建socket if ((recv_sock = socket(destination-&gt;sa_family, SOCK_DGRAM, isIPV6?IPPROTO_ICMPV6:IPPROTO_ICMP)) &lt; 0) if ((send_sock = socket(destination-&gt;sa_family, SOCK_DGRAM, 0)) &lt; 0) //设置sender 套接字的ttl if ((isIPV6? setsockopt(send_sock,IPPROTO_IPV6, IPV6_UNICAST_HOPS, &amp;ttl, sizeof(ttl)): setsockopt(send_sock, IPPROTO_IP, IP_TTL, &amp;ttl, sizeof(ttl))) &lt; 0) //发送成功返回值等于发送消息的长度 ssize_t sentLen = sendto(send_sock, cmsg, sizeof(cmsg), 0, (struct sockaddr *)destination, isIPV6?sizeof(struct sockaddr_in6):sizeof(struct sockaddr_in)); 第三方Reachability按照苹果开发者中心提示，这个必须换。 新的sdk包将这个方法干掉了：reachabilityForLocalWiFi，只要自己的代码中干掉就行了，没什么影响。 原因如下介绍： #pragma mark reachabilityForLocalWiFi //reachabilityForLocalWiFi has been removed from the sample. See ReadMe.md for more information. //+ (instancetype)reachabilityForLocalWiFi; 新浪微博根据官网提示，这个新的sdk支持了ipv6，所以进行替换。 替换后： 根据比较，新旧sdk只有上述变化，替换后command＋B编译无错误提示。应该没事。 连连支付按照连连支付官方文档 最新的sdk包是支持ipv6的，但是旧包也是支持的。项目中用的是2.4.0，官网上最新包是2.4.7，最后我们做了替换。 在新的方法里面添加了一个判断支付类型的参数。 根据项目中报错的两个地方，第一个是快捷支付，第二个是认证支付。按照之前的进行了修改。command＋B编译无错误提示。应该没事。 但是实际上还是遇到了崩溃的bug。然后我们换回了2.4.0版本，应为连连支付官网上说之前的版本也支持ipv6，我们之前的版本没有问题，所以换了回来，看看上线能成功不。 友盟按照友盟官方sdk文档描述，需要更换新的sdk包。 按照需要，勾选了如下： md，搞错了，项目里面的友盟是友盟分析，上边那个是友盟分享。。。 但是根据官方文档，好像我们的不用替换，因为涉及到什么IDFA，我们项目好像不涉及这个。 微信按照微信最新sdk包1.7版本里面的README.txt，最新的sdk包支持ipv6 而我们项目中的微信是1.5版本的。应该进行替换。command＋B编译无错误提示。应该没事。 比较可笑的是微信的sdk包是支持ipv6的，但是微信本身并不支持ipv6，所以说，即便你替换了最新的sdk包，在ipv6网络下还是不能用微信分享，因为你的app应用在ipv6网络环境下调不起微信，也就分享不了了，这个问题微信应该意识到了，估计后边的版本应该也是支持ipv6的吧。 QQ官方文档好像也没有说ipv6的事啊 次奥！支付宝sdk支持了ipv6，上午下载的时候没看见！！！可是下载的时候总是打不开.zip的压缩包。。。叫别人帮忙下载了一份 command＋B编译无错误提示。应该没事。 百度地图根据比较，新的sdk包没有了bundle文件。需要将旧包的bundle文件拷贝进来。 总之，对于ipv6_Only的处理就是这样办的，从两大方面进行自己审核：自身网络请求和三方涉及网络请求。 关于AFNetworking是否支持ipv－6 可见，AFNetworking是支持ipv－6的。 注意： 1.ios9 和 mac os 10.11以后NSURLSession和CFNetwork自动将ipv4合成ipv6进行请求 2.AFN升级3.3就可以实现ipv4 所以对于客户端来说三点即可 1. 检查你所用的库，想AFN3.0以上等，其他的库自己搜索是否支持ipv6 2. 确保所用的SDK支持ipv6，一般文档都会有说明，到目前为止，应该大部分第三方SDK都已经支持ipv6 3. 测试 dig + nocomd + nostats 你的域名 这里主要是看服务器ipv6下是否有相应 如果你有事吗疑问，关于ipv6，关于iOS开发，或者关于PHP学习，欢迎直接联系我，或者在下面留言，希望能一起交流学习！]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS——ipv6(客户端)</tag>
        <tag>ipv6(客户端)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS——ipv6(服务器)]]></title>
    <url>%2F2017%2F04%2F20%2FiOS%E2%80%94%E2%80%94ipv6-%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[此篇文章的起源是由最近一次APP被拒引起的，就在上周，我们App因为ipv6的问题被拒了，当时我就纳闷了，前一次都没有被拒，这一次只改功能，逻辑，界面并没有涉及第三方或者网络相关集成，于是不得不整理一番…… 当时情形是这样的：在2月份之前公司已经上线了一个App，当时我并不知道已经上线的App知否支持ipv6，在我重写整个App，并在上线前对苹果审核规则细查的时候也想到了，当时正好因为去年年末苹果的一份给所有开发中的邮件，我就略过了这一步，结果也上线成功的，现在在发现我这是误打误撞亦或者是运气问题…… 就在第二个版本，上线的时候，既然被拒了，当时我就纳闷了，经过思考与讨论才知道，原来2月份之前上线的App中，服务器是已经搭建的ipv6环境的，但是我们上线第一个版本也是有ipv6的，就在上线第二个版本之前，老板问了我是否需要还需要ipv6支持，当时我只想到了苹果的那份邮件：苹果延迟ipv6的支持。所以就回复不需要的，就这样服务器就删除了ipv6环境….. 上线之后才发现，之前服务器支持ipv6，客户端大部分支持ipv6。先删除服务器ipv6的支持，导致苹果开启客户端ipv6测试的时候，很多操作都无法实现，没办法只能让服务器重新ipv6，并且客户端做相关细节处理….. 好了，废话不多说,本次讲以服务器和客户端讲解ipv6支持的实现，处理，细节。客户端将在下节介绍。 首先我们来为服务器量身定制的解决方案提供最快捷、稳定、高效、安全、可靠的IPv6解决方法. 苹果AppStore审核员在美国的IPv6-Only环境下对APP进行访问（审核），如果APP Server支持IPv6，则可直接访问；如果APP Server不支持IPv6，则通过DNS64 +NAT64进行访问；很明显，大部分开发者的APP服务器都是不支持IPv6直接访问的，所以基本是用NAT64+DNS64进行访问的。那么我们就先了解NAT64+DNS64的访问机制吧，直接看图： 从这里看出审核的关键在于能不能获取一个有效的Server IPv6地址。当苹果公司的APP审核员在进行审核时，由于国内大部分开发者的APPserver没有IPv6地址，只能通过苹果公司自己的NAT64+DNS64服务器进行测试，而最关键的是苹果的服务器不能有效的给APPserver返回一个IPv6地址，这就导致了审核失败，APP被拒。 就国内目前来说审核被拒的主要原因有第三个： 1、国内大部分APP服务器没有IPv6地址，导致DNS无法解析； 2、苹果公司的审核环境不能自动将中国APP内URL转换成IPv6可访问的格式，导致访问失败； 3、由于国际线路带宽严重拥堵等原因造成访问不稳定，失败率高 那么该如何解决这些问题呢？ 方案一就目前国内的现状，能够提供这种服务的当属教育网了，中国教育网坐拥全国几百所高校，拥有真实的IPv6骨干网络，国际出口，IPv6资源丰富，服务质量好。 因此解决方案就是使用教育网的NAT64+DNS64服务，方案示意图如下： 具体的操作步骤就是使用教育网的NAT64+DNS64，把您的域名发给我们，帮你解析出IPv6地址（全球可达的地址），您只需在您的域名管理中添加一条4A记录即可，之后就可以提交审核了，一天之后你就会发现审核通过了！ 解决方案二既然审核被拒是因为IPV6，那么我们就让服务器支持就可以了，但是很多运营商的服务器不提供IPv6地址，这样的话就要使用IPv6隧道技术,通过建立隧道使自己的服务器通过IPv6隧道来支持IPv6,方案示意图如下： 使用IPv6隧道服务APP服务器必须满足三个条件： ① 服务器拥有公网IPv4地址 ② 服务器支持IPv6协议 ③ 服务器放行6in4协议 具体的配置如下：（这里只是举个例子） 确认申请了IPv6隧道服务并按照上述模板进行配置完成后，请检查防火墙（iptables）是否放行了6in4协议，并确认(/etc/sysctl.conf)中IPv6转发已打开。如果上述操作都已正确完成，那么在你的服务器上应该可以看到如下结果： 至此，IPv6隧道搭建完毕，服务器已经支持IPv6了，赶紧提交审核去吧！ 目前来说，服务器对ipv6支持的的实现，大部分公司或者技术人员都可以做，要求并不高。 下节将介绍客户端实现，处理，细节等。 如果你有事吗疑问，关于ipv6，关于iOS开发，或者关于PHP学习，欢迎直接联系我，或者在下面留言，希望能一起交流学习！]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS——ipv6(服务器)</tag>
        <tag>ipv6(服务器)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[直播--技术原理篇]]></title>
    <url>%2F2017%2F03%2F20%2F%E7%9B%B4%E6%92%AD-%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E7%AF%87%2F</url>
    <content type="text"><![CDATA[最近在做直播的App，但是使用的是腾讯云，大部分东西都被封装好了，曾经也想过整理一下关于腾讯云的使用，但是最后想想还是没有必要，官方说的那么好，虽然也会遇到一些坑。所以就找了一些之前留意过的关于直播的东西，整理一下。 视频直播1：采集：AVCaptureSession，显示：AVCaptureVideoPreviewLayer 2：MP4：MP4 是一种视频容器格式 MP4文件中的所有数据都装在box(QuickTime中为atom)中,也就是说MP4文 件由若干个box组成,每个box有类型和长度,可以将box理解为一个数据对象 MP4 件格式是ISO-14496-12基础 件格式的衍 品,14496-14 中对-12协议进 了扩充与进 步定义。 重要的是该“14496-12 基础 件格式”协议如果认祖归宗,我们发现这种 件 格式最初是由Apple公司的QuickTime媒体格式发展 来的。 即,mov格式发展出了“ISO 14496 – 12协议”,再由该协议衍 出了 mp4,f4v,ismv,3gp等我们常见的媒体封装格式。 因此上述标志位的poster位,在14496-12中并没有见到描述, 在Apple的协 议中却看到了准确定义 H264：H.264 是一种图像编码标准。H264是一种高压缩率的编码标准,如何压缩嘞?一般的视频采集都是25帧/秒, 也就是每秒截图25次,其实每一张图片的内容都相差不大,压缩的办法就是利用算 法,只将每张图片变动差异化的部分保存下来,这样视频文件就小多了 三种帧在H264协议里定义了三种帧,完整编码的帧叫I帧,参考之前的I帧生成的只包含差 异部分编码的帧叫P帧,还有一种参考前后的帧编码的帧叫B帧。 H264结构中,一个视频图像编码后的数据叫做一帧,一帧由一个片(slice)或多 个片组成,一个片由一个或多个宏块(MB)组成,一个宏块由16×16的yuv数据 组成。宏块作为H264编码的基本单位。 H264采用的核心算法是帧内压缩和帧间压缩,帧内压缩是生成I帧的算法,帧间压 缩是生成B帧和P帧的算法。 + I帧:帧内编码帧 ,I帧表示关键帧,你可以理解为这一帧画面的完整保留;解码时只 需要本帧数据就可以完成(因为包含完整画面) + P帧:前向预测编码帧。P帧表示的是这一帧跟之前的一个关键帧(或P帧)的差别, 解码时需要用之前缓存的画面叠加上本帧定义的差别,生成最终画面。(也就是差 别帧,P帧没有完整画面数据,只有与前一帧的画面差别的数据) + B帧:双向预测内插编码帧。B帧是双向差别帧,也就是B帧记录的是本帧与前后帧的 差别(具体比较复杂,有4种情况,但我这样说简单些),换言之,要解码B帧,不 仅要取得之前的缓存画面,还要解码之后的画面,通过前后画面的与本帧数据的叠 加取得最终的画面。B帧压缩率高,但是解码时CPU会比较累。 一个序列的第一个图像叫做 IDR 图像(立即刷新图像),IDR 图像都是 I 帧图像。 H.264 引入 IDR 图像是为了解码的重同步,当解码器解码到 IDR 图像时,立即将 参考帧队列清空,将已解码的数据全部输出或抛弃,重新查找参数集,开始一个新 的序列。这样,如果前一个序列出现重大错误,在这里可以获得重新同步的机会。 IDR图像之后的图像永远不会使用IDR之前的图像的数据来解码。 一个序列就是一段内容差异不太大的图像编码后生成的一串数据流。当运动变化比 较少时,一个序列可以很长,因为运动变化少就代表图像画面的内容变动很小,所 以就可以编一个I帧,然后一直P帧、B帧了。当运动变化多时,可能一个序列就比 较短了,比如就包含一个I帧和3、4个P帧。 H264编码后的数据分为两层:1. VCL(video coding layer)视频编码层:它是对核心算法引擎,块,宏块 及片的语法级别的定义,最终输出编码完的数据 SODB。 2. NAL(network abstraction layer)网络提取层:定义片级以上的语法级别 (如序列参数集和图像参数集,针对网络传输),同时支持以下功能:独立 片解码,起始码唯一保证,SEI以及流格式编码数据传送,NAL层将SODB打 包成RBSP然后加上NAL头,组成一个NALU(NAL单元)。 分层的好处显而易见,对于RTMP传输数据,我们只需了解NAL层就足够了。 H264硬编原理想要采用硬件加速编码视频,苹果提供的只有 AVAssetWriter 类,而它只能写入编码后的文件到指定路径的文件中。我们如果想要实时硬编码,例如将视频流输出到网络,这时就需要从输出文件中不断读取新的编码后视频数据。 实现AVEncoder 通过使用 GCD Dispatch Source 监听文件的内容改变,通 过此方式高效的读取编码后的数据,然而简单的读取 raw data 并不能满足我们的 需求,因此在代码中根据Mp4的文件结构(要看懂这里就需要前面介绍的知识 了),每次读取一个完整的 NALU 后再将数据通过 block 传递给外部调用者处理。 AVEncoder -&gt; 读入CMBu er -&gt; 调用 AVAssetWriter 编码Bu er -&gt; 设置 header 的 FileHandler -&gt; 获得第一帧(moov[sps, pps]),切换写入文件(寻 找mdat),重设FileHandle -&gt; [输入数据 -&gt; 编码 处理循环 ] -&gt; 发送给调用者 处理。 FLVFLV里面是由多个Tag构成的:[[tag1][tag2][tag3][tag4]…] 而Tag多种类型,最常见的是 Metainfo Tag , Video Tag , Audio Tag 。 Flv Header 是文件的头部,用 FLV 字符串标明了文件的类型,以及是否有音频、 视频等信息。之后会有几个字节告诉接下来的包字节数。 Metainfo 中用来描述Flv中的各种参数信息,例如视频的编码格式、分辨率、采样 率等等。如果是本地文件(非实时直播流),还会有偏移时间戳之类的信息用于支 持快进等操作。 VideoTag 存放视频数据。对于H.264来说,第一帧发送的NALU应为 SPS和PPS, 这个相当于H.264的文件头部,播放器解码流必须先要找到这个才能进行播放。之 后的数据为I帧或P帧。 AudioTag 存放音频数据。对于AAC来说,我们只需要在每次硬编码完成后给数据 加上adts头部信息即可 VLC：（MobileVLCKit.framework）VLC Media Player (VideoLAN) 为 Windows、Linux、OS X、Android、iOS、Windows Phone等平台提供 个视频播放 器、解码器。它可以播放来 络、摄像头、磁盘、光驱的 件, 持包括MPEG 1/2/4, H264, VC-1, DivX, WMV, Vorbis, AC3, AAC等格式的解码。在 Windows 和 Linux 上的 VLC 是使 C++/Qt写成,提供了 致的 户体验。同时 VLC 还专门 为 OS X 提供了原 版本,OS X 版的 VLC 的 户界 使 Cocoa框架编写,在 OS X 下拥有卓越的原 体验。 VLC优秀的封装,源码中最核 的部分,被封装成了独 的库,基于FFmpeg,Live555提供完整的媒体播放库,你只 需要定制 的界 , 持CocoaPods导 库,开发 个简单界 的播放器,你只需要 代码, 乎覆盖所有媒体格 式!http://www.videolan.org/vlc/download-ios.html 直播博客推荐 [基于RTMP的视频推流](http://www.jianshu.com/p/8ea016b2720e) [高仿&lt;喵播APP&gt;](http://www.jianshu.com/p/b8db6c142aad) [高仿&lt;喵播APP&gt;](http://www.jianshu.com/p/b8db6c142aad) [吖了个峥](http://www.jianshu.com/users/b09c3959ab3b/latest_articles) [七牛云技术(三方直播)](http://www.jianshu.com/users/342c4dafa482/latest_articles) [原文](http://www.cocoachina.com/ios/20161111/18050.html)]]></content>
      <categories>
        <category>Live</category>
      </categories>
      <tags>
        <tag>直播--技术原理篇</tag>
        <tag>Live</tag>
        <tag>技术原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试被虐总结二]]></title>
    <url>%2F2017%2F03%2F12%2F%E9%9D%A2%E8%AF%95%E8%A2%AB%E8%99%90%E6%80%BB%E7%BB%93%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[年后因为各种原因只能重新找工作，期间进攻了UC，CVTE，酷狗还有其他一些比较大一点的公司，一路过来，被虐的不要不要的。 性能优化实战nstrumentsnstruments有三件套(Time Profiler、Core Animation、GPU Driver)，秒把U（GPU、CPU）来搞。 如果想在地铁上用手机也能调BUG，也可以使用HeapInspector，支持OC和Swift，比Beagle更强大。能监测Leak、Retain cycles、dirty memory、对象生命周期（PS：最难调的BUG，往往跟生命周期有关） 解决问题一：App进入一个界面比较慢，尤其是首次进入： 聊天界面 创建Controller及相关类 读取消息列表 渲染消息 通过Instrument Profile过后，发现当时App有相当一部分时间花费在了CoreText的渲染上。当时App的文本消息是使用CoreText绘制的，而CoreText整个绘制流程当中有一步占比最重：文本消息的高度宽度计算及超链接检测。 解决1：以空间换时间，把文字高宽度和超链接的信息都存入database，这样下次启动的时候不用重新计算计算完之后，再启动一个后台任务在子线程当中把计算好的信息（dirty message）存入database。 ### App页面卡顿：滑动中出现严重卡顿问题 用一个倾斜90°的tableview来做，简单，不用自己维护重用队列，每个cell放一个 vc 的view 就可以了。 ### 经测试发现严重卡顿。 用scrollView来写，自己来维护重用队列，具体做法大家可以参考 UIScrollView 实践经验 （3.重用） 。最后“完美”地实现了需求，开始做别的需求去了。 上线一个多月之后发现。我在使用过程中。在scrollView滚动的时候，明显的感觉到了卡帧，然后就开始优化。 ### 解决思路 1.尼玛，该不会是 UIScrollView的重用 没写好？ 断点验证了下，vc只会创建3个，重用没问题呀。 2.因为涉及重用，所有vc里面tableview的内容肯定不是一下子全请求出来的，每滚动一次才会去请求下个页面的数据，以及初始化页面。然后再看nice，忽然发现它滚动的时候，状态栏居然没有网络请求的小菊花！！难不成是一次请求的？应该不会吧，这么多数据呀。为了验证这种猜想，用 Charles 拦截下，结果nice也是每滚动次发次请求的： github，博客，stackOverFlow，各种google，发现都是一些关于tableView优化规范而已。 ### 只能靠自己一点点琢磨了。 先跑下Instruments三件套吧(Time Profiler,Core Animation,GPU Driver)。 1.排除了GPU的问题：关于渲染，OPenGL ES Driver中检测 2.排除了CPU的问题：cellForRowCPU使用30%，头像的地方 ### 只能从代码了： cell的高度没有缓存，这肯定有影响 发现refreshData的success block回调居然执行2次，这岂不是意味着tableview要reloadData两次，短时间刷新2次，肯定会卡啊 ## 三（四）次握手 ### 其实有个问题，为什么连接的时候是三次握手，关闭的时候却是四次挥手？ 因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手 ## 崩溃记录 1、数组越界导致的崩溃。 -[__NSArrayI objectAtIndex:]: index 100 beyond bounds [0 .. 99]’ 2、数据集合类型，如字典、数组中插入元素时，插入空指针nil。 3、调用当前对象类中不存在的方法导致崩溃。 ‘-[AppDelegate button1]: unrecognized selector sent to instance 0x8c764c0’ 4、数据接收时，服务器返回数据不规范，如字典或数组元素中存在null，且客户端没做处理导致的崩溃。 5、内存管理不当，向野指针发送消息导致的崩溃。（此类bug最难解决，所以编码时谨慎） 一般报错为：EXC_BAD_ACCESS ## 疑难杂症 认定消息已经发送成功：二次握手，非心跳包 网络请求失败：域名解析错误，使用ip+host MOV-MP4-&gt;android:使用ijk底层编码H264 文件上传：32位的MD5结合文件的前8个字节的16位+文件的后8个字节的16位=64位 ### 总结 一、客户端发送的请求数量和服务端接收的数量不一致。原因可能是服务端并发请求数量设置的过小。 二、利用循环请求数据时小概率的引起程序崩溃。原因可能是两个线程同时对一个数据源进行了操作。 三、绘制分时、k线时线条模糊，举行时会出现四条边不一样粗细。原因就是IOS绘机制的问题。 四、利用tableView的headerViewForSection:方法获取headerView时一直是nil。原因应该是设置headerView时利用- (UIView *)tableView: viewForHeaderInSection:的代理方法返回的UIView应该是UITableViewHeaderFooterView类型的，很多时候被他的返回值（UIView *）误导了。 五、由于项目比较大，页面多而且复杂，有时就需要从当前的responder通过nextResponder（一个甚至多个）找到深层次的VeiwController。 六、项目中需要用到循环刷新数据，利用NSTimer来实现，但是想在VC销毁时停掉timer（就是在dealloc方法中停掉），结果发现dealloc根本不调用，原本以为是引用计数没有减到0，可是问题不在此，而就在NSTimer这。结果在viewDidDisappear:停掉timer后就调用dealloc方法了。 七、利用viewWithTag:寻找子View时，出现绝对性的错误，对象类型都不对。问题出现在设置的tag有重复，要注意的是子View在包括子View的子View的tag都不可以重复，所以建议另外创建一个文件专门设定tag，就像android中的R.java文件一样来确保tag的唯一。 ### 准确机制 二次握手：而心跳机制，是为了确保客户端跟服务器链接没问题，客户端定时的给服务器发送空字符串或额定格式的消息（一般而言，不会太多内容，节省流量），然后客户端根据返回的结果判断（超时、正常、断线）而做重连与否的操作 非心跳包：二次握手是指小心接收发送都得遵循的，是指一个消息的传递，如A给B发一个消息，A发送到服务器，服务器发给B ，B根据消息告诉服务器已经收到，服务器再传递给A（最后一步可要可不要）；这样一个流程下来才叫一个消息传递成功 ## 关于tableView性能优化 正确使用reuseIdentifier来重用cells 尽量使所有的view opaque，包括cell自身 避免渐变，图片缩放，后台选人 缓存行高 如果cell内现实的内容来自web，使用异步加载，缓存请求结果 使用shadowPath来画阴影 减少subviews的数量 尽量不适用cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果 使用正确的数据结构来存储数据 使用rowHeight, sectionFooterHeight 和 sectionHeaderHeight来设定固定的高，不要请求delegate ### 只定义一种Cell。 ``` bash 提前计算并缓存每个Cell的高度。 提前创建真正显示的、需要加工的数据并缓存。 缓存View！ 在UITableView的Delegate、DataSource方法中，减少任何不必要的操作 最常用的就是cell的重用， 注册重用标识符如果不重用cell时，每当一个cell显示到屏幕上时，就会重新创建一个新的cell 如果有很多数据的时候，就会堆积很多cell。如果重用cell，为cell创建一个ID 每当需要显示cell 的时候，都会先去缓冲池中寻找可循环利用的cell，如果没有再重新创建cell 设置正确的reuseIdentifer以重用cell 避免cell的重新布局cell的布局填充等操作 比较耗时，一般创建时就布局好 如可以将cell单独放到一个自定义类，初始化时就布局好 提前计算并缓存cell的属性及内容在cellForRowAtIndexPath:中尽量做更少的操作。如果需要做一些处理，那么最好做过一次之后，就将结果缓存起来。 当我们创建cell的数据源方法时，编译器并不是先创建cell 再定cell的高度 而是先根据内容一次确定每一个cell的高度，高度确定后，再创建要显示的cell，滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell 减少cell中控件的数量尽量使cell得布局大致相同，不同风格的cell可以使用不用的重用标识符，初始化时添加控件， 不适用的可以先隐藏 不要使用ClearColor，无背景色，透明度也不要设置为0渲染耗时比较长 尽量将view设置为不透明，包括cell本身。 使用局部更新如果只是更新某组的话，使用reloadSection进行局部更新 加载网络数据，下载图片，使用异步加载，并缓存如果cell显示的内容来此网络，那么确保这些内容是通过异步来获取的 少使用addView 给cell动态添加view按需加载cell，cell滚动很快时，只加载范围内的cell注意正确使用懒加载 不要实现无用的代理方法，tableView只遵守两个协议非必要的代理或者数据源方法可以省略，比如numberofsention 缓存行高：如果row的高度不相同，那么将其缓存下来 estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。所以我的建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可 避免渐变，图像缩放以及离屏绘制使用shadowPath来设置阴影。使用适当的数据结构来保存需要的信息。不同的结构会带来不同的操作代价。使用rowHeight, sectionFooterHeight 和 sectionHeaderHeight 来设置一个恒定 高度，而不要从delegate中获取。使用富文本标签代价是很昂贵的tableView性能优化总结入门级（这是些你一定会经常用在你app开发中的建议）1. 用ARC管理内存 2. 在正确的地方使用reuseIdentifier 3. 尽可能使Views不透明 4. 避免庞大的XIB 5. 不要block主线程 6. 在Image Views中调整图片大小 7. 选择正确的Collection 8. 打开gzip压缩 中级（这些是你可能在一些相对复杂情况下可能用到的）9. 重用和延迟加载Views 10. Cache, Cache, 还是Cache！ 11. 权衡渲染方法 12. 处理内存警告 13. 重用大开销的对象 14. 使用Sprite Sheets 15. 避免反复处理数据 16. 选择正确的数据格式 17. 正确地设定Background Images 18. 减少使用Web特性 19. 设定Shadow Path 20. 优化你的Table View 21. 选择正确的数据存储选项 进阶级（这些建议只应该在你确信他们可以解决问题和得心应手的情况下采用）22. 加速启动时间 23. 使用Autorelease Pool 24. 选择是否缓存图片 25. 尽量避免日期格式转换]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>面试被虐总结二</tag>
        <tag>面试二</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试被虐总结一]]></title>
    <url>%2F2017%2F03%2F12%2F%E9%9D%A2%E8%AF%95%E8%A2%AB%E8%99%90%E6%80%BB%E7%BB%93%E4%B8%80%2F</url>
    <content type="text"><![CDATA[年后因为各种原因只能重新找工作，期间进攻了UC，CVTE，酷狗还有其他一些比较大一点的公司，一路过来，被虐的不要不要的。 消息机制关于消息机制简单实现：isa-&gt;class-&gt;selector是否忽略（mac垃圾忽略retain，release）-&gt;是否nil（nil执行方法忽略，运行时忽略掉：我们给把nil对象设给了一个成员变量，setter就会retain nil对象(当然了这个时候nil对象啥事情也不会做)然后release旧的对象）-&gt;查找类的IMP-&gt;缓存列表中-&gt;方法列表中-&gt;父类中（重复上面，直到根类）-&gt;任何一处找到加入缓存，方便下次-&gt;通过方法中的函数指针跳转到对应的函数执行-&gt;都找不到就开始转发 Runtime消息机制完整实现首先通过obj的isa指针找到obj对应的class。 首先检测这个 selector 是不是要忽略。比如 Mac OS X 开发，有了垃圾回收就不理会 retain，release 这些函数。 检测这个 selector 的 target 是不是 nil，Objc 允许我们对一个 nil 对象执行任何方法不会 Crash，因为运行时会被忽略掉。 如果上面两步都通过了，那么就开始查找这个类的实现 IMP， 在Class中先去cache中 通过SEL查找对应函数method，找到就执行对应的实现。 若cache中未找到，再去methodList中查找，找到就执行对应的实现。 若methodlist中未找到，则取superClass中查找（重复执行以上两个步骤），直到找到最根的类为止。 若任何一部能找到，则将method加 入到cache中，以方便下次查找，并通过method中的函数指针跳转到对应的函数中去执行。 如果以上都不能找到，则会开始进行消息转发 消息转发：（动态：resolveInstanceMethod，给机会添加实现）检测是否动态添加方法-&gt;（快速：forwardingTargetForSelector，别的对象执行函数）是否实现了forward。方法-&gt;（标准：forwardInvocation，目标函数以其他形式执行）Runtime发送消息获取签名-&gt;非空就inv转发，否则崩溃退出（doesNotRecognizeSelector） 消息转发完整实现1.动态方法解析：向当前类发送 resolveInstanceMethod: 信号，检查是否动态向该类添加了方法。（迷茫请搜索：@dynamic） 2.快速消息转发：检查该类是否实现了 forwardingTargetForSelector: 方法，若实现了则调用这个方法。若该方法返回值对象非nil或非self，则向该返回对象重新发送消息。 3.标准消息转发：runtime发送methodSignatureForSelector:消息获取Selector对应的方法签名。返回值非空则通过forwardInvocation:转发消息，返回值为空则向当前对象发送doesNotRecognizeSelector:消息，程序崩溃退出 动态特性：动态类型：程序直到执行时才能确定所属的类。 动态绑定：程序直到执行时才能确定实际要调用的方法。 动态加载：根据需求加载所需要的资源 总结就是： 在一个函数找不到时，OC提供了三种方式去补救： 1、调用resolveInstanceMethod给个机会让类添加这个实现这个函数 2、调用forwardingTargetForSelector让别的对象去执行这个函数 3、调用forwardInvocation（函数执行器）灵活的将目标函数以其他形式执行。 如果都不中，调用doesNotRecognizeSelector抛出异常。 事件处理###应用如何找到最合适的控件来处理事件？ 1.首先判断主窗口（keyWindow）自己是否能接受触摸事件 2.判断触摸点是否在自己身上 3.子控件数组中从后往前遍历子控件，重复前面的两个步骤（所谓从后往前遍历子控件，就是首先查找子控件数组中最后一个元素，然后执行1、2步骤） 4.view，比如叫做fitView，那么会把这个事件交给这个fitView，再遍历这个fitView的子控件，直至没有更合适的view为止。 5.如果没有符合条件的子控件，那么就认为自己最合适处理这个事件，也就是自己是最合适的view 事件的传递和响应的区别：+ 事件的传递是从上到下（父控件到子控件），事件的响应是从下到上（顺着响应者链条向上传递：子控件到父控件。 响应者链的事件传递过程:1&gt;如果当前view是控制器的view，那么控制器就是上一个响应者，事件就传递给控制器；如果当前view不是控制器的view，那么父视图就是当前view的上一个响应者，事件就传递给它的父视图 2&gt;在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理 3&gt;如果window对象也不处理，则其将事件或消息传递给UIApplication对象 4&gt;如果UIApplication也不能处理该事件或消息，则将其丢弃 事件处理的整个流程总结： 1.触摸屏幕产生触摸事件后，触摸事件会被添加到由UIApplication管理的事件队列中（即，首先接收到事件的是UIApplication）。 2.UIApplication会从事件队列中取出最前面的事件，把事件传递给应用程序的主窗口（keyWindow）。 3.主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件。（至此，第一步已完成) 4.最合适的view会调用自己的touches方法处理事件 5.touches默认做法是把事件顺着响应者链条向上抛。 view-&gt;控制器/父视图-&gt;window-&gt;UIApplication-&gt;丢弃时间传递：事件添加到UIApplication队列-&gt;取出传递给窗口-&gt;窗口中查找最合适的View（主窗是否接受触摸-&gt;触摸点是否在自己身上-&gt;重复上面步骤在子控件中-&gt;没有就自己处理）-&gt;调用自己的touches处理事件 NSObiect-&gt;UIResponser-&gt;UIView（VC）/UIApp-&gt;UIControl-&gt;UIButton。。 Block：Block介绍：栈地址和对地址值的拷贝，其实里面存储了指向函数体中包含定义block时的代码块的函数指针，以及block外部上下文变量等信息的结构体+ Block是“带有自动变量值的匿名函数” + 对于一般的block来说，它的数据就是传入的参数和在定义这个block时截获的变量。而它的算法，就是我们往里面写的那些方法、函数调用等。 + 被编译为C语言里的普通的struct结构体来实现的 + 一共是四个结构体，显然一个block对象被编译为了一个__main_block_impl_0类型的结构体。这个结构体由两个成员结构体和一个构造函数组成。两个结构体分别是__block_impl和__main_block_desc_0类型的 + 当block需要截获自动变量的时候，首先会在__main_block_impl_0结构体中增加一个成员变量并且在结构体的构造函数中对变量赋值 +在block被执行的时候，把__main_block_impl_0结构体，也就是block对象作为参数传入__main_block_func_0结构体中，取出其中的val的值，进行接下来的操作。 1. 为什么block中不能修改普通变量的值？int val = __cself-&gt;val; 当然这并没有什么影响，甚至还有好处，因为int val变量定义在栈上，在block调用时其实已经被销毁，但是我们还可以正常访问这个变量。但是试想一下，如果我希望在block中修改变量的值，那么受到影响的是int val而非__cself-&gt;val，事实上即使是__cself-&gt;val，也只是截获的自动变量的副本，要想修改在block定义之外的自动变量，是不可能的事情 由于无法直接获得原变量，技术上无法实现修改，所以编译器直接禁止了。 2.__block的作用就是让变量的值在block中可以修改么？只是把val封装在了一个结构体中而已 __Block_byref_val_0 *val; 由于__main_block_impl_0结构体中现在保存了一个指针变量，所以任何对这个指针的操作，是可以影响到原来的变量的。 进一步，我们考虑截获的自动变量是Objective-C的对象的情况。在开启ARC的情况下，将会强引用这个对象一次。这也保证了原对象不被销毁，但与此同时，也会导致循环引用问题。 需要注意的是，在未开启ARC的情况下，如果变量附有__block修饰符，将不会被retain，因此反而可以避免循环引用的问题。 都可以用来让变量在block中可以修改，但是在非ARC模式下，block修饰符会避免循环引用。注意：block的循环引用并非block修饰符引起，而是由其本身的特性引起的。 __block底层实现__block:传值和传址,Block_byref_a_0对象包装局部变量，block拷贝到堆时__Block_byref_a_0也会被底层拷贝到堆，即使局部变量所在堆被销毁，block依然能对堆中的局部变量进行操作（__forwarding）。 __block:变量变成__block_breaf_val_0结构体，包含实例本身引用__forwarding，通过他访问实例变量val，保证栈复制到堆能正常访问__block，堆block持有堆上__block变量。 当栈block拷贝到堆会将__forwarding的值替换为对上__block变量地址。 当一个__block变量从栈上被复制到堆上时，栈上的那个__Block_byref_i_0结构体中的__forwarding指针也会指向堆上的结构。 __Block_byref_i_0结构体，main函数释放的时候，只是释放了栈上的东西。而所有的对局部变量的修改都已经转移到堆上了。 两个成员：__isa（对象），__forwarding（指向自己活另一个bref结构） KVO，KVCKVC：字符串非访问器访问对象实例变量。isa-swizzling就是类型混合指针机制。方法名-&gt;环境参数-&gt;结合isa找到接口-&gt;再找到实现 KCO：对象属性被修改会通知当前对象。运行期动态创建派生类，重写setter方法（isa指向他） GCDGCD：基于核心XNU内核实现，放在libdispatch库中，queue：管理block操作。source：处理事件（通讯） CGD纯C，NSO基于GCD封装。GCD只支持FIFO，NSO可调整顺序，设置并发数。GCD设置依赖代码复杂，NSO简单设置依赖。NSO支持KVO监听状态。GCD速度要快。 JSPatch：Runtime，使用JS利用OC的动态特性，执行我们想要执行的代码。 Rac：native-js bridge，以 JavaScript 的形式告诉 Objective-C 该执行什么代码。 RuntimeRuntime内存布局对象isa指向真实类型，Class的isa指向metaclass，metaclass的isa指向最上层metaclass（NSObject），最上层指向自己。实例方法-&gt;对象的methodList，类方法-&gt;metaclass的methodList isa：维护分发表的对象的类 SEL：是方法选择器（selector）的类型，根据方法名字生成唯一ID，字符串。 Method：是方法（method）的类型 IMP：函数指针，指向方法的实现（首地址），可跳过消息机制。 MethodMethod=SEL+IMP+method_type。SEL与IMP直线的映射（Dispatch Table：将方法的名字（SEL）跟方法的实现（IMP，指向 C 函数的指针）一一对应。Swizzle 一个方法其实就是在程序运行时在 Dispatch Table 里做点改动，让这个方法的名字（SEL）对应到另个 IMP）。 成员变量与属性的区别成员变量地址可根据实例的内存地址偏移寻址。而属性的读写都需要函数调用，相对更慢。 对于复杂的C++类型，往往设为成员变量更合适，也许这种类型不支持copy，或者完全复制很麻烦。 多线程环境下，为保证数据一致性，在需要同步执行的代码段更应该使用成员变量。如果对需要同步更新的数据用getter/setter 方法，数据更新效率低，会带来更多的获取锁请求失败。 成员变量可以做直观的内存管理。属性可以一层层继承，还可以复写。容易出错。 默认用属性，会生成不必要的getter/setter 方法，程序体积会变大。 权限1.如果只是单纯的private变量，最好声明在implementation里.2.如果是类的public属性，就用property写在.h文件里3.如果自己内部需要setter和getter来实现一些东西，就在.m文件的类目里用property来声明 使用关联对象方法混淆NSCoding(归档和解档, 利用runtime遍历模型对象的所有属性)字典 –&gt; 模型 (利用runtime遍历模型对象的所有属性, 根据属性名从字典中取出对应的值, 设置到模型的属性上)KVO(利用runtime动态产生一个类)用于封装框架(想怎么改就怎么改) 这就是我们runtime机制的只要运用方向 RunLoop（至少一个事件源）简介事件接收和分发机制的一个实现，一种异步执行代码的机制，不能并行执行任务。作用是： 保证程序执行的线程不会被系统终止。 两种源事件:input sources和timer sources。input sources 传递异步事件，通常是来自其他线程和不同的程序中的消息； timer sources(定时器) 传递同步事件（重复执行或者在特定时间上触发）。 原理1&gt;当有时间发生时,Runloop会根据具体的事件类型通知应用程序作出相应; 2&gt;当没有事件发生时,Runloop会进入休眠状态,从而达到省电的目的; 3&gt;当事件再次发生时,Runloop会被重新唤醒,处理事件. 提示:一般在开发中很少会主动创建Runloop,而通常会把事件添加到Runloop中. iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread。过去苹果有份文档标明了 NSThread 只是 pthread_t 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 mach thread RunLoop 的销毁是发生在线程结束时一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。 实现unLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。 应用：AutoreleasePool，事件响应，手势识别，界面更新，定时器，PerformSelecter，关于GCD，关于网络请求，AFNetworking，AsyncDisplayKit 多线程多线程介绍与底层实现线程：1个进程要想执行任务，必须得有线程.线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行 底层：Mach是第一个以多线程方式处理任务的系统，因此多线程的底层实现机制是基于Mach的线程。 锁synchronized：互斥锁，@synchronized(obj)指令使用的obj为该锁的唯一标识，只有当标识相同时，才为满足互斥 dispatch_semaphore是GCD用来同步的一种方式 NSLock:Cocoa提供最基本的锁对象 NSRecursiveLock:递归锁，这个锁可以被同一线程多次请求，而不会引起死锁 NSCondition:条件锁(NSConditionLock)。手动控制线程wait和signal pthread_mutex/pthread_mutex(recursive) OSSpinLock：自旋锁，性能最高（do while 忙等） OSSpinLock和dispatch_semaphore的效率远远高于其他。@synchronized和NSConditionLock效率较差。鉴于OSSpinLock的不安全，所以我们在开发中如果考虑性能的话，建议使用dispatch_semaphore。如果不考虑性能，只是图个方便的话，那就使用@synchronized。 测试：黑盒：在软件的接口处进行，不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格 测试：对软件的过程性细节做细致的检查利用程序内部的逻辑结构及有关信息，对程序所有逻辑路径进行测试 测试：介于白黑盒之间，灰盒测试关注输出对于输入的正确性，同时也关注内部表现。 内存相关字段weak与strong：强&amp;弱引用，是否负责销毁（循环引用问题），strong让编译器帮我插入retain，weak相当于assign，对象不再有strong指向会释放，weak就会清除环迅，置nil（weak）。分别对应MRC的retain，assign，避免循环引用使用weak assign与weak：assign指针赋值，不操作引用计数，没有置nil，有野指针。delloc操作使用assign，weak已经找不到了（多了一步nil）。 strong与retain：属性时一样，block时strong=copy，retain==assign。保持与强的区别。不可变对象copy=retain copy与retain：copy（深：内容拷贝），建立相同对象（拷贝），retain（浅：指针拷贝） __weak,__strong:前者打破环（打破环），后者局部变量，栈中（block结束后回收）===不会循环引用 weakify(),strongify():局部strong引用计数+1，pop时不会dealloc，strong持有对象，block结束。局部回收。 autorreleaseautorrelease：建立pool，生成对象，调用autorrelease（标记，提醒后面release），结束pool需要release，每个对象release一次（不能大于1） autorrelease：延迟调用，对象放到当前autorrelease pool中，pool释放时，所持有所有对象release autorrelease：避免频繁申请/释放内存，每个函数自己负责（谁拥有谁释放），不需关系内部管理，使用线程自动维护，主循环结束前释放。 autorrelease：栈中（进出），对象释放，从池中删除自己，池中CCMutableArray（存储结构）。不是根据作用域来决定释放时机是依据runloop，本次runloop迭代结束时清理掉被本次迭代期间被放到autorelease pool中的对象的，发送- autorelease消息，就是将这个对象加入到当前AutoreleasePoolPage的栈顶next指针指向的位置 nonatomicnonatomic:非原子性访问,不加同步,多线程并发访问会提高性能. 网络请求状态码：三个十进制，第一个定义类型，后面才是详细（100信息，200成功，300重定向，400客户端错误如找不到，500服务器错误） 三次握手：客户端发送信号包到服务器，进入send状态，等待确认。服务器收到信号包，确认并发送信号（+确认信号）包给客户端，进入recv状态。客户端收到服务器信号包，发送信号（确认包）给服务器。完成，开始传输数据。 冲突：避免同一文件修改（使用桥接），选择性提交（实时），避免查看Xib，记住备份。project.文件，Nib删除多余，或者重新拉取。 协议相关IP：网络层 TCP（传输控制）：传输层，链接，可靠安全，慢，数据大。传输的是字节流 UDP（用户数据包，广播式）：传输层，不连接（单向），不可靠，快，数据小 HTTP（基于TCP，超文本传输）：应用层，数据如何包装。http协议和基于http协议的Soap协议。传输的是数据包 TCP/IP（传输控制协议/网际协议，一系列）:传输层，数据如何传输 Socket（套接字，网络协议的传输层）：TCP/IP网络的API（包装），不是协议，是接口，通过他才能使用TCP/IP Http&amp;SocketHttp（）：短连接，相应后断开。应用级接口方便，要求不高。但是传输慢，数据大，实时服务器压力大，安全差。 Socket（快，安全，实时）：长连接，不会主动断开（心跳包）。传输字节，可定义，量小，时间段，性能高，适合实时交互，可加密，安全强。但是需要解析传输数据，开发要求高，增加开发量。 XMPP（即时通讯的传输协议）：基于XML的协议，使用TCP传输XML，使用Socket开发，基于TCP/IP协议，核心类XMPPStream，对象GCDAsynSocket封装C中输入流，输出流，基于模块开发。有网关，服务器，客户端。 ReactiveCocoa：函数响应式编程（FRP）框架。以后使用RAC解决问题，就不需要考虑调用顺序，直接考虑结果，把每一次操作都写成一系列嵌套的方法中，使代码高聚合，方便管理。 JSON&amp;XMLJSON（SAX，时间模型：触摸和回调）：轻量级交换，逐行解析（遍历字符，根据规则{}[];）-&gt;编，解，体，交，传。 XML（DOM，树型结构）：可拓展标记，整个文档（父子遍历） 加密：网络（url编码，加密/加盐，post/网络传输,二次验证），本地（H5，js，plist/sqlite/defaults数据,keychain）,代码（方法体/结构/逻辑混淆） 可逆=对称（加密和解密使用同一个算法）：DES,AES。非对称：RSA，DSA。不可逆（消息摘要）：MD5，SHA。电子签名：确认消费发送方身份。 程序启动：main-&gt;UIApplication-&gt;代理-&gt;主循环，监听事件-&gt;调用didFinishLaunching创建Window-&gt;设置根控制-&gt;info.plist中storyboard有就设置根控制器-&gt;初始化自对应的子View显示-&gt;plist文件storyBoard没有就didFinishLaunching设置根控制器didFinishLaunching-&gt;初始化自对应的子View显示 页面执行顺序（View）==加载：alloc-&gt;initXX-&gt;loadView-&gt;viewDidLoad-&gt;viewWillApp-&gt;viewDidiApp-&gt;viewWillLayoutSubviews-&gt;viewDidLayoutSubviews==卸载：viewWillDis-&gt;viewDidDis-&gt;viewDidUnload-&gt;didReceiveMemoryWarning-&gt;dealloc TableView执行顺序：numOfSec-&gt;heightForHeader-&gt;heaghtForFooter-&gt;numOfRow-&gt;heightForHeader-&gt;heaghtForFooter-&gt;numOfRow-&gt;heightForRow-&gt;cellForRow-&gt;WillDisPlayCell tagged Pointer64（13年9-5s-A7）位tagged Pointer（标识+数据）：对象中内存对齐，地址是指针的整数倍（16的倍数），64位的整数，为了对齐，一些为永远为0，tagged Pointer利用这个特性，使得非零位有了特殊含义，64位中，如果对象指针最低有效位为1（奇数），则为tagged Pointer：不是通过isa找类，通过接下来三位的类表索引找对应的类。剩下60位供使用（NSNumber，NSString） load&amp;initilizeload：首次加载（一次），main之前 initilize：首次初始化（一次），init之前，更适合写代码（懒加载） 分类：将category和主（元）类注册到哈希表，如果主（元）类已经实现，重建方法列表。实例方法和属性-&gt;主类，类方法-&gt;元类。分类中协议-&gt;主类/元类 求交集：排序、索引（空间换时间），压缩（减小范围） coreData与多线程（每个线程一个context）：manager context私有，persistent store coordinator私有或者共享。 UIView&amp;CaLayerUIView：UIKit（iOS），集成UIReaponder，多了一个事件处理功能，对CALayer高层封装，需要CALayer支持， CALayer：QuartzCore（OS+iOS），集成NSObject，动画需要加到这里。UIView依靠他才能显示 音视频编解码H264（mov）:编码层视频压缩格式(协议层rtmp与http)，视频编码层(VCL)与网络提取层（NAL）VideoToolbox（AVKit和AVFoudation，Core Me/Vi）ios8-C ACC（wav）:基于MPEG-2的音频编码技术（取代mp3），ADIF（音频数据交换格式）和ADTS（音频数据传输流） M3U8：描述多媒体文件地址的纯文本文件 合并H264+ACC=MP4：FFmpeg推流(LFLiveKit)，使用拉流ijkPlayer，视频和音频数据使用FFmpeg封装为MPEG-TS包和MP4文件。 FLV封装格式是由一个FLV Header文件头和一个一个的Tag组成的。Tag中包含了音频数据以及视频数据 ios10+xcode8:打印，证书管理，各种权限，字体变大，Nib警告，openUrl废弃，插件，导航栏适配，Nib兼容，推送。 图片缓存图片：下载-&gt;处理-&gt;写磁盘-&gt;读到缓冲区-&gt;赋值到用户空间-&gt;解压为位图-&gt;字节对齐-&gt;渲染解压 异步下载，子线程解压，使用缓存（内存/磁盘），存储，减少内存级拷贝与字节对齐，预下载 NSCache：自动删除，减少内存，线程安全，不会被赋值（NSM） 数字签名：指定信息使用哈希算法，得到固定长度的信息摘要，使用私钥对该摘要加密，就得到了数字签名（代码签名） 优化：cell的重用，减少cell中控件的数量，少使用addView ，按需加载cell，缓存行高（属性及内容），使用局部更新（避免cell的重新布局），不要使用ClearColor，加载网络数据，下载图片，使用异步加载，并缓存，不要实现无用的代理方法，避免渐变，图像缩放以及离屏绘制，使用shadowPath来设置阴影，适当的数据结构来保存，恒定高度非delegate，不要使用富文本（缓存），，，， 刷新 layoutSubviews layoutIfNeeded setNeedsLayout setNeedsDisplay drawRect sizeThatFits sizeToFit 大概常用的上面几个 ， 具体的应该还有别的。 layoutSubviews这个方法，默认没有做任何事情，需要子类进行重写 。 系统在很多时候会去调用这个方法： 1.初始化不会触发layoutSubviews，但是如果设置了不为CGRectZero的frame的时候就会触发。 2.addSubview会触发layoutSubviews 3.设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化 4.滚动一个UIScrollView会触发layoutSubviews 5.旋转Screen会触发父UIView上的layoutSubviews事件 6.改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件 在苹果的官方文档中强调: You should override this method only if the autoresizing behaviors of the subviews do not offer the behavior you want.layoutSubviews, 当我们在某个类的内部调整子视图位置时，需要调用。反过来的意思就是说：如果你想要在外部设置subviews的位置，就不要重写。 setNeedsLayout标记为需要重新布局，不立即刷新，但layoutSubviews一定会被调用 配合layoutIfNeeded立即更新 layoutIfNeeded如果，有需要刷新的标记，立即调用layoutSubviews进行布局 所以上面不管写多少约束的改变，只需要在动画里动用 一次self.view.layoutIfNeeded() ,所有的都会已动画的方式 。如果一些变化不想动画 。在动画前执行self.view.layoutIfNeeded() drawRect这个方法是用来重绘的。 drawRect在以下情况下会被调用： 1、如果在UIView初始化时没有设置rect大小，将直接导致drawRect不被自动调用。drawRect调用是在Controller-&gt;loadView, Controller-&gt;viewDidLoad 两方法之后掉用的.所以不用担心在控制器中,这些View的drawRect就开始画了.这样可以在控制器中设置一些值给View(如果这些View draw的时候需要用到某些变量值). 2、该方法在调用sizeToFit后被调用，所以可以先调用sizeToFit计算出size。然后系统自动调用drawRect:方法。3、通过设置contentMode属性值为UIViewContentModeRedraw。那么将在每次设置或更改frame的时候自动调用drawRect:。4、直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:，但是有个前提条件是rect不能为0。以上1,2推荐；而3,4不提倡 drawRect方法使用注意点：1、若使用UIView绘图，只能在drawRect：方法中获取相应的contextRef并绘图。如果在其他方法中获取将获取到一个invalidate的ref并且不能用于画图。drawRect：方法不能手动显示调用，必须通过调用setNeedsDisplay 或者 setNeedsDisplayInRect，让系统自动调该方法。 2、若使用calayer绘图，只能在drawInContext: 中（类似于drawRect）绘制，或者在delegate中的相应方法绘制。同样也是调用setNeedDisplay等间接调用以上方法3、若要实时画图，不能使用gestureRecognizer，只能使用touchbegan等方法来掉用setNeedsDisplay实时刷新屏幕 sizeToFitsizeToFit会自动调用sizeThatFits方法； sizeToFit不应该在子类中被重写，应该重写sizeThatFits sizeThatFits传入的参数是receiver当前的size，返回一个适合的size sizeToFit可以被手动直接调用sizeToFit和sizeThatFits方法都没有递归，对subviews也不负责，只负责自己 内存 Leaked memory: Abandoned memory: Cached memory: Leaked memory 和 Abandoned memory 都属于应该释放而没释放的内存，都是内存泄露，而 Leaks 工具只负责检测 Leaked memory，而不管 Abandoned memory。在 MRC 时代 Leaked memory 很常见，因为很容易忘了调用 release，但在 ARC 时代更常见的内存泄露是循环引用导致的 Abandoned memory，Leaks 工具查不出这类内存泄露，应用有限。 对于 Abandoned memory，可以用 Instrument 的 Allocations 检测出来。检测方法是用 Mark Generation 的方式，当你每次点击 Mark Generation 时，Allocations 会生成当前 App 的内存快照，而且 Allocations 会记录从上回内存快照到这次内存快照这个时间段内，新分配的内存信息 在 GitHub 上有一些内存泄露检测相关的项目，例如 HeapInspector-for-iOS 和 MSLeakHunter。 HeapInspector-for-iOS 可以说是 Allocations 的改进。它通过 hook 掉 alloc，dealloc，retain，release 等方法，来记录对象的生命周期。具体的检测内存泄露的方法和原理，与 Instrument 的 Allocations 一致。然而它跟 Allocations 一样，存在的问题是，你需要一个个场景去重复的操作，还有检测不及时。 MSLeakHunter 就简单得多，它只检测 UIViewController 和 UIView，通过 hook 掉 UIViewController 的 -viewDidDisappear: 方法，并认为 -viewDidDisappear: 后，UIViewController 将很快被释放，如果 UIViewController 没有被释放，则打个建议日志。这种做法其实不是很好，-viewDidDisappear: 被调用可能是因为又 push 进来一个新的 ViewController，把当前的 ViewController 挡住了，所以可能有很多错误的建议，需要结合你实际的操作去具体地分析日志。 MLeaksFinder 提供了内存泄露检测更好的解决方案。只需要引入 MLeaksFinder，就可以自动在 App 运行过程检测到内存泄露的对象并立即提醒，无需打开额外的工具，也无需为了检测内存泄露而一个个场景去重复地操作。MLeaksFinder 目前能自动检测 UIViewController 和 UIView 对象的内存泄露，而且也可以扩展以检测其它类型的对象 原理MLeaksFinder 一开始从 UIViewController 入手。我们知道，当一个 UIViewController 被 pop 或 dismiss 后，该 UIViewController 包括它的 view，view 的 subviews 等等将很快被释放（除非你把它设计成单例，或者持有它的强引用，但一般很少这样做）。于是，我们只需在一个 ViewController 被 pop 或 dismiss 一小段时间后，看看该 UIViewController，它的 view，view 的 subviews 等等是否还存在。 具体的方法是，为基类 NSObject 添加一个方法 -willDealloc 方法，该方法的作用是，先用一个弱指针指向 self，并在一小段时间(3秒)后，通过这个弱指针调用 -assertNotDealloc，而 -assertNotDealloc 主要作用是直接中断言。 这样，当我们认为某个对象应该要被释放了，在释放前调用这个方法，如果3秒后它被释放成功，weakSelf 就指向 nil，不会调用到 -assertNotDealloc 方法，也就不会中断言，如果它没被释放（泄露了），-assertNotDealloc 就会被调用中断言。这样，当一个 UIViewController 被 pop 或 dismiss 时（我们认为它应该要被释放了），我们遍历该 UIViewController 上的所有 view，依次调 -willDealloc，若3秒后没被释放，就会中断言。 设计模式简单工厂，工厂方法，抽象方法都不需要知道具体类，把容易发生改变的地方封装起来，控制变化（哪里变化封装哪里），以适应客户端变动，项目拓展。 简单工厂：一个工厂的各种产品，创建一个类中，客户端无需知道具体产品名称，只要知道对应的参数，但是工厂的责任太重，且类过多时不利于维护与拓展。 一般对各种不同产品的构造函数的封装，需要一个标志产品参数以生产不同的产品。 工厂方法：在简单工厂下增加一个产品就要修改工厂类，不符合开闭，工厂方法下只需要增加具体工厂和产品就可以。 有一个工厂的抽象类，实现不同的具体工厂，每个子类工厂生产不同的产品 抽象工厂：类似一个产品族，一个产品的界面可以通过直接改变具体的工厂实例来改变风格。 类似工厂方法，但是每个子类工厂生产一个产品族，而不是一个产品。 特点简单工厂模式：专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。它又称为静态工厂方法模式。它的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。在这个模式中，工厂类是整个模式的关键所在。它包含必要的判断逻辑，能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。用户在使用时可以直接根据工厂类去创建所需的实例，而无需了解这些对象是如何创建以及如何组织的。有利于整个软件体系结构的优化。 工厂方法模式：工厂方法是粒度很小的设计模式，因为模式的表现只是一个抽象的方法。提前定义用于创建对象的接口，让子类决定实例化具体的某一个类，即在工厂和产品中间增加接口，工厂不再负责产品的创建，由接口针对不同条件返回具体的类实例，由具体类实例去实现。工厂方法模式是简单工厂模式的衍生，解决了许多简单工厂模式的问题。首先完全实现‘开－闭 原则’，实现了可扩展。其次实现更复杂的层次结构，可以应用于产品结果复杂的场合。工厂方法模式是对简单工厂模式进行了抽象。有一个抽象的Factory类（可以是抽象类和接口），这个类将不在负责具体的产品生产，而是只制定一些规范，具体的生产工作由其子类去完成。在这个模式中，工厂类和产品类往往可以依次对应。即一个抽象工厂对应一个抽象产品，一个具体工厂对应一个具体产品，这个具体的工厂就负责生产对应的产品。 抽象工厂模式：抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。它有多个抽象产品类，每个抽象产品类可以派生出多个具体产品类，一个抽象工厂类，可以派生出多个具体工厂类，每个具体工厂类可以创建多个具体产品类的实例。每一个模式都是针对一定问题的解决方案，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式针对的是多个产品等级结果。 优点简单工厂模式：工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅&quot;消费&quot;产品。简单工厂模式通过这种做法实现了对责任的分割。简单工厂模式能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。通过它，外界可以从直接创建具体产品对象的尴尬局面中摆脱出来。外界与具体类隔离开来，偶合性低。明确区分了各自的职责和权力，有利于整个软件体系结构的优化。 工厂方法模式：工厂方法模式是为了克服简单工厂模式的缺点（主要是为了满足OCP）而设计出来的。简单工厂模式的工厂类随着产品类的增加需要增加很多方法（或代码），而工厂方法模式每个具体工厂类只完成单一任务，代码简洁。工厂方法模式完全满足OCP，即它有非常良好的扩展性。 抽象工厂模式：抽象工厂模式主要在于应对“新系列”的需求变化。分离了具体的类，抽象工厂模式帮助你控制一个应用创建的对象的类，因为一个工厂封装创建产品对象的责任和过程。它将客户和类的实现分离，客户通过他们的抽象接口操纵实例，产品的类名也在具体工厂的实现中被分离，它们不出现在客户代码中。它使得易于交换产品系列。一个具体工厂类在一个应用中仅出现一次——即在它初始化的时候。这使得改变一个应用的具体工厂变得很容易。它只需改变具体的工厂即可使用不同的产品配置，这是因为一个抽象工厂创建了一个完整的产品系列，所以整个产品系列会立刻改变。它有利于产品的一致性。当一个系列的产品对象被设计成一起工作时，一个应用一次只能使用同一个系列中的对象，这一点很重要，而抽象工厂很容易实现这一点。抽象工厂模式有助于这样的团队的分工，降低了模块间的耦合性，提高了团队开发效率。 缺点简单工厂模式：当产品有复杂的多层等级结构时，工厂类只有自己，以不变应万变，就是模式的缺点。因为工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，有可能造成工厂逻辑过于复杂,违背了&quot;开放--封闭&quot;原则(OCP).另外，简单工厂模式通常使用静态工厂方法，这使得无法由子类继承，造成工厂角色无法形成基于继承的等级结构。 工厂方法模式：不易于维护，假如某个具体产品类需要进行一定的修改，很可能需要修改对应的工厂类。当同时需要修改多个产品类的时候，对工厂类的修改会变得相当麻烦（对号入座已经是个问题了）。 抽象工厂模式：抽象工厂模式在于难于应付“新对象”的需求变动。难以支持新种类的产品。难以扩展抽象工厂以生产新种类的产品。这是因为抽象工厂几乎确定了可以被创建的产品集合，支持新种类的产品就需要扩展该工厂接口，这将涉及抽象工厂类及其所有子类的改变。 适用范围简单工厂模式：工厂类负责创建的对象比较少，客户只知道传入了工厂类的参数，对于始何创建对象（逻辑）不关心。 工厂方法模式：当一个类不知道它所必须创建对象的类或一个类希望由子类来指定它所创建的对象时，当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候，可以使用工厂方法。 抽象工厂模式：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有形态的工厂模式都是重要的。这个系统有多于一个的产品族，而系统只消费其中某一产品族。同属于同一个产品族的产品是在一起使用的，这一约束必须在系统的设计中体现出来。系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。 测试白盒测试和黑盒测试是软件测试的两种不同方法，任何工程产品(注意是任何工程产品)都可以使用二者之一进行测试： 白盒测试：是通过程序的源代码进行测试而不使用用户界面。这种类型的测试需要从代码句法发现内部代码在算法，溢出，路径，条件等等中的缺点或者错误，进而加以修正。 黑盒测试：是通过使用整个软件或某种软件功能来严格地测试, 而并没有通过检查程序的源代码或者很清楚地了解该软件的源代码程序具体是怎样设计的。测试人员通过输入他们的数据然后看输出的结果从而了解软件怎样工作。在测试时，把程序看作一个不能打开的黑盆子，在完全不考虑程序内部结构和内部特性的情况下，测试者在程序接口进行测试，它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收和正确的输出。 二者最大的区别应该就是测试对象不一样，白盒测试主要针对的是程序代码逻辑，黑盒测试主要针对的是程序所展现给用户的功能，简单的说就是前者测试后台程序后者测试前台展示功能。 什么是黑盒测试和白盒测试？任何工程产品（注意是任何工程产品）都可以使用以下两种方法之一进行测试。 黑盒测试：已知产品的功能设计规格，可以进行测试证明每个实现了的功能是否符合要求。 白盒测试：已知产品的内部工作过程，可以通过测试证明每种内部操作是否符合设计规格要求，所有内部成分是否以经过检查。 黑盒测试软件的黑盒测试意味着测试要在软件的接口处进行。这种方法是把测试对象看做一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。因此黑盒测试又叫功能测试或数据驱动测试。 黑盒测试主要是为了发现以下几类错误：1、是否有不正确或遗漏的功能？ 2、在接口上，输入是否能正确的接受？能否输出正确的结果？ 3、是否有数据结构错误或外部信息（例如数据文件）访问错误？ 4、性能上是否能够满足要求？ 5、是否有初始化或终止性错误？ 白盒测试软件的白盒测试是对软件的过程性细节做细致的检查。这种方法是把测试对象看做一个打开的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。通过在不同点检查程序状态，确定实际状态是否与预期的状态一致。因此白盒测试又称为结构测试或逻辑驱动测试。 白盒测试主要是想对程序模块进行如下检查：1、对程序模块的所有独立的执行路径至少测试一遍。 2、对所有的逻辑判定，取“真”与取“假”的两种情况都能至少测一遍。 3、在循环的边界和运行的界限内执行循环体。 4、测试内部数据结构的有效性，等等。 以上事实说明，软件测试有一个致命的缺陷，即测试的不完全、不彻底性。由于任何程序只能进行少量（相对于穷举的巨大数量而言）的有限的测试，在未发现错误时，不能说明程序中没有错误。 灰盒测试灰盒测试，是介于白盒测试与黑盒测试之间的，可以这样理解，灰盒测试关注输出对于输入的正确性，同时也关注内部表现，但这种关注不象白盒那样详细、完整，只是通过一些表征性的现象、事件、标志来判断内部的运行状态，有时候输出是正确的，但内部其实已经错误了，这种情况非常多，如果每次都通过白盒测试来操作，效率会很低，因此需要采取这样的一种灰盒的方法。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>面试被虐总结一</tag>
        <tag>面试一</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生命之源-RunLoop]]></title>
    <url>%2F2017%2F03%2F10%2F%E7%94%9F%E5%91%BD%E4%B9%8B%E6%BA%90-RunLoop%2F</url>
    <content type="text"><![CDATA[iOS一切的生命之源都需要RunLoop的支持，关于RunLoop的界面和相关知识，网上想你一一搜一天也看不完，所以这里只为总结Runloop相关技术，适用于底层，面试，简单实战了解！ 前言：1+ 一个线程只能执行一个任务，任务执行完之后，线程就会退出，但是主线程不会退出，因为我们需要让主线程等待接收事件 介绍123456+ 运行循环（do-while）：不断处理各种事件+ 一个线程（唯一）对应一个RunLoop（可以嵌套子runloops），主线程默认启动，子线程手动启动（run）：获取RunLoop对象的时候，就会创建RunLoop+ RunLoop有多个Model，Model有多个timer（array）/source（set）/observer（array）。+ 每次启动只能启动一个，切换需要先推出在指定（分隔不同time/source/observer）+ 当前Model没有任何timer/source/observer就会推出（mode只能添加不能删除）+ 第一次获取创建，线程结束销毁 runloop退出的条件：1app退出；线程关闭；设置最大时间到期；modeItem为空； Ref12345+ CFRunLoopTimerRef，基于时间触发（NSTimer），受Model影响，GCD不受Model影响+ CFRunLoopSourceRef，事件源，source0（非Port），source1（Port），跟Port密切联系source0：event事件，只含有回调，需要标记待处理（signal），然后手动将runloop唤醒（wakeup）；source1 ：包含一个 mach_port 和一个回调，被用于通过内核和其他线程发送的消息，能主动唤醒runloop。 Runloop本质：mach port和mach_msg()。123Mach是XNU的内核，进程、线程和虚拟内存等对象通过端口发消息进行通信，Runloop通过mach_msg()函数发送消息，如果没有port 消息，内核会将线程置于等待状态 mach_msg_trap() 。如果有消息，判断消息类型处理事件，并通过modeItem的callback回调(处理事件的具体执行是在DoBlock里还是在回调里目前我还不太明白？？？)。Runloop有两个关键判断点，一个是通过msg决定Runloop是否等待，一个是通过判断退出条件来决定Runloop是否循环 定时源，输入源12+ 定时源，同步消息，特定或者一定时间间隔发生+ 输入源，来自起来线程或者程序 应用1+ NSTimer，ImageView显示，PerformSelector，常驻线程，自动释放池，界面刷新，手势识别，GCD任务，timer：（与CADisplayLink），网络请求： autorrelease释放时机：12+ 手动干预释放：指定autorreleasepool,当前作用域大括号结束立即释放+ 系统自动释放：不指定，aut对象在当前RunLoop迭代结束释放 自动释放池12自动释放池寄生于Runloop：程序启动后，主线程注册了两个Observer监听runloop的进出与睡觉。一个最高优先级OB监测Entry状态；一个最低优先级OB监听BeforeWaiting状态和Exit状态。线程(创建)--&gt;runloop将进入--&gt;最高优先级OB创建释放池--&gt;runloop将睡--&gt;最低优先级OB销毁旧池创建新池--&gt;runloop将退出--&gt;最低优先级OB销毁新池--&gt;线程(销毁) Timer注意121、如果是在主线程中运行timer，想要timer在某界面有视图滚动时，依然能正常运转，那么将timer添加到RunLoop中时，就需要设置mode 为NSRunLoopCommonModes。2、如果是在子线程中运行timer,那么将timer添加到RunLoop中后，Mode设置为NSDefaultRunLoopMode或NSRunLoopCommonModes均可，但是需要保证RunLoop在运行，且其中有任务。 runloop:121、（要让马儿跑）通过do-while死循环让程序持续运行：接收用户输入，调度处理事件时间。2、（要让马儿少吃草）通过mach_msg()让runloop没事时进入trap状态，节省CPU资源。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>生命之源-RunLoop</tag>
        <tag>RunLoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[想怎么转就怎么转]]></title>
    <url>%2F2017%2F03%2F07%2F%E6%83%B3%E6%80%8E%E4%B9%88%E8%BD%AC%E5%B0%B1%E6%80%8E%E4%B9%88%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[最近在做直播，用的是腾讯云，但是主播界面需要横屏显示，而且只能横屏，整个项目也只有这个界面横屏。发现腾讯云在这一块提供了对流的控制，但是并没有提供对界面的控制，需要自己去实现界面的控制，主要是界面各种交互，各种效果，各种逻辑，所以必须自己控制选择，期间也遇到了不少坑。所以就整理了一下，当然这里同样适合iPad适配，相信以后在屏幕旋转和旋转相关适配这一块应该是没有问题了！ 相关枚举：首先需要知道苹果提供的关于屏幕的一些枚举值UIDeviceOrientation：123456789typedef NS_ENUM(NSInteger, UIDeviceOrientation) &#123;UIDeviceOrientationUnknown,UIDeviceOrientationPortrait, // Device oriented vertically, home button on the bottomUIDeviceOrientationPortraitUpsideDown, // Device oriented vertically, home button on the topUIDeviceOrientationLandscapeLeft, // Device oriented horizontally, home button on the rightUIDeviceOrientationLandscapeRight, // Device oriented horizontally, home button on the leftUIDeviceOrientationFaceUp, // Device oriented flat, face upUIDeviceOrientationFaceDown // Device oriented flat, face down&#125;; UIInterfaceOrientation：1234567typedef NS_ENUM(NSInteger, UIInterfaceOrientation) &#123;UIInterfaceOrientationUnknown = UIDeviceOrientationUnknown,UIInterfaceOrientationPortrait = UIDeviceOrientationPortrait,UIInterfaceOrientationPortraitUpsideDown = UIDeviceOrientationPortraitUpsideDown,UIInterfaceOrientationLandscapeLeft = UIDeviceOrientationLandscapeRight,UIInterfaceOrientationLandscapeRight = UIDeviceOrientationLandscapeLeft&#125;; 从宏定义可知，device方向比interface多了两个定义：UIDeviceOrientationFaceUp和UIDeviceOrientationFaceDown，分别表示手机水平放置，屏幕向上和屏幕向下。 两种orientation：然后就是两种相关的orientationdevice orientation设备的物理方向，由类型UIDeviceOrientation表示，当前设备方向获取方式： 12// return current device orientation. this will return UIDeviceOrientationUnknown unless device orientation notifications are being generated.[UIDevice currentDevice].orientation //该属性的值一般是与当前设备方向保持一致的。 注意点1：推荐方式123456if (![UIDevice currentDevice].generatesDeviceOrientationNotifications) &#123;[[UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications];&#125;NSLog(@"%d",[UIDevice currentDevice].orientation);[[UIDevice currentDevice] endGeneratingDeviceOrientationNotifications]; 注意点2：横竖屏关闭12如果关闭了系统的横竖屏切换开关，即系统层级只允许竖屏时，再通过上述方式获取到的设备方向将永远是UIDeviceOrientationUnknown。可以通过Core Motion中的CMMotionManager来获取当前设备方向。 interface orientation界面显示的方向，由类型UIInterfaceOrientation表示。当前界面显示方向有以下两种方式获取： 设备的物理方向，由类型UIDeviceOrientation表示，当前设备方向获取方式： 12NSLog(@"%d",[UIApplication sharedApplication].statusBarOrientation);NSLog(@"%d",viewController.interfaceOrientation); 即可以通过系统statusBar的方向或者viewController的方向来获取当前界面方向。 区别通过UIDevice获取到的设备方向在手机旋转时是实时的。通过UIApplication的statusBar或者viewController获取到的界面方向在下述方法：调用以后才会被更改成最新的值。 12NSLog(@"%d",[UIApplication sharedApplication].statusBarOrientation);NSLog(@"%d",viewController.interfaceOrientation); 相关方法123456789101112// Applications should use supportedInterfaceOrientations and/or shouldAutorotate..- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation NS_DEPRECATED_IOS(2_0, 6_0);// New Autorotation support.- (BOOL)shouldAutorotate NS_AVAILABLE_IOS(6_0);- (NSUInteger)supportedInterfaceOrientations NS_AVAILABLE_IOS(6_0);// Returns interface orientation masks.- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation NS_AVAILABLE_IOS(6_0);// call this method when your return value from shouldAutorotateToInterfaceOrientation: changes// if the current interface orientation does not match the current device orientation, a rotation may occur provided all relevant view controllers now return YES from shouldAutorotateToInterfaceOrientation:+ (void)attemptRotationToDeviceOrientation NS_AVAILABLE_IOS(5_0); 如何旋转全局控制Info.plist文件中，有一个Supported interface orientations，可以配置整个应用的屏幕方向，此处为全局控制。 UIWindowiOS6的UIApplicationDelegate提供了下述方法，能够指定 UIWindow 中的界面的屏幕方向： 1- (NSUInteger)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window NS_AVAILABLE_IOS(6_0); 该方法默认值为Info.plist中配置的Supported interface orientations项的值。 iOS中通常只有一个window，所以此处的控制也可以视为全局控制。 controller只有以下两种情况： 当前controller是window的rootViewController当前controller是modal模式的时候，orientations相关方法才会起作用（才会被调用），当前controller及其所有的childViewController都在此作用范围内。 最终支持的屏幕方向前面所述的3种控制规则的交集就是一个controller的最终支持的方向； 如果最终的交集为空，在iOS6以后会抛出UIApplicationInvalidInterfaceOrientationException崩溃异常。 总结来说改变Orientation有三种途径当手机的重力感应打开的时候, 如果用户旋转手机, 系统会抛发UIDeviceOrientationDidChangeNotification 事件. 您可以分别设置Application和UIViewcontroller支持的旋转方向.Application的设置会影响整个App, UIViewcontroller的设置仅仅会影响一个viewController(IOS5和IOS6有所不同,下面会详细解释). 当UIKit收到UIDeviceOrientationDidChangeNotification事件的时候, 会根据Application和UIViewcontroller的设置, 如果双方都支持此方向, 则会自动屏幕旋转到这个方向. 更code的表达就是, 会对两个设置求与,得到可以支持的方向. 如果求与之后,没有任何可支持的方向, 则会抛发UIApplicationInvalidInterfaceOrientationException异常. 当然，你还可以对View进行旋转，但是这样会有一些需求上的问题，比如状态栏，键盘等就没有办法，只能自己通过其他方式控制！1234567891011121314151617UIView.transform//设置statusBar[[UIApplication sharedApplication] setStatusBarOrientation:orientation];//计算旋转角度float arch;if (orientation == UIInterfaceOrientationLandscapeLeft)arch = -M_PI_2;else if (orientation == UIInterfaceOrientationLandscapeRight)arch = M_PI_2;elsearch = 0;//对navigationController.view 进行强制旋转self.navigationController.view.transform = CGAffineTransformMakeRotation(arch);self.navigationController.view.bounds = UIInterfaceOrientationIsLandscape(orientation) ? CGRectMake(0, 0, SCREEN_HEIGHT, SCREEN_WIDTH) : initialBounds; 当然我们可以对当前viewController进行旋转, 对任何view旋转都可以.但是, 你会发现navigationBar还横在那里. 所以, 我们最好对一个占满全屏的view进行旋转. 在这里我们旋转的对象是self.navigationController.view, 当然self.window也可以, help yourself~我们需要显式的设置bounds. UIKit并不知道你偷偷摸摸干了这些事情, 所以没法帮你自动设置. 具体实现借助通知来控制界面的横竖屏切换。还是整个App中大部分界面都是竖屏，某个界面可以横竖屏切换的情况。首选这只plist只支持竖屏：Portrait（Home朝下） 然后在特殊的视图控制器里的ViewDidLoad中注册通知： 123456789101112131415161718192021222324252627282930313233343536[[UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications];[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(deviceOrientationDidChange) name:UIDeviceOrientationDidChangeNotification object:nil];通知方法的实现过程：- (void)deviceOrientationDidChange&#123;NSLog(@"deviceOrientationDidChange:%ld",(long)[UIDevice currentDevice].orientation);if([UIDevice currentDevice].orientation == UIDeviceOrientationPortrait) &#123;[[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationPortrait];[self orientationChange:NO];//注意： UIDeviceOrientationLandscapeLeft 与 UIInterfaceOrientationLandscapeRight&#125; else if ([UIDevice currentDevice].orientation == UIDeviceOrientationLandscapeLeft) &#123;[[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationLandscapeRight];[self orientationChange:YES];&#125;&#125;- (void)orientationChange:(BOOL)landscapeRight&#123;if (landscapeRight) &#123;[UIView animateWithDuration:0.2f animations:^&#123;self.view.transform = CGAffineTransformMakeRotation(M_PI_2);self.view.bounds = CGRectMake(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);&#125;];&#125; else &#123;[UIView animateWithDuration:0.2f animations:^&#123;self.view.transform = CGAffineTransformMakeRotation(0);self.view.bounds = CGRectMake(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);&#125;];&#125;&#125;// 用到的两个宏：#define SCREEN_WIDTH ([UIScreen mainScreen].bounds.size.width)#define SCREEN_HEIGHT ([UIScreen mainScreen].bounds.size.height) 最重要的一点:需要重写如下方法，并且返回NO。这样，在设备出于横屏时，界面就会变成横屏，设备处于竖屏时，界面就会变成竖屏。 1234- (BOOL)shouldAutorotate&#123;return NO;&#125; 但是这样会遇到两个坑上面方式二，因为【General】–&gt;【Device Orientation】因为只设置了竖屏，所以当横屏时，如果有键盘弹出，键盘是竖屏时的样式。解决办法：在【General】–&gt;【Device Orientation】中加上横屏时的方向。 如果VieController 是放在UINavigationController或者UITabBarController中，需要重写它们的方向控制方法。 123456789101112131415161718192021// UINavigationController：- (BOOL)shouldAutorotate&#123;return [self.topViewController shouldAutorotate];&#125;- (UIInterfaceOrientationMask)supportedInterfaceOrientations&#123;return [self.topViewController supportedInterfaceOrientations];&#125;// UITabBarController:- (BOOL)shouldAutorotate&#123;return [self.selectedViewController shouldAutorotate];&#125;- (UIInterfaceOrientationMask)supportedInterfaceOrientations&#123;return [self.selectedViewController supportedInterfaceOrientations];&#125; 如果想要点击某个按钮之后，强制将竖屏显示的界面变成横屏呢？有人可能会想到这样写: 12345// 横屏- (IBAction)landscapAction:(id)sender &#123;[[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationLandscapeRight];[self orientationChange:YES];&#125; 但是按照上面的写法，会导致返回到之前的界面时，视图方向错误，即使返回前执行如下代码： 12[[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationPortrait];[self orientationChange:NO]; 结果发现也没有作用，下面是在开源工程中无意看到的写法： 12345678910111213141516171819202122// 横屏- (IBAction)landscapAction:(id)sender &#123;[self interfaceOrientation:UIInterfaceOrientationLandscapeRight];&#125;// 竖屏- (IBAction)portraitAction:(id)sender &#123;[self interfaceOrientation:UIInterfaceOrientationPortrait];&#125;- (void)interfaceOrientation:(UIInterfaceOrientation)orientation&#123;if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) &#123;SEL selector = NSSelectorFromString(@"setOrientation:");NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]];[invocation setSelector:selector];[invocation setTarget:[UIDevice currentDevice]];int val = orientation;[invocation setArgument:&amp;val atIndex:2];[invocation invoke];&#125;&#125; 通过属性控制项目需求（场景）： 整个项目不需要旋转（当然了，所有方向的屏幕适配都做好的情况下是没问题的，但是没有必要这么劳民伤财。）的前提下，播放界面控制器需要支持屏幕的其他方向的旋转。 先设置：targets——&gt;general——&gt;device Orientation——&gt;支持的旋转方向在 AppDelegate.m 里面1234567-(UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window &#123;if (self.allowRotation) &#123;//当允许时，支持所有方向return UIInterfaceOrientationMaskAll;&#125;//否则 就只有竖屏return UIInterfaceOrientationMaskPortrait;&#125; 在你想要支持 旋转的控制器 需要导入#import “AppDelegate.h”12345678910111213141516171819- (void)viewWillAppear:(BOOL)animated &#123;[super viewWillAppear:animated];self.navigationController.navigationBarHidden = YES;//改变AppDelegate的appdelegete.allowRotation属性AppDelegate *appdelegete = (AppDelegate *)[UIApplication sharedApplication].delegate;appdelegete.allowRotation = YES;&#125;- (void)viewWillDisappear:(BOOL)animated&#123;[super viewWillDisappear:animated];self.navigationController.navigationBarHidden = NO;AppDelegate *appdelegete = (AppDelegate *)[UIApplication sharedApplication].delegate;appdelegete.allowRotation = NO;&#125; 当你写完这些的时候发现好像可以了，还有问题。但你横屏播放的状态下 直接返回上个控制器（pop）的时候.发现那个控制器也是横屏的（当你竖屏时，它会转过来，但是再旋转就不行了。问题就是pop回来不能使横屏啊，应该直接竖屏才是啊）比如pop回的那个控制器叫 TextViewController在TextViewController.m里 1234//屏幕方向操作-(UIInterfaceOrientationMask)supportedInterfaceOrientations&#123;return UIInterfaceOrientationMaskPortrait;&#125; 此方法是UIKit框架中UIViewController.h的公布方法，iOS 6.0后加入 总结关于屏幕旋转这一块并不难，苹果提供了很多现成的方式，或者说只需要调用方法，当然还是根据具体需求进行调整。适当的控制对应的控件，调用相应的方法，那么不管是iPhone还是iPad你想怎么转就怎么转！]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>想怎么转就怎么转</tag>
        <tag>屏幕旋转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前世-内存管理]]></title>
    <url>%2F2017%2F03%2F03%2F%E5%89%8D%E4%B8%96-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[最近越来越发觉，自己做了这么久iOS开发，似乎都是在瞎玩，回望这一路写的App，写的代码，以及上线的App，又有几个自己真的非常满意的？说道这里，不得不提的是：我相信不止我一个人有这种感触，代码写久了，自己都不知道自己在写撒，就连上线都是个意外。这一路走来我一直在总结，也在回望，到底自己哪里出了问题，终于发现：终究是自己不敢面对而已，底层不了解，只知道敲。 因为换了电脑，换了工作，换了新的环境，也换了一个不一样的心情重新开始探索之路，所以之前的博客地址也停止更新了，如果你对iOS相关知识感兴趣或者有什么疑问和建议可以联系我，或者直接在下面评论， 本来打算这个博客中不会再写iOS的东西，但是最近一直上班，也找了一段时间公司，总之感触不少，现在这个行情，大家都懂的。 前段时间也整理了一些东西，我相信值得一看。 1原则：没有强指针指向对象，对象就会被释放。 MRC-ARC123ARC：LLVM3.0（iOS5，Xcode4）前段编译器：方法内创建对象，末尾自动插入release销毁。类拥有对象，在dealloc内释放。更底层的C语言实现。objc_release,objc_retain优化调用过程ARC优化器：负责移除多余的插入，和一些引用的优化。包括运行期组件。 关于循环12345weak：循环引用，自身强引用，IBOutlet。非拥有，不保留也不释放，置nil，weak必须用于OC对象，assign非OC对象for循环：只有当自动释放器被release，池中的表示autorrelease对象才会被释放===内存耗尽，没有释放-&gt;内存泄露1.i比较大：使用@autorreleasepool&#123;&#125;，在for外面，循环结束，销毁创建对象，解决占据栈内存问题。2.i玩命大：一次循环都会自动释放池满，@autorreleasepool&#123;&#125;放在for里面，每次循环前将上一次对象release。 关于内存12内存布局：没有多继承，所以布局简单最前面isa，指向类。父类实例变量在子类实例变量之前。 关于线程123456789界面线程维护自己的线程池。自己创建的线程数据，需要创建线程的内存池。autorreleasepool实现：objc_autorreleasepool=Push,Pop,objc_autorrelease每次RunLoop完成一个循环的时候，都会检测对象的retainCount，为0则没有使用，释放。内存管理的范围：集成自NSObject对象，基本数据类型无效。因为存储空间不同，基本数据存在栈区。对象在堆中，代码块结束，涉及局部变量弹栈清空，指向对象指针回收，对象没有指针指向，但是还在堆中，所以内存泄露了。unowned（unsafe_unretained）：对象销毁不会为空，但是更快，因为weak需要unwrap。 常见状态管理1234567野指针:指针变量没有初始化，指向的空间被释放。调用方法报异常，崩溃。release后，地址nil，OC中没有空指针异常内存泄露：对象提前赋值nil，导致release不起作用。没有配对释放或者清空。栈区释放了，堆区没有释放。最终导致内存溢出内存溢出：容量超出使用限制僵尸对象：堆中已经被释放的对象count=0空指针：指针赋值为nil判断对象销毁：dealloc（需要super一下），已经释放的对象无法复活 对象关系123集成：组合：（包含关系），确保成员连边不被提前释放，重写set方法，retain一下。成员变量在dealloc中配对释放。内存泄露：1.set没有retain对象，2.没有release旧对象，3.没有判断set方法传入是否是同一对象依赖：（对象作为方法参数传递） autorrelease（pool）/垃圾回收机制1234autorrelease：把该对象放入自动释放池，自动释放池释放时，内部对象引用计数-1。NSAutorreleasePool：通过接受对象向他发送的release消息，记录该对象的release消息，自动释放池销毁时，向池中记录release的对象发送release消息。 垃圾回收机制：autorrelease只是延迟释放，GC是每隔一段时间询问程序，是否有无指针指向的对象，没有就释放 自动释放池123456自动释放池： 1.存储多想对象类型的指针变量（可以嵌套） 2.作用：将对象与自动释放池建议关系，池子内调用autorrelease，在自动释放池销毁时销毁对象，延迟release销毁时间 3.对池内对象作用：存入池中的对象，池销毁，全部对象release一次 4.调用autorrelease将对象加入自动释放池，多次调用导致野指针异常 5.释放时机：简单：autorrelease的&#125;执行完后。实际：Autorrelease对象是在当前RunLoop迭代结束时释放，原因是：系统在每个RunLoop迭代中加入了自动释放池Push，Pop 关键字12345block中多次使用weakSelf（延迟操作，导致取不到弱指针），可以block种先使用strongSelf，防止执行是weakSelf意外释放，对于非ARCweak改为block就可以release和drain：ARC中一样，GC中release无效操作，所以无论是否为GC使用drain没有问题。copy：OC对象类型如果有mutable，深拷贝，新对象为count=1，没有为浅拷贝，count+1. 其他总结1234567891011通过Observer监听RunLoop状态，一旦监听到RunLoop即将进入休眠等状态，就释放自动释放池。FIFO：新访问的数据插入队列尾部，数据在队列中移动，淘汰头部数据。LRU（FIFO相反），LFU循环引用：定时器（timer作为类的成员变量，self-target,不使用记得invalidate），Blcok（block在copy时对内部对象强引用（ARC）或者引用计数+1（MRC）），代理：（assign（MRC），weak（ARC））通知：多对多，主要跨层传值。对象加入到通知中心后，对象被销毁前没有将对象从通知中心移除，当再次发送通知的时候，会崩溃。默认关键字：基本数据类型（atomic，readwrite，assign），OC对象类型（atomic，readwrite，strong）TableView代理用assign：控制器对内部的View进行了一次retain，TableView对代理控制器也retain一次就会循环引用。 其实知道了这个并不证明就能写出好的代码，还需要时间的沉淀，不断的尝试，不断的思考与总结。感谢你能看到最后，希望对你有用，我们下次再见！]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>前世-内存管理</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[温馨提示]]></title>
    <url>%2F2017%2F03%2F01%2F%E6%B8%A9%E9%A6%A8%E6%8F%90%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[嗨，欢迎来到梦工厂，我是曹理鹏 (@iCocos)，一名 iOS(+游戏)/ 前端 开发者，后端开发学习中，希望做点有意义的事情。现居广州，正在修行，探求创意之源。。 12345微信：clpaial10201119 / QQ：2211523682博客(前后端)：https://icocos.github.io/博客(iOS)：http://al1020119.github.io/github：https://github.com/al1020119个人网站：http://www.icocos.cn/ 由于学习，技术方向的原因，本人之前github博客将会停止更新，之前所有文章偏向技术，并且主要针对iOS基础，底层，面试与实战，此后将会停止更新此博客，并将所有新发布文章，更新至当前博客地址，届时会不定时在公众号，和微博发布相关动态。 此博客将会保函以下内容： iOS实战经验(+游戏) 前端开发相关技术 后端开发学习 读书笔记与后感 个人业余爱好 其他原创杂文 如果你想了解更多关于作者，或者关于iOS，前后端，和个人关注内容，请关注我的个人公众号，也可以通过微信，QQ，Github联系我，也可以直接在这里评论留言。 同时，如果对我的文章有一些意见或者建议，也欢迎联系我，我们一起共进退！]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>温馨提示</tag>
        <tag>iCocos</tag>
        <tag>提示</tag>
      </tags>
  </entry>
</search>
